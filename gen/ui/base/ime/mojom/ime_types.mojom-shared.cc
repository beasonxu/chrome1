// ui/base/ime/mojom/ime_types.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/base/ime/mojom/ime_types.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "ui/base/ime/mojom/ime_types.mojom-params-data.h"
namespace ui {
namespace mojom {

static NOINLINE const char* TextInputModeToStringHelper(TextInputMode value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case TextInputMode::kDefault:
      return "kDefault";
    case TextInputMode::kNone:
      return "kNone";
    case TextInputMode::kText:
      return "kText";
    case TextInputMode::kTel:
      return "kTel";
    case TextInputMode::kUrl:
      return "kUrl";
    case TextInputMode::kEmail:
      return "kEmail";
    case TextInputMode::kNumeric:
      return "kNumeric";
    case TextInputMode::kDecimal:
      return "kDecimal";
    case TextInputMode::kSearch:
      return "kSearch";
    default:
      return nullptr;
  }
}

std::string TextInputModeToString(TextInputMode value) {
  const char *str = TextInputModeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown TextInputMode value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, TextInputMode value) {
  return os << TextInputModeToString(value);
}

static NOINLINE const char* TextInputActionToStringHelper(TextInputAction value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case TextInputAction::kDefault:
      return "kDefault";
    case TextInputAction::kEnter:
      return "kEnter";
    case TextInputAction::kDone:
      return "kDone";
    case TextInputAction::kGo:
      return "kGo";
    case TextInputAction::kNext:
      return "kNext";
    case TextInputAction::kPrevious:
      return "kPrevious";
    case TextInputAction::kSearch:
      return "kSearch";
    case TextInputAction::kSend:
      return "kSend";
    default:
      return nullptr;
  }
}

std::string TextInputActionToString(TextInputAction value) {
  const char *str = TextInputActionToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown TextInputAction value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, TextInputAction value) {
  return os << TextInputActionToString(value);
}

static NOINLINE const char* TextInputTypeToStringHelper(TextInputType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case TextInputType::NONE:
      return "NONE";
    case TextInputType::TEXT:
      return "TEXT";
    case TextInputType::PASSWORD:
      return "PASSWORD";
    case TextInputType::SEARCH:
      return "SEARCH";
    case TextInputType::EMAIL:
      return "EMAIL";
    case TextInputType::NUMBER:
      return "NUMBER";
    case TextInputType::TELEPHONE:
      return "TELEPHONE";
    case TextInputType::URL:
      return "URL";
    case TextInputType::DATE:
      return "DATE";
    case TextInputType::DATE_TIME:
      return "DATE_TIME";
    case TextInputType::DATE_TIME_LOCAL:
      return "DATE_TIME_LOCAL";
    case TextInputType::MONTH:
      return "MONTH";
    case TextInputType::TIME:
      return "TIME";
    case TextInputType::WEEK:
      return "WEEK";
    case TextInputType::TEXT_AREA:
      return "TEXT_AREA";
    case TextInputType::CONTENT_EDITABLE:
      return "CONTENT_EDITABLE";
    case TextInputType::DATE_TIME_FIELD:
      return "DATE_TIME_FIELD";
    case TextInputType::TYPE_NULL:
      return "{TYPE_NULL, MAX}";
    default:
      return nullptr;
  }
}

std::string TextInputTypeToString(TextInputType value) {
  const char *str = TextInputTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown TextInputType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, TextInputType value) {
  return os << TextInputTypeToString(value);
}

static NOINLINE const char* ImeTextSpanTypeToStringHelper(ImeTextSpanType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ImeTextSpanType::kComposition:
      return "kComposition";
    case ImeTextSpanType::kSuggestion:
      return "kSuggestion";
    case ImeTextSpanType::kMisspellingSuggestion:
      return "kMisspellingSuggestion";
    case ImeTextSpanType::kAutocorrect:
      return "kAutocorrect";
    case ImeTextSpanType::kGrammarSuggestion:
      return "kGrammarSuggestion";
    default:
      return nullptr;
  }
}

std::string ImeTextSpanTypeToString(ImeTextSpanType value) {
  const char *str = ImeTextSpanTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ImeTextSpanType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ImeTextSpanType value) {
  return os << ImeTextSpanTypeToString(value);
}

static NOINLINE const char* ImeTextSpanThicknessToStringHelper(ImeTextSpanThickness value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ImeTextSpanThickness::kNone:
      return "kNone";
    case ImeTextSpanThickness::kThin:
      return "kThin";
    case ImeTextSpanThickness::kThick:
      return "kThick";
    default:
      return nullptr;
  }
}

std::string ImeTextSpanThicknessToString(ImeTextSpanThickness value) {
  const char *str = ImeTextSpanThicknessToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ImeTextSpanThickness value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ImeTextSpanThickness value) {
  return os << ImeTextSpanThicknessToString(value);
}

static NOINLINE const char* ImeTextSpanUnderlineStyleToStringHelper(ImeTextSpanUnderlineStyle value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ImeTextSpanUnderlineStyle::kNone:
      return "kNone";
    case ImeTextSpanUnderlineStyle::kSolid:
      return "kSolid";
    case ImeTextSpanUnderlineStyle::kDot:
      return "kDot";
    case ImeTextSpanUnderlineStyle::kDash:
      return "kDash";
    case ImeTextSpanUnderlineStyle::kSquiggle:
      return "kSquiggle";
    default:
      return nullptr;
  }
}

std::string ImeTextSpanUnderlineStyleToString(ImeTextSpanUnderlineStyle value) {
  const char *str = ImeTextSpanUnderlineStyleToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ImeTextSpanUnderlineStyle value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ImeTextSpanUnderlineStyle value) {
  return os << ImeTextSpanUnderlineStyleToString(value);
}

namespace internal {


// static
bool ImeTextSpan_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 56, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const ImeTextSpan_Data* object =
      static_cast<const ImeTextSpan_Data*>(data);


  if (!::ui::mojom::internal::ImeTextSpanType_Data
        ::Validate(object->type, validation_context))
    return false;


  if (!::ui::mojom::internal::ImeTextSpanThickness_Data
        ::Validate(object->thickness, validation_context))
    return false;


  if (!::ui::mojom::internal::ImeTextSpanUnderlineStyle_Data
        ::Validate(object->underline_style, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->suggestions, 12, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams suggestions_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  if (!mojo::internal::ValidateContainer(object->suggestions, validation_context,
                                         &suggestions_validate_params)) {
    return false;
  }

  return true;
}

ImeTextSpan_Data::ImeTextSpan_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace ui

namespace perfetto {

// static
void TraceFormatTraits<::ui::mojom::TextInputMode>::WriteIntoTrace(
   perfetto::TracedValue context, ::ui::mojom::TextInputMode value) {
  return std::move(context).WriteString(::ui::mojom::TextInputModeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::ui::mojom::TextInputAction>::WriteIntoTrace(
   perfetto::TracedValue context, ::ui::mojom::TextInputAction value) {
  return std::move(context).WriteString(::ui::mojom::TextInputActionToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::ui::mojom::TextInputType>::WriteIntoTrace(
   perfetto::TracedValue context, ::ui::mojom::TextInputType value) {
  return std::move(context).WriteString(::ui::mojom::TextInputTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::ui::mojom::ImeTextSpanType>::WriteIntoTrace(
   perfetto::TracedValue context, ::ui::mojom::ImeTextSpanType value) {
  return std::move(context).WriteString(::ui::mojom::ImeTextSpanTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::ui::mojom::ImeTextSpanThickness>::WriteIntoTrace(
   perfetto::TracedValue context, ::ui::mojom::ImeTextSpanThickness value) {
  return std::move(context).WriteString(::ui::mojom::ImeTextSpanThicknessToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::ui::mojom::ImeTextSpanUnderlineStyle>::WriteIntoTrace(
   perfetto::TracedValue context, ::ui::mojom::ImeTextSpanUnderlineStyle value) {
  return std::move(context).WriteString(::ui::mojom::ImeTextSpanUnderlineStyleToString(value));
}

} // namespace perfetto