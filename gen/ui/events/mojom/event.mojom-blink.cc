// ui/events/mojom/event.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "ui/events/mojom/event.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "ui/events/mojom/event.mojom-params-data.h"
#include "ui/events/mojom/event.mojom-shared-message-ids.h"

#include "ui/events/mojom/event.mojom-blink-import-headers.h"
#include "ui/events/mojom/event.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef UI_EVENTS_MOJOM_EVENT_MOJOM_BLINK_JUMBO_H_
#define UI_EVENTS_MOJOM_EVENT_MOJOM_BLINK_JUMBO_H_
#endif



namespace ui {
namespace mojom {
namespace blink {
KeyData::KeyData()
    : key_code(),
      dom_code(),
      dom_key(),
      is_char() {}

KeyData::KeyData(
    int32_t key_code_in,
    uint32_t dom_code_in,
    int32_t dom_key_in,
    bool is_char_in)
    : key_code(std::move(key_code_in)),
      dom_code(std::move(dom_code_in)),
      dom_key(std::move(dom_key_in)),
      is_char(std::move(is_char_in)) {}

KeyData::~KeyData() = default;
size_t KeyData::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->key_code);
  seed = mojo::internal::WTFHash(seed, this->dom_code);
  seed = mojo::internal::WTFHash(seed, this->dom_key);
  seed = mojo::internal::WTFHash(seed, this->is_char);
  return seed;
}

void KeyData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_code"), this->key_code,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dom_code"), this->dom_code,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dom_key"), this->dom_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_char"), this->is_char,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool KeyData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
LocationData::LocationData()
    : relative_location(),
      root_location() {}

LocationData::LocationData(
    const ::gfx::PointF& relative_location_in,
    const ::gfx::PointF& root_location_in)
    : relative_location(std::move(relative_location_in)),
      root_location(std::move(root_location_in)) {}

LocationData::~LocationData() = default;

void LocationData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "relative_location"), this->relative_location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "root_location"), this->root_location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LocationData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
GestureData::GestureData()
    : location(),
      device_type(),
      scale() {}

GestureData::GestureData(
    LocationDataPtr location_in,
    ::ui::mojom::blink::GestureDeviceType device_type_in,
    float scale_in)
    : location(std::move(location_in)),
      device_type(std::move(device_type_in)),
      scale(std::move(scale_in)) {}

GestureData::~GestureData() = default;

void GestureData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "location"), this->location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type LocationDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "device_type"), this->device_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::ui::mojom::blink::GestureDeviceType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "scale"), this->scale,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GestureData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ScrollData::ScrollData()
    : location(),
      x_offset(),
      y_offset(),
      x_offset_ordinal(),
      y_offset_ordinal(),
      finger_count(),
      momentum_phase(),
      scroll_event_phase() {}

ScrollData::ScrollData(
    LocationDataPtr location_in,
    float x_offset_in,
    float y_offset_in,
    float x_offset_ordinal_in,
    float y_offset_ordinal_in,
    int32_t finger_count_in,
    ::ui::mojom::blink::EventMomentumPhase momentum_phase_in,
    ::ui::mojom::blink::ScrollEventPhase scroll_event_phase_in)
    : location(std::move(location_in)),
      x_offset(std::move(x_offset_in)),
      y_offset(std::move(y_offset_in)),
      x_offset_ordinal(std::move(x_offset_ordinal_in)),
      y_offset_ordinal(std::move(y_offset_ordinal_in)),
      finger_count(std::move(finger_count_in)),
      momentum_phase(std::move(momentum_phase_in)),
      scroll_event_phase(std::move(scroll_event_phase_in)) {}

ScrollData::~ScrollData() = default;

void ScrollData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "location"), this->location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type LocationDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "x_offset"), this->x_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "y_offset"), this->y_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "x_offset_ordinal"), this->x_offset_ordinal,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "y_offset_ordinal"), this->y_offset_ordinal,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "finger_count"), this->finger_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "momentum_phase"), this->momentum_phase,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::ui::mojom::blink::EventMomentumPhase>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "scroll_event_phase"), this->scroll_event_phase,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::ui::mojom::blink::ScrollEventPhase>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ScrollData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PointerDetails::PointerDetails()
    : pointer_type(),
      radius_x(),
      radius_y(),
      force(),
      tilt_x(),
      tilt_y(),
      tangential_pressure(),
      twist(),
      id(),
      offset_x(),
      offset_y() {}

PointerDetails::PointerDetails(
    ::ui::EventPointerType pointer_type_in,
    float radius_x_in,
    float radius_y_in,
    float force_in,
    float tilt_x_in,
    float tilt_y_in,
    float tangential_pressure_in,
    float twist_in,
    int32_t id_in,
    int32_t offset_x_in,
    int32_t offset_y_in)
    : pointer_type(std::move(pointer_type_in)),
      radius_x(std::move(radius_x_in)),
      radius_y(std::move(radius_y_in)),
      force(std::move(force_in)),
      tilt_x(std::move(tilt_x_in)),
      tilt_y(std::move(tilt_y_in)),
      tangential_pressure(std::move(tangential_pressure_in)),
      twist(std::move(twist_in)),
      id(std::move(id_in)),
      offset_x(std::move(offset_x_in)),
      offset_y(std::move(offset_y_in)) {}

PointerDetails::~PointerDetails() = default;

void PointerDetails::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pointer_type"), this->pointer_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::ui::EventPointerType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "radius_x"), this->radius_x,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "radius_y"), this->radius_y,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "force"), this->force,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "tilt_x"), this->tilt_x,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "tilt_y"), this->tilt_y,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "tangential_pressure"), this->tangential_pressure,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "twist"), this->twist,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "offset_x"), this->offset_x,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "offset_y"), this->offset_y,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PointerDetails::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MouseData::MouseData()
    : changed_button_flags(),
      location(),
      pointer_details(),
      wheel_offset(),
      tick_120ths() {}

MouseData::MouseData(
    int32_t changed_button_flags_in,
    LocationDataPtr location_in,
    PointerDetailsPtr pointer_details_in,
    const ::gfx::Vector2d& wheel_offset_in,
    const ::gfx::Vector2d& tick_120ths_in)
    : changed_button_flags(std::move(changed_button_flags_in)),
      location(std::move(location_in)),
      pointer_details(std::move(pointer_details_in)),
      wheel_offset(std::move(wheel_offset_in)),
      tick_120ths(std::move(tick_120ths_in)) {}

MouseData::~MouseData() = default;

void MouseData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "changed_button_flags"), this->changed_button_flags,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "location"), this->location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type LocationDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pointer_details"), this->pointer_details,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type PointerDetailsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "wheel_offset"), this->wheel_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Vector2d&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "tick_120ths"), this->tick_120ths,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Vector2d&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MouseData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TouchData::TouchData()
    : may_cause_scrolling(),
      hovering(),
      location(),
      pointer_details() {}

TouchData::TouchData(
    bool may_cause_scrolling_in,
    bool hovering_in,
    LocationDataPtr location_in,
    PointerDetailsPtr pointer_details_in)
    : may_cause_scrolling(std::move(may_cause_scrolling_in)),
      hovering(std::move(hovering_in)),
      location(std::move(location_in)),
      pointer_details(std::move(pointer_details_in)) {}

TouchData::~TouchData() = default;

void TouchData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "may_cause_scrolling"), this->may_cause_scrolling,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "hovering"), this->hovering,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "location"), this->location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type LocationDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pointer_details"), this->pointer_details,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type PointerDetailsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool TouchData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Event::Event()
    : action(),
      flags(),
      time_stamp(),
      latency(),
      key_data(),
      gesture_data(),
      scroll_data(),
      touch_data(),
      mouse_data(),
      properties() {}

Event::Event(
    ::ui::mojom::blink::EventType action_in,
    int32_t flags_in,
    ::base::TimeTicks time_stamp_in,
    const ::ui::LatencyInfo& latency_in,
    KeyDataPtr key_data_in,
    GestureDataPtr gesture_data_in,
    ScrollDataPtr scroll_data_in,
    TouchDataPtr touch_data_in,
    MouseDataPtr mouse_data_in,
    const absl::optional<WTF::HashMap<WTF::String, WTF::Vector<uint8_t>>>& properties_in)
    : action(std::move(action_in)),
      flags(std::move(flags_in)),
      time_stamp(std::move(time_stamp_in)),
      latency(std::move(latency_in)),
      key_data(std::move(key_data_in)),
      gesture_data(std::move(gesture_data_in)),
      scroll_data(std::move(scroll_data_in)),
      touch_data(std::move(touch_data_in)),
      mouse_data(std::move(mouse_data_in)),
      properties(std::move(properties_in)) {}

Event::~Event() = default;

void Event::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "action"), this->action,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::ui::mojom::blink::EventType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "flags"), this->flags,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "time_stamp"), this->time_stamp,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeTicks>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "latency"), this->latency,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::ui::LatencyInfo&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_data"), this->key_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type KeyDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "gesture_data"), this->gesture_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type GestureDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "scroll_data"), this->scroll_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ScrollDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "touch_data"), this->touch_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type TouchDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "mouse_data"), this->mouse_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MouseDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "properties"), this->properties,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<WTF::HashMap<WTF::String, WTF::Vector<uint8_t>>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Event::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}


}  // namespace blink
}  // namespace mojom
}  // namespace ui


namespace mojo {


// static
bool StructTraits<::ui::mojom::blink::KeyData::DataView, ::ui::mojom::blink::KeyDataPtr>::Read(
    ::ui::mojom::blink::KeyData::DataView input,
    ::ui::mojom::blink::KeyDataPtr* output) {
  bool success = true;
  ::ui::mojom::blink::KeyDataPtr result(::ui::mojom::blink::KeyData::New());
  
      if (success)
        result->key_code = input.key_code();
      if (success)
        result->dom_code = input.dom_code();
      if (success)
        result->dom_key = input.dom_key();
      if (success)
        result->is_char = input.is_char();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::LocationData::DataView, ::ui::mojom::blink::LocationDataPtr>::Read(
    ::ui::mojom::blink::LocationData::DataView input,
    ::ui::mojom::blink::LocationDataPtr* output) {
  bool success = true;
  ::ui::mojom::blink::LocationDataPtr result(::ui::mojom::blink::LocationData::New());
  
      if (success && !input.ReadRelativeLocation(&result->relative_location))
        success = false;
      if (success && !input.ReadRootLocation(&result->root_location))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::GestureData::DataView, ::ui::mojom::blink::GestureDataPtr>::Read(
    ::ui::mojom::blink::GestureData::DataView input,
    ::ui::mojom::blink::GestureDataPtr* output) {
  bool success = true;
  ::ui::mojom::blink::GestureDataPtr result(::ui::mojom::blink::GestureData::New());
  
      if (success && !input.ReadLocation(&result->location))
        success = false;
      if (success && !input.ReadDeviceType(&result->device_type))
        success = false;
      if (success)
        result->scale = input.scale();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::ScrollData::DataView, ::ui::mojom::blink::ScrollDataPtr>::Read(
    ::ui::mojom::blink::ScrollData::DataView input,
    ::ui::mojom::blink::ScrollDataPtr* output) {
  bool success = true;
  ::ui::mojom::blink::ScrollDataPtr result(::ui::mojom::blink::ScrollData::New());
  
      if (success && !input.ReadLocation(&result->location))
        success = false;
      if (success)
        result->x_offset = input.x_offset();
      if (success)
        result->y_offset = input.y_offset();
      if (success)
        result->x_offset_ordinal = input.x_offset_ordinal();
      if (success)
        result->y_offset_ordinal = input.y_offset_ordinal();
      if (success)
        result->finger_count = input.finger_count();
      if (success && !input.ReadMomentumPhase(&result->momentum_phase))
        success = false;
      if (success && !input.ReadScrollEventPhase(&result->scroll_event_phase))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::PointerDetails::DataView, ::ui::mojom::blink::PointerDetailsPtr>::Read(
    ::ui::mojom::blink::PointerDetails::DataView input,
    ::ui::mojom::blink::PointerDetailsPtr* output) {
  bool success = true;
  ::ui::mojom::blink::PointerDetailsPtr result(::ui::mojom::blink::PointerDetails::New());
  
      if (success && !input.ReadPointerType(&result->pointer_type))
        success = false;
      if (success)
        result->radius_x = input.radius_x();
      if (success)
        result->radius_y = input.radius_y();
      if (success)
        result->force = input.force();
      if (success)
        result->tilt_x = input.tilt_x();
      if (success)
        result->tilt_y = input.tilt_y();
      if (success)
        result->tangential_pressure = input.tangential_pressure();
      if (success)
        result->twist = input.twist();
      if (success)
        result->id = input.id();
      if (success)
        result->offset_x = input.offset_x();
      if (success)
        result->offset_y = input.offset_y();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::MouseData::DataView, ::ui::mojom::blink::MouseDataPtr>::Read(
    ::ui::mojom::blink::MouseData::DataView input,
    ::ui::mojom::blink::MouseDataPtr* output) {
  bool success = true;
  ::ui::mojom::blink::MouseDataPtr result(::ui::mojom::blink::MouseData::New());
  
      if (success)
        result->changed_button_flags = input.changed_button_flags();
      if (success && !input.ReadLocation(&result->location))
        success = false;
      if (success && !input.ReadPointerDetails(&result->pointer_details))
        success = false;
      if (success && !input.ReadWheelOffset(&result->wheel_offset))
        success = false;
      if (success && !input.ReadTick120ths(&result->tick_120ths))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::TouchData::DataView, ::ui::mojom::blink::TouchDataPtr>::Read(
    ::ui::mojom::blink::TouchData::DataView input,
    ::ui::mojom::blink::TouchDataPtr* output) {
  bool success = true;
  ::ui::mojom::blink::TouchDataPtr result(::ui::mojom::blink::TouchData::New());
  
      if (success)
        result->may_cause_scrolling = input.may_cause_scrolling();
      if (success)
        result->hovering = input.hovering();
      if (success && !input.ReadLocation(&result->location))
        success = false;
      if (success && !input.ReadPointerDetails(&result->pointer_details))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::ui::mojom::blink::Event::DataView, ::ui::mojom::blink::EventPtr>::Read(
    ::ui::mojom::blink::Event::DataView input,
    ::ui::mojom::blink::EventPtr* output) {
  bool success = true;
  ::ui::mojom::blink::EventPtr result(::ui::mojom::blink::Event::New());
  
      if (success && !input.ReadAction(&result->action))
        success = false;
      if (success)
        result->flags = input.flags();
      if (success && !input.ReadTimeStamp(&result->time_stamp))
        success = false;
      if (success && !input.ReadLatency(&result->latency))
        success = false;
      if (success && !input.ReadKeyData(&result->key_data))
        success = false;
      if (success && !input.ReadGestureData(&result->gesture_data))
        success = false;
      if (success && !input.ReadScrollData(&result->scroll_data))
        success = false;
      if (success && !input.ReadTouchData(&result->touch_data))
        success = false;
      if (success && !input.ReadMouseData(&result->mouse_data))
        success = false;
      if (success && !input.ReadProperties(&result->properties))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace ui {
namespace mojom {
namespace blink {




}  // namespace blink
}  // namespace mojom
}  // namespace ui


#if defined(__clang__)
#pragma clang diagnostic pop
#endif