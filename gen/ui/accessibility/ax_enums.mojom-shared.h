// ui/accessibility/ax_enums.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_ACCESSIBILITY_AX_ENUMS_MOJOM_SHARED_H_
#define UI_ACCESSIBILITY_AX_ENUMS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "ui/accessibility/ax_enums.mojom-shared-internal.h"



#include "base/component_export.h"




namespace ax {
namespace mojom {


}  // namespace mojom
}  // namespace ax

namespace mojo {
namespace internal {

}  // namespace internal
}  // namespace mojo


namespace ax {
namespace mojom {


enum class Event : int32_t {
  
  kNone = 0,
  
  kActiveDescendantChanged = 1,
  
  kAlert = 2,
  
  kAriaAttributeChanged = 3,
  
  kAutocorrectionOccured = 4,
  
  kBlur = 5,
  
  kCheckedStateChanged = 6,
  
  kChildrenChanged = 7,
  
  kClicked = 8,
  
  kControlsChanged = 9,
  
  kDocumentSelectionChanged = 10,
  
  kDocumentTitleChanged = 11,
  
  kEndOfTest = 12,
  
  kExpandedChanged = 13,
  
  kFocus = 14,
  
  kFocusAfterMenuClose = 15,
  
  kFocusContext = 16,
  
  kHide = 17,
  
  kHitTestResult = 18,
  
  kHover = 19,
  
  kImageFrameUpdated = 20,
  
  kLayoutComplete = 21,
  
  kLiveRegionCreated = 22,
  
  kLiveRegionChanged = 23,
  
  kLoadComplete = 24,
  
  kLoadStart = 25,
  
  kLocationChanged = 26,
  
  kMediaStartedPlaying = 27,
  
  kMediaStoppedPlaying = 28,
  
  kMenuEnd = 29,
  
  kMenuListValueChanged = 30,
  
  kMenuPopupEnd = 31,
  
  kMenuPopupStart = 32,
  
  kMenuStart = 33,
  
  kMouseCanceled = 34,
  
  kMouseDragged = 35,
  
  kMouseMoved = 36,
  
  kMousePressed = 37,
  
  kMouseReleased = 38,
  
  kRowCollapsed = 39,
  
  kRowCountChanged = 40,
  
  kRowExpanded = 41,
  
  kScrollPositionChanged = 42,
  
  kScrolledToAnchor = 43,
  
  kSelectedChildrenChanged = 44,
  
  kSelection = 45,
  
  kSelectionAdd = 46,
  
  kSelectionRemove = 47,
  
  kShow = 48,
  
  kStateChanged = 49,
  
  kTextChanged = 50,
  
  kTextSelectionChanged = 51,
  
  kTooltipClosed = 52,
  
  kTooltipOpened = 53,
  
  kTreeChanged = 54,
  
  kValueChanged = 55,
  
  kWindowActivated = 56,
  
  kWindowDeactivated = 57,
  
  kWindowVisibilityChanged = 58,
  kMinValue = 0,
  kMaxValue = 58,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Event value);
inline bool IsKnownEnumValue(Event value) {
  return internal::Event_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline Event ToKnownEnumValue(Event value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return Event::kDefaultValue;
}


enum class Role : int32_t {
  
  kNone = 0,
  
  kAbbr = 1,
  
  kAlert = 2,
  
  kAlertDialog = 3,
  
  kApplication = 4,
  
  kArticle = 5,
  
  kAudio = 6,
  
  kBanner = 7,
  
  kBlockquote = 8,
  
  kButton = 9,
  
  kCanvas = 10,
  
  kCaption = 11,
  
  kCaret = 12,
  
  kCell = 13,
  
  kCheckBox = 14,
  
  kClient = 15,
  
  kCode = 16,
  
  kColorWell = 17,
  
  kColumn = 18,
  
  kColumnHeader = 19,
  
  kComboBoxGrouping = 20,
  
  kComboBoxMenuButton = 21,
  
  kComplementary = 22,
  
  kComment = 23,
  
  kContentDeletion = 24,
  
  kContentInsertion = 25,
  
  kContentInfo = 26,
  
  kDate = 27,
  
  kDateTime = 28,
  
  kDefinition = 29,
  
  kDescriptionList = 30,
  
  kDescriptionListDetail = 31,
  
  kDescriptionListTerm = 32,
  
  kDesktop = 33,
  
  kDetails = 34,
  
  kDialog = 35,
  
  kDirectory = 36,
  
  kDisclosureTriangle = 37,
  
  kDocAbstract = 38,
  
  kDocAcknowledgments = 39,
  
  kDocAfterword = 40,
  
  kDocAppendix = 41,
  
  kDocBackLink = 42,
  
  kDocBiblioEntry = 43,
  
  kDocBibliography = 44,
  
  kDocBiblioRef = 45,
  
  kDocChapter = 46,
  
  kDocColophon = 47,
  
  kDocConclusion = 48,
  
  kDocCover = 49,
  
  kDocCredit = 50,
  
  kDocCredits = 51,
  
  kDocDedication = 52,
  
  kDocEndnote = 53,
  
  kDocEndnotes = 54,
  
  kDocEpigraph = 55,
  
  kDocEpilogue = 56,
  
  kDocErrata = 57,
  
  kDocExample = 58,
  
  kDocFootnote = 59,
  
  kDocForeword = 60,
  
  kDocGlossary = 61,
  
  kDocGlossRef = 62,
  
  kDocIndex = 63,
  
  kDocIntroduction = 64,
  
  kDocNoteRef = 65,
  
  kDocNotice = 66,
  
  kDocPageBreak = 67,
  
  kDocPageFooter = 68,
  
  kDocPageHeader = 69,
  
  kDocPageList = 70,
  
  kDocPart = 71,
  
  kDocPreface = 72,
  
  kDocPrologue = 73,
  
  kDocPullquote = 74,
  
  kDocQna = 75,
  
  kDocSubtitle = 76,
  
  kDocTip = 77,
  
  kDocToc = 78,
  
  kDocument = 79,
  
  kEmbeddedObject = 80,
  
  kEmphasis = 81,
  
  kFeed = 82,
  
  kFigcaption = 83,
  
  kFigure = 84,
  
  kFooter = 85,
  
  kFooterAsNonLandmark = 86,
  
  kForm = 87,
  
  kGenericContainer = 88,
  
  kGraphicsDocument = 89,
  
  kGraphicsObject = 90,
  
  kGraphicsSymbol = 91,
  
  kGrid = 92,
  
  kGroup = 93,
  
  kHeader = 94,
  
  kHeaderAsNonLandmark = 95,
  
  kHeading = 96,
  
  kIframe = 97,
  
  kIframePresentational = 98,
  
  kImage = 99,
  
  kImeCandidate = 100,
  
  kInlineTextBox = 101,
  
  kInputTime = 102,
  
  kKeyboard = 103,
  
  kLabelText = 104,
  
  kLayoutTable = 105,
  
  kLayoutTableCell = 106,
  
  kLayoutTableRow = 107,
  
  kLegend = 108,
  
  kLineBreak = 109,
  
  kLink = 110,
  
  kList = 111,
  
  kListBox = 112,
  
  kListBoxOption = 113,
  
  kListGrid = 114,
  
  kListItem = 115,
  
  kListMarker = 116,
  
  kLog = 117,
  
  kMain = 118,
  
  kMark = 119,
  
  kMarquee = 120,
  
  kMath = 121,
  
  kMathMLFraction = 188,
  
  kMathMLIdentifier = 189,
  
  kMathMLMath = 187,
  
  kMathMLMultiscripts = 190,
  
  kMathMLNoneScript = 191,
  
  kMathMLNumber = 192,
  
  kMathMLOperator = 193,
  
  kMathMLOver = 194,
  
  kMathMLPrescriptDelimiter = 195,
  
  kMathMLRoot = 196,
  
  kMathMLRow = 197,
  
  kMathMLSquareRoot = 198,
  
  kMathMLStringLiteral = 199,
  
  kMathMLSub = 200,
  
  kMathMLSubSup = 201,
  
  kMathMLSup = 202,
  
  kMathMLTable = 203,
  
  kMathMLTableCell = 204,
  
  kMathMLTableRow = 205,
  
  kMathMLText = 206,
  
  kMathMLUnder = 207,
  
  kMathMLUnderOver = 208,
  
  kMenu = 122,
  
  kMenuBar = 123,
  
  kMenuItem = 124,
  
  kMenuItemCheckBox = 125,
  
  kMenuItemRadio = 126,
  
  kMenuListOption = 127,
  
  kMenuListPopup = 128,
  
  kMeter = 129,
  
  kNavigation = 130,
  
  kNote = 131,
  
  kPane = 132,
  
  kParagraph = 133,
  
  kPdfActionableHighlight = 134,
  
  kPdfRoot = 135,
  
  kPluginObject = 136,
  
  kPopUpButton = 137,
  
  kPortal = 138,
  
  kPre = 139,
  
  kProgressIndicator = 140,
  
  kRadioButton = 141,
  
  kRadioGroup = 142,
  
  kRegion = 143,
  
  kRootWebArea = 144,
  
  kRow = 145,
  
  kRowGroup = 146,
  
  kRowHeader = 147,
  
  kRuby = 148,
  
  kRubyAnnotation = 149,
  
  kScrollBar = 150,
  
  kScrollView = 151,
  
  kSearch = 152,
  
  kSearchBox = 153,
  
  kSection = 154,
  
  kSlider = 155,
  
  kSpinButton = 156,
  
  kSplitter = 157,
  
  kStaticText = 158,
  
  kStatus = 159,
  
  kStrong = 160,
  
  kSubscript = 185,
  
  kSuggestion = 161,
  
  kSuperscript = 186,
  
  kSvgRoot = 162,
  
  kSwitch = 163,
  
  kTab = 164,
  
  kTabList = 165,
  
  kTabPanel = 166,
  
  kTable = 167,
  
  kTableHeaderContainer = 168,
  
  kTerm = 169,
  
  kTextField = 170,
  
  kTextFieldWithComboBox = 171,
  
  kTime = 172,
  
  kTimer = 173,
  
  kTitleBar = 174,
  
  kToggleButton = 175,
  
  kToolbar = 176,
  
  kTooltip = 177,
  
  kTree = 178,
  
  kTreeGrid = 179,
  
  kTreeItem = 180,
  
  kUnknown = 181,
  
  kVideo = 182,
  
  kWebView = 183,
  
  kWindow = 184,
  kMinValue = 0,
  kMaxValue = 208,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Role value);
inline bool IsKnownEnumValue(Role value) {
  return internal::Role_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline Role ToKnownEnumValue(Role value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return Role::kDefaultValue;
}


enum class State : int32_t {
  
  kNone = 0,
  
  kAutofillAvailable = 1,
  
  kCollapsed = 2,
  
  kDefault = 3,
  
  kEditable = 4,
  
  kExpanded = 5,
  
  kFocusable = 6,
  
  kHorizontal = 7,
  
  kHovered = 8,
  
  kIgnored = 9,
  
  kInvisible = 10,
  
  kLinked = 11,
  
  kMultiline = 12,
  
  kMultiselectable = 13,
  
  kProtected = 14,
  
  kRequired = 15,
  
  kRichlyEditable = 16,
  
  kVertical = 17,
  
  kVisited = 18,
  kMinValue = 0,
  kMaxValue = 18,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, State value);
inline bool IsKnownEnumValue(State value) {
  return internal::State_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline State ToKnownEnumValue(State value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return State::kDefaultValue;
}


enum class Action : int32_t {
  
  kNone = 0,
  
  kAnnotatePageImages = 1,
  
  kBlur = 2,
  
  kClearAccessibilityFocus = 3,
  
  kCollapse = 4,
  
  kCustomAction = 5,
  
  kDecrement = 6,
  
  kDoDefault = 7,
  
  kExpand = 8,
  
  kFocus = 9,
  
  kGetImageData = 10,
  
  kGetTextLocation = 11,
  
  kHideTooltip = 12,
  
  kHitTest = 13,
  
  kIncrement = 14,
  
  kInternalInvalidateTree = 15,
  
  kLoadInlineTextBoxes = 16,
  
  kReplaceSelectedText = 17,
  
  kResumeMedia = 34,
  
  kScrollBackward = 18,
  
  kScrollDown = 19,
  
  kScrollForward = 20,
  
  kScrollLeft = 21,
  
  kScrollRight = 22,
  
  kScrollUp = 23,
  
  kScrollToMakeVisible = 24,
  
  kScrollToPoint = 25,
  
  kSetAccessibilityFocus = 26,
  
  kSetScrollOffset = 27,
  
  kSetSelection = 28,
  
  kSetSequentialFocusNavigationStartingPoint = 29,
  
  kSetValue = 30,
  
  kShowContextMenu = 31,
  
  kSignalEndOfTest = 32,
  
  kShowTooltip = 33,
  
  kStartDuckingMedia = 35,
  
  kStopDuckingMedia = 36,
  
  kSuspendMedia = 37,
  kMinValue = 0,
  kMaxValue = 37,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Action value);
inline bool IsKnownEnumValue(Action value) {
  return internal::Action_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline Action ToKnownEnumValue(Action value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return Action::kDefaultValue;
}


enum class ActionFlags : int32_t {
  
  kNone = 0,
  
  kRequestImages = 1,
  
  kRequestInlineTextBoxes = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, ActionFlags value);
inline bool IsKnownEnumValue(ActionFlags value) {
  return internal::ActionFlags_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ScrollAlignment : int32_t {
  
  kNone = 0,
  
  kScrollAlignmentCenter = 1,
  
  kScrollAlignmentTop = 2,
  
  kScrollAlignmentBottom = 3,
  
  kScrollAlignmentLeft = 4,
  
  kScrollAlignmentRight = 5,
  
  kScrollAlignmentClosestEdge = 6,
  kMinValue = 0,
  kMaxValue = 6,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, ScrollAlignment value);
inline bool IsKnownEnumValue(ScrollAlignment value) {
  return internal::ScrollAlignment_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline ScrollAlignment ToKnownEnumValue(ScrollAlignment value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return ScrollAlignment::kDefaultValue;
}


enum class ScrollBehavior : int32_t {
  
  kNone = 0,
  
  kDoNotScrollIfVisible = 1,
  
  kScrollIfVisible = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, ScrollBehavior value);
inline bool IsKnownEnumValue(ScrollBehavior value) {
  return internal::ScrollBehavior_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline ScrollBehavior ToKnownEnumValue(ScrollBehavior value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return ScrollBehavior::kDefaultValue;
}


enum class DefaultActionVerb : int32_t {
  
  kNone = 0,
  
  kActivate = 1,
  
  kCheck = 2,
  
  kClick = 3,
  
  kClickAncestor = 4,
  
  kJump = 5,
  
  kOpen = 6,
  
  kPress = 7,
  
  kSelect = 8,
  
  kUncheck = 9,
  kMinValue = 0,
  kMaxValue = 9,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, DefaultActionVerb value);
inline bool IsKnownEnumValue(DefaultActionVerb value) {
  return internal::DefaultActionVerb_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class Mutation : int32_t {
  
  kNone = 0,
  
  kNodeCreated = 1,
  
  kSubtreeCreated = 2,
  
  kNodeChanged = 3,
  
  kNodeRemoved = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Mutation value);
inline bool IsKnownEnumValue(Mutation value) {
  return internal::Mutation_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class StringAttribute : int32_t {
  
  kNone = 0,
  
  kAccessKey = 1,
  
  kAppId = 2,
  
  kAriaInvalidValue = 3,
  
  kAutoComplete = 4,
  
  kCheckedStateDescription = 5,
  
  kChildTreeId = 6,
  
  kChildTreeNodeAppId = 7,
  
  kClassName = 8,
  
  kContainerLiveRelevant = 9,
  
  kContainerLiveStatus = 10,
  
  kDescription = 11,
  
  kDisplay = 12,
  
  kFontFamily = 13,
  
  kHtmlTag = 14,
  
  kImageAnnotation = 15,
  
  kImageDataUrl = 16,
  
  kInnerHtml = 17,
  
  kInputType = 18,
  
  kKeyShortcuts = 19,
  
  kLanguage = 20,
  
  kName = 21,
  
  kLiveRelevant = 22,
  
  kLiveStatus = 23,
  
  kPlaceholder = 24,
  
  kRole = 25,
  
  kRoleDescription = 26,
  
  kTooltip = 27,
  
  kUrl = 28,
  
  kValue = 29,
  
  kVirtualContent = 30,
  kMinValue = 0,
  kMaxValue = 30,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, StringAttribute value);
inline bool IsKnownEnumValue(StringAttribute value) {
  return internal::StringAttribute_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline StringAttribute ToKnownEnumValue(StringAttribute value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return StringAttribute::kDefaultValue;
}


enum class IntAttribute : int32_t {
  
  kNone = 0,
  
  kDefaultActionVerb = 1,
  
  kScrollX = 2,
  
  kScrollXMin = 3,
  
  kScrollXMax = 4,
  
  kScrollY = 5,
  
  kScrollYMin = 6,
  
  kScrollYMax = 7,
  
  kTextSelStart = 8,
  
  kTextSelEnd = 9,
  
  kAriaColumnCount = 10,
  
  kAriaCellColumnIndex = 11,
  
  kAriaCellColumnSpan = 12,
  
  kAriaRowCount = 13,
  
  kAriaCellRowIndex = 14,
  
  kAriaCellRowSpan = 15,
  
  kTableRowCount = 16,
  
  kTableColumnCount = 17,
  
  kTableHeaderId = 18,
  
  kTableRowIndex = 19,
  
  kTableRowHeaderId = 20,
  
  kTableColumnIndex = 21,
  
  kTableColumnHeaderId = 22,
  
  kTableCellColumnIndex = 23,
  
  kTableCellColumnSpan = 24,
  
  kTableCellRowIndex = 25,
  
  kTableCellRowSpan = 26,
  
  kSortDirection = 27,
  
  kHierarchicalLevel = 28,
  
  kNameFrom = 29,
  
  kDescriptionFrom = 30,
  
  kActivedescendantId = 31,
  
  kErrormessageId = 32,
  
  kInPageLinkTargetId = 33,
  
  kMemberOfId = 34,
  
  kNextOnLineId = 35,
  
  kPopupForId = 36,
  
  kPreviousOnLineId = 37,
  
  kRestriction = 38,
  
  kSetSize = 39,
  
  kPosInSet = 40,
  
  kColorValue = 41,
  
  kAriaCurrentState = 42,
  
  kBackgroundColor = 43,
  
  kColor = 44,
  
  kHasPopup = 45,
  
  kImageAnnotationStatus = 46,
  
  kInvalidState = 47,
  
  kCheckedState = 48,
  
  kListStyle = 49,
  
  kTextAlign = 50,
  
  kTextDirection = 51,
  
  kTextPosition = 52,
  
  kTextStyle = 53,
  
  kTextOverlineStyle = 54,
  
  kTextStrikethroughStyle = 55,
  
  kTextUnderlineStyle = 56,
  
  kPreviousFocusId = 57,
  
  kNextFocusId = 58,
  
  kDropeffect = 59,
  
  kDOMNodeId = 60,
  kMinValue = 0,
  kMaxValue = 60,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, IntAttribute value);
inline bool IsKnownEnumValue(IntAttribute value) {
  return internal::IntAttribute_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline IntAttribute ToKnownEnumValue(IntAttribute value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return IntAttribute::kDefaultValue;
}


enum class FloatAttribute : int32_t {
  
  kNone = 0,
  
  kValueForRange = 1,
  
  kMinValueForRange = 2,
  
  kMaxValueForRange = 3,
  
  kStepValueForRange = 4,
  
  kFontSize = 5,
  
  kFontWeight = 6,
  
  kTextIndent = 7,
  
  kChildTreeScale = 8,
  kMinValue = 0,
  kMaxValue = 8,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, FloatAttribute value);
inline bool IsKnownEnumValue(FloatAttribute value) {
  return internal::FloatAttribute_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline FloatAttribute ToKnownEnumValue(FloatAttribute value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return FloatAttribute::kDefaultValue;
}


enum class BoolAttribute : int32_t {
  
  kNone = 0,
  
  kBusy = 1,
  
  kNonAtomicTextFieldRoot = 2,
  
  kContainerLiveAtomic = 3,
  
  kContainerLiveBusy = 4,
  
  kLiveAtomic = 5,
  
  kModal = 6,
  
  kUpdateLocationOnly = 7,
  
  kCanvasHasFallback = 8,
  
  kScrollable = 9,
  
  kClickable = 10,
  
  kClipsChildren = 11,
  
  kNotUserSelectableStyle = 12,
  
  kSelected = 13,
  
  kSelectedFromFocus = 14,
  
  kSupportsTextLocation = 15,
  
  kGrabbed = 16,
  
  kIsLineBreakingObject = 17,
  
  kIsPageBreakingObject = 18,
  
  kHasAriaAttribute = 19,
  
  kTouchPassthrough = 20,
  kMinValue = 0,
  kMaxValue = 20,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, BoolAttribute value);
inline bool IsKnownEnumValue(BoolAttribute value) {
  return internal::BoolAttribute_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline BoolAttribute ToKnownEnumValue(BoolAttribute value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return BoolAttribute::kDefaultValue;
}


enum class IntListAttribute : int32_t {
  
  kNone = 0,
  
  kIndirectChildIds = 1,
  
  kControlsIds = 2,
  
  kDetailsIds = 3,
  
  kDescribedbyIds = 4,
  
  kFlowtoIds = 5,
  
  kLabelledbyIds = 6,
  
  kRadioGroupIds = 7,
  
  kMarkerTypes = 8,
  
  kMarkerStarts = 9,
  
  kMarkerEnds = 10,
  
  kHighlightTypes = 20,
  
  kCaretBounds = 16,
  
  kCharacterOffsets = 11,
  
  kLineStarts = 12,
  
  kLineEnds = 17,
  
  kSentenceStarts = 18,
  
  kSentenceEnds = 19,
  
  kWordStarts = 13,
  
  kWordEnds = 14,
  
  kCustomActionIds = 15,
  kMinValue = 0,
  kMaxValue = 20,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, IntListAttribute value);
inline bool IsKnownEnumValue(IntListAttribute value) {
  return internal::IntListAttribute_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline IntListAttribute ToKnownEnumValue(IntListAttribute value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return IntListAttribute::kDefaultValue;
}


enum class StringListAttribute : int32_t {
  
  kNone = 0,
  
  kCustomActionDescriptions = 1,
  kMinValue = 0,
  kMaxValue = 1,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, StringListAttribute value);
inline bool IsKnownEnumValue(StringListAttribute value) {
  return internal::StringListAttribute_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline StringListAttribute ToKnownEnumValue(StringListAttribute value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return StringListAttribute::kDefaultValue;
}


enum class ListStyle : int32_t {
  
  kNone = 0,
  
  kCircle = 1,
  
  kDisc = 2,
  
  kImage = 3,
  
  kNumeric = 4,
  
  kSquare = 5,
  
  kOther = 6,
  kMinValue = 0,
  kMaxValue = 6,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, ListStyle value);
inline bool IsKnownEnumValue(ListStyle value) {
  return internal::ListStyle_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MarkerType : int32_t {
  
  kNone = 0,
  
  kSpelling = 1,
  
  kGrammar = 2,
  
  kTextMatch = 4,
  
  kActiveSuggestion = 16,
  
  kSuggestion = 32,
  
  kHighlight = 64,
  kMinValue = 0,
  kMaxValue = 64,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, MarkerType value);
inline bool IsKnownEnumValue(MarkerType value) {
  return internal::MarkerType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class HighlightType : int32_t {
  
  kNone = 0,
  
  kHighlight = 1,
  
  kSpellingError = 2,
  
  kGrammarError = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, HighlightType value);
inline bool IsKnownEnumValue(HighlightType value) {
  return internal::HighlightType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MoveDirection : int32_t {
  
  kNone = 0,
  
  kBackward = 1,
  
  kForward = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, MoveDirection value);
inline bool IsKnownEnumValue(MoveDirection value) {
  return internal::MoveDirection_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline MoveDirection ToKnownEnumValue(MoveDirection value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return MoveDirection::kDefaultValue;
}


enum class Command : int32_t {
  
  kNone = 0,
  
  kClearSelection = 1,
  
  kDelete = 2,
  
  kDictate = 3,
  
  kExtendSelection = 4,
  
  kFormat = 5,
  
  kHistory = 6,
  
  kInsert = 7,
  
  kMarker = 8,
  
  kMoveSelection = 9,
  
  kSetSelection = 10,
  kMinValue = 0,
  kMaxValue = 10,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Command value);
inline bool IsKnownEnumValue(Command value) {
  return internal::Command_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline Command ToKnownEnumValue(Command value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return Command::kDefaultValue;
}


enum class InputEventType : int32_t {
  
  kNone = 0,
  
  kInsertText = 1,
  
  kInsertLineBreak = 2,
  
  kInsertParagraph = 3,
  
  kInsertOrderedList = 4,
  
  kInsertUnorderedList = 5,
  
  kInsertHorizontalRule = 6,
  
  kInsertFromPaste = 7,
  
  kInsertFromDrop = 8,
  
  kInsertFromYank = 9,
  
  kInsertTranspose = 10,
  
  kInsertReplacementText = 11,
  
  kInsertCompositionText = 12,
  
  kDeleteWordBackward = 13,
  
  kDeleteWordForward = 14,
  
  kDeleteSoftLineBackward = 15,
  
  kDeleteSoftLineForward = 16,
  
  kDeleteHardLineBackward = 17,
  
  kDeleteHardLineForward = 18,
  
  kDeleteContentBackward = 19,
  
  kDeleteContentForward = 20,
  
  kDeleteByCut = 21,
  
  kDeleteByDrag = 22,
  
  kHistoryUndo = 23,
  
  kHistoryRedo = 24,
  
  kFormatBold = 25,
  
  kFormatItalic = 26,
  
  kFormatUnderline = 27,
  
  kFormatStrikeThrough = 28,
  
  kFormatSuperscript = 29,
  
  kFormatSubscript = 30,
  
  kFormatJustifyCenter = 31,
  
  kFormatJustifyFull = 32,
  
  kFormatJustifyRight = 33,
  
  kFormatJustifyLeft = 34,
  
  kFormatIndent = 35,
  
  kFormatOutdent = 36,
  
  kFormatRemove = 37,
  
  kFormatSetBlockTextDirection = 38,
  kMinValue = 0,
  kMaxValue = 38,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, InputEventType value);
inline bool IsKnownEnumValue(InputEventType value) {
  return internal::InputEventType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline InputEventType ToKnownEnumValue(InputEventType value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return InputEventType::kDefaultValue;
}


enum class TextBoundary : int32_t {
  
  kNone = 0,
  
  kCharacter = 1,
  
  kFormatEnd = 2,
  
  kFormatStart = 21,
  
  kFormatStartOrEnd = 22,
  
  kLineEnd = 3,
  
  kLineStart = 4,
  
  kLineStartOrEnd = 5,
  
  kObject = 6,
  
  kPageEnd = 7,
  
  kPageStart = 8,
  
  kPageStartOrEnd = 9,
  
  kParagraphEnd = 10,
  
  kParagraphStart = 11,
  
  kParagraphStartSkippingEmptyParagraphs = 20,
  
  kParagraphStartOrEnd = 12,
  
  kSentenceEnd = 13,
  
  kSentenceStart = 14,
  
  kSentenceStartOrEnd = 15,
  
  kWebPage = 16,
  
  kWordEnd = 17,
  
  kWordStart = 18,
  
  kWordStartOrEnd = 19,
  kMinValue = 0,
  kMaxValue = 22,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TextBoundary value);
inline bool IsKnownEnumValue(TextBoundary value) {
  return internal::TextBoundary_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline TextBoundary ToKnownEnumValue(TextBoundary value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return TextBoundary::kDefaultValue;
}


enum class TextAlign : int32_t {
  
  kNone = 0,
  
  kLeft = 1,
  
  kRight = 2,
  
  kCenter = 3,
  
  kJustify = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TextAlign value);
inline bool IsKnownEnumValue(TextAlign value) {
  return internal::TextAlign_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class WritingDirection : int32_t {
  
  kNone = 0,
  
  kLtr = 1,
  
  kRtl = 2,
  
  kTtb = 3,
  
  kBtt = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, WritingDirection value);
inline bool IsKnownEnumValue(WritingDirection value) {
  return internal::WritingDirection_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TextPosition : int32_t {
  
  kNone = 0,
  
  kSubscript = 1,
  
  kSuperscript = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TextPosition value);
inline bool IsKnownEnumValue(TextPosition value) {
  return internal::TextPosition_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TextStyle : int32_t {
  
  kNone = 0,
  
  kBold = 1,
  
  kItalic = 2,
  
  kUnderline = 3,
  
  kLineThrough = 4,
  
  kOverline = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TextStyle value);
inline bool IsKnownEnumValue(TextStyle value) {
  return internal::TextStyle_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TextDecorationStyle : int32_t {
  
  kNone = 0,
  
  kDotted = 1,
  
  kDashed = 2,
  
  kSolid = 3,
  
  kDouble = 4,
  
  kWavy = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TextDecorationStyle value);
inline bool IsKnownEnumValue(TextDecorationStyle value) {
  return internal::TextDecorationStyle_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class AriaCurrentState : int32_t {
  
  kNone = 0,
  
  kFalse = 1,
  
  kTrue = 2,
  
  kPage = 3,
  
  kStep = 4,
  
  kLocation = 5,
  
  kDate = 6,
  
  kTime = 7,
  kMinValue = 0,
  kMaxValue = 7,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, AriaCurrentState value);
inline bool IsKnownEnumValue(AriaCurrentState value) {
  return internal::AriaCurrentState_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class HasPopup : int32_t {
  
  kFalse = 0,
  
  kTrue = 1,
  
  kMenu = 2,
  
  kListbox = 3,
  
  kTree = 4,
  
  kGrid = 5,
  
  kDialog = 6,
  
  kNone = 0,
  kMinValue = 0,
  kMaxValue = 6,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, HasPopup value);
inline bool IsKnownEnumValue(HasPopup value) {
  return internal::HasPopup_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class InvalidState : int32_t {
  
  kNone = 0,
  
  kFalse = 1,
  
  kTrue = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, InvalidState value);
inline bool IsKnownEnumValue(InvalidState value) {
  return internal::InvalidState_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class Restriction : int32_t {
  
  kNone = 0,
  
  kReadOnly = 1,
  
  kDisabled = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Restriction value);
inline bool IsKnownEnumValue(Restriction value) {
  return internal::Restriction_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class CheckedState : int32_t {
  
  kNone = 0,
  
  kFalse = 1,
  
  kTrue = 2,
  
  kMixed = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, CheckedState value);
inline bool IsKnownEnumValue(CheckedState value) {
  return internal::CheckedState_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class SortDirection : int32_t {
  
  kNone = 0,
  
  kUnsorted = 1,
  
  kAscending = 2,
  
  kDescending = 3,
  
  kOther = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, SortDirection value);
inline bool IsKnownEnumValue(SortDirection value) {
  return internal::SortDirection_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class NameFrom : int32_t {
  
  kNone = 0,
  
  kAttribute = 1,
  
  kAttributeExplicitlyEmpty = 2,
  
  kCaption = 3,
  
  kContents = 4,
  
  kPlaceholder = 5,
  
  kRelatedElement = 6,
  
  kTitle = 7,
  
  kValue = 8,
  kMinValue = 0,
  kMaxValue = 8,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, NameFrom value);
inline bool IsKnownEnumValue(NameFrom value) {
  return internal::NameFrom_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class DescriptionFrom : int32_t {
  
  kNone = 0,
  
  kAriaDescription = 1,
  
  kAttributeExplicitlyEmpty = 2,
  
  kButtonLabel = 3,
  
  kRelatedElement = 4,
  
  kRubyAnnotation = 5,
  
  kSummary = 6,
  
  kSvgDescElement = 7,
  
  kTableCaption = 8,
  
  kTitle = 9,
  
  kPopupElement = 10,
  kMinValue = 0,
  kMaxValue = 10,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, DescriptionFrom value);
inline bool IsKnownEnumValue(DescriptionFrom value) {
  return internal::DescriptionFrom_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class EventFrom : int32_t {
  
  kNone = 0,
  
  kUser = 1,
  
  kPage = 2,
  
  kAction = 3,
  kMinValue = 0,
  kMaxValue = 3,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, EventFrom value);
inline bool IsKnownEnumValue(EventFrom value) {
  return internal::EventFrom_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline EventFrom ToKnownEnumValue(EventFrom value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return EventFrom::kDefaultValue;
}


enum class Gesture : int32_t {
  
  kNone = 0,
  
  kClick = 1,
  
  kSwipeLeft1 = 2,
  
  kSwipeUp1 = 3,
  
  kSwipeRight1 = 4,
  
  kSwipeDown1 = 5,
  
  kSwipeLeft2 = 6,
  
  kSwipeUp2 = 7,
  
  kSwipeRight2 = 8,
  
  kSwipeDown2 = 9,
  
  kSwipeLeft3 = 10,
  
  kSwipeUp3 = 11,
  
  kSwipeRight3 = 12,
  
  kSwipeDown3 = 13,
  
  kSwipeLeft4 = 14,
  
  kSwipeUp4 = 15,
  
  kSwipeRight4 = 16,
  
  kSwipeDown4 = 17,
  
  kTap2 = 18,
  
  kTap3 = 19,
  
  kTap4 = 20,
  
  kTouchExplore = 21,
  kMinValue = 0,
  kMaxValue = 21,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Gesture value);
inline bool IsKnownEnumValue(Gesture value) {
  return internal::Gesture_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TextAffinity : int32_t {
  
  kNone = 0,
  
  kDownstream = 1,
  
  kUpstream = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 0
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TextAffinity value);
inline bool IsKnownEnumValue(TextAffinity value) {
  return internal::TextAffinity_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline TextAffinity ToKnownEnumValue(TextAffinity value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return TextAffinity::kDefaultValue;
}


enum class TreeOrder : int32_t {
  
  kNone = 0,
  
  kUndefined = 1,
  
  kBefore = 2,
  
  kEqual = 3,
  
  kAfter = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, TreeOrder value);
inline bool IsKnownEnumValue(TreeOrder value) {
  return internal::TreeOrder_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class AXTreeIDType : int32_t {
  
  kUnknown = 0,
  
  kToken = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, AXTreeIDType value);
inline bool IsKnownEnumValue(AXTreeIDType value) {
  return internal::AXTreeIDType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ImageAnnotationStatus : int32_t {
  
  kNone = 0,
  
  kWillNotAnnotateDueToScheme = 1,
  
  kIneligibleForAnnotation = 2,
  
  kEligibleForAnnotation = 3,
  
  kSilentlyEligibleForAnnotation = 4,
  
  kAnnotationPending = 5,
  
  kAnnotationSucceeded = 6,
  
  kAnnotationEmpty = 7,
  
  kAnnotationAdult = 8,
  
  kAnnotationProcessFailed = 9,
  kMinValue = 0,
  kMaxValue = 9,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, ImageAnnotationStatus value);
inline bool IsKnownEnumValue(ImageAnnotationStatus value) {
  return internal::ImageAnnotationStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class Dropeffect : int32_t {
  
  kNone = 0,
  
  kCopy = 1,
  
  kExecute = 2,
  
  kLink = 3,
  
  kMove = 4,
  
  kPopup = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Dropeffect value);
inline bool IsKnownEnumValue(Dropeffect value) {
  return internal::Dropeffect_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


}  // namespace mojom
}  // namespace ax

namespace std {

template <>
struct hash<::ax::mojom::Event>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Event> {};

template <>
struct hash<::ax::mojom::Role>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Role> {};

template <>
struct hash<::ax::mojom::State>
    : public mojo::internal::EnumHashImpl<::ax::mojom::State> {};

template <>
struct hash<::ax::mojom::Action>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Action> {};

template <>
struct hash<::ax::mojom::ActionFlags>
    : public mojo::internal::EnumHashImpl<::ax::mojom::ActionFlags> {};

template <>
struct hash<::ax::mojom::ScrollAlignment>
    : public mojo::internal::EnumHashImpl<::ax::mojom::ScrollAlignment> {};

template <>
struct hash<::ax::mojom::ScrollBehavior>
    : public mojo::internal::EnumHashImpl<::ax::mojom::ScrollBehavior> {};

template <>
struct hash<::ax::mojom::DefaultActionVerb>
    : public mojo::internal::EnumHashImpl<::ax::mojom::DefaultActionVerb> {};

template <>
struct hash<::ax::mojom::Mutation>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Mutation> {};

template <>
struct hash<::ax::mojom::StringAttribute>
    : public mojo::internal::EnumHashImpl<::ax::mojom::StringAttribute> {};

template <>
struct hash<::ax::mojom::IntAttribute>
    : public mojo::internal::EnumHashImpl<::ax::mojom::IntAttribute> {};

template <>
struct hash<::ax::mojom::FloatAttribute>
    : public mojo::internal::EnumHashImpl<::ax::mojom::FloatAttribute> {};

template <>
struct hash<::ax::mojom::BoolAttribute>
    : public mojo::internal::EnumHashImpl<::ax::mojom::BoolAttribute> {};

template <>
struct hash<::ax::mojom::IntListAttribute>
    : public mojo::internal::EnumHashImpl<::ax::mojom::IntListAttribute> {};

template <>
struct hash<::ax::mojom::StringListAttribute>
    : public mojo::internal::EnumHashImpl<::ax::mojom::StringListAttribute> {};

template <>
struct hash<::ax::mojom::ListStyle>
    : public mojo::internal::EnumHashImpl<::ax::mojom::ListStyle> {};

template <>
struct hash<::ax::mojom::MarkerType>
    : public mojo::internal::EnumHashImpl<::ax::mojom::MarkerType> {};

template <>
struct hash<::ax::mojom::HighlightType>
    : public mojo::internal::EnumHashImpl<::ax::mojom::HighlightType> {};

template <>
struct hash<::ax::mojom::MoveDirection>
    : public mojo::internal::EnumHashImpl<::ax::mojom::MoveDirection> {};

template <>
struct hash<::ax::mojom::Command>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Command> {};

template <>
struct hash<::ax::mojom::InputEventType>
    : public mojo::internal::EnumHashImpl<::ax::mojom::InputEventType> {};

template <>
struct hash<::ax::mojom::TextBoundary>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TextBoundary> {};

template <>
struct hash<::ax::mojom::TextAlign>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TextAlign> {};

template <>
struct hash<::ax::mojom::WritingDirection>
    : public mojo::internal::EnumHashImpl<::ax::mojom::WritingDirection> {};

template <>
struct hash<::ax::mojom::TextPosition>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TextPosition> {};

template <>
struct hash<::ax::mojom::TextStyle>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TextStyle> {};

template <>
struct hash<::ax::mojom::TextDecorationStyle>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TextDecorationStyle> {};

template <>
struct hash<::ax::mojom::AriaCurrentState>
    : public mojo::internal::EnumHashImpl<::ax::mojom::AriaCurrentState> {};

template <>
struct hash<::ax::mojom::HasPopup>
    : public mojo::internal::EnumHashImpl<::ax::mojom::HasPopup> {};

template <>
struct hash<::ax::mojom::InvalidState>
    : public mojo::internal::EnumHashImpl<::ax::mojom::InvalidState> {};

template <>
struct hash<::ax::mojom::Restriction>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Restriction> {};

template <>
struct hash<::ax::mojom::CheckedState>
    : public mojo::internal::EnumHashImpl<::ax::mojom::CheckedState> {};

template <>
struct hash<::ax::mojom::SortDirection>
    : public mojo::internal::EnumHashImpl<::ax::mojom::SortDirection> {};

template <>
struct hash<::ax::mojom::NameFrom>
    : public mojo::internal::EnumHashImpl<::ax::mojom::NameFrom> {};

template <>
struct hash<::ax::mojom::DescriptionFrom>
    : public mojo::internal::EnumHashImpl<::ax::mojom::DescriptionFrom> {};

template <>
struct hash<::ax::mojom::EventFrom>
    : public mojo::internal::EnumHashImpl<::ax::mojom::EventFrom> {};

template <>
struct hash<::ax::mojom::Gesture>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Gesture> {};

template <>
struct hash<::ax::mojom::TextAffinity>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TextAffinity> {};

template <>
struct hash<::ax::mojom::TreeOrder>
    : public mojo::internal::EnumHashImpl<::ax::mojom::TreeOrder> {};

template <>
struct hash<::ax::mojom::AXTreeIDType>
    : public mojo::internal::EnumHashImpl<::ax::mojom::AXTreeIDType> {};

template <>
struct hash<::ax::mojom::ImageAnnotationStatus>
    : public mojo::internal::EnumHashImpl<::ax::mojom::ImageAnnotationStatus> {};

template <>
struct hash<::ax::mojom::Dropeffect>
    : public mojo::internal::EnumHashImpl<::ax::mojom::Dropeffect> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Event, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Event, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Event>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Role, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Role, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Role>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::State, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::State, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::State>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Action, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Action, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Action>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::ActionFlags, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::ActionFlags, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::ActionFlags>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::ScrollAlignment, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::ScrollAlignment, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::ScrollAlignment>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::ScrollBehavior, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::ScrollBehavior, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::ScrollBehavior>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::DefaultActionVerb, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::DefaultActionVerb, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::DefaultActionVerb>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Mutation, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Mutation, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Mutation>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::StringAttribute, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::StringAttribute, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::StringAttribute>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::IntAttribute, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::IntAttribute, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::IntAttribute>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::FloatAttribute, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::FloatAttribute, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::FloatAttribute>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::BoolAttribute, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::BoolAttribute, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::BoolAttribute>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::IntListAttribute, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::IntListAttribute, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::IntListAttribute>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::StringListAttribute, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::StringListAttribute, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::StringListAttribute>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::ListStyle, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::ListStyle, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::ListStyle>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::MarkerType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::MarkerType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::MarkerType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::HighlightType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::HighlightType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::HighlightType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::MoveDirection, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::MoveDirection, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::MoveDirection>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Command, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Command, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Command>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::InputEventType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::InputEventType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::InputEventType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TextBoundary, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TextBoundary, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TextBoundary>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TextAlign, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TextAlign, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TextAlign>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::WritingDirection, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::WritingDirection, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::WritingDirection>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TextPosition, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TextPosition, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TextPosition>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TextStyle, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TextStyle, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TextStyle>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TextDecorationStyle, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TextDecorationStyle, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TextDecorationStyle>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::AriaCurrentState, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::AriaCurrentState, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::AriaCurrentState>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::HasPopup, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::HasPopup, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::HasPopup>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::InvalidState, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::InvalidState, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::InvalidState>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Restriction, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Restriction, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Restriction>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::CheckedState, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::CheckedState, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::CheckedState>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::SortDirection, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::SortDirection, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::SortDirection>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::NameFrom, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::NameFrom, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::NameFrom>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::DescriptionFrom, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::DescriptionFrom, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::DescriptionFrom>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::EventFrom, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::EventFrom, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::EventFrom>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Gesture, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Gesture, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Gesture>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TextAffinity, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TextAffinity, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TextAffinity>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::TreeOrder, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::TreeOrder, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::TreeOrder>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::AXTreeIDType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::AXTreeIDType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::AXTreeIDType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::ImageAnnotationStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::ImageAnnotationStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::ImageAnnotationStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::ax::mojom::Dropeffect, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::ax::mojom::Dropeffect, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::ax::mojom::Dropeffect>(input)), output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace ax {
namespace mojom {


}  // namespace mojom
}  // namespace ax

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Event> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Event value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Role> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Role value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::State> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::State value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Action> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Action value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::ActionFlags> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::ActionFlags value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::ScrollAlignment> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::ScrollAlignment value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::ScrollBehavior> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::ScrollBehavior value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::DefaultActionVerb> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::DefaultActionVerb value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Mutation> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Mutation value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::StringAttribute> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::StringAttribute value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::IntAttribute> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::IntAttribute value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::FloatAttribute> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::FloatAttribute value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::BoolAttribute> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::BoolAttribute value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::IntListAttribute> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::IntListAttribute value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::StringListAttribute> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::StringListAttribute value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::ListStyle> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::ListStyle value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::MarkerType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::MarkerType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::HighlightType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::HighlightType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::MoveDirection> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::MoveDirection value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Command> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Command value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::InputEventType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::InputEventType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TextBoundary> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TextBoundary value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TextAlign> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TextAlign value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::WritingDirection> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::WritingDirection value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TextPosition> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TextPosition value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TextStyle> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TextStyle value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TextDecorationStyle> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TextDecorationStyle value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::AriaCurrentState> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::AriaCurrentState value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::HasPopup> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::HasPopup value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::InvalidState> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::InvalidState value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Restriction> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Restriction value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::CheckedState> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::CheckedState value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::SortDirection> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::SortDirection value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::NameFrom> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::NameFrom value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::DescriptionFrom> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::DescriptionFrom value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::EventFrom> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::EventFrom value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Gesture> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Gesture value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TextAffinity> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TextAffinity value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::TreeOrder> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::TreeOrder value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::AXTreeIDType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::AXTreeIDType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::ImageAnnotationStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::ImageAnnotationStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(UI_ACCESSIBILITY_AX_MOJOM_SHARED) TraceFormatTraits<::ax::mojom::Dropeffect> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::ax::mojom::Dropeffect value);
};

} // namespace perfetto

#endif  // UI_ACCESSIBILITY_AX_ENUMS_MOJOM_SHARED_H_