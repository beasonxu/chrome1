// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: prediction_service_messages.proto

#include "prediction_service_messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace permissions {
PROTOBUF_CONSTEXPR SiteFeatures::SiteFeatures(
    ::_pbi::ConstantInitialized){}
struct SiteFeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SiteFeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SiteFeaturesDefaultTypeInternal() {}
  union {
    SiteFeatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SiteFeaturesDefaultTypeInternal _SiteFeatures_default_instance_;
PROTOBUF_CONSTEXPR StatsFeatures::StatsFeatures(
    ::_pbi::ConstantInitialized)
  : avg_deny_rate_(0)
  , avg_grant_rate_(0)
  , avg_dismiss_rate_(0)
  , avg_ignore_rate_(0)
  , prompts_count_(0){}
struct StatsFeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsFeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsFeaturesDefaultTypeInternal() {}
  union {
    StatsFeatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsFeaturesDefaultTypeInternal _StatsFeatures_default_instance_;
PROTOBUF_CONSTEXPR ClientFeatures::ClientFeatures(
    ::_pbi::ConstantInitialized)
  : client_stats_(nullptr)
  , platform_(0)

  , gesture_(0)

  , gesture_enum_(0)

  , platform_enum_(0)
{}
struct ClientFeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientFeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientFeaturesDefaultTypeInternal() {}
  union {
    ClientFeatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientFeaturesDefaultTypeInternal _ClientFeatures_default_instance_;
PROTOBUF_CONSTEXPR PermissionFeatures_NotificationPermission::PermissionFeatures_NotificationPermission(
    ::_pbi::ConstantInitialized){}
struct PermissionFeatures_NotificationPermissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionFeatures_NotificationPermissionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionFeatures_NotificationPermissionDefaultTypeInternal() {}
  union {
    PermissionFeatures_NotificationPermission _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionFeatures_NotificationPermissionDefaultTypeInternal _PermissionFeatures_NotificationPermission_default_instance_;
PROTOBUF_CONSTEXPR PermissionFeatures_GeolocationPermission::PermissionFeatures_GeolocationPermission(
    ::_pbi::ConstantInitialized){}
struct PermissionFeatures_GeolocationPermissionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionFeatures_GeolocationPermissionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionFeatures_GeolocationPermissionDefaultTypeInternal() {}
  union {
    PermissionFeatures_GeolocationPermission _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionFeatures_GeolocationPermissionDefaultTypeInternal _PermissionFeatures_GeolocationPermission_default_instance_;
PROTOBUF_CONSTEXPR PermissionFeatures::PermissionFeatures(
    ::_pbi::ConstantInitialized)
  : permission_stats_(nullptr)
  , _oneof_case_{}{}
struct PermissionFeaturesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionFeaturesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionFeaturesDefaultTypeInternal() {}
  union {
    PermissionFeatures _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionFeaturesDefaultTypeInternal _PermissionFeatures_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction_NotificationPrediction::PermissionPrediction_NotificationPrediction(
    ::_pbi::ConstantInitialized){}
struct PermissionPrediction_NotificationPredictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionPrediction_NotificationPredictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionPrediction_NotificationPredictionDefaultTypeInternal() {}
  union {
    PermissionPrediction_NotificationPrediction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPrediction_NotificationPredictionDefaultTypeInternal _PermissionPrediction_NotificationPrediction_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction_GeolocationPrediction::PermissionPrediction_GeolocationPrediction(
    ::_pbi::ConstantInitialized){}
struct PermissionPrediction_GeolocationPredictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionPrediction_GeolocationPredictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionPrediction_GeolocationPredictionDefaultTypeInternal() {}
  union {
    PermissionPrediction_GeolocationPrediction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPrediction_GeolocationPredictionDefaultTypeInternal _PermissionPrediction_GeolocationPrediction_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction_Likelihood::PermissionPrediction_Likelihood(
    ::_pbi::ConstantInitialized)
  : discretized_likelihood_(0)
{}
struct PermissionPrediction_LikelihoodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionPrediction_LikelihoodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionPrediction_LikelihoodDefaultTypeInternal() {}
  union {
    PermissionPrediction_Likelihood _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPrediction_LikelihoodDefaultTypeInternal _PermissionPrediction_Likelihood_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction::PermissionPrediction(
    ::_pbi::ConstantInitialized)
  : grant_likelihood_(nullptr)
  , _oneof_case_{}{}
struct PermissionPredictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionPredictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionPredictionDefaultTypeInternal() {}
  union {
    PermissionPrediction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPredictionDefaultTypeInternal _PermissionPrediction_default_instance_;
PROTOBUF_CONSTEXPR GeneratePredictionsRequest::GeneratePredictionsRequest(
    ::_pbi::ConstantInitialized)
  : permission_features_()
  , client_features_(nullptr)
  , site_features_(nullptr){}
struct GeneratePredictionsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeneratePredictionsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeneratePredictionsRequestDefaultTypeInternal() {}
  union {
    GeneratePredictionsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeneratePredictionsRequestDefaultTypeInternal _GeneratePredictionsRequest_default_instance_;
PROTOBUF_CONSTEXPR GeneratePredictionsResponse::GeneratePredictionsResponse(
    ::_pbi::ConstantInitialized)
  : prediction_(){}
struct GeneratePredictionsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeneratePredictionsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeneratePredictionsResponseDefaultTypeInternal() {}
  union {
    GeneratePredictionsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeneratePredictionsResponseDefaultTypeInternal _GeneratePredictionsResponse_default_instance_;
}  // namespace permissions
namespace permissions {
bool ClientFeatures_Platform_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_Platform_strings[3] = {};

static const char ClientFeatures_Platform_names[] =
  "PLATFORM_DESKTOP"
  "PLATFORM_MOBILE"
  "PLATFORM_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_Platform_entries[] = {
  { {ClientFeatures_Platform_names + 0, 16}, 2 },
  { {ClientFeatures_Platform_names + 16, 15}, 1 },
  { {ClientFeatures_Platform_names + 31, 20}, 0 },
};

static const int ClientFeatures_Platform_entries_by_number[] = {
  2, // 0 -> PLATFORM_UNSPECIFIED
  1, // 1 -> PLATFORM_MOBILE
  0, // 2 -> PLATFORM_DESKTOP
};

const std::string& ClientFeatures_Platform_Name(
    ClientFeatures_Platform value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFeatures_Platform_entries,
          ClientFeatures_Platform_entries_by_number,
          3, ClientFeatures_Platform_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFeatures_Platform_entries,
      ClientFeatures_Platform_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFeatures_Platform_strings[idx].get();
}
bool ClientFeatures_Platform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_Platform* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFeatures_Platform_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientFeatures_Platform>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_Platform ClientFeatures::PLATFORM_UNSPECIFIED;
constexpr ClientFeatures_Platform ClientFeatures::PLATFORM_MOBILE;
constexpr ClientFeatures_Platform ClientFeatures::PLATFORM_DESKTOP;
constexpr ClientFeatures_Platform ClientFeatures::Platform_MIN;
constexpr ClientFeatures_Platform ClientFeatures::Platform_MAX;
constexpr int ClientFeatures::Platform_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientFeatures_Gesture_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_Gesture_strings[3] = {};

static const char ClientFeatures_Gesture_names[] =
  "GESTURE"
  "GESTURE_UNSPECIFIED"
  "NO_GESTURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_Gesture_entries[] = {
  { {ClientFeatures_Gesture_names + 0, 7}, 2 },
  { {ClientFeatures_Gesture_names + 7, 19}, 0 },
  { {ClientFeatures_Gesture_names + 26, 10}, 1 },
};

static const int ClientFeatures_Gesture_entries_by_number[] = {
  1, // 0 -> GESTURE_UNSPECIFIED
  2, // 1 -> NO_GESTURE
  0, // 2 -> GESTURE
};

const std::string& ClientFeatures_Gesture_Name(
    ClientFeatures_Gesture value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFeatures_Gesture_entries,
          ClientFeatures_Gesture_entries_by_number,
          3, ClientFeatures_Gesture_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFeatures_Gesture_entries,
      ClientFeatures_Gesture_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFeatures_Gesture_strings[idx].get();
}
bool ClientFeatures_Gesture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_Gesture* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFeatures_Gesture_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientFeatures_Gesture>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_Gesture ClientFeatures::GESTURE_UNSPECIFIED;
constexpr ClientFeatures_Gesture ClientFeatures::NO_GESTURE;
constexpr ClientFeatures_Gesture ClientFeatures::GESTURE;
constexpr ClientFeatures_Gesture ClientFeatures::Gesture_MIN;
constexpr ClientFeatures_Gesture ClientFeatures::Gesture_MAX;
constexpr int ClientFeatures::Gesture_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientFeatures_GestureEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_GestureEnum_strings[2] = {};

static const char ClientFeatures_GestureEnum_names[] =
  "GESTURE_UNSPECIFIED_V2"
  "GESTURE_V2";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_GestureEnum_entries[] = {
  { {ClientFeatures_GestureEnum_names + 0, 22}, 1 },
  { {ClientFeatures_GestureEnum_names + 22, 10}, 0 },
};

static const int ClientFeatures_GestureEnum_entries_by_number[] = {
  1, // 0 -> GESTURE_V2
  0, // 1 -> GESTURE_UNSPECIFIED_V2
};

const std::string& ClientFeatures_GestureEnum_Name(
    ClientFeatures_GestureEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFeatures_GestureEnum_entries,
          ClientFeatures_GestureEnum_entries_by_number,
          2, ClientFeatures_GestureEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFeatures_GestureEnum_entries,
      ClientFeatures_GestureEnum_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFeatures_GestureEnum_strings[idx].get();
}
bool ClientFeatures_GestureEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_GestureEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFeatures_GestureEnum_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ClientFeatures_GestureEnum>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_GestureEnum ClientFeatures::GESTURE_V2;
constexpr ClientFeatures_GestureEnum ClientFeatures::GESTURE_UNSPECIFIED_V2;
constexpr ClientFeatures_GestureEnum ClientFeatures::GestureEnum_MIN;
constexpr ClientFeatures_GestureEnum ClientFeatures::GestureEnum_MAX;
constexpr int ClientFeatures::GestureEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientFeatures_PlatformEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_PlatformEnum_strings[3] = {};

static const char ClientFeatures_PlatformEnum_names[] =
  "PLATFORM_DESKTOP_V2"
  "PLATFORM_MOBILE_V2"
  "PLATFORM_UNSPECIFIED_V2";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_PlatformEnum_entries[] = {
  { {ClientFeatures_PlatformEnum_names + 0, 19}, 1 },
  { {ClientFeatures_PlatformEnum_names + 19, 18}, 0 },
  { {ClientFeatures_PlatformEnum_names + 37, 23}, 3 },
};

static const int ClientFeatures_PlatformEnum_entries_by_number[] = {
  1, // 0 -> PLATFORM_MOBILE_V2
  0, // 1 -> PLATFORM_DESKTOP_V2
  2, // 3 -> PLATFORM_UNSPECIFIED_V2
};

const std::string& ClientFeatures_PlatformEnum_Name(
    ClientFeatures_PlatformEnum value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientFeatures_PlatformEnum_entries,
          ClientFeatures_PlatformEnum_entries_by_number,
          3, ClientFeatures_PlatformEnum_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientFeatures_PlatformEnum_entries,
      ClientFeatures_PlatformEnum_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientFeatures_PlatformEnum_strings[idx].get();
}
bool ClientFeatures_PlatformEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_PlatformEnum* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientFeatures_PlatformEnum_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientFeatures_PlatformEnum>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_PlatformEnum ClientFeatures::PLATFORM_MOBILE_V2;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PLATFORM_DESKTOP_V2;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PLATFORM_UNSPECIFIED_V2;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PlatformEnum_MIN;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PlatformEnum_MAX;
constexpr int ClientFeatures::PlatformEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PermissionPrediction_Likelihood_DiscretizedLikelihood_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PermissionPrediction_Likelihood_DiscretizedLikelihood_strings[6] = {};

static const char PermissionPrediction_Likelihood_DiscretizedLikelihood_names[] =
  "DISCRETIZED_LIKELIHOOD_UNSPECIFIED"
  "LIKELY"
  "NEUTRAL"
  "UNLIKELY"
  "VERY_LIKELY"
  "VERY_UNLIKELY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PermissionPrediction_Likelihood_DiscretizedLikelihood_entries[] = {
  { {PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 0, 34}, 0 },
  { {PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 34, 6}, 4 },
  { {PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 40, 7}, 3 },
  { {PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 47, 8}, 2 },
  { {PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 55, 11}, 5 },
  { {PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 66, 13}, 1 },
};

static const int PermissionPrediction_Likelihood_DiscretizedLikelihood_entries_by_number[] = {
  0, // 0 -> DISCRETIZED_LIKELIHOOD_UNSPECIFIED
  5, // 1 -> VERY_UNLIKELY
  3, // 2 -> UNLIKELY
  2, // 3 -> NEUTRAL
  1, // 4 -> LIKELY
  4, // 5 -> VERY_LIKELY
};

const std::string& PermissionPrediction_Likelihood_DiscretizedLikelihood_Name(
    PermissionPrediction_Likelihood_DiscretizedLikelihood value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PermissionPrediction_Likelihood_DiscretizedLikelihood_entries,
          PermissionPrediction_Likelihood_DiscretizedLikelihood_entries_by_number,
          6, PermissionPrediction_Likelihood_DiscretizedLikelihood_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PermissionPrediction_Likelihood_DiscretizedLikelihood_entries,
      PermissionPrediction_Likelihood_DiscretizedLikelihood_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PermissionPrediction_Likelihood_DiscretizedLikelihood_strings[idx].get();
}
bool PermissionPrediction_Likelihood_DiscretizedLikelihood_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionPrediction_Likelihood_DiscretizedLikelihood* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PermissionPrediction_Likelihood_DiscretizedLikelihood_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<PermissionPrediction_Likelihood_DiscretizedLikelihood>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::DISCRETIZED_LIKELIHOOD_UNSPECIFIED;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::VERY_UNLIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::UNLIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::NEUTRAL;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::LIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::VERY_LIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::DiscretizedLikelihood_MIN;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::DiscretizedLikelihood_MAX;
constexpr int PermissionPrediction_Likelihood::DiscretizedLikelihood_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SiteFeatures::_Internal {
 public:
};

SiteFeatures::SiteFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.SiteFeatures)
}
SiteFeatures::SiteFeatures(const SiteFeatures& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:permissions.SiteFeatures)
}

inline void SiteFeatures::SharedCtor() {
}

SiteFeatures::~SiteFeatures() {
  // @@protoc_insertion_point(destructor:permissions.SiteFeatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SiteFeatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SiteFeatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SiteFeatures::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.SiteFeatures)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SiteFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SiteFeatures::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.SiteFeatures)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.SiteFeatures)
  return target;
}

size_t SiteFeatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.SiteFeatures)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SiteFeatures::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SiteFeatures*>(
      &from));
}

void SiteFeatures::MergeFrom(const SiteFeatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.SiteFeatures)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SiteFeatures::CopyFrom(const SiteFeatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.SiteFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SiteFeatures::IsInitialized() const {
  return true;
}

void SiteFeatures::InternalSwap(SiteFeatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SiteFeatures::GetTypeName() const {
  return "permissions.SiteFeatures";
}


// ===================================================================

class StatsFeatures::_Internal {
 public:
  using HasBits = decltype(std::declval<StatsFeatures>()._has_bits_);
  static void set_has_avg_deny_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avg_grant_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avg_dismiss_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_avg_ignore_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_prompts_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

StatsFeatures::StatsFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.StatsFeatures)
}
StatsFeatures::StatsFeatures(const StatsFeatures& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&avg_deny_rate_, &from.avg_deny_rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&prompts_count_) -
    reinterpret_cast<char*>(&avg_deny_rate_)) + sizeof(prompts_count_));
  // @@protoc_insertion_point(copy_constructor:permissions.StatsFeatures)
}

inline void StatsFeatures::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&avg_deny_rate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&prompts_count_) -
    reinterpret_cast<char*>(&avg_deny_rate_)) + sizeof(prompts_count_));
}

StatsFeatures::~StatsFeatures() {
  // @@protoc_insertion_point(destructor:permissions.StatsFeatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsFeatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatsFeatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatsFeatures::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.StatsFeatures)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&avg_deny_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&prompts_count_) -
        reinterpret_cast<char*>(&avg_deny_rate_)) + sizeof(prompts_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StatsFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float avg_deny_rate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_avg_deny_rate(&has_bits);
          avg_deny_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_grant_rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_avg_grant_rate(&has_bits);
          avg_grant_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_dismiss_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_avg_dismiss_rate(&has_bits);
          avg_dismiss_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_ignore_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_avg_ignore_rate(&has_bits);
          avg_ignore_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 prompts_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_prompts_count(&has_bits);
          prompts_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsFeatures::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.StatsFeatures)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float avg_deny_rate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_avg_deny_rate(), target);
  }

  // optional float avg_grant_rate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_avg_grant_rate(), target);
  }

  // optional float avg_dismiss_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_avg_dismiss_rate(), target);
  }

  // optional float avg_ignore_rate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_avg_ignore_rate(), target);
  }

  // optional int32 prompts_count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_prompts_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.StatsFeatures)
  return target;
}

size_t StatsFeatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.StatsFeatures)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float avg_deny_rate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float avg_grant_rate = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float avg_dismiss_rate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float avg_ignore_rate = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 prompts_count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prompts_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatsFeatures::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StatsFeatures*>(
      &from));
}

void StatsFeatures::MergeFrom(const StatsFeatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.StatsFeatures)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      avg_deny_rate_ = from.avg_deny_rate_;
    }
    if (cached_has_bits & 0x00000002u) {
      avg_grant_rate_ = from.avg_grant_rate_;
    }
    if (cached_has_bits & 0x00000004u) {
      avg_dismiss_rate_ = from.avg_dismiss_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      avg_ignore_rate_ = from.avg_ignore_rate_;
    }
    if (cached_has_bits & 0x00000010u) {
      prompts_count_ = from.prompts_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatsFeatures::CopyFrom(const StatsFeatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.StatsFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsFeatures::IsInitialized() const {
  return true;
}

void StatsFeatures::InternalSwap(StatsFeatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatsFeatures, prompts_count_)
      + sizeof(StatsFeatures::prompts_count_)
      - PROTOBUF_FIELD_OFFSET(StatsFeatures, avg_deny_rate_)>(
          reinterpret_cast<char*>(&avg_deny_rate_),
          reinterpret_cast<char*>(&other->avg_deny_rate_));
}

std::string StatsFeatures::GetTypeName() const {
  return "permissions.StatsFeatures";
}


// ===================================================================

class ClientFeatures::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientFeatures>()._has_bits_);
  static const ::permissions::StatsFeatures& client_stats(const ClientFeatures* msg);
  static void set_has_client_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_gesture(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gesture_enum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_enum(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::permissions::StatsFeatures&
ClientFeatures::_Internal::client_stats(const ClientFeatures* msg) {
  return *msg->client_stats_;
}
ClientFeatures::ClientFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.ClientFeatures)
}
ClientFeatures::ClientFeatures(const ClientFeatures& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client_stats()) {
    client_stats_ = new ::permissions::StatsFeatures(*from.client_stats_);
  } else {
    client_stats_ = nullptr;
  }
  ::memcpy(&platform_, &from.platform_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_enum_) -
    reinterpret_cast<char*>(&platform_)) + sizeof(platform_enum_));
  // @@protoc_insertion_point(copy_constructor:permissions.ClientFeatures)
}

inline void ClientFeatures::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_stats_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&platform_enum_) -
    reinterpret_cast<char*>(&client_stats_)) + sizeof(platform_enum_));
}

ClientFeatures::~ClientFeatures() {
  // @@protoc_insertion_point(destructor:permissions.ClientFeatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientFeatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_stats_;
}

void ClientFeatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientFeatures::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.ClientFeatures)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(client_stats_ != nullptr);
    client_stats_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&platform_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&platform_enum_) -
        reinterpret_cast<char*>(&platform_)) + sizeof(platform_enum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .permissions.StatsFeatures client_stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .permissions.ClientFeatures.Platform platform = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_Platform_IsValid(val))) {
            _internal_set_platform(static_cast<::permissions::ClientFeatures_Platform>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .permissions.ClientFeatures.Gesture gesture = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_Gesture_IsValid(val))) {
            _internal_set_gesture(static_cast<::permissions::ClientFeatures_Gesture>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .permissions.ClientFeatures.GestureEnum gesture_enum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_GestureEnum_IsValid(val))) {
            _internal_set_gesture_enum(static_cast<::permissions::ClientFeatures_GestureEnum>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .permissions.ClientFeatures.PlatformEnum platform_enum = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_PlatformEnum_IsValid(val))) {
            _internal_set_platform_enum(static_cast<::permissions::ClientFeatures_PlatformEnum>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientFeatures::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.ClientFeatures)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .permissions.StatsFeatures client_stats = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client_stats(this),
        _Internal::client_stats(this).GetCachedSize(), target, stream);
  }

  // optional .permissions.ClientFeatures.Platform platform = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform(), target);
  }

  // optional .permissions.ClientFeatures.Gesture gesture = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_gesture(), target);
  }

  // optional .permissions.ClientFeatures.GestureEnum gesture_enum = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_gesture_enum(), target);
  }

  // optional .permissions.ClientFeatures.PlatformEnum platform_enum = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_platform_enum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.ClientFeatures)
  return target;
}

size_t ClientFeatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.ClientFeatures)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .permissions.StatsFeatures client_stats = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_stats_);
    }

    // optional .permissions.ClientFeatures.Platform platform = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
    }

    // optional .permissions.ClientFeatures.Gesture gesture = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_gesture());
    }

    // optional .permissions.ClientFeatures.GestureEnum gesture_enum = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_gesture_enum());
    }

    // optional .permissions.ClientFeatures.PlatformEnum platform_enum = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_enum());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientFeatures::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientFeatures*>(
      &from));
}

void ClientFeatures::MergeFrom(const ClientFeatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.ClientFeatures)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client_stats()->::permissions::StatsFeatures::MergeFrom(from._internal_client_stats());
    }
    if (cached_has_bits & 0x00000002u) {
      platform_ = from.platform_;
    }
    if (cached_has_bits & 0x00000004u) {
      gesture_ = from.gesture_;
    }
    if (cached_has_bits & 0x00000008u) {
      gesture_enum_ = from.gesture_enum_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_enum_ = from.platform_enum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientFeatures::CopyFrom(const ClientFeatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.ClientFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientFeatures::IsInitialized() const {
  return true;
}

void ClientFeatures::InternalSwap(ClientFeatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientFeatures, platform_enum_)
      + sizeof(ClientFeatures::platform_enum_)
      - PROTOBUF_FIELD_OFFSET(ClientFeatures, client_stats_)>(
          reinterpret_cast<char*>(&client_stats_),
          reinterpret_cast<char*>(&other->client_stats_));
}

std::string ClientFeatures::GetTypeName() const {
  return "permissions.ClientFeatures";
}


// ===================================================================

class PermissionFeatures_NotificationPermission::_Internal {
 public:
};

PermissionFeatures_NotificationPermission::PermissionFeatures_NotificationPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionFeatures.NotificationPermission)
}
PermissionFeatures_NotificationPermission::PermissionFeatures_NotificationPermission(const PermissionFeatures_NotificationPermission& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionFeatures.NotificationPermission)
}

inline void PermissionFeatures_NotificationPermission::SharedCtor() {
}

PermissionFeatures_NotificationPermission::~PermissionFeatures_NotificationPermission() {
  // @@protoc_insertion_point(destructor:permissions.PermissionFeatures.NotificationPermission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionFeatures_NotificationPermission::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionFeatures_NotificationPermission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionFeatures_NotificationPermission::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionFeatures.NotificationPermission)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PermissionFeatures_NotificationPermission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionFeatures_NotificationPermission::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionFeatures.NotificationPermission)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionFeatures.NotificationPermission)
  return target;
}

size_t PermissionFeatures_NotificationPermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionFeatures.NotificationPermission)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionFeatures_NotificationPermission::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionFeatures_NotificationPermission*>(
      &from));
}

void PermissionFeatures_NotificationPermission::MergeFrom(const PermissionFeatures_NotificationPermission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionFeatures.NotificationPermission)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionFeatures_NotificationPermission::CopyFrom(const PermissionFeatures_NotificationPermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionFeatures.NotificationPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionFeatures_NotificationPermission::IsInitialized() const {
  return true;
}

void PermissionFeatures_NotificationPermission::InternalSwap(PermissionFeatures_NotificationPermission* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionFeatures_NotificationPermission::GetTypeName() const {
  return "permissions.PermissionFeatures.NotificationPermission";
}


// ===================================================================

class PermissionFeatures_GeolocationPermission::_Internal {
 public:
};

PermissionFeatures_GeolocationPermission::PermissionFeatures_GeolocationPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionFeatures.GeolocationPermission)
}
PermissionFeatures_GeolocationPermission::PermissionFeatures_GeolocationPermission(const PermissionFeatures_GeolocationPermission& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionFeatures.GeolocationPermission)
}

inline void PermissionFeatures_GeolocationPermission::SharedCtor() {
}

PermissionFeatures_GeolocationPermission::~PermissionFeatures_GeolocationPermission() {
  // @@protoc_insertion_point(destructor:permissions.PermissionFeatures.GeolocationPermission)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionFeatures_GeolocationPermission::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionFeatures_GeolocationPermission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionFeatures_GeolocationPermission::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionFeatures.GeolocationPermission)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PermissionFeatures_GeolocationPermission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionFeatures_GeolocationPermission::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionFeatures.GeolocationPermission)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionFeatures.GeolocationPermission)
  return target;
}

size_t PermissionFeatures_GeolocationPermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionFeatures.GeolocationPermission)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionFeatures_GeolocationPermission::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionFeatures_GeolocationPermission*>(
      &from));
}

void PermissionFeatures_GeolocationPermission::MergeFrom(const PermissionFeatures_GeolocationPermission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionFeatures.GeolocationPermission)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionFeatures_GeolocationPermission::CopyFrom(const PermissionFeatures_GeolocationPermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionFeatures.GeolocationPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionFeatures_GeolocationPermission::IsInitialized() const {
  return true;
}

void PermissionFeatures_GeolocationPermission::InternalSwap(PermissionFeatures_GeolocationPermission* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionFeatures_GeolocationPermission::GetTypeName() const {
  return "permissions.PermissionFeatures.GeolocationPermission";
}


// ===================================================================

class PermissionFeatures::_Internal {
 public:
  using HasBits = decltype(std::declval<PermissionFeatures>()._has_bits_);
  static const ::permissions::StatsFeatures& permission_stats(const PermissionFeatures* msg);
  static void set_has_permission_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::permissions::PermissionFeatures_NotificationPermission& notification_permission(const PermissionFeatures* msg);
  static const ::permissions::PermissionFeatures_GeolocationPermission& geolocation_permission(const PermissionFeatures* msg);
};

const ::permissions::StatsFeatures&
PermissionFeatures::_Internal::permission_stats(const PermissionFeatures* msg) {
  return *msg->permission_stats_;
}
const ::permissions::PermissionFeatures_NotificationPermission&
PermissionFeatures::_Internal::notification_permission(const PermissionFeatures* msg) {
  return *msg->permission_type_.notification_permission_;
}
const ::permissions::PermissionFeatures_GeolocationPermission&
PermissionFeatures::_Internal::geolocation_permission(const PermissionFeatures* msg) {
  return *msg->permission_type_.geolocation_permission_;
}
void PermissionFeatures::set_allocated_notification_permission(::permissions::PermissionFeatures_NotificationPermission* notification_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_permission_type();
  if (notification_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notification_permission);
    if (message_arena != submessage_arena) {
      notification_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notification_permission, submessage_arena);
    }
    set_has_notification_permission();
    permission_type_.notification_permission_ = notification_permission;
  }
  // @@protoc_insertion_point(field_set_allocated:permissions.PermissionFeatures.notification_permission)
}
void PermissionFeatures::set_allocated_geolocation_permission(::permissions::PermissionFeatures_GeolocationPermission* geolocation_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_permission_type();
  if (geolocation_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geolocation_permission);
    if (message_arena != submessage_arena) {
      geolocation_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geolocation_permission, submessage_arena);
    }
    set_has_geolocation_permission();
    permission_type_.geolocation_permission_ = geolocation_permission;
  }
  // @@protoc_insertion_point(field_set_allocated:permissions.PermissionFeatures.geolocation_permission)
}
PermissionFeatures::PermissionFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionFeatures)
}
PermissionFeatures::PermissionFeatures(const PermissionFeatures& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_permission_stats()) {
    permission_stats_ = new ::permissions::StatsFeatures(*from.permission_stats_);
  } else {
    permission_stats_ = nullptr;
  }
  clear_has_permission_type();
  switch (from.permission_type_case()) {
    case kNotificationPermission: {
      _internal_mutable_notification_permission()->::permissions::PermissionFeatures_NotificationPermission::MergeFrom(from._internal_notification_permission());
      break;
    }
    case kGeolocationPermission: {
      _internal_mutable_geolocation_permission()->::permissions::PermissionFeatures_GeolocationPermission::MergeFrom(from._internal_geolocation_permission());
      break;
    }
    case PERMISSION_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionFeatures)
}

inline void PermissionFeatures::SharedCtor() {
permission_stats_ = nullptr;
clear_has_permission_type();
}

PermissionFeatures::~PermissionFeatures() {
  // @@protoc_insertion_point(destructor:permissions.PermissionFeatures)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionFeatures::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete permission_stats_;
  if (has_permission_type()) {
    clear_permission_type();
  }
}

void PermissionFeatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionFeatures::clear_permission_type() {
// @@protoc_insertion_point(one_of_clear_start:permissions.PermissionFeatures)
  switch (permission_type_case()) {
    case kNotificationPermission: {
      if (GetArenaForAllocation() == nullptr) {
        delete permission_type_.notification_permission_;
      }
      break;
    }
    case kGeolocationPermission: {
      if (GetArenaForAllocation() == nullptr) {
        delete permission_type_.geolocation_permission_;
      }
      break;
    }
    case PERMISSION_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PERMISSION_TYPE_NOT_SET;
}


void PermissionFeatures::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionFeatures)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(permission_stats_ != nullptr);
    permission_stats_->Clear();
  }
  clear_permission_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PermissionFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .permissions.StatsFeatures permission_stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_permission_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .permissions.PermissionFeatures.NotificationPermission notification_permission = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_notification_permission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .permissions.PermissionFeatures.GeolocationPermission geolocation_permission = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_geolocation_permission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionFeatures::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionFeatures)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .permissions.StatsFeatures permission_stats = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::permission_stats(this),
        _Internal::permission_stats(this).GetCachedSize(), target, stream);
  }

  switch (permission_type_case()) {
    case kNotificationPermission: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::notification_permission(this),
          _Internal::notification_permission(this).GetCachedSize(), target, stream);
      break;
    }
    case kGeolocationPermission: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::geolocation_permission(this),
          _Internal::geolocation_permission(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionFeatures)
  return target;
}

size_t PermissionFeatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionFeatures)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .permissions.StatsFeatures permission_stats = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *permission_stats_);
  }

  switch (permission_type_case()) {
    // .permissions.PermissionFeatures.NotificationPermission notification_permission = 2;
    case kNotificationPermission: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *permission_type_.notification_permission_);
      break;
    }
    // .permissions.PermissionFeatures.GeolocationPermission geolocation_permission = 3;
    case kGeolocationPermission: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *permission_type_.geolocation_permission_);
      break;
    }
    case PERMISSION_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionFeatures::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionFeatures*>(
      &from));
}

void PermissionFeatures::MergeFrom(const PermissionFeatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionFeatures)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_permission_stats()) {
    _internal_mutable_permission_stats()->::permissions::StatsFeatures::MergeFrom(from._internal_permission_stats());
  }
  switch (from.permission_type_case()) {
    case kNotificationPermission: {
      _internal_mutable_notification_permission()->::permissions::PermissionFeatures_NotificationPermission::MergeFrom(from._internal_notification_permission());
      break;
    }
    case kGeolocationPermission: {
      _internal_mutable_geolocation_permission()->::permissions::PermissionFeatures_GeolocationPermission::MergeFrom(from._internal_geolocation_permission());
      break;
    }
    case PERMISSION_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionFeatures::CopyFrom(const PermissionFeatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionFeatures::IsInitialized() const {
  return true;
}

void PermissionFeatures::InternalSwap(PermissionFeatures* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(permission_stats_, other->permission_stats_);
  swap(permission_type_, other->permission_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string PermissionFeatures::GetTypeName() const {
  return "permissions.PermissionFeatures";
}


// ===================================================================

class PermissionPrediction_NotificationPrediction::_Internal {
 public:
};

PermissionPrediction_NotificationPrediction::PermissionPrediction_NotificationPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction.NotificationPrediction)
}
PermissionPrediction_NotificationPrediction::PermissionPrediction_NotificationPrediction(const PermissionPrediction_NotificationPrediction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction.NotificationPrediction)
}

inline void PermissionPrediction_NotificationPrediction::SharedCtor() {
}

PermissionPrediction_NotificationPrediction::~PermissionPrediction_NotificationPrediction() {
  // @@protoc_insertion_point(destructor:permissions.PermissionPrediction.NotificationPrediction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionPrediction_NotificationPrediction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionPrediction_NotificationPrediction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionPrediction_NotificationPrediction::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction.NotificationPrediction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction_NotificationPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction_NotificationPrediction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction.NotificationPrediction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction.NotificationPrediction)
  return target;
}

size_t PermissionPrediction_NotificationPrediction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction.NotificationPrediction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionPrediction_NotificationPrediction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionPrediction_NotificationPrediction*>(
      &from));
}

void PermissionPrediction_NotificationPrediction::MergeFrom(const PermissionPrediction_NotificationPrediction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction.NotificationPrediction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction_NotificationPrediction::CopyFrom(const PermissionPrediction_NotificationPrediction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction.NotificationPrediction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionPrediction_NotificationPrediction::IsInitialized() const {
  return true;
}

void PermissionPrediction_NotificationPrediction::InternalSwap(PermissionPrediction_NotificationPrediction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionPrediction_NotificationPrediction::GetTypeName() const {
  return "permissions.PermissionPrediction.NotificationPrediction";
}


// ===================================================================

class PermissionPrediction_GeolocationPrediction::_Internal {
 public:
};

PermissionPrediction_GeolocationPrediction::PermissionPrediction_GeolocationPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction.GeolocationPrediction)
}
PermissionPrediction_GeolocationPrediction::PermissionPrediction_GeolocationPrediction(const PermissionPrediction_GeolocationPrediction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction.GeolocationPrediction)
}

inline void PermissionPrediction_GeolocationPrediction::SharedCtor() {
}

PermissionPrediction_GeolocationPrediction::~PermissionPrediction_GeolocationPrediction() {
  // @@protoc_insertion_point(destructor:permissions.PermissionPrediction.GeolocationPrediction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionPrediction_GeolocationPrediction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionPrediction_GeolocationPrediction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionPrediction_GeolocationPrediction::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction.GeolocationPrediction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction_GeolocationPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction_GeolocationPrediction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction.GeolocationPrediction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction.GeolocationPrediction)
  return target;
}

size_t PermissionPrediction_GeolocationPrediction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction.GeolocationPrediction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionPrediction_GeolocationPrediction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionPrediction_GeolocationPrediction*>(
      &from));
}

void PermissionPrediction_GeolocationPrediction::MergeFrom(const PermissionPrediction_GeolocationPrediction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction.GeolocationPrediction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction_GeolocationPrediction::CopyFrom(const PermissionPrediction_GeolocationPrediction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction.GeolocationPrediction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionPrediction_GeolocationPrediction::IsInitialized() const {
  return true;
}

void PermissionPrediction_GeolocationPrediction::InternalSwap(PermissionPrediction_GeolocationPrediction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionPrediction_GeolocationPrediction::GetTypeName() const {
  return "permissions.PermissionPrediction.GeolocationPrediction";
}


// ===================================================================

class PermissionPrediction_Likelihood::_Internal {
 public:
  using HasBits = decltype(std::declval<PermissionPrediction_Likelihood>()._has_bits_);
  static void set_has_discretized_likelihood(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PermissionPrediction_Likelihood::PermissionPrediction_Likelihood(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction.Likelihood)
}
PermissionPrediction_Likelihood::PermissionPrediction_Likelihood(const PermissionPrediction_Likelihood& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  discretized_likelihood_ = from.discretized_likelihood_;
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction.Likelihood)
}

inline void PermissionPrediction_Likelihood::SharedCtor() {
discretized_likelihood_ = 0;
}

PermissionPrediction_Likelihood::~PermissionPrediction_Likelihood() {
  // @@protoc_insertion_point(destructor:permissions.PermissionPrediction.Likelihood)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionPrediction_Likelihood::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionPrediction_Likelihood::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionPrediction_Likelihood::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction.Likelihood)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  discretized_likelihood_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction_Likelihood::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .permissions.PermissionPrediction.Likelihood.DiscretizedLikelihood discretized_likelihood = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::permissions::PermissionPrediction_Likelihood_DiscretizedLikelihood_IsValid(val))) {
            _internal_set_discretized_likelihood(static_cast<::permissions::PermissionPrediction_Likelihood_DiscretizedLikelihood>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction_Likelihood::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction.Likelihood)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .permissions.PermissionPrediction.Likelihood.DiscretizedLikelihood discretized_likelihood = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_discretized_likelihood(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction.Likelihood)
  return target;
}

size_t PermissionPrediction_Likelihood::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction.Likelihood)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .permissions.PermissionPrediction.Likelihood.DiscretizedLikelihood discretized_likelihood = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_discretized_likelihood());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionPrediction_Likelihood::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionPrediction_Likelihood*>(
      &from));
}

void PermissionPrediction_Likelihood::MergeFrom(const PermissionPrediction_Likelihood& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction.Likelihood)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_discretized_likelihood()) {
    _internal_set_discretized_likelihood(from._internal_discretized_likelihood());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction_Likelihood::CopyFrom(const PermissionPrediction_Likelihood& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction.Likelihood)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionPrediction_Likelihood::IsInitialized() const {
  return true;
}

void PermissionPrediction_Likelihood::InternalSwap(PermissionPrediction_Likelihood* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(discretized_likelihood_, other->discretized_likelihood_);
}

std::string PermissionPrediction_Likelihood::GetTypeName() const {
  return "permissions.PermissionPrediction.Likelihood";
}


// ===================================================================

class PermissionPrediction::_Internal {
 public:
  using HasBits = decltype(std::declval<PermissionPrediction>()._has_bits_);
  static const ::permissions::PermissionPrediction_NotificationPrediction& notification_prediction(const PermissionPrediction* msg);
  static const ::permissions::PermissionPrediction_GeolocationPrediction& geolocation_prediction(const PermissionPrediction* msg);
  static const ::permissions::PermissionPrediction_Likelihood& grant_likelihood(const PermissionPrediction* msg);
  static void set_has_grant_likelihood(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::permissions::PermissionPrediction_NotificationPrediction&
PermissionPrediction::_Internal::notification_prediction(const PermissionPrediction* msg) {
  return *msg->prediction_type_.notification_prediction_;
}
const ::permissions::PermissionPrediction_GeolocationPrediction&
PermissionPrediction::_Internal::geolocation_prediction(const PermissionPrediction* msg) {
  return *msg->prediction_type_.geolocation_prediction_;
}
const ::permissions::PermissionPrediction_Likelihood&
PermissionPrediction::_Internal::grant_likelihood(const PermissionPrediction* msg) {
  return *msg->grant_likelihood_;
}
void PermissionPrediction::set_allocated_notification_prediction(::permissions::PermissionPrediction_NotificationPrediction* notification_prediction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_prediction_type();
  if (notification_prediction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notification_prediction);
    if (message_arena != submessage_arena) {
      notification_prediction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, notification_prediction, submessage_arena);
    }
    set_has_notification_prediction();
    prediction_type_.notification_prediction_ = notification_prediction;
  }
  // @@protoc_insertion_point(field_set_allocated:permissions.PermissionPrediction.notification_prediction)
}
void PermissionPrediction::set_allocated_geolocation_prediction(::permissions::PermissionPrediction_GeolocationPrediction* geolocation_prediction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_prediction_type();
  if (geolocation_prediction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geolocation_prediction);
    if (message_arena != submessage_arena) {
      geolocation_prediction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geolocation_prediction, submessage_arena);
    }
    set_has_geolocation_prediction();
    prediction_type_.geolocation_prediction_ = geolocation_prediction;
  }
  // @@protoc_insertion_point(field_set_allocated:permissions.PermissionPrediction.geolocation_prediction)
}
PermissionPrediction::PermissionPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction)
}
PermissionPrediction::PermissionPrediction(const PermissionPrediction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_grant_likelihood()) {
    grant_likelihood_ = new ::permissions::PermissionPrediction_Likelihood(*from.grant_likelihood_);
  } else {
    grant_likelihood_ = nullptr;
  }
  clear_has_prediction_type();
  switch (from.prediction_type_case()) {
    case kNotificationPrediction: {
      _internal_mutable_notification_prediction()->::permissions::PermissionPrediction_NotificationPrediction::MergeFrom(from._internal_notification_prediction());
      break;
    }
    case kGeolocationPrediction: {
      _internal_mutable_geolocation_prediction()->::permissions::PermissionPrediction_GeolocationPrediction::MergeFrom(from._internal_geolocation_prediction());
      break;
    }
    case PREDICTION_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction)
}

inline void PermissionPrediction::SharedCtor() {
grant_likelihood_ = nullptr;
clear_has_prediction_type();
}

PermissionPrediction::~PermissionPrediction() {
  // @@protoc_insertion_point(destructor:permissions.PermissionPrediction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PermissionPrediction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete grant_likelihood_;
  if (has_prediction_type()) {
    clear_prediction_type();
  }
}

void PermissionPrediction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PermissionPrediction::clear_prediction_type() {
// @@protoc_insertion_point(one_of_clear_start:permissions.PermissionPrediction)
  switch (prediction_type_case()) {
    case kNotificationPrediction: {
      if (GetArenaForAllocation() == nullptr) {
        delete prediction_type_.notification_prediction_;
      }
      break;
    }
    case kGeolocationPrediction: {
      if (GetArenaForAllocation() == nullptr) {
        delete prediction_type_.geolocation_prediction_;
      }
      break;
    }
    case PREDICTION_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PREDICTION_TYPE_NOT_SET;
}


void PermissionPrediction::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(grant_likelihood_ != nullptr);
    grant_likelihood_->Clear();
  }
  clear_prediction_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .permissions.PermissionPrediction.NotificationPrediction notification_prediction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_notification_prediction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .permissions.PermissionPrediction.Likelihood grant_likelihood = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_grant_likelihood(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .permissions.PermissionPrediction.GeolocationPrediction geolocation_prediction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_geolocation_prediction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .permissions.PermissionPrediction.NotificationPrediction notification_prediction = 1;
  if (_internal_has_notification_prediction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::notification_prediction(this),
        _Internal::notification_prediction(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .permissions.PermissionPrediction.Likelihood grant_likelihood = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::grant_likelihood(this),
        _Internal::grant_likelihood(this).GetCachedSize(), target, stream);
  }

  // .permissions.PermissionPrediction.GeolocationPrediction geolocation_prediction = 3;
  if (_internal_has_geolocation_prediction()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::geolocation_prediction(this),
        _Internal::geolocation_prediction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction)
  return target;
}

size_t PermissionPrediction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .permissions.PermissionPrediction.Likelihood grant_likelihood = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *grant_likelihood_);
  }

  switch (prediction_type_case()) {
    // .permissions.PermissionPrediction.NotificationPrediction notification_prediction = 1;
    case kNotificationPrediction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *prediction_type_.notification_prediction_);
      break;
    }
    // .permissions.PermissionPrediction.GeolocationPrediction geolocation_prediction = 3;
    case kGeolocationPrediction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *prediction_type_.geolocation_prediction_);
      break;
    }
    case PREDICTION_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PermissionPrediction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PermissionPrediction*>(
      &from));
}

void PermissionPrediction::MergeFrom(const PermissionPrediction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_grant_likelihood()) {
    _internal_mutable_grant_likelihood()->::permissions::PermissionPrediction_Likelihood::MergeFrom(from._internal_grant_likelihood());
  }
  switch (from.prediction_type_case()) {
    case kNotificationPrediction: {
      _internal_mutable_notification_prediction()->::permissions::PermissionPrediction_NotificationPrediction::MergeFrom(from._internal_notification_prediction());
      break;
    }
    case kGeolocationPrediction: {
      _internal_mutable_geolocation_prediction()->::permissions::PermissionPrediction_GeolocationPrediction::MergeFrom(from._internal_geolocation_prediction());
      break;
    }
    case PREDICTION_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction::CopyFrom(const PermissionPrediction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PermissionPrediction::IsInitialized() const {
  return true;
}

void PermissionPrediction::InternalSwap(PermissionPrediction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(grant_likelihood_, other->grant_likelihood_);
  swap(prediction_type_, other->prediction_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string PermissionPrediction::GetTypeName() const {
  return "permissions.PermissionPrediction";
}


// ===================================================================

class GeneratePredictionsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GeneratePredictionsRequest>()._has_bits_);
  static const ::permissions::ClientFeatures& client_features(const GeneratePredictionsRequest* msg);
  static void set_has_client_features(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::permissions::SiteFeatures& site_features(const GeneratePredictionsRequest* msg);
  static void set_has_site_features(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::permissions::ClientFeatures&
GeneratePredictionsRequest::_Internal::client_features(const GeneratePredictionsRequest* msg) {
  return *msg->client_features_;
}
const ::permissions::SiteFeatures&
GeneratePredictionsRequest::_Internal::site_features(const GeneratePredictionsRequest* msg) {
  return *msg->site_features_;
}
GeneratePredictionsRequest::GeneratePredictionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  permission_features_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.GeneratePredictionsRequest)
}
GeneratePredictionsRequest::GeneratePredictionsRequest(const GeneratePredictionsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      permission_features_(from.permission_features_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client_features()) {
    client_features_ = new ::permissions::ClientFeatures(*from.client_features_);
  } else {
    client_features_ = nullptr;
  }
  if (from._internal_has_site_features()) {
    site_features_ = new ::permissions::SiteFeatures(*from.site_features_);
  } else {
    site_features_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:permissions.GeneratePredictionsRequest)
}

inline void GeneratePredictionsRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_features_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&site_features_) -
    reinterpret_cast<char*>(&client_features_)) + sizeof(site_features_));
}

GeneratePredictionsRequest::~GeneratePredictionsRequest() {
  // @@protoc_insertion_point(destructor:permissions.GeneratePredictionsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeneratePredictionsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_features_;
  if (this != internal_default_instance()) delete site_features_;
}

void GeneratePredictionsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeneratePredictionsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.GeneratePredictionsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permission_features_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_features_ != nullptr);
      client_features_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(site_features_ != nullptr);
      site_features_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GeneratePredictionsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .permissions.ClientFeatures client_features = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_features(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .permissions.SiteFeatures site_features = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_site_features(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .permissions.PermissionFeatures permission_features = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_permission_features(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeneratePredictionsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.GeneratePredictionsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .permissions.ClientFeatures client_features = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client_features(this),
        _Internal::client_features(this).GetCachedSize(), target, stream);
  }

  // optional .permissions.SiteFeatures site_features = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::site_features(this),
        _Internal::site_features(this).GetCachedSize(), target, stream);
  }

  // repeated .permissions.PermissionFeatures permission_features = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_permission_features_size()); i < n; i++) {
    const auto& repfield = this->_internal_permission_features(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.GeneratePredictionsRequest)
  return target;
}

size_t GeneratePredictionsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.GeneratePredictionsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .permissions.PermissionFeatures permission_features = 3;
  total_size += 1UL * this->_internal_permission_features_size();
  for (const auto& msg : this->permission_features_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .permissions.ClientFeatures client_features = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_features_);
    }

    // optional .permissions.SiteFeatures site_features = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *site_features_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GeneratePredictionsRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GeneratePredictionsRequest*>(
      &from));
}

void GeneratePredictionsRequest::MergeFrom(const GeneratePredictionsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.GeneratePredictionsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  permission_features_.MergeFrom(from.permission_features_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client_features()->::permissions::ClientFeatures::MergeFrom(from._internal_client_features());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_site_features()->::permissions::SiteFeatures::MergeFrom(from._internal_site_features());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeneratePredictionsRequest::CopyFrom(const GeneratePredictionsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.GeneratePredictionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeneratePredictionsRequest::IsInitialized() const {
  return true;
}

void GeneratePredictionsRequest::InternalSwap(GeneratePredictionsRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  permission_features_.InternalSwap(&other->permission_features_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeneratePredictionsRequest, site_features_)
      + sizeof(GeneratePredictionsRequest::site_features_)
      - PROTOBUF_FIELD_OFFSET(GeneratePredictionsRequest, client_features_)>(
          reinterpret_cast<char*>(&client_features_),
          reinterpret_cast<char*>(&other->client_features_));
}

std::string GeneratePredictionsRequest::GetTypeName() const {
  return "permissions.GeneratePredictionsRequest";
}


// ===================================================================

class GeneratePredictionsResponse::_Internal {
 public:
};

GeneratePredictionsResponse::GeneratePredictionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  prediction_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:permissions.GeneratePredictionsResponse)
}
GeneratePredictionsResponse::GeneratePredictionsResponse(const GeneratePredictionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      prediction_(from.prediction_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:permissions.GeneratePredictionsResponse)
}

inline void GeneratePredictionsResponse::SharedCtor() {
}

GeneratePredictionsResponse::~GeneratePredictionsResponse() {
  // @@protoc_insertion_point(destructor:permissions.GeneratePredictionsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeneratePredictionsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GeneratePredictionsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeneratePredictionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:permissions.GeneratePredictionsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  prediction_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GeneratePredictionsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .permissions.PermissionPrediction prediction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prediction(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeneratePredictionsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:permissions.GeneratePredictionsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .permissions.PermissionPrediction prediction = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prediction_size()); i < n; i++) {
    const auto& repfield = this->_internal_prediction(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:permissions.GeneratePredictionsResponse)
  return target;
}

size_t GeneratePredictionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:permissions.GeneratePredictionsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .permissions.PermissionPrediction prediction = 1;
  total_size += 1UL * this->_internal_prediction_size();
  for (const auto& msg : this->prediction_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GeneratePredictionsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GeneratePredictionsResponse*>(
      &from));
}

void GeneratePredictionsResponse::MergeFrom(const GeneratePredictionsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:permissions.GeneratePredictionsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  prediction_.MergeFrom(from.prediction_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeneratePredictionsResponse::CopyFrom(const GeneratePredictionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:permissions.GeneratePredictionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeneratePredictionsResponse::IsInitialized() const {
  return true;
}

void GeneratePredictionsResponse::InternalSwap(GeneratePredictionsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  prediction_.InternalSwap(&other->prediction_);
}

std::string GeneratePredictionsResponse::GetTypeName() const {
  return "permissions.GeneratePredictionsResponse";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace permissions
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::permissions::SiteFeatures*
Arena::CreateMaybeMessage< ::permissions::SiteFeatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::SiteFeatures >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::StatsFeatures*
Arena::CreateMaybeMessage< ::permissions::StatsFeatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::StatsFeatures >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::ClientFeatures*
Arena::CreateMaybeMessage< ::permissions::ClientFeatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::ClientFeatures >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionFeatures_NotificationPermission*
Arena::CreateMaybeMessage< ::permissions::PermissionFeatures_NotificationPermission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionFeatures_NotificationPermission >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionFeatures_GeolocationPermission*
Arena::CreateMaybeMessage< ::permissions::PermissionFeatures_GeolocationPermission >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionFeatures_GeolocationPermission >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionFeatures*
Arena::CreateMaybeMessage< ::permissions::PermissionFeatures >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionFeatures >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionPrediction_NotificationPrediction*
Arena::CreateMaybeMessage< ::permissions::PermissionPrediction_NotificationPrediction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionPrediction_NotificationPrediction >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionPrediction_GeolocationPrediction*
Arena::CreateMaybeMessage< ::permissions::PermissionPrediction_GeolocationPrediction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionPrediction_GeolocationPrediction >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionPrediction_Likelihood*
Arena::CreateMaybeMessage< ::permissions::PermissionPrediction_Likelihood >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionPrediction_Likelihood >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::PermissionPrediction*
Arena::CreateMaybeMessage< ::permissions::PermissionPrediction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::PermissionPrediction >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::GeneratePredictionsRequest*
Arena::CreateMaybeMessage< ::permissions::GeneratePredictionsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::GeneratePredictionsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::permissions::GeneratePredictionsResponse*
Arena::CreateMaybeMessage< ::permissions::GeneratePredictionsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::permissions::GeneratePredictionsResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
