// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CLIENTMODEL_SAFE_BROWSING_FLAT_MATCHRULE__H_
#define FLATBUFFERS_GENERATED_CLIENTMODEL_SAFE_BROWSING_FLAT_MATCHRULE__H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

#include "components/safe_browsing/core/common/fbs/csd_generated.h"

namespace safe_browsing {
namespace flat {

struct Hash;
struct HashBuilder;

struct ClientSideModel;
struct ClientSideModelBuilder;

namespace ClientSideModel_ {

struct Rule;
struct RuleBuilder;

struct IPSubnet;
struct IPSubnetBuilder;

}  // namespace ClientSideModel_

struct TfLiteModelMetadata;
struct TfLiteModelMetadataBuilder;

namespace TfLiteModelMetadata_ {

struct Threshold;
struct ThresholdBuilder;

}  // namespace TfLiteModelMetadata_

struct VisionModel;
struct VisionModelBuilder;

struct VisualTarget;
struct VisualTargetBuilder;

struct MatchConfig;
struct MatchConfigBuilder;

struct MatchRule;
struct MatchRuleBuilder;

namespace MatchRule_ {

struct ColorRange;
struct ColorRangeBuilder;

struct FloatColorRange;
struct FloatColorRangeBuilder;

}  // namespace MatchRule_

struct Hash FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct HashBuilder {
  typedef Hash Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Hash::VT_DATA, data);
  }
  explicit HashBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Hash> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hash>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hash> CreateHash(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  HashBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hash> CreateHashDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return safe_browsing::flat::CreateHash(
      _fbb,
      data__);
}

struct ClientSideModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClientSideModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASHES = 4,
    VT_RULE = 6,
    VT_PAGE_TERM = 8,
    VT_PAGE_WORD = 10,
    VT_MAX_WORDS_PER_TERM = 12,
    VT_VERSION = 14,
    VT_BAD_SUBNET = 16,
    VT_MURMUR_HASH_SEED = 18,
    VT_MAX_SHINGLES_PER_PAGE = 20,
    VT_SHINGLE_SIZE = 22,
    VT_THRESHOLD_PROBABILITY = 24,
    VT_VISION_MODEL = 26,
    VT_TFLITE_METADATA = 36,
    VT_DOM_MODEL_VERSION = 38
  };
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::Hash>> *hashes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::Hash>> *>(VT_HASHES);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::Hash>> *mutable_hashes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::Hash>> *>(VT_HASHES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>> *rule() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>> *>(VT_RULE);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>> *mutable_rule() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>> *>(VT_RULE);
  }
  const flatbuffers::Vector<int32_t> *page_term() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PAGE_TERM);
  }
  flatbuffers::Vector<int32_t> *mutable_page_term() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_PAGE_TERM);
  }
  const flatbuffers::Vector<uint32_t> *page_word() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_PAGE_WORD);
  }
  flatbuffers::Vector<uint32_t> *mutable_page_word() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_PAGE_WORD);
  }
  int32_t max_words_per_term() const {
    return GetField<int32_t>(VT_MAX_WORDS_PER_TERM, 0);
  }
  bool mutate_max_words_per_term(int32_t _max_words_per_term = 0) {
    return SetField<int32_t>(VT_MAX_WORDS_PER_TERM, _max_words_per_term, 0);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  bool mutate_version(int32_t _version = 0) {
    return SetField<int32_t>(VT_VERSION, _version, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>> *bad_subnet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>> *>(VT_BAD_SUBNET);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>> *mutable_bad_subnet() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>> *>(VT_BAD_SUBNET);
  }
  uint32_t murmur_hash_seed() const {
    return GetField<uint32_t>(VT_MURMUR_HASH_SEED, 0);
  }
  bool mutate_murmur_hash_seed(uint32_t _murmur_hash_seed = 0) {
    return SetField<uint32_t>(VT_MURMUR_HASH_SEED, _murmur_hash_seed, 0);
  }
  int32_t max_shingles_per_page() const {
    return GetField<int32_t>(VT_MAX_SHINGLES_PER_PAGE, 200);
  }
  bool mutate_max_shingles_per_page(int32_t _max_shingles_per_page = 200) {
    return SetField<int32_t>(VT_MAX_SHINGLES_PER_PAGE, _max_shingles_per_page, 200);
  }
  int32_t shingle_size() const {
    return GetField<int32_t>(VT_SHINGLE_SIZE, 4);
  }
  bool mutate_shingle_size(int32_t _shingle_size = 4) {
    return SetField<int32_t>(VT_SHINGLE_SIZE, _shingle_size, 4);
  }
  float threshold_probability() const {
    return GetField<float>(VT_THRESHOLD_PROBABILITY, 0.5f);
  }
  bool mutate_threshold_probability(float _threshold_probability = 0.5f) {
    return SetField<float>(VT_THRESHOLD_PROBABILITY, _threshold_probability, 0.5f);
  }
  const safe_browsing::flat::VisionModel *vision_model() const {
    return GetPointer<const safe_browsing::flat::VisionModel *>(VT_VISION_MODEL);
  }
  safe_browsing::flat::VisionModel *mutable_vision_model() {
    return GetPointer<safe_browsing::flat::VisionModel *>(VT_VISION_MODEL);
  }
  const safe_browsing::flat::TfLiteModelMetadata *tflite_metadata() const {
    return GetPointer<const safe_browsing::flat::TfLiteModelMetadata *>(VT_TFLITE_METADATA);
  }
  safe_browsing::flat::TfLiteModelMetadata *mutable_tflite_metadata() {
    return GetPointer<safe_browsing::flat::TfLiteModelMetadata *>(VT_TFLITE_METADATA);
  }
  int32_t dom_model_version() const {
    return GetField<int32_t>(VT_DOM_MODEL_VERSION, 0);
  }
  bool mutate_dom_model_version(int32_t _dom_model_version = 0) {
    return SetField<int32_t>(VT_DOM_MODEL_VERSION, _dom_model_version, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HASHES) &&
           verifier.VerifyVector(hashes()) &&
           verifier.VerifyVectorOfTables(hashes()) &&
           VerifyOffset(verifier, VT_RULE) &&
           verifier.VerifyVector(rule()) &&
           verifier.VerifyVectorOfTables(rule()) &&
           VerifyOffset(verifier, VT_PAGE_TERM) &&
           verifier.VerifyVector(page_term()) &&
           VerifyOffset(verifier, VT_PAGE_WORD) &&
           verifier.VerifyVector(page_word()) &&
           VerifyField<int32_t>(verifier, VT_MAX_WORDS_PER_TERM, 4) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_BAD_SUBNET) &&
           verifier.VerifyVector(bad_subnet()) &&
           verifier.VerifyVectorOfTables(bad_subnet()) &&
           VerifyField<uint32_t>(verifier, VT_MURMUR_HASH_SEED, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_SHINGLES_PER_PAGE, 4) &&
           VerifyField<int32_t>(verifier, VT_SHINGLE_SIZE, 4) &&
           VerifyField<float>(verifier, VT_THRESHOLD_PROBABILITY, 4) &&
           VerifyOffset(verifier, VT_VISION_MODEL) &&
           verifier.VerifyTable(vision_model()) &&
           VerifyOffset(verifier, VT_TFLITE_METADATA) &&
           verifier.VerifyTable(tflite_metadata()) &&
           VerifyField<int32_t>(verifier, VT_DOM_MODEL_VERSION, 4) &&
           verifier.EndTable();
  }
};

struct ClientSideModelBuilder {
  typedef ClientSideModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hashes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::Hash>>> hashes) {
    fbb_.AddOffset(ClientSideModel::VT_HASHES, hashes);
  }
  void add_rule(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>> rule) {
    fbb_.AddOffset(ClientSideModel::VT_RULE, rule);
  }
  void add_page_term(flatbuffers::Offset<flatbuffers::Vector<int32_t>> page_term) {
    fbb_.AddOffset(ClientSideModel::VT_PAGE_TERM, page_term);
  }
  void add_page_word(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> page_word) {
    fbb_.AddOffset(ClientSideModel::VT_PAGE_WORD, page_word);
  }
  void add_max_words_per_term(int32_t max_words_per_term) {
    fbb_.AddElement<int32_t>(ClientSideModel::VT_MAX_WORDS_PER_TERM, max_words_per_term, 0);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(ClientSideModel::VT_VERSION, version, 0);
  }
  void add_bad_subnet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>> bad_subnet) {
    fbb_.AddOffset(ClientSideModel::VT_BAD_SUBNET, bad_subnet);
  }
  void add_murmur_hash_seed(uint32_t murmur_hash_seed) {
    fbb_.AddElement<uint32_t>(ClientSideModel::VT_MURMUR_HASH_SEED, murmur_hash_seed, 0);
  }
  void add_max_shingles_per_page(int32_t max_shingles_per_page) {
    fbb_.AddElement<int32_t>(ClientSideModel::VT_MAX_SHINGLES_PER_PAGE, max_shingles_per_page, 200);
  }
  void add_shingle_size(int32_t shingle_size) {
    fbb_.AddElement<int32_t>(ClientSideModel::VT_SHINGLE_SIZE, shingle_size, 4);
  }
  void add_threshold_probability(float threshold_probability) {
    fbb_.AddElement<float>(ClientSideModel::VT_THRESHOLD_PROBABILITY, threshold_probability, 0.5f);
  }
  void add_vision_model(flatbuffers::Offset<safe_browsing::flat::VisionModel> vision_model) {
    fbb_.AddOffset(ClientSideModel::VT_VISION_MODEL, vision_model);
  }
  void add_tflite_metadata(flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> tflite_metadata) {
    fbb_.AddOffset(ClientSideModel::VT_TFLITE_METADATA, tflite_metadata);
  }
  void add_dom_model_version(int32_t dom_model_version) {
    fbb_.AddElement<int32_t>(ClientSideModel::VT_DOM_MODEL_VERSION, dom_model_version, 0);
  }
  explicit ClientSideModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClientSideModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientSideModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientSideModel> CreateClientSideModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::Hash>>> hashes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>> rule = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> page_term = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> page_word = 0,
    int32_t max_words_per_term = 0,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>> bad_subnet = 0,
    uint32_t murmur_hash_seed = 0,
    int32_t max_shingles_per_page = 200,
    int32_t shingle_size = 4,
    float threshold_probability = 0.5f,
    flatbuffers::Offset<safe_browsing::flat::VisionModel> vision_model = 0,
    flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> tflite_metadata = 0,
    int32_t dom_model_version = 0) {
  ClientSideModelBuilder builder_(_fbb);
  builder_.add_dom_model_version(dom_model_version);
  builder_.add_tflite_metadata(tflite_metadata);
  builder_.add_vision_model(vision_model);
  builder_.add_threshold_probability(threshold_probability);
  builder_.add_shingle_size(shingle_size);
  builder_.add_max_shingles_per_page(max_shingles_per_page);
  builder_.add_murmur_hash_seed(murmur_hash_seed);
  builder_.add_bad_subnet(bad_subnet);
  builder_.add_version(version);
  builder_.add_max_words_per_term(max_words_per_term);
  builder_.add_page_word(page_word);
  builder_.add_page_term(page_term);
  builder_.add_rule(rule);
  builder_.add_hashes(hashes);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientSideModel> CreateClientSideModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::Hash>> *hashes = nullptr,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>> *rule = nullptr,
    const std::vector<int32_t> *page_term = nullptr,
    const std::vector<uint32_t> *page_word = nullptr,
    int32_t max_words_per_term = 0,
    int32_t version = 0,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>> *bad_subnet = nullptr,
    uint32_t murmur_hash_seed = 0,
    int32_t max_shingles_per_page = 200,
    int32_t shingle_size = 4,
    float threshold_probability = 0.5f,
    flatbuffers::Offset<safe_browsing::flat::VisionModel> vision_model = 0,
    flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> tflite_metadata = 0,
    int32_t dom_model_version = 0) {
  auto hashes__ = hashes ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::Hash>>(*hashes) : 0;
  auto rule__ = rule ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>(*rule) : 0;
  auto page_term__ = page_term ? _fbb.CreateVector<int32_t>(*page_term) : 0;
  auto page_word__ = page_word ? _fbb.CreateVector<uint32_t>(*page_word) : 0;
  auto bad_subnet__ = bad_subnet ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>(*bad_subnet) : 0;
  return safe_browsing::flat::CreateClientSideModel(
      _fbb,
      hashes__,
      rule__,
      page_term__,
      page_word__,
      max_words_per_term,
      version,
      bad_subnet__,
      murmur_hash_seed,
      max_shingles_per_page,
      shingle_size,
      threshold_probability,
      vision_model,
      tflite_metadata,
      dom_model_version);
}

namespace ClientSideModel_ {

struct Rule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURE = 4,
    VT_WEIGHT = 6
  };
  const flatbuffers::Vector<int32_t> *feature() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FEATURE);
  }
  flatbuffers::Vector<int32_t> *mutable_feature() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_FEATURE);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool mutate_weight(float _weight = 0.0f) {
    return SetField<float>(VT_WEIGHT, _weight, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FEATURE) &&
           verifier.VerifyVector(feature()) &&
           VerifyField<float>(verifier, VT_WEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct RuleBuilder {
  typedef Rule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_feature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> feature) {
    fbb_.AddOffset(Rule::VT_FEATURE, feature);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(Rule::VT_WEIGHT, weight, 0.0f);
  }
  explicit RuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rule>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rule> CreateRule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> feature = 0,
    float weight = 0.0f) {
  RuleBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_feature(feature);
  return builder_.Finish();
}

inline flatbuffers::Offset<Rule> CreateRuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *feature = nullptr,
    float weight = 0.0f) {
  auto feature__ = feature ? _fbb.CreateVector<int32_t>(*feature) : 0;
  return safe_browsing::flat::ClientSideModel_::CreateRule(
      _fbb,
      feature__,
      weight);
}

struct IPSubnet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IPSubnetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREFIX = 4,
    VT_SIZE = 6
  };
  const flatbuffers::Vector<uint8_t> *prefix() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PREFIX);
  }
  flatbuffers::Vector<uint8_t> *mutable_prefix() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PREFIX);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 128);
  }
  bool mutate_size(int32_t _size = 128) {
    return SetField<int32_t>(VT_SIZE, _size, 128);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PREFIX) &&
           verifier.VerifyVector(prefix()) &&
           VerifyField<int32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct IPSubnetBuilder {
  typedef IPSubnet Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prefix(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prefix) {
    fbb_.AddOffset(IPSubnet::VT_PREFIX, prefix);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(IPSubnet::VT_SIZE, size, 128);
  }
  explicit IPSubnetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IPSubnet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IPSubnet>(end);
    fbb_.Required(o, IPSubnet::VT_PREFIX);
    return o;
  }
};

inline flatbuffers::Offset<IPSubnet> CreateIPSubnet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prefix = 0,
    int32_t size = 128) {
  IPSubnetBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_prefix(prefix);
  return builder_.Finish();
}

inline flatbuffers::Offset<IPSubnet> CreateIPSubnetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *prefix = nullptr,
    int32_t size = 128) {
  auto prefix__ = prefix ? _fbb.CreateVector<uint8_t>(*prefix) : 0;
  return safe_browsing::flat::ClientSideModel_::CreateIPSubnet(
      _fbb,
      prefix__,
      size);
}

}  // namespace ClientSideModel_

struct TfLiteModelMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TfLiteModelMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_THRESHOLDS = 6,
    VT_INPUT_WIDTH = 8,
    VT_INPUT_HEIGHT = 10
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  bool mutate_version(int32_t _version = 0) {
    return SetField<int32_t>(VT_VERSION, _version, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>> *thresholds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>> *>(VT_THRESHOLDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>> *mutable_thresholds() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>> *>(VT_THRESHOLDS);
  }
  int32_t input_width() const {
    return GetField<int32_t>(VT_INPUT_WIDTH, 0);
  }
  bool mutate_input_width(int32_t _input_width = 0) {
    return SetField<int32_t>(VT_INPUT_WIDTH, _input_width, 0);
  }
  int32_t input_height() const {
    return GetField<int32_t>(VT_INPUT_HEIGHT, 0);
  }
  bool mutate_input_height(int32_t _input_height = 0) {
    return SetField<int32_t>(VT_INPUT_HEIGHT, _input_height, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_THRESHOLDS) &&
           verifier.VerifyVector(thresholds()) &&
           verifier.VerifyVectorOfTables(thresholds()) &&
           VerifyField<int32_t>(verifier, VT_INPUT_WIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_INPUT_HEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct TfLiteModelMetadataBuilder {
  typedef TfLiteModelMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(TfLiteModelMetadata::VT_VERSION, version, 0);
  }
  void add_thresholds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>> thresholds) {
    fbb_.AddOffset(TfLiteModelMetadata::VT_THRESHOLDS, thresholds);
  }
  void add_input_width(int32_t input_width) {
    fbb_.AddElement<int32_t>(TfLiteModelMetadata::VT_INPUT_WIDTH, input_width, 0);
  }
  void add_input_height(int32_t input_height) {
    fbb_.AddElement<int32_t>(TfLiteModelMetadata::VT_INPUT_HEIGHT, input_height, 0);
  }
  explicit TfLiteModelMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TfLiteModelMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TfLiteModelMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<TfLiteModelMetadata> CreateTfLiteModelMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>> thresholds = 0,
    int32_t input_width = 0,
    int32_t input_height = 0) {
  TfLiteModelMetadataBuilder builder_(_fbb);
  builder_.add_input_height(input_height);
  builder_.add_input_width(input_width);
  builder_.add_thresholds(thresholds);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<TfLiteModelMetadata> CreateTfLiteModelMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>> *thresholds = nullptr,
    int32_t input_width = 0,
    int32_t input_height = 0) {
  auto thresholds__ = thresholds ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>(*thresholds) : 0;
  return safe_browsing::flat::CreateTfLiteModelMetadata(
      _fbb,
      version,
      thresholds__,
      input_width,
      input_height);
}

namespace TfLiteModelMetadata_ {

struct Threshold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ThresholdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_THRESHOLD = 6
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  flatbuffers::String *mutable_label() {
    return GetPointer<flatbuffers::String *>(VT_LABEL);
  }
  float threshold() const {
    return GetField<float>(VT_THRESHOLD, 0.0f);
  }
  bool mutate_threshold(float _threshold = 0.0f) {
    return SetField<float>(VT_THRESHOLD, _threshold, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<float>(verifier, VT_THRESHOLD, 4) &&
           verifier.EndTable();
  }
};

struct ThresholdBuilder {
  typedef Threshold Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Threshold::VT_LABEL, label);
  }
  void add_threshold(float threshold) {
    fbb_.AddElement<float>(Threshold::VT_THRESHOLD, threshold, 0.0f);
  }
  explicit ThresholdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Threshold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Threshold>(end);
    return o;
  }
};

inline flatbuffers::Offset<Threshold> CreateThreshold(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    float threshold = 0.0f) {
  ThresholdBuilder builder_(_fbb);
  builder_.add_threshold(threshold);
  builder_.add_label(label);
  return builder_.Finish();
}

inline flatbuffers::Offset<Threshold> CreateThresholdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    float threshold = 0.0f) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  return safe_browsing::flat::TfLiteModelMetadata_::CreateThreshold(
      _fbb,
      label__,
      threshold);
}

}  // namespace TfLiteModelMetadata_

struct VisionModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VisionModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGETS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>> *>(VT_TARGETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>> *mutable_targets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>> *>(VT_TARGETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           verifier.EndTable();
  }
};

struct VisionModelBuilder {
  typedef VisionModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>>> targets) {
    fbb_.AddOffset(VisionModel::VT_TARGETS, targets);
  }
  explicit VisionModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VisionModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VisionModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<VisionModel> CreateVisionModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>>> targets = 0) {
  VisionModelBuilder builder_(_fbb);
  builder_.add_targets(targets);
  return builder_.Finish();
}

inline flatbuffers::Offset<VisionModel> CreateVisionModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>> *targets = nullptr) {
  auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::VisualTarget>>(*targets) : 0;
  return safe_browsing::flat::CreateVisionModel(
      _fbb,
      targets__);
}

struct VisualTarget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VisualTargetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIGEST = 4,
    VT_TIMESTAMP_USEC = 6,
    VT_HASH = 8,
    VT_DIMENSION_SIZE = 10,
    VT_BINS = 12,
    VT_MATCH_CONFIG = 14
  };
  const flatbuffers::Vector<uint8_t> *digest() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DIGEST);
  }
  flatbuffers::Vector<uint8_t> *mutable_digest() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DIGEST);
  }
  int64_t timestamp_usec() const {
    return GetField<int64_t>(VT_TIMESTAMP_USEC, 0);
  }
  bool mutate_timestamp_usec(int64_t _timestamp_usec = 0) {
    return SetField<int64_t>(VT_TIMESTAMP_USEC, _timestamp_usec, 0);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  int32_t dimension_size() const {
    return GetField<int32_t>(VT_DIMENSION_SIZE, 0);
  }
  bool mutate_dimension_size(int32_t _dimension_size = 0) {
    return SetField<int32_t>(VT_DIMENSION_SIZE, _dimension_size, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>> *bins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>> *>(VT_BINS);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>> *mutable_bins() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>> *>(VT_BINS);
  }
  const safe_browsing::flat::MatchConfig *match_config() const {
    return GetPointer<const safe_browsing::flat::MatchConfig *>(VT_MATCH_CONFIG);
  }
  safe_browsing::flat::MatchConfig *mutable_match_config() {
    return GetPointer<safe_browsing::flat::MatchConfig *>(VT_MATCH_CONFIG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIGEST) &&
           verifier.VerifyVector(digest()) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP_USEC, 8) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyVector(hash()) &&
           VerifyField<int32_t>(verifier, VT_DIMENSION_SIZE, 4) &&
           VerifyOffset(verifier, VT_BINS) &&
           verifier.VerifyVector(bins()) &&
           verifier.VerifyVectorOfTables(bins()) &&
           VerifyOffset(verifier, VT_MATCH_CONFIG) &&
           verifier.VerifyTable(match_config()) &&
           verifier.EndTable();
  }
};

struct VisualTargetBuilder {
  typedef VisualTarget Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_digest(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> digest) {
    fbb_.AddOffset(VisualTarget::VT_DIGEST, digest);
  }
  void add_timestamp_usec(int64_t timestamp_usec) {
    fbb_.AddElement<int64_t>(VisualTarget::VT_TIMESTAMP_USEC, timestamp_usec, 0);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(VisualTarget::VT_HASH, hash);
  }
  void add_dimension_size(int32_t dimension_size) {
    fbb_.AddElement<int32_t>(VisualTarget::VT_DIMENSION_SIZE, dimension_size, 0);
  }
  void add_bins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>> bins) {
    fbb_.AddOffset(VisualTarget::VT_BINS, bins);
  }
  void add_match_config(flatbuffers::Offset<safe_browsing::flat::MatchConfig> match_config) {
    fbb_.AddOffset(VisualTarget::VT_MATCH_CONFIG, match_config);
  }
  explicit VisualTargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VisualTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VisualTarget>(end);
    return o;
  }
};

inline flatbuffers::Offset<VisualTarget> CreateVisualTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> digest = 0,
    int64_t timestamp_usec = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    int32_t dimension_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>> bins = 0,
    flatbuffers::Offset<safe_browsing::flat::MatchConfig> match_config = 0) {
  VisualTargetBuilder builder_(_fbb);
  builder_.add_timestamp_usec(timestamp_usec);
  builder_.add_match_config(match_config);
  builder_.add_bins(bins);
  builder_.add_dimension_size(dimension_size);
  builder_.add_hash(hash);
  builder_.add_digest(digest);
  return builder_.Finish();
}

inline flatbuffers::Offset<VisualTarget> CreateVisualTargetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *digest = nullptr,
    int64_t timestamp_usec = 0,
    const std::vector<uint8_t> *hash = nullptr,
    int32_t dimension_size = 0,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>> *bins = nullptr,
    flatbuffers::Offset<safe_browsing::flat::MatchConfig> match_config = 0) {
  auto digest__ = digest ? _fbb.CreateVector<uint8_t>(*digest) : 0;
  auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
  auto bins__ = bins ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>(*bins) : 0;
  return safe_browsing::flat::CreateVisualTarget(
      _fbb,
      digest__,
      timestamp_usec,
      hash__,
      dimension_size,
      bins__,
      match_config);
}

struct MatchConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatchConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATCH_RULE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>> *match_rule() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>> *>(VT_MATCH_RULE);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>> *mutable_match_rule() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>> *>(VT_MATCH_RULE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATCH_RULE) &&
           verifier.VerifyVector(match_rule()) &&
           verifier.VerifyVectorOfTables(match_rule()) &&
           verifier.EndTable();
  }
};

struct MatchConfigBuilder {
  typedef MatchConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_match_rule(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>>> match_rule) {
    fbb_.AddOffset(MatchConfig::VT_MATCH_RULE, match_rule);
  }
  explicit MatchConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatchConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatchConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatchConfig> CreateMatchConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>>> match_rule = 0) {
  MatchConfigBuilder builder_(_fbb);
  builder_.add_match_rule(match_rule);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatchConfig> CreateMatchConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::MatchRule>> *match_rule = nullptr) {
  auto match_rule__ = match_rule ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::MatchRule>>(*match_rule) : 0;
  return safe_browsing::flat::CreateMatchConfig(
      _fbb,
      match_rule__);
}

struct MatchRule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatchRuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH_DISTANCE = 4,
    VT_COLOR_DISTANCE = 6,
    VT_COLOR_RANGE = 8,
    VT_FLOAT_COLOR_RANGE = 10
  };
  double hash_distance() const {
    return GetField<double>(VT_HASH_DISTANCE, 0.0);
  }
  bool mutate_hash_distance(double _hash_distance = 0.0) {
    return SetField<double>(VT_HASH_DISTANCE, _hash_distance, 0.0);
  }
  double color_distance() const {
    return GetField<double>(VT_COLOR_DISTANCE, 0.0);
  }
  bool mutate_color_distance(double _color_distance = 0.0) {
    return SetField<double>(VT_COLOR_DISTANCE, _color_distance, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>> *color_range() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>> *>(VT_COLOR_RANGE);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>> *mutable_color_range() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>> *>(VT_COLOR_RANGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>> *float_color_range() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>> *>(VT_FLOAT_COLOR_RANGE);
  }
  flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>> *mutable_float_color_range() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>> *>(VT_FLOAT_COLOR_RANGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_HASH_DISTANCE, 8) &&
           VerifyField<double>(verifier, VT_COLOR_DISTANCE, 8) &&
           VerifyOffset(verifier, VT_COLOR_RANGE) &&
           verifier.VerifyVector(color_range()) &&
           verifier.VerifyVectorOfTables(color_range()) &&
           VerifyOffset(verifier, VT_FLOAT_COLOR_RANGE) &&
           verifier.VerifyVector(float_color_range()) &&
           verifier.VerifyVectorOfTables(float_color_range()) &&
           verifier.EndTable();
  }
};

struct MatchRuleBuilder {
  typedef MatchRule Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash_distance(double hash_distance) {
    fbb_.AddElement<double>(MatchRule::VT_HASH_DISTANCE, hash_distance, 0.0);
  }
  void add_color_distance(double color_distance) {
    fbb_.AddElement<double>(MatchRule::VT_COLOR_DISTANCE, color_distance, 0.0);
  }
  void add_color_range(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>> color_range) {
    fbb_.AddOffset(MatchRule::VT_COLOR_RANGE, color_range);
  }
  void add_float_color_range(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>> float_color_range) {
    fbb_.AddOffset(MatchRule::VT_FLOAT_COLOR_RANGE, float_color_range);
  }
  explicit MatchRuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatchRule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatchRule>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatchRule> CreateMatchRule(
    flatbuffers::FlatBufferBuilder &_fbb,
    double hash_distance = 0.0,
    double color_distance = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>> color_range = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>> float_color_range = 0) {
  MatchRuleBuilder builder_(_fbb);
  builder_.add_color_distance(color_distance);
  builder_.add_hash_distance(hash_distance);
  builder_.add_float_color_range(float_color_range);
  builder_.add_color_range(color_range);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatchRule> CreateMatchRuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double hash_distance = 0.0,
    double color_distance = 0.0,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>> *color_range = nullptr,
    const std::vector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>> *float_color_range = nullptr) {
  auto color_range__ = color_range ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>(*color_range) : 0;
  auto float_color_range__ = float_color_range ? _fbb.CreateVector<flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>(*float_color_range) : 0;
  return safe_browsing::flat::CreateMatchRule(
      _fbb,
      hash_distance,
      color_distance,
      color_range__,
      float_color_range__);
}

namespace MatchRule_ {

struct ColorRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColorRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  int32_t low() const {
    return GetField<int32_t>(VT_LOW, 0);
  }
  bool mutate_low(int32_t _low = 0) {
    return SetField<int32_t>(VT_LOW, _low, 0);
  }
  int32_t high() const {
    return GetField<int32_t>(VT_HIGH, 0);
  }
  bool mutate_high(int32_t _high = 0) {
    return SetField<int32_t>(VT_HIGH, _high, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LOW, 4) &&
           VerifyField<int32_t>(verifier, VT_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct ColorRangeBuilder {
  typedef ColorRange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_low(int32_t low) {
    fbb_.AddElement<int32_t>(ColorRange::VT_LOW, low, 0);
  }
  void add_high(int32_t high) {
    fbb_.AddElement<int32_t>(ColorRange::VT_HIGH, high, 0);
  }
  explicit ColorRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColorRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColorRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColorRange> CreateColorRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t low = 0,
    int32_t high = 0) {
  ColorRangeBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

struct FloatColorRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatColorRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  float low() const {
    return GetField<float>(VT_LOW, 0.0f);
  }
  bool mutate_low(float _low = 0.0f) {
    return SetField<float>(VT_LOW, _low, 0.0f);
  }
  float high() const {
    return GetField<float>(VT_HIGH, 0.0f);
  }
  bool mutate_high(float _high = 0.0f) {
    return SetField<float>(VT_HIGH, _high, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LOW, 4) &&
           VerifyField<float>(verifier, VT_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct FloatColorRangeBuilder {
  typedef FloatColorRange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_low(float low) {
    fbb_.AddElement<float>(FloatColorRange::VT_LOW, low, 0.0f);
  }
  void add_high(float high) {
    fbb_.AddElement<float>(FloatColorRange::VT_HIGH, high, 0.0f);
  }
  explicit FloatColorRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloatColorRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatColorRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatColorRange> CreateFloatColorRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    float low = 0.0f,
    float high = 0.0f) {
  FloatColorRangeBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

}  // namespace MatchRule_

namespace ClientSideModel_ {

}  // namespace ClientSideModel_

namespace TfLiteModelMetadata_ {

}  // namespace TfLiteModelMetadata_

namespace MatchRule_ {

}  // namespace MatchRule_

inline const safe_browsing::flat::ClientSideModel *GetClientSideModel(const void *buf) {
  return flatbuffers::GetRoot<safe_browsing::flat::ClientSideModel>(buf);
}

inline const safe_browsing::flat::ClientSideModel *GetSizePrefixedClientSideModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<safe_browsing::flat::ClientSideModel>(buf);
}

inline ClientSideModel *GetMutableClientSideModel(void *buf) {
  return flatbuffers::GetMutableRoot<ClientSideModel>(buf);
}

inline safe_browsing::flat::ClientSideModel *GetMutableSizePrefixedClientSideModel(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<safe_browsing::flat::ClientSideModel>(buf);
}

inline bool VerifyClientSideModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<safe_browsing::flat::ClientSideModel>(nullptr);
}

inline bool VerifySizePrefixedClientSideModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<safe_browsing::flat::ClientSideModel>(nullptr);
}

inline void FinishClientSideModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<safe_browsing::flat::ClientSideModel> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedClientSideModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<safe_browsing::flat::ClientSideModel> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat
}  // namespace safe_browsing

#endif  // FLATBUFFERS_GENERATED_CLIENTMODEL_SAFE_BROWSING_FLAT_MATCHRULE__H_
