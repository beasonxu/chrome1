// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_safebrowsing_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_safebrowsing_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_safebrowsing_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_safebrowsing_2eproto {
  static const uint32_t offsets[];
};
namespace safe_browsing {
class Checksum;
struct ChecksumDefaultTypeInternal;
extern ChecksumDefaultTypeInternal _Checksum_default_instance_;
class ChromeClientInfo;
struct ChromeClientInfoDefaultTypeInternal;
extern ChromeClientInfoDefaultTypeInternal _ChromeClientInfo_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class Duration;
struct DurationDefaultTypeInternal;
extern DurationDefaultTypeInternal _Duration_default_instance_;
class FetchThreatListUpdatesRequest;
struct FetchThreatListUpdatesRequestDefaultTypeInternal;
extern FetchThreatListUpdatesRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest;
struct FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal;
extern FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
struct FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal;
extern FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
class FetchThreatListUpdatesResponse;
struct FetchThreatListUpdatesResponseDefaultTypeInternal;
extern FetchThreatListUpdatesResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_default_instance_;
class FetchThreatListUpdatesResponse_ListUpdateResponse;
struct FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal;
extern FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
class FindFullHashesRequest;
struct FindFullHashesRequestDefaultTypeInternal;
extern FindFullHashesRequestDefaultTypeInternal _FindFullHashesRequest_default_instance_;
class FindFullHashesResponse;
struct FindFullHashesResponseDefaultTypeInternal;
extern FindFullHashesResponseDefaultTypeInternal _FindFullHashesResponse_default_instance_;
class FindThreatMatchesRequest;
struct FindThreatMatchesRequestDefaultTypeInternal;
extern FindThreatMatchesRequestDefaultTypeInternal _FindThreatMatchesRequest_default_instance_;
class FindThreatMatchesResponse;
struct FindThreatMatchesResponseDefaultTypeInternal;
extern FindThreatMatchesResponseDefaultTypeInternal _FindThreatMatchesResponse_default_instance_;
class ListThreatListsResponse;
struct ListThreatListsResponseDefaultTypeInternal;
extern ListThreatListsResponseDefaultTypeInternal _ListThreatListsResponse_default_instance_;
class RawHashes;
struct RawHashesDefaultTypeInternal;
extern RawHashesDefaultTypeInternal _RawHashes_default_instance_;
class RawIndices;
struct RawIndicesDefaultTypeInternal;
extern RawIndicesDefaultTypeInternal _RawIndices_default_instance_;
class RiceDeltaEncoding;
struct RiceDeltaEncodingDefaultTypeInternal;
extern RiceDeltaEncodingDefaultTypeInternal _RiceDeltaEncoding_default_instance_;
class ThreatEntry;
struct ThreatEntryDefaultTypeInternal;
extern ThreatEntryDefaultTypeInternal _ThreatEntry_default_instance_;
class ThreatEntryMetadata;
struct ThreatEntryMetadataDefaultTypeInternal;
extern ThreatEntryMetadataDefaultTypeInternal _ThreatEntryMetadata_default_instance_;
class ThreatEntryMetadata_MetadataEntry;
struct ThreatEntryMetadata_MetadataEntryDefaultTypeInternal;
extern ThreatEntryMetadata_MetadataEntryDefaultTypeInternal _ThreatEntryMetadata_MetadataEntry_default_instance_;
class ThreatEntrySet;
struct ThreatEntrySetDefaultTypeInternal;
extern ThreatEntrySetDefaultTypeInternal _ThreatEntrySet_default_instance_;
class ThreatHit;
struct ThreatHitDefaultTypeInternal;
extern ThreatHitDefaultTypeInternal _ThreatHit_default_instance_;
class ThreatHit_ThreatSource;
struct ThreatHit_ThreatSourceDefaultTypeInternal;
extern ThreatHit_ThreatSourceDefaultTypeInternal _ThreatHit_ThreatSource_default_instance_;
class ThreatInfo;
struct ThreatInfoDefaultTypeInternal;
extern ThreatInfoDefaultTypeInternal _ThreatInfo_default_instance_;
class ThreatListDescriptor;
struct ThreatListDescriptorDefaultTypeInternal;
extern ThreatListDescriptorDefaultTypeInternal _ThreatListDescriptor_default_instance_;
class ThreatMatch;
struct ThreatMatchDefaultTypeInternal;
extern ThreatMatchDefaultTypeInternal _ThreatMatch_default_instance_;
}  // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template<> ::safe_browsing::Checksum* Arena::CreateMaybeMessage<::safe_browsing::Checksum>(Arena*);
template<> ::safe_browsing::ChromeClientInfo* Arena::CreateMaybeMessage<::safe_browsing::ChromeClientInfo>(Arena*);
template<> ::safe_browsing::ClientInfo* Arena::CreateMaybeMessage<::safe_browsing::ClientInfo>(Arena*);
template<> ::safe_browsing::Duration* Arena::CreateMaybeMessage<::safe_browsing::Duration>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesRequest* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesResponse* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesResponse>(Arena*);
template<> ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* Arena::CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse>(Arena*);
template<> ::safe_browsing::FindFullHashesRequest* Arena::CreateMaybeMessage<::safe_browsing::FindFullHashesRequest>(Arena*);
template<> ::safe_browsing::FindFullHashesResponse* Arena::CreateMaybeMessage<::safe_browsing::FindFullHashesResponse>(Arena*);
template<> ::safe_browsing::FindThreatMatchesRequest* Arena::CreateMaybeMessage<::safe_browsing::FindThreatMatchesRequest>(Arena*);
template<> ::safe_browsing::FindThreatMatchesResponse* Arena::CreateMaybeMessage<::safe_browsing::FindThreatMatchesResponse>(Arena*);
template<> ::safe_browsing::ListThreatListsResponse* Arena::CreateMaybeMessage<::safe_browsing::ListThreatListsResponse>(Arena*);
template<> ::safe_browsing::RawHashes* Arena::CreateMaybeMessage<::safe_browsing::RawHashes>(Arena*);
template<> ::safe_browsing::RawIndices* Arena::CreateMaybeMessage<::safe_browsing::RawIndices>(Arena*);
template<> ::safe_browsing::RiceDeltaEncoding* Arena::CreateMaybeMessage<::safe_browsing::RiceDeltaEncoding>(Arena*);
template<> ::safe_browsing::ThreatEntry* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntry>(Arena*);
template<> ::safe_browsing::ThreatEntryMetadata* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntryMetadata>(Arena*);
template<> ::safe_browsing::ThreatEntryMetadata_MetadataEntry* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntryMetadata_MetadataEntry>(Arena*);
template<> ::safe_browsing::ThreatEntrySet* Arena::CreateMaybeMessage<::safe_browsing::ThreatEntrySet>(Arena*);
template<> ::safe_browsing::ThreatHit* Arena::CreateMaybeMessage<::safe_browsing::ThreatHit>(Arena*);
template<> ::safe_browsing::ThreatHit_ThreatSource* Arena::CreateMaybeMessage<::safe_browsing::ThreatHit_ThreatSource>(Arena*);
template<> ::safe_browsing::ThreatInfo* Arena::CreateMaybeMessage<::safe_browsing::ThreatInfo>(Arena*);
template<> ::safe_browsing::ThreatListDescriptor* Arena::CreateMaybeMessage<::safe_browsing::ThreatListDescriptor>(Arena*);
template<> ::safe_browsing::ThreatMatch* Arena::CreateMaybeMessage<::safe_browsing::ThreatMatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safe_browsing {

enum FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType : int {
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED = 0,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE = 1,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE = 2
};
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value);
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
constexpr int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX + 1;

const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);
template<typename T>
inline const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name.");
  return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(static_cast<FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(enum_t_value));
}
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType* value);
enum ThreatHit_ThreatSourceType : int {
  ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED = 0,
  ThreatHit_ThreatSourceType_MATCHING_URL = 1,
  ThreatHit_ThreatSourceType_TAB_URL = 2,
  ThreatHit_ThreatSourceType_TAB_REDIRECT = 3
};
bool ThreatHit_ThreatSourceType_IsValid(int value);
constexpr ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MIN = ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
constexpr ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MAX = ThreatHit_ThreatSourceType_TAB_REDIRECT;
constexpr int ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE = ThreatHit_ThreatSourceType_ThreatSourceType_MAX + 1;

const std::string& ThreatHit_ThreatSourceType_Name(ThreatHit_ThreatSourceType value);
template<typename T>
inline const std::string& ThreatHit_ThreatSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatHit_ThreatSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatHit_ThreatSourceType_Name.");
  return ThreatHit_ThreatSourceType_Name(static_cast<ThreatHit_ThreatSourceType>(enum_t_value));
}
bool ThreatHit_ThreatSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatHit_ThreatSourceType* value);
enum ChromeClientInfo_SafeBrowsingReportingPopulation : int {
  ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED = 0,
  ChromeClientInfo_SafeBrowsingReportingPopulation_OPT_OUT = 1,
  ChromeClientInfo_SafeBrowsingReportingPopulation_EXTENDED = 2,
  ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT = 3
};
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value);
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MIN = ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX = ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT;
constexpr int ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_ARRAYSIZE = ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX + 1;

const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(ChromeClientInfo_SafeBrowsingReportingPopulation value);
template<typename T>
inline const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChromeClientInfo_SafeBrowsingReportingPopulation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChromeClientInfo_SafeBrowsingReportingPopulation_Name.");
  return ChromeClientInfo_SafeBrowsingReportingPopulation_Name(static_cast<ChromeClientInfo_SafeBrowsingReportingPopulation>(enum_t_value));
}
bool ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeClientInfo_SafeBrowsingReportingPopulation* value);
enum ThreatType : int {
  THREAT_TYPE_UNSPECIFIED = 0,
  MALWARE_THREAT = 1,
  SOCIAL_ENGINEERING_PUBLIC = 2,
  UNWANTED_SOFTWARE = 3,
  POTENTIALLY_HARMFUL_APPLICATION = 4,
  SOCIAL_ENGINEERING = 5,
  API_ABUSE = 6,
  MALICIOUS_BINARY = 7,
  CSD_WHITELIST = 8,
  CSD_DOWNLOAD_WHITELIST = 9,
  CLIENT_INCIDENT = 10,
  SUBRESOURCE_FILTER = 13,
  SUSPICIOUS = 14,
  BILLING = 15,
  HIGH_CONFIDENCE_ALLOWLIST = 16,
  ACCURACY_TIPS = 17
};
bool ThreatType_IsValid(int value);
constexpr ThreatType ThreatType_MIN = THREAT_TYPE_UNSPECIFIED;
constexpr ThreatType ThreatType_MAX = ACCURACY_TIPS;
constexpr int ThreatType_ARRAYSIZE = ThreatType_MAX + 1;

const std::string& ThreatType_Name(ThreatType value);
template<typename T>
inline const std::string& ThreatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatType_Name.");
  return ThreatType_Name(static_cast<ThreatType>(enum_t_value));
}
bool ThreatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatType* value);
enum PlatformType : int {
  PLATFORM_TYPE_UNSPECIFIED = 0,
  WINDOWS_PLATFORM = 1,
  LINUX_PLATFORM = 2,
  ANDROID_PLATFORM = 3,
  OSX_PLATFORM = 4,
  IOS_PLATFORM = 5,
  ANY_PLATFORM = 6,
  ALL_PLATFORMS = 7,
  CHROME_PLATFORM = 8
};
bool PlatformType_IsValid(int value);
constexpr PlatformType PlatformType_MIN = PLATFORM_TYPE_UNSPECIFIED;
constexpr PlatformType PlatformType_MAX = CHROME_PLATFORM;
constexpr int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

const std::string& PlatformType_Name(PlatformType value);
template<typename T>
inline const std::string& PlatformType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlatformType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlatformType_Name.");
  return PlatformType_Name(static_cast<PlatformType>(enum_t_value));
}
bool PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlatformType* value);
enum CompressionType : int {
  COMPRESSION_TYPE_UNSPECIFIED = 0,
  RAW = 1,
  RICE = 2
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = COMPRESSION_TYPE_UNSPECIFIED;
constexpr CompressionType CompressionType_MAX = RICE;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const std::string& CompressionType_Name(CompressionType value);
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return CompressionType_Name(static_cast<CompressionType>(enum_t_value));
}
bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value);
enum ThreatEntryType : int {
  THREAT_ENTRY_TYPE_UNSPECIFIED = 0,
  URL = 1,
  EXECUTABLE = 2,
  IP_RANGE = 3,
  CHROME_EXTENSION = 4,
  FILENAME = 5,
  CERT = 6
};
bool ThreatEntryType_IsValid(int value);
constexpr ThreatEntryType ThreatEntryType_MIN = THREAT_ENTRY_TYPE_UNSPECIFIED;
constexpr ThreatEntryType ThreatEntryType_MAX = CERT;
constexpr int ThreatEntryType_ARRAYSIZE = ThreatEntryType_MAX + 1;

const std::string& ThreatEntryType_Name(ThreatEntryType value);
template<typename T>
inline const std::string& ThreatEntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatEntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatEntryType_Name.");
  return ThreatEntryType_Name(static_cast<ThreatEntryType>(enum_t_value));
}
bool ThreatEntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatEntryType* value);
// ===================================================================

class ThreatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatInfo) */ {
 public:
  inline ThreatInfo() : ThreatInfo(nullptr) {}
  ~ThreatInfo() override;
  explicit PROTOBUF_CONSTEXPR ThreatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatInfo(const ThreatInfo& from);
  ThreatInfo(ThreatInfo&& from) noexcept
    : ThreatInfo() {
    *this = ::std::move(from);
  }

  inline ThreatInfo& operator=(const ThreatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatInfo& operator=(ThreatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatInfo* internal_default_instance() {
    return reinterpret_cast<const ThreatInfo*>(
               &_ThreatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ThreatInfo& a, ThreatInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatInfo& from);
  void MergeFrom(const ThreatInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatInfo";
  }
  protected:
  explicit ThreatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatTypesFieldNumber = 1,
    kPlatformTypesFieldNumber = 2,
    kThreatEntriesFieldNumber = 3,
    kThreatEntryTypesFieldNumber = 4,
  };
  // repeated .safe_browsing.ThreatType threat_types = 1;
  int threat_types_size() const;
  private:
  int _internal_threat_types_size() const;
  public:
  void clear_threat_types();
  private:
  ::safe_browsing::ThreatType _internal_threat_types(int index) const;
  void _internal_add_threat_types(::safe_browsing::ThreatType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_threat_types();
  public:
  ::safe_browsing::ThreatType threat_types(int index) const;
  void set_threat_types(int index, ::safe_browsing::ThreatType value);
  void add_threat_types(::safe_browsing::ThreatType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& threat_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_threat_types();

  // repeated .safe_browsing.PlatformType platform_types = 2;
  int platform_types_size() const;
  private:
  int _internal_platform_types_size() const;
  public:
  void clear_platform_types();
  private:
  ::safe_browsing::PlatformType _internal_platform_types(int index) const;
  void _internal_add_platform_types(::safe_browsing::PlatformType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_platform_types();
  public:
  ::safe_browsing::PlatformType platform_types(int index) const;
  void set_platform_types(int index, ::safe_browsing::PlatformType value);
  void add_platform_types(::safe_browsing::PlatformType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& platform_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_platform_types();

  // repeated .safe_browsing.ThreatEntry threat_entries = 3;
  int threat_entries_size() const;
  private:
  int _internal_threat_entries_size() const;
  public:
  void clear_threat_entries();
  ::safe_browsing::ThreatEntry* mutable_threat_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >*
      mutable_threat_entries();
  private:
  const ::safe_browsing::ThreatEntry& _internal_threat_entries(int index) const;
  ::safe_browsing::ThreatEntry* _internal_add_threat_entries();
  public:
  const ::safe_browsing::ThreatEntry& threat_entries(int index) const;
  ::safe_browsing::ThreatEntry* add_threat_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >&
      threat_entries() const;

  // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
  int threat_entry_types_size() const;
  private:
  int _internal_threat_entry_types_size() const;
  public:
  void clear_threat_entry_types();
  private:
  ::safe_browsing::ThreatEntryType _internal_threat_entry_types(int index) const;
  void _internal_add_threat_entry_types(::safe_browsing::ThreatEntryType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_threat_entry_types();
  public:
  ::safe_browsing::ThreatEntryType threat_entry_types(int index) const;
  void set_threat_entry_types(int index, ::safe_browsing::ThreatEntryType value);
  void add_threat_entry_types(::safe_browsing::ThreatEntryType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& threat_entry_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_threat_entry_types();

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> threat_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> platform_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry > threat_entries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> threat_entry_types_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatMatch final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatMatch) */ {
 public:
  inline ThreatMatch() : ThreatMatch(nullptr) {}
  ~ThreatMatch() override;
  explicit PROTOBUF_CONSTEXPR ThreatMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatMatch(const ThreatMatch& from);
  ThreatMatch(ThreatMatch&& from) noexcept
    : ThreatMatch() {
    *this = ::std::move(from);
  }

  inline ThreatMatch& operator=(const ThreatMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatMatch& operator=(ThreatMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatMatch* internal_default_instance() {
    return reinterpret_cast<const ThreatMatch*>(
               &_ThreatMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ThreatMatch& a, ThreatMatch& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatMatch>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatMatch& from);
  void MergeFrom(const ThreatMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatMatch";
  }
  protected:
  explicit ThreatMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatFieldNumber = 3,
    kThreatEntryMetadataFieldNumber = 4,
    kCacheDurationFieldNumber = 5,
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
    kThreatEntryTypeFieldNumber = 6,
  };
  // optional .safe_browsing.ThreatEntry threat = 3;
  bool has_threat() const;
  private:
  bool _internal_has_threat() const;
  public:
  void clear_threat();
  const ::safe_browsing::ThreatEntry& threat() const;
  PROTOBUF_NODISCARD ::safe_browsing::ThreatEntry* release_threat();
  ::safe_browsing::ThreatEntry* mutable_threat();
  void set_allocated_threat(::safe_browsing::ThreatEntry* threat);
  private:
  const ::safe_browsing::ThreatEntry& _internal_threat() const;
  ::safe_browsing::ThreatEntry* _internal_mutable_threat();
  public:
  void unsafe_arena_set_allocated_threat(
      ::safe_browsing::ThreatEntry* threat);
  ::safe_browsing::ThreatEntry* unsafe_arena_release_threat();

  // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
  bool has_threat_entry_metadata() const;
  private:
  bool _internal_has_threat_entry_metadata() const;
  public:
  void clear_threat_entry_metadata();
  const ::safe_browsing::ThreatEntryMetadata& threat_entry_metadata() const;
  PROTOBUF_NODISCARD ::safe_browsing::ThreatEntryMetadata* release_threat_entry_metadata();
  ::safe_browsing::ThreatEntryMetadata* mutable_threat_entry_metadata();
  void set_allocated_threat_entry_metadata(::safe_browsing::ThreatEntryMetadata* threat_entry_metadata);
  private:
  const ::safe_browsing::ThreatEntryMetadata& _internal_threat_entry_metadata() const;
  ::safe_browsing::ThreatEntryMetadata* _internal_mutable_threat_entry_metadata();
  public:
  void unsafe_arena_set_allocated_threat_entry_metadata(
      ::safe_browsing::ThreatEntryMetadata* threat_entry_metadata);
  ::safe_browsing::ThreatEntryMetadata* unsafe_arena_release_threat_entry_metadata();

  // optional .safe_browsing.Duration cache_duration = 5;
  bool has_cache_duration() const;
  private:
  bool _internal_has_cache_duration() const;
  public:
  void clear_cache_duration();
  const ::safe_browsing::Duration& cache_duration() const;
  PROTOBUF_NODISCARD ::safe_browsing::Duration* release_cache_duration();
  ::safe_browsing::Duration* mutable_cache_duration();
  void set_allocated_cache_duration(::safe_browsing::Duration* cache_duration);
  private:
  const ::safe_browsing::Duration& _internal_cache_duration() const;
  ::safe_browsing::Duration* _internal_mutable_cache_duration();
  public:
  void unsafe_arena_set_allocated_cache_duration(
      ::safe_browsing::Duration* cache_duration);
  ::safe_browsing::Duration* unsafe_arena_release_cache_duration();

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  private:
  bool _internal_has_threat_type() const;
  public:
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);
  private:
  ::safe_browsing::ThreatType _internal_threat_type() const;
  void _internal_set_threat_type(::safe_browsing::ThreatType value);
  public:

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);
  private:
  ::safe_browsing::PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::safe_browsing::PlatformType value);
  public:

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
  bool has_threat_entry_type() const;
  private:
  bool _internal_has_threat_entry_type() const;
  public:
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  private:
  ::safe_browsing::ThreatEntryType _internal_threat_entry_type() const;
  void _internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::safe_browsing::ThreatEntry* threat_;
  ::safe_browsing::ThreatEntryMetadata* threat_entry_metadata_;
  ::safe_browsing::Duration* cache_duration_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindThreatMatchesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindThreatMatchesRequest) */ {
 public:
  inline FindThreatMatchesRequest() : FindThreatMatchesRequest(nullptr) {}
  ~FindThreatMatchesRequest() override;
  explicit PROTOBUF_CONSTEXPR FindThreatMatchesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindThreatMatchesRequest(const FindThreatMatchesRequest& from);
  FindThreatMatchesRequest(FindThreatMatchesRequest&& from) noexcept
    : FindThreatMatchesRequest() {
    *this = ::std::move(from);
  }

  inline FindThreatMatchesRequest& operator=(const FindThreatMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindThreatMatchesRequest& operator=(FindThreatMatchesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FindThreatMatchesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindThreatMatchesRequest* internal_default_instance() {
    return reinterpret_cast<const FindThreatMatchesRequest*>(
               &_FindThreatMatchesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FindThreatMatchesRequest& a, FindThreatMatchesRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FindThreatMatchesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindThreatMatchesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindThreatMatchesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindThreatMatchesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FindThreatMatchesRequest& from);
  void MergeFrom(const FindThreatMatchesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindThreatMatchesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindThreatMatchesRequest";
  }
  protected:
  explicit FindThreatMatchesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientFieldNumber = 1,
    kThreatInfoFieldNumber = 2,
  };
  // optional .safe_browsing.ClientInfo client = 1;
  bool has_client() const;
  private:
  bool _internal_has_client() const;
  public:
  void clear_client();
  const ::safe_browsing::ClientInfo& client() const;
  PROTOBUF_NODISCARD ::safe_browsing::ClientInfo* release_client();
  ::safe_browsing::ClientInfo* mutable_client();
  void set_allocated_client(::safe_browsing::ClientInfo* client);
  private:
  const ::safe_browsing::ClientInfo& _internal_client() const;
  ::safe_browsing::ClientInfo* _internal_mutable_client();
  public:
  void unsafe_arena_set_allocated_client(
      ::safe_browsing::ClientInfo* client);
  ::safe_browsing::ClientInfo* unsafe_arena_release_client();

  // optional .safe_browsing.ThreatInfo threat_info = 2;
  bool has_threat_info() const;
  private:
  bool _internal_has_threat_info() const;
  public:
  void clear_threat_info();
  const ::safe_browsing::ThreatInfo& threat_info() const;
  PROTOBUF_NODISCARD ::safe_browsing::ThreatInfo* release_threat_info();
  ::safe_browsing::ThreatInfo* mutable_threat_info();
  void set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info);
  private:
  const ::safe_browsing::ThreatInfo& _internal_threat_info() const;
  ::safe_browsing::ThreatInfo* _internal_mutable_threat_info();
  public:
  void unsafe_arena_set_allocated_threat_info(
      ::safe_browsing::ThreatInfo* threat_info);
  ::safe_browsing::ThreatInfo* unsafe_arena_release_threat_info();

  // @@protoc_insertion_point(class_scope:safe_browsing.FindThreatMatchesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::safe_browsing::ClientInfo* client_;
  ::safe_browsing::ThreatInfo* threat_info_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindThreatMatchesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindThreatMatchesResponse) */ {
 public:
  inline FindThreatMatchesResponse() : FindThreatMatchesResponse(nullptr) {}
  ~FindThreatMatchesResponse() override;
  explicit PROTOBUF_CONSTEXPR FindThreatMatchesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindThreatMatchesResponse(const FindThreatMatchesResponse& from);
  FindThreatMatchesResponse(FindThreatMatchesResponse&& from) noexcept
    : FindThreatMatchesResponse() {
    *this = ::std::move(from);
  }

  inline FindThreatMatchesResponse& operator=(const FindThreatMatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindThreatMatchesResponse& operator=(FindThreatMatchesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FindThreatMatchesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindThreatMatchesResponse* internal_default_instance() {
    return reinterpret_cast<const FindThreatMatchesResponse*>(
               &_FindThreatMatchesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FindThreatMatchesResponse& a, FindThreatMatchesResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FindThreatMatchesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindThreatMatchesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindThreatMatchesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindThreatMatchesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FindThreatMatchesResponse& from);
  void MergeFrom(const FindThreatMatchesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindThreatMatchesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindThreatMatchesResponse";
  }
  protected:
  explicit FindThreatMatchesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 1,
  };
  // repeated .safe_browsing.ThreatMatch matches = 1;
  int matches_size() const;
  private:
  int _internal_matches_size() const;
  public:
  void clear_matches();
  ::safe_browsing::ThreatMatch* mutable_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
      mutable_matches();
  private:
  const ::safe_browsing::ThreatMatch& _internal_matches(int index) const;
  ::safe_browsing::ThreatMatch* _internal_add_matches();
  public:
  const ::safe_browsing::ThreatMatch& matches(int index) const;
  ::safe_browsing::ThreatMatch* add_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
      matches() const;

  // @@protoc_insertion_point(class_scope:safe_browsing.FindThreatMatchesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch > matches_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints) */ {
 public:
  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() : FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(nullptr) {}
  ~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() override;
  explicit PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&& from) noexcept
    : FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
               &_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& a, FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
  }
  protected:
  explicit FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedCompressionsFieldNumber = 4,
    kRegionFieldNumber = 3,
    kMaxUpdateEntriesFieldNumber = 1,
    kMaxDatabaseEntriesFieldNumber = 2,
  };
  // repeated .safe_browsing.CompressionType supported_compressions = 4;
  int supported_compressions_size() const;
  private:
  int _internal_supported_compressions_size() const;
  public:
  void clear_supported_compressions();
  private:
  ::safe_browsing::CompressionType _internal_supported_compressions(int index) const;
  void _internal_add_supported_compressions(::safe_browsing::CompressionType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_compressions();
  public:
  ::safe_browsing::CompressionType supported_compressions(int index) const;
  void set_supported_compressions(int index, ::safe_browsing::CompressionType value);
  void add_supported_compressions(::safe_browsing::CompressionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_compressions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_compressions();

  // optional string region = 3;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional int32 max_update_entries = 1;
  bool has_max_update_entries() const;
  private:
  bool _internal_has_max_update_entries() const;
  public:
  void clear_max_update_entries();
  int32_t max_update_entries() const;
  void set_max_update_entries(int32_t value);
  private:
  int32_t _internal_max_update_entries() const;
  void _internal_set_max_update_entries(int32_t value);
  public:

  // optional int32 max_database_entries = 2;
  bool has_max_database_entries() const;
  private:
  bool _internal_has_max_database_entries() const;
  public:
  void clear_max_database_entries();
  int32_t max_database_entries() const;
  void set_max_database_entries(int32_t value);
  private:
  int32_t _internal_max_database_entries() const;
  void _internal_set_max_database_entries(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_compressions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  int32_t max_update_entries_;
  int32_t max_database_entries_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest) */ {
 public:
  inline FetchThreatListUpdatesRequest_ListUpdateRequest() : FetchThreatListUpdatesRequest_ListUpdateRequest(nullptr) {}
  ~FetchThreatListUpdatesRequest_ListUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  FetchThreatListUpdatesRequest_ListUpdateRequest(FetchThreatListUpdatesRequest_ListUpdateRequest&& from) noexcept
    : FetchThreatListUpdatesRequest_ListUpdateRequest() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(FetchThreatListUpdatesRequest_ListUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(
               &_FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FetchThreatListUpdatesRequest_ListUpdateRequest& a, FetchThreatListUpdatesRequest_ListUpdateRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesRequest_ListUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest_ListUpdateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
  }
  protected:
  explicit FetchThreatListUpdatesRequest_ListUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints Constraints;

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 3,
    kConstraintsFieldNumber = 4,
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
    kThreatEntryTypeFieldNumber = 5,
  };
  // optional bytes state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  bool has_constraints() const;
  private:
  bool _internal_has_constraints() const;
  public:
  void clear_constraints();
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints() const;
  PROTOBUF_NODISCARD ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* release_constraints();
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* mutable_constraints();
  void set_allocated_constraints(::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints);
  private:
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& _internal_constraints() const;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* _internal_mutable_constraints();
  public:
  void unsafe_arena_set_allocated_constraints(
      ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints);
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* unsafe_arena_release_constraints();

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  private:
  bool _internal_has_threat_type() const;
  public:
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);
  private:
  ::safe_browsing::ThreatType _internal_threat_type() const;
  void _internal_set_threat_type(::safe_browsing::ThreatType value);
  public:

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);
  private:
  ::safe_browsing::PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::safe_browsing::PlatformType value);
  public:

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
  bool has_threat_entry_type() const;
  private:
  bool _internal_has_threat_entry_type() const;
  public:
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  private:
  ::safe_browsing::ThreatEntryType _internal_threat_entry_type() const;
  void _internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesRequest) */ {
 public:
  inline FetchThreatListUpdatesRequest() : FetchThreatListUpdatesRequest(nullptr) {}
  ~FetchThreatListUpdatesRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from);
  FetchThreatListUpdatesRequest(FetchThreatListUpdatesRequest&& from) noexcept
    : FetchThreatListUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesRequest& operator=(const FetchThreatListUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesRequest& operator=(FetchThreatListUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FetchThreatListUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchThreatListUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesRequest*>(
               &_FetchThreatListUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FetchThreatListUpdatesRequest& a, FetchThreatListUpdatesRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FetchThreatListUpdatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchThreatListUpdatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FetchThreatListUpdatesRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesRequest";
  }
  protected:
  explicit FetchThreatListUpdatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest ListUpdateRequest;

  // accessors -------------------------------------------------------

  enum : int {
    kListUpdateRequestsFieldNumber = 3,
    kClientFieldNumber = 1,
    kChromeClientInfoFieldNumber = 4,
  };
  // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  int list_update_requests_size() const;
  private:
  int _internal_list_update_requests_size() const;
  public:
  void clear_list_update_requests();
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* mutable_list_update_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
      mutable_list_update_requests();
  private:
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& _internal_list_update_requests(int index) const;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* _internal_add_list_update_requests();
  public:
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& list_update_requests(int index) const;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* add_list_update_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
      list_update_requests() const;

  // optional .safe_browsing.ClientInfo client = 1;
  bool has_client() const;
  private:
  bool _internal_has_client() const;
  public:
  void clear_client();
  const ::safe_browsing::ClientInfo& client() const;
  PROTOBUF_NODISCARD ::safe_browsing::ClientInfo* release_client();
  ::safe_browsing::ClientInfo* mutable_client();
  void set_allocated_client(::safe_browsing::ClientInfo* client);
  private:
  const ::safe_browsing::ClientInfo& _internal_client() const;
  ::safe_browsing::ClientInfo* _internal_mutable_client();
  public:
  void unsafe_arena_set_allocated_client(
      ::safe_browsing::ClientInfo* client);
  ::safe_browsing::ClientInfo* unsafe_arena_release_client();

  // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
  bool has_chrome_client_info() const;
  private:
  bool _internal_has_chrome_client_info() const;
  public:
  void clear_chrome_client_info();
  const ::safe_browsing::ChromeClientInfo& chrome_client_info() const;
  PROTOBUF_NODISCARD ::safe_browsing::ChromeClientInfo* release_chrome_client_info();
  ::safe_browsing::ChromeClientInfo* mutable_chrome_client_info();
  void set_allocated_chrome_client_info(::safe_browsing::ChromeClientInfo* chrome_client_info);
  private:
  const ::safe_browsing::ChromeClientInfo& _internal_chrome_client_info() const;
  ::safe_browsing::ChromeClientInfo* _internal_mutable_chrome_client_info();
  public:
  void unsafe_arena_set_allocated_chrome_client_info(
      ::safe_browsing::ChromeClientInfo* chrome_client_info);
  ::safe_browsing::ChromeClientInfo* unsafe_arena_release_chrome_client_info();

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest > list_update_requests_;
  ::safe_browsing::ClientInfo* client_;
  ::safe_browsing::ChromeClientInfo* chrome_client_info_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse_ListUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse) */ {
 public:
  inline FetchThreatListUpdatesResponse_ListUpdateResponse() : FetchThreatListUpdatesResponse_ListUpdateResponse(nullptr) {}
  ~FetchThreatListUpdatesResponse_ListUpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse_ListUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  FetchThreatListUpdatesResponse_ListUpdateResponse(FetchThreatListUpdatesResponse_ListUpdateResponse&& from) noexcept
    : FetchThreatListUpdatesResponse_ListUpdateResponse() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(FetchThreatListUpdatesResponse_ListUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FetchThreatListUpdatesResponse_ListUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchThreatListUpdatesResponse_ListUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(
               &_FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FetchThreatListUpdatesResponse_ListUpdateResponse& a, FetchThreatListUpdatesResponse_ListUpdateResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesResponse_ListUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesResponse_ListUpdateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
  }
  protected:
  explicit FetchThreatListUpdatesResponse_ListUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType ResponseType;
  static constexpr ResponseType RESPONSE_TYPE_UNSPECIFIED =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
  static constexpr ResponseType PARTIAL_UPDATE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE;
  static constexpr ResponseType FULL_UPDATE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
  static inline bool ResponseType_IsValid(int value) {
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value);
  }
  static constexpr ResponseType ResponseType_MIN =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN;
  static constexpr ResponseType ResponseType_MAX =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX;
  static constexpr int ResponseType_ARRAYSIZE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResponseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseType_Name.");
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(enum_t_value);
  }
  static inline bool ResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResponseType* value) {
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionsFieldNumber = 5,
    kRemovalsFieldNumber = 6,
    kNewClientStateFieldNumber = 7,
    kChecksumFieldNumber = 8,
    kThreatTypeFieldNumber = 1,
    kThreatEntryTypeFieldNumber = 2,
    kPlatformTypeFieldNumber = 3,
    kResponseTypeFieldNumber = 4,
  };
  // repeated .safe_browsing.ThreatEntrySet additions = 5;
  int additions_size() const;
  private:
  int _internal_additions_size() const;
  public:
  void clear_additions();
  ::safe_browsing::ThreatEntrySet* mutable_additions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
      mutable_additions();
  private:
  const ::safe_browsing::ThreatEntrySet& _internal_additions(int index) const;
  ::safe_browsing::ThreatEntrySet* _internal_add_additions();
  public:
  const ::safe_browsing::ThreatEntrySet& additions(int index) const;
  ::safe_browsing::ThreatEntrySet* add_additions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
      additions() const;

  // repeated .safe_browsing.ThreatEntrySet removals = 6;
  int removals_size() const;
  private:
  int _internal_removals_size() const;
  public:
  void clear_removals();
  ::safe_browsing::ThreatEntrySet* mutable_removals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
      mutable_removals();
  private:
  const ::safe_browsing::ThreatEntrySet& _internal_removals(int index) const;
  ::safe_browsing::ThreatEntrySet* _internal_add_removals();
  public:
  const ::safe_browsing::ThreatEntrySet& removals(int index) const;
  ::safe_browsing::ThreatEntrySet* add_removals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
      removals() const;

  // optional bytes new_client_state = 7;
  bool has_new_client_state() const;
  private:
  bool _internal_has_new_client_state() const;
  public:
  void clear_new_client_state();
  const std::string& new_client_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_client_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_client_state();
  PROTOBUF_NODISCARD std::string* release_new_client_state();
  void set_allocated_new_client_state(std::string* new_client_state);
  private:
  const std::string& _internal_new_client_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_client_state(const std::string& value);
  std::string* _internal_mutable_new_client_state();
  public:

  // optional .safe_browsing.Checksum checksum = 8;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  const ::safe_browsing::Checksum& checksum() const;
  PROTOBUF_NODISCARD ::safe_browsing::Checksum* release_checksum();
  ::safe_browsing::Checksum* mutable_checksum();
  void set_allocated_checksum(::safe_browsing::Checksum* checksum);
  private:
  const ::safe_browsing::Checksum& _internal_checksum() const;
  ::safe_browsing::Checksum* _internal_mutable_checksum();
  public:
  void unsafe_arena_set_allocated_checksum(
      ::safe_browsing::Checksum* checksum);
  ::safe_browsing::Checksum* unsafe_arena_release_checksum();

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  private:
  bool _internal_has_threat_type() const;
  public:
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);
  private:
  ::safe_browsing::ThreatType _internal_threat_type() const;
  void _internal_set_threat_type(::safe_browsing::ThreatType value);
  public:

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
  bool has_threat_entry_type() const;
  private:
  bool _internal_has_threat_entry_type() const;
  public:
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  private:
  ::safe_browsing::ThreatEntryType _internal_threat_entry_type() const;
  void _internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  public:

  // optional .safe_browsing.PlatformType platform_type = 3;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);
  private:
  ::safe_browsing::PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::safe_browsing::PlatformType value);
  public:

  // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  bool has_response_type() const;
  private:
  bool _internal_has_response_type() const;
  public:
  void clear_response_type();
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType response_type() const;
  void set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);
  private:
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType _internal_response_type() const;
  void _internal_set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet > additions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet > removals_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_client_state_;
  ::safe_browsing::Checksum* checksum_;
  int threat_type_;
  int threat_entry_type_;
  int platform_type_;
  int response_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FetchThreatListUpdatesResponse) */ {
 public:
  inline FetchThreatListUpdatesResponse() : FetchThreatListUpdatesResponse(nullptr) {}
  ~FetchThreatListUpdatesResponse() override;
  explicit PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from);
  FetchThreatListUpdatesResponse(FetchThreatListUpdatesResponse&& from) noexcept
    : FetchThreatListUpdatesResponse() {
    *this = ::std::move(from);
  }

  inline FetchThreatListUpdatesResponse& operator=(const FetchThreatListUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchThreatListUpdatesResponse& operator=(FetchThreatListUpdatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FetchThreatListUpdatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchThreatListUpdatesResponse* internal_default_instance() {
    return reinterpret_cast<const FetchThreatListUpdatesResponse*>(
               &_FetchThreatListUpdatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FetchThreatListUpdatesResponse& a, FetchThreatListUpdatesResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FetchThreatListUpdatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchThreatListUpdatesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchThreatListUpdatesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FetchThreatListUpdatesResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FetchThreatListUpdatesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FetchThreatListUpdatesResponse";
  }
  protected:
  explicit FetchThreatListUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse ListUpdateResponse;

  // accessors -------------------------------------------------------

  enum : int {
    kListUpdateResponsesFieldNumber = 1,
    kMinimumWaitDurationFieldNumber = 2,
  };
  // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  int list_update_responses_size() const;
  private:
  int _internal_list_update_responses_size() const;
  public:
  void clear_list_update_responses();
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* mutable_list_update_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
      mutable_list_update_responses();
  private:
  const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& _internal_list_update_responses(int index) const;
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* _internal_add_list_update_responses();
  public:
  const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& list_update_responses(int index) const;
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* add_list_update_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
      list_update_responses() const;

  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  bool has_minimum_wait_duration() const;
  private:
  bool _internal_has_minimum_wait_duration() const;
  public:
  void clear_minimum_wait_duration();
  const ::safe_browsing::Duration& minimum_wait_duration() const;
  PROTOBUF_NODISCARD ::safe_browsing::Duration* release_minimum_wait_duration();
  ::safe_browsing::Duration* mutable_minimum_wait_duration();
  void set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration);
  private:
  const ::safe_browsing::Duration& _internal_minimum_wait_duration() const;
  ::safe_browsing::Duration* _internal_mutable_minimum_wait_duration();
  public:
  void unsafe_arena_set_allocated_minimum_wait_duration(
      ::safe_browsing::Duration* minimum_wait_duration);
  ::safe_browsing::Duration* unsafe_arena_release_minimum_wait_duration();

  // @@protoc_insertion_point(class_scope:safe_browsing.FetchThreatListUpdatesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse > list_update_responses_;
  ::safe_browsing::Duration* minimum_wait_duration_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindFullHashesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindFullHashesRequest) */ {
 public:
  inline FindFullHashesRequest() : FindFullHashesRequest(nullptr) {}
  ~FindFullHashesRequest() override;
  explicit PROTOBUF_CONSTEXPR FindFullHashesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindFullHashesRequest(const FindFullHashesRequest& from);
  FindFullHashesRequest(FindFullHashesRequest&& from) noexcept
    : FindFullHashesRequest() {
    *this = ::std::move(from);
  }

  inline FindFullHashesRequest& operator=(const FindFullHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindFullHashesRequest& operator=(FindFullHashesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FindFullHashesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindFullHashesRequest* internal_default_instance() {
    return reinterpret_cast<const FindFullHashesRequest*>(
               &_FindFullHashesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FindFullHashesRequest& a, FindFullHashesRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FindFullHashesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindFullHashesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindFullHashesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindFullHashesRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FindFullHashesRequest& from);
  void MergeFrom(const FindFullHashesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindFullHashesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindFullHashesRequest";
  }
  protected:
  explicit FindFullHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientStatesFieldNumber = 2,
    kClientFieldNumber = 1,
    kThreatInfoFieldNumber = 3,
  };
  // repeated bytes client_states = 2;
  int client_states_size() const;
  private:
  int _internal_client_states_size() const;
  public:
  void clear_client_states();
  const std::string& client_states(int index) const;
  std::string* mutable_client_states(int index);
  void set_client_states(int index, const std::string& value);
  void set_client_states(int index, std::string&& value);
  void set_client_states(int index, const char* value);
  void set_client_states(int index, const void* value, size_t size);
  std::string* add_client_states();
  void add_client_states(const std::string& value);
  void add_client_states(std::string&& value);
  void add_client_states(const char* value);
  void add_client_states(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& client_states() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_client_states();
  private:
  const std::string& _internal_client_states(int index) const;
  std::string* _internal_add_client_states();
  public:

  // optional .safe_browsing.ClientInfo client = 1;
  bool has_client() const;
  private:
  bool _internal_has_client() const;
  public:
  void clear_client();
  const ::safe_browsing::ClientInfo& client() const;
  PROTOBUF_NODISCARD ::safe_browsing::ClientInfo* release_client();
  ::safe_browsing::ClientInfo* mutable_client();
  void set_allocated_client(::safe_browsing::ClientInfo* client);
  private:
  const ::safe_browsing::ClientInfo& _internal_client() const;
  ::safe_browsing::ClientInfo* _internal_mutable_client();
  public:
  void unsafe_arena_set_allocated_client(
      ::safe_browsing::ClientInfo* client);
  ::safe_browsing::ClientInfo* unsafe_arena_release_client();

  // optional .safe_browsing.ThreatInfo threat_info = 3;
  bool has_threat_info() const;
  private:
  bool _internal_has_threat_info() const;
  public:
  void clear_threat_info();
  const ::safe_browsing::ThreatInfo& threat_info() const;
  PROTOBUF_NODISCARD ::safe_browsing::ThreatInfo* release_threat_info();
  ::safe_browsing::ThreatInfo* mutable_threat_info();
  void set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info);
  private:
  const ::safe_browsing::ThreatInfo& _internal_threat_info() const;
  ::safe_browsing::ThreatInfo* _internal_mutable_threat_info();
  public:
  void unsafe_arena_set_allocated_threat_info(
      ::safe_browsing::ThreatInfo* threat_info);
  ::safe_browsing::ThreatInfo* unsafe_arena_release_threat_info();

  // @@protoc_insertion_point(class_scope:safe_browsing.FindFullHashesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> client_states_;
  ::safe_browsing::ClientInfo* client_;
  ::safe_browsing::ThreatInfo* threat_info_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class FindFullHashesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.FindFullHashesResponse) */ {
 public:
  inline FindFullHashesResponse() : FindFullHashesResponse(nullptr) {}
  ~FindFullHashesResponse() override;
  explicit PROTOBUF_CONSTEXPR FindFullHashesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindFullHashesResponse(const FindFullHashesResponse& from);
  FindFullHashesResponse(FindFullHashesResponse&& from) noexcept
    : FindFullHashesResponse() {
    *this = ::std::move(from);
  }

  inline FindFullHashesResponse& operator=(const FindFullHashesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindFullHashesResponse& operator=(FindFullHashesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FindFullHashesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindFullHashesResponse* internal_default_instance() {
    return reinterpret_cast<const FindFullHashesResponse*>(
               &_FindFullHashesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FindFullHashesResponse& a, FindFullHashesResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FindFullHashesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindFullHashesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindFullHashesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindFullHashesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FindFullHashesResponse& from);
  void MergeFrom(const FindFullHashesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindFullHashesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.FindFullHashesResponse";
  }
  protected:
  explicit FindFullHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 1,
    kMinimumWaitDurationFieldNumber = 2,
    kNegativeCacheDurationFieldNumber = 3,
  };
  // repeated .safe_browsing.ThreatMatch matches = 1;
  int matches_size() const;
  private:
  int _internal_matches_size() const;
  public:
  void clear_matches();
  ::safe_browsing::ThreatMatch* mutable_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
      mutable_matches();
  private:
  const ::safe_browsing::ThreatMatch& _internal_matches(int index) const;
  ::safe_browsing::ThreatMatch* _internal_add_matches();
  public:
  const ::safe_browsing::ThreatMatch& matches(int index) const;
  ::safe_browsing::ThreatMatch* add_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
      matches() const;

  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  bool has_minimum_wait_duration() const;
  private:
  bool _internal_has_minimum_wait_duration() const;
  public:
  void clear_minimum_wait_duration();
  const ::safe_browsing::Duration& minimum_wait_duration() const;
  PROTOBUF_NODISCARD ::safe_browsing::Duration* release_minimum_wait_duration();
  ::safe_browsing::Duration* mutable_minimum_wait_duration();
  void set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration);
  private:
  const ::safe_browsing::Duration& _internal_minimum_wait_duration() const;
  ::safe_browsing::Duration* _internal_mutable_minimum_wait_duration();
  public:
  void unsafe_arena_set_allocated_minimum_wait_duration(
      ::safe_browsing::Duration* minimum_wait_duration);
  ::safe_browsing::Duration* unsafe_arena_release_minimum_wait_duration();

  // optional .safe_browsing.Duration negative_cache_duration = 3;
  bool has_negative_cache_duration() const;
  private:
  bool _internal_has_negative_cache_duration() const;
  public:
  void clear_negative_cache_duration();
  const ::safe_browsing::Duration& negative_cache_duration() const;
  PROTOBUF_NODISCARD ::safe_browsing::Duration* release_negative_cache_duration();
  ::safe_browsing::Duration* mutable_negative_cache_duration();
  void set_allocated_negative_cache_duration(::safe_browsing::Duration* negative_cache_duration);
  private:
  const ::safe_browsing::Duration& _internal_negative_cache_duration() const;
  ::safe_browsing::Duration* _internal_mutable_negative_cache_duration();
  public:
  void unsafe_arena_set_allocated_negative_cache_duration(
      ::safe_browsing::Duration* negative_cache_duration);
  ::safe_browsing::Duration* unsafe_arena_release_negative_cache_duration();

  // @@protoc_insertion_point(class_scope:safe_browsing.FindFullHashesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch > matches_;
  ::safe_browsing::Duration* minimum_wait_duration_;
  ::safe_browsing::Duration* negative_cache_duration_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatHit_ThreatSource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatHit.ThreatSource) */ {
 public:
  inline ThreatHit_ThreatSource() : ThreatHit_ThreatSource(nullptr) {}
  ~ThreatHit_ThreatSource() override;
  explicit PROTOBUF_CONSTEXPR ThreatHit_ThreatSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from);
  ThreatHit_ThreatSource(ThreatHit_ThreatSource&& from) noexcept
    : ThreatHit_ThreatSource() {
    *this = ::std::move(from);
  }

  inline ThreatHit_ThreatSource& operator=(const ThreatHit_ThreatSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatHit_ThreatSource& operator=(ThreatHit_ThreatSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatHit_ThreatSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatHit_ThreatSource* internal_default_instance() {
    return reinterpret_cast<const ThreatHit_ThreatSource*>(
               &_ThreatHit_ThreatSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ThreatHit_ThreatSource& a, ThreatHit_ThreatSource& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatHit_ThreatSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatHit_ThreatSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatHit_ThreatSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatHit_ThreatSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatHit_ThreatSource& from);
  void MergeFrom(const ThreatHit_ThreatSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit_ThreatSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatHit.ThreatSource";
  }
  protected:
  explicit ThreatHit_ThreatSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kRemoteIpFieldNumber = 3,
    kReferrerFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string remote_ip = 3;
  bool has_remote_ip() const;
  private:
  bool _internal_has_remote_ip() const;
  public:
  void clear_remote_ip();
  const std::string& remote_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_ip();
  PROTOBUF_NODISCARD std::string* release_remote_ip();
  void set_allocated_remote_ip(std::string* remote_ip);
  private:
  const std::string& _internal_remote_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_ip(const std::string& value);
  std::string* _internal_mutable_remote_ip();
  public:

  // optional string referrer = 4;
  bool has_referrer() const;
  private:
  bool _internal_has_referrer() const;
  public:
  void clear_referrer();
  const std::string& referrer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referrer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referrer();
  PROTOBUF_NODISCARD std::string* release_referrer();
  void set_allocated_referrer(std::string* referrer);
  private:
  const std::string& _internal_referrer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referrer(const std::string& value);
  std::string* _internal_mutable_referrer();
  public:

  // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::safe_browsing::ThreatHit_ThreatSourceType type() const;
  void set_type(::safe_browsing::ThreatHit_ThreatSourceType value);
  private:
  ::safe_browsing::ThreatHit_ThreatSourceType _internal_type() const;
  void _internal_set_type(::safe_browsing::ThreatHit_ThreatSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatHit.ThreatSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referrer_;
  int type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatHit final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatHit) */ {
 public:
  inline ThreatHit() : ThreatHit(nullptr) {}
  ~ThreatHit() override;
  explicit PROTOBUF_CONSTEXPR ThreatHit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatHit(const ThreatHit& from);
  ThreatHit(ThreatHit&& from) noexcept
    : ThreatHit() {
    *this = ::std::move(from);
  }

  inline ThreatHit& operator=(const ThreatHit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatHit& operator=(ThreatHit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatHit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatHit* internal_default_instance() {
    return reinterpret_cast<const ThreatHit*>(
               &_ThreatHit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ThreatHit& a, ThreatHit& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatHit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatHit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatHit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatHit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatHit& from);
  void MergeFrom(const ThreatHit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatHit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatHit";
  }
  protected:
  explicit ThreatHit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ThreatHit_ThreatSource ThreatSource;

  typedef ThreatHit_ThreatSourceType ThreatSourceType;
  static constexpr ThreatSourceType THREAT_SOURCE_TYPE_UNSPECIFIED =
    ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
  static constexpr ThreatSourceType MATCHING_URL =
    ThreatHit_ThreatSourceType_MATCHING_URL;
  static constexpr ThreatSourceType TAB_URL =
    ThreatHit_ThreatSourceType_TAB_URL;
  static constexpr ThreatSourceType TAB_REDIRECT =
    ThreatHit_ThreatSourceType_TAB_REDIRECT;
  static inline bool ThreatSourceType_IsValid(int value) {
    return ThreatHit_ThreatSourceType_IsValid(value);
  }
  static constexpr ThreatSourceType ThreatSourceType_MIN =
    ThreatHit_ThreatSourceType_ThreatSourceType_MIN;
  static constexpr ThreatSourceType ThreatSourceType_MAX =
    ThreatHit_ThreatSourceType_ThreatSourceType_MAX;
  static constexpr int ThreatSourceType_ARRAYSIZE =
    ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ThreatSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThreatSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThreatSourceType_Name.");
    return ThreatHit_ThreatSourceType_Name(enum_t_value);
  }
  static inline bool ThreatSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ThreatSourceType* value) {
    return ThreatHit_ThreatSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 4,
    kEntryFieldNumber = 3,
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
  };
  // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::safe_browsing::ThreatHit_ThreatSource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >*
      mutable_resources();
  private:
  const ::safe_browsing::ThreatHit_ThreatSource& _internal_resources(int index) const;
  ::safe_browsing::ThreatHit_ThreatSource* _internal_add_resources();
  public:
  const ::safe_browsing::ThreatHit_ThreatSource& resources(int index) const;
  ::safe_browsing::ThreatHit_ThreatSource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >&
      resources() const;

  // optional .safe_browsing.ThreatEntry entry = 3;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  const ::safe_browsing::ThreatEntry& entry() const;
  PROTOBUF_NODISCARD ::safe_browsing::ThreatEntry* release_entry();
  ::safe_browsing::ThreatEntry* mutable_entry();
  void set_allocated_entry(::safe_browsing::ThreatEntry* entry);
  private:
  const ::safe_browsing::ThreatEntry& _internal_entry() const;
  ::safe_browsing::ThreatEntry* _internal_mutable_entry();
  public:
  void unsafe_arena_set_allocated_entry(
      ::safe_browsing::ThreatEntry* entry);
  ::safe_browsing::ThreatEntry* unsafe_arena_release_entry();

  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  private:
  bool _internal_has_threat_type() const;
  public:
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);
  private:
  ::safe_browsing::ThreatType _internal_threat_type() const;
  void _internal_set_threat_type(::safe_browsing::ThreatType value);
  public:

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);
  private:
  ::safe_browsing::PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::safe_browsing::PlatformType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatHit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource > resources_;
  ::safe_browsing::ThreatEntry* entry_;
  int threat_type_;
  int platform_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit PROTOBUF_CONSTEXPR ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kClientVersionFieldNumber = 2,
  };
  // optional string client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // optional string client_version = 2;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ChromeClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ChromeClientInfo) */ {
 public:
  inline ChromeClientInfo() : ChromeClientInfo(nullptr) {}
  ~ChromeClientInfo() override;
  explicit PROTOBUF_CONSTEXPR ChromeClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeClientInfo(const ChromeClientInfo& from);
  ChromeClientInfo(ChromeClientInfo&& from) noexcept
    : ChromeClientInfo() {
    *this = ::std::move(from);
  }

  inline ChromeClientInfo& operator=(const ChromeClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeClientInfo& operator=(ChromeClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeClientInfo* internal_default_instance() {
    return reinterpret_cast<const ChromeClientInfo*>(
               &_ChromeClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ChromeClientInfo& a, ChromeClientInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ChromeClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeClientInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeClientInfo& from);
  void MergeFrom(const ChromeClientInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ChromeClientInfo";
  }
  protected:
  explicit ChromeClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ChromeClientInfo_SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation;
  static constexpr SafeBrowsingReportingPopulation UNSPECIFIED =
    ChromeClientInfo_SafeBrowsingReportingPopulation_UNSPECIFIED;
  static constexpr SafeBrowsingReportingPopulation OPT_OUT =
    ChromeClientInfo_SafeBrowsingReportingPopulation_OPT_OUT;
  static constexpr SafeBrowsingReportingPopulation EXTENDED =
    ChromeClientInfo_SafeBrowsingReportingPopulation_EXTENDED;
  static constexpr SafeBrowsingReportingPopulation SCOUT =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SCOUT;
  static inline bool SafeBrowsingReportingPopulation_IsValid(int value) {
    return ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value);
  }
  static constexpr SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation_MIN =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MIN;
  static constexpr SafeBrowsingReportingPopulation SafeBrowsingReportingPopulation_MAX =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_MAX;
  static constexpr int SafeBrowsingReportingPopulation_ARRAYSIZE =
    ChromeClientInfo_SafeBrowsingReportingPopulation_SafeBrowsingReportingPopulation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SafeBrowsingReportingPopulation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SafeBrowsingReportingPopulation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SafeBrowsingReportingPopulation_Name.");
    return ChromeClientInfo_SafeBrowsingReportingPopulation_Name(enum_t_value);
  }
  static inline bool SafeBrowsingReportingPopulation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SafeBrowsingReportingPopulation* value) {
    return ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReportingPopulationFieldNumber = 1,
  };
  // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  bool has_reporting_population() const;
  private:
  bool _internal_has_reporting_population() const;
  public:
  void clear_reporting_population();
  ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation reporting_population() const;
  void set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value);
  private:
  ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation _internal_reporting_population() const;
  void _internal_set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ChromeClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int reporting_population_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class Checksum final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.Checksum) */ {
 public:
  inline Checksum() : Checksum(nullptr) {}
  ~Checksum() override;
  explicit PROTOBUF_CONSTEXPR Checksum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Checksum(const Checksum& from);
  Checksum(Checksum&& from) noexcept
    : Checksum() {
    *this = ::std::move(from);
  }

  inline Checksum& operator=(const Checksum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Checksum& operator=(Checksum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Checksum& default_instance() {
    return *internal_default_instance();
  }
  static inline const Checksum* internal_default_instance() {
    return reinterpret_cast<const Checksum*>(
               &_Checksum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Checksum& a, Checksum& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Checksum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Checksum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Checksum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Checksum>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Checksum& from);
  void MergeFrom(const Checksum& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Checksum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.Checksum";
  }
  protected:
  explicit Checksum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSha256FieldNumber = 1,
  };
  // optional bytes sha256 = 1;
  bool has_sha256() const;
  private:
  bool _internal_has_sha256() const;
  public:
  void clear_sha256();
  const std::string& sha256() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha256(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha256();
  PROTOBUF_NODISCARD std::string* release_sha256();
  void set_allocated_sha256(std::string* sha256);
  private:
  const std::string& _internal_sha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha256(const std::string& value);
  std::string* _internal_mutable_sha256();
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.Checksum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha256_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntry) */ {
 public:
  inline ThreatEntry() : ThreatEntry(nullptr) {}
  ~ThreatEntry() override;
  explicit PROTOBUF_CONSTEXPR ThreatEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatEntry(const ThreatEntry& from);
  ThreatEntry(ThreatEntry&& from) noexcept
    : ThreatEntry() {
    *this = ::std::move(from);
  }

  inline ThreatEntry& operator=(const ThreatEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntry& operator=(ThreatEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatEntry* internal_default_instance() {
    return reinterpret_cast<const ThreatEntry*>(
               &_ThreatEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ThreatEntry& a, ThreatEntry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatEntry& from);
  void MergeFrom(const ThreatEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntry";
  }
  protected:
  explicit ThreatEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kUrlFieldNumber = 2,
  };
  // optional bytes hash = 1;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntrySet final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntrySet) */ {
 public:
  inline ThreatEntrySet() : ThreatEntrySet(nullptr) {}
  ~ThreatEntrySet() override;
  explicit PROTOBUF_CONSTEXPR ThreatEntrySet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatEntrySet(const ThreatEntrySet& from);
  ThreatEntrySet(ThreatEntrySet&& from) noexcept
    : ThreatEntrySet() {
    *this = ::std::move(from);
  }

  inline ThreatEntrySet& operator=(const ThreatEntrySet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntrySet& operator=(ThreatEntrySet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatEntrySet& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatEntrySet* internal_default_instance() {
    return reinterpret_cast<const ThreatEntrySet*>(
               &_ThreatEntrySet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ThreatEntrySet& a, ThreatEntrySet& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatEntrySet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatEntrySet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatEntrySet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatEntrySet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatEntrySet& from);
  void MergeFrom(const ThreatEntrySet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntrySet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntrySet";
  }
  protected:
  explicit ThreatEntrySet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawHashesFieldNumber = 2,
    kRawIndicesFieldNumber = 3,
    kRiceHashesFieldNumber = 4,
    kRiceIndicesFieldNumber = 5,
    kCompressionTypeFieldNumber = 1,
  };
  // optional .safe_browsing.RawHashes raw_hashes = 2;
  bool has_raw_hashes() const;
  private:
  bool _internal_has_raw_hashes() const;
  public:
  void clear_raw_hashes();
  const ::safe_browsing::RawHashes& raw_hashes() const;
  PROTOBUF_NODISCARD ::safe_browsing::RawHashes* release_raw_hashes();
  ::safe_browsing::RawHashes* mutable_raw_hashes();
  void set_allocated_raw_hashes(::safe_browsing::RawHashes* raw_hashes);
  private:
  const ::safe_browsing::RawHashes& _internal_raw_hashes() const;
  ::safe_browsing::RawHashes* _internal_mutable_raw_hashes();
  public:
  void unsafe_arena_set_allocated_raw_hashes(
      ::safe_browsing::RawHashes* raw_hashes);
  ::safe_browsing::RawHashes* unsafe_arena_release_raw_hashes();

  // optional .safe_browsing.RawIndices raw_indices = 3;
  bool has_raw_indices() const;
  private:
  bool _internal_has_raw_indices() const;
  public:
  void clear_raw_indices();
  const ::safe_browsing::RawIndices& raw_indices() const;
  PROTOBUF_NODISCARD ::safe_browsing::RawIndices* release_raw_indices();
  ::safe_browsing::RawIndices* mutable_raw_indices();
  void set_allocated_raw_indices(::safe_browsing::RawIndices* raw_indices);
  private:
  const ::safe_browsing::RawIndices& _internal_raw_indices() const;
  ::safe_browsing::RawIndices* _internal_mutable_raw_indices();
  public:
  void unsafe_arena_set_allocated_raw_indices(
      ::safe_browsing::RawIndices* raw_indices);
  ::safe_browsing::RawIndices* unsafe_arena_release_raw_indices();

  // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
  bool has_rice_hashes() const;
  private:
  bool _internal_has_rice_hashes() const;
  public:
  void clear_rice_hashes();
  const ::safe_browsing::RiceDeltaEncoding& rice_hashes() const;
  PROTOBUF_NODISCARD ::safe_browsing::RiceDeltaEncoding* release_rice_hashes();
  ::safe_browsing::RiceDeltaEncoding* mutable_rice_hashes();
  void set_allocated_rice_hashes(::safe_browsing::RiceDeltaEncoding* rice_hashes);
  private:
  const ::safe_browsing::RiceDeltaEncoding& _internal_rice_hashes() const;
  ::safe_browsing::RiceDeltaEncoding* _internal_mutable_rice_hashes();
  public:
  void unsafe_arena_set_allocated_rice_hashes(
      ::safe_browsing::RiceDeltaEncoding* rice_hashes);
  ::safe_browsing::RiceDeltaEncoding* unsafe_arena_release_rice_hashes();

  // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
  bool has_rice_indices() const;
  private:
  bool _internal_has_rice_indices() const;
  public:
  void clear_rice_indices();
  const ::safe_browsing::RiceDeltaEncoding& rice_indices() const;
  PROTOBUF_NODISCARD ::safe_browsing::RiceDeltaEncoding* release_rice_indices();
  ::safe_browsing::RiceDeltaEncoding* mutable_rice_indices();
  void set_allocated_rice_indices(::safe_browsing::RiceDeltaEncoding* rice_indices);
  private:
  const ::safe_browsing::RiceDeltaEncoding& _internal_rice_indices() const;
  ::safe_browsing::RiceDeltaEncoding* _internal_mutable_rice_indices();
  public:
  void unsafe_arena_set_allocated_rice_indices(
      ::safe_browsing::RiceDeltaEncoding* rice_indices);
  ::safe_browsing::RiceDeltaEncoding* unsafe_arena_release_rice_indices();

  // optional .safe_browsing.CompressionType compression_type = 1;
  bool has_compression_type() const;
  private:
  bool _internal_has_compression_type() const;
  public:
  void clear_compression_type();
  ::safe_browsing::CompressionType compression_type() const;
  void set_compression_type(::safe_browsing::CompressionType value);
  private:
  ::safe_browsing::CompressionType _internal_compression_type() const;
  void _internal_set_compression_type(::safe_browsing::CompressionType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntrySet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::safe_browsing::RawHashes* raw_hashes_;
  ::safe_browsing::RawIndices* raw_indices_;
  ::safe_browsing::RiceDeltaEncoding* rice_hashes_;
  ::safe_browsing::RiceDeltaEncoding* rice_indices_;
  int compression_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class RawIndices final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RawIndices) */ {
 public:
  inline RawIndices() : RawIndices(nullptr) {}
  ~RawIndices() override;
  explicit PROTOBUF_CONSTEXPR RawIndices(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RawIndices(const RawIndices& from);
  RawIndices(RawIndices&& from) noexcept
    : RawIndices() {
    *this = ::std::move(from);
  }

  inline RawIndices& operator=(const RawIndices& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawIndices& operator=(RawIndices&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RawIndices& default_instance() {
    return *internal_default_instance();
  }
  static inline const RawIndices* internal_default_instance() {
    return reinterpret_cast<const RawIndices*>(
               &_RawIndices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RawIndices& a, RawIndices& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RawIndices* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawIndices* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RawIndices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RawIndices>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RawIndices& from);
  void MergeFrom(const RawIndices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawIndices* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.RawIndices";
  }
  protected:
  explicit RawIndices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndicesFieldNumber = 1,
  };
  // repeated int32 indices = 1;
  int indices_size() const;
  private:
  int _internal_indices_size() const;
  public:
  void clear_indices();
  private:
  int32_t _internal_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_indices() const;
  void _internal_add_indices(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_indices();
  public:
  int32_t indices(int index) const;
  void set_indices(int index, int32_t value);
  void add_indices(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_indices();

  // @@protoc_insertion_point(class_scope:safe_browsing.RawIndices)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > indices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class RawHashes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RawHashes) */ {
 public:
  inline RawHashes() : RawHashes(nullptr) {}
  ~RawHashes() override;
  explicit PROTOBUF_CONSTEXPR RawHashes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RawHashes(const RawHashes& from);
  RawHashes(RawHashes&& from) noexcept
    : RawHashes() {
    *this = ::std::move(from);
  }

  inline RawHashes& operator=(const RawHashes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawHashes& operator=(RawHashes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RawHashes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RawHashes* internal_default_instance() {
    return reinterpret_cast<const RawHashes*>(
               &_RawHashes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RawHashes& a, RawHashes& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RawHashes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawHashes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RawHashes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RawHashes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RawHashes& from);
  void MergeFrom(const RawHashes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RawHashes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.RawHashes";
  }
  protected:
  explicit RawHashes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawHashesFieldNumber = 2,
    kPrefixSizeFieldNumber = 1,
  };
  // optional bytes raw_hashes = 2;
  bool has_raw_hashes() const;
  private:
  bool _internal_has_raw_hashes() const;
  public:
  void clear_raw_hashes();
  const std::string& raw_hashes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_hashes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_hashes();
  PROTOBUF_NODISCARD std::string* release_raw_hashes();
  void set_allocated_raw_hashes(std::string* raw_hashes);
  private:
  const std::string& _internal_raw_hashes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_hashes(const std::string& value);
  std::string* _internal_mutable_raw_hashes();
  public:

  // optional int32 prefix_size = 1;
  bool has_prefix_size() const;
  private:
  bool _internal_has_prefix_size() const;
  public:
  void clear_prefix_size();
  int32_t prefix_size() const;
  void set_prefix_size(int32_t value);
  private:
  int32_t _internal_prefix_size() const;
  void _internal_set_prefix_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.RawHashes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_hashes_;
  int32_t prefix_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class RiceDeltaEncoding final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RiceDeltaEncoding) */ {
 public:
  inline RiceDeltaEncoding() : RiceDeltaEncoding(nullptr) {}
  ~RiceDeltaEncoding() override;
  explicit PROTOBUF_CONSTEXPR RiceDeltaEncoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RiceDeltaEncoding(const RiceDeltaEncoding& from);
  RiceDeltaEncoding(RiceDeltaEncoding&& from) noexcept
    : RiceDeltaEncoding() {
    *this = ::std::move(from);
  }

  inline RiceDeltaEncoding& operator=(const RiceDeltaEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline RiceDeltaEncoding& operator=(RiceDeltaEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RiceDeltaEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const RiceDeltaEncoding* internal_default_instance() {
    return reinterpret_cast<const RiceDeltaEncoding*>(
               &_RiceDeltaEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RiceDeltaEncoding& a, RiceDeltaEncoding& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RiceDeltaEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RiceDeltaEncoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RiceDeltaEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RiceDeltaEncoding>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RiceDeltaEncoding& from);
  void MergeFrom(const RiceDeltaEncoding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RiceDeltaEncoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.RiceDeltaEncoding";
  }
  protected:
  explicit RiceDeltaEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedDataFieldNumber = 4,
    kFirstValueFieldNumber = 1,
    kRiceParameterFieldNumber = 2,
    kNumEntriesFieldNumber = 3,
  };
  // optional bytes encoded_data = 4;
  bool has_encoded_data() const;
  private:
  bool _internal_has_encoded_data() const;
  public:
  void clear_encoded_data();
  const std::string& encoded_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded_data();
  PROTOBUF_NODISCARD std::string* release_encoded_data();
  void set_allocated_encoded_data(std::string* encoded_data);
  private:
  const std::string& _internal_encoded_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_data(const std::string& value);
  std::string* _internal_mutable_encoded_data();
  public:

  // optional int64 first_value = 1;
  bool has_first_value() const;
  private:
  bool _internal_has_first_value() const;
  public:
  void clear_first_value();
  int64_t first_value() const;
  void set_first_value(int64_t value);
  private:
  int64_t _internal_first_value() const;
  void _internal_set_first_value(int64_t value);
  public:

  // optional int32 rice_parameter = 2;
  bool has_rice_parameter() const;
  private:
  bool _internal_has_rice_parameter() const;
  public:
  void clear_rice_parameter();
  int32_t rice_parameter() const;
  void set_rice_parameter(int32_t value);
  private:
  int32_t _internal_rice_parameter() const;
  void _internal_set_rice_parameter(int32_t value);
  public:

  // optional int32 num_entries = 3;
  bool has_num_entries() const;
  private:
  bool _internal_has_num_entries() const;
  public:
  void clear_num_entries();
  int32_t num_entries() const;
  void set_num_entries(int32_t value);
  private:
  int32_t _internal_num_entries() const;
  void _internal_set_num_entries(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.RiceDeltaEncoding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_data_;
  int64_t first_value_;
  int32_t rice_parameter_;
  int32_t num_entries_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata_MetadataEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntryMetadata.MetadataEntry) */ {
 public:
  inline ThreatEntryMetadata_MetadataEntry() : ThreatEntryMetadata_MetadataEntry(nullptr) {}
  ~ThreatEntryMetadata_MetadataEntry() override;
  explicit PROTOBUF_CONSTEXPR ThreatEntryMetadata_MetadataEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from);
  ThreatEntryMetadata_MetadataEntry(ThreatEntryMetadata_MetadataEntry&& from) noexcept
    : ThreatEntryMetadata_MetadataEntry() {
    *this = ::std::move(from);
  }

  inline ThreatEntryMetadata_MetadataEntry& operator=(const ThreatEntryMetadata_MetadataEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntryMetadata_MetadataEntry& operator=(ThreatEntryMetadata_MetadataEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatEntryMetadata_MetadataEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatEntryMetadata_MetadataEntry* internal_default_instance() {
    return reinterpret_cast<const ThreatEntryMetadata_MetadataEntry*>(
               &_ThreatEntryMetadata_MetadataEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ThreatEntryMetadata_MetadataEntry& a, ThreatEntryMetadata_MetadataEntry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatEntryMetadata_MetadataEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatEntryMetadata_MetadataEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatEntryMetadata_MetadataEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatEntryMetadata_MetadataEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatEntryMetadata_MetadataEntry& from);
  void MergeFrom(const ThreatEntryMetadata_MetadataEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntryMetadata_MetadataEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntryMetadata.MetadataEntry";
  }
  protected:
  explicit ThreatEntryMetadata_MetadataEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntryMetadata.MetadataEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatEntryMetadata) */ {
 public:
  inline ThreatEntryMetadata() : ThreatEntryMetadata(nullptr) {}
  ~ThreatEntryMetadata() override;
  explicit PROTOBUF_CONSTEXPR ThreatEntryMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatEntryMetadata(const ThreatEntryMetadata& from);
  ThreatEntryMetadata(ThreatEntryMetadata&& from) noexcept
    : ThreatEntryMetadata() {
    *this = ::std::move(from);
  }

  inline ThreatEntryMetadata& operator=(const ThreatEntryMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatEntryMetadata& operator=(ThreatEntryMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatEntryMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatEntryMetadata* internal_default_instance() {
    return reinterpret_cast<const ThreatEntryMetadata*>(
               &_ThreatEntryMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ThreatEntryMetadata& a, ThreatEntryMetadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatEntryMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatEntryMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatEntryMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatEntryMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatEntryMetadata& from);
  void MergeFrom(const ThreatEntryMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatEntryMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatEntryMetadata";
  }
  protected:
  explicit ThreatEntryMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ThreatEntryMetadata_MetadataEntry MetadataEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::safe_browsing::ThreatEntryMetadata_MetadataEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >*
      mutable_entries();
  private:
  const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& _internal_entries(int index) const;
  ::safe_browsing::ThreatEntryMetadata_MetadataEntry* _internal_add_entries();
  public:
  const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& entries(int index) const;
  ::safe_browsing::ThreatEntryMetadata_MetadataEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatEntryMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ThreatListDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ThreatListDescriptor) */ {
 public:
  inline ThreatListDescriptor() : ThreatListDescriptor(nullptr) {}
  ~ThreatListDescriptor() override;
  explicit PROTOBUF_CONSTEXPR ThreatListDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatListDescriptor(const ThreatListDescriptor& from);
  ThreatListDescriptor(ThreatListDescriptor&& from) noexcept
    : ThreatListDescriptor() {
    *this = ::std::move(from);
  }

  inline ThreatListDescriptor& operator=(const ThreatListDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatListDescriptor& operator=(ThreatListDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ThreatListDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatListDescriptor* internal_default_instance() {
    return reinterpret_cast<const ThreatListDescriptor*>(
               &_ThreatListDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ThreatListDescriptor& a, ThreatListDescriptor& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ThreatListDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatListDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatListDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatListDescriptor>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ThreatListDescriptor& from);
  void MergeFrom(const ThreatListDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ThreatListDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ThreatListDescriptor";
  }
  protected:
  explicit ThreatListDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatTypeFieldNumber = 1,
    kPlatformTypeFieldNumber = 2,
    kThreatEntryTypeFieldNumber = 3,
  };
  // optional .safe_browsing.ThreatType threat_type = 1;
  bool has_threat_type() const;
  private:
  bool _internal_has_threat_type() const;
  public:
  void clear_threat_type();
  ::safe_browsing::ThreatType threat_type() const;
  void set_threat_type(::safe_browsing::ThreatType value);
  private:
  ::safe_browsing::ThreatType _internal_threat_type() const;
  void _internal_set_threat_type(::safe_browsing::ThreatType value);
  public:

  // optional .safe_browsing.PlatformType platform_type = 2;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::safe_browsing::PlatformType platform_type() const;
  void set_platform_type(::safe_browsing::PlatformType value);
  private:
  ::safe_browsing::PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::safe_browsing::PlatformType value);
  public:

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
  bool has_threat_entry_type() const;
  private:
  bool _internal_has_threat_entry_type() const;
  public:
  void clear_threat_entry_type();
  ::safe_browsing::ThreatEntryType threat_entry_type() const;
  void set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  private:
  ::safe_browsing::ThreatEntryType _internal_threat_entry_type() const;
  void _internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.ThreatListDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class ListThreatListsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.ListThreatListsResponse) */ {
 public:
  inline ListThreatListsResponse() : ListThreatListsResponse(nullptr) {}
  ~ListThreatListsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListThreatListsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListThreatListsResponse(const ListThreatListsResponse& from);
  ListThreatListsResponse(ListThreatListsResponse&& from) noexcept
    : ListThreatListsResponse() {
    *this = ::std::move(from);
  }

  inline ListThreatListsResponse& operator=(const ListThreatListsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListThreatListsResponse& operator=(ListThreatListsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ListThreatListsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListThreatListsResponse* internal_default_instance() {
    return reinterpret_cast<const ListThreatListsResponse*>(
               &_ListThreatListsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ListThreatListsResponse& a, ListThreatListsResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ListThreatListsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListThreatListsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListThreatListsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListThreatListsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ListThreatListsResponse& from);
  void MergeFrom(const ListThreatListsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListThreatListsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.ListThreatListsResponse";
  }
  protected:
  explicit ListThreatListsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreatListsFieldNumber = 1,
  };
  // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
  int threat_lists_size() const;
  private:
  int _internal_threat_lists_size() const;
  public:
  void clear_threat_lists();
  ::safe_browsing::ThreatListDescriptor* mutable_threat_lists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >*
      mutable_threat_lists();
  private:
  const ::safe_browsing::ThreatListDescriptor& _internal_threat_lists(int index) const;
  ::safe_browsing::ThreatListDescriptor* _internal_add_threat_lists();
  public:
  const ::safe_browsing::ThreatListDescriptor& threat_lists(int index) const;
  ::safe_browsing::ThreatListDescriptor* add_threat_lists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >&
      threat_lists() const;

  // @@protoc_insertion_point(class_scope:safe_browsing.ListThreatListsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor > threat_lists_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// -------------------------------------------------------------------

class Duration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.Duration) */ {
 public:
  inline Duration() : Duration(nullptr) {}
  ~Duration() override;
  explicit PROTOBUF_CONSTEXPR Duration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Duration(const Duration& from);
  Duration(Duration&& from) noexcept
    : Duration() {
    *this = ::std::move(from);
  }

  inline Duration& operator=(const Duration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Duration& operator=(Duration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Duration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Duration* internal_default_instance() {
    return reinterpret_cast<const Duration*>(
               &_Duration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Duration& a, Duration& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Duration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Duration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Duration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Duration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Duration& from);
  void MergeFrom(const Duration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Duration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safe_browsing.Duration";
  }
  protected:
  explicit Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // optional int32 nanos = 2;
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safe_browsing.Duration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t seconds_;
  int32_t nanos_;
  friend struct ::TableStruct_safebrowsing_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ThreatInfo

// repeated .safe_browsing.ThreatType threat_types = 1;
inline int ThreatInfo::_internal_threat_types_size() const {
  return threat_types_.size();
}
inline int ThreatInfo::threat_types_size() const {
  return _internal_threat_types_size();
}
inline void ThreatInfo::clear_threat_types() {
  threat_types_.Clear();
}
inline ::safe_browsing::ThreatType ThreatInfo::_internal_threat_types(int index) const {
  return static_cast< ::safe_browsing::ThreatType >(threat_types_.Get(index));
}
inline ::safe_browsing::ThreatType ThreatInfo::threat_types(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_types)
  return _internal_threat_types(index);
}
inline void ThreatInfo::set_threat_types(int index, ::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  threat_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.threat_types)
}
inline void ThreatInfo::_internal_add_threat_types(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  threat_types_.Add(value);
}
inline void ThreatInfo::add_threat_types(::safe_browsing::ThreatType value) {
  _internal_add_threat_types(value);
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ThreatInfo::threat_types() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_types)
  return threat_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::_internal_mutable_threat_types() {
  return &threat_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::mutable_threat_types() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_types)
  return _internal_mutable_threat_types();
}

// repeated .safe_browsing.PlatformType platform_types = 2;
inline int ThreatInfo::_internal_platform_types_size() const {
  return platform_types_.size();
}
inline int ThreatInfo::platform_types_size() const {
  return _internal_platform_types_size();
}
inline void ThreatInfo::clear_platform_types() {
  platform_types_.Clear();
}
inline ::safe_browsing::PlatformType ThreatInfo::_internal_platform_types(int index) const {
  return static_cast< ::safe_browsing::PlatformType >(platform_types_.Get(index));
}
inline ::safe_browsing::PlatformType ThreatInfo::platform_types(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.platform_types)
  return _internal_platform_types(index);
}
inline void ThreatInfo::set_platform_types(int index, ::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  platform_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.platform_types)
}
inline void ThreatInfo::_internal_add_platform_types(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  platform_types_.Add(value);
}
inline void ThreatInfo::add_platform_types(::safe_browsing::PlatformType value) {
  _internal_add_platform_types(value);
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.platform_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ThreatInfo::platform_types() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.platform_types)
  return platform_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::_internal_mutable_platform_types() {
  return &platform_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::mutable_platform_types() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.platform_types)
  return _internal_mutable_platform_types();
}

// repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
inline int ThreatInfo::_internal_threat_entry_types_size() const {
  return threat_entry_types_.size();
}
inline int ThreatInfo::threat_entry_types_size() const {
  return _internal_threat_entry_types_size();
}
inline void ThreatInfo::clear_threat_entry_types() {
  threat_entry_types_.Clear();
}
inline ::safe_browsing::ThreatEntryType ThreatInfo::_internal_threat_entry_types(int index) const {
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_types_.Get(index));
}
inline ::safe_browsing::ThreatEntryType ThreatInfo::threat_entry_types(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_entry_types)
  return _internal_threat_entry_types(index);
}
inline void ThreatInfo::set_threat_entry_types(int index, ::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatInfo.threat_entry_types)
}
inline void ThreatInfo::_internal_add_threat_entry_types(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Add(value);
}
inline void ThreatInfo::add_threat_entry_types(::safe_browsing::ThreatEntryType value) {
  _internal_add_threat_entry_types(value);
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_entry_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ThreatInfo::threat_entry_types() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_entry_types)
  return threat_entry_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::_internal_mutable_threat_entry_types() {
  return &threat_entry_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ThreatInfo::mutable_threat_entry_types() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_entry_types)
  return _internal_mutable_threat_entry_types();
}

// repeated .safe_browsing.ThreatEntry threat_entries = 3;
inline int ThreatInfo::_internal_threat_entries_size() const {
  return threat_entries_.size();
}
inline int ThreatInfo::threat_entries_size() const {
  return _internal_threat_entries_size();
}
inline void ThreatInfo::clear_threat_entries() {
  threat_entries_.Clear();
}
inline ::safe_browsing::ThreatEntry* ThreatInfo::mutable_threat_entries(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatInfo.threat_entries)
  return threat_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >*
ThreatInfo::mutable_threat_entries() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatInfo.threat_entries)
  return &threat_entries_;
}
inline const ::safe_browsing::ThreatEntry& ThreatInfo::_internal_threat_entries(int index) const {
  return threat_entries_.Get(index);
}
inline const ::safe_browsing::ThreatEntry& ThreatInfo::threat_entries(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatInfo.threat_entries)
  return _internal_threat_entries(index);
}
inline ::safe_browsing::ThreatEntry* ThreatInfo::_internal_add_threat_entries() {
  return threat_entries_.Add();
}
inline ::safe_browsing::ThreatEntry* ThreatInfo::add_threat_entries() {
  ::safe_browsing::ThreatEntry* _add = _internal_add_threat_entries();
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatInfo.threat_entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntry >&
ThreatInfo::threat_entries() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatInfo.threat_entries)
  return threat_entries_;
}

// -------------------------------------------------------------------

// ThreatMatch

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool ThreatMatch::_internal_has_threat_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ThreatMatch::has_threat_type() const {
  return _internal_has_threat_type();
}
inline void ThreatMatch::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::ThreatType ThreatMatch::_internal_threat_type() const {
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline ::safe_browsing::ThreatType ThreatMatch::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_type)
  return _internal_threat_type();
}
inline void ThreatMatch::_internal_set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  threat_type_ = value;
}
inline void ThreatMatch::set_threat_type(::safe_browsing::ThreatType value) {
  _internal_set_threat_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool ThreatMatch::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ThreatMatch::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void ThreatMatch::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::PlatformType ThreatMatch::_internal_platform_type() const {
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline ::safe_browsing::PlatformType ThreatMatch::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.platform_type)
  return _internal_platform_type();
}
inline void ThreatMatch::_internal_set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  platform_type_ = value;
}
inline void ThreatMatch::set_platform_type(::safe_browsing::PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
inline bool ThreatMatch::_internal_has_threat_entry_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ThreatMatch::has_threat_entry_type() const {
  return _internal_has_threat_entry_type();
}
inline void ThreatMatch::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::safe_browsing::ThreatEntryType ThreatMatch::_internal_threat_entry_type() const {
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline ::safe_browsing::ThreatEntryType ThreatMatch::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_entry_type)
  return _internal_threat_entry_type();
}
inline void ThreatMatch::_internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  threat_entry_type_ = value;
}
inline void ThreatMatch::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  _internal_set_threat_entry_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatMatch.threat_entry_type)
}

// optional .safe_browsing.ThreatEntry threat = 3;
inline bool ThreatMatch::_internal_has_threat() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || threat_ != nullptr);
  return value;
}
inline bool ThreatMatch::has_threat() const {
  return _internal_has_threat();
}
inline void ThreatMatch::clear_threat() {
  if (threat_ != nullptr) threat_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ThreatEntry& ThreatMatch::_internal_threat() const {
  const ::safe_browsing::ThreatEntry* p = threat_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ThreatEntry&>(
      ::safe_browsing::_ThreatEntry_default_instance_);
}
inline const ::safe_browsing::ThreatEntry& ThreatMatch::threat() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat)
  return _internal_threat();
}
inline void ThreatMatch::unsafe_arena_set_allocated_threat(
    ::safe_browsing::ThreatEntry* threat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threat_);
  }
  threat_ = threat;
  if (threat) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatMatch.threat)
}
inline ::safe_browsing::ThreatEntry* ThreatMatch::release_threat() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ThreatEntry* temp = threat_;
  threat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ThreatEntry* ThreatMatch::unsafe_arena_release_threat() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.threat)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ThreatEntry* temp = threat_;
  threat_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatEntry* ThreatMatch::_internal_mutable_threat() {
  _has_bits_[0] |= 0x00000001u;
  if (threat_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatEntry>(GetArenaForAllocation());
    threat_ = p;
  }
  return threat_;
}
inline ::safe_browsing::ThreatEntry* ThreatMatch::mutable_threat() {
  ::safe_browsing::ThreatEntry* _msg = _internal_mutable_threat();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.threat)
  return _msg;
}
inline void ThreatMatch::set_allocated_threat(::safe_browsing::ThreatEntry* threat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete threat_;
  }
  if (threat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(threat);
    if (message_arena != submessage_arena) {
      threat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  threat_ = threat;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.threat)
}

// optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
inline bool ThreatMatch::_internal_has_threat_entry_metadata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || threat_entry_metadata_ != nullptr);
  return value;
}
inline bool ThreatMatch::has_threat_entry_metadata() const {
  return _internal_has_threat_entry_metadata();
}
inline void ThreatMatch::clear_threat_entry_metadata() {
  if (threat_entry_metadata_ != nullptr) threat_entry_metadata_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ThreatEntryMetadata& ThreatMatch::_internal_threat_entry_metadata() const {
  const ::safe_browsing::ThreatEntryMetadata* p = threat_entry_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ThreatEntryMetadata&>(
      ::safe_browsing::_ThreatEntryMetadata_default_instance_);
}
inline const ::safe_browsing::ThreatEntryMetadata& ThreatMatch::threat_entry_metadata() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.threat_entry_metadata)
  return _internal_threat_entry_metadata();
}
inline void ThreatMatch::unsafe_arena_set_allocated_threat_entry_metadata(
    ::safe_browsing::ThreatEntryMetadata* threat_entry_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threat_entry_metadata_);
  }
  threat_entry_metadata_ = threat_entry_metadata;
  if (threat_entry_metadata) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatMatch.threat_entry_metadata)
}
inline ::safe_browsing::ThreatEntryMetadata* ThreatMatch::release_threat_entry_metadata() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
  threat_entry_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ThreatEntryMetadata* ThreatMatch::unsafe_arena_release_threat_entry_metadata() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.threat_entry_metadata)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
  threat_entry_metadata_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatEntryMetadata* ThreatMatch::_internal_mutable_threat_entry_metadata() {
  _has_bits_[0] |= 0x00000002u;
  if (threat_entry_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatEntryMetadata>(GetArenaForAllocation());
    threat_entry_metadata_ = p;
  }
  return threat_entry_metadata_;
}
inline ::safe_browsing::ThreatEntryMetadata* ThreatMatch::mutable_threat_entry_metadata() {
  ::safe_browsing::ThreatEntryMetadata* _msg = _internal_mutable_threat_entry_metadata();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.threat_entry_metadata)
  return _msg;
}
inline void ThreatMatch::set_allocated_threat_entry_metadata(::safe_browsing::ThreatEntryMetadata* threat_entry_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete threat_entry_metadata_;
  }
  if (threat_entry_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(threat_entry_metadata);
    if (message_arena != submessage_arena) {
      threat_entry_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat_entry_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threat_entry_metadata_ = threat_entry_metadata;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.threat_entry_metadata)
}

// optional .safe_browsing.Duration cache_duration = 5;
inline bool ThreatMatch::_internal_has_cache_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || cache_duration_ != nullptr);
  return value;
}
inline bool ThreatMatch::has_cache_duration() const {
  return _internal_has_cache_duration();
}
inline void ThreatMatch::clear_cache_duration() {
  if (cache_duration_ != nullptr) cache_duration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::safe_browsing::Duration& ThreatMatch::_internal_cache_duration() const {
  const ::safe_browsing::Duration* p = cache_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::Duration&>(
      ::safe_browsing::_Duration_default_instance_);
}
inline const ::safe_browsing::Duration& ThreatMatch::cache_duration() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatMatch.cache_duration)
  return _internal_cache_duration();
}
inline void ThreatMatch::unsafe_arena_set_allocated_cache_duration(
    ::safe_browsing::Duration* cache_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cache_duration_);
  }
  cache_duration_ = cache_duration;
  if (cache_duration) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatMatch.cache_duration)
}
inline ::safe_browsing::Duration* ThreatMatch::release_cache_duration() {
  _has_bits_[0] &= ~0x00000004u;
  ::safe_browsing::Duration* temp = cache_duration_;
  cache_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::Duration* ThreatMatch::unsafe_arena_release_cache_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatMatch.cache_duration)
  _has_bits_[0] &= ~0x00000004u;
  ::safe_browsing::Duration* temp = cache_duration_;
  cache_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* ThreatMatch::_internal_mutable_cache_duration() {
  _has_bits_[0] |= 0x00000004u;
  if (cache_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaForAllocation());
    cache_duration_ = p;
  }
  return cache_duration_;
}
inline ::safe_browsing::Duration* ThreatMatch::mutable_cache_duration() {
  ::safe_browsing::Duration* _msg = _internal_mutable_cache_duration();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatMatch.cache_duration)
  return _msg;
}
inline void ThreatMatch::set_allocated_cache_duration(::safe_browsing::Duration* cache_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cache_duration_;
  }
  if (cache_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache_duration);
    if (message_arena != submessage_arena) {
      cache_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cache_duration_ = cache_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatMatch.cache_duration)
}

// -------------------------------------------------------------------

// FindThreatMatchesRequest

// optional .safe_browsing.ClientInfo client = 1;
inline bool FindThreatMatchesRequest::_internal_has_client() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_ != nullptr);
  return value;
}
inline bool FindThreatMatchesRequest::has_client() const {
  return _internal_has_client();
}
inline void FindThreatMatchesRequest::clear_client() {
  if (client_ != nullptr) client_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ClientInfo& FindThreatMatchesRequest::_internal_client() const {
  const ::safe_browsing::ClientInfo* p = client_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ClientInfo&>(
      ::safe_browsing::_ClientInfo_default_instance_);
}
inline const ::safe_browsing::ClientInfo& FindThreatMatchesRequest::client() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesRequest.client)
  return _internal_client();
}
inline void FindThreatMatchesRequest::unsafe_arena_set_allocated_client(
    ::safe_browsing::ClientInfo* client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_);
  }
  client_ = client;
  if (client) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FindThreatMatchesRequest.client)
}
inline ::safe_browsing::ClientInfo* FindThreatMatchesRequest::release_client() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ClientInfo* FindThreatMatchesRequest::unsafe_arena_release_client() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindThreatMatchesRequest.client)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::safe_browsing::ClientInfo* FindThreatMatchesRequest::_internal_mutable_client() {
  _has_bits_[0] |= 0x00000001u;
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ClientInfo>(GetArenaForAllocation());
    client_ = p;
  }
  return client_;
}
inline ::safe_browsing::ClientInfo* FindThreatMatchesRequest::mutable_client() {
  ::safe_browsing::ClientInfo* _msg = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesRequest.client)
  return _msg;
}
inline void FindThreatMatchesRequest::set_allocated_client(::safe_browsing::ClientInfo* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client);
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindThreatMatchesRequest.client)
}

// optional .safe_browsing.ThreatInfo threat_info = 2;
inline bool FindThreatMatchesRequest::_internal_has_threat_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || threat_info_ != nullptr);
  return value;
}
inline bool FindThreatMatchesRequest::has_threat_info() const {
  return _internal_has_threat_info();
}
inline void FindThreatMatchesRequest::clear_threat_info() {
  if (threat_info_ != nullptr) threat_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ThreatInfo& FindThreatMatchesRequest::_internal_threat_info() const {
  const ::safe_browsing::ThreatInfo* p = threat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ThreatInfo&>(
      ::safe_browsing::_ThreatInfo_default_instance_);
}
inline const ::safe_browsing::ThreatInfo& FindThreatMatchesRequest::threat_info() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesRequest.threat_info)
  return _internal_threat_info();
}
inline void FindThreatMatchesRequest::unsafe_arena_set_allocated_threat_info(
    ::safe_browsing::ThreatInfo* threat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threat_info_);
  }
  threat_info_ = threat_info;
  if (threat_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FindThreatMatchesRequest.threat_info)
}
inline ::safe_browsing::ThreatInfo* FindThreatMatchesRequest::release_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatInfo* temp = threat_info_;
  threat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ThreatInfo* FindThreatMatchesRequest::unsafe_arena_release_threat_info() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindThreatMatchesRequest.threat_info)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatInfo* temp = threat_info_;
  threat_info_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatInfo* FindThreatMatchesRequest::_internal_mutable_threat_info() {
  _has_bits_[0] |= 0x00000002u;
  if (threat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatInfo>(GetArenaForAllocation());
    threat_info_ = p;
  }
  return threat_info_;
}
inline ::safe_browsing::ThreatInfo* FindThreatMatchesRequest::mutable_threat_info() {
  ::safe_browsing::ThreatInfo* _msg = _internal_mutable_threat_info();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesRequest.threat_info)
  return _msg;
}
inline void FindThreatMatchesRequest::set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete threat_info_;
  }
  if (threat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(threat_info);
    if (message_arena != submessage_arena) {
      threat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threat_info_ = threat_info;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindThreatMatchesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindThreatMatchesResponse

// repeated .safe_browsing.ThreatMatch matches = 1;
inline int FindThreatMatchesResponse::_internal_matches_size() const {
  return matches_.size();
}
inline int FindThreatMatchesResponse::matches_size() const {
  return _internal_matches_size();
}
inline void FindThreatMatchesResponse::clear_matches() {
  matches_.Clear();
}
inline ::safe_browsing::ThreatMatch* FindThreatMatchesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindThreatMatchesResponse.matches)
  return matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
FindThreatMatchesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindThreatMatchesResponse.matches)
  return &matches_;
}
inline const ::safe_browsing::ThreatMatch& FindThreatMatchesResponse::_internal_matches(int index) const {
  return matches_.Get(index);
}
inline const ::safe_browsing::ThreatMatch& FindThreatMatchesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindThreatMatchesResponse.matches)
  return _internal_matches(index);
}
inline ::safe_browsing::ThreatMatch* FindThreatMatchesResponse::_internal_add_matches() {
  return matches_.Add();
}
inline ::safe_browsing::ThreatMatch* FindThreatMatchesResponse::add_matches() {
  ::safe_browsing::ThreatMatch* _add = _internal_add_matches();
  // @@protoc_insertion_point(field_add:safe_browsing.FindThreatMatchesResponse.matches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
FindThreatMatchesResponse::matches() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FindThreatMatchesResponse.matches)
  return matches_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints

// optional int32 max_update_entries = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_has_max_update_entries() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_update_entries() const {
  return _internal_has_max_update_entries();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_update_entries() {
  max_update_entries_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_max_update_entries() const {
  return max_update_entries_;
}
inline int32_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_update_entries() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
  return _internal_max_update_entries();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_set_max_update_entries(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  max_update_entries_ = value;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_update_entries(int32_t value) {
  _internal_set_max_update_entries(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
}

// optional int32 max_database_entries = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_has_max_database_entries() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_database_entries() const {
  return _internal_has_max_database_entries();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_database_entries() {
  max_database_entries_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_max_database_entries() const {
  return max_database_entries_;
}
inline int32_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
  return _internal_max_database_entries();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_set_max_database_entries(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  max_database_entries_ = value;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_database_entries(int32_t value) {
  _internal_set_max_database_entries(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
}

// optional string region = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_region() const {
  return _internal_has_region();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::region() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return _s;
}
inline const std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_region() const {
  return region_.Get();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::release_region() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}

// repeated .safe_browsing.CompressionType supported_compressions = 4;
inline int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_supported_compressions_size() const {
  return supported_compressions_.size();
}
inline int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions_size() const {
  return _internal_supported_compressions_size();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_supported_compressions() {
  supported_compressions_.Clear();
}
inline ::safe_browsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_supported_compressions(int index) const {
  return static_cast< ::safe_browsing::CompressionType >(supported_compressions_.Get(index));
}
inline ::safe_browsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return _internal_supported_compressions(index);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_supported_compressions(int index, ::safe_browsing::CompressionType value) {
  assert(::safe_browsing::CompressionType_IsValid(value));
  supported_compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_add_supported_compressions(::safe_browsing::CompressionType value) {
  assert(::safe_browsing::CompressionType_IsValid(value));
  supported_compressions_.Add(value);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::add_supported_compressions(::safe_browsing::CompressionType value) {
  _internal_add_supported_compressions(value);
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return supported_compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_internal_mutable_supported_compressions() {
  return &supported_compressions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_supported_compressions() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return _internal_mutable_supported_compressions();
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_has_threat_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_type() const {
  return _internal_has_threat_type();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_threat_type() const {
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline ::safe_browsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
  return _internal_threat_type();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  threat_type_ = value;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_type(::safe_browsing::ThreatType value) {
  _internal_set_threat_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_platform_type() const {
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline ::safe_browsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
  return _internal_platform_type();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  platform_type_ = value;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_platform_type(::safe_browsing::PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_has_threat_entry_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_entry_type() const {
  return _internal_has_threat_entry_type();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_threat_entry_type() const {
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline ::safe_browsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
  return _internal_threat_entry_type();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  threat_entry_type_ = value;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  _internal_set_threat_entry_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
}

// optional bytes state = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_state() const {
  return _internal_has_state();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::state() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 state_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return _s;
}
inline const std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_state() const {
  return state_.Get();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  state_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000001u;
  return state_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::release_state() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = state_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault()) {
    state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault()) {
    state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}

// optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_has_constraints() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || constraints_ != nullptr);
  return value;
}
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_constraints() const {
  return _internal_has_constraints();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_constraints() {
  if (constraints_ != nullptr) constraints_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_constraints() const {
  const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* p = constraints_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&>(
      ::safe_browsing::_FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_);
}
inline const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::constraints() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return _internal_constraints();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::unsafe_arena_set_allocated_constraints(
    ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(constraints_);
  }
  constraints_ = constraints;
  if (constraints) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::release_constraints() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
  constraints_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::unsafe_arena_release_constraints() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
  constraints_ = nullptr;
  return temp;
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::_internal_mutable_constraints() {
  _has_bits_[0] |= 0x00000002u;
  if (constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>(GetArenaForAllocation());
    constraints_ = p;
  }
  return constraints_;
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_constraints() {
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* _msg = _internal_mutable_constraints();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return _msg;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_constraints(::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete constraints_;
  }
  if (constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(constraints);
    if (message_arena != submessage_arena) {
      constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, constraints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  constraints_ = constraints;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest

// optional .safe_browsing.ClientInfo client = 1;
inline bool FetchThreatListUpdatesRequest::_internal_has_client() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_ != nullptr);
  return value;
}
inline bool FetchThreatListUpdatesRequest::has_client() const {
  return _internal_has_client();
}
inline void FetchThreatListUpdatesRequest::clear_client() {
  if (client_ != nullptr) client_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ClientInfo& FetchThreatListUpdatesRequest::_internal_client() const {
  const ::safe_browsing::ClientInfo* p = client_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ClientInfo&>(
      ::safe_browsing::_ClientInfo_default_instance_);
}
inline const ::safe_browsing::ClientInfo& FetchThreatListUpdatesRequest::client() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.client)
  return _internal_client();
}
inline void FetchThreatListUpdatesRequest::unsafe_arena_set_allocated_client(
    ::safe_browsing::ClientInfo* client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_);
  }
  client_ = client;
  if (client) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.client)
}
inline ::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::release_client() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::unsafe_arena_release_client() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.client)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::_internal_mutable_client() {
  _has_bits_[0] |= 0x00000001u;
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ClientInfo>(GetArenaForAllocation());
    client_ = p;
  }
  return client_;
}
inline ::safe_browsing::ClientInfo* FetchThreatListUpdatesRequest::mutable_client() {
  ::safe_browsing::ClientInfo* _msg = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.client)
  return _msg;
}
inline void FetchThreatListUpdatesRequest::set_allocated_client(::safe_browsing::ClientInfo* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client);
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.client)
}

// repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
inline int FetchThreatListUpdatesRequest::_internal_list_update_requests_size() const {
  return list_update_requests_.size();
}
inline int FetchThreatListUpdatesRequest::list_update_requests_size() const {
  return _internal_list_update_requests_size();
}
inline void FetchThreatListUpdatesRequest::clear_list_update_requests() {
  list_update_requests_.Clear();
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::mutable_list_update_requests(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
FetchThreatListUpdatesRequest::mutable_list_update_requests() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return &list_update_requests_;
}
inline const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::_internal_list_update_requests(int index) const {
  return list_update_requests_.Get(index);
}
inline const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::list_update_requests(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return _internal_list_update_requests(index);
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::_internal_add_list_update_requests() {
  return list_update_requests_.Add();
}
inline ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::add_list_update_requests() {
  ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest* _add = _internal_add_list_update_requests();
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
FetchThreatListUpdatesRequest::list_update_requests() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_;
}

// optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
inline bool FetchThreatListUpdatesRequest::_internal_has_chrome_client_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || chrome_client_info_ != nullptr);
  return value;
}
inline bool FetchThreatListUpdatesRequest::has_chrome_client_info() const {
  return _internal_has_chrome_client_info();
}
inline void FetchThreatListUpdatesRequest::clear_chrome_client_info() {
  if (chrome_client_info_ != nullptr) chrome_client_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ChromeClientInfo& FetchThreatListUpdatesRequest::_internal_chrome_client_info() const {
  const ::safe_browsing::ChromeClientInfo* p = chrome_client_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ChromeClientInfo&>(
      ::safe_browsing::_ChromeClientInfo_default_instance_);
}
inline const ::safe_browsing::ChromeClientInfo& FetchThreatListUpdatesRequest::chrome_client_info() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return _internal_chrome_client_info();
}
inline void FetchThreatListUpdatesRequest::unsafe_arena_set_allocated_chrome_client_info(
    ::safe_browsing::ChromeClientInfo* chrome_client_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_client_info_);
  }
  chrome_client_info_ = chrome_client_info;
  if (chrome_client_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
}
inline ::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::release_chrome_client_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ChromeClientInfo* temp = chrome_client_info_;
  chrome_client_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::unsafe_arena_release_chrome_client_info() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ChromeClientInfo* temp = chrome_client_info_;
  chrome_client_info_ = nullptr;
  return temp;
}
inline ::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::_internal_mutable_chrome_client_info() {
  _has_bits_[0] |= 0x00000002u;
  if (chrome_client_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ChromeClientInfo>(GetArenaForAllocation());
    chrome_client_info_ = p;
  }
  return chrome_client_info_;
}
inline ::safe_browsing::ChromeClientInfo* FetchThreatListUpdatesRequest::mutable_chrome_client_info() {
  ::safe_browsing::ChromeClientInfo* _msg = _internal_mutable_chrome_client_info();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
  return _msg;
}
inline void FetchThreatListUpdatesRequest::set_allocated_chrome_client_info(::safe_browsing::ChromeClientInfo* chrome_client_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chrome_client_info_;
  }
  if (chrome_client_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_client_info);
    if (message_arena != submessage_arena) {
      chrome_client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_client_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  chrome_client_info_ = chrome_client_info;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesRequest.chrome_client_info)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse_ListUpdateResponse

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_has_threat_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_type() const {
  return _internal_has_threat_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_threat_type() const {
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline ::safe_browsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
  return _internal_threat_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  threat_type_ = value;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_type(::safe_browsing::ThreatType value) {
  _internal_set_threat_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_has_threat_entry_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_entry_type() const {
  return _internal_has_threat_entry_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_threat_entry_type() const {
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline ::safe_browsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
  return _internal_threat_entry_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  threat_entry_type_ = value;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  _internal_set_threat_entry_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
}

// optional .safe_browsing.PlatformType platform_type = 3;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_platform_type() const {
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline ::safe_browsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
  return _internal_platform_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  platform_type_ = value;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_platform_type(::safe_browsing::PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
}

// optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_has_response_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_response_type() const {
  return _internal_has_response_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_response_type() {
  response_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_response_type() const {
  return static_cast< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType >(response_type_);
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::response_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
  return _internal_response_type();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  assert(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  response_type_ = value;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_response_type(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  _internal_set_response_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
}

// repeated .safe_browsing.ThreatEntrySet additions = 5;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_additions_size() const {
  return additions_.size();
}
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::additions_size() const {
  return _internal_additions_size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_additions() {
  additions_.Clear();
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return &additions_;
}
inline const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_additions(int index) const {
  return additions_.Get(index);
}
inline const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::additions(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return _internal_additions(index);
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_add_additions() {
  return additions_.Add();
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_additions() {
  ::safe_browsing::ThreatEntrySet* _add = _internal_add_additions();
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::additions() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_;
}

// repeated .safe_browsing.ThreatEntrySet removals = 6;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_removals_size() const {
  return removals_.size();
}
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::removals_size() const {
  return _internal_removals_size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_removals() {
  removals_.Clear();
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return &removals_;
}
inline const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_removals(int index) const {
  return removals_.Get(index);
}
inline const ::safe_browsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::removals(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return _internal_removals(index);
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_add_removals() {
  return removals_.Add();
}
inline ::safe_browsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_removals() {
  ::safe_browsing::ThreatEntrySet* _add = _internal_add_removals();
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::removals() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_;
}

// optional bytes new_client_state = 7;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_has_new_client_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_new_client_state() const {
  return _internal_has_new_client_state();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_new_client_state() {
  new_client_state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::new_client_state() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return _internal_new_client_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 new_client_state_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_new_client_state() {
  std::string* _s = _internal_mutable_new_client_state();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return _s;
}
inline const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_new_client_state() const {
  return new_client_state_.Get();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_set_new_client_state(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  new_client_state_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_mutable_new_client_state() {
  _has_bits_[0] |= 0x00000001u;
  return new_client_state_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::release_new_client_state() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  if (!_internal_has_new_client_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = new_client_state_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_client_state_.IsDefault()) {
    new_client_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_new_client_state(std::string* new_client_state) {
  if (new_client_state != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_client_state_.SetAllocated(new_client_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_client_state_.IsDefault()) {
    new_client_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}

// optional .safe_browsing.Checksum checksum = 8;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || checksum_ != nullptr);
  return value;
}
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_checksum() const {
  return _internal_has_checksum();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_checksum() {
  if (checksum_ != nullptr) checksum_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_checksum() const {
  const ::safe_browsing::Checksum* p = checksum_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::Checksum&>(
      ::safe_browsing::_Checksum_default_instance_);
}
inline const ::safe_browsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::checksum() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return _internal_checksum();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::unsafe_arena_set_allocated_checksum(
    ::safe_browsing::Checksum* checksum) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(checksum_);
  }
  checksum_ = checksum;
  if (checksum) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}
inline ::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::release_checksum() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::Checksum* temp = checksum_;
  checksum_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::unsafe_arena_release_checksum() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::Checksum* temp = checksum_;
  checksum_ = nullptr;
  return temp;
}
inline ::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::_internal_mutable_checksum() {
  _has_bits_[0] |= 0x00000002u;
  if (checksum_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Checksum>(GetArenaForAllocation());
    checksum_ = p;
  }
  return checksum_;
}
inline ::safe_browsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_checksum() {
  ::safe_browsing::Checksum* _msg = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return _msg;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_checksum(::safe_browsing::Checksum* checksum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete checksum_;
  }
  if (checksum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(checksum);
    if (message_arena != submessage_arena) {
      checksum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checksum, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  checksum_ = checksum;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse

// repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
inline int FetchThreatListUpdatesResponse::_internal_list_update_responses_size() const {
  return list_update_responses_.size();
}
inline int FetchThreatListUpdatesResponse::list_update_responses_size() const {
  return _internal_list_update_responses_size();
}
inline void FetchThreatListUpdatesResponse::clear_list_update_responses() {
  list_update_responses_.Clear();
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::mutable_list_update_responses(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
FetchThreatListUpdatesResponse::mutable_list_update_responses() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return &list_update_responses_;
}
inline const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::_internal_list_update_responses(int index) const {
  return list_update_responses_.Get(index);
}
inline const ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::list_update_responses(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return _internal_list_update_responses(index);
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::_internal_add_list_update_responses() {
  return list_update_responses_.Add();
}
inline ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::add_list_update_responses() {
  ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse* _add = _internal_add_list_update_responses();
  // @@protoc_insertion_point(field_add:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
FetchThreatListUpdatesResponse::list_update_responses() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_;
}

// optional .safe_browsing.Duration minimum_wait_duration = 2;
inline bool FetchThreatListUpdatesResponse::_internal_has_minimum_wait_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || minimum_wait_duration_ != nullptr);
  return value;
}
inline bool FetchThreatListUpdatesResponse::has_minimum_wait_duration() const {
  return _internal_has_minimum_wait_duration();
}
inline void FetchThreatListUpdatesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != nullptr) minimum_wait_duration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::Duration& FetchThreatListUpdatesResponse::_internal_minimum_wait_duration() const {
  const ::safe_browsing::Duration* p = minimum_wait_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::Duration&>(
      ::safe_browsing::_Duration_default_instance_);
}
inline const ::safe_browsing::Duration& FetchThreatListUpdatesResponse::minimum_wait_duration() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return _internal_minimum_wait_duration();
}
inline void FetchThreatListUpdatesResponse::unsafe_arena_set_allocated_minimum_wait_duration(
    ::safe_browsing::Duration* minimum_wait_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimum_wait_duration_);
  }
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}
inline ::safe_browsing::Duration* FetchThreatListUpdatesResponse::release_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::Duration* FetchThreatListUpdatesResponse::unsafe_arena_release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* FetchThreatListUpdatesResponse::_internal_mutable_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
  if (minimum_wait_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaForAllocation());
    minimum_wait_duration_ = p;
  }
  return minimum_wait_duration_;
}
inline ::safe_browsing::Duration* FetchThreatListUpdatesResponse::mutable_minimum_wait_duration() {
  ::safe_browsing::Duration* _msg = _internal_mutable_minimum_wait_duration();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return _msg;
}
inline void FetchThreatListUpdatesResponse::set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete minimum_wait_duration_;
  }
  if (minimum_wait_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(minimum_wait_duration);
    if (message_arena != submessage_arena) {
      minimum_wait_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_wait_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  minimum_wait_duration_ = minimum_wait_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}

// -------------------------------------------------------------------

// FindFullHashesRequest

// optional .safe_browsing.ClientInfo client = 1;
inline bool FindFullHashesRequest::_internal_has_client() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_ != nullptr);
  return value;
}
inline bool FindFullHashesRequest::has_client() const {
  return _internal_has_client();
}
inline void FindFullHashesRequest::clear_client() {
  if (client_ != nullptr) client_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ClientInfo& FindFullHashesRequest::_internal_client() const {
  const ::safe_browsing::ClientInfo* p = client_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ClientInfo&>(
      ::safe_browsing::_ClientInfo_default_instance_);
}
inline const ::safe_browsing::ClientInfo& FindFullHashesRequest::client() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.client)
  return _internal_client();
}
inline void FindFullHashesRequest::unsafe_arena_set_allocated_client(
    ::safe_browsing::ClientInfo* client) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_);
  }
  client_ = client;
  if (client) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FindFullHashesRequest.client)
}
inline ::safe_browsing::ClientInfo* FindFullHashesRequest::release_client() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ClientInfo* FindFullHashesRequest::unsafe_arena_release_client() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesRequest.client)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ClientInfo* temp = client_;
  client_ = nullptr;
  return temp;
}
inline ::safe_browsing::ClientInfo* FindFullHashesRequest::_internal_mutable_client() {
  _has_bits_[0] |= 0x00000001u;
  if (client_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ClientInfo>(GetArenaForAllocation());
    client_ = p;
  }
  return client_;
}
inline ::safe_browsing::ClientInfo* FindFullHashesRequest::mutable_client() {
  ::safe_browsing::ClientInfo* _msg = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.client)
  return _msg;
}
inline void FindFullHashesRequest::set_allocated_client(::safe_browsing::ClientInfo* client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_;
  }
  if (client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client);
    if (message_arena != submessage_arena) {
      client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_ = client;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesRequest.client)
}

// repeated bytes client_states = 2;
inline int FindFullHashesRequest::_internal_client_states_size() const {
  return client_states_.size();
}
inline int FindFullHashesRequest::client_states_size() const {
  return _internal_client_states_size();
}
inline void FindFullHashesRequest::clear_client_states() {
  client_states_.Clear();
}
inline std::string* FindFullHashesRequest::add_client_states() {
  std::string* _s = _internal_add_client_states();
  // @@protoc_insertion_point(field_add_mutable:safe_browsing.FindFullHashesRequest.client_states)
  return _s;
}
inline const std::string& FindFullHashesRequest::_internal_client_states(int index) const {
  return client_states_.Get(index);
}
inline const std::string& FindFullHashesRequest::client_states(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.client_states)
  return _internal_client_states(index);
}
inline std::string* FindFullHashesRequest::mutable_client_states(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.client_states)
  return client_states_.Mutable(index);
}
inline void FindFullHashesRequest::set_client_states(int index, const std::string& value) {
  client_states_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::set_client_states(int index, std::string&& value) {
  client_states_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::set_client_states(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_states_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::set_client_states(int index, const void* value, size_t size) {
  client_states_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safe_browsing.FindFullHashesRequest.client_states)
}
inline std::string* FindFullHashesRequest::_internal_add_client_states() {
  return client_states_.Add();
}
inline void FindFullHashesRequest::add_client_states(const std::string& value) {
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(std::string&& value) {
  client_states_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safe_browsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const void* value, size_t size) {
  client_states_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safe_browsing.FindFullHashesRequest.client_states)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FindFullHashesRequest::client_states() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FindFullHashesRequest.client_states)
  return client_states_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FindFullHashesRequest::mutable_client_states() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindFullHashesRequest.client_states)
  return &client_states_;
}

// optional .safe_browsing.ThreatInfo threat_info = 3;
inline bool FindFullHashesRequest::_internal_has_threat_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || threat_info_ != nullptr);
  return value;
}
inline bool FindFullHashesRequest::has_threat_info() const {
  return _internal_has_threat_info();
}
inline void FindFullHashesRequest::clear_threat_info() {
  if (threat_info_ != nullptr) threat_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::ThreatInfo& FindFullHashesRequest::_internal_threat_info() const {
  const ::safe_browsing::ThreatInfo* p = threat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ThreatInfo&>(
      ::safe_browsing::_ThreatInfo_default_instance_);
}
inline const ::safe_browsing::ThreatInfo& FindFullHashesRequest::threat_info() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesRequest.threat_info)
  return _internal_threat_info();
}
inline void FindFullHashesRequest::unsafe_arena_set_allocated_threat_info(
    ::safe_browsing::ThreatInfo* threat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threat_info_);
  }
  threat_info_ = threat_info;
  if (threat_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FindFullHashesRequest.threat_info)
}
inline ::safe_browsing::ThreatInfo* FindFullHashesRequest::release_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatInfo* temp = threat_info_;
  threat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ThreatInfo* FindFullHashesRequest::unsafe_arena_release_threat_info() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesRequest.threat_info)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::ThreatInfo* temp = threat_info_;
  threat_info_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatInfo* FindFullHashesRequest::_internal_mutable_threat_info() {
  _has_bits_[0] |= 0x00000002u;
  if (threat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatInfo>(GetArenaForAllocation());
    threat_info_ = p;
  }
  return threat_info_;
}
inline ::safe_browsing::ThreatInfo* FindFullHashesRequest::mutable_threat_info() {
  ::safe_browsing::ThreatInfo* _msg = _internal_mutable_threat_info();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesRequest.threat_info)
  return _msg;
}
inline void FindFullHashesRequest::set_allocated_threat_info(::safe_browsing::ThreatInfo* threat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete threat_info_;
  }
  if (threat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(threat_info);
    if (message_arena != submessage_arena) {
      threat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threat_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threat_info_ = threat_info;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindFullHashesResponse

// repeated .safe_browsing.ThreatMatch matches = 1;
inline int FindFullHashesResponse::_internal_matches_size() const {
  return matches_.size();
}
inline int FindFullHashesResponse::matches_size() const {
  return _internal_matches_size();
}
inline void FindFullHashesResponse::clear_matches() {
  matches_.Clear();
}
inline ::safe_browsing::ThreatMatch* FindFullHashesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.matches)
  return matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >*
FindFullHashesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.FindFullHashesResponse.matches)
  return &matches_;
}
inline const ::safe_browsing::ThreatMatch& FindFullHashesResponse::_internal_matches(int index) const {
  return matches_.Get(index);
}
inline const ::safe_browsing::ThreatMatch& FindFullHashesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.matches)
  return _internal_matches(index);
}
inline ::safe_browsing::ThreatMatch* FindFullHashesResponse::_internal_add_matches() {
  return matches_.Add();
}
inline ::safe_browsing::ThreatMatch* FindFullHashesResponse::add_matches() {
  ::safe_browsing::ThreatMatch* _add = _internal_add_matches();
  // @@protoc_insertion_point(field_add:safe_browsing.FindFullHashesResponse.matches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatMatch >&
FindFullHashesResponse::matches() const {
  // @@protoc_insertion_point(field_list:safe_browsing.FindFullHashesResponse.matches)
  return matches_;
}

// optional .safe_browsing.Duration minimum_wait_duration = 2;
inline bool FindFullHashesResponse::_internal_has_minimum_wait_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || minimum_wait_duration_ != nullptr);
  return value;
}
inline bool FindFullHashesResponse::has_minimum_wait_duration() const {
  return _internal_has_minimum_wait_duration();
}
inline void FindFullHashesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != nullptr) minimum_wait_duration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::Duration& FindFullHashesResponse::_internal_minimum_wait_duration() const {
  const ::safe_browsing::Duration* p = minimum_wait_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::Duration&>(
      ::safe_browsing::_Duration_default_instance_);
}
inline const ::safe_browsing::Duration& FindFullHashesResponse::minimum_wait_duration() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
  return _internal_minimum_wait_duration();
}
inline void FindFullHashesResponse::unsafe_arena_set_allocated_minimum_wait_duration(
    ::safe_browsing::Duration* minimum_wait_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimum_wait_duration_);
  }
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
}
inline ::safe_browsing::Duration* FindFullHashesResponse::release_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::unsafe_arena_release_minimum_wait_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::_internal_mutable_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000001u;
  if (minimum_wait_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaForAllocation());
    minimum_wait_duration_ = p;
  }
  return minimum_wait_duration_;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::mutable_minimum_wait_duration() {
  ::safe_browsing::Duration* _msg = _internal_mutable_minimum_wait_duration();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
  return _msg;
}
inline void FindFullHashesResponse::set_allocated_minimum_wait_duration(::safe_browsing::Duration* minimum_wait_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete minimum_wait_duration_;
  }
  if (minimum_wait_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(minimum_wait_duration);
    if (message_arena != submessage_arena) {
      minimum_wait_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_wait_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  minimum_wait_duration_ = minimum_wait_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesResponse.minimum_wait_duration)
}

// optional .safe_browsing.Duration negative_cache_duration = 3;
inline bool FindFullHashesResponse::_internal_has_negative_cache_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || negative_cache_duration_ != nullptr);
  return value;
}
inline bool FindFullHashesResponse::has_negative_cache_duration() const {
  return _internal_has_negative_cache_duration();
}
inline void FindFullHashesResponse::clear_negative_cache_duration() {
  if (negative_cache_duration_ != nullptr) negative_cache_duration_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::Duration& FindFullHashesResponse::_internal_negative_cache_duration() const {
  const ::safe_browsing::Duration* p = negative_cache_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::Duration&>(
      ::safe_browsing::_Duration_default_instance_);
}
inline const ::safe_browsing::Duration& FindFullHashesResponse::negative_cache_duration() const {
  // @@protoc_insertion_point(field_get:safe_browsing.FindFullHashesResponse.negative_cache_duration)
  return _internal_negative_cache_duration();
}
inline void FindFullHashesResponse::unsafe_arena_set_allocated_negative_cache_duration(
    ::safe_browsing::Duration* negative_cache_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(negative_cache_duration_);
  }
  negative_cache_duration_ = negative_cache_duration;
  if (negative_cache_duration) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.FindFullHashesResponse.negative_cache_duration)
}
inline ::safe_browsing::Duration* FindFullHashesResponse::release_negative_cache_duration() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::Duration* temp = negative_cache_duration_;
  negative_cache_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::unsafe_arena_release_negative_cache_duration() {
  // @@protoc_insertion_point(field_release:safe_browsing.FindFullHashesResponse.negative_cache_duration)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::Duration* temp = negative_cache_duration_;
  negative_cache_duration_ = nullptr;
  return temp;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::_internal_mutable_negative_cache_duration() {
  _has_bits_[0] |= 0x00000002u;
  if (negative_cache_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::Duration>(GetArenaForAllocation());
    negative_cache_duration_ = p;
  }
  return negative_cache_duration_;
}
inline ::safe_browsing::Duration* FindFullHashesResponse::mutable_negative_cache_duration() {
  ::safe_browsing::Duration* _msg = _internal_mutable_negative_cache_duration();
  // @@protoc_insertion_point(field_mutable:safe_browsing.FindFullHashesResponse.negative_cache_duration)
  return _msg;
}
inline void FindFullHashesResponse::set_allocated_negative_cache_duration(::safe_browsing::Duration* negative_cache_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete negative_cache_duration_;
  }
  if (negative_cache_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(negative_cache_duration);
    if (message_arena != submessage_arena) {
      negative_cache_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negative_cache_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  negative_cache_duration_ = negative_cache_duration;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.FindFullHashesResponse.negative_cache_duration)
}

// -------------------------------------------------------------------

// ThreatHit_ThreatSource

// optional string url = 1;
inline bool ThreatHit_ThreatSource::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThreatHit_ThreatSource::has_url() const {
  return _internal_has_url();
}
inline void ThreatHit_ThreatSource::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreatHit_ThreatSource::url() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatHit_ThreatSource::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.url)
}
inline std::string* ThreatHit_ThreatSource::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.url)
  return _s;
}
inline const std::string& ThreatHit_ThreatSource::_internal_url() const {
  return url_.Get();
}
inline void ThreatHit_ThreatSource::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatHit_ThreatSource::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatHit_ThreatSource::release_url() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatHit_ThreatSource::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.url)
}

// optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
inline bool ThreatHit_ThreatSource::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ThreatHit_ThreatSource::has_type() const {
  return _internal_has_type();
}
inline void ThreatHit_ThreatSource::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::safe_browsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::_internal_type() const {
  return static_cast< ::safe_browsing::ThreatHit_ThreatSourceType >(type_);
}
inline ::safe_browsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.type)
  return _internal_type();
}
inline void ThreatHit_ThreatSource::_internal_set_type(::safe_browsing::ThreatHit_ThreatSourceType value) {
  assert(::safe_browsing::ThreatHit_ThreatSourceType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void ThreatHit_ThreatSource::set_type(::safe_browsing::ThreatHit_ThreatSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.type)
}

// optional string remote_ip = 3;
inline bool ThreatHit_ThreatSource::_internal_has_remote_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ThreatHit_ThreatSource::has_remote_ip() const {
  return _internal_has_remote_ip();
}
inline void ThreatHit_ThreatSource::clear_remote_ip() {
  remote_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ThreatHit_ThreatSource::remote_ip() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.remote_ip)
  return _internal_remote_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatHit_ThreatSource::set_remote_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 remote_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}
inline std::string* ThreatHit_ThreatSource::mutable_remote_ip() {
  std::string* _s = _internal_mutable_remote_ip();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.remote_ip)
  return _s;
}
inline const std::string& ThreatHit_ThreatSource::_internal_remote_ip() const {
  return remote_ip_.Get();
}
inline void ThreatHit_ThreatSource::_internal_set_remote_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  remote_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatHit_ThreatSource::_internal_mutable_remote_ip() {
  _has_bits_[0] |= 0x00000002u;
  return remote_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatHit_ThreatSource::release_remote_ip() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.remote_ip)
  if (!_internal_has_remote_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = remote_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_ip_.IsDefault()) {
    remote_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatHit_ThreatSource::set_allocated_remote_ip(std::string* remote_ip) {
  if (remote_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  remote_ip_.SetAllocated(remote_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_ip_.IsDefault()) {
    remote_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.remote_ip)
}

// optional string referrer = 4;
inline bool ThreatHit_ThreatSource::_internal_has_referrer() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ThreatHit_ThreatSource::has_referrer() const {
  return _internal_has_referrer();
}
inline void ThreatHit_ThreatSource::clear_referrer() {
  referrer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ThreatHit_ThreatSource::referrer() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.ThreatSource.referrer)
  return _internal_referrer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatHit_ThreatSource::set_referrer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 referrer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.ThreatSource.referrer)
}
inline std::string* ThreatHit_ThreatSource::mutable_referrer() {
  std::string* _s = _internal_mutable_referrer();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.ThreatSource.referrer)
  return _s;
}
inline const std::string& ThreatHit_ThreatSource::_internal_referrer() const {
  return referrer_.Get();
}
inline void ThreatHit_ThreatSource::_internal_set_referrer(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  referrer_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatHit_ThreatSource::_internal_mutable_referrer() {
  _has_bits_[0] |= 0x00000004u;
  return referrer_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatHit_ThreatSource::release_referrer() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.ThreatSource.referrer)
  if (!_internal_has_referrer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = referrer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (referrer_.IsDefault()) {
    referrer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatHit_ThreatSource::set_allocated_referrer(std::string* referrer) {
  if (referrer != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  referrer_.SetAllocated(referrer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (referrer_.IsDefault()) {
    referrer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.ThreatSource.referrer)
}

// -------------------------------------------------------------------

// ThreatHit

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool ThreatHit::_internal_has_threat_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ThreatHit::has_threat_type() const {
  return _internal_has_threat_type();
}
inline void ThreatHit::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::safe_browsing::ThreatType ThreatHit::_internal_threat_type() const {
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline ::safe_browsing::ThreatType ThreatHit::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.threat_type)
  return _internal_threat_type();
}
inline void ThreatHit::_internal_set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  threat_type_ = value;
}
inline void ThreatHit::set_threat_type(::safe_browsing::ThreatType value) {
  _internal_set_threat_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool ThreatHit::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ThreatHit::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void ThreatHit::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::PlatformType ThreatHit::_internal_platform_type() const {
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline ::safe_browsing::PlatformType ThreatHit::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.platform_type)
  return _internal_platform_type();
}
inline void ThreatHit::_internal_set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  platform_type_ = value;
}
inline void ThreatHit::set_platform_type(::safe_browsing::PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatHit.platform_type)
}

// optional .safe_browsing.ThreatEntry entry = 3;
inline bool ThreatHit::_internal_has_entry() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || entry_ != nullptr);
  return value;
}
inline bool ThreatHit::has_entry() const {
  return _internal_has_entry();
}
inline void ThreatHit::clear_entry() {
  if (entry_ != nullptr) entry_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::ThreatEntry& ThreatHit::_internal_entry() const {
  const ::safe_browsing::ThreatEntry* p = entry_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ThreatEntry&>(
      ::safe_browsing::_ThreatEntry_default_instance_);
}
inline const ::safe_browsing::ThreatEntry& ThreatHit::entry() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.entry)
  return _internal_entry();
}
inline void ThreatHit::unsafe_arena_set_allocated_entry(
    ::safe_browsing::ThreatEntry* entry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entry_);
  }
  entry_ = entry;
  if (entry) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatHit.entry)
}
inline ::safe_browsing::ThreatEntry* ThreatHit::release_entry() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ThreatEntry* temp = entry_;
  entry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::ThreatEntry* ThreatHit::unsafe_arena_release_entry() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatHit.entry)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::ThreatEntry* temp = entry_;
  entry_ = nullptr;
  return temp;
}
inline ::safe_browsing::ThreatEntry* ThreatHit::_internal_mutable_entry() {
  _has_bits_[0] |= 0x00000001u;
  if (entry_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::ThreatEntry>(GetArenaForAllocation());
    entry_ = p;
  }
  return entry_;
}
inline ::safe_browsing::ThreatEntry* ThreatHit::mutable_entry() {
  ::safe_browsing::ThreatEntry* _msg = _internal_mutable_entry();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.entry)
  return _msg;
}
inline void ThreatHit::set_allocated_entry(::safe_browsing::ThreatEntry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete entry_;
  }
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatHit.entry)
}

// repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
inline int ThreatHit::_internal_resources_size() const {
  return resources_.size();
}
inline int ThreatHit::resources_size() const {
  return _internal_resources_size();
}
inline void ThreatHit::clear_resources() {
  resources_.Clear();
}
inline ::safe_browsing::ThreatHit_ThreatSource* ThreatHit::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatHit.resources)
  return resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >*
ThreatHit::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatHit.resources)
  return &resources_;
}
inline const ::safe_browsing::ThreatHit_ThreatSource& ThreatHit::_internal_resources(int index) const {
  return resources_.Get(index);
}
inline const ::safe_browsing::ThreatHit_ThreatSource& ThreatHit::resources(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatHit.resources)
  return _internal_resources(index);
}
inline ::safe_browsing::ThreatHit_ThreatSource* ThreatHit::_internal_add_resources() {
  return resources_.Add();
}
inline ::safe_browsing::ThreatHit_ThreatSource* ThreatHit::add_resources() {
  ::safe_browsing::ThreatHit_ThreatSource* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatHit.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatHit_ThreatSource >&
ThreatHit::resources() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatHit.resources)
  return resources_;
}

// -------------------------------------------------------------------

// ClientInfo

// optional string client_id = 1;
inline bool ClientInfo::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientInfo::has_client_id() const {
  return _internal_has_client_id();
}
inline void ClientInfo::clear_client_id() {
  client_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientInfo::client_id() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ClientInfo.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_client_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ClientInfo.client_id)
}
inline std::string* ClientInfo::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ClientInfo.client_id)
  return _s;
}
inline const std::string& ClientInfo::_internal_client_id() const {
  return client_id_.Get();
}
inline void ClientInfo::_internal_set_client_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  return client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_client_id() {
  // @@protoc_insertion_point(field_release:safe_browsing.ClientInfo.client_id)
  if (!_internal_has_client_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault()) {
    client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientInfo::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault()) {
    client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ClientInfo.client_id)
}

// optional string client_version = 2;
inline bool ClientInfo::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientInfo::has_client_version() const {
  return _internal_has_client_version();
}
inline void ClientInfo::clear_client_version() {
  client_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientInfo::client_version() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ClientInfo.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_client_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 client_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ClientInfo.client_version)
}
inline std::string* ClientInfo::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ClientInfo.client_version)
  return _s;
}
inline const std::string& ClientInfo::_internal_client_version() const {
  return client_version_.Get();
}
inline void ClientInfo::_internal_set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_client_version() {
  _has_bits_[0] |= 0x00000002u;
  return client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_client_version() {
  // @@protoc_insertion_point(field_release:safe_browsing.ClientInfo.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = client_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault()) {
    client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientInfo::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault()) {
    client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ClientInfo.client_version)
}

// -------------------------------------------------------------------

// ChromeClientInfo

// optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
inline bool ChromeClientInfo::_internal_has_reporting_population() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromeClientInfo::has_reporting_population() const {
  return _internal_has_reporting_population();
}
inline void ChromeClientInfo::clear_reporting_population() {
  reporting_population_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::_internal_reporting_population() const {
  return static_cast< ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation >(reporting_population_);
}
inline ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::reporting_population() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ChromeClientInfo.reporting_population)
  return _internal_reporting_population();
}
inline void ChromeClientInfo::_internal_set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  assert(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  reporting_population_ = value;
}
inline void ChromeClientInfo::set_reporting_population(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  _internal_set_reporting_population(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ChromeClientInfo.reporting_population)
}

// -------------------------------------------------------------------

// Checksum

// optional bytes sha256 = 1;
inline bool Checksum::_internal_has_sha256() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Checksum::has_sha256() const {
  return _internal_has_sha256();
}
inline void Checksum::clear_sha256() {
  sha256_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Checksum::sha256() const {
  // @@protoc_insertion_point(field_get:safe_browsing.Checksum.sha256)
  return _internal_sha256();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Checksum::set_sha256(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sha256_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.Checksum.sha256)
}
inline std::string* Checksum::mutable_sha256() {
  std::string* _s = _internal_mutable_sha256();
  // @@protoc_insertion_point(field_mutable:safe_browsing.Checksum.sha256)
  return _s;
}
inline const std::string& Checksum::_internal_sha256() const {
  return sha256_.Get();
}
inline void Checksum::_internal_set_sha256(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sha256_.Set(value, GetArenaForAllocation());
}
inline std::string* Checksum::_internal_mutable_sha256() {
  _has_bits_[0] |= 0x00000001u;
  return sha256_.Mutable(GetArenaForAllocation());
}
inline std::string* Checksum::release_sha256() {
  // @@protoc_insertion_point(field_release:safe_browsing.Checksum.sha256)
  if (!_internal_has_sha256()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sha256_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha256_.IsDefault()) {
    sha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Checksum::set_allocated_sha256(std::string* sha256) {
  if (sha256 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sha256_.SetAllocated(sha256, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha256_.IsDefault()) {
    sha256_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.Checksum.sha256)
}

// -------------------------------------------------------------------

// ThreatEntry

// optional bytes hash = 1;
inline bool ThreatEntry::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThreatEntry::has_hash() const {
  return _internal_has_hash();
}
inline void ThreatEntry::clear_hash() {
  hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreatEntry::hash() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntry.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatEntry::set_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntry.hash)
}
inline std::string* ThreatEntry::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntry.hash)
  return _s;
}
inline const std::string& ThreatEntry::_internal_hash() const {
  return hash_.Get();
}
inline void ThreatEntry::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatEntry::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatEntry::release_hash() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntry.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault()) {
    hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatEntry::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault()) {
    hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntry.hash)
}

// optional string url = 2;
inline bool ThreatEntry::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ThreatEntry::has_url() const {
  return _internal_has_url();
}
inline void ThreatEntry::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ThreatEntry::url() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntry.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatEntry::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntry.url)
}
inline std::string* ThreatEntry::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntry.url)
  return _s;
}
inline const std::string& ThreatEntry::_internal_url() const {
  return url_.Get();
}
inline void ThreatEntry::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatEntry::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000002u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatEntry::release_url() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntry.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatEntry::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntry.url)
}

// -------------------------------------------------------------------

// ThreatEntrySet

// optional .safe_browsing.CompressionType compression_type = 1;
inline bool ThreatEntrySet::_internal_has_compression_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ThreatEntrySet::has_compression_type() const {
  return _internal_has_compression_type();
}
inline void ThreatEntrySet::clear_compression_type() {
  compression_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::CompressionType ThreatEntrySet::_internal_compression_type() const {
  return static_cast< ::safe_browsing::CompressionType >(compression_type_);
}
inline ::safe_browsing::CompressionType ThreatEntrySet::compression_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.compression_type)
  return _internal_compression_type();
}
inline void ThreatEntrySet::_internal_set_compression_type(::safe_browsing::CompressionType value) {
  assert(::safe_browsing::CompressionType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  compression_type_ = value;
}
inline void ThreatEntrySet::set_compression_type(::safe_browsing::CompressionType value) {
  _internal_set_compression_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntrySet.compression_type)
}

// optional .safe_browsing.RawHashes raw_hashes = 2;
inline bool ThreatEntrySet::_internal_has_raw_hashes() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || raw_hashes_ != nullptr);
  return value;
}
inline bool ThreatEntrySet::has_raw_hashes() const {
  return _internal_has_raw_hashes();
}
inline void ThreatEntrySet::clear_raw_hashes() {
  if (raw_hashes_ != nullptr) raw_hashes_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::safe_browsing::RawHashes& ThreatEntrySet::_internal_raw_hashes() const {
  const ::safe_browsing::RawHashes* p = raw_hashes_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::RawHashes&>(
      ::safe_browsing::_RawHashes_default_instance_);
}
inline const ::safe_browsing::RawHashes& ThreatEntrySet::raw_hashes() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.raw_hashes)
  return _internal_raw_hashes();
}
inline void ThreatEntrySet::unsafe_arena_set_allocated_raw_hashes(
    ::safe_browsing::RawHashes* raw_hashes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_hashes_);
  }
  raw_hashes_ = raw_hashes;
  if (raw_hashes) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatEntrySet.raw_hashes)
}
inline ::safe_browsing::RawHashes* ThreatEntrySet::release_raw_hashes() {
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::RawHashes* temp = raw_hashes_;
  raw_hashes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::RawHashes* ThreatEntrySet::unsafe_arena_release_raw_hashes() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.raw_hashes)
  _has_bits_[0] &= ~0x00000001u;
  ::safe_browsing::RawHashes* temp = raw_hashes_;
  raw_hashes_ = nullptr;
  return temp;
}
inline ::safe_browsing::RawHashes* ThreatEntrySet::_internal_mutable_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
  if (raw_hashes_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RawHashes>(GetArenaForAllocation());
    raw_hashes_ = p;
  }
  return raw_hashes_;
}
inline ::safe_browsing::RawHashes* ThreatEntrySet::mutable_raw_hashes() {
  ::safe_browsing::RawHashes* _msg = _internal_mutable_raw_hashes();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.raw_hashes)
  return _msg;
}
inline void ThreatEntrySet::set_allocated_raw_hashes(::safe_browsing::RawHashes* raw_hashes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_hashes_;
  }
  if (raw_hashes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(raw_hashes);
    if (message_arena != submessage_arena) {
      raw_hashes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_hashes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  raw_hashes_ = raw_hashes;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.raw_hashes)
}

// optional .safe_browsing.RawIndices raw_indices = 3;
inline bool ThreatEntrySet::_internal_has_raw_indices() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || raw_indices_ != nullptr);
  return value;
}
inline bool ThreatEntrySet::has_raw_indices() const {
  return _internal_has_raw_indices();
}
inline void ThreatEntrySet::clear_raw_indices() {
  if (raw_indices_ != nullptr) raw_indices_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::safe_browsing::RawIndices& ThreatEntrySet::_internal_raw_indices() const {
  const ::safe_browsing::RawIndices* p = raw_indices_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::RawIndices&>(
      ::safe_browsing::_RawIndices_default_instance_);
}
inline const ::safe_browsing::RawIndices& ThreatEntrySet::raw_indices() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.raw_indices)
  return _internal_raw_indices();
}
inline void ThreatEntrySet::unsafe_arena_set_allocated_raw_indices(
    ::safe_browsing::RawIndices* raw_indices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_indices_);
  }
  raw_indices_ = raw_indices;
  if (raw_indices) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatEntrySet.raw_indices)
}
inline ::safe_browsing::RawIndices* ThreatEntrySet::release_raw_indices() {
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::RawIndices* temp = raw_indices_;
  raw_indices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::RawIndices* ThreatEntrySet::unsafe_arena_release_raw_indices() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.raw_indices)
  _has_bits_[0] &= ~0x00000002u;
  ::safe_browsing::RawIndices* temp = raw_indices_;
  raw_indices_ = nullptr;
  return temp;
}
inline ::safe_browsing::RawIndices* ThreatEntrySet::_internal_mutable_raw_indices() {
  _has_bits_[0] |= 0x00000002u;
  if (raw_indices_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RawIndices>(GetArenaForAllocation());
    raw_indices_ = p;
  }
  return raw_indices_;
}
inline ::safe_browsing::RawIndices* ThreatEntrySet::mutable_raw_indices() {
  ::safe_browsing::RawIndices* _msg = _internal_mutable_raw_indices();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.raw_indices)
  return _msg;
}
inline void ThreatEntrySet::set_allocated_raw_indices(::safe_browsing::RawIndices* raw_indices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_indices_;
  }
  if (raw_indices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(raw_indices);
    if (message_arena != submessage_arena) {
      raw_indices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_indices, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  raw_indices_ = raw_indices;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.raw_indices)
}

// optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
inline bool ThreatEntrySet::_internal_has_rice_hashes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || rice_hashes_ != nullptr);
  return value;
}
inline bool ThreatEntrySet::has_rice_hashes() const {
  return _internal_has_rice_hashes();
}
inline void ThreatEntrySet::clear_rice_hashes() {
  if (rice_hashes_ != nullptr) rice_hashes_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::_internal_rice_hashes() const {
  const ::safe_browsing::RiceDeltaEncoding* p = rice_hashes_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::RiceDeltaEncoding&>(
      ::safe_browsing::_RiceDeltaEncoding_default_instance_);
}
inline const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::rice_hashes() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.rice_hashes)
  return _internal_rice_hashes();
}
inline void ThreatEntrySet::unsafe_arena_set_allocated_rice_hashes(
    ::safe_browsing::RiceDeltaEncoding* rice_hashes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rice_hashes_);
  }
  rice_hashes_ = rice_hashes;
  if (rice_hashes) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatEntrySet.rice_hashes)
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_hashes() {
  _has_bits_[0] &= ~0x00000004u;
  ::safe_browsing::RiceDeltaEncoding* temp = rice_hashes_;
  rice_hashes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::unsafe_arena_release_rice_hashes() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.rice_hashes)
  _has_bits_[0] &= ~0x00000004u;
  ::safe_browsing::RiceDeltaEncoding* temp = rice_hashes_;
  rice_hashes_ = nullptr;
  return temp;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::_internal_mutable_rice_hashes() {
  _has_bits_[0] |= 0x00000004u;
  if (rice_hashes_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RiceDeltaEncoding>(GetArenaForAllocation());
    rice_hashes_ = p;
  }
  return rice_hashes_;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_hashes() {
  ::safe_browsing::RiceDeltaEncoding* _msg = _internal_mutable_rice_hashes();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.rice_hashes)
  return _msg;
}
inline void ThreatEntrySet::set_allocated_rice_hashes(::safe_browsing::RiceDeltaEncoding* rice_hashes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rice_hashes_;
  }
  if (rice_hashes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rice_hashes);
    if (message_arena != submessage_arena) {
      rice_hashes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rice_hashes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  rice_hashes_ = rice_hashes;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.rice_hashes)
}

// optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
inline bool ThreatEntrySet::_internal_has_rice_indices() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rice_indices_ != nullptr);
  return value;
}
inline bool ThreatEntrySet::has_rice_indices() const {
  return _internal_has_rice_indices();
}
inline void ThreatEntrySet::clear_rice_indices() {
  if (rice_indices_ != nullptr) rice_indices_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::_internal_rice_indices() const {
  const ::safe_browsing::RiceDeltaEncoding* p = rice_indices_;
  return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::RiceDeltaEncoding&>(
      ::safe_browsing::_RiceDeltaEncoding_default_instance_);
}
inline const ::safe_browsing::RiceDeltaEncoding& ThreatEntrySet::rice_indices() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntrySet.rice_indices)
  return _internal_rice_indices();
}
inline void ThreatEntrySet::unsafe_arena_set_allocated_rice_indices(
    ::safe_browsing::RiceDeltaEncoding* rice_indices) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rice_indices_);
  }
  rice_indices_ = rice_indices;
  if (rice_indices) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.ThreatEntrySet.rice_indices)
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_indices() {
  _has_bits_[0] &= ~0x00000008u;
  ::safe_browsing::RiceDeltaEncoding* temp = rice_indices_;
  rice_indices_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::unsafe_arena_release_rice_indices() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntrySet.rice_indices)
  _has_bits_[0] &= ~0x00000008u;
  ::safe_browsing::RiceDeltaEncoding* temp = rice_indices_;
  rice_indices_ = nullptr;
  return temp;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::_internal_mutable_rice_indices() {
  _has_bits_[0] |= 0x00000008u;
  if (rice_indices_ == nullptr) {
    auto* p = CreateMaybeMessage<::safe_browsing::RiceDeltaEncoding>(GetArenaForAllocation());
    rice_indices_ = p;
  }
  return rice_indices_;
}
inline ::safe_browsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_indices() {
  ::safe_browsing::RiceDeltaEncoding* _msg = _internal_mutable_rice_indices();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntrySet.rice_indices)
  return _msg;
}
inline void ThreatEntrySet::set_allocated_rice_indices(::safe_browsing::RiceDeltaEncoding* rice_indices) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rice_indices_;
  }
  if (rice_indices) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rice_indices);
    if (message_arena != submessage_arena) {
      rice_indices = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rice_indices, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rice_indices_ = rice_indices;
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntrySet.rice_indices)
}

// -------------------------------------------------------------------

// RawIndices

// repeated int32 indices = 1;
inline int RawIndices::_internal_indices_size() const {
  return indices_.size();
}
inline int RawIndices::indices_size() const {
  return _internal_indices_size();
}
inline void RawIndices::clear_indices() {
  indices_.Clear();
}
inline int32_t RawIndices::_internal_indices(int index) const {
  return indices_.Get(index);
}
inline int32_t RawIndices::indices(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.RawIndices.indices)
  return _internal_indices(index);
}
inline void RawIndices::set_indices(int index, int32_t value) {
  indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:safe_browsing.RawIndices.indices)
}
inline void RawIndices::_internal_add_indices(int32_t value) {
  indices_.Add(value);
}
inline void RawIndices::add_indices(int32_t value) {
  _internal_add_indices(value);
  // @@protoc_insertion_point(field_add:safe_browsing.RawIndices.indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RawIndices::_internal_indices() const {
  return indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RawIndices::indices() const {
  // @@protoc_insertion_point(field_list:safe_browsing.RawIndices.indices)
  return _internal_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RawIndices::_internal_mutable_indices() {
  return &indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RawIndices::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.RawIndices.indices)
  return _internal_mutable_indices();
}

// -------------------------------------------------------------------

// RawHashes

// optional int32 prefix_size = 1;
inline bool RawHashes::_internal_has_prefix_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RawHashes::has_prefix_size() const {
  return _internal_has_prefix_size();
}
inline void RawHashes::clear_prefix_size() {
  prefix_size_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t RawHashes::_internal_prefix_size() const {
  return prefix_size_;
}
inline int32_t RawHashes::prefix_size() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RawHashes.prefix_size)
  return _internal_prefix_size();
}
inline void RawHashes::_internal_set_prefix_size(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_size_ = value;
}
inline void RawHashes::set_prefix_size(int32_t value) {
  _internal_set_prefix_size(value);
  // @@protoc_insertion_point(field_set:safe_browsing.RawHashes.prefix_size)
}

// optional bytes raw_hashes = 2;
inline bool RawHashes::_internal_has_raw_hashes() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RawHashes::has_raw_hashes() const {
  return _internal_has_raw_hashes();
}
inline void RawHashes::clear_raw_hashes() {
  raw_hashes_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RawHashes::raw_hashes() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RawHashes.raw_hashes)
  return _internal_raw_hashes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RawHashes::set_raw_hashes(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 raw_hashes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.RawHashes.raw_hashes)
}
inline std::string* RawHashes::mutable_raw_hashes() {
  std::string* _s = _internal_mutable_raw_hashes();
  // @@protoc_insertion_point(field_mutable:safe_browsing.RawHashes.raw_hashes)
  return _s;
}
inline const std::string& RawHashes::_internal_raw_hashes() const {
  return raw_hashes_.Get();
}
inline void RawHashes::_internal_set_raw_hashes(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  raw_hashes_.Set(value, GetArenaForAllocation());
}
inline std::string* RawHashes::_internal_mutable_raw_hashes() {
  _has_bits_[0] |= 0x00000001u;
  return raw_hashes_.Mutable(GetArenaForAllocation());
}
inline std::string* RawHashes::release_raw_hashes() {
  // @@protoc_insertion_point(field_release:safe_browsing.RawHashes.raw_hashes)
  if (!_internal_has_raw_hashes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = raw_hashes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (raw_hashes_.IsDefault()) {
    raw_hashes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RawHashes::set_allocated_raw_hashes(std::string* raw_hashes) {
  if (raw_hashes != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  raw_hashes_.SetAllocated(raw_hashes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (raw_hashes_.IsDefault()) {
    raw_hashes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.RawHashes.raw_hashes)
}

// -------------------------------------------------------------------

// RiceDeltaEncoding

// optional int64 first_value = 1;
inline bool RiceDeltaEncoding::_internal_has_first_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RiceDeltaEncoding::has_first_value() const {
  return _internal_has_first_value();
}
inline void RiceDeltaEncoding::clear_first_value() {
  first_value_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t RiceDeltaEncoding::_internal_first_value() const {
  return first_value_;
}
inline int64_t RiceDeltaEncoding::first_value() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.first_value)
  return _internal_first_value();
}
inline void RiceDeltaEncoding::_internal_set_first_value(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  first_value_ = value;
}
inline void RiceDeltaEncoding::set_first_value(int64_t value) {
  _internal_set_first_value(value);
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.first_value)
}

// optional int32 rice_parameter = 2;
inline bool RiceDeltaEncoding::_internal_has_rice_parameter() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RiceDeltaEncoding::has_rice_parameter() const {
  return _internal_has_rice_parameter();
}
inline void RiceDeltaEncoding::clear_rice_parameter() {
  rice_parameter_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t RiceDeltaEncoding::_internal_rice_parameter() const {
  return rice_parameter_;
}
inline int32_t RiceDeltaEncoding::rice_parameter() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.rice_parameter)
  return _internal_rice_parameter();
}
inline void RiceDeltaEncoding::_internal_set_rice_parameter(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  rice_parameter_ = value;
}
inline void RiceDeltaEncoding::set_rice_parameter(int32_t value) {
  _internal_set_rice_parameter(value);
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.rice_parameter)
}

// optional int32 num_entries = 3;
inline bool RiceDeltaEncoding::_internal_has_num_entries() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RiceDeltaEncoding::has_num_entries() const {
  return _internal_has_num_entries();
}
inline void RiceDeltaEncoding::clear_num_entries() {
  num_entries_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t RiceDeltaEncoding::_internal_num_entries() const {
  return num_entries_;
}
inline int32_t RiceDeltaEncoding::num_entries() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.num_entries)
  return _internal_num_entries();
}
inline void RiceDeltaEncoding::_internal_set_num_entries(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  num_entries_ = value;
}
inline void RiceDeltaEncoding::set_num_entries(int32_t value) {
  _internal_set_num_entries(value);
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.num_entries)
}

// optional bytes encoded_data = 4;
inline bool RiceDeltaEncoding::_internal_has_encoded_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RiceDeltaEncoding::has_encoded_data() const {
  return _internal_has_encoded_data();
}
inline void RiceDeltaEncoding::clear_encoded_data() {
  encoded_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RiceDeltaEncoding::encoded_data() const {
  // @@protoc_insertion_point(field_get:safe_browsing.RiceDeltaEncoding.encoded_data)
  return _internal_encoded_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RiceDeltaEncoding::set_encoded_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 encoded_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.RiceDeltaEncoding.encoded_data)
}
inline std::string* RiceDeltaEncoding::mutable_encoded_data() {
  std::string* _s = _internal_mutable_encoded_data();
  // @@protoc_insertion_point(field_mutable:safe_browsing.RiceDeltaEncoding.encoded_data)
  return _s;
}
inline const std::string& RiceDeltaEncoding::_internal_encoded_data() const {
  return encoded_data_.Get();
}
inline void RiceDeltaEncoding::_internal_set_encoded_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_data_.Set(value, GetArenaForAllocation());
}
inline std::string* RiceDeltaEncoding::_internal_mutable_encoded_data() {
  _has_bits_[0] |= 0x00000001u;
  return encoded_data_.Mutable(GetArenaForAllocation());
}
inline std::string* RiceDeltaEncoding::release_encoded_data() {
  // @@protoc_insertion_point(field_release:safe_browsing.RiceDeltaEncoding.encoded_data)
  if (!_internal_has_encoded_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = encoded_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_data_.IsDefault()) {
    encoded_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RiceDeltaEncoding::set_allocated_encoded_data(std::string* encoded_data) {
  if (encoded_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoded_data_.SetAllocated(encoded_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_data_.IsDefault()) {
    encoded_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.RiceDeltaEncoding.encoded_data)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata_MetadataEntry

// optional bytes key = 1;
inline bool ThreatEntryMetadata_MetadataEntry::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThreatEntryMetadata_MetadataEntry::has_key() const {
  return _internal_has_key();
}
inline void ThreatEntryMetadata_MetadataEntry::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ThreatEntryMetadata_MetadataEntry::key() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatEntryMetadata_MetadataEntry::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline std::string* ThreatEntryMetadata_MetadataEntry::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
  return _s;
}
inline const std::string& ThreatEntryMetadata_MetadataEntry::_internal_key() const {
  return key_.Get();
}
inline void ThreatEntryMetadata_MetadataEntry::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatEntryMetadata_MetadataEntry::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatEntryMetadata_MetadataEntry::release_key() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntryMetadata.MetadataEntry.key)
}

// optional bytes value = 2;
inline bool ThreatEntryMetadata_MetadataEntry::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ThreatEntryMetadata_MetadataEntry::has_value() const {
  return _internal_has_value();
}
inline void ThreatEntryMetadata_MetadataEntry::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ThreatEntryMetadata_MetadataEntry::value() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatEntryMetadata_MetadataEntry::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline std::string* ThreatEntryMetadata_MetadataEntry::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
  return _s;
}
inline const std::string& ThreatEntryMetadata_MetadataEntry::_internal_value() const {
  return value_.Get();
}
inline void ThreatEntryMetadata_MetadataEntry::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatEntryMetadata_MetadataEntry::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatEntryMetadata_MetadataEntry::release_value() {
  // @@protoc_insertion_point(field_release:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safe_browsing.ThreatEntryMetadata.MetadataEntry.value)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata

// repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
inline int ThreatEntryMetadata::_internal_entries_size() const {
  return entries_.size();
}
inline int ThreatEntryMetadata::entries_size() const {
  return _internal_entries_size();
}
inline void ThreatEntryMetadata::clear_entries() {
  entries_.Clear();
}
inline ::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ThreatEntryMetadata.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >*
ThreatEntryMetadata::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ThreatEntryMetadata.entries)
  return &entries_;
}
inline const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::safe_browsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::entries(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatEntryMetadata.entries)
  return _internal_entries(index);
}
inline ::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::_internal_add_entries() {
  return entries_.Add();
}
inline ::safe_browsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::add_entries() {
  ::safe_browsing::ThreatEntryMetadata_MetadataEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:safe_browsing.ThreatEntryMetadata.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >&
ThreatEntryMetadata::entries() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ThreatEntryMetadata.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ThreatListDescriptor

// optional .safe_browsing.ThreatType threat_type = 1;
inline bool ThreatListDescriptor::_internal_has_threat_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThreatListDescriptor::has_threat_type() const {
  return _internal_has_threat_type();
}
inline void ThreatListDescriptor::clear_threat_type() {
  threat_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::safe_browsing::ThreatType ThreatListDescriptor::_internal_threat_type() const {
  return static_cast< ::safe_browsing::ThreatType >(threat_type_);
}
inline ::safe_browsing::ThreatType ThreatListDescriptor::threat_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.threat_type)
  return _internal_threat_type();
}
inline void ThreatListDescriptor::_internal_set_threat_type(::safe_browsing::ThreatType value) {
  assert(::safe_browsing::ThreatType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  threat_type_ = value;
}
inline void ThreatListDescriptor::set_threat_type(::safe_browsing::ThreatType value) {
  _internal_set_threat_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.threat_type)
}

// optional .safe_browsing.PlatformType platform_type = 2;
inline bool ThreatListDescriptor::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ThreatListDescriptor::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void ThreatListDescriptor::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::safe_browsing::PlatformType ThreatListDescriptor::_internal_platform_type() const {
  return static_cast< ::safe_browsing::PlatformType >(platform_type_);
}
inline ::safe_browsing::PlatformType ThreatListDescriptor::platform_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.platform_type)
  return _internal_platform_type();
}
inline void ThreatListDescriptor::_internal_set_platform_type(::safe_browsing::PlatformType value) {
  assert(::safe_browsing::PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  platform_type_ = value;
}
inline void ThreatListDescriptor::set_platform_type(::safe_browsing::PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.platform_type)
}

// optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
inline bool ThreatListDescriptor::_internal_has_threat_entry_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ThreatListDescriptor::has_threat_entry_type() const {
  return _internal_has_threat_entry_type();
}
inline void ThreatListDescriptor::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::safe_browsing::ThreatEntryType ThreatListDescriptor::_internal_threat_entry_type() const {
  return static_cast< ::safe_browsing::ThreatEntryType >(threat_entry_type_);
}
inline ::safe_browsing::ThreatEntryType ThreatListDescriptor::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:safe_browsing.ThreatListDescriptor.threat_entry_type)
  return _internal_threat_entry_type();
}
inline void ThreatListDescriptor::_internal_set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  assert(::safe_browsing::ThreatEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  threat_entry_type_ = value;
}
inline void ThreatListDescriptor::set_threat_entry_type(::safe_browsing::ThreatEntryType value) {
  _internal_set_threat_entry_type(value);
  // @@protoc_insertion_point(field_set:safe_browsing.ThreatListDescriptor.threat_entry_type)
}

// -------------------------------------------------------------------

// ListThreatListsResponse

// repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
inline int ListThreatListsResponse::_internal_threat_lists_size() const {
  return threat_lists_.size();
}
inline int ListThreatListsResponse::threat_lists_size() const {
  return _internal_threat_lists_size();
}
inline void ListThreatListsResponse::clear_threat_lists() {
  threat_lists_.Clear();
}
inline ::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::mutable_threat_lists(int index) {
  // @@protoc_insertion_point(field_mutable:safe_browsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >*
ListThreatListsResponse::mutable_threat_lists() {
  // @@protoc_insertion_point(field_mutable_list:safe_browsing.ListThreatListsResponse.threat_lists)
  return &threat_lists_;
}
inline const ::safe_browsing::ThreatListDescriptor& ListThreatListsResponse::_internal_threat_lists(int index) const {
  return threat_lists_.Get(index);
}
inline const ::safe_browsing::ThreatListDescriptor& ListThreatListsResponse::threat_lists(int index) const {
  // @@protoc_insertion_point(field_get:safe_browsing.ListThreatListsResponse.threat_lists)
  return _internal_threat_lists(index);
}
inline ::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::_internal_add_threat_lists() {
  return threat_lists_.Add();
}
inline ::safe_browsing::ThreatListDescriptor* ListThreatListsResponse::add_threat_lists() {
  ::safe_browsing::ThreatListDescriptor* _add = _internal_add_threat_lists();
  // @@protoc_insertion_point(field_add:safe_browsing.ListThreatListsResponse.threat_lists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safe_browsing::ThreatListDescriptor >&
ListThreatListsResponse::threat_lists() const {
  // @@protoc_insertion_point(field_list:safe_browsing.ListThreatListsResponse.threat_lists)
  return threat_lists_;
}

// -------------------------------------------------------------------

// Duration

// optional int64 seconds = 1;
inline bool Duration::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Duration::has_seconds() const {
  return _internal_has_seconds();
}
inline void Duration::clear_seconds() {
  seconds_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Duration::_internal_seconds() const {
  return seconds_;
}
inline int64_t Duration::seconds() const {
  // @@protoc_insertion_point(field_get:safe_browsing.Duration.seconds)
  return _internal_seconds();
}
inline void Duration::_internal_set_seconds(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_ = value;
}
inline void Duration::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:safe_browsing.Duration.seconds)
}

// optional int32 nanos = 2;
inline bool Duration::_internal_has_nanos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Duration::has_nanos() const {
  return _internal_has_nanos();
}
inline void Duration::clear_nanos() {
  nanos_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Duration::_internal_nanos() const {
  return nanos_;
}
inline int32_t Duration::nanos() const {
  // @@protoc_insertion_point(field_get:safe_browsing.Duration.nanos)
  return _internal_nanos();
}
inline void Duration::_internal_set_nanos(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  nanos_ = value;
}
inline void Duration::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:safe_browsing.Duration.nanos)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace safe_browsing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ThreatHit_ThreatSourceType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ThreatType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::PlatformType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::CompressionType> : ::std::true_type {};
template <> struct is_proto_enum< ::safe_browsing::ThreatEntryType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_safebrowsing_2eproto
