// components/web_package/mojom/web_bundle_parser.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_TEST_UTILS_H_
#define COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_TEST_UTILS_H_

#include "components/web_package/mojom/web_bundle_parser.mojom.h"


namespace web_package {
namespace mojom {


class  WebBundleParserFactoryInterceptorForTesting : public WebBundleParserFactory {
  virtual WebBundleParserFactory* GetForwardingInterface() = 0;
  void GetParserForFile(::mojo::PendingReceiver<WebBundleParser> receiver, ::base::File file) override;
  void GetParserForDataSource(::mojo::PendingReceiver<WebBundleParser> receiver, ::mojo::PendingRemote<BundleDataSource> data_source) override;
};
class  WebBundleParserFactoryAsyncWaiter {
 public:
  explicit WebBundleParserFactoryAsyncWaiter(WebBundleParserFactory* proxy);

  WebBundleParserFactoryAsyncWaiter(const WebBundleParserFactoryAsyncWaiter&) = delete;
  WebBundleParserFactoryAsyncWaiter& operator=(const WebBundleParserFactoryAsyncWaiter&) = delete;

  ~WebBundleParserFactoryAsyncWaiter();

 private:
  WebBundleParserFactory* const proxy_;
};


class  WebBundleParserInterceptorForTesting : public WebBundleParser {
  virtual WebBundleParser* GetForwardingInterface() = 0;
  void ParseIntegrityBlock(ParseIntegrityBlockCallback callback) override;
  void ParseMetadata(int64_t offset, ParseMetadataCallback callback) override;
  void ParseResponse(uint64_t response_offset, uint64_t response_length, ParseResponseCallback callback) override;
};
class  WebBundleParserAsyncWaiter {
 public:
  explicit WebBundleParserAsyncWaiter(WebBundleParser* proxy);

  WebBundleParserAsyncWaiter(const WebBundleParserAsyncWaiter&) = delete;
  WebBundleParserAsyncWaiter& operator=(const WebBundleParserAsyncWaiter&) = delete;

  ~WebBundleParserAsyncWaiter();
  void ParseIntegrityBlock(
      BundleIntegrityBlockPtr* out_Result, BundleIntegrityBlockParseErrorPtr* out_error);
  void ParseMetadata(
      int64_t offset, BundleMetadataPtr* out_Result, BundleMetadataParseErrorPtr* out_error);
  void ParseResponse(
      uint64_t response_offset, uint64_t response_length, BundleResponsePtr* out_Result, BundleResponseParseErrorPtr* out_error);

 private:
  WebBundleParser* const proxy_;
};


class  BundleDataSourceInterceptorForTesting : public BundleDataSource {
  virtual BundleDataSource* GetForwardingInterface() = 0;
  void Read(uint64_t offset, uint64_t length, ReadCallback callback) override;
  void Length(LengthCallback callback) override;
  void IsRandomAccessContext(IsRandomAccessContextCallback callback) override;
};
class  BundleDataSourceAsyncWaiter {
 public:
  explicit BundleDataSourceAsyncWaiter(BundleDataSource* proxy);

  BundleDataSourceAsyncWaiter(const BundleDataSourceAsyncWaiter&) = delete;
  BundleDataSourceAsyncWaiter& operator=(const BundleDataSourceAsyncWaiter&) = delete;

  ~BundleDataSourceAsyncWaiter();
  void Read(
      uint64_t offset, uint64_t length, absl::optional<std::vector<uint8_t>>* out_buffer);
  void Length(
      int64_t* out_length);
  void IsRandomAccessContext(
      bool* out_is_random_access);

 private:
  BundleDataSource* const proxy_;
};




}  // namespace mojom
}  // namespace web_package

#endif  // COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_TEST_UTILS_H_