// components/web_package/mojom/web_bundle_parser.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_SHARED_H_
#define COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/web_package/mojom/web_bundle_parser.mojom-shared-internal.h"
#include "mojo/public/mojom/base/read_only_file.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace web_package {
namespace mojom {
class BundleIntegrityBlockParseErrorDataView;

class BundleMetadataParseErrorDataView;

class BundleResponseParseErrorDataView;

class BundleIntegrityBlockDataView;

class BundleIntegrityBlockSignatureStackEntryDataView;

class BundleMetadataDataView;

class BundleResponseLocationDataView;

class AugmentedCertificateDataView;

class VouchedSubsetDataView;

class SignedSubsetDataView;

class SubsetHashesValueDataView;

class ResourceIntegrityDataView;

class BundleResponseDataView;



}  // namespace mojom
}  // namespace web_package

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::web_package::mojom::BundleIntegrityBlockParseErrorDataView> {
  using Data = ::web_package::mojom::internal::BundleIntegrityBlockParseError_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleMetadataParseErrorDataView> {
  using Data = ::web_package::mojom::internal::BundleMetadataParseError_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleResponseParseErrorDataView> {
  using Data = ::web_package::mojom::internal::BundleResponseParseError_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleIntegrityBlockDataView> {
  using Data = ::web_package::mojom::internal::BundleIntegrityBlock_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleIntegrityBlockSignatureStackEntryDataView> {
  using Data = ::web_package::mojom::internal::BundleIntegrityBlockSignatureStackEntry_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleMetadataDataView> {
  using Data = ::web_package::mojom::internal::BundleMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleResponseLocationDataView> {
  using Data = ::web_package::mojom::internal::BundleResponseLocation_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::AugmentedCertificateDataView> {
  using Data = ::web_package::mojom::internal::AugmentedCertificate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::VouchedSubsetDataView> {
  using Data = ::web_package::mojom::internal::VouchedSubset_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::SignedSubsetDataView> {
  using Data = ::web_package::mojom::internal::SignedSubset_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::SubsetHashesValueDataView> {
  using Data = ::web_package::mojom::internal::SubsetHashesValue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::ResourceIntegrityDataView> {
  using Data = ::web_package::mojom::internal::ResourceIntegrity_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::web_package::mojom::BundleResponseDataView> {
  using Data = ::web_package::mojom::internal::BundleResponse_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace web_package {
namespace mojom {


enum class BundleParseErrorType : int32_t {
  
  kParserInternalError = 0,
  
  kFormatError = 1,
  
  kVersionError = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, BundleParseErrorType value);
inline bool IsKnownEnumValue(BundleParseErrorType value) {
  return internal::BundleParseErrorType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class BundleFormatVersion : int32_t {
  
  kB1 = 0,
  
  kB2 = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, BundleFormatVersion value);
inline bool IsKnownEnumValue(BundleFormatVersion value) {
  return internal::BundleFormatVersion_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class WebBundleParserFactoryInterfaceBase {};

using WebBundleParserFactoryPtrDataView =
    mojo::InterfacePtrDataView<WebBundleParserFactoryInterfaceBase>;
using WebBundleParserFactoryRequestDataView =
    mojo::InterfaceRequestDataView<WebBundleParserFactoryInterfaceBase>;
using WebBundleParserFactoryAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<WebBundleParserFactoryInterfaceBase>;
using WebBundleParserFactoryAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<WebBundleParserFactoryInterfaceBase>;
class WebBundleParserInterfaceBase {};

using WebBundleParserPtrDataView =
    mojo::InterfacePtrDataView<WebBundleParserInterfaceBase>;
using WebBundleParserRequestDataView =
    mojo::InterfaceRequestDataView<WebBundleParserInterfaceBase>;
using WebBundleParserAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<WebBundleParserInterfaceBase>;
using WebBundleParserAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<WebBundleParserInterfaceBase>;
class BundleDataSourceInterfaceBase {};

using BundleDataSourcePtrDataView =
    mojo::InterfacePtrDataView<BundleDataSourceInterfaceBase>;
using BundleDataSourceRequestDataView =
    mojo::InterfaceRequestDataView<BundleDataSourceInterfaceBase>;
using BundleDataSourceAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<BundleDataSourceInterfaceBase>;
using BundleDataSourceAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<BundleDataSourceInterfaceBase>;


class BundleIntegrityBlockParseErrorDataView {
 public:
  BundleIntegrityBlockParseErrorDataView() = default;

  BundleIntegrityBlockParseErrorDataView(
      internal::BundleIntegrityBlockParseError_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::web_package::mojom::BundleParseErrorType>(
        data_value, output);
  }
  BundleParseErrorType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::web_package::mojom::BundleParseErrorType>(data_->type));
  }
  inline void GetMessageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMessage(UserType* output) {
    
    auto* pointer = data_->message.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::BundleIntegrityBlockParseError_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleMetadataParseErrorDataView {
 public:
  BundleMetadataParseErrorDataView() = default;

  BundleMetadataParseErrorDataView(
      internal::BundleMetadataParseError_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::web_package::mojom::BundleParseErrorType>(
        data_value, output);
  }
  BundleParseErrorType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::web_package::mojom::BundleParseErrorType>(data_->type));
  }
  inline void GetMessageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMessage(UserType* output) {
    
    auto* pointer = data_->message.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::BundleMetadataParseError_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleResponseParseErrorDataView {
 public:
  BundleResponseParseErrorDataView() = default;

  BundleResponseParseErrorDataView(
      internal::BundleResponseParseError_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::web_package::mojom::BundleParseErrorType>(
        data_value, output);
  }
  BundleParseErrorType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::web_package::mojom::BundleParseErrorType>(data_->type));
  }
  inline void GetMessageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMessage(UserType* output) {
    
    auto* pointer = data_->message.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::BundleResponseParseError_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleIntegrityBlockDataView {
 public:
  BundleIntegrityBlockDataView() = default;

  BundleIntegrityBlockDataView(
      internal::BundleIntegrityBlock_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t size() const {
    return data_->size;
  }
  inline void GetSignatureStackDataView(
      mojo::ArrayDataView<BundleIntegrityBlockSignatureStackEntryDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSignatureStack(UserType* output) {
    
    auto* pointer = data_->signature_stack.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::web_package::mojom::BundleIntegrityBlockSignatureStackEntryDataView>>(
        pointer, output, message_);
  }
 private:
  internal::BundleIntegrityBlock_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleIntegrityBlockSignatureStackEntryDataView {
 public:
  BundleIntegrityBlockSignatureStackEntryDataView() = default;

  BundleIntegrityBlockSignatureStackEntryDataView(
      internal::BundleIntegrityBlockSignatureStackEntry_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetCompleteEntryCborDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCompleteEntryCbor(UserType* output) {
    
    auto* pointer = data_->complete_entry_cbor.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetAttributesCborDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAttributesCbor(UserType* output) {
    
    auto* pointer = data_->attributes_cbor.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetPublicKeyDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPublicKey(UserType* output) {
    
    auto* pointer = data_->public_key.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetSignatureDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSignature(UserType* output) {
    
    auto* pointer = data_->signature.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::BundleIntegrityBlockSignatureStackEntry_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleMetadataDataView {
 public:
  BundleMetadataDataView() = default;

  BundleMetadataDataView(
      internal::BundleMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadVersion(UserType* output) const {
    auto data_value = data_->version;
    return mojo::internal::Deserialize<::web_package::mojom::BundleFormatVersion>(
        data_value, output);
  }
  BundleFormatVersion version() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::web_package::mojom::BundleFormatVersion>(data_->version));
  }
  inline void GetPrimaryUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryUrl(UserType* output) {
    
    auto* pointer = data_->primary_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetRequestsDataView(
      mojo::MapDataView<::url::mojom::UrlDataView, BundleResponseLocationDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequests(UserType* output) {
    
    auto* pointer = data_->requests.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<::url::mojom::UrlDataView, ::web_package::mojom::BundleResponseLocationDataView>>(
        pointer, output, message_);
  }
  inline void GetAuthoritiesDataView(
      mojo::ArrayDataView<AugmentedCertificateDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuthorities(UserType* output) {
    
    auto* pointer = data_->authorities.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::web_package::mojom::AugmentedCertificateDataView>>(
        pointer, output, message_);
  }
  inline void GetVouchedSubsetsDataView(
      mojo::ArrayDataView<VouchedSubsetDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVouchedSubsets(UserType* output) {
    
    auto* pointer = data_->vouched_subsets.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::web_package::mojom::VouchedSubsetDataView>>(
        pointer, output, message_);
  }
 private:
  internal::BundleMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleResponseLocationDataView {
 public:
  BundleResponseLocationDataView() = default;

  BundleResponseLocationDataView(
      internal::BundleResponseLocation_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t offset() const {
    return data_->offset;
  }
  uint64_t length() const {
    return data_->length;
  }
 private:
  internal::BundleResponseLocation_Data* data_ = nullptr;
};



class AugmentedCertificateDataView {
 public:
  AugmentedCertificateDataView() = default;

  AugmentedCertificateDataView(
      internal::AugmentedCertificate_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetCertDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCert(UserType* output) {
    
    auto* pointer = data_->cert.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetOcspDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOcsp(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `ocsp` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadOcsp` instead "
    "of `ReadOcsp if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->ocsp.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetSctDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSct(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `sct` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSct` instead "
    "of `ReadSct if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->sct.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::AugmentedCertificate_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VouchedSubsetDataView {
 public:
  VouchedSubsetDataView() = default;

  VouchedSubsetDataView(
      internal::VouchedSubset_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t authority() const {
    return data_->authority;
  }
  inline void GetSigDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSig(UserType* output) {
    
    auto* pointer = data_->sig.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetRawSignedDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRawSigned(UserType* output) {
    
    auto* pointer = data_->raw_signed.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetParsedSignedDataView(
      SignedSubsetDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParsedSigned(UserType* output) {
    
    auto* pointer = data_->parsed_signed.Get();
    return mojo::internal::Deserialize<::web_package::mojom::SignedSubsetDataView>(
        pointer, output, message_);
  }
 private:
  internal::VouchedSubset_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SignedSubsetDataView {
 public:
  SignedSubsetDataView() = default;

  SignedSubsetDataView(
      internal::SignedSubset_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetValidityUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValidityUrl(UserType* output) {
    
    auto* pointer = data_->validity_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetAuthSha256DataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuthSha256(UserType* output) {
    
    auto* pointer = data_->auth_sha256.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  uint64_t date() const {
    return data_->date;
  }
  uint64_t expires() const {
    return data_->expires;
  }
  inline void GetSubsetHashesDataView(
      mojo::MapDataView<::url::mojom::UrlDataView, SubsetHashesValueDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSubsetHashes(UserType* output) {
    
    auto* pointer = data_->subset_hashes.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<::url::mojom::UrlDataView, ::web_package::mojom::SubsetHashesValueDataView>>(
        pointer, output, message_);
  }
 private:
  internal::SignedSubset_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SubsetHashesValueDataView {
 public:
  SubsetHashesValueDataView() = default;

  SubsetHashesValueDataView(
      internal::SubsetHashesValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetVariantsValueDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVariantsValue(UserType* output) {
    
    auto* pointer = data_->variants_value.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetResourceIntegritiesDataView(
      mojo::ArrayDataView<ResourceIntegrityDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadResourceIntegrities(UserType* output) {
    
    auto* pointer = data_->resource_integrities.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::web_package::mojom::ResourceIntegrityDataView>>(
        pointer, output, message_);
  }
 private:
  internal::SubsetHashesValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ResourceIntegrityDataView {
 public:
  ResourceIntegrityDataView() = default;

  ResourceIntegrityDataView(
      internal::ResourceIntegrity_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetHeaderSha256DataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHeaderSha256(UserType* output) {
    
    auto* pointer = data_->header_sha256.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetPayloadIntegrityHeaderDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPayloadIntegrityHeader(UserType* output) {
    
    auto* pointer = data_->payload_integrity_header.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::ResourceIntegrity_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BundleResponseDataView {
 public:
  BundleResponseDataView() = default;

  BundleResponseDataView(
      internal::BundleResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t response_code() const {
    return data_->response_code;
  }
  inline void GetResponseHeadersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadResponseHeaders(UserType* output) {
    
    auto* pointer = data_->response_headers.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        pointer, output, message_);
  }
  uint64_t payload_offset() const {
    return data_->payload_offset;
  }
  uint64_t payload_length() const {
    return data_->payload_length;
  }
 private:
  internal::BundleResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace web_package

namespace std {

template <>
struct hash<::web_package::mojom::BundleParseErrorType>
    : public mojo::internal::EnumHashImpl<::web_package::mojom::BundleParseErrorType> {};

template <>
struct hash<::web_package::mojom::BundleFormatVersion>
    : public mojo::internal::EnumHashImpl<::web_package::mojom::BundleFormatVersion> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleParseErrorType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::web_package::mojom::BundleParseErrorType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::web_package::mojom::BundleParseErrorType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleFormatVersion, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::web_package::mojom::BundleFormatVersion, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::web_package::mojom::BundleFormatVersion>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleIntegrityBlockParseErrorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleIntegrityBlockParseErrorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleIntegrityBlockParseError_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::web_package::mojom::BundleParseErrorType>(
        Traits::type(input), &fragment->type);
    decltype(Traits::message(input)) in_message = Traits::message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->message)::BaseType> message_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_message, message_fragment);
    fragment->message.Set(
        message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null message in BundleIntegrityBlockParseError struct");
  }

  static bool Deserialize(::web_package::mojom::internal::BundleIntegrityBlockParseError_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleIntegrityBlockParseErrorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleMetadataParseErrorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleMetadataParseErrorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleMetadataParseError_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::web_package::mojom::BundleParseErrorType>(
        Traits::type(input), &fragment->type);
    decltype(Traits::message(input)) in_message = Traits::message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->message)::BaseType> message_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_message, message_fragment);
    fragment->message.Set(
        message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null message in BundleMetadataParseError struct");
  }

  static bool Deserialize(::web_package::mojom::internal::BundleMetadataParseError_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleMetadataParseErrorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleResponseParseErrorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleResponseParseErrorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleResponseParseError_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::web_package::mojom::BundleParseErrorType>(
        Traits::type(input), &fragment->type);
    decltype(Traits::message(input)) in_message = Traits::message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->message)::BaseType> message_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_message, message_fragment);
    fragment->message.Set(
        message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null message in BundleResponseParseError struct");
  }

  static bool Deserialize(::web_package::mojom::internal::BundleResponseParseError_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleResponseParseErrorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleIntegrityBlockDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleIntegrityBlockDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleIntegrityBlock_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->size = Traits::size(input);
    decltype(Traits::signature_stack(input)) in_signature_stack = Traits::signature_stack(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->signature_stack)::BaseType>
        signature_stack_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams signature_stack_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::web_package::mojom::BundleIntegrityBlockSignatureStackEntryDataView>>(
        in_signature_stack, signature_stack_fragment, &signature_stack_validate_params);
    fragment->signature_stack.Set(
        signature_stack_fragment.is_null() ? nullptr : signature_stack_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->signature_stack.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null signature_stack in BundleIntegrityBlock struct");
  }

  static bool Deserialize(::web_package::mojom::internal::BundleIntegrityBlock_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleIntegrityBlockDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleIntegrityBlockSignatureStackEntryDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleIntegrityBlockSignatureStackEntryDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleIntegrityBlockSignatureStackEntry_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::complete_entry_cbor(input)) in_complete_entry_cbor = Traits::complete_entry_cbor(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->complete_entry_cbor)::BaseType>
        complete_entry_cbor_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams complete_entry_cbor_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_complete_entry_cbor, complete_entry_cbor_fragment, &complete_entry_cbor_validate_params);
    fragment->complete_entry_cbor.Set(
        complete_entry_cbor_fragment.is_null() ? nullptr : complete_entry_cbor_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->complete_entry_cbor.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null complete_entry_cbor in BundleIntegrityBlockSignatureStackEntry struct");
    decltype(Traits::attributes_cbor(input)) in_attributes_cbor = Traits::attributes_cbor(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->attributes_cbor)::BaseType>
        attributes_cbor_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams attributes_cbor_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_attributes_cbor, attributes_cbor_fragment, &attributes_cbor_validate_params);
    fragment->attributes_cbor.Set(
        attributes_cbor_fragment.is_null() ? nullptr : attributes_cbor_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->attributes_cbor.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null attributes_cbor in BundleIntegrityBlockSignatureStackEntry struct");
    decltype(Traits::public_key(input)) in_public_key = Traits::public_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->public_key)::BaseType>
        public_key_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams public_key_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_public_key, public_key_fragment, &public_key_validate_params);
    fragment->public_key.Set(
        public_key_fragment.is_null() ? nullptr : public_key_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->public_key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null public_key in BundleIntegrityBlockSignatureStackEntry struct");
    decltype(Traits::signature(input)) in_signature = Traits::signature(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->signature)::BaseType>
        signature_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams signature_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_signature, signature_fragment, &signature_validate_params);
    fragment->signature.Set(
        signature_fragment.is_null() ? nullptr : signature_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->signature.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null signature in BundleIntegrityBlockSignatureStackEntry struct");
  }

  static bool Deserialize(::web_package::mojom::internal::BundleIntegrityBlockSignatureStackEntry_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::web_package::mojom::BundleFormatVersion>(
        Traits::version(input), &fragment->version);
    decltype(Traits::primary_url(input)) in_primary_url = Traits::primary_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->primary_url)::BaseType> primary_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_primary_url, primary_url_fragment);
    fragment->primary_url.Set(
        primary_url_fragment.is_null() ? nullptr : primary_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_url in BundleMetadata struct");
    decltype(Traits::requests(input)) in_requests = Traits::requests(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->requests)::BaseType>
        requests_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams requests_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<::url::mojom::UrlDataView, ::web_package::mojom::BundleResponseLocationDataView>>(
        in_requests, requests_fragment, &requests_validate_params);
    fragment->requests.Set(
        requests_fragment.is_null() ? nullptr : requests_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->requests.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null requests in BundleMetadata struct");
    decltype(Traits::authorities(input)) in_authorities = Traits::authorities(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->authorities)::BaseType>
        authorities_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams authorities_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::web_package::mojom::AugmentedCertificateDataView>>(
        in_authorities, authorities_fragment, &authorities_validate_params);
    fragment->authorities.Set(
        authorities_fragment.is_null() ? nullptr : authorities_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->authorities.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null authorities in BundleMetadata struct");
    decltype(Traits::vouched_subsets(input)) in_vouched_subsets = Traits::vouched_subsets(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->vouched_subsets)::BaseType>
        vouched_subsets_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams vouched_subsets_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::web_package::mojom::VouchedSubsetDataView>>(
        in_vouched_subsets, vouched_subsets_fragment, &vouched_subsets_validate_params);
    fragment->vouched_subsets.Set(
        vouched_subsets_fragment.is_null() ? nullptr : vouched_subsets_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->vouched_subsets.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null vouched_subsets in BundleMetadata struct");
  }

  static bool Deserialize(::web_package::mojom::internal::BundleMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleResponseLocationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleResponseLocationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleResponseLocation_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->offset = Traits::offset(input);
    fragment->length = Traits::length(input);
  }

  static bool Deserialize(::web_package::mojom::internal::BundleResponseLocation_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleResponseLocationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::AugmentedCertificateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::AugmentedCertificateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::AugmentedCertificate_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::cert(input)) in_cert = Traits::cert(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cert)::BaseType>
        cert_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams cert_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_cert, cert_fragment, &cert_validate_params);
    fragment->cert.Set(
        cert_fragment.is_null() ? nullptr : cert_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->cert.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null cert in AugmentedCertificate struct");
    decltype(Traits::ocsp(input)) in_ocsp = Traits::ocsp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->ocsp)::BaseType>
        ocsp_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams ocsp_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_ocsp, ocsp_fragment, &ocsp_validate_params);
    fragment->ocsp.Set(
        ocsp_fragment.is_null() ? nullptr : ocsp_fragment.data());
    decltype(Traits::sct(input)) in_sct = Traits::sct(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->sct)::BaseType>
        sct_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams sct_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_sct, sct_fragment, &sct_validate_params);
    fragment->sct.Set(
        sct_fragment.is_null() ? nullptr : sct_fragment.data());
  }

  static bool Deserialize(::web_package::mojom::internal::AugmentedCertificate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::AugmentedCertificateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::VouchedSubsetDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::VouchedSubsetDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::VouchedSubset_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->authority = Traits::authority(input);
    decltype(Traits::sig(input)) in_sig = Traits::sig(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->sig)::BaseType>
        sig_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams sig_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_sig, sig_fragment, &sig_validate_params);
    fragment->sig.Set(
        sig_fragment.is_null() ? nullptr : sig_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->sig.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null sig in VouchedSubset struct");
    decltype(Traits::raw_signed(input)) in_raw_signed = Traits::raw_signed(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->raw_signed)::BaseType>
        raw_signed_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams raw_signed_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_raw_signed, raw_signed_fragment, &raw_signed_validate_params);
    fragment->raw_signed.Set(
        raw_signed_fragment.is_null() ? nullptr : raw_signed_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->raw_signed.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null raw_signed in VouchedSubset struct");
    decltype(Traits::parsed_signed(input)) in_parsed_signed = Traits::parsed_signed(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parsed_signed)::BaseType> parsed_signed_fragment(
            fragment.message());
    mojo::internal::Serialize<::web_package::mojom::SignedSubsetDataView>(
        in_parsed_signed, parsed_signed_fragment);
    fragment->parsed_signed.Set(
        parsed_signed_fragment.is_null() ? nullptr : parsed_signed_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->parsed_signed.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null parsed_signed in VouchedSubset struct");
  }

  static bool Deserialize(::web_package::mojom::internal::VouchedSubset_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::VouchedSubsetDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::SignedSubsetDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::SignedSubsetDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::SignedSubset_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::validity_url(input)) in_validity_url = Traits::validity_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->validity_url)::BaseType> validity_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_validity_url, validity_url_fragment);
    fragment->validity_url.Set(
        validity_url_fragment.is_null() ? nullptr : validity_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->validity_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null validity_url in SignedSubset struct");
    decltype(Traits::auth_sha256(input)) in_auth_sha256 = Traits::auth_sha256(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->auth_sha256)::BaseType>
        auth_sha256_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams auth_sha256_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_auth_sha256, auth_sha256_fragment, &auth_sha256_validate_params);
    fragment->auth_sha256.Set(
        auth_sha256_fragment.is_null() ? nullptr : auth_sha256_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->auth_sha256.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null auth_sha256 in SignedSubset struct");
    fragment->date = Traits::date(input);
    fragment->expires = Traits::expires(input);
    decltype(Traits::subset_hashes(input)) in_subset_hashes = Traits::subset_hashes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->subset_hashes)::BaseType>
        subset_hashes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams subset_hashes_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<::url::mojom::UrlDataView, ::web_package::mojom::SubsetHashesValueDataView>>(
        in_subset_hashes, subset_hashes_fragment, &subset_hashes_validate_params);
    fragment->subset_hashes.Set(
        subset_hashes_fragment.is_null() ? nullptr : subset_hashes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->subset_hashes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null subset_hashes in SignedSubset struct");
  }

  static bool Deserialize(::web_package::mojom::internal::SignedSubset_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::SignedSubsetDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::SubsetHashesValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::SubsetHashesValueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::SubsetHashesValue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::variants_value(input)) in_variants_value = Traits::variants_value(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->variants_value)::BaseType> variants_value_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_variants_value, variants_value_fragment);
    fragment->variants_value.Set(
        variants_value_fragment.is_null() ? nullptr : variants_value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->variants_value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null variants_value in SubsetHashesValue struct");
    decltype(Traits::resource_integrities(input)) in_resource_integrities = Traits::resource_integrities(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->resource_integrities)::BaseType>
        resource_integrities_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams resource_integrities_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::web_package::mojom::ResourceIntegrityDataView>>(
        in_resource_integrities, resource_integrities_fragment, &resource_integrities_validate_params);
    fragment->resource_integrities.Set(
        resource_integrities_fragment.is_null() ? nullptr : resource_integrities_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->resource_integrities.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null resource_integrities in SubsetHashesValue struct");
  }

  static bool Deserialize(::web_package::mojom::internal::SubsetHashesValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::SubsetHashesValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::ResourceIntegrityDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::ResourceIntegrityDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::ResourceIntegrity_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::header_sha256(input)) in_header_sha256 = Traits::header_sha256(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->header_sha256)::BaseType>
        header_sha256_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams header_sha256_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_header_sha256, header_sha256_fragment, &header_sha256_validate_params);
    fragment->header_sha256.Set(
        header_sha256_fragment.is_null() ? nullptr : header_sha256_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->header_sha256.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null header_sha256 in ResourceIntegrity struct");
    decltype(Traits::payload_integrity_header(input)) in_payload_integrity_header = Traits::payload_integrity_header(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->payload_integrity_header)::BaseType> payload_integrity_header_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_payload_integrity_header, payload_integrity_header_fragment);
    fragment->payload_integrity_header.Set(
        payload_integrity_header_fragment.is_null() ? nullptr : payload_integrity_header_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->payload_integrity_header.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null payload_integrity_header in ResourceIntegrity struct");
  }

  static bool Deserialize(::web_package::mojom::internal::ResourceIntegrity_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::ResourceIntegrityDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::web_package::mojom::BundleResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::web_package::mojom::BundleResponseDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::web_package::mojom::internal::BundleResponse_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->response_code = Traits::response_code(input);
    decltype(Traits::response_headers(input)) in_response_headers = Traits::response_headers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->response_headers)::BaseType>
        response_headers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams response_headers_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        in_response_headers, response_headers_fragment, &response_headers_validate_params);
    fragment->response_headers.Set(
        response_headers_fragment.is_null() ? nullptr : response_headers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->response_headers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null response_headers in BundleResponse struct");
    fragment->payload_offset = Traits::payload_offset(input);
    fragment->payload_length = Traits::payload_length(input);
  }

  static bool Deserialize(::web_package::mojom::internal::BundleResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::web_package::mojom::BundleResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace web_package {
namespace mojom {

inline void BundleIntegrityBlockParseErrorDataView::GetMessageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->message.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void BundleMetadataParseErrorDataView::GetMessageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->message.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void BundleResponseParseErrorDataView::GetMessageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->message.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void BundleIntegrityBlockDataView::GetSignatureStackDataView(
    mojo::ArrayDataView<BundleIntegrityBlockSignatureStackEntryDataView>* output) {
  auto pointer = data_->signature_stack.Get();
  *output = mojo::ArrayDataView<BundleIntegrityBlockSignatureStackEntryDataView>(pointer, message_);
}


inline void BundleIntegrityBlockSignatureStackEntryDataView::GetCompleteEntryCborDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->complete_entry_cbor.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void BundleIntegrityBlockSignatureStackEntryDataView::GetAttributesCborDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->attributes_cbor.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void BundleIntegrityBlockSignatureStackEntryDataView::GetPublicKeyDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->public_key.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void BundleIntegrityBlockSignatureStackEntryDataView::GetSignatureDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->signature.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void BundleMetadataDataView::GetPrimaryUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->primary_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void BundleMetadataDataView::GetRequestsDataView(
    mojo::MapDataView<::url::mojom::UrlDataView, BundleResponseLocationDataView>* output) {
  auto pointer = data_->requests.Get();
  *output = mojo::MapDataView<::url::mojom::UrlDataView, BundleResponseLocationDataView>(pointer, message_);
}
inline void BundleMetadataDataView::GetAuthoritiesDataView(
    mojo::ArrayDataView<AugmentedCertificateDataView>* output) {
  auto pointer = data_->authorities.Get();
  *output = mojo::ArrayDataView<AugmentedCertificateDataView>(pointer, message_);
}
inline void BundleMetadataDataView::GetVouchedSubsetsDataView(
    mojo::ArrayDataView<VouchedSubsetDataView>* output) {
  auto pointer = data_->vouched_subsets.Get();
  *output = mojo::ArrayDataView<VouchedSubsetDataView>(pointer, message_);
}




inline void AugmentedCertificateDataView::GetCertDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->cert.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void AugmentedCertificateDataView::GetOcspDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->ocsp.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void AugmentedCertificateDataView::GetSctDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->sct.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void VouchedSubsetDataView::GetSigDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->sig.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void VouchedSubsetDataView::GetRawSignedDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->raw_signed.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void VouchedSubsetDataView::GetParsedSignedDataView(
    SignedSubsetDataView* output) {
  auto pointer = data_->parsed_signed.Get();
  *output = SignedSubsetDataView(pointer, message_);
}


inline void SignedSubsetDataView::GetValidityUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->validity_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void SignedSubsetDataView::GetAuthSha256DataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->auth_sha256.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void SignedSubsetDataView::GetSubsetHashesDataView(
    mojo::MapDataView<::url::mojom::UrlDataView, SubsetHashesValueDataView>* output) {
  auto pointer = data_->subset_hashes.Get();
  *output = mojo::MapDataView<::url::mojom::UrlDataView, SubsetHashesValueDataView>(pointer, message_);
}


inline void SubsetHashesValueDataView::GetVariantsValueDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->variants_value.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void SubsetHashesValueDataView::GetResourceIntegritiesDataView(
    mojo::ArrayDataView<ResourceIntegrityDataView>* output) {
  auto pointer = data_->resource_integrities.Get();
  *output = mojo::ArrayDataView<ResourceIntegrityDataView>(pointer, message_);
}


inline void ResourceIntegrityDataView::GetHeaderSha256DataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->header_sha256.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void ResourceIntegrityDataView::GetPayloadIntegrityHeaderDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->payload_integrity_header.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void BundleResponseDataView::GetResponseHeadersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output) {
  auto pointer = data_->response_headers.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>(pointer, message_);
}



}  // namespace mojom
}  // namespace web_package

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::web_package::mojom::BundleParseErrorType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::web_package::mojom::BundleParseErrorType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::web_package::mojom::BundleFormatVersion> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::web_package::mojom::BundleFormatVersion value);
};

} // namespace perfetto

#endif  // COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_SHARED_H_