// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service_worker_database.proto

#include "service_worker_database.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace storage {
PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialFeature::ServiceWorkerOriginTrialFeature(
    ::_pbi::ConstantInitialized)
  : tokens_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ServiceWorkerOriginTrialFeatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialFeatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceWorkerOriginTrialFeatureDefaultTypeInternal() {}
  union {
    ServiceWorkerOriginTrialFeature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerOriginTrialFeatureDefaultTypeInternal _ServiceWorkerOriginTrialFeature_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialInfo::ServiceWorkerOriginTrialInfo(
    ::_pbi::ConstantInitialized)
  : features_(){}
struct ServiceWorkerOriginTrialInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceWorkerOriginTrialInfoDefaultTypeInternal() {}
  union {
    ServiceWorkerOriginTrialInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerOriginTrialInfoDefaultTypeInternal _ServiceWorkerOriginTrialInfo_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerNavigationPreloadState::ServiceWorkerNavigationPreloadState(
    ::_pbi::ConstantInitialized)
  : header_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enabled_(false){}
struct ServiceWorkerNavigationPreloadStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceWorkerNavigationPreloadStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceWorkerNavigationPreloadStateDefaultTypeInternal() {}
  union {
    ServiceWorkerNavigationPreloadState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerNavigationPreloadStateDefaultTypeInternal _ServiceWorkerNavigationPreloadState_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData::ServiceWorkerRegistrationData(
    ::_pbi::ConstantInitialized)
  : used_features_()
  , scope_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , script_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cross_origin_embedder_policy_reporting_endpoint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cross_origin_embedder_policy_report_only_reporting_endpoint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , origin_trial_tokens_(nullptr)
  , navigation_preload_state_(nullptr)
  , registration_id_(int64_t{0})
  , version_id_(int64_t{0})
  , last_update_check_time_(int64_t{0})
  , resources_total_size_bytes_(uint64_t{0u})
  , is_active_(false)
  , has_fetch_handler_(false)
  , update_via_cache_(0)

  , script_response_time_(int64_t{0})
  , script_type_(0)

  , cross_origin_embedder_policy_value_(0)

  , cross_origin_embedder_policy_report_only_value_(0)

  , ancestor_frame_type_(0)

  , fetch_handler_skippable_type_(1)
{}
struct ServiceWorkerRegistrationDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceWorkerRegistrationDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceWorkerRegistrationDataDefaultTypeInternal() {}
  union {
    ServiceWorkerRegistrationData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationDataDefaultTypeInternal _ServiceWorkerRegistrationData_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerResourceRecord::ServiceWorkerResourceRecord(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , resource_id_(int64_t{0})
  , size_bytes_(uint64_t{0u}){}
struct ServiceWorkerResourceRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServiceWorkerResourceRecordDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServiceWorkerResourceRecordDefaultTypeInternal() {}
  union {
    ServiceWorkerResourceRecord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerResourceRecordDefaultTypeInternal _ServiceWorkerResourceRecord_default_instance_;
}  // namespace storage
namespace storage {
bool ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_ServiceWorkerScriptType_strings[2] = {};

static const char ServiceWorkerRegistrationData_ServiceWorkerScriptType_names[] =
  "CLASSIC"
  "MODULE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries[] = {
  { {ServiceWorkerRegistrationData_ServiceWorkerScriptType_names + 0, 7}, 0 },
  { {ServiceWorkerRegistrationData_ServiceWorkerScriptType_names + 7, 6}, 1 },
};

static const int ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries_by_number[] = {
  0, // 0 -> CLASSIC
  1, // 1 -> MODULE
};

const std::string& ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name(
    ServiceWorkerRegistrationData_ServiceWorkerScriptType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries,
          ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries_by_number,
          2, ServiceWorkerRegistrationData_ServiceWorkerScriptType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries,
      ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceWorkerRegistrationData_ServiceWorkerScriptType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_ServiceWorkerScriptType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ServiceWorkerScriptType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ServiceWorkerRegistrationData_ServiceWorkerScriptType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::CLASSIC;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::MODULE;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::ServiceWorkerScriptType_MIN;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::ServiceWorkerScriptType_MAX;
constexpr int ServiceWorkerRegistrationData::ServiceWorkerScriptType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_strings[3] = {};

static const char ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names[] =
  "ALL"
  "IMPORTS"
  "NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries[] = {
  { {ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names + 0, 3}, 1 },
  { {ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names + 3, 7}, 0 },
  { {ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names + 10, 4}, 2 },
};

static const int ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries_by_number[] = {
  1, // 0 -> IMPORTS
  0, // 1 -> ALL
  2, // 2 -> NONE
};

const std::string& ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name(
    ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries,
          ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries_by_number,
          3, ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries,
      ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::IMPORTS;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::ALL;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::NONE;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::ServiceWorkerUpdateViaCacheType_MIN;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::ServiceWorkerUpdateViaCacheType_MAX;
constexpr int ServiceWorkerRegistrationData::ServiceWorkerUpdateViaCacheType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_strings[3] = {};

static const char ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names[] =
  "CREDENTIALLESS"
  "NONE_OR_NOT_EXIST"
  "REQUIRE_CORP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries[] = {
  { {ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names + 0, 14}, 2 },
  { {ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names + 14, 17}, 0 },
  { {ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names + 31, 12}, 1 },
};

static const int ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries_by_number[] = {
  1, // 0 -> NONE_OR_NOT_EXIST
  2, // 1 -> REQUIRE_CORP
  0, // 2 -> CREDENTIALLESS
};

const std::string& ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name(
    ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries,
          ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries_by_number,
          3, ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries,
      ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_strings[idx].get();
}
bool ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::NONE_OR_NOT_EXIST;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::REQUIRE_CORP;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::CREDENTIALLESS;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::CrossOriginEmbedderPolicyValue_MIN;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::CrossOriginEmbedderPolicyValue_MAX;
constexpr int ServiceWorkerRegistrationData::CrossOriginEmbedderPolicyValue_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_AncestorFrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_AncestorFrameType_strings[2] = {};

static const char ServiceWorkerRegistrationData_AncestorFrameType_names[] =
  "FENCED_FRAME"
  "NORMAL_FRAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_AncestorFrameType_entries[] = {
  { {ServiceWorkerRegistrationData_AncestorFrameType_names + 0, 12}, 1 },
  { {ServiceWorkerRegistrationData_AncestorFrameType_names + 12, 12}, 0 },
};

static const int ServiceWorkerRegistrationData_AncestorFrameType_entries_by_number[] = {
  1, // 0 -> NORMAL_FRAME
  0, // 1 -> FENCED_FRAME
};

const std::string& ServiceWorkerRegistrationData_AncestorFrameType_Name(
    ServiceWorkerRegistrationData_AncestorFrameType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceWorkerRegistrationData_AncestorFrameType_entries,
          ServiceWorkerRegistrationData_AncestorFrameType_entries_by_number,
          2, ServiceWorkerRegistrationData_AncestorFrameType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceWorkerRegistrationData_AncestorFrameType_entries,
      ServiceWorkerRegistrationData_AncestorFrameType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceWorkerRegistrationData_AncestorFrameType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_AncestorFrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_AncestorFrameType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceWorkerRegistrationData_AncestorFrameType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ServiceWorkerRegistrationData_AncestorFrameType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::NORMAL_FRAME;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::FENCED_FRAME;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::AncestorFrameType_MIN;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::AncestorFrameType_MAX;
constexpr int ServiceWorkerRegistrationData::AncestorFrameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_FetchHandlerSkippableType_strings[2] = {};

static const char ServiceWorkerRegistrationData_FetchHandlerSkippableType_names[] =
  "NOT_SKIPPABLE"
  "SKIPPABLE_EMPTY_FETCH_HANDLER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries[] = {
  { {ServiceWorkerRegistrationData_FetchHandlerSkippableType_names + 0, 13}, 1 },
  { {ServiceWorkerRegistrationData_FetchHandlerSkippableType_names + 13, 29}, 2 },
};

static const int ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries_by_number[] = {
  0, // 1 -> NOT_SKIPPABLE
  1, // 2 -> SKIPPABLE_EMPTY_FETCH_HANDLER
};

const std::string& ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name(
    ServiceWorkerRegistrationData_FetchHandlerSkippableType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries,
          ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries_by_number,
          2, ServiceWorkerRegistrationData_FetchHandlerSkippableType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries,
      ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ServiceWorkerRegistrationData_FetchHandlerSkippableType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_FetchHandlerSkippableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_FetchHandlerSkippableType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ServiceWorkerRegistrationData_FetchHandlerSkippableType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::NOT_SKIPPABLE;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::SKIPPABLE_EMPTY_FETCH_HANDLER;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::FetchHandlerSkippableType_MIN;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::FetchHandlerSkippableType_MAX;
constexpr int ServiceWorkerRegistrationData::FetchHandlerSkippableType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ServiceWorkerOriginTrialFeature::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceWorkerOriginTrialFeature>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ServiceWorkerOriginTrialFeature::ServiceWorkerOriginTrialFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  tokens_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerOriginTrialFeature)
}
ServiceWorkerOriginTrialFeature::ServiceWorkerOriginTrialFeature(const ServiceWorkerOriginTrialFeature& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      tokens_(from.tokens_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerOriginTrialFeature)
}

inline void ServiceWorkerOriginTrialFeature::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerOriginTrialFeature::~ServiceWorkerOriginTrialFeature() {
  // @@protoc_insertion_point(destructor:storage.ServiceWorkerOriginTrialFeature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceWorkerOriginTrialFeature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void ServiceWorkerOriginTrialFeature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceWorkerOriginTrialFeature::Clear() {
// @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerOriginTrialFeature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tokens_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerOriginTrialFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string tokens = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tokens();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerOriginTrialFeature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerOriginTrialFeature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated string tokens = 2;
  for (int i = 0, n = this->_internal_tokens_size(); i < n; i++) {
    const auto& s = this->_internal_tokens(i);
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerOriginTrialFeature)
  return target;
}

size_t ServiceWorkerOriginTrialFeature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerOriginTrialFeature)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tokens = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tokens_.size());
  for (int i = 0, n = tokens_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      tokens_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceWorkerOriginTrialFeature::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceWorkerOriginTrialFeature*>(
      &from));
}

void ServiceWorkerOriginTrialFeature::MergeFrom(const ServiceWorkerOriginTrialFeature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerOriginTrialFeature)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  tokens_.MergeFrom(from.tokens_);
  if (from._internal_has_name()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerOriginTrialFeature::CopyFrom(const ServiceWorkerOriginTrialFeature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerOriginTrialFeature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceWorkerOriginTrialFeature::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ServiceWorkerOriginTrialFeature::InternalSwap(ServiceWorkerOriginTrialFeature* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tokens_.InternalSwap(&other->tokens_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string ServiceWorkerOriginTrialFeature::GetTypeName() const {
  return "storage.ServiceWorkerOriginTrialFeature";
}


// ===================================================================

class ServiceWorkerOriginTrialInfo::_Internal {
 public:
};

ServiceWorkerOriginTrialInfo::ServiceWorkerOriginTrialInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  features_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerOriginTrialInfo)
}
ServiceWorkerOriginTrialInfo::ServiceWorkerOriginTrialInfo(const ServiceWorkerOriginTrialInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      features_(from.features_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerOriginTrialInfo)
}

inline void ServiceWorkerOriginTrialInfo::SharedCtor() {
}

ServiceWorkerOriginTrialInfo::~ServiceWorkerOriginTrialInfo() {
  // @@protoc_insertion_point(destructor:storage.ServiceWorkerOriginTrialInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceWorkerOriginTrialInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerOriginTrialInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceWorkerOriginTrialInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerOriginTrialInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  features_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerOriginTrialInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_features(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerOriginTrialInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerOriginTrialInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_features_size()); i < n; i++) {
    const auto& repfield = this->_internal_features(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerOriginTrialInfo)
  return target;
}

size_t ServiceWorkerOriginTrialInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerOriginTrialInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
  total_size += 1UL * this->_internal_features_size();
  for (const auto& msg : this->features_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceWorkerOriginTrialInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceWorkerOriginTrialInfo*>(
      &from));
}

void ServiceWorkerOriginTrialInfo::MergeFrom(const ServiceWorkerOriginTrialInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerOriginTrialInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  features_.MergeFrom(from.features_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerOriginTrialInfo::CopyFrom(const ServiceWorkerOriginTrialInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerOriginTrialInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceWorkerOriginTrialInfo::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(features_))
    return false;
  return true;
}

void ServiceWorkerOriginTrialInfo::InternalSwap(ServiceWorkerOriginTrialInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  features_.InternalSwap(&other->features_);
}

std::string ServiceWorkerOriginTrialInfo::GetTypeName() const {
  return "storage.ServiceWorkerOriginTrialInfo";
}


// ===================================================================

class ServiceWorkerNavigationPreloadState::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceWorkerNavigationPreloadState>()._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

ServiceWorkerNavigationPreloadState::ServiceWorkerNavigationPreloadState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerNavigationPreloadState)
}
ServiceWorkerNavigationPreloadState::ServiceWorkerNavigationPreloadState(const ServiceWorkerNavigationPreloadState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  header_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    header_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_header()) {
    header_.Set(from._internal_header(), 
      GetArenaForAllocation());
  }
  enabled_ = from.enabled_;
  // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerNavigationPreloadState)
}

inline void ServiceWorkerNavigationPreloadState::SharedCtor() {
header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
enabled_ = false;
}

ServiceWorkerNavigationPreloadState::~ServiceWorkerNavigationPreloadState() {
  // @@protoc_insertion_point(destructor:storage.ServiceWorkerNavigationPreloadState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceWorkerNavigationPreloadState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  header_.Destroy();
}

void ServiceWorkerNavigationPreloadState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceWorkerNavigationPreloadState::Clear() {
// @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerNavigationPreloadState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    header_.ClearNonDefaultToEmpty();
  }
  enabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerNavigationPreloadState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string header = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_header();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerNavigationPreloadState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerNavigationPreloadState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  // optional string header = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_header(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerNavigationPreloadState)
  return target;
}

size_t ServiceWorkerNavigationPreloadState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerNavigationPreloadState)
  size_t total_size = 0;

  // required bool enabled = 1;
  if (_internal_has_enabled()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string header = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_header());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceWorkerNavigationPreloadState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceWorkerNavigationPreloadState*>(
      &from));
}

void ServiceWorkerNavigationPreloadState::MergeFrom(const ServiceWorkerNavigationPreloadState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerNavigationPreloadState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_header(from._internal_header());
    }
    if (cached_has_bits & 0x00000002u) {
      enabled_ = from.enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerNavigationPreloadState::CopyFrom(const ServiceWorkerNavigationPreloadState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerNavigationPreloadState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceWorkerNavigationPreloadState::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ServiceWorkerNavigationPreloadState::InternalSwap(ServiceWorkerNavigationPreloadState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &header_, lhs_arena,
      &other->header_, rhs_arena
  );
  swap(enabled_, other->enabled_);
}

std::string ServiceWorkerNavigationPreloadState::GetTypeName() const {
  return "storage.ServiceWorkerNavigationPreloadState";
}


// ===================================================================

class ServiceWorkerRegistrationData::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceWorkerRegistrationData>()._has_bits_);
  static void set_has_registration_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_scope_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_script_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_has_fetch_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fetch_handler_skippable_type(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_last_update_check_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_resources_total_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::storage::ServiceWorkerOriginTrialInfo& origin_trial_tokens(const ServiceWorkerRegistrationData* msg);
  static void set_has_origin_trial_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::storage::ServiceWorkerNavigationPreloadState& navigation_preload_state(const ServiceWorkerRegistrationData* msg);
  static void set_has_navigation_preload_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_update_via_cache(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_script_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_script_response_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_cross_origin_embedder_policy_value(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_cross_origin_embedder_policy_reporting_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cross_origin_embedder_policy_report_only_value(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_cross_origin_embedder_policy_report_only_reporting_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ancestor_frame_type(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000dc3) ^ 0x00000dc3) != 0;
  }
};

const ::storage::ServiceWorkerOriginTrialInfo&
ServiceWorkerRegistrationData::_Internal::origin_trial_tokens(const ServiceWorkerRegistrationData* msg) {
  return *msg->origin_trial_tokens_;
}
const ::storage::ServiceWorkerNavigationPreloadState&
ServiceWorkerRegistrationData::_Internal::navigation_preload_state(const ServiceWorkerRegistrationData* msg) {
  return *msg->navigation_preload_state_;
}
ServiceWorkerRegistrationData::ServiceWorkerRegistrationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  used_features_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData)
}
ServiceWorkerRegistrationData::ServiceWorkerRegistrationData(const ServiceWorkerRegistrationData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      used_features_(from.used_features_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  scope_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    scope_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_scope_url()) {
    scope_url_.Set(from._internal_scope_url(), 
      GetArenaForAllocation());
  }
  script_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    script_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_script_url()) {
    script_url_.Set(from._internal_script_url(), 
      GetArenaForAllocation());
  }
  cross_origin_embedder_policy_reporting_endpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cross_origin_embedder_policy_reporting_endpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cross_origin_embedder_policy_reporting_endpoint()) {
    cross_origin_embedder_policy_reporting_endpoint_.Set(from._internal_cross_origin_embedder_policy_reporting_endpoint(), 
      GetArenaForAllocation());
  }
  cross_origin_embedder_policy_report_only_reporting_endpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cross_origin_embedder_policy_report_only_reporting_endpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cross_origin_embedder_policy_report_only_reporting_endpoint()) {
    cross_origin_embedder_policy_report_only_reporting_endpoint_.Set(from._internal_cross_origin_embedder_policy_report_only_reporting_endpoint(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_origin_trial_tokens()) {
    origin_trial_tokens_ = new ::storage::ServiceWorkerOriginTrialInfo(*from.origin_trial_tokens_);
  } else {
    origin_trial_tokens_ = nullptr;
  }
  if (from._internal_has_navigation_preload_state()) {
    navigation_preload_state_ = new ::storage::ServiceWorkerNavigationPreloadState(*from.navigation_preload_state_);
  } else {
    navigation_preload_state_ = nullptr;
  }
  ::memcpy(&registration_id_, &from.registration_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&fetch_handler_skippable_type_) -
    reinterpret_cast<char*>(&registration_id_)) + sizeof(fetch_handler_skippable_type_));
  // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData)
}

inline void ServiceWorkerRegistrationData::SharedCtor() {
scope_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  scope_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
script_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  script_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cross_origin_embedder_policy_reporting_endpoint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cross_origin_embedder_policy_reporting_endpoint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cross_origin_embedder_policy_report_only_reporting_endpoint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cross_origin_embedder_policy_report_only_reporting_endpoint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_trial_tokens_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ancestor_frame_type_) -
    reinterpret_cast<char*>(&origin_trial_tokens_)) + sizeof(ancestor_frame_type_));
fetch_handler_skippable_type_ = 1;
}

ServiceWorkerRegistrationData::~ServiceWorkerRegistrationData() {
  // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceWorkerRegistrationData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  scope_url_.Destroy();
  script_url_.Destroy();
  cross_origin_embedder_policy_reporting_endpoint_.Destroy();
  cross_origin_embedder_policy_report_only_reporting_endpoint_.Destroy();
  if (this != internal_default_instance()) delete origin_trial_tokens_;
  if (this != internal_default_instance()) delete navigation_preload_state_;
}

void ServiceWorkerRegistrationData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceWorkerRegistrationData::Clear() {
// @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  used_features_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      scope_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      script_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      cross_origin_embedder_policy_reporting_endpoint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      cross_origin_embedder_policy_report_only_reporting_endpoint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(origin_trial_tokens_ != nullptr);
      origin_trial_tokens_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(navigation_preload_state_ != nullptr);
      navigation_preload_state_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&registration_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_id_) -
        reinterpret_cast<char*>(&registration_id_)) + sizeof(version_id_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&last_update_check_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cross_origin_embedder_policy_value_) -
        reinterpret_cast<char*>(&last_update_check_time_)) + sizeof(cross_origin_embedder_policy_value_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&cross_origin_embedder_policy_report_only_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ancestor_frame_type_) -
        reinterpret_cast<char*>(&cross_origin_embedder_policy_report_only_value_)) + sizeof(ancestor_frame_type_));
    fetch_handler_skippable_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 registration_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_registration_id(&has_bits);
          registration_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string scope_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_scope_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string script_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_script_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 version_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_version_id(&has_bits);
          version_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool is_active = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_active(&has_bits);
          is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool has_fetch_handler = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_has_fetch_handler(&has_bits);
          has_fetch_handler_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 last_update_check_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_last_update_check_time(&has_bits);
          last_update_check_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 resources_total_size_bytes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_resources_total_size_bytes(&has_bits);
          resources_total_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin_trial_tokens(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_navigation_preload_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 used_features = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_used_features(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_used_features(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(val))) {
            _internal_set_update_via_cache(static_cast<::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(val))) {
            _internal_set_script_type(static_cast<::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 script_response_time = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_script_response_time(&has_bits);
          script_response_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(val))) {
            _internal_set_cross_origin_embedder_policy_value(static_cast<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_cross_origin_embedder_policy_reporting_endpoint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(val))) {
            _internal_set_cross_origin_embedder_policy_report_only_value(static_cast<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_cross_origin_embedder_policy_report_only_reporting_endpoint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_AncestorFrameType_IsValid(val))) {
            _internal_set_ancestor_frame_type(static_cast<::storage::ServiceWorkerRegistrationData_AncestorFrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(val))) {
            _internal_set_fetch_handler_skippable_type(static_cast<::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 registration_id = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_registration_id(), target);
  }

  // required string scope_url = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_scope_url(), target);
  }

  // required string script_url = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_script_url(), target);
  }

  // required int64 version_id = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_version_id(), target);
  }

  // required bool is_active = 5;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_active(), target);
  }

  // required bool has_fetch_handler = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_has_fetch_handler(), target);
  }

  // required int64 last_update_check_time = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_last_update_check_time(), target);
  }

  // optional uint64 resources_total_size_bytes = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_resources_total_size_bytes(), target);
  }

  // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::origin_trial_tokens(this),
        _Internal::origin_trial_tokens(this).GetCachedSize(), target, stream);
  }

  // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::navigation_preload_state(this),
        _Internal::navigation_preload_state(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 used_features = 13;
  for (int i = 0, n = this->_internal_used_features_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_used_features(i), target);
  }

  // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_update_via_cache(), target);
  }

  // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      15, this->_internal_script_type(), target);
  }

  // optional int64 script_response_time = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(16, this->_internal_script_response_time(), target);
  }

  // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_cross_origin_embedder_policy_value(), target);
  }

  // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_cross_origin_embedder_policy_reporting_endpoint(), target);
  }

  // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_cross_origin_embedder_policy_report_only_value(), target);
  }

  // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_cross_origin_embedder_policy_report_only_reporting_endpoint(), target);
  }

  // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      21, this->_internal_ancestor_frame_type(), target);
  }

  // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      22, this->_internal_fetch_handler_skippable_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData)
  return target;
}

size_t ServiceWorkerRegistrationData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:storage.ServiceWorkerRegistrationData)
  size_t total_size = 0;

  if (_internal_has_scope_url()) {
    // required string scope_url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scope_url());
  }

  if (_internal_has_script_url()) {
    // required string script_url = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_script_url());
  }

  if (_internal_has_registration_id()) {
    // required int64 registration_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_registration_id());
  }

  if (_internal_has_version_id()) {
    // required int64 version_id = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version_id());
  }

  if (_internal_has_last_update_check_time()) {
    // required int64 last_update_check_time = 7;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_update_check_time());
  }

  if (_internal_has_is_active()) {
    // required bool is_active = 5;
    total_size += 1 + 1;
  }

  if (_internal_has_has_fetch_handler()) {
    // required bool has_fetch_handler = 6;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t ServiceWorkerRegistrationData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000dc3) ^ 0x00000dc3) == 0) {  // All required fields are present.
    // required string scope_url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scope_url());

    // required string script_url = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_script_url());

    // required int64 registration_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_registration_id());

    // required int64 version_id = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version_id());

    // required int64 last_update_check_time = 7;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_update_check_time());

    // required bool is_active = 5;
    total_size += 1 + 1;

    // required bool has_fetch_handler = 6;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 used_features = 13;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->used_features_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_used_features_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003cu) {
    // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cross_origin_embedder_policy_reporting_endpoint());
    }

    // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cross_origin_embedder_policy_report_only_reporting_endpoint());
    }

    // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_trial_tokens_);
    }

    // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *navigation_preload_state_);
    }

  }
  // optional uint64 resources_total_size_bytes = 8;
  if (cached_has_bits & 0x00000200u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resources_total_size_bytes());
  }

  if (cached_has_bits & 0x0000f000u) {
    // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_update_via_cache());
    }

    // optional int64 script_response_time = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_script_response_time());
    }

    // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_script_type());
    }

    // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cross_origin_embedder_policy_value());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cross_origin_embedder_policy_report_only_value());
    }

    // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ancestor_frame_type());
    }

    // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_fetch_handler_skippable_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceWorkerRegistrationData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData*>(
      &from));
}

void ServiceWorkerRegistrationData::MergeFrom(const ServiceWorkerRegistrationData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  used_features_.MergeFrom(from.used_features_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_scope_url(from._internal_scope_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_script_url(from._internal_script_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_cross_origin_embedder_policy_reporting_endpoint(from._internal_cross_origin_embedder_policy_reporting_endpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_cross_origin_embedder_policy_report_only_reporting_endpoint(from._internal_cross_origin_embedder_policy_report_only_reporting_endpoint());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_origin_trial_tokens()->::storage::ServiceWorkerOriginTrialInfo::MergeFrom(from._internal_origin_trial_tokens());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_navigation_preload_state()->::storage::ServiceWorkerNavigationPreloadState::MergeFrom(from._internal_navigation_preload_state());
    }
    if (cached_has_bits & 0x00000040u) {
      registration_id_ = from.registration_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      version_id_ = from.version_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      last_update_check_time_ = from.last_update_check_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      resources_total_size_bytes_ = from.resources_total_size_bytes_;
    }
    if (cached_has_bits & 0x00000400u) {
      is_active_ = from.is_active_;
    }
    if (cached_has_bits & 0x00000800u) {
      has_fetch_handler_ = from.has_fetch_handler_;
    }
    if (cached_has_bits & 0x00001000u) {
      update_via_cache_ = from.update_via_cache_;
    }
    if (cached_has_bits & 0x00002000u) {
      script_response_time_ = from.script_response_time_;
    }
    if (cached_has_bits & 0x00004000u) {
      script_type_ = from.script_type_;
    }
    if (cached_has_bits & 0x00008000u) {
      cross_origin_embedder_policy_value_ = from.cross_origin_embedder_policy_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      cross_origin_embedder_policy_report_only_value_ = from.cross_origin_embedder_policy_report_only_value_;
    }
    if (cached_has_bits & 0x00020000u) {
      ancestor_frame_type_ = from.ancestor_frame_type_;
    }
    if (cached_has_bits & 0x00040000u) {
      fetch_handler_skippable_type_ = from.fetch_handler_skippable_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData::CopyFrom(const ServiceWorkerRegistrationData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceWorkerRegistrationData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_origin_trial_tokens()) {
    if (!origin_trial_tokens_->IsInitialized()) return false;
  }
  if (_internal_has_navigation_preload_state()) {
    if (!navigation_preload_state_->IsInitialized()) return false;
  }
  return true;
}

void ServiceWorkerRegistrationData::InternalSwap(ServiceWorkerRegistrationData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  used_features_.InternalSwap(&other->used_features_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &scope_url_, lhs_arena,
      &other->scope_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &script_url_, lhs_arena,
      &other->script_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cross_origin_embedder_policy_reporting_endpoint_, lhs_arena,
      &other->cross_origin_embedder_policy_reporting_endpoint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cross_origin_embedder_policy_report_only_reporting_endpoint_, lhs_arena,
      &other->cross_origin_embedder_policy_report_only_reporting_endpoint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData, ancestor_frame_type_)
      + sizeof(ServiceWorkerRegistrationData::ancestor_frame_type_)
      - PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData, origin_trial_tokens_)>(
          reinterpret_cast<char*>(&origin_trial_tokens_),
          reinterpret_cast<char*>(&other->origin_trial_tokens_));
  swap(fetch_handler_skippable_type_, other->fetch_handler_skippable_type_);
}

std::string ServiceWorkerRegistrationData::GetTypeName() const {
  return "storage.ServiceWorkerRegistrationData";
}


// ===================================================================

class ServiceWorkerResourceRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<ServiceWorkerResourceRecord>()._has_bits_);
  static void set_has_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ServiceWorkerResourceRecord::ServiceWorkerResourceRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerResourceRecord)
}
ServiceWorkerResourceRecord::ServiceWorkerResourceRecord(const ServiceWorkerResourceRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  ::memcpy(&resource_id_, &from.resource_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&size_bytes_) -
    reinterpret_cast<char*>(&resource_id_)) + sizeof(size_bytes_));
  // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerResourceRecord)
}

inline void ServiceWorkerResourceRecord::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&resource_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&size_bytes_) -
    reinterpret_cast<char*>(&resource_id_)) + sizeof(size_bytes_));
}

ServiceWorkerResourceRecord::~ServiceWorkerResourceRecord() {
  // @@protoc_insertion_point(destructor:storage.ServiceWorkerResourceRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ServiceWorkerResourceRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void ServiceWorkerResourceRecord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceWorkerResourceRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerResourceRecord)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&resource_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&size_bytes_) -
        reinterpret_cast<char*>(&resource_id_)) + sizeof(size_bytes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerResourceRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 resource_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_resource_id(&has_bits);
          resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size_bytes(&has_bits);
          size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerResourceRecord::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerResourceRecord)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 resource_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_resource_id(), target);
  }

  // required string url = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // optional uint64 size_bytes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_size_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerResourceRecord)
  return target;
}

size_t ServiceWorkerResourceRecord::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:storage.ServiceWorkerResourceRecord)
  size_t total_size = 0;

  if (_internal_has_url()) {
    // required string url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (_internal_has_resource_id()) {
    // required int64 resource_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_resource_id());
  }

  return total_size;
}
size_t ServiceWorkerResourceRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerResourceRecord)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string url = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());

    // required int64 resource_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_resource_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 size_bytes = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size_bytes());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ServiceWorkerResourceRecord::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ServiceWorkerResourceRecord*>(
      &from));
}

void ServiceWorkerResourceRecord::MergeFrom(const ServiceWorkerResourceRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerResourceRecord)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      resource_id_ = from.resource_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      size_bytes_ = from.size_bytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerResourceRecord::CopyFrom(const ServiceWorkerResourceRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerResourceRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceWorkerResourceRecord::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ServiceWorkerResourceRecord::InternalSwap(ServiceWorkerResourceRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServiceWorkerResourceRecord, size_bytes_)
      + sizeof(ServiceWorkerResourceRecord::size_bytes_)
      - PROTOBUF_FIELD_OFFSET(ServiceWorkerResourceRecord, resource_id_)>(
          reinterpret_cast<char*>(&resource_id_),
          reinterpret_cast<char*>(&other->resource_id_));
}

std::string ServiceWorkerResourceRecord::GetTypeName() const {
  return "storage.ServiceWorkerResourceRecord";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace storage
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::storage::ServiceWorkerOriginTrialFeature*
Arena::CreateMaybeMessage< ::storage::ServiceWorkerOriginTrialFeature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage::ServiceWorkerOriginTrialFeature >(arena);
}
template<> PROTOBUF_NOINLINE ::storage::ServiceWorkerOriginTrialInfo*
Arena::CreateMaybeMessage< ::storage::ServiceWorkerOriginTrialInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage::ServiceWorkerOriginTrialInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::storage::ServiceWorkerNavigationPreloadState*
Arena::CreateMaybeMessage< ::storage::ServiceWorkerNavigationPreloadState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage::ServiceWorkerNavigationPreloadState >(arena);
}
template<> PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData*
Arena::CreateMaybeMessage< ::storage::ServiceWorkerRegistrationData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage::ServiceWorkerRegistrationData >(arena);
}
template<> PROTOBUF_NOINLINE ::storage::ServiceWorkerResourceRecord*
Arena::CreateMaybeMessage< ::storage::ServiceWorkerResourceRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::storage::ServiceWorkerResourceRecord >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
