// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/action_strategy.proto

#include "components/autofill_assistant/browser/action_strategy.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
}  // namespace autofill_assistant
namespace autofill_assistant {
bool KeyboardValueFillStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KeyboardValueFillStrategy_strings[5] = {};

static const char KeyboardValueFillStrategy_names[] =
  "SET_VALUE"
  "SIMULATE_KEY_PRESSES"
  "SIMULATE_KEY_PRESSES_FOCUS"
  "SIMULATE_KEY_PRESSES_SELECT_VALUE"
  "UNSPECIFIED_KEYBAORD_STRATEGY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KeyboardValueFillStrategy_entries[] = {
  { {KeyboardValueFillStrategy_names + 0, 9}, 1 },
  { {KeyboardValueFillStrategy_names + 9, 20}, 2 },
  { {KeyboardValueFillStrategy_names + 29, 26}, 4 },
  { {KeyboardValueFillStrategy_names + 55, 33}, 3 },
  { {KeyboardValueFillStrategy_names + 88, 29}, 0 },
};

static const int KeyboardValueFillStrategy_entries_by_number[] = {
  4, // 0 -> UNSPECIFIED_KEYBAORD_STRATEGY
  0, // 1 -> SET_VALUE
  1, // 2 -> SIMULATE_KEY_PRESSES
  3, // 3 -> SIMULATE_KEY_PRESSES_SELECT_VALUE
  2, // 4 -> SIMULATE_KEY_PRESSES_FOCUS
};

const std::string& KeyboardValueFillStrategy_Name(
    KeyboardValueFillStrategy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KeyboardValueFillStrategy_entries,
          KeyboardValueFillStrategy_entries_by_number,
          5, KeyboardValueFillStrategy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KeyboardValueFillStrategy_entries,
      KeyboardValueFillStrategy_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KeyboardValueFillStrategy_strings[idx].get();
}
bool KeyboardValueFillStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyboardValueFillStrategy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KeyboardValueFillStrategy_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<KeyboardValueFillStrategy>(int_value);
  }
  return success;
}
bool DropdownSelectStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DropdownSelectStrategy_strings[4] = {};

static const char DropdownSelectStrategy_names[] =
  "LABEL_MATCH"
  "LABEL_STARTS_WITH"
  "UNSPECIFIED_SELECT_STRATEGY"
  "VALUE_MATCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DropdownSelectStrategy_entries[] = {
  { {DropdownSelectStrategy_names + 0, 11}, 2 },
  { {DropdownSelectStrategy_names + 11, 17}, 3 },
  { {DropdownSelectStrategy_names + 28, 27}, 0 },
  { {DropdownSelectStrategy_names + 55, 11}, 1 },
};

static const int DropdownSelectStrategy_entries_by_number[] = {
  2, // 0 -> UNSPECIFIED_SELECT_STRATEGY
  3, // 1 -> VALUE_MATCH
  0, // 2 -> LABEL_MATCH
  1, // 3 -> LABEL_STARTS_WITH
};

const std::string& DropdownSelectStrategy_Name(
    DropdownSelectStrategy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DropdownSelectStrategy_entries,
          DropdownSelectStrategy_entries_by_number,
          4, DropdownSelectStrategy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DropdownSelectStrategy_entries,
      DropdownSelectStrategy_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DropdownSelectStrategy_strings[idx].get();
}
bool DropdownSelectStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DropdownSelectStrategy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DropdownSelectStrategy_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DropdownSelectStrategy>(int_value);
  }
  return success;
}
bool ClickType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClickType_strings[4] = {};

static const char ClickType_names[] =
  "CLICK"
  "JAVASCRIPT"
  "NOT_SET"
  "TAP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClickType_entries[] = {
  { {ClickType_names + 0, 5}, 3 },
  { {ClickType_names + 5, 10}, 2 },
  { {ClickType_names + 15, 7}, 0 },
  { {ClickType_names + 22, 3}, 1 },
};

static const int ClickType_entries_by_number[] = {
  2, // 0 -> NOT_SET
  3, // 1 -> TAP
  1, // 2 -> JAVASCRIPT
  0, // 3 -> CLICK
};

const std::string& ClickType_Name(
    ClickType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClickType_entries,
          ClickType_entries_by_number,
          4, ClickType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClickType_entries,
      ClickType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClickType_strings[idx].get();
}
bool ClickType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClickType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClickType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClickType>(int_value);
  }
  return success;
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
