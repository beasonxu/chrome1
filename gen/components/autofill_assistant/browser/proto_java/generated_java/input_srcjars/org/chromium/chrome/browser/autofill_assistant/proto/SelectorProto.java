// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/service.proto

package org.chromium.chrome.browser.autofill_assistant.proto;

/**
 * <pre>
 * A reference to one or more elements on the page, possibly nested in frames.
 * Next ID: 12
 * </pre>
 *
 * Protobuf type {@code autofill_assistant.SelectorProto}
 */
public  final class SelectorProto extends
    com.google.protobuf.GeneratedMessageLite<
        SelectorProto, SelectorProto.Builder> implements
    // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto)
    SelectorProtoOrBuilder {
  private SelectorProto() {
    filters_ = emptyProtobufList();
  }
  public interface FilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.Filter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     * @return Whether the enterFrame field is set.
     */
    boolean hasEnterFrame();
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     * @return The enterFrame.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getEnterFrame();

    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return Whether the cssSelector field is set.
     */
    boolean hasCssSelector();
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The cssSelector.
     */
    java.lang.String getCssSelector();
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The bytes for cssSelector.
     */
    com.google.protobuf.ByteString
        getCssSelectorBytes();

    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     * @return Whether the innerText field is set.
     */
    boolean hasInnerText();
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     * @return The innerText.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getInnerText();

    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     * @return The value.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getValue();

    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return Whether the pseudoType field is set.
     */
    boolean hasPseudoType();
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return The pseudoType.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType();

    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     * @return Whether the boundingBox field is set.
     */
    boolean hasBoundingBox();
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     * @return The boundingBox.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getBoundingBox();

    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     * @return Whether the nthMatch field is set.
     */
    boolean hasNthMatch();
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     * @return The nthMatch.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getNthMatch();

    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     * @return Whether the pseudoElementContent field is set.
     */
    boolean hasPseudoElementContent();
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     * @return The pseudoElementContent.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getPseudoElementContent();

    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     * @return Whether the labelled field is set.
     */
    boolean hasLabelled();
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     * @return The labelled.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getLabelled();

    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return Whether the matchCssSelector field is set.
     */
    boolean hasMatchCssSelector();
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The matchCssSelector.
     */
    java.lang.String getMatchCssSelector();
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The bytes for matchCssSelector.
     */
    com.google.protobuf.ByteString
        getMatchCssSelectorBytes();

    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     * @return Whether the cssStyle field is set.
     */
    boolean hasCssStyle();
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     * @return The cssStyle.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getCssStyle();

    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     * @return Whether the onTop field is set.
     */
    boolean hasOnTop();
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     * @return The onTop.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getOnTop();

    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     * @return Whether the property field is set.
     */
    boolean hasProperty();
    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     * @return The property.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter getProperty();

    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     * @return Whether the parent field is set.
     */
    boolean hasParent();
    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     * @return The parent.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getParent();

    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     * @return Whether the semantic field is set.
     */
    boolean hasSemantic();
    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     * @return The semantic.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter getSemantic();

    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.FilterCase getFilterCase();
  }
  /**
   * <pre>
   * A filter that starts with one or more elements and returns one on more
   * elements. Filters are meant to be applied sequentially.
   * The returned elements will be sorted by their order in the document.
   * Elements that were matched via the labelled filter will have the same order
   * as their label.
   * Next ID: 17
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.Filter}
   */
  public  static final class Filter extends
      com.google.protobuf.GeneratedMessageLite<
          Filter, Filter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.Filter)
      FilterOrBuilder {
    private Filter() {
    }
    private int bitField0_;
    private int filterCase_ = 0;
    private java.lang.Object filter_;
    public enum FilterCase {
      ENTER_FRAME(1),
      CSS_SELECTOR(2),
      INNER_TEXT(3),
      VALUE(4),
      PSEUDO_TYPE(5),
      BOUNDING_BOX(6),
      NTH_MATCH(7),
      PSEUDO_ELEMENT_CONTENT(8),
      LABELLED(9),
      MATCH_CSS_SELECTOR(11),
      CSS_STYLE(12),
      ON_TOP(13),
      PROPERTY(14),
      PARENT(15),
      SEMANTIC(16),
      FILTER_NOT_SET(0);
      private final int value;
      private FilterCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FilterCase valueOf(int value) {
        return forNumber(value);
      }

      public static FilterCase forNumber(int value) {
        switch (value) {
          case 1: return ENTER_FRAME;
          case 2: return CSS_SELECTOR;
          case 3: return INNER_TEXT;
          case 4: return VALUE;
          case 5: return PSEUDO_TYPE;
          case 6: return BOUNDING_BOX;
          case 7: return NTH_MATCH;
          case 8: return PSEUDO_ELEMENT_CONTENT;
          case 9: return LABELLED;
          case 11: return MATCH_CSS_SELECTOR;
          case 12: return CSS_STYLE;
          case 13: return ON_TOP;
          case 14: return PROPERTY;
          case 15: return PARENT;
          case 16: return SEMANTIC;
          case 0: return FILTER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public FilterCase
    getFilterCase() {
      return FilterCase.forNumber(
          filterCase_);
    }

    private void clearFilter() {
      filterCase_ = 0;
      filter_ = null;
    }

    public static final int ENTER_FRAME_FIELD_NUMBER = 1;
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    @java.lang.Override
    public boolean hasEnterFrame() {
      return filterCase_ == 1;
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getEnterFrame() {
      if (filterCase_ == 1) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    private void setEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 1;
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    private void mergeEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  if (filterCase_ == 1 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 1;
    }
    /**
     * <pre>
     * Enter the document of an iframe or shadow root. The next filters apply
     * to the document inside of the iframe(s) or on the shadow element.
     * Fails if there are more than one match.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
     */
    private void clearEnterFrame() {
      if (filterCase_ == 1) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int CSS_SELECTOR_FIELD_NUMBER = 2;
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return Whether the cssSelector field is set.
     */
    @java.lang.Override
    public boolean hasCssSelector() {
      return filterCase_ == 2;
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The cssSelector.
     */
    @java.lang.Override
    public java.lang.String getCssSelector() {
      java.lang.String ref = "";
      if (filterCase_ == 2) {
        ref = (java.lang.String) filter_;
      }
      return ref;
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @return The bytes for cssSelector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getCssSelectorBytes() {
      java.lang.String ref = "";
      if (filterCase_ == 2) {
        ref = (java.lang.String) filter_;
      }
      return com.google.protobuf.ByteString.copyFromUtf8(ref);
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @param value The cssSelector to set.
     */
    private void setCssSelector(
        java.lang.String value) {
      value.getClass();
  filterCase_ = 2;
      filter_ = value;
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     */
    private void clearCssSelector() {
      if (filterCase_ == 2) {
        filterCase_ = 0;
        filter_ = null;
      }
    }
    /**
     * <pre>
     * Evaluate the given CSS selector on all start elements and use
     * the result as end elements.
     * </pre>
     *
     * <code>string css_selector = 2;</code>
     * @param value The bytes for cssSelector to set.
     */
    private void setCssSelectorBytes(
        com.google.protobuf.ByteString value) {
      filter_ = value.toStringUtf8();
      filterCase_ = 2;
    }

    public static final int INNER_TEXT_FIELD_NUMBER = 3;
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     */
    @java.lang.Override
    public boolean hasInnerText() {
      return filterCase_ == 3;
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getInnerText() {
      if (filterCase_ == 3) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.TextFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     */
    private void setInnerText(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 3;
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     */
    private void mergeInnerText(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  if (filterCase_ == 3 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.TextFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 3;
    }
    /**
     * <pre>
     * Check the inner text of all start elements, using the Javascript
     * innerText property. Keep only the element whose innerText match the
     * given regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
     */
    private void clearInnerText() {
      if (filterCase_ == 3) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 4;
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     */
    @java.lang.Override
    public boolean hasValue() {
      return filterCase_ == 4;
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getValue() {
      if (filterCase_ == 4) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.TextFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     */
    private void setValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 4;
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     */
    private void mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  if (filterCase_ == 4 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.TextFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 4;
    }
    /**
     * <pre>
     * Check the value of all start elements, using the Javascript value
     * property. Keep only the element whose value property match the given
     * regular expression.
     * </pre>
     *
     * <code>.autofill_assistant.TextFilter value = 4;</code>
     */
    private void clearValue() {
      if (filterCase_ == 4) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int PSEUDO_TYPE_FIELD_NUMBER = 5;
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return Whether the pseudoType field is set.
     */
    @java.lang.Override
    public boolean hasPseudoType() {
      return filterCase_ == 5;
    }
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @return The pseudoType.
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
      if (filterCase_ == 5) {
        org.chromium.chrome.browser.autofill_assistant.proto.PseudoType result = org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.forNumber((java.lang.Integer) filter_);
        return result == null ? org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.UNDEFINED : result;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.UNDEFINED;
    }
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     * @param value The pseudoType to set.
     */
    private void setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
      filter_ = value.getNumber();
      filterCase_ = 5;
    }
    /**
     * <pre>
     * Select the pseudo-element of the given type associated with the current
     * elements.
     * </pre>
     *
     * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
     */
    private void clearPseudoType() {
      if (filterCase_ == 5) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int BOUNDING_BOX_FIELD_NUMBER = 6;
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    @java.lang.Override
    public boolean hasBoundingBox() {
      return filterCase_ == 6;
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getBoundingBox() {
      if (filterCase_ == 6) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    private void setBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 6;
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    private void mergeBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
      value.getClass();
  if (filterCase_ == 6 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 6;
    }
    /**
     * <pre>
     * Only keep elements that have a box model, even if it is empty.
     * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
     * renamed as having a bounding box is not enough to imply visibility.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
     */
    private void clearBoundingBox() {
      if (filterCase_ == 6) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int NTH_MATCH_FIELD_NUMBER = 7;
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    @java.lang.Override
    public boolean hasNthMatch() {
      return filterCase_ == 7;
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getNthMatch() {
      if (filterCase_ == 7) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    private void setNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 7;
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    private void mergeNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
      value.getClass();
  if (filterCase_ == 7 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 7;
    }
    /**
     * <pre>
     * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
     * not enough matches.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
     */
    private void clearNthMatch() {
      if (filterCase_ == 7) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int PSEUDO_ELEMENT_CONTENT_FIELD_NUMBER = 8;
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    @java.lang.Override
    public boolean hasPseudoElementContent() {
      return filterCase_ == 8;
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getPseudoElementContent() {
      if (filterCase_ == 8) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.getDefaultInstance();
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    private void setPseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 8;
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    private void mergePseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
      value.getClass();
  if (filterCase_ == 8 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 8;
    }
    /**
     * <pre>
     * Only keep elements that have a pseudo-element with the given content.
     * This only works with BEFORE and AFTER.
     * Note that this just filters out elements. It doesn't select the
     * pseudo-element; use pseudo_type for that.
     * Deprecated: prefer css_style. This should be removed in Chrome M89.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
     */
    private void clearPseudoElementContent() {
      if (filterCase_ == 8) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int LABELLED_FIELD_NUMBER = 9;
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    @java.lang.Override
    public boolean hasLabelled() {
      return filterCase_ == 9;
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getLabelled() {
      if (filterCase_ == 9) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    private void setLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 9;
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    private void mergeLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  if (filterCase_ == 9 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 9;
    }
    /**
     * <pre>
     * Go from label to the labelled control. Only works starting with current
     * elements that are LABEL.
     * For example if we have:
     *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
     * then labelled, goes from the label to the form element.
     * So, the form element can be accessed as "label~=/FirstName/ labelled".
     * This is especially useful in situations where someid can change.
     * The same selector also works in the case where the element is inside of
     * the label, so we don't need to worry which implementation is used when
     * building the selector:
     *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
     */
    private void clearLabelled() {
      if (filterCase_ == 9) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int MATCH_CSS_SELECTOR_FIELD_NUMBER = 11;
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return Whether the matchCssSelector field is set.
     */
    @java.lang.Override
    public boolean hasMatchCssSelector() {
      return filterCase_ == 11;
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The matchCssSelector.
     */
    @java.lang.Override
    public java.lang.String getMatchCssSelector() {
      java.lang.String ref = "";
      if (filterCase_ == 11) {
        ref = (java.lang.String) filter_;
      }
      return ref;
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @return The bytes for matchCssSelector.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getMatchCssSelectorBytes() {
      java.lang.String ref = "";
      if (filterCase_ == 11) {
        ref = (java.lang.String) filter_;
      }
      return com.google.protobuf.ByteString.copyFromUtf8(ref);
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @param value The matchCssSelector to set.
     */
    private void setMatchCssSelector(
        java.lang.String value) {
      value.getClass();
  filterCase_ = 11;
      filter_ = value;
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     */
    private void clearMatchCssSelector() {
      if (filterCase_ == 11) {
        filterCase_ = 0;
        filter_ = null;
      }
    }
    /**
     * <pre>
     * Only keep results that match the given CSS selector.
     * </pre>
     *
     * <code>string match_css_selector = 11;</code>
     * @param value The bytes for matchCssSelector to set.
     */
    private void setMatchCssSelectorBytes(
        com.google.protobuf.ByteString value) {
      filter_ = value.toStringUtf8();
      filterCase_ = 11;
    }

    public static final int CSS_STYLE_FIELD_NUMBER = 12;
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    @java.lang.Override
    public boolean hasCssStyle() {
      return filterCase_ == 12;
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getCssStyle() {
      if (filterCase_ == 12) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    private void setCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 12;
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    private void mergeCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
      value.getClass();
  if (filterCase_ == 12 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 12;
    }
    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
     */
    private void clearCssStyle() {
      if (filterCase_ == 12) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int ON_TOP_FIELD_NUMBER = 13;
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    @java.lang.Override
    public boolean hasOnTop() {
      return filterCase_ == 13;
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getOnTop() {
      if (filterCase_ == 13) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    private void setOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 13;
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    private void mergeOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
      value.getClass();
  if (filterCase_ == 13 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 13;
    }
    /**
     * <pre>
     * Filter out elements whose center point are covered by another element.
     * This first calls Element.scrollIntoViewIfNeeded to make sure the
     * element can be moved to the viewport, then calls
     * DocumentOrShadowDom.getElementFromPoint and compares the result with
     * the expected element. If the element at point is not the element, a
     * descendant of the element or a label of the element, there is an
     * overlay.
     * Note that:
     * - this filter will also weed out elements with no bounding box. Check
     * with bounding_box { } first.
     * - this filter will also weed out elements that cannot be scrolled into
     * the viewport.
     * - an element might be covered by an overlay and still be visible if the
     * overlay is transparent. An element might be covered by an overlay and
     * still be clickable, if the overlay intercepts and forwards events.
     * Overlays with pointer-events set to none are ignored.
     * - an element might be only partially covered by an overlay. This filter
     * only checks the center of the element, since this is where the click
     * action sends its clicks or taps.
     * - this filter only detects overlays in the current frame. To detect
     * overlays that cover the frame element itself, apply this filter on the
     * frame element before calling enter_frame.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
     */
    private void clearOnTop() {
      if (filterCase_ == 13) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int PROPERTY_FIELD_NUMBER = 14;
    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     */
    @java.lang.Override
    public boolean hasProperty() {
      return filterCase_ == 14;
    }
    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter getProperty() {
      if (filterCase_ == 14) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     */
    private void setProperty(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 14;
    }
    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     */
    private void mergeProperty(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter value) {
      value.getClass();
  if (filterCase_ == 14 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 14;
    }
    /**
     * <pre>
     * Filtering against an element property.
     * This filter replaces |inner_text| and |value|.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
     */
    private void clearProperty() {
      if (filterCase_ == 14) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int PARENT_FIELD_NUMBER = 15;
    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     */
    @java.lang.Override
    public boolean hasParent() {
      return filterCase_ == 15;
    }
    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getParent() {
      if (filterCase_ == 15) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     */
    private void setParent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 15;
    }
    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     */
    private void mergeParent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
      value.getClass();
  if (filterCase_ == 15 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 15;
    }
    /**
     * <pre>
     * Retrieve parent of current elements.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
     */
    private void clearParent() {
      if (filterCase_ == 15) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static final int SEMANTIC_FIELD_NUMBER = 16;
    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     */
    @java.lang.Override
    public boolean hasSemantic() {
      return filterCase_ == 16;
    }
    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter getSemantic() {
      if (filterCase_ == 16) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter) filter_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.getDefaultInstance();
    }
    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     */
    private void setSemantic(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter value) {
      value.getClass();
  filter_ = value;
      filterCase_ = 16;
    }
    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     */
    private void mergeSemantic(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter value) {
      value.getClass();
  if (filterCase_ == 16 &&
          filter_ != org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.getDefaultInstance()) {
        filter_ = org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter) filter_)
            .mergeFrom(value).buildPartial();
      } else {
        filter_ = value;
      }
      filterCase_ = 16;
    }
    /**
     * <pre>
     * Run the ML model over extracted node signals and retrieve a matching
     * result.
     * TODO(b/233340267): By convention this must be the first filter in the
     * list. It can be followed by any set of other filters.
     * TODO(b/233340267): The filter only supports returning a single element,
     * although that element can have any number of children. Should it find
     * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
     * error.
     * </pre>
     *
     * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
     */
    private void clearSemantic() {
      if (filterCase_ == 16) {
        filterCase_ = 0;
        filter_ = null;
      }
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A filter that starts with one or more elements and returns one on more
     * elements. Filters are meant to be applied sequentially.
     * The returned elements will be sorted by their order in the document.
     * Elements that were matched via the labelled filter will have the same order
     * as their label.
     * Next ID: 17
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.Filter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.Filter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public FilterCase
          getFilterCase() {
        return instance.getFilterCase();
      }

      public Builder clearFilter() {
        copyOnWrite();
        instance.clearFilter();
        return this;
      }


      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      @java.lang.Override
      public boolean hasEnterFrame() {
        return instance.hasEnterFrame();
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getEnterFrame() {
        return instance.getEnterFrame();
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder setEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.setEnterFrame(value);
        return this;
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder setEnterFrame(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setEnterFrame(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder mergeEnterFrame(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.mergeEnterFrame(value);
        return this;
      }
      /**
       * <pre>
       * Enter the document of an iframe or shadow root. The next filters apply
       * to the document inside of the iframe(s) or on the shadow element.
       * Fails if there are more than one match.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;</code>
       */
      public Builder clearEnterFrame() {
        copyOnWrite();
        instance.clearEnterFrame();
        return this;
      }

      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return Whether the cssSelector field is set.
       */
      @java.lang.Override
      public boolean hasCssSelector() {
        return instance.hasCssSelector();
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return The cssSelector.
       */
      @java.lang.Override
      public java.lang.String getCssSelector() {
        return instance.getCssSelector();
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return The bytes for cssSelector.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCssSelectorBytes() {
        return instance.getCssSelectorBytes();
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @param value The cssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setCssSelector(
          java.lang.String value) {
        copyOnWrite();
        instance.setCssSelector(value);
        return this;
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearCssSelector() {
        copyOnWrite();
        instance.clearCssSelector();
        return this;
      }
      /**
       * <pre>
       * Evaluate the given CSS selector on all start elements and use
       * the result as end elements.
       * </pre>
       *
       * <code>string css_selector = 2;</code>
       * @param value The bytes for cssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setCssSelectorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCssSelectorBytes(value);
        return this;
      }

      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
       */
      @java.lang.Override
      public boolean hasInnerText() {
        return instance.hasInnerText();
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getInnerText() {
        return instance.getInnerText();
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
       */
      public Builder setInnerText(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.setInnerText(value);
        return this;
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
       */
      public Builder setInnerText(
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setInnerText(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
       */
      public Builder mergeInnerText(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.mergeInnerText(value);
        return this;
      }
      /**
       * <pre>
       * Check the inner text of all start elements, using the Javascript
       * innerText property. Keep only the element whose innerText match the
       * given regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter inner_text = 3;</code>
       */
      public Builder clearInnerText() {
        copyOnWrite();
        instance.clearInnerText();
        return this;
      }

      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter value = 4;</code>
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter value = 4;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter value = 4;</code>
       */
      public Builder setValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter value = 4;</code>
       */
      public Builder setValue(
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setValue(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter value = 4;</code>
       */
      public Builder mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.mergeValue(value);
        return this;
      }
      /**
       * <pre>
       * Check the value of all start elements, using the Javascript value
       * property. Keep only the element whose value property match the given
       * regular expression.
       * </pre>
       *
       * <code>.autofill_assistant.TextFilter value = 4;</code>
       */
      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }

      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @return Whether the pseudoType field is set.
       */
      @java.lang.Override
      public boolean hasPseudoType() {
        return instance.hasPseudoType();
      }
      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @return The pseudoType.
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
        return instance.getPseudoType();
      }
      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @param value The pseudoType to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
        copyOnWrite();
        instance.setPseudoType(value);
        return this;
      }
      /**
       * <pre>
       * Select the pseudo-element of the given type associated with the current
       * elements.
       * </pre>
       *
       * <code>.autofill_assistant.PseudoType pseudo_type = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearPseudoType() {
        copyOnWrite();
        instance.clearPseudoType();
        return this;
      }

      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      @java.lang.Override
      public boolean hasBoundingBox() {
        return instance.hasBoundingBox();
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getBoundingBox() {
        return instance.getBoundingBox();
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder setBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
        copyOnWrite();
        instance.setBoundingBox(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder setBoundingBox(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setBoundingBox(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder mergeBoundingBox(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter value) {
        copyOnWrite();
        instance.mergeBoundingBox(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a box model, even if it is empty.
       * This is the equivalent of the old MUST_BE_VISIBLE flag. It's been
       * renamed as having a bounding box is not enough to imply visibility.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;</code>
       */
      public Builder clearBoundingBox() {
        copyOnWrite();
        instance.clearBoundingBox();
        return this;
      }

      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      @java.lang.Override
      public boolean hasNthMatch() {
        return instance.hasNthMatch();
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getNthMatch() {
        return instance.getNthMatch();
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder setNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
        copyOnWrite();
        instance.setNthMatch(value);
        return this;
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder setNthMatch(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setNthMatch(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder mergeNthMatch(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter value) {
        copyOnWrite();
        instance.mergeNthMatch(value);
        return this;
      }
      /**
       * <pre>
       * Take the nth match. Fails with ELEMENT_RESOLUTION_FAILED if there are
       * not enough matches.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;</code>
       */
      public Builder clearNthMatch() {
        copyOnWrite();
        instance.clearNthMatch();
        return this;
      }

      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      @java.lang.Override
      public boolean hasPseudoElementContent() {
        return instance.hasPseudoElementContent();
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getPseudoElementContent() {
        return instance.getPseudoElementContent();
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder setPseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
        copyOnWrite();
        instance.setPseudoElementContent(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder setPseudoElementContent(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.Builder builderForValue) {
        copyOnWrite();
        instance.setPseudoElementContent(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder mergePseudoElementContent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent value) {
        copyOnWrite();
        instance.mergePseudoElementContent(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements that have a pseudo-element with the given content.
       * This only works with BEFORE and AFTER.
       * Note that this just filters out elements. It doesn't select the
       * pseudo-element; use pseudo_type for that.
       * Deprecated: prefer css_style. This should be removed in Chrome M89.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;</code>
       */
      public Builder clearPseudoElementContent() {
        copyOnWrite();
        instance.clearPseudoElementContent();
        return this;
      }

      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      @java.lang.Override
      public boolean hasLabelled() {
        return instance.hasLabelled();
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getLabelled() {
        return instance.getLabelled();
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder setLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.setLabelled(value);
        return this;
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder setLabelled(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setLabelled(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder mergeLabelled(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.mergeLabelled(value);
        return this;
      }
      /**
       * <pre>
       * Go from label to the labelled control. Only works starting with current
       * elements that are LABEL.
       * For example if we have:
       *  &lt;label for="someid"&gt;First Name&lt;/label&gt;...&lt;input id="someid" ...&gt;
       * then labelled, goes from the label to the form element.
       * So, the form element can be accessed as "label~=/FirstName/ labelled".
       * This is especially useful in situations where someid can change.
       * The same selector also works in the case where the element is inside of
       * the label, so we don't need to worry which implementation is used when
       * building the selector:
       *   &lt;label&gt;First Name &lt;input ...&gt;&lt;/label&gt;
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter labelled = 9;</code>
       */
      public Builder clearLabelled() {
        copyOnWrite();
        instance.clearLabelled();
        return this;
      }

      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return Whether the matchCssSelector field is set.
       */
      @java.lang.Override
      public boolean hasMatchCssSelector() {
        return instance.hasMatchCssSelector();
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return The matchCssSelector.
       */
      @java.lang.Override
      public java.lang.String getMatchCssSelector() {
        return instance.getMatchCssSelector();
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return The bytes for matchCssSelector.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getMatchCssSelectorBytes() {
        return instance.getMatchCssSelectorBytes();
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @param value The matchCssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setMatchCssSelector(
          java.lang.String value) {
        copyOnWrite();
        instance.setMatchCssSelector(value);
        return this;
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearMatchCssSelector() {
        copyOnWrite();
        instance.clearMatchCssSelector();
        return this;
      }
      /**
       * <pre>
       * Only keep results that match the given CSS selector.
       * </pre>
       *
       * <code>string match_css_selector = 11;</code>
       * @param value The bytes for matchCssSelector to set.
       * @return This builder for chaining.
       */
      public Builder setMatchCssSelectorBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMatchCssSelectorBytes(value);
        return this;
      }

      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      @java.lang.Override
      public boolean hasCssStyle() {
        return instance.hasCssStyle();
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getCssStyle() {
        return instance.getCssStyle();
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder setCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
        copyOnWrite();
        instance.setCssStyle(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder setCssStyle(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setCssStyle(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder mergeCssStyle(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter value) {
        copyOnWrite();
        instance.mergeCssStyle(value);
        return this;
      }
      /**
       * <pre>
       * Only keep elements whose computed style match the given filter. This is
       * based on Window.computedStyle()
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;</code>
       */
      public Builder clearCssStyle() {
        copyOnWrite();
        instance.clearCssStyle();
        return this;
      }

      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      @java.lang.Override
      public boolean hasOnTop() {
        return instance.hasOnTop();
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getOnTop() {
        return instance.getOnTop();
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder setOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
        copyOnWrite();
        instance.setOnTop(value);
        return this;
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder setOnTop(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setOnTop(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder mergeOnTop(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter value) {
        copyOnWrite();
        instance.mergeOnTop(value);
        return this;
      }
      /**
       * <pre>
       * Filter out elements whose center point are covered by another element.
       * This first calls Element.scrollIntoViewIfNeeded to make sure the
       * element can be moved to the viewport, then calls
       * DocumentOrShadowDom.getElementFromPoint and compares the result with
       * the expected element. If the element at point is not the element, a
       * descendant of the element or a label of the element, there is an
       * overlay.
       * Note that:
       * - this filter will also weed out elements with no bounding box. Check
       * with bounding_box { } first.
       * - this filter will also weed out elements that cannot be scrolled into
       * the viewport.
       * - an element might be covered by an overlay and still be visible if the
       * overlay is transparent. An element might be covered by an overlay and
       * still be clickable, if the overlay intercepts and forwards events.
       * Overlays with pointer-events set to none are ignored.
       * - an element might be only partially covered by an overlay. This filter
       * only checks the center of the element, since this is where the click
       * action sends its clicks or taps.
       * - this filter only detects overlays in the current frame. To detect
       * overlays that cover the frame element itself, apply this filter on the
       * frame element before calling enter_frame.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.OnTopFilter on_top = 13;</code>
       */
      public Builder clearOnTop() {
        copyOnWrite();
        instance.clearOnTop();
        return this;
      }

      /**
       * <pre>
       * Filtering against an element property.
       * This filter replaces |inner_text| and |value|.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
       */
      @java.lang.Override
      public boolean hasProperty() {
        return instance.hasProperty();
      }
      /**
       * <pre>
       * Filtering against an element property.
       * This filter replaces |inner_text| and |value|.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter getProperty() {
        return instance.getProperty();
      }
      /**
       * <pre>
       * Filtering against an element property.
       * This filter replaces |inner_text| and |value|.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
       */
      public Builder setProperty(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter value) {
        copyOnWrite();
        instance.setProperty(value);
        return this;
      }
      /**
       * <pre>
       * Filtering against an element property.
       * This filter replaces |inner_text| and |value|.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
       */
      public Builder setProperty(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setProperty(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Filtering against an element property.
       * This filter replaces |inner_text| and |value|.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
       */
      public Builder mergeProperty(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter value) {
        copyOnWrite();
        instance.mergeProperty(value);
        return this;
      }
      /**
       * <pre>
       * Filtering against an element property.
       * This filter replaces |inner_text| and |value|.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.PropertyFilter property = 14;</code>
       */
      public Builder clearProperty() {
        copyOnWrite();
        instance.clearProperty();
        return this;
      }

      /**
       * <pre>
       * Retrieve parent of current elements.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
       */
      @java.lang.Override
      public boolean hasParent() {
        return instance.hasParent();
      }
      /**
       * <pre>
       * Retrieve parent of current elements.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getParent() {
        return instance.getParent();
      }
      /**
       * <pre>
       * Retrieve parent of current elements.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
       */
      public Builder setParent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.setParent(value);
        return this;
      }
      /**
       * <pre>
       * Retrieve parent of current elements.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
       */
      public Builder setParent(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setParent(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Retrieve parent of current elements.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
       */
      public Builder mergeParent(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter value) {
        copyOnWrite();
        instance.mergeParent(value);
        return this;
      }
      /**
       * <pre>
       * Retrieve parent of current elements.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.EmptyFilter parent = 15;</code>
       */
      public Builder clearParent() {
        copyOnWrite();
        instance.clearParent();
        return this;
      }

      /**
       * <pre>
       * Run the ML model over extracted node signals and retrieve a matching
       * result.
       * TODO(b/233340267): By convention this must be the first filter in the
       * list. It can be followed by any set of other filters.
       * TODO(b/233340267): The filter only supports returning a single element,
       * although that element can have any number of children. Should it find
       * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
       * error.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
       */
      @java.lang.Override
      public boolean hasSemantic() {
        return instance.hasSemantic();
      }
      /**
       * <pre>
       * Run the ML model over extracted node signals and retrieve a matching
       * result.
       * TODO(b/233340267): By convention this must be the first filter in the
       * list. It can be followed by any set of other filters.
       * TODO(b/233340267): The filter only supports returning a single element,
       * although that element can have any number of children. Should it find
       * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
       * error.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter getSemantic() {
        return instance.getSemantic();
      }
      /**
       * <pre>
       * Run the ML model over extracted node signals and retrieve a matching
       * result.
       * TODO(b/233340267): By convention this must be the first filter in the
       * list. It can be followed by any set of other filters.
       * TODO(b/233340267): The filter only supports returning a single element,
       * although that element can have any number of children. Should it find
       * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
       * error.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
       */
      public Builder setSemantic(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter value) {
        copyOnWrite();
        instance.setSemantic(value);
        return this;
      }
      /**
       * <pre>
       * Run the ML model over extracted node signals and retrieve a matching
       * result.
       * TODO(b/233340267): By convention this must be the first filter in the
       * list. It can be followed by any set of other filters.
       * TODO(b/233340267): The filter only supports returning a single element,
       * although that element can have any number of children. Should it find
       * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
       * error.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
       */
      public Builder setSemantic(
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setSemantic(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Run the ML model over extracted node signals and retrieve a matching
       * result.
       * TODO(b/233340267): By convention this must be the first filter in the
       * list. It can be followed by any set of other filters.
       * TODO(b/233340267): The filter only supports returning a single element,
       * although that element can have any number of children. Should it find
       * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
       * error.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
       */
      public Builder mergeSemantic(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter value) {
        copyOnWrite();
        instance.mergeSemantic(value);
        return this;
      }
      /**
       * <pre>
       * Run the ML model over extracted node signals and retrieve a matching
       * result.
       * TODO(b/233340267): By convention this must be the first filter in the
       * list. It can be followed by any set of other filters.
       * TODO(b/233340267): The filter only supports returning a single element,
       * although that element can have any number of children. Should it find
       * multiple elements, the Selector will return a |TOO_MANY_ELEMENTS|
       * error.
       * </pre>
       *
       * <code>.autofill_assistant.SelectorProto.SemanticFilter semantic = 16;</code>
       */
      public Builder clearSemantic() {
        copyOnWrite();
        instance.clearSemantic();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.Filter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "filter_",
              "filterCase_",
              "bitField0_",
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.internalGetVerifier(),
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.class,
            };
            java.lang.String info =
                "\u0001\u000f\u0001\u0001\u0001\u0010\u000f\u0000\u0000\u0000\u0001\u103c\u0000\u0002" +
                "\u103b\u0000\u0003\u103c\u0000\u0004\u103c\u0000\u0005\u103f\u0000\u0006\u103c\u0000" +
                "\u0007\u103c\u0000\b\u103c\u0000\t\u103c\u0000\u000b\u103b\u0000\f\u103c\u0000\r" +
                "\u103c\u0000\u000e\u103c\u0000\u000f\u103c\u0000\u0010\u103c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.Filter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter DEFAULT_INSTANCE;
    static {
      Filter defaultInstance = new Filter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Filter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Filter> PARSER;

    public static com.google.protobuf.Parser<Filter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PropertyFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.PropertyFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @return Whether the property field is set.
     */
    boolean hasProperty();
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @return The property.
     */
    java.lang.String getProperty();
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @return The bytes for property.
     */
    com.google.protobuf.ByteString
        getPropertyBytes();

    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     * @return Whether the textFilter field is set.
     */
    boolean hasTextFilter();
    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     * @return The textFilter.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getTextFilter();

    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     * @return Whether the autofillValueRegexp field is set.
     */
    boolean hasAutofillValueRegexp();
    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     * @return The autofillValueRegexp.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp getAutofillValueRegexp();

    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.ValueCase getValueCase();
  }
  /**
   * <pre>
   * A regular expression value for filtering.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.PropertyFilter}
   */
  public  static final class PropertyFilter extends
      com.google.protobuf.GeneratedMessageLite<
          PropertyFilter, PropertyFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.PropertyFilter)
      PropertyFilterOrBuilder {
    private PropertyFilter() {
      property_ = "";
    }
    private int bitField0_;
    private int valueCase_ = 0;
    private java.lang.Object value_;
    public enum ValueCase {
      TEXT_FILTER(2),
      AUTOFILL_VALUE_REGEXP(3),
      VALUE_NOT_SET(0);
      private final int value;
      private ValueCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ValueCase valueOf(int value) {
        return forNumber(value);
      }

      public static ValueCase forNumber(int value) {
        switch (value) {
          case 2: return TEXT_FILTER;
          case 3: return AUTOFILL_VALUE_REGEXP;
          case 0: return VALUE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    @java.lang.Override
    public ValueCase
    getValueCase() {
      return ValueCase.forNumber(
          valueCase_);
    }

    private void clearValue() {
      valueCase_ = 0;
      value_ = null;
    }

    public static final int PROPERTY_FIELD_NUMBER = 1;
    private java.lang.String property_;
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @return Whether the property field is set.
     */
    @java.lang.Override
    public boolean hasProperty() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @return The property.
     */
    @java.lang.Override
    public java.lang.String getProperty() {
      return property_;
    }
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @return The bytes for property.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPropertyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(property_);
    }
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @param value The property to set.
     */
    private void setProperty(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      property_ = value;
    }
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     */
    private void clearProperty() {
      bitField0_ = (bitField0_ & ~0x00000001);
      property_ = getDefaultInstance().getProperty();
    }
    /**
     * <pre>
     * The property to filter against.
     * </pre>
     *
     * <code>optional string property = 1;</code>
     * @param value The bytes for property to set.
     */
    private void setPropertyBytes(
        com.google.protobuf.ByteString value) {
      property_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int TEXT_FILTER_FIELD_NUMBER = 2;
    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     */
    @java.lang.Override
    public boolean hasTextFilter() {
      return valueCase_ == 2;
    }
    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getTextFilter() {
      if (valueCase_ == 2) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.TextFilter) value_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance();
    }
    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     */
    private void setTextFilter(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  value_ = value;
      valueCase_ = 2;
    }
    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     */
    private void mergeTextFilter(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  if (valueCase_ == 2 &&
          value_ != org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance()) {
        value_ = org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.TextFilter) value_)
            .mergeFrom(value).buildPartial();
      } else {
        value_ = value;
      }
      valueCase_ = 2;
    }
    /**
     * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
     */
    private void clearTextFilter() {
      if (valueCase_ == 2) {
        valueCase_ = 0;
        value_ = null;
      }
    }

    public static final int AUTOFILL_VALUE_REGEXP_FIELD_NUMBER = 3;
    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     */
    @java.lang.Override
    public boolean hasAutofillValueRegexp() {
      return valueCase_ == 3;
    }
    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp getAutofillValueRegexp() {
      if (valueCase_ == 3) {
         return (org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp) value_;
      }
      return org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp.getDefaultInstance();
    }
    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     */
    private void setAutofillValueRegexp(org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp value) {
      value.getClass();
  value_ = value;
      valueCase_ = 3;
    }
    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     */
    private void mergeAutofillValueRegexp(org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp value) {
      value.getClass();
  if (valueCase_ == 3 &&
          value_ != org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp.getDefaultInstance()) {
        value_ = org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp.newBuilder((org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp) value_)
            .mergeFrom(value).buildPartial();
      } else {
        value_ = value;
      }
      valueCase_ = 3;
    }
    /**
     * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
     */
    private void clearAutofillValueRegexp() {
      if (valueCase_ == 3) {
        valueCase_ = 0;
        value_ = null;
      }
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A regular expression value for filtering.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.PropertyFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.PropertyFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      @java.lang.Override
      public ValueCase
          getValueCase() {
        return instance.getValueCase();
      }

      public Builder clearValue() {
        copyOnWrite();
        instance.clearValue();
        return this;
      }


      /**
       * <pre>
       * The property to filter against.
       * </pre>
       *
       * <code>optional string property = 1;</code>
       * @return Whether the property field is set.
       */
      @java.lang.Override
      public boolean hasProperty() {
        return instance.hasProperty();
      }
      /**
       * <pre>
       * The property to filter against.
       * </pre>
       *
       * <code>optional string property = 1;</code>
       * @return The property.
       */
      @java.lang.Override
      public java.lang.String getProperty() {
        return instance.getProperty();
      }
      /**
       * <pre>
       * The property to filter against.
       * </pre>
       *
       * <code>optional string property = 1;</code>
       * @return The bytes for property.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPropertyBytes() {
        return instance.getPropertyBytes();
      }
      /**
       * <pre>
       * The property to filter against.
       * </pre>
       *
       * <code>optional string property = 1;</code>
       * @param value The property to set.
       * @return This builder for chaining.
       */
      public Builder setProperty(
          java.lang.String value) {
        copyOnWrite();
        instance.setProperty(value);
        return this;
      }
      /**
       * <pre>
       * The property to filter against.
       * </pre>
       *
       * <code>optional string property = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearProperty() {
        copyOnWrite();
        instance.clearProperty();
        return this;
      }
      /**
       * <pre>
       * The property to filter against.
       * </pre>
       *
       * <code>optional string property = 1;</code>
       * @param value The bytes for property to set.
       * @return This builder for chaining.
       */
      public Builder setPropertyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPropertyBytes(value);
        return this;
      }

      /**
       * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
       */
      @java.lang.Override
      public boolean hasTextFilter() {
        return instance.hasTextFilter();
      }
      /**
       * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getTextFilter() {
        return instance.getTextFilter();
      }
      /**
       * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
       */
      public Builder setTextFilter(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.setTextFilter(value);
        return this;
      }
      /**
       * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
       */
      public Builder setTextFilter(
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setTextFilter(builderForValue.build());
        return this;
      }
      /**
       * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
       */
      public Builder mergeTextFilter(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.mergeTextFilter(value);
        return this;
      }
      /**
       * <code>.autofill_assistant.TextFilter text_filter = 2;</code>
       */
      public Builder clearTextFilter() {
        copyOnWrite();
        instance.clearTextFilter();
        return this;
      }

      /**
       * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
       */
      @java.lang.Override
      public boolean hasAutofillValueRegexp() {
        return instance.hasAutofillValueRegexp();
      }
      /**
       * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp getAutofillValueRegexp() {
        return instance.getAutofillValueRegexp();
      }
      /**
       * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
       */
      public Builder setAutofillValueRegexp(org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp value) {
        copyOnWrite();
        instance.setAutofillValueRegexp(value);
        return this;
      }
      /**
       * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
       */
      public Builder setAutofillValueRegexp(
          org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp.Builder builderForValue) {
        copyOnWrite();
        instance.setAutofillValueRegexp(builderForValue.build());
        return this;
      }
      /**
       * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
       */
      public Builder mergeAutofillValueRegexp(org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp value) {
        copyOnWrite();
        instance.mergeAutofillValueRegexp(value);
        return this;
      }
      /**
       * <code>.autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;</code>
       */
      public Builder clearAutofillValueRegexp() {
        copyOnWrite();
        instance.clearAutofillValueRegexp();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.PropertyFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "value_",
              "valueCase_",
              "bitField0_",
              "property_",
              org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.class,
              org.chromium.chrome.browser.autofill_assistant.proto.AutofillValueRegexp.class,
            };
            java.lang.String info =
                "\u0001\u0003\u0001\u0001\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u1008\u0000\u0002" +
                "\u103c\u0000\u0003\u103c\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.PropertyFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter DEFAULT_INSTANCE;
    static {
      PropertyFilter defaultInstance = new PropertyFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PropertyFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PropertyFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PropertyFilter> PARSER;

    public static com.google.protobuf.Parser<PropertyFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PseudoElementContentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.PseudoElementContent)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return Whether the pseudoType field is set.
     */
    boolean hasPseudoType();
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return The pseudoType.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType();

    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     * @return Whether the content field is set.
     */
    boolean hasContent();
    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     * @return The content.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getContent();
  }
  /**
   * <pre>
   * A way of filtering elements by their pseudo-element content.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.PseudoElementContent}
   */
  public  static final class PseudoElementContent extends
      com.google.protobuf.GeneratedMessageLite<
          PseudoElementContent, PseudoElementContent.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.PseudoElementContent)
      PseudoElementContentOrBuilder {
    private PseudoElementContent() {
    }
    private int bitField0_;
    public static final int PSEUDO_TYPE_FIELD_NUMBER = 1;
    private int pseudoType_;
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return Whether the pseudoType field is set.
     */
    @java.lang.Override
    public boolean hasPseudoType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @return The pseudoType.
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
      org.chromium.chrome.browser.autofill_assistant.proto.PseudoType result = org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.forNumber(pseudoType_);
      return result == null ? org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.UNDEFINED : result;
    }
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     * @param value The pseudoType to set.
     */
    private void setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
      pseudoType_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
     */
    private void clearPseudoType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      pseudoType_ = 0;
    }

    public static final int CONTENT_FIELD_NUMBER = 2;
    private org.chromium.chrome.browser.autofill_assistant.proto.TextFilter content_;
    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     */
    @java.lang.Override
    public boolean hasContent() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getContent() {
      return content_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance() : content_;
    }
    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     */
    private void setContent(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  content_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeContent(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  if (content_ != null &&
          content_ != org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance()) {
        content_ =
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.newBuilder(content_).mergeFrom(value).buildPartial();
      } else {
        content_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <code>optional .autofill_assistant.TextFilter content = 2;</code>
     */
    private void clearContent() {  content_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * A way of filtering elements by their pseudo-element content.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.PseudoElementContent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.PseudoElementContent)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContentOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @return Whether the pseudoType field is set.
       */
      @java.lang.Override
      public boolean hasPseudoType() {
        return instance.hasPseudoType();
      }
      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @return The pseudoType.
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.PseudoType getPseudoType() {
        return instance.getPseudoType();
      }
      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @param value The enum numeric value on the wire for pseudoType to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoType(org.chromium.chrome.browser.autofill_assistant.proto.PseudoType value) {
        copyOnWrite();
        instance.setPseudoType(value);
        return this;
      }
      /**
       * <code>optional .autofill_assistant.PseudoType pseudo_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPseudoType() {
        copyOnWrite();
        instance.clearPseudoType();
        return this;
      }

      /**
       * <code>optional .autofill_assistant.TextFilter content = 2;</code>
       */
      @java.lang.Override
      public boolean hasContent() {
        return instance.hasContent();
      }
      /**
       * <code>optional .autofill_assistant.TextFilter content = 2;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getContent() {
        return instance.getContent();
      }
      /**
       * <code>optional .autofill_assistant.TextFilter content = 2;</code>
       */
      public Builder setContent(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.setContent(value);
        return this;
        }
      /**
       * <code>optional .autofill_assistant.TextFilter content = 2;</code>
       */
      public Builder setContent(
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setContent(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .autofill_assistant.TextFilter content = 2;</code>
       */
      public Builder mergeContent(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.mergeContent(value);
        return this;
      }
      /**
       * <code>optional .autofill_assistant.TextFilter content = 2;</code>
       */
      public Builder clearContent() {  copyOnWrite();
        instance.clearContent();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.PseudoElementContent)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "pseudoType_",
              org.chromium.chrome.browser.autofill_assistant.proto.PseudoType.internalGetVerifier(),
              "content_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u100c\u0000\u0002" +
                "\u1009\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.PseudoElementContent)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent DEFAULT_INSTANCE;
    static {
      PseudoElementContent defaultInstance = new PseudoElementContent();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PseudoElementContent.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.PseudoElementContent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PseudoElementContent> PARSER;

    public static com.google.protobuf.Parser<PseudoElementContent> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface CssStyleFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.CssStyleFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return Whether the property field is set.
     */
    boolean hasProperty();
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The property.
     */
    java.lang.String getProperty();
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The bytes for property.
     */
    com.google.protobuf.ByteString
        getPropertyBytes();

    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return Whether the pseudoElement field is set.
     */
    boolean hasPseudoElement();
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The pseudoElement.
     */
    java.lang.String getPseudoElement();
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The bytes for pseudoElement.
     */
    com.google.protobuf.ByteString
        getPseudoElementBytes();

    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return Whether the shouldMatch field is set.
     */
    boolean hasShouldMatch();
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return The shouldMatch.
     */
    boolean getShouldMatch();

    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     * @return The value.
     */
    org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getValue();
  }
  /**
   * <pre>
   * Only keep elements whose computed style match the given filter. This is
   * based on Window.computedStyle()
   * See
   * https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.CssStyleFilter}
   */
  public  static final class CssStyleFilter extends
      com.google.protobuf.GeneratedMessageLite<
          CssStyleFilter, CssStyleFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.CssStyleFilter)
      CssStyleFilterOrBuilder {
    private CssStyleFilter() {
      property_ = "";
      pseudoElement_ = "";
      shouldMatch_ = true;
    }
    private int bitField0_;
    public static final int PROPERTY_FIELD_NUMBER = 3;
    private java.lang.String property_;
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return Whether the property field is set.
     */
    @java.lang.Override
    public boolean hasProperty() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The property.
     */
    @java.lang.Override
    public java.lang.String getProperty() {
      return property_;
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @return The bytes for property.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPropertyBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(property_);
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @param value The property to set.
     */
    private void setProperty(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000001;
      property_ = value;
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     */
    private void clearProperty() {
      bitField0_ = (bitField0_ & ~0x00000001);
      property_ = getDefaultInstance().getProperty();
    }
    /**
     * <pre>
     * CSS property name.
     * </pre>
     *
     * <code>optional string property = 3;</code>
     * @param value The bytes for property to set.
     */
    private void setPropertyBytes(
        com.google.protobuf.ByteString value) {
      property_ = value.toStringUtf8();
      bitField0_ |= 0x00000001;
    }

    public static final int PSEUDO_ELEMENT_FIELD_NUMBER = 4;
    private java.lang.String pseudoElement_;
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return Whether the pseudoElement field is set.
     */
    @java.lang.Override
    public boolean hasPseudoElement() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The pseudoElement.
     */
    @java.lang.Override
    public java.lang.String getPseudoElement() {
      return pseudoElement_;
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @return The bytes for pseudoElement.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPseudoElementBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(pseudoElement_);
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @param value The pseudoElement to set.
     */
    private void setPseudoElement(
        java.lang.String value) {
      value.getClass();
  bitField0_ |= 0x00000002;
      pseudoElement_ = value;
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     */
    private void clearPseudoElement() {
      bitField0_ = (bitField0_ & ~0x00000002);
      pseudoElement_ = getDefaultInstance().getPseudoElement();
    }
    /**
     * <pre>
     * Name of the pseudo-element whose style should be checked. Leave it unset
     * or set to the empty string to check the style of the real element.
     * This is the pseudoElt argument of JavaScript's
     * window.getComputedStyle(element, [, pseudoElt]).
     * </pre>
     *
     * <code>optional string pseudo_element = 4;</code>
     * @param value The bytes for pseudoElement to set.
     */
    private void setPseudoElementBytes(
        com.google.protobuf.ByteString value) {
      pseudoElement_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int SHOULD_MATCH_FIELD_NUMBER = 5;
    private boolean shouldMatch_;
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return Whether the shouldMatch field is set.
     */
    @java.lang.Override
    public boolean hasShouldMatch() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @return The shouldMatch.
     */
    @java.lang.Override
    public boolean getShouldMatch() {
      return shouldMatch_;
    }
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     * @param value The shouldMatch to set.
     */
    private void setShouldMatch(boolean value) {
      bitField0_ |= 0x00000004;
      shouldMatch_ = value;
    }
    /**
     * <pre>
     * By default the text filter in |value| must match. Set this to false to
     * require the text condition not to match.
     * </pre>
     *
     * <code>optional bool should_match = 5 [default = true];</code>
     */
    private void clearShouldMatch() {
      bitField0_ = (bitField0_ & ~0x00000004);
      shouldMatch_ = true;
    }

    public static final int VALUE_FIELD_NUMBER = 6;
    private org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value_;
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getValue() {
      return value_ == null ? org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance() : value_;
    }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     */
    private void setValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  value_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
      value.getClass();
  if (value_ != null &&
          value_ != org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.getDefaultInstance()) {
        value_ =
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.newBuilder(value_).mergeFrom(value).buildPartial();
      } else {
        value_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <pre>
     * CSS property value match.
     * Valid computed CSS properties always have a value, even if it's a default
     * value. The default value depends on the property.
     * </pre>
     *
     * <code>optional .autofill_assistant.TextFilter value = 6;</code>
     */
    private void clearValue() {  value_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Only keep elements whose computed style match the given filter. This is
     * based on Window.computedStyle()
     * See
     * https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.CssStyleFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.CssStyleFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return Whether the property field is set.
       */
      @java.lang.Override
      public boolean hasProperty() {
        return instance.hasProperty();
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return The property.
       */
      @java.lang.Override
      public java.lang.String getProperty() {
        return instance.getProperty();
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return The bytes for property.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPropertyBytes() {
        return instance.getPropertyBytes();
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @param value The property to set.
       * @return This builder for chaining.
       */
      public Builder setProperty(
          java.lang.String value) {
        copyOnWrite();
        instance.setProperty(value);
        return this;
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearProperty() {
        copyOnWrite();
        instance.clearProperty();
        return this;
      }
      /**
       * <pre>
       * CSS property name.
       * </pre>
       *
       * <code>optional string property = 3;</code>
       * @param value The bytes for property to set.
       * @return This builder for chaining.
       */
      public Builder setPropertyBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPropertyBytes(value);
        return this;
      }

      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return Whether the pseudoElement field is set.
       */
      @java.lang.Override
      public boolean hasPseudoElement() {
        return instance.hasPseudoElement();
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return The pseudoElement.
       */
      @java.lang.Override
      public java.lang.String getPseudoElement() {
        return instance.getPseudoElement();
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return The bytes for pseudoElement.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getPseudoElementBytes() {
        return instance.getPseudoElementBytes();
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @param value The pseudoElement to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoElement(
          java.lang.String value) {
        copyOnWrite();
        instance.setPseudoElement(value);
        return this;
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearPseudoElement() {
        copyOnWrite();
        instance.clearPseudoElement();
        return this;
      }
      /**
       * <pre>
       * Name of the pseudo-element whose style should be checked. Leave it unset
       * or set to the empty string to check the style of the real element.
       * This is the pseudoElt argument of JavaScript's
       * window.getComputedStyle(element, [, pseudoElt]).
       * </pre>
       *
       * <code>optional string pseudo_element = 4;</code>
       * @param value The bytes for pseudoElement to set.
       * @return This builder for chaining.
       */
      public Builder setPseudoElementBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPseudoElementBytes(value);
        return this;
      }

      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @return Whether the shouldMatch field is set.
       */
      @java.lang.Override
      public boolean hasShouldMatch() {
        return instance.hasShouldMatch();
      }
      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @return The shouldMatch.
       */
      @java.lang.Override
      public boolean getShouldMatch() {
        return instance.getShouldMatch();
      }
      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @param value The shouldMatch to set.
       * @return This builder for chaining.
       */
      public Builder setShouldMatch(boolean value) {
        copyOnWrite();
        instance.setShouldMatch(value);
        return this;
      }
      /**
       * <pre>
       * By default the text filter in |value| must match. Set this to false to
       * require the text condition not to match.
       * </pre>
       *
       * <code>optional bool should_match = 5 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearShouldMatch() {
        copyOnWrite();
        instance.clearShouldMatch();
        return this;
      }

      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.TextFilter value = 6;</code>
       */
      @java.lang.Override
      public boolean hasValue() {
        return instance.hasValue();
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.TextFilter value = 6;</code>
       */
      @java.lang.Override
      public org.chromium.chrome.browser.autofill_assistant.proto.TextFilter getValue() {
        return instance.getValue();
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.TextFilter value = 6;</code>
       */
      public Builder setValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.setValue(value);
        return this;
        }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.TextFilter value = 6;</code>
       */
      public Builder setValue(
          org.chromium.chrome.browser.autofill_assistant.proto.TextFilter.Builder builderForValue) {
        copyOnWrite();
        instance.setValue(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.TextFilter value = 6;</code>
       */
      public Builder mergeValue(org.chromium.chrome.browser.autofill_assistant.proto.TextFilter value) {
        copyOnWrite();
        instance.mergeValue(value);
        return this;
      }
      /**
       * <pre>
       * CSS property value match.
       * Valid computed CSS properties always have a value, even if it's a default
       * value. The default value depends on the property.
       * </pre>
       *
       * <code>optional .autofill_assistant.TextFilter value = 6;</code>
       */
      public Builder clearValue() {  copyOnWrite();
        instance.clearValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.CssStyleFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "property_",
              "pseudoElement_",
              "shouldMatch_",
              "value_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0003\u0006\u0004\u0000\u0000\u0000\u0003\u1008\u0000\u0004" +
                "\u1008\u0001\u0005\u1007\u0002\u0006\u1009\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.CssStyleFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter DEFAULT_INSTANCE;
    static {
      CssStyleFilter defaultInstance = new CssStyleFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CssStyleFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.CssStyleFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CssStyleFilter> PARSER;

    public static com.google.protobuf.Parser<CssStyleFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface BoundingBoxFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.BoundingBoxFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return Whether the requireNonempty field is set.
     */
    boolean hasRequireNonempty();
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return The requireNonempty.
     */
    boolean getRequireNonempty();
  }
  /**
   * <pre>
   * Only keep elements that have a bounding box.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.BoundingBoxFilter}
   */
  public  static final class BoundingBoxFilter extends
      com.google.protobuf.GeneratedMessageLite<
          BoundingBoxFilter, BoundingBoxFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.BoundingBoxFilter)
      BoundingBoxFilterOrBuilder {
    private BoundingBoxFilter() {
    }
    private int bitField0_;
    public static final int REQUIRE_NONEMPTY_FIELD_NUMBER = 1;
    private boolean requireNonempty_;
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return Whether the requireNonempty field is set.
     */
    @java.lang.Override
    public boolean hasRequireNonempty() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @return The requireNonempty.
     */
    @java.lang.Override
    public boolean getRequireNonempty() {
      return requireNonempty_;
    }
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     * @param value The requireNonempty to set.
     */
    private void setRequireNonempty(boolean value) {
      bitField0_ |= 0x00000001;
      requireNonempty_ = value;
    }
    /**
     * <pre>
     * If require_nonempty=false, which is the default, require elements to have
     * at least one bounding rect returned by Element.getClientRects()
     * If require_nonempty=true, additionally require the element's bounding
     * client rect to have a nonzero width and height.
     * </pre>
     *
     * <code>optional bool require_nonempty = 1;</code>
     */
    private void clearRequireNonempty() {
      bitField0_ = (bitField0_ & ~0x00000001);
      requireNonempty_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Only keep elements that have a bounding box.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.BoundingBoxFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.BoundingBoxFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @return Whether the requireNonempty field is set.
       */
      @java.lang.Override
      public boolean hasRequireNonempty() {
        return instance.hasRequireNonempty();
      }
      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @return The requireNonempty.
       */
      @java.lang.Override
      public boolean getRequireNonempty() {
        return instance.getRequireNonempty();
      }
      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @param value The requireNonempty to set.
       * @return This builder for chaining.
       */
      public Builder setRequireNonempty(boolean value) {
        copyOnWrite();
        instance.setRequireNonempty(value);
        return this;
      }
      /**
       * <pre>
       * If require_nonempty=false, which is the default, require elements to have
       * at least one bounding rect returned by Element.getClientRects()
       * If require_nonempty=true, additionally require the element's bounding
       * client rect to have a nonzero width and height.
       * </pre>
       *
       * <code>optional bool require_nonempty = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRequireNonempty() {
        copyOnWrite();
        instance.clearRequireNonempty();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.BoundingBoxFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "requireNonempty_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u1007\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.BoundingBoxFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter DEFAULT_INSTANCE;
    static {
      BoundingBoxFilter defaultInstance = new BoundingBoxFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        BoundingBoxFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.BoundingBoxFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<BoundingBoxFilter> PARSER;

    public static com.google.protobuf.Parser<BoundingBoxFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface OnTopFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.OnTopFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return Whether the scrollIntoViewIfNeeded field is set.
     */
    boolean hasScrollIntoViewIfNeeded();
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return The scrollIntoViewIfNeeded.
     */
    boolean getScrollIntoViewIfNeeded();

    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return Whether the acceptElementIfNotInView field is set.
     */
    boolean hasAcceptElementIfNotInView();
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return The acceptElementIfNotInView.
     */
    boolean getAcceptElementIfNotInView();
  }
  /**
   * <pre>
   * Filter out elements covered by other elements, such as overlays.
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto.OnTopFilter}
   */
  public  static final class OnTopFilter extends
      com.google.protobuf.GeneratedMessageLite<
          OnTopFilter, OnTopFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.OnTopFilter)
      OnTopFilterOrBuilder {
    private OnTopFilter() {
      scrollIntoViewIfNeeded_ = true;
    }
    private int bitField0_;
    public static final int SCROLL_INTO_VIEW_IF_NEEDED_FIELD_NUMBER = 1;
    private boolean scrollIntoViewIfNeeded_;
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return Whether the scrollIntoViewIfNeeded field is set.
     */
    @java.lang.Override
    public boolean hasScrollIntoViewIfNeeded() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @return The scrollIntoViewIfNeeded.
     */
    @java.lang.Override
    public boolean getScrollIntoViewIfNeeded() {
      return scrollIntoViewIfNeeded_;
    }
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     * @param value The scrollIntoViewIfNeeded to set.
     */
    private void setScrollIntoViewIfNeeded(boolean value) {
      bitField0_ |= 0x00000001;
      scrollIntoViewIfNeeded_ = value;
    }
    /**
     * <pre>
     * If true, scroll the element into view before checking whether
     * it's on top.
     * The logic for checking whether an element is on top only works on
     * elements that are positioned within the current viewport. Setting it to
     * false turns off automatic scrolling to make the element visible, so the
     * caller must make sure it's already the case.
     * </pre>
     *
     * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
     */
    private void clearScrollIntoViewIfNeeded() {
      bitField0_ = (bitField0_ & ~0x00000001);
      scrollIntoViewIfNeeded_ = true;
    }

    public static final int ACCEPT_ELEMENT_IF_NOT_IN_VIEW_FIELD_NUMBER = 2;
    private boolean acceptElementIfNotInView_;
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return Whether the acceptElementIfNotInView field is set.
     */
    @java.lang.Override
    public boolean hasAcceptElementIfNotInView() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @return The acceptElementIfNotInView.
     */
    @java.lang.Override
    public boolean getAcceptElementIfNotInView() {
      return acceptElementIfNotInView_;
    }
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     * @param value The acceptElementIfNotInView to set.
     */
    private void setAcceptElementIfNotInView(boolean value) {
      bitField0_ |= 0x00000002;
      acceptElementIfNotInView_ = value;
    }
    /**
     * <pre>
     * If true and the element cannot be scrolled into view, so the filter
     * cannot check whether the element is on top, keep the element in the match
     * set.
     * This can be combined with scroll_into_view_if_needed=false to make
     * this filter best effort and only check elements that are already in view.
     * </pre>
     *
     * <code>optional bool accept_element_if_not_in_view = 2;</code>
     */
    private void clearAcceptElementIfNotInView() {
      bitField0_ = (bitField0_ & ~0x00000002);
      acceptElementIfNotInView_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Filter out elements covered by other elements, such as overlays.
     * </pre>
     *
     * Protobuf type {@code autofill_assistant.SelectorProto.OnTopFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.OnTopFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @return Whether the scrollIntoViewIfNeeded field is set.
       */
      @java.lang.Override
      public boolean hasScrollIntoViewIfNeeded() {
        return instance.hasScrollIntoViewIfNeeded();
      }
      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @return The scrollIntoViewIfNeeded.
       */
      @java.lang.Override
      public boolean getScrollIntoViewIfNeeded() {
        return instance.getScrollIntoViewIfNeeded();
      }
      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @param value The scrollIntoViewIfNeeded to set.
       * @return This builder for chaining.
       */
      public Builder setScrollIntoViewIfNeeded(boolean value) {
        copyOnWrite();
        instance.setScrollIntoViewIfNeeded(value);
        return this;
      }
      /**
       * <pre>
       * If true, scroll the element into view before checking whether
       * it's on top.
       * The logic for checking whether an element is on top only works on
       * elements that are positioned within the current viewport. Setting it to
       * false turns off automatic scrolling to make the element visible, so the
       * caller must make sure it's already the case.
       * </pre>
       *
       * <code>optional bool scroll_into_view_if_needed = 1 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearScrollIntoViewIfNeeded() {
        copyOnWrite();
        instance.clearScrollIntoViewIfNeeded();
        return this;
      }

      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @return Whether the acceptElementIfNotInView field is set.
       */
      @java.lang.Override
      public boolean hasAcceptElementIfNotInView() {
        return instance.hasAcceptElementIfNotInView();
      }
      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @return The acceptElementIfNotInView.
       */
      @java.lang.Override
      public boolean getAcceptElementIfNotInView() {
        return instance.getAcceptElementIfNotInView();
      }
      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @param value The acceptElementIfNotInView to set.
       * @return This builder for chaining.
       */
      public Builder setAcceptElementIfNotInView(boolean value) {
        copyOnWrite();
        instance.setAcceptElementIfNotInView(value);
        return this;
      }
      /**
       * <pre>
       * If true and the element cannot be scrolled into view, so the filter
       * cannot check whether the element is on top, keep the element in the match
       * set.
       * This can be combined with scroll_into_view_if_needed=false to make
       * this filter best effort and only check elements that are already in view.
       * </pre>
       *
       * <code>optional bool accept_element_if_not_in_view = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAcceptElementIfNotInView() {
        copyOnWrite();
        instance.clearAcceptElementIfNotInView();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.OnTopFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "scrollIntoViewIfNeeded_",
              "acceptElementIfNotInView_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u1007\u0000\u0002" +
                "\u1007\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.OnTopFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter DEFAULT_INSTANCE;
    static {
      OnTopFilter defaultInstance = new OnTopFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        OnTopFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.OnTopFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<OnTopFilter> PARSER;

    public static com.google.protobuf.Parser<OnTopFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface EmptyFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.EmptyFilter)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * Protobuf type {@code autofill_assistant.SelectorProto.EmptyFilter}
   */
  public  static final class EmptyFilter extends
      com.google.protobuf.GeneratedMessageLite<
          EmptyFilter, EmptyFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.EmptyFilter)
      EmptyFilterOrBuilder {
    private EmptyFilter() {
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.SelectorProto.EmptyFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.EmptyFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.EmptyFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = null;java.lang.String info =
                "\u0001\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.EmptyFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter DEFAULT_INSTANCE;
    static {
      EmptyFilter defaultInstance = new EmptyFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        EmptyFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.EmptyFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<EmptyFilter> PARSER;

    public static com.google.protobuf.Parser<EmptyFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface NthMatchFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.NthMatchFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return Whether the index field is set.
     */
    boolean hasIndex();
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return The index.
     */
    int getIndex();
  }
  /**
   * Protobuf type {@code autofill_assistant.SelectorProto.NthMatchFilter}
   */
  public  static final class NthMatchFilter extends
      com.google.protobuf.GeneratedMessageLite<
          NthMatchFilter, NthMatchFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.NthMatchFilter)
      NthMatchFilterOrBuilder {
    private NthMatchFilter() {
    }
    private int bitField0_;
    public static final int INDEX_FIELD_NUMBER = 1;
    private int index_;
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return Whether the index field is set.
     */
    @java.lang.Override
    public boolean hasIndex() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @return The index.
     */
    @java.lang.Override
    public int getIndex() {
      return index_;
    }
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     * @param value The index to set.
     */
    private void setIndex(int value) {
      bitField0_ |= 0x00000001;
      index_ = value;
    }
    /**
     * <pre>
     * Take the match at the given |index|.
     * </pre>
     *
     * <code>optional int32 index = 1;</code>
     */
    private void clearIndex() {
      bitField0_ = (bitField0_ & ~0x00000001);
      index_ = 0;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.SelectorProto.NthMatchFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.NthMatchFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @return Whether the index field is set.
       */
      @java.lang.Override
      public boolean hasIndex() {
        return instance.hasIndex();
      }
      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @return The index.
       */
      @java.lang.Override
      public int getIndex() {
        return instance.getIndex();
      }
      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @param value The index to set.
       * @return This builder for chaining.
       */
      public Builder setIndex(int value) {
        copyOnWrite();
        instance.setIndex(value);
        return this;
      }
      /**
       * <pre>
       * Take the match at the given |index|.
       * </pre>
       *
       * <code>optional int32 index = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIndex() {
        copyOnWrite();
        instance.clearIndex();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.NthMatchFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "index_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u1004\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.NthMatchFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter DEFAULT_INSTANCE;
    static {
      NthMatchFilter defaultInstance = new NthMatchFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        NthMatchFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.NthMatchFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<NthMatchFilter> PARSER;

    public static com.google.protobuf.Parser<NthMatchFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SemanticFilterOrBuilder extends
      // @@protoc_insertion_point(interface_extends:autofill_assistant.SelectorProto.SemanticFilter)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The objective we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 objective = 1;</code>
     * @return Whether the objective field is set.
     */
    boolean hasObjective();
    /**
     * <pre>
     * The objective we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 objective = 1;</code>
     * @return The objective.
     */
    int getObjective();

    /**
     * <pre>
     * The role we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 role = 2;</code>
     * @return Whether the role field is set.
     */
    boolean hasRole();
    /**
     * <pre>
     * The role we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 role = 2;</code>
     * @return The role.
     */
    int getRole();

    /**
     * <pre>
     * Timeout, defaults to 5s.
     * TODO(b/218482826): Consider moving this to settings.
     * </pre>
     *
     * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
     * @return Whether the modelTimeoutMs field is set.
     */
    boolean hasModelTimeoutMs();
    /**
     * <pre>
     * Timeout, defaults to 5s.
     * TODO(b/218482826): Consider moving this to settings.
     * </pre>
     *
     * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
     * @return The modelTimeoutMs.
     */
    int getModelTimeoutMs();

    /**
     * <pre>
     * If true, ignore the objective and treat it as a wildcard '*' when
     * matching.
     * </pre>
     *
     * <code>optional bool ignore_objective = 4;</code>
     * @return Whether the ignoreObjective field is set.
     */
    boolean hasIgnoreObjective();
    /**
     * <pre>
     * If true, ignore the objective and treat it as a wildcard '*' when
     * matching.
     * </pre>
     *
     * <code>optional bool ignore_objective = 4;</code>
     * @return The ignoreObjective.
     */
    boolean getIgnoreObjective();
  }
  /**
   * Protobuf type {@code autofill_assistant.SelectorProto.SemanticFilter}
   */
  public  static final class SemanticFilter extends
      com.google.protobuf.GeneratedMessageLite<
          SemanticFilter, SemanticFilter.Builder> implements
      // @@protoc_insertion_point(message_implements:autofill_assistant.SelectorProto.SemanticFilter)
      SemanticFilterOrBuilder {
    private SemanticFilter() {
      modelTimeoutMs_ = 5000;
    }
    private int bitField0_;
    public static final int OBJECTIVE_FIELD_NUMBER = 1;
    private int objective_;
    /**
     * <pre>
     * The objective we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 objective = 1;</code>
     * @return Whether the objective field is set.
     */
    @java.lang.Override
    public boolean hasObjective() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The objective we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 objective = 1;</code>
     * @return The objective.
     */
    @java.lang.Override
    public int getObjective() {
      return objective_;
    }
    /**
     * <pre>
     * The objective we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 objective = 1;</code>
     * @param value The objective to set.
     */
    private void setObjective(int value) {
      bitField0_ |= 0x00000001;
      objective_ = value;
    }
    /**
     * <pre>
     * The objective we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 objective = 1;</code>
     */
    private void clearObjective() {
      bitField0_ = (bitField0_ & ~0x00000001);
      objective_ = 0;
    }

    public static final int ROLE_FIELD_NUMBER = 2;
    private int role_;
    /**
     * <pre>
     * The role we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 role = 2;</code>
     * @return Whether the role field is set.
     */
    @java.lang.Override
    public boolean hasRole() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The role we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 role = 2;</code>
     * @return The role.
     */
    @java.lang.Override
    public int getRole() {
      return role_;
    }
    /**
     * <pre>
     * The role we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 role = 2;</code>
     * @param value The role to set.
     */
    private void setRole(int value) {
      bitField0_ |= 0x00000002;
      role_ = value;
    }
    /**
     * <pre>
     * The role we expect this Selector to have.
     * </pre>
     *
     * <code>optional int32 role = 2;</code>
     */
    private void clearRole() {
      bitField0_ = (bitField0_ & ~0x00000002);
      role_ = 0;
    }

    public static final int MODEL_TIMEOUT_MS_FIELD_NUMBER = 3;
    private int modelTimeoutMs_;
    /**
     * <pre>
     * Timeout, defaults to 5s.
     * TODO(b/218482826): Consider moving this to settings.
     * </pre>
     *
     * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
     * @return Whether the modelTimeoutMs field is set.
     */
    @java.lang.Override
    public boolean hasModelTimeoutMs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Timeout, defaults to 5s.
     * TODO(b/218482826): Consider moving this to settings.
     * </pre>
     *
     * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
     * @return The modelTimeoutMs.
     */
    @java.lang.Override
    public int getModelTimeoutMs() {
      return modelTimeoutMs_;
    }
    /**
     * <pre>
     * Timeout, defaults to 5s.
     * TODO(b/218482826): Consider moving this to settings.
     * </pre>
     *
     * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
     * @param value The modelTimeoutMs to set.
     */
    private void setModelTimeoutMs(int value) {
      bitField0_ |= 0x00000004;
      modelTimeoutMs_ = value;
    }
    /**
     * <pre>
     * Timeout, defaults to 5s.
     * TODO(b/218482826): Consider moving this to settings.
     * </pre>
     *
     * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
     */
    private void clearModelTimeoutMs() {
      bitField0_ = (bitField0_ & ~0x00000004);
      modelTimeoutMs_ = 5000;
    }

    public static final int IGNORE_OBJECTIVE_FIELD_NUMBER = 4;
    private boolean ignoreObjective_;
    /**
     * <pre>
     * If true, ignore the objective and treat it as a wildcard '*' when
     * matching.
     * </pre>
     *
     * <code>optional bool ignore_objective = 4;</code>
     * @return Whether the ignoreObjective field is set.
     */
    @java.lang.Override
    public boolean hasIgnoreObjective() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If true, ignore the objective and treat it as a wildcard '*' when
     * matching.
     * </pre>
     *
     * <code>optional bool ignore_objective = 4;</code>
     * @return The ignoreObjective.
     */
    @java.lang.Override
    public boolean getIgnoreObjective() {
      return ignoreObjective_;
    }
    /**
     * <pre>
     * If true, ignore the objective and treat it as a wildcard '*' when
     * matching.
     * </pre>
     *
     * <code>optional bool ignore_objective = 4;</code>
     * @param value The ignoreObjective to set.
     */
    private void setIgnoreObjective(boolean value) {
      bitField0_ |= 0x00000008;
      ignoreObjective_ = value;
    }
    /**
     * <pre>
     * If true, ignore the objective and treat it as a wildcard '*' when
     * matching.
     * </pre>
     *
     * <code>optional bool ignore_objective = 4;</code>
     */
    private void clearIgnoreObjective() {
      bitField0_ = (bitField0_ & ~0x00000008);
      ignoreObjective_ = false;
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code autofill_assistant.SelectorProto.SemanticFilter}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter, Builder> implements
        // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto.SemanticFilter)
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilterOrBuilder {
      // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The objective we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 objective = 1;</code>
       * @return Whether the objective field is set.
       */
      @java.lang.Override
      public boolean hasObjective() {
        return instance.hasObjective();
      }
      /**
       * <pre>
       * The objective we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 objective = 1;</code>
       * @return The objective.
       */
      @java.lang.Override
      public int getObjective() {
        return instance.getObjective();
      }
      /**
       * <pre>
       * The objective we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 objective = 1;</code>
       * @param value The objective to set.
       * @return This builder for chaining.
       */
      public Builder setObjective(int value) {
        copyOnWrite();
        instance.setObjective(value);
        return this;
      }
      /**
       * <pre>
       * The objective we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 objective = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearObjective() {
        copyOnWrite();
        instance.clearObjective();
        return this;
      }

      /**
       * <pre>
       * The role we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 role = 2;</code>
       * @return Whether the role field is set.
       */
      @java.lang.Override
      public boolean hasRole() {
        return instance.hasRole();
      }
      /**
       * <pre>
       * The role we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 role = 2;</code>
       * @return The role.
       */
      @java.lang.Override
      public int getRole() {
        return instance.getRole();
      }
      /**
       * <pre>
       * The role we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 role = 2;</code>
       * @param value The role to set.
       * @return This builder for chaining.
       */
      public Builder setRole(int value) {
        copyOnWrite();
        instance.setRole(value);
        return this;
      }
      /**
       * <pre>
       * The role we expect this Selector to have.
       * </pre>
       *
       * <code>optional int32 role = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRole() {
        copyOnWrite();
        instance.clearRole();
        return this;
      }

      /**
       * <pre>
       * Timeout, defaults to 5s.
       * TODO(b/218482826): Consider moving this to settings.
       * </pre>
       *
       * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
       * @return Whether the modelTimeoutMs field is set.
       */
      @java.lang.Override
      public boolean hasModelTimeoutMs() {
        return instance.hasModelTimeoutMs();
      }
      /**
       * <pre>
       * Timeout, defaults to 5s.
       * TODO(b/218482826): Consider moving this to settings.
       * </pre>
       *
       * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
       * @return The modelTimeoutMs.
       */
      @java.lang.Override
      public int getModelTimeoutMs() {
        return instance.getModelTimeoutMs();
      }
      /**
       * <pre>
       * Timeout, defaults to 5s.
       * TODO(b/218482826): Consider moving this to settings.
       * </pre>
       *
       * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
       * @param value The modelTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setModelTimeoutMs(int value) {
        copyOnWrite();
        instance.setModelTimeoutMs(value);
        return this;
      }
      /**
       * <pre>
       * Timeout, defaults to 5s.
       * TODO(b/218482826): Consider moving this to settings.
       * </pre>
       *
       * <code>optional int32 model_timeout_ms = 3 [default = 5000];</code>
       * @return This builder for chaining.
       */
      public Builder clearModelTimeoutMs() {
        copyOnWrite();
        instance.clearModelTimeoutMs();
        return this;
      }

      /**
       * <pre>
       * If true, ignore the objective and treat it as a wildcard '*' when
       * matching.
       * </pre>
       *
       * <code>optional bool ignore_objective = 4;</code>
       * @return Whether the ignoreObjective field is set.
       */
      @java.lang.Override
      public boolean hasIgnoreObjective() {
        return instance.hasIgnoreObjective();
      }
      /**
       * <pre>
       * If true, ignore the objective and treat it as a wildcard '*' when
       * matching.
       * </pre>
       *
       * <code>optional bool ignore_objective = 4;</code>
       * @return The ignoreObjective.
       */
      @java.lang.Override
      public boolean getIgnoreObjective() {
        return instance.getIgnoreObjective();
      }
      /**
       * <pre>
       * If true, ignore the objective and treat it as a wildcard '*' when
       * matching.
       * </pre>
       *
       * <code>optional bool ignore_objective = 4;</code>
       * @param value The ignoreObjective to set.
       * @return This builder for chaining.
       */
      public Builder setIgnoreObjective(boolean value) {
        copyOnWrite();
        instance.setIgnoreObjective(value);
        return this;
      }
      /**
       * <pre>
       * If true, ignore the objective and treat it as a wildcard '*' when
       * matching.
       * </pre>
       *
       * <code>optional bool ignore_objective = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearIgnoreObjective() {
        copyOnWrite();
        instance.clearIgnoreObjective();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto.SemanticFilter)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "objective_",
              "role_",
              "modelTimeoutMs_",
              "ignoreObjective_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0000\u0001\u1004\u0000\u0002" +
                "\u1004\u0001\u0003\u1004\u0002\u0004\u1007\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.SemanticFilter)
    private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter DEFAULT_INSTANCE;
    static {
      SemanticFilter defaultInstance = new SemanticFilter();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SemanticFilter.class, defaultInstance);
    }

    public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.SemanticFilter getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SemanticFilter> PARSER;

    public static com.google.protobuf.Parser<SemanticFilter> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  private int bitField0_;
  public static final int FILTERS_FIELD_NUMBER = 9;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> filters_;
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  @java.lang.Override
  public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> getFiltersList() {
    return filters_;
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  public java.util.List<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder> 
      getFiltersOrBuilderList() {
    return filters_;
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  @java.lang.Override
  public int getFiltersCount() {
    return filters_.size();
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  @java.lang.Override
  public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getFilters(int index) {
    return filters_.get(index);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.FilterOrBuilder getFiltersOrBuilder(
      int index) {
    return filters_.get(index);
  }
  private void ensureFiltersIsMutable() {
    com.google.protobuf.Internal.ProtobufList<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> tmp = filters_;
    if (!tmp.isModifiable()) {
      filters_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void setFilters(
      int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
    value.getClass();
  ensureFiltersIsMutable();
    filters_.set(index, value);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void addFilters(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
    value.getClass();
  ensureFiltersIsMutable();
    filters_.add(value);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void addFilters(
      int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
    value.getClass();
  ensureFiltersIsMutable();
    filters_.add(index, value);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void addAllFilters(
      java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> values) {
    ensureFiltersIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, filters_);
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void clearFilters() {
    filters_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Filters for the element on the page. Filter are applied sequentially, using
   * the output of the previous filter as input. The root of these filters is
   * the main frame's document.
   * </pre>
   *
   * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
   */
  private void removeFilters(int index) {
    ensureFiltersIsMutable();
    filters_.remove(index);
  }

  public static final int TRACKING_ID_FIELD_NUMBER = 10;
  private long trackingId_;
  /**
   * <pre>
   * An ID that's used to identify selector in logs, as they pass through
   * different layers. It is passed to the client only as FYI. Client might
   * choose to echo back these ids when reporting specific selectors as
   * matching or not matching.
   * </pre>
   *
   * <code>optional int64 tracking_id = 10;</code>
   * @return Whether the trackingId field is set.
   */
  @java.lang.Override
  public boolean hasTrackingId() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * An ID that's used to identify selector in logs, as they pass through
   * different layers. It is passed to the client only as FYI. Client might
   * choose to echo back these ids when reporting specific selectors as
   * matching or not matching.
   * </pre>
   *
   * <code>optional int64 tracking_id = 10;</code>
   * @return The trackingId.
   */
  @java.lang.Override
  public long getTrackingId() {
    return trackingId_;
  }
  /**
   * <pre>
   * An ID that's used to identify selector in logs, as they pass through
   * different layers. It is passed to the client only as FYI. Client might
   * choose to echo back these ids when reporting specific selectors as
   * matching or not matching.
   * </pre>
   *
   * <code>optional int64 tracking_id = 10;</code>
   * @param value The trackingId to set.
   */
  private void setTrackingId(long value) {
    bitField0_ |= 0x00000001;
    trackingId_ = value;
  }
  /**
   * <pre>
   * An ID that's used to identify selector in logs, as they pass through
   * different layers. It is passed to the client only as FYI. Client might
   * choose to echo back these ids when reporting specific selectors as
   * matching or not matching.
   * </pre>
   *
   * <code>optional int64 tracking_id = 10;</code>
   */
  private void clearTrackingId() {
    bitField0_ = (bitField0_ & ~0x00000001);
    trackingId_ = 0L;
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * A reference to one or more elements on the page, possibly nested in frames.
   * Next ID: 12
   * </pre>
   *
   * Protobuf type {@code autofill_assistant.SelectorProto}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto, Builder> implements
      // @@protoc_insertion_point(builder_implements:autofill_assistant.SelectorProto)
      org.chromium.chrome.browser.autofill_assistant.proto.SelectorProtoOrBuilder {
    // Construct using org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    @java.lang.Override
    public java.util.List<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> getFiltersList() {
      return java.util.Collections.unmodifiableList(
          instance.getFiltersList());
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    @java.lang.Override
    public int getFiltersCount() {
      return instance.getFiltersCount();
    }/**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    @java.lang.Override
    public org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter getFilters(int index) {
      return instance.getFilters(index);
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder setFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      copyOnWrite();
      instance.setFilters(index, value);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder setFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
      copyOnWrite();
      instance.setFilters(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      copyOnWrite();
      instance.addFilters(value);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter value) {
      copyOnWrite();
      instance.addFilters(index, value);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(
        org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
      copyOnWrite();
      instance.addFilters(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addFilters(
        int index, org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.Builder builderForValue) {
      copyOnWrite();
      instance.addFilters(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder addAllFilters(
        java.lang.Iterable<? extends org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter> values) {
      copyOnWrite();
      instance.addAllFilters(values);
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder clearFilters() {
      copyOnWrite();
      instance.clearFilters();
      return this;
    }
    /**
     * <pre>
     * Filters for the element on the page. Filter are applied sequentially, using
     * the output of the previous filter as input. The root of these filters is
     * the main frame's document.
     * </pre>
     *
     * <code>repeated .autofill_assistant.SelectorProto.Filter filters = 9;</code>
     */
    public Builder removeFilters(int index) {
      copyOnWrite();
      instance.removeFilters(index);
      return this;
    }

    /**
     * <pre>
     * An ID that's used to identify selector in logs, as they pass through
     * different layers. It is passed to the client only as FYI. Client might
     * choose to echo back these ids when reporting specific selectors as
     * matching or not matching.
     * </pre>
     *
     * <code>optional int64 tracking_id = 10;</code>
     * @return Whether the trackingId field is set.
     */
    @java.lang.Override
    public boolean hasTrackingId() {
      return instance.hasTrackingId();
    }
    /**
     * <pre>
     * An ID that's used to identify selector in logs, as they pass through
     * different layers. It is passed to the client only as FYI. Client might
     * choose to echo back these ids when reporting specific selectors as
     * matching or not matching.
     * </pre>
     *
     * <code>optional int64 tracking_id = 10;</code>
     * @return The trackingId.
     */
    @java.lang.Override
    public long getTrackingId() {
      return instance.getTrackingId();
    }
    /**
     * <pre>
     * An ID that's used to identify selector in logs, as they pass through
     * different layers. It is passed to the client only as FYI. Client might
     * choose to echo back these ids when reporting specific selectors as
     * matching or not matching.
     * </pre>
     *
     * <code>optional int64 tracking_id = 10;</code>
     * @param value The trackingId to set.
     * @return This builder for chaining.
     */
    public Builder setTrackingId(long value) {
      copyOnWrite();
      instance.setTrackingId(value);
      return this;
    }
    /**
     * <pre>
     * An ID that's used to identify selector in logs, as they pass through
     * different layers. It is passed to the client only as FYI. Client might
     * choose to echo back these ids when reporting specific selectors as
     * matching or not matching.
     * </pre>
     *
     * <code>optional int64 tracking_id = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearTrackingId() {
      copyOnWrite();
      instance.clearTrackingId();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:autofill_assistant.SelectorProto)
  }
  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0, java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          java.lang.Object[] objects = new java.lang.Object[] {
            "bitField0_",
            "filters_",
            org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.Filter.class,
            "trackingId_",
          };
          java.lang.String info =
              "\u0001\u0002\u0000\u0001\t\n\u0002\u0000\u0001\u0000\t\u001b\n\u1002\u0000";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto> parser = PARSER;
        if (parser == null) {
          synchronized (org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto)
  private static final org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto DEFAULT_INSTANCE;
  static {
    SelectorProto defaultInstance = new SelectorProto();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      SelectorProto.class, defaultInstance);
  }

  public static org.chromium.chrome.browser.autofill_assistant.proto.SelectorProto getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<SelectorProto> PARSER;

  public static com.google.protobuf.Parser<SelectorProto> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

