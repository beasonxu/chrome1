// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/generic_ui.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/autofill_assistant/browser/action_value.pb.h"
#include "components/autofill_assistant/browser/model.pb.h"
#include "components/autofill_assistant/browser/view_layout.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
class AutofillFormatProto;
struct AutofillFormatProtoDefaultTypeInternal;
extern AutofillFormatProtoDefaultTypeInternal _AutofillFormatProto_default_instance_;
class BooleanAndProto;
struct BooleanAndProtoDefaultTypeInternal;
extern BooleanAndProtoDefaultTypeInternal _BooleanAndProto_default_instance_;
class BooleanNotProto;
struct BooleanNotProtoDefaultTypeInternal;
extern BooleanNotProtoDefaultTypeInternal _BooleanNotProto_default_instance_;
class BooleanOrProto;
struct BooleanOrProtoDefaultTypeInternal;
extern BooleanOrProtoDefaultTypeInternal _BooleanOrProto_default_instance_;
class CallbackProto;
struct CallbackProtoDefaultTypeInternal;
extern CallbackProtoDefaultTypeInternal _CallbackProto_default_instance_;
class ClearViewContainerProto;
struct ClearViewContainerProtoDefaultTypeInternal;
extern ClearViewContainerProtoDefaultTypeInternal _ClearViewContainerProto_default_instance_;
class ComputeValueProto;
struct ComputeValueProtoDefaultTypeInternal;
extern ComputeValueProtoDefaultTypeInternal _ComputeValueProto_default_instance_;
class CreateCreditCardResponseProto;
struct CreateCreditCardResponseProtoDefaultTypeInternal;
extern CreateCreditCardResponseProtoDefaultTypeInternal _CreateCreditCardResponseProto_default_instance_;
class CreateLoginOptionResponseProto;
struct CreateLoginOptionResponseProtoDefaultTypeInternal;
extern CreateLoginOptionResponseProtoDefaultTypeInternal _CreateLoginOptionResponseProto_default_instance_;
class CreateNestedGenericUiProto;
struct CreateNestedGenericUiProtoDefaultTypeInternal;
extern CreateNestedGenericUiProtoDefaultTypeInternal _CreateNestedGenericUiProto_default_instance_;
class DateFormatProto;
struct DateFormatProtoDefaultTypeInternal;
extern DateFormatProtoDefaultTypeInternal _DateFormatProto_default_instance_;
class EndActionProto;
struct EndActionProtoDefaultTypeInternal;
extern EndActionProtoDefaultTypeInternal _EndActionProto_default_instance_;
class EventProto;
struct EventProtoDefaultTypeInternal;
extern EventProtoDefaultTypeInternal _EventProto_default_instance_;
class ForEachProto;
struct ForEachProtoDefaultTypeInternal;
extern ForEachProtoDefaultTypeInternal _ForEachProto_default_instance_;
class GenericUserInterfaceProto;
struct GenericUserInterfaceProtoDefaultTypeInternal;
extern GenericUserInterfaceProtoDefaultTypeInternal _GenericUserInterfaceProto_default_instance_;
class IntegerSumProto;
struct IntegerSumProtoDefaultTypeInternal;
extern IntegerSumProtoDefaultTypeInternal _IntegerSumProto_default_instance_;
class InteractionProto;
struct InteractionProtoDefaultTypeInternal;
extern InteractionProtoDefaultTypeInternal _InteractionProto_default_instance_;
class InteractionsProto;
struct InteractionsProtoDefaultTypeInternal;
extern InteractionsProtoDefaultTypeInternal _InteractionsProto_default_instance_;
class OnModelValueChangedEventProto;
struct OnModelValueChangedEventProtoDefaultTypeInternal;
extern OnModelValueChangedEventProtoDefaultTypeInternal _OnModelValueChangedEventProto_default_instance_;
class OnPopupDismissedProto;
struct OnPopupDismissedProtoDefaultTypeInternal;
extern OnPopupDismissedProtoDefaultTypeInternal _OnPopupDismissedProto_default_instance_;
class OnTextLinkClickedProto;
struct OnTextLinkClickedProtoDefaultTypeInternal;
extern OnTextLinkClickedProtoDefaultTypeInternal _OnTextLinkClickedProto_default_instance_;
class OnUserActionCalled;
struct OnUserActionCalledDefaultTypeInternal;
extern OnUserActionCalledDefaultTypeInternal _OnUserActionCalled_default_instance_;
class OnViewClickedEventProto;
struct OnViewClickedEventProtoDefaultTypeInternal;
extern OnViewClickedEventProtoDefaultTypeInternal _OnViewClickedEventProto_default_instance_;
class OnViewContainerClearedProto;
struct OnViewContainerClearedProtoDefaultTypeInternal;
extern OnViewContainerClearedProtoDefaultTypeInternal _OnViewContainerClearedProto_default_instance_;
class SetModelValueProto;
struct SetModelValueProtoDefaultTypeInternal;
extern SetModelValueProtoDefaultTypeInternal _SetModelValueProto_default_instance_;
class SetTextProto;
struct SetTextProtoDefaultTypeInternal;
extern SetTextProtoDefaultTypeInternal _SetTextProto_default_instance_;
class SetUserActionsProto;
struct SetUserActionsProtoDefaultTypeInternal;
extern SetUserActionsProtoDefaultTypeInternal _SetUserActionsProto_default_instance_;
class SetViewEnabledProto;
struct SetViewEnabledProtoDefaultTypeInternal;
extern SetViewEnabledProtoDefaultTypeInternal _SetViewEnabledProto_default_instance_;
class SetViewVisibilityProto;
struct SetViewVisibilityProtoDefaultTypeInternal;
extern SetViewVisibilityProtoDefaultTypeInternal _SetViewVisibilityProto_default_instance_;
class ShowCalendarPopupProto;
struct ShowCalendarPopupProtoDefaultTypeInternal;
extern ShowCalendarPopupProtoDefaultTypeInternal _ShowCalendarPopupProto_default_instance_;
class ShowGenericUiPopupProto;
struct ShowGenericUiPopupProtoDefaultTypeInternal;
extern ShowGenericUiPopupProtoDefaultTypeInternal _ShowGenericUiPopupProto_default_instance_;
class ShowInfoPopupProto;
struct ShowInfoPopupProtoDefaultTypeInternal;
extern ShowInfoPopupProtoDefaultTypeInternal _ShowInfoPopupProto_default_instance_;
class ShowListPopupProto;
struct ShowListPopupProtoDefaultTypeInternal;
extern ShowListPopupProtoDefaultTypeInternal _ShowListPopupProto_default_instance_;
class StringEmptyProto;
struct StringEmptyProtoDefaultTypeInternal;
extern StringEmptyProtoDefaultTypeInternal _StringEmptyProto_default_instance_;
class ToStringProto;
struct ToStringProtoDefaultTypeInternal;
extern ToStringProtoDefaultTypeInternal _ToStringProto_default_instance_;
class ToggleUserActionProto;
struct ToggleUserActionProtoDefaultTypeInternal;
extern ToggleUserActionProtoDefaultTypeInternal _ToggleUserActionProto_default_instance_;
class ValueComparisonProto;
struct ValueComparisonProtoDefaultTypeInternal;
extern ValueComparisonProtoDefaultTypeInternal _ValueComparisonProto_default_instance_;
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::AutofillFormatProto* Arena::CreateMaybeMessage<::autofill_assistant::AutofillFormatProto>(Arena*);
template<> ::autofill_assistant::BooleanAndProto* Arena::CreateMaybeMessage<::autofill_assistant::BooleanAndProto>(Arena*);
template<> ::autofill_assistant::BooleanNotProto* Arena::CreateMaybeMessage<::autofill_assistant::BooleanNotProto>(Arena*);
template<> ::autofill_assistant::BooleanOrProto* Arena::CreateMaybeMessage<::autofill_assistant::BooleanOrProto>(Arena*);
template<> ::autofill_assistant::CallbackProto* Arena::CreateMaybeMessage<::autofill_assistant::CallbackProto>(Arena*);
template<> ::autofill_assistant::ClearViewContainerProto* Arena::CreateMaybeMessage<::autofill_assistant::ClearViewContainerProto>(Arena*);
template<> ::autofill_assistant::ComputeValueProto* Arena::CreateMaybeMessage<::autofill_assistant::ComputeValueProto>(Arena*);
template<> ::autofill_assistant::CreateCreditCardResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::CreateCreditCardResponseProto>(Arena*);
template<> ::autofill_assistant::CreateLoginOptionResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::CreateLoginOptionResponseProto>(Arena*);
template<> ::autofill_assistant::CreateNestedGenericUiProto* Arena::CreateMaybeMessage<::autofill_assistant::CreateNestedGenericUiProto>(Arena*);
template<> ::autofill_assistant::DateFormatProto* Arena::CreateMaybeMessage<::autofill_assistant::DateFormatProto>(Arena*);
template<> ::autofill_assistant::EndActionProto* Arena::CreateMaybeMessage<::autofill_assistant::EndActionProto>(Arena*);
template<> ::autofill_assistant::EventProto* Arena::CreateMaybeMessage<::autofill_assistant::EventProto>(Arena*);
template<> ::autofill_assistant::ForEachProto* Arena::CreateMaybeMessage<::autofill_assistant::ForEachProto>(Arena*);
template<> ::autofill_assistant::GenericUserInterfaceProto* Arena::CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(Arena*);
template<> ::autofill_assistant::IntegerSumProto* Arena::CreateMaybeMessage<::autofill_assistant::IntegerSumProto>(Arena*);
template<> ::autofill_assistant::InteractionProto* Arena::CreateMaybeMessage<::autofill_assistant::InteractionProto>(Arena*);
template<> ::autofill_assistant::InteractionsProto* Arena::CreateMaybeMessage<::autofill_assistant::InteractionsProto>(Arena*);
template<> ::autofill_assistant::OnModelValueChangedEventProto* Arena::CreateMaybeMessage<::autofill_assistant::OnModelValueChangedEventProto>(Arena*);
template<> ::autofill_assistant::OnPopupDismissedProto* Arena::CreateMaybeMessage<::autofill_assistant::OnPopupDismissedProto>(Arena*);
template<> ::autofill_assistant::OnTextLinkClickedProto* Arena::CreateMaybeMessage<::autofill_assistant::OnTextLinkClickedProto>(Arena*);
template<> ::autofill_assistant::OnUserActionCalled* Arena::CreateMaybeMessage<::autofill_assistant::OnUserActionCalled>(Arena*);
template<> ::autofill_assistant::OnViewClickedEventProto* Arena::CreateMaybeMessage<::autofill_assistant::OnViewClickedEventProto>(Arena*);
template<> ::autofill_assistant::OnViewContainerClearedProto* Arena::CreateMaybeMessage<::autofill_assistant::OnViewContainerClearedProto>(Arena*);
template<> ::autofill_assistant::SetModelValueProto* Arena::CreateMaybeMessage<::autofill_assistant::SetModelValueProto>(Arena*);
template<> ::autofill_assistant::SetTextProto* Arena::CreateMaybeMessage<::autofill_assistant::SetTextProto>(Arena*);
template<> ::autofill_assistant::SetUserActionsProto* Arena::CreateMaybeMessage<::autofill_assistant::SetUserActionsProto>(Arena*);
template<> ::autofill_assistant::SetViewEnabledProto* Arena::CreateMaybeMessage<::autofill_assistant::SetViewEnabledProto>(Arena*);
template<> ::autofill_assistant::SetViewVisibilityProto* Arena::CreateMaybeMessage<::autofill_assistant::SetViewVisibilityProto>(Arena*);
template<> ::autofill_assistant::ShowCalendarPopupProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowCalendarPopupProto>(Arena*);
template<> ::autofill_assistant::ShowGenericUiPopupProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiPopupProto>(Arena*);
template<> ::autofill_assistant::ShowInfoPopupProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowInfoPopupProto>(Arena*);
template<> ::autofill_assistant::ShowListPopupProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowListPopupProto>(Arena*);
template<> ::autofill_assistant::StringEmptyProto* Arena::CreateMaybeMessage<::autofill_assistant::StringEmptyProto>(Arena*);
template<> ::autofill_assistant::ToStringProto* Arena::CreateMaybeMessage<::autofill_assistant::ToStringProto>(Arena*);
template<> ::autofill_assistant::ToggleUserActionProto* Arena::CreateMaybeMessage<::autofill_assistant::ToggleUserActionProto>(Arena*);
template<> ::autofill_assistant::ValueComparisonProto* Arena::CreateMaybeMessage<::autofill_assistant::ValueComparisonProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {

enum AutofillFormatProto_AutofillAssistantCustomField : int {
  AutofillFormatProto_AutofillAssistantCustomField_UNDEFINED = 0,
  AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_VERIFICATION_CODE = -1,
  AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NETWORK = -2,
  AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_RAW_NUMBER = -3,
  AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NUMBER_LAST_FOUR_DIGITS = -4,
  AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NETWORK_FOR_DISPLAY = -5,
  AutofillFormatProto_AutofillAssistantCustomField_ADDRESS_HOME_STATE_NAME = -6,
  AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NON_PADDED_EXP_MONTH = -7,
  AutofillFormatProto_AutofillAssistantCustomField_ADDRESS_HOME_COUNTRY_CODE = -8
};
bool AutofillFormatProto_AutofillAssistantCustomField_IsValid(int value);
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_MIN = AutofillFormatProto_AutofillAssistantCustomField_ADDRESS_HOME_COUNTRY_CODE;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_MAX = AutofillFormatProto_AutofillAssistantCustomField_UNDEFINED;
constexpr int AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_ARRAYSIZE = AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_MAX + 1;

const std::string& AutofillFormatProto_AutofillAssistantCustomField_Name(AutofillFormatProto_AutofillAssistantCustomField value);
template<typename T>
inline const std::string& AutofillFormatProto_AutofillAssistantCustomField_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillFormatProto_AutofillAssistantCustomField>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillFormatProto_AutofillAssistantCustomField_Name.");
  return AutofillFormatProto_AutofillAssistantCustomField_Name(static_cast<AutofillFormatProto_AutofillAssistantCustomField>(enum_t_value));
}
bool AutofillFormatProto_AutofillAssistantCustomField_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillFormatProto_AutofillAssistantCustomField* value);
enum ValueComparisonProto_Mode : int {
  ValueComparisonProto_Mode_UNDEFINED = 0,
  ValueComparisonProto_Mode_LESS = 1,
  ValueComparisonProto_Mode_LESS_OR_EQUAL = 2,
  ValueComparisonProto_Mode_EQUAL = 3,
  ValueComparisonProto_Mode_GREATER_OR_EQUAL = 4,
  ValueComparisonProto_Mode_GREATER = 5,
  ValueComparisonProto_Mode_NOT_EQUAL = 6
};
bool ValueComparisonProto_Mode_IsValid(int value);
constexpr ValueComparisonProto_Mode ValueComparisonProto_Mode_Mode_MIN = ValueComparisonProto_Mode_UNDEFINED;
constexpr ValueComparisonProto_Mode ValueComparisonProto_Mode_Mode_MAX = ValueComparisonProto_Mode_NOT_EQUAL;
constexpr int ValueComparisonProto_Mode_Mode_ARRAYSIZE = ValueComparisonProto_Mode_Mode_MAX + 1;

const std::string& ValueComparisonProto_Mode_Name(ValueComparisonProto_Mode value);
template<typename T>
inline const std::string& ValueComparisonProto_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValueComparisonProto_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValueComparisonProto_Mode_Name.");
  return ValueComparisonProto_Mode_Name(static_cast<ValueComparisonProto_Mode>(enum_t_value));
}
bool ValueComparisonProto_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueComparisonProto_Mode* value);
enum ShowListPopupProto_ItemType : int {
  ShowListPopupProto_ItemType_GROUP = 0,
  ShowListPopupProto_ItemType_DISABLED = 1,
  ShowListPopupProto_ItemType_ENABLED = 2
};
bool ShowListPopupProto_ItemType_IsValid(int value);
constexpr ShowListPopupProto_ItemType ShowListPopupProto_ItemType_ItemType_MIN = ShowListPopupProto_ItemType_GROUP;
constexpr ShowListPopupProto_ItemType ShowListPopupProto_ItemType_ItemType_MAX = ShowListPopupProto_ItemType_ENABLED;
constexpr int ShowListPopupProto_ItemType_ItemType_ARRAYSIZE = ShowListPopupProto_ItemType_ItemType_MAX + 1;

const std::string& ShowListPopupProto_ItemType_Name(ShowListPopupProto_ItemType value);
template<typename T>
inline const std::string& ShowListPopupProto_ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShowListPopupProto_ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShowListPopupProto_ItemType_Name.");
  return ShowListPopupProto_ItemType_Name(static_cast<ShowListPopupProto_ItemType>(enum_t_value));
}
bool ShowListPopupProto_ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShowListPopupProto_ItemType* value);
// ===================================================================

class GenericUserInterfaceProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GenericUserInterfaceProto) */ {
 public:
  inline GenericUserInterfaceProto() : GenericUserInterfaceProto(nullptr) {}
  ~GenericUserInterfaceProto() override;
  explicit PROTOBUF_CONSTEXPR GenericUserInterfaceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericUserInterfaceProto(const GenericUserInterfaceProto& from);
  GenericUserInterfaceProto(GenericUserInterfaceProto&& from) noexcept
    : GenericUserInterfaceProto() {
    *this = ::std::move(from);
  }

  inline GenericUserInterfaceProto& operator=(const GenericUserInterfaceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericUserInterfaceProto& operator=(GenericUserInterfaceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericUserInterfaceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericUserInterfaceProto* internal_default_instance() {
    return reinterpret_cast<const GenericUserInterfaceProto*>(
               &_GenericUserInterfaceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenericUserInterfaceProto& a, GenericUserInterfaceProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GenericUserInterfaceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericUserInterfaceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericUserInterfaceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericUserInterfaceProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GenericUserInterfaceProto& from);
  void MergeFrom(const GenericUserInterfaceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericUserInterfaceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GenericUserInterfaceProto";
  }
  protected:
  explicit GenericUserInterfaceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootViewFieldNumber = 1,
    kInteractionsFieldNumber = 2,
    kModelFieldNumber = 3,
  };
  // optional .autofill_assistant.ViewProto root_view = 1;
  bool has_root_view() const;
  private:
  bool _internal_has_root_view() const;
  public:
  void clear_root_view();
  const ::autofill_assistant::ViewProto& root_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewProto* release_root_view();
  ::autofill_assistant::ViewProto* mutable_root_view();
  void set_allocated_root_view(::autofill_assistant::ViewProto* root_view);
  private:
  const ::autofill_assistant::ViewProto& _internal_root_view() const;
  ::autofill_assistant::ViewProto* _internal_mutable_root_view();
  public:
  void unsafe_arena_set_allocated_root_view(
      ::autofill_assistant::ViewProto* root_view);
  ::autofill_assistant::ViewProto* unsafe_arena_release_root_view();

  // optional .autofill_assistant.InteractionsProto interactions = 2;
  bool has_interactions() const;
  private:
  bool _internal_has_interactions() const;
  public:
  void clear_interactions();
  const ::autofill_assistant::InteractionsProto& interactions() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InteractionsProto* release_interactions();
  ::autofill_assistant::InteractionsProto* mutable_interactions();
  void set_allocated_interactions(::autofill_assistant::InteractionsProto* interactions);
  private:
  const ::autofill_assistant::InteractionsProto& _internal_interactions() const;
  ::autofill_assistant::InteractionsProto* _internal_mutable_interactions();
  public:
  void unsafe_arena_set_allocated_interactions(
      ::autofill_assistant::InteractionsProto* interactions);
  ::autofill_assistant::InteractionsProto* unsafe_arena_release_interactions();

  // optional .autofill_assistant.ModelProto model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::autofill_assistant::ModelProto& model() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ModelProto* release_model();
  ::autofill_assistant::ModelProto* mutable_model();
  void set_allocated_model(::autofill_assistant::ModelProto* model);
  private:
  const ::autofill_assistant::ModelProto& _internal_model() const;
  ::autofill_assistant::ModelProto* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::autofill_assistant::ModelProto* model);
  ::autofill_assistant::ModelProto* unsafe_arena_release_model();

  // @@protoc_insertion_point(class_scope:autofill_assistant.GenericUserInterfaceProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ViewProto* root_view_;
  ::autofill_assistant::InteractionsProto* interactions_;
  ::autofill_assistant::ModelProto* model_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class InteractionsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InteractionsProto) */ {
 public:
  inline InteractionsProto() : InteractionsProto(nullptr) {}
  ~InteractionsProto() override;
  explicit PROTOBUF_CONSTEXPR InteractionsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InteractionsProto(const InteractionsProto& from);
  InteractionsProto(InteractionsProto&& from) noexcept
    : InteractionsProto() {
    *this = ::std::move(from);
  }

  inline InteractionsProto& operator=(const InteractionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InteractionsProto& operator=(InteractionsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InteractionsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InteractionsProto* internal_default_instance() {
    return reinterpret_cast<const InteractionsProto*>(
               &_InteractionsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InteractionsProto& a, InteractionsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InteractionsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InteractionsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InteractionsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InteractionsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InteractionsProto& from);
  void MergeFrom(const InteractionsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InteractionsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InteractionsProto";
  }
  protected:
  explicit InteractionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionsFieldNumber = 1,
  };
  // repeated .autofill_assistant.InteractionProto interactions = 1;
  int interactions_size() const;
  private:
  int _internal_interactions_size() const;
  public:
  void clear_interactions();
  ::autofill_assistant::InteractionProto* mutable_interactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::InteractionProto >*
      mutable_interactions();
  private:
  const ::autofill_assistant::InteractionProto& _internal_interactions(int index) const;
  ::autofill_assistant::InteractionProto* _internal_add_interactions();
  public:
  const ::autofill_assistant::InteractionProto& interactions(int index) const;
  ::autofill_assistant::InteractionProto* add_interactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::InteractionProto >&
      interactions() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.InteractionsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::InteractionProto > interactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class InteractionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InteractionProto) */ {
 public:
  inline InteractionProto() : InteractionProto(nullptr) {}
  ~InteractionProto() override;
  explicit PROTOBUF_CONSTEXPR InteractionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InteractionProto(const InteractionProto& from);
  InteractionProto(InteractionProto&& from) noexcept
    : InteractionProto() {
    *this = ::std::move(from);
  }

  inline InteractionProto& operator=(const InteractionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InteractionProto& operator=(InteractionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InteractionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InteractionProto* internal_default_instance() {
    return reinterpret_cast<const InteractionProto*>(
               &_InteractionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InteractionProto& a, InteractionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InteractionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InteractionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InteractionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InteractionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InteractionProto& from);
  void MergeFrom(const InteractionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InteractionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InteractionProto";
  }
  protected:
  explicit InteractionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbacksFieldNumber = 1,
    kTriggerEventFieldNumber = 2,
  };
  // repeated .autofill_assistant.CallbackProto callbacks = 1;
  int callbacks_size() const;
  private:
  int _internal_callbacks_size() const;
  public:
  void clear_callbacks();
  ::autofill_assistant::CallbackProto* mutable_callbacks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >*
      mutable_callbacks();
  private:
  const ::autofill_assistant::CallbackProto& _internal_callbacks(int index) const;
  ::autofill_assistant::CallbackProto* _internal_add_callbacks();
  public:
  const ::autofill_assistant::CallbackProto& callbacks(int index) const;
  ::autofill_assistant::CallbackProto* add_callbacks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >&
      callbacks() const;

  // repeated .autofill_assistant.EventProto trigger_event = 2;
  int trigger_event_size() const;
  private:
  int _internal_trigger_event_size() const;
  public:
  void clear_trigger_event();
  ::autofill_assistant::EventProto* mutable_trigger_event(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::EventProto >*
      mutable_trigger_event();
  private:
  const ::autofill_assistant::EventProto& _internal_trigger_event(int index) const;
  ::autofill_assistant::EventProto* _internal_add_trigger_event();
  public:
  const ::autofill_assistant::EventProto& trigger_event(int index) const;
  ::autofill_assistant::EventProto* add_trigger_event();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::EventProto >&
      trigger_event() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.InteractionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto > callbacks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::EventProto > trigger_event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class CallbackProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CallbackProto) */ {
 public:
  inline CallbackProto() : CallbackProto(nullptr) {}
  ~CallbackProto() override;
  explicit PROTOBUF_CONSTEXPR CallbackProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackProto(const CallbackProto& from);
  CallbackProto(CallbackProto&& from) noexcept
    : CallbackProto() {
    *this = ::std::move(from);
  }

  inline CallbackProto& operator=(const CallbackProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackProto& operator=(CallbackProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CallbackProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kSetValue = 1,
    kShowInfoPopup = 2,
    kShowListPopup = 3,
    kComputeValue = 4,
    kSetUserActions = 5,
    kEndAction = 6,
    kShowCalendarPopup = 7,
    kSetText = 8,
    kToggleUserAction = 9,
    kSetViewVisibility = 11,
    kSetViewEnabled = 12,
    kShowGenericPopup = 13,
    kCreateNestedUi = 14,
    kClearViewContainer = 15,
    kForEach = 16,
    KIND_NOT_SET = 0,
  };

  static inline const CallbackProto* internal_default_instance() {
    return reinterpret_cast<const CallbackProto*>(
               &_CallbackProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CallbackProto& a, CallbackProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CallbackProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CallbackProto& from);
  void MergeFrom(const CallbackProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallbackProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CallbackProto";
  }
  protected:
  explicit CallbackProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionModelIdentifierFieldNumber = 10,
    kSetValueFieldNumber = 1,
    kShowInfoPopupFieldNumber = 2,
    kShowListPopupFieldNumber = 3,
    kComputeValueFieldNumber = 4,
    kSetUserActionsFieldNumber = 5,
    kEndActionFieldNumber = 6,
    kShowCalendarPopupFieldNumber = 7,
    kSetTextFieldNumber = 8,
    kToggleUserActionFieldNumber = 9,
    kSetViewVisibilityFieldNumber = 11,
    kSetViewEnabledFieldNumber = 12,
    kShowGenericPopupFieldNumber = 13,
    kCreateNestedUiFieldNumber = 14,
    kClearViewContainerFieldNumber = 15,
    kForEachFieldNumber = 16,
  };
  // optional string condition_model_identifier = 10;
  bool has_condition_model_identifier() const;
  private:
  bool _internal_has_condition_model_identifier() const;
  public:
  void clear_condition_model_identifier();
  const std::string& condition_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_condition_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_condition_model_identifier();
  PROTOBUF_NODISCARD std::string* release_condition_model_identifier();
  void set_allocated_condition_model_identifier(std::string* condition_model_identifier);
  private:
  const std::string& _internal_condition_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_condition_model_identifier(const std::string& value);
  std::string* _internal_mutable_condition_model_identifier();
  public:

  // .autofill_assistant.SetModelValueProto set_value = 1;
  bool has_set_value() const;
  private:
  bool _internal_has_set_value() const;
  public:
  void clear_set_value();
  const ::autofill_assistant::SetModelValueProto& set_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetModelValueProto* release_set_value();
  ::autofill_assistant::SetModelValueProto* mutable_set_value();
  void set_allocated_set_value(::autofill_assistant::SetModelValueProto* set_value);
  private:
  const ::autofill_assistant::SetModelValueProto& _internal_set_value() const;
  ::autofill_assistant::SetModelValueProto* _internal_mutable_set_value();
  public:
  void unsafe_arena_set_allocated_set_value(
      ::autofill_assistant::SetModelValueProto* set_value);
  ::autofill_assistant::SetModelValueProto* unsafe_arena_release_set_value();

  // .autofill_assistant.ShowInfoPopupProto show_info_popup = 2;
  bool has_show_info_popup() const;
  private:
  bool _internal_has_show_info_popup() const;
  public:
  void clear_show_info_popup();
  const ::autofill_assistant::ShowInfoPopupProto& show_info_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowInfoPopupProto* release_show_info_popup();
  ::autofill_assistant::ShowInfoPopupProto* mutable_show_info_popup();
  void set_allocated_show_info_popup(::autofill_assistant::ShowInfoPopupProto* show_info_popup);
  private:
  const ::autofill_assistant::ShowInfoPopupProto& _internal_show_info_popup() const;
  ::autofill_assistant::ShowInfoPopupProto* _internal_mutable_show_info_popup();
  public:
  void unsafe_arena_set_allocated_show_info_popup(
      ::autofill_assistant::ShowInfoPopupProto* show_info_popup);
  ::autofill_assistant::ShowInfoPopupProto* unsafe_arena_release_show_info_popup();

  // .autofill_assistant.ShowListPopupProto show_list_popup = 3;
  bool has_show_list_popup() const;
  private:
  bool _internal_has_show_list_popup() const;
  public:
  void clear_show_list_popup();
  const ::autofill_assistant::ShowListPopupProto& show_list_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowListPopupProto* release_show_list_popup();
  ::autofill_assistant::ShowListPopupProto* mutable_show_list_popup();
  void set_allocated_show_list_popup(::autofill_assistant::ShowListPopupProto* show_list_popup);
  private:
  const ::autofill_assistant::ShowListPopupProto& _internal_show_list_popup() const;
  ::autofill_assistant::ShowListPopupProto* _internal_mutable_show_list_popup();
  public:
  void unsafe_arena_set_allocated_show_list_popup(
      ::autofill_assistant::ShowListPopupProto* show_list_popup);
  ::autofill_assistant::ShowListPopupProto* unsafe_arena_release_show_list_popup();

  // .autofill_assistant.ComputeValueProto compute_value = 4;
  bool has_compute_value() const;
  private:
  bool _internal_has_compute_value() const;
  public:
  void clear_compute_value();
  const ::autofill_assistant::ComputeValueProto& compute_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ComputeValueProto* release_compute_value();
  ::autofill_assistant::ComputeValueProto* mutable_compute_value();
  void set_allocated_compute_value(::autofill_assistant::ComputeValueProto* compute_value);
  private:
  const ::autofill_assistant::ComputeValueProto& _internal_compute_value() const;
  ::autofill_assistant::ComputeValueProto* _internal_mutable_compute_value();
  public:
  void unsafe_arena_set_allocated_compute_value(
      ::autofill_assistant::ComputeValueProto* compute_value);
  ::autofill_assistant::ComputeValueProto* unsafe_arena_release_compute_value();

  // .autofill_assistant.SetUserActionsProto set_user_actions = 5;
  bool has_set_user_actions() const;
  private:
  bool _internal_has_set_user_actions() const;
  public:
  void clear_set_user_actions();
  const ::autofill_assistant::SetUserActionsProto& set_user_actions() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetUserActionsProto* release_set_user_actions();
  ::autofill_assistant::SetUserActionsProto* mutable_set_user_actions();
  void set_allocated_set_user_actions(::autofill_assistant::SetUserActionsProto* set_user_actions);
  private:
  const ::autofill_assistant::SetUserActionsProto& _internal_set_user_actions() const;
  ::autofill_assistant::SetUserActionsProto* _internal_mutable_set_user_actions();
  public:
  void unsafe_arena_set_allocated_set_user_actions(
      ::autofill_assistant::SetUserActionsProto* set_user_actions);
  ::autofill_assistant::SetUserActionsProto* unsafe_arena_release_set_user_actions();

  // .autofill_assistant.EndActionProto end_action = 6;
  bool has_end_action() const;
  private:
  bool _internal_has_end_action() const;
  public:
  void clear_end_action();
  const ::autofill_assistant::EndActionProto& end_action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::EndActionProto* release_end_action();
  ::autofill_assistant::EndActionProto* mutable_end_action();
  void set_allocated_end_action(::autofill_assistant::EndActionProto* end_action);
  private:
  const ::autofill_assistant::EndActionProto& _internal_end_action() const;
  ::autofill_assistant::EndActionProto* _internal_mutable_end_action();
  public:
  void unsafe_arena_set_allocated_end_action(
      ::autofill_assistant::EndActionProto* end_action);
  ::autofill_assistant::EndActionProto* unsafe_arena_release_end_action();

  // .autofill_assistant.ShowCalendarPopupProto show_calendar_popup = 7;
  bool has_show_calendar_popup() const;
  private:
  bool _internal_has_show_calendar_popup() const;
  public:
  void clear_show_calendar_popup();
  const ::autofill_assistant::ShowCalendarPopupProto& show_calendar_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowCalendarPopupProto* release_show_calendar_popup();
  ::autofill_assistant::ShowCalendarPopupProto* mutable_show_calendar_popup();
  void set_allocated_show_calendar_popup(::autofill_assistant::ShowCalendarPopupProto* show_calendar_popup);
  private:
  const ::autofill_assistant::ShowCalendarPopupProto& _internal_show_calendar_popup() const;
  ::autofill_assistant::ShowCalendarPopupProto* _internal_mutable_show_calendar_popup();
  public:
  void unsafe_arena_set_allocated_show_calendar_popup(
      ::autofill_assistant::ShowCalendarPopupProto* show_calendar_popup);
  ::autofill_assistant::ShowCalendarPopupProto* unsafe_arena_release_show_calendar_popup();

  // .autofill_assistant.SetTextProto set_text = 8;
  bool has_set_text() const;
  private:
  bool _internal_has_set_text() const;
  public:
  void clear_set_text();
  const ::autofill_assistant::SetTextProto& set_text() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetTextProto* release_set_text();
  ::autofill_assistant::SetTextProto* mutable_set_text();
  void set_allocated_set_text(::autofill_assistant::SetTextProto* set_text);
  private:
  const ::autofill_assistant::SetTextProto& _internal_set_text() const;
  ::autofill_assistant::SetTextProto* _internal_mutable_set_text();
  public:
  void unsafe_arena_set_allocated_set_text(
      ::autofill_assistant::SetTextProto* set_text);
  ::autofill_assistant::SetTextProto* unsafe_arena_release_set_text();

  // .autofill_assistant.ToggleUserActionProto toggle_user_action = 9;
  bool has_toggle_user_action() const;
  private:
  bool _internal_has_toggle_user_action() const;
  public:
  void clear_toggle_user_action();
  const ::autofill_assistant::ToggleUserActionProto& toggle_user_action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ToggleUserActionProto* release_toggle_user_action();
  ::autofill_assistant::ToggleUserActionProto* mutable_toggle_user_action();
  void set_allocated_toggle_user_action(::autofill_assistant::ToggleUserActionProto* toggle_user_action);
  private:
  const ::autofill_assistant::ToggleUserActionProto& _internal_toggle_user_action() const;
  ::autofill_assistant::ToggleUserActionProto* _internal_mutable_toggle_user_action();
  public:
  void unsafe_arena_set_allocated_toggle_user_action(
      ::autofill_assistant::ToggleUserActionProto* toggle_user_action);
  ::autofill_assistant::ToggleUserActionProto* unsafe_arena_release_toggle_user_action();

  // .autofill_assistant.SetViewVisibilityProto set_view_visibility = 11;
  bool has_set_view_visibility() const;
  private:
  bool _internal_has_set_view_visibility() const;
  public:
  void clear_set_view_visibility();
  const ::autofill_assistant::SetViewVisibilityProto& set_view_visibility() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetViewVisibilityProto* release_set_view_visibility();
  ::autofill_assistant::SetViewVisibilityProto* mutable_set_view_visibility();
  void set_allocated_set_view_visibility(::autofill_assistant::SetViewVisibilityProto* set_view_visibility);
  private:
  const ::autofill_assistant::SetViewVisibilityProto& _internal_set_view_visibility() const;
  ::autofill_assistant::SetViewVisibilityProto* _internal_mutable_set_view_visibility();
  public:
  void unsafe_arena_set_allocated_set_view_visibility(
      ::autofill_assistant::SetViewVisibilityProto* set_view_visibility);
  ::autofill_assistant::SetViewVisibilityProto* unsafe_arena_release_set_view_visibility();

  // .autofill_assistant.SetViewEnabledProto set_view_enabled = 12;
  bool has_set_view_enabled() const;
  private:
  bool _internal_has_set_view_enabled() const;
  public:
  void clear_set_view_enabled();
  const ::autofill_assistant::SetViewEnabledProto& set_view_enabled() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetViewEnabledProto* release_set_view_enabled();
  ::autofill_assistant::SetViewEnabledProto* mutable_set_view_enabled();
  void set_allocated_set_view_enabled(::autofill_assistant::SetViewEnabledProto* set_view_enabled);
  private:
  const ::autofill_assistant::SetViewEnabledProto& _internal_set_view_enabled() const;
  ::autofill_assistant::SetViewEnabledProto* _internal_mutable_set_view_enabled();
  public:
  void unsafe_arena_set_allocated_set_view_enabled(
      ::autofill_assistant::SetViewEnabledProto* set_view_enabled);
  ::autofill_assistant::SetViewEnabledProto* unsafe_arena_release_set_view_enabled();

  // .autofill_assistant.ShowGenericUiPopupProto show_generic_popup = 13;
  bool has_show_generic_popup() const;
  private:
  bool _internal_has_show_generic_popup() const;
  public:
  void clear_show_generic_popup();
  const ::autofill_assistant::ShowGenericUiPopupProto& show_generic_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowGenericUiPopupProto* release_show_generic_popup();
  ::autofill_assistant::ShowGenericUiPopupProto* mutable_show_generic_popup();
  void set_allocated_show_generic_popup(::autofill_assistant::ShowGenericUiPopupProto* show_generic_popup);
  private:
  const ::autofill_assistant::ShowGenericUiPopupProto& _internal_show_generic_popup() const;
  ::autofill_assistant::ShowGenericUiPopupProto* _internal_mutable_show_generic_popup();
  public:
  void unsafe_arena_set_allocated_show_generic_popup(
      ::autofill_assistant::ShowGenericUiPopupProto* show_generic_popup);
  ::autofill_assistant::ShowGenericUiPopupProto* unsafe_arena_release_show_generic_popup();

  // .autofill_assistant.CreateNestedGenericUiProto create_nested_ui = 14;
  bool has_create_nested_ui() const;
  private:
  bool _internal_has_create_nested_ui() const;
  public:
  void clear_create_nested_ui();
  const ::autofill_assistant::CreateNestedGenericUiProto& create_nested_ui() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CreateNestedGenericUiProto* release_create_nested_ui();
  ::autofill_assistant::CreateNestedGenericUiProto* mutable_create_nested_ui();
  void set_allocated_create_nested_ui(::autofill_assistant::CreateNestedGenericUiProto* create_nested_ui);
  private:
  const ::autofill_assistant::CreateNestedGenericUiProto& _internal_create_nested_ui() const;
  ::autofill_assistant::CreateNestedGenericUiProto* _internal_mutable_create_nested_ui();
  public:
  void unsafe_arena_set_allocated_create_nested_ui(
      ::autofill_assistant::CreateNestedGenericUiProto* create_nested_ui);
  ::autofill_assistant::CreateNestedGenericUiProto* unsafe_arena_release_create_nested_ui();

  // .autofill_assistant.ClearViewContainerProto clear_view_container = 15;
  bool has_clear_view_container() const;
  private:
  bool _internal_has_clear_view_container() const;
  public:
  void clear_clear_view_container();
  const ::autofill_assistant::ClearViewContainerProto& clear_view_container() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClearViewContainerProto* release_clear_view_container();
  ::autofill_assistant::ClearViewContainerProto* mutable_clear_view_container();
  void set_allocated_clear_view_container(::autofill_assistant::ClearViewContainerProto* clear_view_container);
  private:
  const ::autofill_assistant::ClearViewContainerProto& _internal_clear_view_container() const;
  ::autofill_assistant::ClearViewContainerProto* _internal_mutable_clear_view_container();
  public:
  void unsafe_arena_set_allocated_clear_view_container(
      ::autofill_assistant::ClearViewContainerProto* clear_view_container);
  ::autofill_assistant::ClearViewContainerProto* unsafe_arena_release_clear_view_container();

  // .autofill_assistant.ForEachProto for_each = 16;
  bool has_for_each() const;
  private:
  bool _internal_has_for_each() const;
  public:
  void clear_for_each();
  const ::autofill_assistant::ForEachProto& for_each() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ForEachProto* release_for_each();
  ::autofill_assistant::ForEachProto* mutable_for_each();
  void set_allocated_for_each(::autofill_assistant::ForEachProto* for_each);
  private:
  const ::autofill_assistant::ForEachProto& _internal_for_each() const;
  ::autofill_assistant::ForEachProto* _internal_mutable_for_each();
  public:
  void unsafe_arena_set_allocated_for_each(
      ::autofill_assistant::ForEachProto* for_each);
  ::autofill_assistant::ForEachProto* unsafe_arena_release_for_each();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.CallbackProto)
 private:
  class _Internal;
  void set_has_set_value();
  void set_has_show_info_popup();
  void set_has_show_list_popup();
  void set_has_compute_value();
  void set_has_set_user_actions();
  void set_has_end_action();
  void set_has_show_calendar_popup();
  void set_has_set_text();
  void set_has_toggle_user_action();
  void set_has_set_view_visibility();
  void set_has_set_view_enabled();
  void set_has_show_generic_popup();
  void set_has_create_nested_ui();
  void set_has_clear_view_container();
  void set_has_for_each();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr condition_model_identifier_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::SetModelValueProto* set_value_;
    ::autofill_assistant::ShowInfoPopupProto* show_info_popup_;
    ::autofill_assistant::ShowListPopupProto* show_list_popup_;
    ::autofill_assistant::ComputeValueProto* compute_value_;
    ::autofill_assistant::SetUserActionsProto* set_user_actions_;
    ::autofill_assistant::EndActionProto* end_action_;
    ::autofill_assistant::ShowCalendarPopupProto* show_calendar_popup_;
    ::autofill_assistant::SetTextProto* set_text_;
    ::autofill_assistant::ToggleUserActionProto* toggle_user_action_;
    ::autofill_assistant::SetViewVisibilityProto* set_view_visibility_;
    ::autofill_assistant::SetViewEnabledProto* set_view_enabled_;
    ::autofill_assistant::ShowGenericUiPopupProto* show_generic_popup_;
    ::autofill_assistant::CreateNestedGenericUiProto* create_nested_ui_;
    ::autofill_assistant::ClearViewContainerProto* clear_view_container_;
    ::autofill_assistant::ForEachProto* for_each_;
  } kind_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class EventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.EventProto) */ {
 public:
  inline EventProto() : EventProto(nullptr) {}
  ~EventProto() override;
  explicit PROTOBUF_CONSTEXPR EventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventProto(const EventProto& from);
  EventProto(EventProto&& from) noexcept
    : EventProto() {
    *this = ::std::move(from);
  }

  inline EventProto& operator=(const EventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventProto& operator=(EventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EventProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kOnValueChanged = 1,
    kOnViewClicked = 2,
    kOnUserActionCalled = 3,
    kOnTextLinkClicked = 4,
    kOnPopupDismissed = 5,
    kOnViewContainerCleared = 6,
    KIND_NOT_SET = 0,
  };

  static inline const EventProto* internal_default_instance() {
    return reinterpret_cast<const EventProto*>(
               &_EventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EventProto& a, EventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventProto& from);
  void MergeFrom(const EventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.EventProto";
  }
  protected:
  explicit EventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnValueChangedFieldNumber = 1,
    kOnViewClickedFieldNumber = 2,
    kOnUserActionCalledFieldNumber = 3,
    kOnTextLinkClickedFieldNumber = 4,
    kOnPopupDismissedFieldNumber = 5,
    kOnViewContainerClearedFieldNumber = 6,
  };
  // .autofill_assistant.OnModelValueChangedEventProto on_value_changed = 1;
  bool has_on_value_changed() const;
  private:
  bool _internal_has_on_value_changed() const;
  public:
  void clear_on_value_changed();
  const ::autofill_assistant::OnModelValueChangedEventProto& on_value_changed() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OnModelValueChangedEventProto* release_on_value_changed();
  ::autofill_assistant::OnModelValueChangedEventProto* mutable_on_value_changed();
  void set_allocated_on_value_changed(::autofill_assistant::OnModelValueChangedEventProto* on_value_changed);
  private:
  const ::autofill_assistant::OnModelValueChangedEventProto& _internal_on_value_changed() const;
  ::autofill_assistant::OnModelValueChangedEventProto* _internal_mutable_on_value_changed();
  public:
  void unsafe_arena_set_allocated_on_value_changed(
      ::autofill_assistant::OnModelValueChangedEventProto* on_value_changed);
  ::autofill_assistant::OnModelValueChangedEventProto* unsafe_arena_release_on_value_changed();

  // .autofill_assistant.OnViewClickedEventProto on_view_clicked = 2;
  bool has_on_view_clicked() const;
  private:
  bool _internal_has_on_view_clicked() const;
  public:
  void clear_on_view_clicked();
  const ::autofill_assistant::OnViewClickedEventProto& on_view_clicked() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OnViewClickedEventProto* release_on_view_clicked();
  ::autofill_assistant::OnViewClickedEventProto* mutable_on_view_clicked();
  void set_allocated_on_view_clicked(::autofill_assistant::OnViewClickedEventProto* on_view_clicked);
  private:
  const ::autofill_assistant::OnViewClickedEventProto& _internal_on_view_clicked() const;
  ::autofill_assistant::OnViewClickedEventProto* _internal_mutable_on_view_clicked();
  public:
  void unsafe_arena_set_allocated_on_view_clicked(
      ::autofill_assistant::OnViewClickedEventProto* on_view_clicked);
  ::autofill_assistant::OnViewClickedEventProto* unsafe_arena_release_on_view_clicked();

  // .autofill_assistant.OnUserActionCalled on_user_action_called = 3;
  bool has_on_user_action_called() const;
  private:
  bool _internal_has_on_user_action_called() const;
  public:
  void clear_on_user_action_called();
  const ::autofill_assistant::OnUserActionCalled& on_user_action_called() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OnUserActionCalled* release_on_user_action_called();
  ::autofill_assistant::OnUserActionCalled* mutable_on_user_action_called();
  void set_allocated_on_user_action_called(::autofill_assistant::OnUserActionCalled* on_user_action_called);
  private:
  const ::autofill_assistant::OnUserActionCalled& _internal_on_user_action_called() const;
  ::autofill_assistant::OnUserActionCalled* _internal_mutable_on_user_action_called();
  public:
  void unsafe_arena_set_allocated_on_user_action_called(
      ::autofill_assistant::OnUserActionCalled* on_user_action_called);
  ::autofill_assistant::OnUserActionCalled* unsafe_arena_release_on_user_action_called();

  // .autofill_assistant.OnTextLinkClickedProto on_text_link_clicked = 4;
  bool has_on_text_link_clicked() const;
  private:
  bool _internal_has_on_text_link_clicked() const;
  public:
  void clear_on_text_link_clicked();
  const ::autofill_assistant::OnTextLinkClickedProto& on_text_link_clicked() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OnTextLinkClickedProto* release_on_text_link_clicked();
  ::autofill_assistant::OnTextLinkClickedProto* mutable_on_text_link_clicked();
  void set_allocated_on_text_link_clicked(::autofill_assistant::OnTextLinkClickedProto* on_text_link_clicked);
  private:
  const ::autofill_assistant::OnTextLinkClickedProto& _internal_on_text_link_clicked() const;
  ::autofill_assistant::OnTextLinkClickedProto* _internal_mutable_on_text_link_clicked();
  public:
  void unsafe_arena_set_allocated_on_text_link_clicked(
      ::autofill_assistant::OnTextLinkClickedProto* on_text_link_clicked);
  ::autofill_assistant::OnTextLinkClickedProto* unsafe_arena_release_on_text_link_clicked();

  // .autofill_assistant.OnPopupDismissedProto on_popup_dismissed = 5;
  bool has_on_popup_dismissed() const;
  private:
  bool _internal_has_on_popup_dismissed() const;
  public:
  void clear_on_popup_dismissed();
  const ::autofill_assistant::OnPopupDismissedProto& on_popup_dismissed() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OnPopupDismissedProto* release_on_popup_dismissed();
  ::autofill_assistant::OnPopupDismissedProto* mutable_on_popup_dismissed();
  void set_allocated_on_popup_dismissed(::autofill_assistant::OnPopupDismissedProto* on_popup_dismissed);
  private:
  const ::autofill_assistant::OnPopupDismissedProto& _internal_on_popup_dismissed() const;
  ::autofill_assistant::OnPopupDismissedProto* _internal_mutable_on_popup_dismissed();
  public:
  void unsafe_arena_set_allocated_on_popup_dismissed(
      ::autofill_assistant::OnPopupDismissedProto* on_popup_dismissed);
  ::autofill_assistant::OnPopupDismissedProto* unsafe_arena_release_on_popup_dismissed();

  // .autofill_assistant.OnViewContainerClearedProto on_view_container_cleared = 6;
  bool has_on_view_container_cleared() const;
  private:
  bool _internal_has_on_view_container_cleared() const;
  public:
  void clear_on_view_container_cleared();
  const ::autofill_assistant::OnViewContainerClearedProto& on_view_container_cleared() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OnViewContainerClearedProto* release_on_view_container_cleared();
  ::autofill_assistant::OnViewContainerClearedProto* mutable_on_view_container_cleared();
  void set_allocated_on_view_container_cleared(::autofill_assistant::OnViewContainerClearedProto* on_view_container_cleared);
  private:
  const ::autofill_assistant::OnViewContainerClearedProto& _internal_on_view_container_cleared() const;
  ::autofill_assistant::OnViewContainerClearedProto* _internal_mutable_on_view_container_cleared();
  public:
  void unsafe_arena_set_allocated_on_view_container_cleared(
      ::autofill_assistant::OnViewContainerClearedProto* on_view_container_cleared);
  ::autofill_assistant::OnViewContainerClearedProto* unsafe_arena_release_on_view_container_cleared();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.EventProto)
 private:
  class _Internal;
  void set_has_on_value_changed();
  void set_has_on_view_clicked();
  void set_has_on_user_action_called();
  void set_has_on_text_link_clicked();
  void set_has_on_popup_dismissed();
  void set_has_on_view_container_cleared();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::OnModelValueChangedEventProto* on_value_changed_;
    ::autofill_assistant::OnViewClickedEventProto* on_view_clicked_;
    ::autofill_assistant::OnUserActionCalled* on_user_action_called_;
    ::autofill_assistant::OnTextLinkClickedProto* on_text_link_clicked_;
    ::autofill_assistant::OnPopupDismissedProto* on_popup_dismissed_;
    ::autofill_assistant::OnViewContainerClearedProto* on_view_container_cleared_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class OnModelValueChangedEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OnModelValueChangedEventProto) */ {
 public:
  inline OnModelValueChangedEventProto() : OnModelValueChangedEventProto(nullptr) {}
  ~OnModelValueChangedEventProto() override;
  explicit PROTOBUF_CONSTEXPR OnModelValueChangedEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnModelValueChangedEventProto(const OnModelValueChangedEventProto& from);
  OnModelValueChangedEventProto(OnModelValueChangedEventProto&& from) noexcept
    : OnModelValueChangedEventProto() {
    *this = ::std::move(from);
  }

  inline OnModelValueChangedEventProto& operator=(const OnModelValueChangedEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnModelValueChangedEventProto& operator=(OnModelValueChangedEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OnModelValueChangedEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnModelValueChangedEventProto* internal_default_instance() {
    return reinterpret_cast<const OnModelValueChangedEventProto*>(
               &_OnModelValueChangedEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OnModelValueChangedEventProto& a, OnModelValueChangedEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OnModelValueChangedEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnModelValueChangedEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnModelValueChangedEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnModelValueChangedEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OnModelValueChangedEventProto& from);
  void MergeFrom(const OnModelValueChangedEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnModelValueChangedEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OnModelValueChangedEventProto";
  }
  protected:
  explicit OnModelValueChangedEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdentifierFieldNumber = 1,
  };
  // optional string model_identifier = 1;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.OnModelValueChangedEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class OnViewClickedEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OnViewClickedEventProto) */ {
 public:
  inline OnViewClickedEventProto() : OnViewClickedEventProto(nullptr) {}
  ~OnViewClickedEventProto() override;
  explicit PROTOBUF_CONSTEXPR OnViewClickedEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnViewClickedEventProto(const OnViewClickedEventProto& from);
  OnViewClickedEventProto(OnViewClickedEventProto&& from) noexcept
    : OnViewClickedEventProto() {
    *this = ::std::move(from);
  }

  inline OnViewClickedEventProto& operator=(const OnViewClickedEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnViewClickedEventProto& operator=(OnViewClickedEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OnViewClickedEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnViewClickedEventProto* internal_default_instance() {
    return reinterpret_cast<const OnViewClickedEventProto*>(
               &_OnViewClickedEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OnViewClickedEventProto& a, OnViewClickedEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OnViewClickedEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnViewClickedEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnViewClickedEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnViewClickedEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OnViewClickedEventProto& from);
  void MergeFrom(const OnViewClickedEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnViewClickedEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OnViewClickedEventProto";
  }
  protected:
  explicit OnViewClickedEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewIdentifierFieldNumber = 1,
  };
  // optional string view_identifier = 1;
  bool has_view_identifier() const;
  private:
  bool _internal_has_view_identifier() const;
  public:
  void clear_view_identifier();
  const std::string& view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_identifier();
  PROTOBUF_NODISCARD std::string* release_view_identifier();
  void set_allocated_view_identifier(std::string* view_identifier);
  private:
  const std::string& _internal_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_identifier(const std::string& value);
  std::string* _internal_mutable_view_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.OnViewClickedEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class OnUserActionCalled final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OnUserActionCalled) */ {
 public:
  inline OnUserActionCalled() : OnUserActionCalled(nullptr) {}
  ~OnUserActionCalled() override;
  explicit PROTOBUF_CONSTEXPR OnUserActionCalled(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnUserActionCalled(const OnUserActionCalled& from);
  OnUserActionCalled(OnUserActionCalled&& from) noexcept
    : OnUserActionCalled() {
    *this = ::std::move(from);
  }

  inline OnUserActionCalled& operator=(const OnUserActionCalled& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnUserActionCalled& operator=(OnUserActionCalled&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OnUserActionCalled& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnUserActionCalled* internal_default_instance() {
    return reinterpret_cast<const OnUserActionCalled*>(
               &_OnUserActionCalled_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OnUserActionCalled& a, OnUserActionCalled& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OnUserActionCalled* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnUserActionCalled* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnUserActionCalled* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnUserActionCalled>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OnUserActionCalled& from);
  void MergeFrom(const OnUserActionCalled& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnUserActionCalled* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OnUserActionCalled";
  }
  protected:
  explicit OnUserActionCalled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserActionIdentifierFieldNumber = 1,
  };
  // optional string user_action_identifier = 1;
  bool has_user_action_identifier() const;
  private:
  bool _internal_has_user_action_identifier() const;
  public:
  void clear_user_action_identifier();
  const std::string& user_action_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_action_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_action_identifier();
  PROTOBUF_NODISCARD std::string* release_user_action_identifier();
  void set_allocated_user_action_identifier(std::string* user_action_identifier);
  private:
  const std::string& _internal_user_action_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_action_identifier(const std::string& value);
  std::string* _internal_mutable_user_action_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.OnUserActionCalled)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_action_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class OnTextLinkClickedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OnTextLinkClickedProto) */ {
 public:
  inline OnTextLinkClickedProto() : OnTextLinkClickedProto(nullptr) {}
  ~OnTextLinkClickedProto() override;
  explicit PROTOBUF_CONSTEXPR OnTextLinkClickedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnTextLinkClickedProto(const OnTextLinkClickedProto& from);
  OnTextLinkClickedProto(OnTextLinkClickedProto&& from) noexcept
    : OnTextLinkClickedProto() {
    *this = ::std::move(from);
  }

  inline OnTextLinkClickedProto& operator=(const OnTextLinkClickedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnTextLinkClickedProto& operator=(OnTextLinkClickedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OnTextLinkClickedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnTextLinkClickedProto* internal_default_instance() {
    return reinterpret_cast<const OnTextLinkClickedProto*>(
               &_OnTextLinkClickedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OnTextLinkClickedProto& a, OnTextLinkClickedProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OnTextLinkClickedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnTextLinkClickedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnTextLinkClickedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnTextLinkClickedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OnTextLinkClickedProto& from);
  void MergeFrom(const OnTextLinkClickedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnTextLinkClickedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OnTextLinkClickedProto";
  }
  protected:
  explicit OnTextLinkClickedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextLinkFieldNumber = 1,
  };
  // optional int32 text_link = 1;
  bool has_text_link() const;
  private:
  bool _internal_has_text_link() const;
  public:
  void clear_text_link();
  int32_t text_link() const;
  void set_text_link(int32_t value);
  private:
  int32_t _internal_text_link() const;
  void _internal_set_text_link(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.OnTextLinkClickedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t text_link_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class OnPopupDismissedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OnPopupDismissedProto) */ {
 public:
  inline OnPopupDismissedProto() : OnPopupDismissedProto(nullptr) {}
  ~OnPopupDismissedProto() override;
  explicit PROTOBUF_CONSTEXPR OnPopupDismissedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnPopupDismissedProto(const OnPopupDismissedProto& from);
  OnPopupDismissedProto(OnPopupDismissedProto&& from) noexcept
    : OnPopupDismissedProto() {
    *this = ::std::move(from);
  }

  inline OnPopupDismissedProto& operator=(const OnPopupDismissedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnPopupDismissedProto& operator=(OnPopupDismissedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OnPopupDismissedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnPopupDismissedProto* internal_default_instance() {
    return reinterpret_cast<const OnPopupDismissedProto*>(
               &_OnPopupDismissedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OnPopupDismissedProto& a, OnPopupDismissedProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OnPopupDismissedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnPopupDismissedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnPopupDismissedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnPopupDismissedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OnPopupDismissedProto& from);
  void MergeFrom(const OnPopupDismissedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnPopupDismissedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OnPopupDismissedProto";
  }
  protected:
  explicit OnPopupDismissedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPopupIdentifierFieldNumber = 1,
  };
  // optional string popup_identifier = 1;
  bool has_popup_identifier() const;
  private:
  bool _internal_has_popup_identifier() const;
  public:
  void clear_popup_identifier();
  const std::string& popup_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_popup_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_popup_identifier();
  PROTOBUF_NODISCARD std::string* release_popup_identifier();
  void set_allocated_popup_identifier(std::string* popup_identifier);
  private:
  const std::string& _internal_popup_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_popup_identifier(const std::string& value);
  std::string* _internal_mutable_popup_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.OnPopupDismissedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr popup_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class OnViewContainerClearedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OnViewContainerClearedProto) */ {
 public:
  inline OnViewContainerClearedProto() : OnViewContainerClearedProto(nullptr) {}
  ~OnViewContainerClearedProto() override;
  explicit PROTOBUF_CONSTEXPR OnViewContainerClearedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnViewContainerClearedProto(const OnViewContainerClearedProto& from);
  OnViewContainerClearedProto(OnViewContainerClearedProto&& from) noexcept
    : OnViewContainerClearedProto() {
    *this = ::std::move(from);
  }

  inline OnViewContainerClearedProto& operator=(const OnViewContainerClearedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnViewContainerClearedProto& operator=(OnViewContainerClearedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OnViewContainerClearedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnViewContainerClearedProto* internal_default_instance() {
    return reinterpret_cast<const OnViewContainerClearedProto*>(
               &_OnViewContainerClearedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OnViewContainerClearedProto& a, OnViewContainerClearedProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OnViewContainerClearedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnViewContainerClearedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnViewContainerClearedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnViewContainerClearedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OnViewContainerClearedProto& from);
  void MergeFrom(const OnViewContainerClearedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnViewContainerClearedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OnViewContainerClearedProto";
  }
  protected:
  explicit OnViewContainerClearedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewIdentifierFieldNumber = 1,
  };
  // optional string view_identifier = 1;
  bool has_view_identifier() const;
  private:
  bool _internal_has_view_identifier() const;
  public:
  void clear_view_identifier();
  const std::string& view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_identifier();
  PROTOBUF_NODISCARD std::string* release_view_identifier();
  void set_allocated_view_identifier(std::string* view_identifier);
  private:
  const std::string& _internal_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_identifier(const std::string& value);
  std::string* _internal_mutable_view_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.OnViewContainerClearedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class SetModelValueProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetModelValueProto) */ {
 public:
  inline SetModelValueProto() : SetModelValueProto(nullptr) {}
  ~SetModelValueProto() override;
  explicit PROTOBUF_CONSTEXPR SetModelValueProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetModelValueProto(const SetModelValueProto& from);
  SetModelValueProto(SetModelValueProto&& from) noexcept
    : SetModelValueProto() {
    *this = ::std::move(from);
  }

  inline SetModelValueProto& operator=(const SetModelValueProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetModelValueProto& operator=(SetModelValueProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetModelValueProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetModelValueProto* internal_default_instance() {
    return reinterpret_cast<const SetModelValueProto*>(
               &_SetModelValueProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetModelValueProto& a, SetModelValueProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetModelValueProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetModelValueProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetModelValueProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetModelValueProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetModelValueProto& from);
  void MergeFrom(const SetModelValueProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetModelValueProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetModelValueProto";
  }
  protected:
  explicit SetModelValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdentifierFieldNumber = 1,
    kValueFieldNumber = 3,
  };
  // optional string model_identifier = 1;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueReferenceProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value();
  ::autofill_assistant::ValueReferenceProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueReferenceProto* value);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueReferenceProto* value);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetModelValueProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  ::autofill_assistant::ValueReferenceProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ComputeValueProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ComputeValueProto) */ {
 public:
  inline ComputeValueProto() : ComputeValueProto(nullptr) {}
  ~ComputeValueProto() override;
  explicit PROTOBUF_CONSTEXPR ComputeValueProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputeValueProto(const ComputeValueProto& from);
  ComputeValueProto(ComputeValueProto&& from) noexcept
    : ComputeValueProto() {
    *this = ::std::move(from);
  }

  inline ComputeValueProto& operator=(const ComputeValueProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputeValueProto& operator=(ComputeValueProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ComputeValueProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kBooleanAnd = 2,
    kBooleanOr = 3,
    kBooleanNot = 4,
    kToString = 5,
    kComparison = 6,
    kIntegerSum = 7,
    kCreateCreditCardResponse = 8,
    kCreateLoginOptionResponse = 9,
    kStringEmpty = 10,
    KIND_NOT_SET = 0,
  };

  static inline const ComputeValueProto* internal_default_instance() {
    return reinterpret_cast<const ComputeValueProto*>(
               &_ComputeValueProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ComputeValueProto& a, ComputeValueProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ComputeValueProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputeValueProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputeValueProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputeValueProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ComputeValueProto& from);
  void MergeFrom(const ComputeValueProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputeValueProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ComputeValueProto";
  }
  protected:
  explicit ComputeValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultModelIdentifierFieldNumber = 1,
    kBooleanAndFieldNumber = 2,
    kBooleanOrFieldNumber = 3,
    kBooleanNotFieldNumber = 4,
    kToStringFieldNumber = 5,
    kComparisonFieldNumber = 6,
    kIntegerSumFieldNumber = 7,
    kCreateCreditCardResponseFieldNumber = 8,
    kCreateLoginOptionResponseFieldNumber = 9,
    kStringEmptyFieldNumber = 10,
  };
  // optional string result_model_identifier = 1;
  bool has_result_model_identifier() const;
  private:
  bool _internal_has_result_model_identifier() const;
  public:
  void clear_result_model_identifier();
  const std::string& result_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_model_identifier();
  PROTOBUF_NODISCARD std::string* release_result_model_identifier();
  void set_allocated_result_model_identifier(std::string* result_model_identifier);
  private:
  const std::string& _internal_result_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_model_identifier(const std::string& value);
  std::string* _internal_mutable_result_model_identifier();
  public:

  // .autofill_assistant.BooleanAndProto boolean_and = 2;
  bool has_boolean_and() const;
  private:
  bool _internal_has_boolean_and() const;
  public:
  void clear_boolean_and();
  const ::autofill_assistant::BooleanAndProto& boolean_and() const;
  PROTOBUF_NODISCARD ::autofill_assistant::BooleanAndProto* release_boolean_and();
  ::autofill_assistant::BooleanAndProto* mutable_boolean_and();
  void set_allocated_boolean_and(::autofill_assistant::BooleanAndProto* boolean_and);
  private:
  const ::autofill_assistant::BooleanAndProto& _internal_boolean_and() const;
  ::autofill_assistant::BooleanAndProto* _internal_mutable_boolean_and();
  public:
  void unsafe_arena_set_allocated_boolean_and(
      ::autofill_assistant::BooleanAndProto* boolean_and);
  ::autofill_assistant::BooleanAndProto* unsafe_arena_release_boolean_and();

  // .autofill_assistant.BooleanOrProto boolean_or = 3;
  bool has_boolean_or() const;
  private:
  bool _internal_has_boolean_or() const;
  public:
  void clear_boolean_or();
  const ::autofill_assistant::BooleanOrProto& boolean_or() const;
  PROTOBUF_NODISCARD ::autofill_assistant::BooleanOrProto* release_boolean_or();
  ::autofill_assistant::BooleanOrProto* mutable_boolean_or();
  void set_allocated_boolean_or(::autofill_assistant::BooleanOrProto* boolean_or);
  private:
  const ::autofill_assistant::BooleanOrProto& _internal_boolean_or() const;
  ::autofill_assistant::BooleanOrProto* _internal_mutable_boolean_or();
  public:
  void unsafe_arena_set_allocated_boolean_or(
      ::autofill_assistant::BooleanOrProto* boolean_or);
  ::autofill_assistant::BooleanOrProto* unsafe_arena_release_boolean_or();

  // .autofill_assistant.BooleanNotProto boolean_not = 4;
  bool has_boolean_not() const;
  private:
  bool _internal_has_boolean_not() const;
  public:
  void clear_boolean_not();
  const ::autofill_assistant::BooleanNotProto& boolean_not() const;
  PROTOBUF_NODISCARD ::autofill_assistant::BooleanNotProto* release_boolean_not();
  ::autofill_assistant::BooleanNotProto* mutable_boolean_not();
  void set_allocated_boolean_not(::autofill_assistant::BooleanNotProto* boolean_not);
  private:
  const ::autofill_assistant::BooleanNotProto& _internal_boolean_not() const;
  ::autofill_assistant::BooleanNotProto* _internal_mutable_boolean_not();
  public:
  void unsafe_arena_set_allocated_boolean_not(
      ::autofill_assistant::BooleanNotProto* boolean_not);
  ::autofill_assistant::BooleanNotProto* unsafe_arena_release_boolean_not();

  // .autofill_assistant.ToStringProto to_string = 5;
  bool has_to_string() const;
  private:
  bool _internal_has_to_string() const;
  public:
  void clear_to_string();
  const ::autofill_assistant::ToStringProto& to_string() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ToStringProto* release_to_string();
  ::autofill_assistant::ToStringProto* mutable_to_string();
  void set_allocated_to_string(::autofill_assistant::ToStringProto* to_string);
  private:
  const ::autofill_assistant::ToStringProto& _internal_to_string() const;
  ::autofill_assistant::ToStringProto* _internal_mutable_to_string();
  public:
  void unsafe_arena_set_allocated_to_string(
      ::autofill_assistant::ToStringProto* to_string);
  ::autofill_assistant::ToStringProto* unsafe_arena_release_to_string();

  // .autofill_assistant.ValueComparisonProto comparison = 6;
  bool has_comparison() const;
  private:
  bool _internal_has_comparison() const;
  public:
  void clear_comparison();
  const ::autofill_assistant::ValueComparisonProto& comparison() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueComparisonProto* release_comparison();
  ::autofill_assistant::ValueComparisonProto* mutable_comparison();
  void set_allocated_comparison(::autofill_assistant::ValueComparisonProto* comparison);
  private:
  const ::autofill_assistant::ValueComparisonProto& _internal_comparison() const;
  ::autofill_assistant::ValueComparisonProto* _internal_mutable_comparison();
  public:
  void unsafe_arena_set_allocated_comparison(
      ::autofill_assistant::ValueComparisonProto* comparison);
  ::autofill_assistant::ValueComparisonProto* unsafe_arena_release_comparison();

  // .autofill_assistant.IntegerSumProto integer_sum = 7;
  bool has_integer_sum() const;
  private:
  bool _internal_has_integer_sum() const;
  public:
  void clear_integer_sum();
  const ::autofill_assistant::IntegerSumProto& integer_sum() const;
  PROTOBUF_NODISCARD ::autofill_assistant::IntegerSumProto* release_integer_sum();
  ::autofill_assistant::IntegerSumProto* mutable_integer_sum();
  void set_allocated_integer_sum(::autofill_assistant::IntegerSumProto* integer_sum);
  private:
  const ::autofill_assistant::IntegerSumProto& _internal_integer_sum() const;
  ::autofill_assistant::IntegerSumProto* _internal_mutable_integer_sum();
  public:
  void unsafe_arena_set_allocated_integer_sum(
      ::autofill_assistant::IntegerSumProto* integer_sum);
  ::autofill_assistant::IntegerSumProto* unsafe_arena_release_integer_sum();

  // .autofill_assistant.CreateCreditCardResponseProto create_credit_card_response = 8;
  bool has_create_credit_card_response() const;
  private:
  bool _internal_has_create_credit_card_response() const;
  public:
  void clear_create_credit_card_response();
  const ::autofill_assistant::CreateCreditCardResponseProto& create_credit_card_response() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CreateCreditCardResponseProto* release_create_credit_card_response();
  ::autofill_assistant::CreateCreditCardResponseProto* mutable_create_credit_card_response();
  void set_allocated_create_credit_card_response(::autofill_assistant::CreateCreditCardResponseProto* create_credit_card_response);
  private:
  const ::autofill_assistant::CreateCreditCardResponseProto& _internal_create_credit_card_response() const;
  ::autofill_assistant::CreateCreditCardResponseProto* _internal_mutable_create_credit_card_response();
  public:
  void unsafe_arena_set_allocated_create_credit_card_response(
      ::autofill_assistant::CreateCreditCardResponseProto* create_credit_card_response);
  ::autofill_assistant::CreateCreditCardResponseProto* unsafe_arena_release_create_credit_card_response();

  // .autofill_assistant.CreateLoginOptionResponseProto create_login_option_response = 9;
  bool has_create_login_option_response() const;
  private:
  bool _internal_has_create_login_option_response() const;
  public:
  void clear_create_login_option_response();
  const ::autofill_assistant::CreateLoginOptionResponseProto& create_login_option_response() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CreateLoginOptionResponseProto* release_create_login_option_response();
  ::autofill_assistant::CreateLoginOptionResponseProto* mutable_create_login_option_response();
  void set_allocated_create_login_option_response(::autofill_assistant::CreateLoginOptionResponseProto* create_login_option_response);
  private:
  const ::autofill_assistant::CreateLoginOptionResponseProto& _internal_create_login_option_response() const;
  ::autofill_assistant::CreateLoginOptionResponseProto* _internal_mutable_create_login_option_response();
  public:
  void unsafe_arena_set_allocated_create_login_option_response(
      ::autofill_assistant::CreateLoginOptionResponseProto* create_login_option_response);
  ::autofill_assistant::CreateLoginOptionResponseProto* unsafe_arena_release_create_login_option_response();

  // .autofill_assistant.StringEmptyProto string_empty = 10;
  bool has_string_empty() const;
  private:
  bool _internal_has_string_empty() const;
  public:
  void clear_string_empty();
  const ::autofill_assistant::StringEmptyProto& string_empty() const;
  PROTOBUF_NODISCARD ::autofill_assistant::StringEmptyProto* release_string_empty();
  ::autofill_assistant::StringEmptyProto* mutable_string_empty();
  void set_allocated_string_empty(::autofill_assistant::StringEmptyProto* string_empty);
  private:
  const ::autofill_assistant::StringEmptyProto& _internal_string_empty() const;
  ::autofill_assistant::StringEmptyProto* _internal_mutable_string_empty();
  public:
  void unsafe_arena_set_allocated_string_empty(
      ::autofill_assistant::StringEmptyProto* string_empty);
  ::autofill_assistant::StringEmptyProto* unsafe_arena_release_string_empty();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ComputeValueProto)
 private:
  class _Internal;
  void set_has_boolean_and();
  void set_has_boolean_or();
  void set_has_boolean_not();
  void set_has_to_string();
  void set_has_comparison();
  void set_has_integer_sum();
  void set_has_create_credit_card_response();
  void set_has_create_login_option_response();
  void set_has_string_empty();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_model_identifier_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::BooleanAndProto* boolean_and_;
    ::autofill_assistant::BooleanOrProto* boolean_or_;
    ::autofill_assistant::BooleanNotProto* boolean_not_;
    ::autofill_assistant::ToStringProto* to_string_;
    ::autofill_assistant::ValueComparisonProto* comparison_;
    ::autofill_assistant::IntegerSumProto* integer_sum_;
    ::autofill_assistant::CreateCreditCardResponseProto* create_credit_card_response_;
    ::autofill_assistant::CreateLoginOptionResponseProto* create_login_option_response_;
    ::autofill_assistant::StringEmptyProto* string_empty_;
  } kind_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class BooleanAndProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.BooleanAndProto) */ {
 public:
  inline BooleanAndProto() : BooleanAndProto(nullptr) {}
  ~BooleanAndProto() override;
  explicit PROTOBUF_CONSTEXPR BooleanAndProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BooleanAndProto(const BooleanAndProto& from);
  BooleanAndProto(BooleanAndProto&& from) noexcept
    : BooleanAndProto() {
    *this = ::std::move(from);
  }

  inline BooleanAndProto& operator=(const BooleanAndProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanAndProto& operator=(BooleanAndProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BooleanAndProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanAndProto* internal_default_instance() {
    return reinterpret_cast<const BooleanAndProto*>(
               &_BooleanAndProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BooleanAndProto& a, BooleanAndProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BooleanAndProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanAndProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanAndProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BooleanAndProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BooleanAndProto& from);
  void MergeFrom(const BooleanAndProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BooleanAndProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.BooleanAndProto";
  }
  protected:
  explicit BooleanAndProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
  };
  // repeated .autofill_assistant.ValueReferenceProto values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::ValueReferenceProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >*
      mutable_values();
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_values(int index) const;
  ::autofill_assistant::ValueReferenceProto* _internal_add_values();
  public:
  const ::autofill_assistant::ValueReferenceProto& values(int index) const;
  ::autofill_assistant::ValueReferenceProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.BooleanAndProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class BooleanOrProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.BooleanOrProto) */ {
 public:
  inline BooleanOrProto() : BooleanOrProto(nullptr) {}
  ~BooleanOrProto() override;
  explicit PROTOBUF_CONSTEXPR BooleanOrProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BooleanOrProto(const BooleanOrProto& from);
  BooleanOrProto(BooleanOrProto&& from) noexcept
    : BooleanOrProto() {
    *this = ::std::move(from);
  }

  inline BooleanOrProto& operator=(const BooleanOrProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanOrProto& operator=(BooleanOrProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BooleanOrProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanOrProto* internal_default_instance() {
    return reinterpret_cast<const BooleanOrProto*>(
               &_BooleanOrProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BooleanOrProto& a, BooleanOrProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BooleanOrProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanOrProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanOrProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BooleanOrProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BooleanOrProto& from);
  void MergeFrom(const BooleanOrProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BooleanOrProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.BooleanOrProto";
  }
  protected:
  explicit BooleanOrProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
  };
  // repeated .autofill_assistant.ValueReferenceProto values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::ValueReferenceProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >*
      mutable_values();
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_values(int index) const;
  ::autofill_assistant::ValueReferenceProto* _internal_add_values();
  public:
  const ::autofill_assistant::ValueReferenceProto& values(int index) const;
  ::autofill_assistant::ValueReferenceProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.BooleanOrProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class BooleanNotProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.BooleanNotProto) */ {
 public:
  inline BooleanNotProto() : BooleanNotProto(nullptr) {}
  ~BooleanNotProto() override;
  explicit PROTOBUF_CONSTEXPR BooleanNotProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BooleanNotProto(const BooleanNotProto& from);
  BooleanNotProto(BooleanNotProto&& from) noexcept
    : BooleanNotProto() {
    *this = ::std::move(from);
  }

  inline BooleanNotProto& operator=(const BooleanNotProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanNotProto& operator=(BooleanNotProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BooleanNotProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanNotProto* internal_default_instance() {
    return reinterpret_cast<const BooleanNotProto*>(
               &_BooleanNotProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BooleanNotProto& a, BooleanNotProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BooleanNotProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanNotProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanNotProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BooleanNotProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BooleanNotProto& from);
  void MergeFrom(const BooleanNotProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BooleanNotProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.BooleanNotProto";
  }
  protected:
  explicit BooleanNotProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
  };
  // optional .autofill_assistant.ValueReferenceProto value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueReferenceProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value();
  ::autofill_assistant::ValueReferenceProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueReferenceProto* value);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueReferenceProto* value);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.BooleanNotProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ToStringProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ToStringProto) */ {
 public:
  inline ToStringProto() : ToStringProto(nullptr) {}
  ~ToStringProto() override;
  explicit PROTOBUF_CONSTEXPR ToStringProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToStringProto(const ToStringProto& from);
  ToStringProto(ToStringProto&& from) noexcept
    : ToStringProto() {
    *this = ::std::move(from);
  }

  inline ToStringProto& operator=(const ToStringProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToStringProto& operator=(ToStringProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToStringProto& default_instance() {
    return *internal_default_instance();
  }
  enum FormatOptionsCase {
    kDateFormat = 2,
    kAutofillFormat = 4,
    FORMAT_OPTIONS_NOT_SET = 0,
  };

  static inline const ToStringProto* internal_default_instance() {
    return reinterpret_cast<const ToStringProto*>(
               &_ToStringProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ToStringProto& a, ToStringProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ToStringProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToStringProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToStringProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToStringProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ToStringProto& from);
  void MergeFrom(const ToStringProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToStringProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ToStringProto";
  }
  protected:
  explicit ToStringProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kDateFormatFieldNumber = 2,
    kAutofillFormatFieldNumber = 4,
  };
  // optional .autofill_assistant.ValueReferenceProto value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueReferenceProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value();
  ::autofill_assistant::ValueReferenceProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueReferenceProto* value);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueReferenceProto* value);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value();

  // .autofill_assistant.DateFormatProto date_format = 2;
  bool has_date_format() const;
  private:
  bool _internal_has_date_format() const;
  public:
  void clear_date_format();
  const ::autofill_assistant::DateFormatProto& date_format() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DateFormatProto* release_date_format();
  ::autofill_assistant::DateFormatProto* mutable_date_format();
  void set_allocated_date_format(::autofill_assistant::DateFormatProto* date_format);
  private:
  const ::autofill_assistant::DateFormatProto& _internal_date_format() const;
  ::autofill_assistant::DateFormatProto* _internal_mutable_date_format();
  public:
  void unsafe_arena_set_allocated_date_format(
      ::autofill_assistant::DateFormatProto* date_format);
  ::autofill_assistant::DateFormatProto* unsafe_arena_release_date_format();

  // .autofill_assistant.AutofillFormatProto autofill_format = 4;
  bool has_autofill_format() const;
  private:
  bool _internal_has_autofill_format() const;
  public:
  void clear_autofill_format();
  const ::autofill_assistant::AutofillFormatProto& autofill_format() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillFormatProto* release_autofill_format();
  ::autofill_assistant::AutofillFormatProto* mutable_autofill_format();
  void set_allocated_autofill_format(::autofill_assistant::AutofillFormatProto* autofill_format);
  private:
  const ::autofill_assistant::AutofillFormatProto& _internal_autofill_format() const;
  ::autofill_assistant::AutofillFormatProto* _internal_mutable_autofill_format();
  public:
  void unsafe_arena_set_allocated_autofill_format(
      ::autofill_assistant::AutofillFormatProto* autofill_format);
  ::autofill_assistant::AutofillFormatProto* unsafe_arena_release_autofill_format();

  void clear_format_options();
  FormatOptionsCase format_options_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ToStringProto)
 private:
  class _Internal;
  void set_has_date_format();
  void set_has_autofill_format();

  inline bool has_format_options() const;
  inline void clear_has_format_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* value_;
  union FormatOptionsUnion {
    constexpr FormatOptionsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::DateFormatProto* date_format_;
    ::autofill_assistant::AutofillFormatProto* autofill_format_;
  } format_options_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class DateFormatProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DateFormatProto) */ {
 public:
  inline DateFormatProto() : DateFormatProto(nullptr) {}
  ~DateFormatProto() override;
  explicit PROTOBUF_CONSTEXPR DateFormatProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateFormatProto(const DateFormatProto& from);
  DateFormatProto(DateFormatProto&& from) noexcept
    : DateFormatProto() {
    *this = ::std::move(from);
  }

  inline DateFormatProto& operator=(const DateFormatProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateFormatProto& operator=(DateFormatProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DateFormatProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateFormatProto* internal_default_instance() {
    return reinterpret_cast<const DateFormatProto*>(
               &_DateFormatProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DateFormatProto& a, DateFormatProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DateFormatProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateFormatProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateFormatProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateFormatProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DateFormatProto& from);
  void MergeFrom(const DateFormatProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DateFormatProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DateFormatProto";
  }
  protected:
  explicit DateFormatProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDateFormatFieldNumber = 1,
  };
  // optional string date_format = 1;
  bool has_date_format() const;
  private:
  bool _internal_has_date_format() const;
  public:
  void clear_date_format();
  const std::string& date_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_format();
  PROTOBUF_NODISCARD std::string* release_date_format();
  void set_allocated_date_format(std::string* date_format);
  private:
  const std::string& _internal_date_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_format(const std::string& value);
  std::string* _internal_mutable_date_format();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DateFormatProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_format_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class AutofillFormatProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillFormatProto) */ {
 public:
  inline AutofillFormatProto() : AutofillFormatProto(nullptr) {}
  ~AutofillFormatProto() override;
  explicit PROTOBUF_CONSTEXPR AutofillFormatProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillFormatProto(const AutofillFormatProto& from);
  AutofillFormatProto(AutofillFormatProto&& from) noexcept
    : AutofillFormatProto() {
    *this = ::std::move(from);
  }

  inline AutofillFormatProto& operator=(const AutofillFormatProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillFormatProto& operator=(AutofillFormatProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillFormatProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillFormatProto* internal_default_instance() {
    return reinterpret_cast<const AutofillFormatProto*>(
               &_AutofillFormatProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AutofillFormatProto& a, AutofillFormatProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillFormatProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillFormatProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillFormatProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillFormatProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillFormatProto& from);
  void MergeFrom(const AutofillFormatProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillFormatProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillFormatProto";
  }
  protected:
  explicit AutofillFormatProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillFormatProto_AutofillAssistantCustomField AutofillAssistantCustomField;
  static constexpr AutofillAssistantCustomField UNDEFINED =
    AutofillFormatProto_AutofillAssistantCustomField_UNDEFINED;
  static constexpr AutofillAssistantCustomField CREDIT_CARD_VERIFICATION_CODE =
    AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_VERIFICATION_CODE;
  static constexpr AutofillAssistantCustomField CREDIT_CARD_NETWORK =
    AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NETWORK;
  static constexpr AutofillAssistantCustomField CREDIT_CARD_RAW_NUMBER =
    AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_RAW_NUMBER;
  static constexpr AutofillAssistantCustomField CREDIT_CARD_NUMBER_LAST_FOUR_DIGITS =
    AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NUMBER_LAST_FOUR_DIGITS;
  static constexpr AutofillAssistantCustomField CREDIT_CARD_NETWORK_FOR_DISPLAY =
    AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NETWORK_FOR_DISPLAY;
  static constexpr AutofillAssistantCustomField ADDRESS_HOME_STATE_NAME =
    AutofillFormatProto_AutofillAssistantCustomField_ADDRESS_HOME_STATE_NAME;
  static constexpr AutofillAssistantCustomField CREDIT_CARD_NON_PADDED_EXP_MONTH =
    AutofillFormatProto_AutofillAssistantCustomField_CREDIT_CARD_NON_PADDED_EXP_MONTH;
  static constexpr AutofillAssistantCustomField ADDRESS_HOME_COUNTRY_CODE =
    AutofillFormatProto_AutofillAssistantCustomField_ADDRESS_HOME_COUNTRY_CODE;
  static inline bool AutofillAssistantCustomField_IsValid(int value) {
    return AutofillFormatProto_AutofillAssistantCustomField_IsValid(value);
  }
  static constexpr AutofillAssistantCustomField AutofillAssistantCustomField_MIN =
    AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_MIN;
  static constexpr AutofillAssistantCustomField AutofillAssistantCustomField_MAX =
    AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_MAX;
  static constexpr int AutofillAssistantCustomField_ARRAYSIZE =
    AutofillFormatProto_AutofillAssistantCustomField_AutofillAssistantCustomField_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AutofillAssistantCustomField_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AutofillAssistantCustomField>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AutofillAssistantCustomField_Name.");
    return AutofillFormatProto_AutofillAssistantCustomField_Name(enum_t_value);
  }
  static inline bool AutofillAssistantCustomField_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AutofillAssistantCustomField* value) {
    return AutofillFormatProto_AutofillAssistantCustomField_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 2,
    kValueExpressionFieldNumber = 3,
  };
  // optional string locale = 2;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional .autofill_assistant.ValueExpression value_expression = 3;
  bool has_value_expression() const;
  private:
  bool _internal_has_value_expression() const;
  public:
  void clear_value_expression();
  const ::autofill_assistant::ValueExpression& value_expression() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueExpression* release_value_expression();
  ::autofill_assistant::ValueExpression* mutable_value_expression();
  void set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression);
  private:
  const ::autofill_assistant::ValueExpression& _internal_value_expression() const;
  ::autofill_assistant::ValueExpression* _internal_mutable_value_expression();
  public:
  void unsafe_arena_set_allocated_value_expression(
      ::autofill_assistant::ValueExpression* value_expression);
  ::autofill_assistant::ValueExpression* unsafe_arena_release_value_expression();

  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillFormatProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::autofill_assistant::ValueExpression* value_expression_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ValueComparisonProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueComparisonProto) */ {
 public:
  inline ValueComparisonProto() : ValueComparisonProto(nullptr) {}
  ~ValueComparisonProto() override;
  explicit PROTOBUF_CONSTEXPR ValueComparisonProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueComparisonProto(const ValueComparisonProto& from);
  ValueComparisonProto(ValueComparisonProto&& from) noexcept
    : ValueComparisonProto() {
    *this = ::std::move(from);
  }

  inline ValueComparisonProto& operator=(const ValueComparisonProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueComparisonProto& operator=(ValueComparisonProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueComparisonProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueComparisonProto* internal_default_instance() {
    return reinterpret_cast<const ValueComparisonProto*>(
               &_ValueComparisonProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ValueComparisonProto& a, ValueComparisonProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueComparisonProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueComparisonProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueComparisonProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueComparisonProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueComparisonProto& from);
  void MergeFrom(const ValueComparisonProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueComparisonProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueComparisonProto";
  }
  protected:
  explicit ValueComparisonProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ValueComparisonProto_Mode Mode;
  static constexpr Mode UNDEFINED =
    ValueComparisonProto_Mode_UNDEFINED;
  static constexpr Mode LESS =
    ValueComparisonProto_Mode_LESS;
  static constexpr Mode LESS_OR_EQUAL =
    ValueComparisonProto_Mode_LESS_OR_EQUAL;
  static constexpr Mode EQUAL =
    ValueComparisonProto_Mode_EQUAL;
  static constexpr Mode GREATER_OR_EQUAL =
    ValueComparisonProto_Mode_GREATER_OR_EQUAL;
  static constexpr Mode GREATER =
    ValueComparisonProto_Mode_GREATER;
  static constexpr Mode NOT_EQUAL =
    ValueComparisonProto_Mode_NOT_EQUAL;
  static inline bool Mode_IsValid(int value) {
    return ValueComparisonProto_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    ValueComparisonProto_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    ValueComparisonProto_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    ValueComparisonProto_Mode_Mode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return ValueComparisonProto_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return ValueComparisonProto_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueAFieldNumber = 4,
    kValueBFieldNumber = 5,
    kModeFieldNumber = 3,
  };
  // optional .autofill_assistant.ValueReferenceProto value_a = 4;
  bool has_value_a() const;
  private:
  bool _internal_has_value_a() const;
  public:
  void clear_value_a();
  const ::autofill_assistant::ValueReferenceProto& value_a() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value_a();
  ::autofill_assistant::ValueReferenceProto* mutable_value_a();
  void set_allocated_value_a(::autofill_assistant::ValueReferenceProto* value_a);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value_a() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value_a();
  public:
  void unsafe_arena_set_allocated_value_a(
      ::autofill_assistant::ValueReferenceProto* value_a);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value_a();

  // optional .autofill_assistant.ValueReferenceProto value_b = 5;
  bool has_value_b() const;
  private:
  bool _internal_has_value_b() const;
  public:
  void clear_value_b();
  const ::autofill_assistant::ValueReferenceProto& value_b() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value_b();
  ::autofill_assistant::ValueReferenceProto* mutable_value_b();
  void set_allocated_value_b(::autofill_assistant::ValueReferenceProto* value_b);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value_b() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value_b();
  public:
  void unsafe_arena_set_allocated_value_b(
      ::autofill_assistant::ValueReferenceProto* value_b);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value_b();

  // optional .autofill_assistant.ValueComparisonProto.Mode mode = 3;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::autofill_assistant::ValueComparisonProto_Mode mode() const;
  void set_mode(::autofill_assistant::ValueComparisonProto_Mode value);
  private:
  ::autofill_assistant::ValueComparisonProto_Mode _internal_mode() const;
  void _internal_set_mode(::autofill_assistant::ValueComparisonProto_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueComparisonProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* value_a_;
  ::autofill_assistant::ValueReferenceProto* value_b_;
  int mode_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class IntegerSumProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.IntegerSumProto) */ {
 public:
  inline IntegerSumProto() : IntegerSumProto(nullptr) {}
  ~IntegerSumProto() override;
  explicit PROTOBUF_CONSTEXPR IntegerSumProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntegerSumProto(const IntegerSumProto& from);
  IntegerSumProto(IntegerSumProto&& from) noexcept
    : IntegerSumProto() {
    *this = ::std::move(from);
  }

  inline IntegerSumProto& operator=(const IntegerSumProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerSumProto& operator=(IntegerSumProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IntegerSumProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegerSumProto* internal_default_instance() {
    return reinterpret_cast<const IntegerSumProto*>(
               &_IntegerSumProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IntegerSumProto& a, IntegerSumProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(IntegerSumProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerSumProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerSumProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntegerSumProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IntegerSumProto& from);
  void MergeFrom(const IntegerSumProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntegerSumProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.IntegerSumProto";
  }
  protected:
  explicit IntegerSumProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 3,
  };
  // repeated .autofill_assistant.ValueReferenceProto values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::ValueReferenceProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >*
      mutable_values();
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_values(int index) const;
  ::autofill_assistant::ValueReferenceProto* _internal_add_values();
  public:
  const ::autofill_assistant::ValueReferenceProto& values(int index) const;
  ::autofill_assistant::ValueReferenceProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.IntegerSumProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class CreateCreditCardResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CreateCreditCardResponseProto) */ {
 public:
  inline CreateCreditCardResponseProto() : CreateCreditCardResponseProto(nullptr) {}
  ~CreateCreditCardResponseProto() override;
  explicit PROTOBUF_CONSTEXPR CreateCreditCardResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCreditCardResponseProto(const CreateCreditCardResponseProto& from);
  CreateCreditCardResponseProto(CreateCreditCardResponseProto&& from) noexcept
    : CreateCreditCardResponseProto() {
    *this = ::std::move(from);
  }

  inline CreateCreditCardResponseProto& operator=(const CreateCreditCardResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCreditCardResponseProto& operator=(CreateCreditCardResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CreateCreditCardResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCreditCardResponseProto* internal_default_instance() {
    return reinterpret_cast<const CreateCreditCardResponseProto*>(
               &_CreateCreditCardResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateCreditCardResponseProto& a, CreateCreditCardResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreateCreditCardResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCreditCardResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCreditCardResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCreditCardResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreateCreditCardResponseProto& from);
  void MergeFrom(const CreateCreditCardResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateCreditCardResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CreateCreditCardResponseProto";
  }
  protected:
  explicit CreateCreditCardResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional .autofill_assistant.ValueReferenceProto value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueReferenceProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value();
  ::autofill_assistant::ValueReferenceProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueReferenceProto* value);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueReferenceProto* value);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.CreateCreditCardResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class CreateLoginOptionResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CreateLoginOptionResponseProto) */ {
 public:
  inline CreateLoginOptionResponseProto() : CreateLoginOptionResponseProto(nullptr) {}
  ~CreateLoginOptionResponseProto() override;
  explicit PROTOBUF_CONSTEXPR CreateLoginOptionResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateLoginOptionResponseProto(const CreateLoginOptionResponseProto& from);
  CreateLoginOptionResponseProto(CreateLoginOptionResponseProto&& from) noexcept
    : CreateLoginOptionResponseProto() {
    *this = ::std::move(from);
  }

  inline CreateLoginOptionResponseProto& operator=(const CreateLoginOptionResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateLoginOptionResponseProto& operator=(CreateLoginOptionResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CreateLoginOptionResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateLoginOptionResponseProto* internal_default_instance() {
    return reinterpret_cast<const CreateLoginOptionResponseProto*>(
               &_CreateLoginOptionResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateLoginOptionResponseProto& a, CreateLoginOptionResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreateLoginOptionResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateLoginOptionResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateLoginOptionResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateLoginOptionResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreateLoginOptionResponseProto& from);
  void MergeFrom(const CreateLoginOptionResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateLoginOptionResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CreateLoginOptionResponseProto";
  }
  protected:
  explicit CreateLoginOptionResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional .autofill_assistant.ValueReferenceProto value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueReferenceProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value();
  ::autofill_assistant::ValueReferenceProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueReferenceProto* value);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueReferenceProto* value);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.CreateLoginOptionResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class StringEmptyProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.StringEmptyProto) */ {
 public:
  inline StringEmptyProto() : StringEmptyProto(nullptr) {}
  ~StringEmptyProto() override;
  explicit PROTOBUF_CONSTEXPR StringEmptyProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringEmptyProto(const StringEmptyProto& from);
  StringEmptyProto(StringEmptyProto&& from) noexcept
    : StringEmptyProto() {
    *this = ::std::move(from);
  }

  inline StringEmptyProto& operator=(const StringEmptyProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringEmptyProto& operator=(StringEmptyProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StringEmptyProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringEmptyProto* internal_default_instance() {
    return reinterpret_cast<const StringEmptyProto*>(
               &_StringEmptyProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StringEmptyProto& a, StringEmptyProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StringEmptyProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringEmptyProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringEmptyProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringEmptyProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StringEmptyProto& from);
  void MergeFrom(const StringEmptyProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringEmptyProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.StringEmptyProto";
  }
  protected:
  explicit StringEmptyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional .autofill_assistant.ValueReferenceProto value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueReferenceProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_value();
  ::autofill_assistant::ValueReferenceProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueReferenceProto* value);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_value() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueReferenceProto* value);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.StringEmptyProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ShowInfoPopupProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowInfoPopupProto) */ {
 public:
  inline ShowInfoPopupProto() : ShowInfoPopupProto(nullptr) {}
  ~ShowInfoPopupProto() override;
  explicit PROTOBUF_CONSTEXPR ShowInfoPopupProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowInfoPopupProto(const ShowInfoPopupProto& from);
  ShowInfoPopupProto(ShowInfoPopupProto&& from) noexcept
    : ShowInfoPopupProto() {
    *this = ::std::move(from);
  }

  inline ShowInfoPopupProto& operator=(const ShowInfoPopupProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowInfoPopupProto& operator=(ShowInfoPopupProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowInfoPopupProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowInfoPopupProto* internal_default_instance() {
    return reinterpret_cast<const ShowInfoPopupProto*>(
               &_ShowInfoPopupProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ShowInfoPopupProto& a, ShowInfoPopupProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowInfoPopupProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowInfoPopupProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowInfoPopupProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowInfoPopupProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowInfoPopupProto& from);
  void MergeFrom(const ShowInfoPopupProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowInfoPopupProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowInfoPopupProto";
  }
  protected:
  explicit ShowInfoPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoPopupFieldNumber = 1,
  };
  // optional .autofill_assistant.InfoPopupProto info_popup = 1;
  bool has_info_popup() const;
  private:
  bool _internal_has_info_popup() const;
  public:
  void clear_info_popup();
  const ::autofill_assistant::InfoPopupProto& info_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto* release_info_popup();
  ::autofill_assistant::InfoPopupProto* mutable_info_popup();
  void set_allocated_info_popup(::autofill_assistant::InfoPopupProto* info_popup);
  private:
  const ::autofill_assistant::InfoPopupProto& _internal_info_popup() const;
  ::autofill_assistant::InfoPopupProto* _internal_mutable_info_popup();
  public:
  void unsafe_arena_set_allocated_info_popup(
      ::autofill_assistant::InfoPopupProto* info_popup);
  ::autofill_assistant::InfoPopupProto* unsafe_arena_release_info_popup();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowInfoPopupProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::InfoPopupProto* info_popup_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ShowListPopupProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowListPopupProto) */ {
 public:
  inline ShowListPopupProto() : ShowListPopupProto(nullptr) {}
  ~ShowListPopupProto() override;
  explicit PROTOBUF_CONSTEXPR ShowListPopupProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowListPopupProto(const ShowListPopupProto& from);
  ShowListPopupProto(ShowListPopupProto&& from) noexcept
    : ShowListPopupProto() {
    *this = ::std::move(from);
  }

  inline ShowListPopupProto& operator=(const ShowListPopupProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowListPopupProto& operator=(ShowListPopupProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowListPopupProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowListPopupProto* internal_default_instance() {
    return reinterpret_cast<const ShowListPopupProto*>(
               &_ShowListPopupProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ShowListPopupProto& a, ShowListPopupProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowListPopupProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowListPopupProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowListPopupProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowListPopupProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowListPopupProto& from);
  void MergeFrom(const ShowListPopupProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowListPopupProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowListPopupProto";
  }
  protected:
  explicit ShowListPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShowListPopupProto_ItemType ItemType;
  static constexpr ItemType GROUP =
    ShowListPopupProto_ItemType_GROUP;
  static constexpr ItemType DISABLED =
    ShowListPopupProto_ItemType_DISABLED;
  static constexpr ItemType ENABLED =
    ShowListPopupProto_ItemType_ENABLED;
  static inline bool ItemType_IsValid(int value) {
    return ShowListPopupProto_ItemType_IsValid(value);
  }
  static constexpr ItemType ItemType_MIN =
    ShowListPopupProto_ItemType_ItemType_MIN;
  static constexpr ItemType ItemType_MAX =
    ShowListPopupProto_ItemType_ItemType_MAX;
  static constexpr int ItemType_ARRAYSIZE =
    ShowListPopupProto_ItemType_ItemType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ItemType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ItemType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ItemType_Name.");
    return ShowListPopupProto_ItemType_Name(enum_t_value);
  }
  static inline bool ItemType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ItemType* value) {
    return ShowListPopupProto_ItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedItemIndicesModelIdentifierFieldNumber = 3,
    kSelectedItemNamesModelIdentifierFieldNumber = 5,
    kItemNamesFieldNumber = 6,
    kItemTypesFieldNumber = 7,
    kAllowMultiselectFieldNumber = 4,
  };
  // optional string selected_item_indices_model_identifier = 3;
  bool has_selected_item_indices_model_identifier() const;
  private:
  bool _internal_has_selected_item_indices_model_identifier() const;
  public:
  void clear_selected_item_indices_model_identifier();
  const std::string& selected_item_indices_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_item_indices_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_item_indices_model_identifier();
  PROTOBUF_NODISCARD std::string* release_selected_item_indices_model_identifier();
  void set_allocated_selected_item_indices_model_identifier(std::string* selected_item_indices_model_identifier);
  private:
  const std::string& _internal_selected_item_indices_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_item_indices_model_identifier(const std::string& value);
  std::string* _internal_mutable_selected_item_indices_model_identifier();
  public:

  // optional string selected_item_names_model_identifier = 5;
  bool has_selected_item_names_model_identifier() const;
  private:
  bool _internal_has_selected_item_names_model_identifier() const;
  public:
  void clear_selected_item_names_model_identifier();
  const std::string& selected_item_names_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_item_names_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_item_names_model_identifier();
  PROTOBUF_NODISCARD std::string* release_selected_item_names_model_identifier();
  void set_allocated_selected_item_names_model_identifier(std::string* selected_item_names_model_identifier);
  private:
  const std::string& _internal_selected_item_names_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_item_names_model_identifier(const std::string& value);
  std::string* _internal_mutable_selected_item_names_model_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto item_names = 6;
  bool has_item_names() const;
  private:
  bool _internal_has_item_names() const;
  public:
  void clear_item_names();
  const ::autofill_assistant::ValueReferenceProto& item_names() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_item_names();
  ::autofill_assistant::ValueReferenceProto* mutable_item_names();
  void set_allocated_item_names(::autofill_assistant::ValueReferenceProto* item_names);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_item_names() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_item_names();
  public:
  void unsafe_arena_set_allocated_item_names(
      ::autofill_assistant::ValueReferenceProto* item_names);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_item_names();

  // optional .autofill_assistant.ValueReferenceProto item_types = 7;
  bool has_item_types() const;
  private:
  bool _internal_has_item_types() const;
  public:
  void clear_item_types();
  const ::autofill_assistant::ValueReferenceProto& item_types() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_item_types();
  ::autofill_assistant::ValueReferenceProto* mutable_item_types();
  void set_allocated_item_types(::autofill_assistant::ValueReferenceProto* item_types);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_item_types() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_item_types();
  public:
  void unsafe_arena_set_allocated_item_types(
      ::autofill_assistant::ValueReferenceProto* item_types);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_item_types();

  // optional bool allow_multiselect = 4;
  bool has_allow_multiselect() const;
  private:
  bool _internal_has_allow_multiselect() const;
  public:
  void clear_allow_multiselect();
  bool allow_multiselect() const;
  void set_allow_multiselect(bool value);
  private:
  bool _internal_allow_multiselect() const;
  void _internal_set_allow_multiselect(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowListPopupProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_item_indices_model_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_item_names_model_identifier_;
  ::autofill_assistant::ValueReferenceProto* item_names_;
  ::autofill_assistant::ValueReferenceProto* item_types_;
  bool allow_multiselect_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class SetUserActionsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetUserActionsProto) */ {
 public:
  inline SetUserActionsProto() : SetUserActionsProto(nullptr) {}
  ~SetUserActionsProto() override;
  explicit PROTOBUF_CONSTEXPR SetUserActionsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUserActionsProto(const SetUserActionsProto& from);
  SetUserActionsProto(SetUserActionsProto&& from) noexcept
    : SetUserActionsProto() {
    *this = ::std::move(from);
  }

  inline SetUserActionsProto& operator=(const SetUserActionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUserActionsProto& operator=(SetUserActionsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetUserActionsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUserActionsProto* internal_default_instance() {
    return reinterpret_cast<const SetUserActionsProto*>(
               &_SetUserActionsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetUserActionsProto& a, SetUserActionsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetUserActionsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUserActionsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUserActionsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUserActionsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetUserActionsProto& from);
  void MergeFrom(const SetUserActionsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetUserActionsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetUserActionsProto";
  }
  protected:
  explicit SetUserActionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserActionsFieldNumber = 2,
  };
  // optional .autofill_assistant.ValueReferenceProto user_actions = 2;
  bool has_user_actions() const;
  private:
  bool _internal_has_user_actions() const;
  public:
  void clear_user_actions();
  const ::autofill_assistant::ValueReferenceProto& user_actions() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_user_actions();
  ::autofill_assistant::ValueReferenceProto* mutable_user_actions();
  void set_allocated_user_actions(::autofill_assistant::ValueReferenceProto* user_actions);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_user_actions() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_user_actions();
  public:
  void unsafe_arena_set_allocated_user_actions(
      ::autofill_assistant::ValueReferenceProto* user_actions);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_user_actions();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetUserActionsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueReferenceProto* user_actions_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ToggleUserActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ToggleUserActionProto) */ {
 public:
  inline ToggleUserActionProto() : ToggleUserActionProto(nullptr) {}
  ~ToggleUserActionProto() override;
  explicit PROTOBUF_CONSTEXPR ToggleUserActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleUserActionProto(const ToggleUserActionProto& from);
  ToggleUserActionProto(ToggleUserActionProto&& from) noexcept
    : ToggleUserActionProto() {
    *this = ::std::move(from);
  }

  inline ToggleUserActionProto& operator=(const ToggleUserActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleUserActionProto& operator=(ToggleUserActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleUserActionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleUserActionProto* internal_default_instance() {
    return reinterpret_cast<const ToggleUserActionProto*>(
               &_ToggleUserActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ToggleUserActionProto& a, ToggleUserActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ToggleUserActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleUserActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleUserActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleUserActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ToggleUserActionProto& from);
  void MergeFrom(const ToggleUserActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleUserActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ToggleUserActionProto";
  }
  protected:
  explicit ToggleUserActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserActionsModelIdentifierFieldNumber = 1,
    kUserActionIdentifierFieldNumber = 2,
    kEnabledFieldNumber = 4,
  };
  // optional string user_actions_model_identifier = 1;
  bool has_user_actions_model_identifier() const;
  private:
  bool _internal_has_user_actions_model_identifier() const;
  public:
  void clear_user_actions_model_identifier();
  const std::string& user_actions_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_actions_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_actions_model_identifier();
  PROTOBUF_NODISCARD std::string* release_user_actions_model_identifier();
  void set_allocated_user_actions_model_identifier(std::string* user_actions_model_identifier);
  private:
  const std::string& _internal_user_actions_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_actions_model_identifier(const std::string& value);
  std::string* _internal_mutable_user_actions_model_identifier();
  public:

  // optional string user_action_identifier = 2;
  bool has_user_action_identifier() const;
  private:
  bool _internal_has_user_action_identifier() const;
  public:
  void clear_user_action_identifier();
  const std::string& user_action_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_action_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_action_identifier();
  PROTOBUF_NODISCARD std::string* release_user_action_identifier();
  void set_allocated_user_action_identifier(std::string* user_action_identifier);
  private:
  const std::string& _internal_user_action_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_action_identifier(const std::string& value);
  std::string* _internal_mutable_user_action_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto enabled = 4;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  const ::autofill_assistant::ValueReferenceProto& enabled() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_enabled();
  ::autofill_assistant::ValueReferenceProto* mutable_enabled();
  void set_allocated_enabled(::autofill_assistant::ValueReferenceProto* enabled);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_enabled() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_enabled();
  public:
  void unsafe_arena_set_allocated_enabled(
      ::autofill_assistant::ValueReferenceProto* enabled);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_enabled();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ToggleUserActionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_actions_model_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_action_identifier_;
  ::autofill_assistant::ValueReferenceProto* enabled_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class EndActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.EndActionProto) */ {
 public:
  inline EndActionProto() : EndActionProto(nullptr) {}
  ~EndActionProto() override;
  explicit PROTOBUF_CONSTEXPR EndActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EndActionProto(const EndActionProto& from);
  EndActionProto(EndActionProto&& from) noexcept
    : EndActionProto() {
    *this = ::std::move(from);
  }

  inline EndActionProto& operator=(const EndActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndActionProto& operator=(EndActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EndActionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndActionProto* internal_default_instance() {
    return reinterpret_cast<const EndActionProto*>(
               &_EndActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(EndActionProto& a, EndActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EndActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EndActionProto& from);
  void MergeFrom(const EndActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.EndActionProto";
  }
  protected:
  explicit EndActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .autofill_assistant.ProcessedActionStatusProto status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::autofill_assistant::ProcessedActionStatusProto status() const;
  void set_status(::autofill_assistant::ProcessedActionStatusProto value);
  private:
  ::autofill_assistant::ProcessedActionStatusProto _internal_status() const;
  void _internal_set_status(::autofill_assistant::ProcessedActionStatusProto value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.EndActionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ShowCalendarPopupProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowCalendarPopupProto) */ {
 public:
  inline ShowCalendarPopupProto() : ShowCalendarPopupProto(nullptr) {}
  ~ShowCalendarPopupProto() override;
  explicit PROTOBUF_CONSTEXPR ShowCalendarPopupProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowCalendarPopupProto(const ShowCalendarPopupProto& from);
  ShowCalendarPopupProto(ShowCalendarPopupProto&& from) noexcept
    : ShowCalendarPopupProto() {
    *this = ::std::move(from);
  }

  inline ShowCalendarPopupProto& operator=(const ShowCalendarPopupProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowCalendarPopupProto& operator=(ShowCalendarPopupProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowCalendarPopupProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowCalendarPopupProto* internal_default_instance() {
    return reinterpret_cast<const ShowCalendarPopupProto*>(
               &_ShowCalendarPopupProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ShowCalendarPopupProto& a, ShowCalendarPopupProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowCalendarPopupProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowCalendarPopupProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowCalendarPopupProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowCalendarPopupProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowCalendarPopupProto& from);
  void MergeFrom(const ShowCalendarPopupProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowCalendarPopupProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowCalendarPopupProto";
  }
  protected:
  explicit ShowCalendarPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDateModelIdentifierFieldNumber = 1,
    kMinDateFieldNumber = 4,
    kMaxDateFieldNumber = 5,
  };
  // optional string date_model_identifier = 1;
  bool has_date_model_identifier() const;
  private:
  bool _internal_has_date_model_identifier() const;
  public:
  void clear_date_model_identifier();
  const std::string& date_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_model_identifier();
  PROTOBUF_NODISCARD std::string* release_date_model_identifier();
  void set_allocated_date_model_identifier(std::string* date_model_identifier);
  private:
  const std::string& _internal_date_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_model_identifier(const std::string& value);
  std::string* _internal_mutable_date_model_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto min_date = 4;
  bool has_min_date() const;
  private:
  bool _internal_has_min_date() const;
  public:
  void clear_min_date();
  const ::autofill_assistant::ValueReferenceProto& min_date() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_min_date();
  ::autofill_assistant::ValueReferenceProto* mutable_min_date();
  void set_allocated_min_date(::autofill_assistant::ValueReferenceProto* min_date);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_min_date() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_min_date();
  public:
  void unsafe_arena_set_allocated_min_date(
      ::autofill_assistant::ValueReferenceProto* min_date);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_min_date();

  // optional .autofill_assistant.ValueReferenceProto max_date = 5;
  bool has_max_date() const;
  private:
  bool _internal_has_max_date() const;
  public:
  void clear_max_date();
  const ::autofill_assistant::ValueReferenceProto& max_date() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_max_date();
  ::autofill_assistant::ValueReferenceProto* mutable_max_date();
  void set_allocated_max_date(::autofill_assistant::ValueReferenceProto* max_date);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_max_date() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_max_date();
  public:
  void unsafe_arena_set_allocated_max_date(
      ::autofill_assistant::ValueReferenceProto* max_date);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_max_date();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowCalendarPopupProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_model_identifier_;
  ::autofill_assistant::ValueReferenceProto* min_date_;
  ::autofill_assistant::ValueReferenceProto* max_date_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class SetTextProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetTextProto) */ {
 public:
  inline SetTextProto() : SetTextProto(nullptr) {}
  ~SetTextProto() override;
  explicit PROTOBUF_CONSTEXPR SetTextProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTextProto(const SetTextProto& from);
  SetTextProto(SetTextProto&& from) noexcept
    : SetTextProto() {
    *this = ::std::move(from);
  }

  inline SetTextProto& operator=(const SetTextProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTextProto& operator=(SetTextProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetTextProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTextProto* internal_default_instance() {
    return reinterpret_cast<const SetTextProto*>(
               &_SetTextProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SetTextProto& a, SetTextProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetTextProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTextProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTextProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTextProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetTextProto& from);
  void MergeFrom(const SetTextProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetTextProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetTextProto";
  }
  protected:
  explicit SetTextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewIdentifierFieldNumber = 2,
    kTextFieldNumber = 3,
  };
  // optional string view_identifier = 2;
  bool has_view_identifier() const;
  private:
  bool _internal_has_view_identifier() const;
  public:
  void clear_view_identifier();
  const std::string& view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_identifier();
  PROTOBUF_NODISCARD std::string* release_view_identifier();
  void set_allocated_view_identifier(std::string* view_identifier);
  private:
  const std::string& _internal_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_identifier(const std::string& value);
  std::string* _internal_mutable_view_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::autofill_assistant::ValueReferenceProto& text() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_text();
  ::autofill_assistant::ValueReferenceProto* mutable_text();
  void set_allocated_text(::autofill_assistant::ValueReferenceProto* text);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_text() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::autofill_assistant::ValueReferenceProto* text);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_text();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetTextProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_identifier_;
  ::autofill_assistant::ValueReferenceProto* text_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class SetViewVisibilityProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetViewVisibilityProto) */ {
 public:
  inline SetViewVisibilityProto() : SetViewVisibilityProto(nullptr) {}
  ~SetViewVisibilityProto() override;
  explicit PROTOBUF_CONSTEXPR SetViewVisibilityProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetViewVisibilityProto(const SetViewVisibilityProto& from);
  SetViewVisibilityProto(SetViewVisibilityProto&& from) noexcept
    : SetViewVisibilityProto() {
    *this = ::std::move(from);
  }

  inline SetViewVisibilityProto& operator=(const SetViewVisibilityProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetViewVisibilityProto& operator=(SetViewVisibilityProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetViewVisibilityProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetViewVisibilityProto* internal_default_instance() {
    return reinterpret_cast<const SetViewVisibilityProto*>(
               &_SetViewVisibilityProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SetViewVisibilityProto& a, SetViewVisibilityProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetViewVisibilityProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetViewVisibilityProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetViewVisibilityProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetViewVisibilityProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetViewVisibilityProto& from);
  void MergeFrom(const SetViewVisibilityProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetViewVisibilityProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetViewVisibilityProto";
  }
  protected:
  explicit SetViewVisibilityProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewIdentifierFieldNumber = 1,
    kVisibleFieldNumber = 3,
  };
  // optional string view_identifier = 1;
  bool has_view_identifier() const;
  private:
  bool _internal_has_view_identifier() const;
  public:
  void clear_view_identifier();
  const std::string& view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_identifier();
  PROTOBUF_NODISCARD std::string* release_view_identifier();
  void set_allocated_view_identifier(std::string* view_identifier);
  private:
  const std::string& _internal_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_identifier(const std::string& value);
  std::string* _internal_mutable_view_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto visible = 3;
  bool has_visible() const;
  private:
  bool _internal_has_visible() const;
  public:
  void clear_visible();
  const ::autofill_assistant::ValueReferenceProto& visible() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_visible();
  ::autofill_assistant::ValueReferenceProto* mutable_visible();
  void set_allocated_visible(::autofill_assistant::ValueReferenceProto* visible);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_visible() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_visible();
  public:
  void unsafe_arena_set_allocated_visible(
      ::autofill_assistant::ValueReferenceProto* visible);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_visible();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetViewVisibilityProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_identifier_;
  ::autofill_assistant::ValueReferenceProto* visible_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiPopupProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiPopupProto) */ {
 public:
  inline ShowGenericUiPopupProto() : ShowGenericUiPopupProto(nullptr) {}
  ~ShowGenericUiPopupProto() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiPopupProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiPopupProto(const ShowGenericUiPopupProto& from);
  ShowGenericUiPopupProto(ShowGenericUiPopupProto&& from) noexcept
    : ShowGenericUiPopupProto() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiPopupProto& operator=(const ShowGenericUiPopupProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiPopupProto& operator=(ShowGenericUiPopupProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiPopupProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiPopupProto* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiPopupProto*>(
               &_ShowGenericUiPopupProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ShowGenericUiPopupProto& a, ShowGenericUiPopupProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiPopupProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiPopupProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiPopupProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiPopupProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiPopupProto& from);
  void MergeFrom(const ShowGenericUiPopupProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiPopupProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiPopupProto";
  }
  protected:
  explicit ShowGenericUiPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPopupIdentifierFieldNumber = 2,
    kGenericUiFieldNumber = 1,
  };
  // optional string popup_identifier = 2;
  bool has_popup_identifier() const;
  private:
  bool _internal_has_popup_identifier() const;
  public:
  void clear_popup_identifier();
  const std::string& popup_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_popup_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_popup_identifier();
  PROTOBUF_NODISCARD std::string* release_popup_identifier();
  void set_allocated_popup_identifier(std::string* popup_identifier);
  private:
  const std::string& _internal_popup_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_popup_identifier(const std::string& value);
  std::string* _internal_mutable_popup_identifier();
  public:

  // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 1;
  bool has_generic_ui() const;
  private:
  bool _internal_has_generic_ui() const;
  public:
  void clear_generic_ui();
  const ::autofill_assistant::GenericUserInterfaceProto& generic_ui() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GenericUserInterfaceProto* release_generic_ui();
  ::autofill_assistant::GenericUserInterfaceProto* mutable_generic_ui();
  void set_allocated_generic_ui(::autofill_assistant::GenericUserInterfaceProto* generic_ui);
  private:
  const ::autofill_assistant::GenericUserInterfaceProto& _internal_generic_ui() const;
  ::autofill_assistant::GenericUserInterfaceProto* _internal_mutable_generic_ui();
  public:
  void unsafe_arena_set_allocated_generic_ui(
      ::autofill_assistant::GenericUserInterfaceProto* generic_ui);
  ::autofill_assistant::GenericUserInterfaceProto* unsafe_arena_release_generic_ui();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiPopupProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr popup_identifier_;
  ::autofill_assistant::GenericUserInterfaceProto* generic_ui_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class SetViewEnabledProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetViewEnabledProto) */ {
 public:
  inline SetViewEnabledProto() : SetViewEnabledProto(nullptr) {}
  ~SetViewEnabledProto() override;
  explicit PROTOBUF_CONSTEXPR SetViewEnabledProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetViewEnabledProto(const SetViewEnabledProto& from);
  SetViewEnabledProto(SetViewEnabledProto&& from) noexcept
    : SetViewEnabledProto() {
    *this = ::std::move(from);
  }

  inline SetViewEnabledProto& operator=(const SetViewEnabledProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetViewEnabledProto& operator=(SetViewEnabledProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetViewEnabledProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetViewEnabledProto* internal_default_instance() {
    return reinterpret_cast<const SetViewEnabledProto*>(
               &_SetViewEnabledProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SetViewEnabledProto& a, SetViewEnabledProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetViewEnabledProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetViewEnabledProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetViewEnabledProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetViewEnabledProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetViewEnabledProto& from);
  void MergeFrom(const SetViewEnabledProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetViewEnabledProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetViewEnabledProto";
  }
  protected:
  explicit SetViewEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewIdentifierFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // optional string view_identifier = 1;
  bool has_view_identifier() const;
  private:
  bool _internal_has_view_identifier() const;
  public:
  void clear_view_identifier();
  const std::string& view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_identifier();
  PROTOBUF_NODISCARD std::string* release_view_identifier();
  void set_allocated_view_identifier(std::string* view_identifier);
  private:
  const std::string& _internal_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_identifier(const std::string& value);
  std::string* _internal_mutable_view_identifier();
  public:

  // optional .autofill_assistant.ValueReferenceProto enabled = 2;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  const ::autofill_assistant::ValueReferenceProto& enabled() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueReferenceProto* release_enabled();
  ::autofill_assistant::ValueReferenceProto* mutable_enabled();
  void set_allocated_enabled(::autofill_assistant::ValueReferenceProto* enabled);
  private:
  const ::autofill_assistant::ValueReferenceProto& _internal_enabled() const;
  ::autofill_assistant::ValueReferenceProto* _internal_mutable_enabled();
  public:
  void unsafe_arena_set_allocated_enabled(
      ::autofill_assistant::ValueReferenceProto* enabled);
  ::autofill_assistant::ValueReferenceProto* unsafe_arena_release_enabled();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetViewEnabledProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_identifier_;
  ::autofill_assistant::ValueReferenceProto* enabled_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class CreateNestedGenericUiProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CreateNestedGenericUiProto) */ {
 public:
  inline CreateNestedGenericUiProto() : CreateNestedGenericUiProto(nullptr) {}
  ~CreateNestedGenericUiProto() override;
  explicit PROTOBUF_CONSTEXPR CreateNestedGenericUiProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNestedGenericUiProto(const CreateNestedGenericUiProto& from);
  CreateNestedGenericUiProto(CreateNestedGenericUiProto&& from) noexcept
    : CreateNestedGenericUiProto() {
    *this = ::std::move(from);
  }

  inline CreateNestedGenericUiProto& operator=(const CreateNestedGenericUiProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNestedGenericUiProto& operator=(CreateNestedGenericUiProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CreateNestedGenericUiProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNestedGenericUiProto* internal_default_instance() {
    return reinterpret_cast<const CreateNestedGenericUiProto*>(
               &_CreateNestedGenericUiProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CreateNestedGenericUiProto& a, CreateNestedGenericUiProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreateNestedGenericUiProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNestedGenericUiProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNestedGenericUiProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNestedGenericUiProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreateNestedGenericUiProto& from);
  void MergeFrom(const CreateNestedGenericUiProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateNestedGenericUiProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CreateNestedGenericUiProto";
  }
  protected:
  explicit CreateNestedGenericUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGenericUiIdentifierFieldNumber = 1,
    kParentViewIdentifierFieldNumber = 3,
    kGenericUiFieldNumber = 2,
  };
  // optional string generic_ui_identifier = 1;
  bool has_generic_ui_identifier() const;
  private:
  bool _internal_has_generic_ui_identifier() const;
  public:
  void clear_generic_ui_identifier();
  const std::string& generic_ui_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_generic_ui_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_generic_ui_identifier();
  PROTOBUF_NODISCARD std::string* release_generic_ui_identifier();
  void set_allocated_generic_ui_identifier(std::string* generic_ui_identifier);
  private:
  const std::string& _internal_generic_ui_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_generic_ui_identifier(const std::string& value);
  std::string* _internal_mutable_generic_ui_identifier();
  public:

  // optional string parent_view_identifier = 3;
  bool has_parent_view_identifier() const;
  private:
  bool _internal_has_parent_view_identifier() const;
  public:
  void clear_parent_view_identifier();
  const std::string& parent_view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_view_identifier();
  PROTOBUF_NODISCARD std::string* release_parent_view_identifier();
  void set_allocated_parent_view_identifier(std::string* parent_view_identifier);
  private:
  const std::string& _internal_parent_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_view_identifier(const std::string& value);
  std::string* _internal_mutable_parent_view_identifier();
  public:

  // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 2;
  bool has_generic_ui() const;
  private:
  bool _internal_has_generic_ui() const;
  public:
  void clear_generic_ui();
  const ::autofill_assistant::GenericUserInterfaceProto& generic_ui() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GenericUserInterfaceProto* release_generic_ui();
  ::autofill_assistant::GenericUserInterfaceProto* mutable_generic_ui();
  void set_allocated_generic_ui(::autofill_assistant::GenericUserInterfaceProto* generic_ui);
  private:
  const ::autofill_assistant::GenericUserInterfaceProto& _internal_generic_ui() const;
  ::autofill_assistant::GenericUserInterfaceProto* _internal_mutable_generic_ui();
  public:
  void unsafe_arena_set_allocated_generic_ui(
      ::autofill_assistant::GenericUserInterfaceProto* generic_ui);
  ::autofill_assistant::GenericUserInterfaceProto* unsafe_arena_release_generic_ui();

  // @@protoc_insertion_point(class_scope:autofill_assistant.CreateNestedGenericUiProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr generic_ui_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_view_identifier_;
  ::autofill_assistant::GenericUserInterfaceProto* generic_ui_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ClearViewContainerProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClearViewContainerProto) */ {
 public:
  inline ClearViewContainerProto() : ClearViewContainerProto(nullptr) {}
  ~ClearViewContainerProto() override;
  explicit PROTOBUF_CONSTEXPR ClearViewContainerProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearViewContainerProto(const ClearViewContainerProto& from);
  ClearViewContainerProto(ClearViewContainerProto&& from) noexcept
    : ClearViewContainerProto() {
    *this = ::std::move(from);
  }

  inline ClearViewContainerProto& operator=(const ClearViewContainerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearViewContainerProto& operator=(ClearViewContainerProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClearViewContainerProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearViewContainerProto* internal_default_instance() {
    return reinterpret_cast<const ClearViewContainerProto*>(
               &_ClearViewContainerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ClearViewContainerProto& a, ClearViewContainerProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClearViewContainerProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearViewContainerProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearViewContainerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearViewContainerProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClearViewContainerProto& from);
  void MergeFrom(const ClearViewContainerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearViewContainerProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClearViewContainerProto";
  }
  protected:
  explicit ClearViewContainerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewIdentifierFieldNumber = 1,
  };
  // optional string view_identifier = 1;
  bool has_view_identifier() const;
  private:
  bool _internal_has_view_identifier() const;
  public:
  void clear_view_identifier();
  const std::string& view_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_identifier();
  PROTOBUF_NODISCARD std::string* release_view_identifier();
  void set_allocated_view_identifier(std::string* view_identifier);
  private:
  const std::string& _internal_view_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_identifier(const std::string& value);
  std::string* _internal_mutable_view_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClearViewContainerProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// -------------------------------------------------------------------

class ForEachProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ForEachProto) */ {
 public:
  inline ForEachProto() : ForEachProto(nullptr) {}
  ~ForEachProto() override;
  explicit PROTOBUF_CONSTEXPR ForEachProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForEachProto(const ForEachProto& from);
  ForEachProto(ForEachProto&& from) noexcept
    : ForEachProto() {
    *this = ::std::move(from);
  }

  inline ForEachProto& operator=(const ForEachProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForEachProto& operator=(ForEachProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ForEachProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForEachProto* internal_default_instance() {
    return reinterpret_cast<const ForEachProto*>(
               &_ForEachProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ForEachProto& a, ForEachProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ForEachProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForEachProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForEachProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForEachProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ForEachProto& from);
  void MergeFrom(const ForEachProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ForEachProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ForEachProto";
  }
  protected:
  explicit ForEachProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbacksFieldNumber = 3,
    kLoopCounterFieldNumber = 1,
    kLoopValueModelIdentifierFieldNumber = 2,
  };
  // repeated .autofill_assistant.CallbackProto callbacks = 3;
  int callbacks_size() const;
  private:
  int _internal_callbacks_size() const;
  public:
  void clear_callbacks();
  ::autofill_assistant::CallbackProto* mutable_callbacks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >*
      mutable_callbacks();
  private:
  const ::autofill_assistant::CallbackProto& _internal_callbacks(int index) const;
  ::autofill_assistant::CallbackProto* _internal_add_callbacks();
  public:
  const ::autofill_assistant::CallbackProto& callbacks(int index) const;
  ::autofill_assistant::CallbackProto* add_callbacks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >&
      callbacks() const;

  // optional string loop_counter = 1;
  bool has_loop_counter() const;
  private:
  bool _internal_has_loop_counter() const;
  public:
  void clear_loop_counter();
  const std::string& loop_counter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loop_counter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loop_counter();
  PROTOBUF_NODISCARD std::string* release_loop_counter();
  void set_allocated_loop_counter(std::string* loop_counter);
  private:
  const std::string& _internal_loop_counter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loop_counter(const std::string& value);
  std::string* _internal_mutable_loop_counter();
  public:

  // optional string loop_value_model_identifier = 2;
  bool has_loop_value_model_identifier() const;
  private:
  bool _internal_has_loop_value_model_identifier() const;
  public:
  void clear_loop_value_model_identifier();
  const std::string& loop_value_model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loop_value_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loop_value_model_identifier();
  PROTOBUF_NODISCARD std::string* release_loop_value_model_identifier();
  void set_allocated_loop_value_model_identifier(std::string* loop_value_model_identifier);
  private:
  const std::string& _internal_loop_value_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loop_value_model_identifier(const std::string& value);
  std::string* _internal_mutable_loop_value_model_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ForEachProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto > callbacks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loop_counter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loop_value_model_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GenericUserInterfaceProto

// optional .autofill_assistant.ViewProto root_view = 1;
inline bool GenericUserInterfaceProto::_internal_has_root_view() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || root_view_ != nullptr);
  return value;
}
inline bool GenericUserInterfaceProto::has_root_view() const {
  return _internal_has_root_view();
}
inline const ::autofill_assistant::ViewProto& GenericUserInterfaceProto::_internal_root_view() const {
  const ::autofill_assistant::ViewProto* p = root_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewProto&>(
      ::autofill_assistant::_ViewProto_default_instance_);
}
inline const ::autofill_assistant::ViewProto& GenericUserInterfaceProto::root_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GenericUserInterfaceProto.root_view)
  return _internal_root_view();
}
inline void GenericUserInterfaceProto::unsafe_arena_set_allocated_root_view(
    ::autofill_assistant::ViewProto* root_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_view_);
  }
  root_view_ = root_view;
  if (root_view) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GenericUserInterfaceProto.root_view)
}
inline ::autofill_assistant::ViewProto* GenericUserInterfaceProto::release_root_view() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ViewProto* temp = root_view_;
  root_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewProto* GenericUserInterfaceProto::unsafe_arena_release_root_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GenericUserInterfaceProto.root_view)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ViewProto* temp = root_view_;
  root_view_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewProto* GenericUserInterfaceProto::_internal_mutable_root_view() {
  _has_bits_[0] |= 0x00000001u;
  if (root_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewProto>(GetArenaForAllocation());
    root_view_ = p;
  }
  return root_view_;
}
inline ::autofill_assistant::ViewProto* GenericUserInterfaceProto::mutable_root_view() {
  ::autofill_assistant::ViewProto* _msg = _internal_mutable_root_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GenericUserInterfaceProto.root_view)
  return _msg;
}
inline void GenericUserInterfaceProto::set_allocated_root_view(::autofill_assistant::ViewProto* root_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_view_);
  }
  if (root_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_view));
    if (message_arena != submessage_arena) {
      root_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root_view, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  root_view_ = root_view;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GenericUserInterfaceProto.root_view)
}

// optional .autofill_assistant.InteractionsProto interactions = 2;
inline bool GenericUserInterfaceProto::_internal_has_interactions() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || interactions_ != nullptr);
  return value;
}
inline bool GenericUserInterfaceProto::has_interactions() const {
  return _internal_has_interactions();
}
inline void GenericUserInterfaceProto::clear_interactions() {
  if (interactions_ != nullptr) interactions_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::InteractionsProto& GenericUserInterfaceProto::_internal_interactions() const {
  const ::autofill_assistant::InteractionsProto* p = interactions_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InteractionsProto&>(
      ::autofill_assistant::_InteractionsProto_default_instance_);
}
inline const ::autofill_assistant::InteractionsProto& GenericUserInterfaceProto::interactions() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GenericUserInterfaceProto.interactions)
  return _internal_interactions();
}
inline void GenericUserInterfaceProto::unsafe_arena_set_allocated_interactions(
    ::autofill_assistant::InteractionsProto* interactions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interactions_);
  }
  interactions_ = interactions;
  if (interactions) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GenericUserInterfaceProto.interactions)
}
inline ::autofill_assistant::InteractionsProto* GenericUserInterfaceProto::release_interactions() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::InteractionsProto* temp = interactions_;
  interactions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InteractionsProto* GenericUserInterfaceProto::unsafe_arena_release_interactions() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GenericUserInterfaceProto.interactions)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::InteractionsProto* temp = interactions_;
  interactions_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InteractionsProto* GenericUserInterfaceProto::_internal_mutable_interactions() {
  _has_bits_[0] |= 0x00000002u;
  if (interactions_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InteractionsProto>(GetArenaForAllocation());
    interactions_ = p;
  }
  return interactions_;
}
inline ::autofill_assistant::InteractionsProto* GenericUserInterfaceProto::mutable_interactions() {
  ::autofill_assistant::InteractionsProto* _msg = _internal_mutable_interactions();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GenericUserInterfaceProto.interactions)
  return _msg;
}
inline void GenericUserInterfaceProto::set_allocated_interactions(::autofill_assistant::InteractionsProto* interactions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete interactions_;
  }
  if (interactions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interactions);
    if (message_arena != submessage_arena) {
      interactions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interactions, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  interactions_ = interactions;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GenericUserInterfaceProto.interactions)
}

// optional .autofill_assistant.ModelProto model = 3;
inline bool GenericUserInterfaceProto::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || model_ != nullptr);
  return value;
}
inline bool GenericUserInterfaceProto::has_model() const {
  return _internal_has_model();
}
inline const ::autofill_assistant::ModelProto& GenericUserInterfaceProto::_internal_model() const {
  const ::autofill_assistant::ModelProto* p = model_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ModelProto&>(
      ::autofill_assistant::_ModelProto_default_instance_);
}
inline const ::autofill_assistant::ModelProto& GenericUserInterfaceProto::model() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GenericUserInterfaceProto.model)
  return _internal_model();
}
inline void GenericUserInterfaceProto::unsafe_arena_set_allocated_model(
    ::autofill_assistant::ModelProto* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  model_ = model;
  if (model) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GenericUserInterfaceProto.model)
}
inline ::autofill_assistant::ModelProto* GenericUserInterfaceProto::release_model() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ModelProto* temp = model_;
  model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ModelProto* GenericUserInterfaceProto::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GenericUserInterfaceProto.model)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ModelProto* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ModelProto* GenericUserInterfaceProto::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000004u;
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ModelProto>(GetArenaForAllocation());
    model_ = p;
  }
  return model_;
}
inline ::autofill_assistant::ModelProto* GenericUserInterfaceProto::mutable_model() {
  ::autofill_assistant::ModelProto* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GenericUserInterfaceProto.model)
  return _msg;
}
inline void GenericUserInterfaceProto::set_allocated_model(::autofill_assistant::ModelProto* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model));
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GenericUserInterfaceProto.model)
}

// -------------------------------------------------------------------

// InteractionsProto

// repeated .autofill_assistant.InteractionProto interactions = 1;
inline int InteractionsProto::_internal_interactions_size() const {
  return interactions_.size();
}
inline int InteractionsProto::interactions_size() const {
  return _internal_interactions_size();
}
inline void InteractionsProto::clear_interactions() {
  interactions_.Clear();
}
inline ::autofill_assistant::InteractionProto* InteractionsProto::mutable_interactions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InteractionsProto.interactions)
  return interactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::InteractionProto >*
InteractionsProto::mutable_interactions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.InteractionsProto.interactions)
  return &interactions_;
}
inline const ::autofill_assistant::InteractionProto& InteractionsProto::_internal_interactions(int index) const {
  return interactions_.Get(index);
}
inline const ::autofill_assistant::InteractionProto& InteractionsProto::interactions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InteractionsProto.interactions)
  return _internal_interactions(index);
}
inline ::autofill_assistant::InteractionProto* InteractionsProto::_internal_add_interactions() {
  return interactions_.Add();
}
inline ::autofill_assistant::InteractionProto* InteractionsProto::add_interactions() {
  ::autofill_assistant::InteractionProto* _add = _internal_add_interactions();
  // @@protoc_insertion_point(field_add:autofill_assistant.InteractionsProto.interactions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::InteractionProto >&
InteractionsProto::interactions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.InteractionsProto.interactions)
  return interactions_;
}

// -------------------------------------------------------------------

// InteractionProto

// repeated .autofill_assistant.CallbackProto callbacks = 1;
inline int InteractionProto::_internal_callbacks_size() const {
  return callbacks_.size();
}
inline int InteractionProto::callbacks_size() const {
  return _internal_callbacks_size();
}
inline void InteractionProto::clear_callbacks() {
  callbacks_.Clear();
}
inline ::autofill_assistant::CallbackProto* InteractionProto::mutable_callbacks(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InteractionProto.callbacks)
  return callbacks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >*
InteractionProto::mutable_callbacks() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.InteractionProto.callbacks)
  return &callbacks_;
}
inline const ::autofill_assistant::CallbackProto& InteractionProto::_internal_callbacks(int index) const {
  return callbacks_.Get(index);
}
inline const ::autofill_assistant::CallbackProto& InteractionProto::callbacks(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InteractionProto.callbacks)
  return _internal_callbacks(index);
}
inline ::autofill_assistant::CallbackProto* InteractionProto::_internal_add_callbacks() {
  return callbacks_.Add();
}
inline ::autofill_assistant::CallbackProto* InteractionProto::add_callbacks() {
  ::autofill_assistant::CallbackProto* _add = _internal_add_callbacks();
  // @@protoc_insertion_point(field_add:autofill_assistant.InteractionProto.callbacks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >&
InteractionProto::callbacks() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.InteractionProto.callbacks)
  return callbacks_;
}

// repeated .autofill_assistant.EventProto trigger_event = 2;
inline int InteractionProto::_internal_trigger_event_size() const {
  return trigger_event_.size();
}
inline int InteractionProto::trigger_event_size() const {
  return _internal_trigger_event_size();
}
inline void InteractionProto::clear_trigger_event() {
  trigger_event_.Clear();
}
inline ::autofill_assistant::EventProto* InteractionProto::mutable_trigger_event(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InteractionProto.trigger_event)
  return trigger_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::EventProto >*
InteractionProto::mutable_trigger_event() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.InteractionProto.trigger_event)
  return &trigger_event_;
}
inline const ::autofill_assistant::EventProto& InteractionProto::_internal_trigger_event(int index) const {
  return trigger_event_.Get(index);
}
inline const ::autofill_assistant::EventProto& InteractionProto::trigger_event(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InteractionProto.trigger_event)
  return _internal_trigger_event(index);
}
inline ::autofill_assistant::EventProto* InteractionProto::_internal_add_trigger_event() {
  return trigger_event_.Add();
}
inline ::autofill_assistant::EventProto* InteractionProto::add_trigger_event() {
  ::autofill_assistant::EventProto* _add = _internal_add_trigger_event();
  // @@protoc_insertion_point(field_add:autofill_assistant.InteractionProto.trigger_event)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::EventProto >&
InteractionProto::trigger_event() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.InteractionProto.trigger_event)
  return trigger_event_;
}

// -------------------------------------------------------------------

// CallbackProto

// .autofill_assistant.SetModelValueProto set_value = 1;
inline bool CallbackProto::_internal_has_set_value() const {
  return kind_case() == kSetValue;
}
inline bool CallbackProto::has_set_value() const {
  return _internal_has_set_value();
}
inline void CallbackProto::set_has_set_value() {
  _oneof_case_[0] = kSetValue;
}
inline void CallbackProto::clear_set_value() {
  if (_internal_has_set_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.set_value_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::SetModelValueProto* CallbackProto::release_set_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.set_value)
  if (_internal_has_set_value()) {
    clear_has_kind();
    ::autofill_assistant::SetModelValueProto* temp = kind_.set_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.set_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetModelValueProto& CallbackProto::_internal_set_value() const {
  return _internal_has_set_value()
      ? *kind_.set_value_
      : reinterpret_cast< ::autofill_assistant::SetModelValueProto&>(::autofill_assistant::_SetModelValueProto_default_instance_);
}
inline const ::autofill_assistant::SetModelValueProto& CallbackProto::set_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.set_value)
  return _internal_set_value();
}
inline ::autofill_assistant::SetModelValueProto* CallbackProto::unsafe_arena_release_set_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.set_value)
  if (_internal_has_set_value()) {
    clear_has_kind();
    ::autofill_assistant::SetModelValueProto* temp = kind_.set_value_;
    kind_.set_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_set_value(::autofill_assistant::SetModelValueProto* set_value) {
  clear_kind();
  if (set_value) {
    set_has_set_value();
    kind_.set_value_ = set_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.set_value)
}
inline ::autofill_assistant::SetModelValueProto* CallbackProto::_internal_mutable_set_value() {
  if (!_internal_has_set_value()) {
    clear_kind();
    set_has_set_value();
    kind_.set_value_ = CreateMaybeMessage< ::autofill_assistant::SetModelValueProto >(GetArenaForAllocation());
  }
  return kind_.set_value_;
}
inline ::autofill_assistant::SetModelValueProto* CallbackProto::mutable_set_value() {
  ::autofill_assistant::SetModelValueProto* _msg = _internal_mutable_set_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.set_value)
  return _msg;
}

// .autofill_assistant.ShowInfoPopupProto show_info_popup = 2;
inline bool CallbackProto::_internal_has_show_info_popup() const {
  return kind_case() == kShowInfoPopup;
}
inline bool CallbackProto::has_show_info_popup() const {
  return _internal_has_show_info_popup();
}
inline void CallbackProto::set_has_show_info_popup() {
  _oneof_case_[0] = kShowInfoPopup;
}
inline void CallbackProto::clear_show_info_popup() {
  if (_internal_has_show_info_popup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.show_info_popup_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ShowInfoPopupProto* CallbackProto::release_show_info_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.show_info_popup)
  if (_internal_has_show_info_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowInfoPopupProto* temp = kind_.show_info_popup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.show_info_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowInfoPopupProto& CallbackProto::_internal_show_info_popup() const {
  return _internal_has_show_info_popup()
      ? *kind_.show_info_popup_
      : reinterpret_cast< ::autofill_assistant::ShowInfoPopupProto&>(::autofill_assistant::_ShowInfoPopupProto_default_instance_);
}
inline const ::autofill_assistant::ShowInfoPopupProto& CallbackProto::show_info_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.show_info_popup)
  return _internal_show_info_popup();
}
inline ::autofill_assistant::ShowInfoPopupProto* CallbackProto::unsafe_arena_release_show_info_popup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.show_info_popup)
  if (_internal_has_show_info_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowInfoPopupProto* temp = kind_.show_info_popup_;
    kind_.show_info_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_show_info_popup(::autofill_assistant::ShowInfoPopupProto* show_info_popup) {
  clear_kind();
  if (show_info_popup) {
    set_has_show_info_popup();
    kind_.show_info_popup_ = show_info_popup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.show_info_popup)
}
inline ::autofill_assistant::ShowInfoPopupProto* CallbackProto::_internal_mutable_show_info_popup() {
  if (!_internal_has_show_info_popup()) {
    clear_kind();
    set_has_show_info_popup();
    kind_.show_info_popup_ = CreateMaybeMessage< ::autofill_assistant::ShowInfoPopupProto >(GetArenaForAllocation());
  }
  return kind_.show_info_popup_;
}
inline ::autofill_assistant::ShowInfoPopupProto* CallbackProto::mutable_show_info_popup() {
  ::autofill_assistant::ShowInfoPopupProto* _msg = _internal_mutable_show_info_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.show_info_popup)
  return _msg;
}

// .autofill_assistant.ShowListPopupProto show_list_popup = 3;
inline bool CallbackProto::_internal_has_show_list_popup() const {
  return kind_case() == kShowListPopup;
}
inline bool CallbackProto::has_show_list_popup() const {
  return _internal_has_show_list_popup();
}
inline void CallbackProto::set_has_show_list_popup() {
  _oneof_case_[0] = kShowListPopup;
}
inline void CallbackProto::clear_show_list_popup() {
  if (_internal_has_show_list_popup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.show_list_popup_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ShowListPopupProto* CallbackProto::release_show_list_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.show_list_popup)
  if (_internal_has_show_list_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowListPopupProto* temp = kind_.show_list_popup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.show_list_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowListPopupProto& CallbackProto::_internal_show_list_popup() const {
  return _internal_has_show_list_popup()
      ? *kind_.show_list_popup_
      : reinterpret_cast< ::autofill_assistant::ShowListPopupProto&>(::autofill_assistant::_ShowListPopupProto_default_instance_);
}
inline const ::autofill_assistant::ShowListPopupProto& CallbackProto::show_list_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.show_list_popup)
  return _internal_show_list_popup();
}
inline ::autofill_assistant::ShowListPopupProto* CallbackProto::unsafe_arena_release_show_list_popup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.show_list_popup)
  if (_internal_has_show_list_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowListPopupProto* temp = kind_.show_list_popup_;
    kind_.show_list_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_show_list_popup(::autofill_assistant::ShowListPopupProto* show_list_popup) {
  clear_kind();
  if (show_list_popup) {
    set_has_show_list_popup();
    kind_.show_list_popup_ = show_list_popup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.show_list_popup)
}
inline ::autofill_assistant::ShowListPopupProto* CallbackProto::_internal_mutable_show_list_popup() {
  if (!_internal_has_show_list_popup()) {
    clear_kind();
    set_has_show_list_popup();
    kind_.show_list_popup_ = CreateMaybeMessage< ::autofill_assistant::ShowListPopupProto >(GetArenaForAllocation());
  }
  return kind_.show_list_popup_;
}
inline ::autofill_assistant::ShowListPopupProto* CallbackProto::mutable_show_list_popup() {
  ::autofill_assistant::ShowListPopupProto* _msg = _internal_mutable_show_list_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.show_list_popup)
  return _msg;
}

// .autofill_assistant.ComputeValueProto compute_value = 4;
inline bool CallbackProto::_internal_has_compute_value() const {
  return kind_case() == kComputeValue;
}
inline bool CallbackProto::has_compute_value() const {
  return _internal_has_compute_value();
}
inline void CallbackProto::set_has_compute_value() {
  _oneof_case_[0] = kComputeValue;
}
inline void CallbackProto::clear_compute_value() {
  if (_internal_has_compute_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.compute_value_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ComputeValueProto* CallbackProto::release_compute_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.compute_value)
  if (_internal_has_compute_value()) {
    clear_has_kind();
    ::autofill_assistant::ComputeValueProto* temp = kind_.compute_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.compute_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ComputeValueProto& CallbackProto::_internal_compute_value() const {
  return _internal_has_compute_value()
      ? *kind_.compute_value_
      : reinterpret_cast< ::autofill_assistant::ComputeValueProto&>(::autofill_assistant::_ComputeValueProto_default_instance_);
}
inline const ::autofill_assistant::ComputeValueProto& CallbackProto::compute_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.compute_value)
  return _internal_compute_value();
}
inline ::autofill_assistant::ComputeValueProto* CallbackProto::unsafe_arena_release_compute_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.compute_value)
  if (_internal_has_compute_value()) {
    clear_has_kind();
    ::autofill_assistant::ComputeValueProto* temp = kind_.compute_value_;
    kind_.compute_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_compute_value(::autofill_assistant::ComputeValueProto* compute_value) {
  clear_kind();
  if (compute_value) {
    set_has_compute_value();
    kind_.compute_value_ = compute_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.compute_value)
}
inline ::autofill_assistant::ComputeValueProto* CallbackProto::_internal_mutable_compute_value() {
  if (!_internal_has_compute_value()) {
    clear_kind();
    set_has_compute_value();
    kind_.compute_value_ = CreateMaybeMessage< ::autofill_assistant::ComputeValueProto >(GetArenaForAllocation());
  }
  return kind_.compute_value_;
}
inline ::autofill_assistant::ComputeValueProto* CallbackProto::mutable_compute_value() {
  ::autofill_assistant::ComputeValueProto* _msg = _internal_mutable_compute_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.compute_value)
  return _msg;
}

// .autofill_assistant.SetUserActionsProto set_user_actions = 5;
inline bool CallbackProto::_internal_has_set_user_actions() const {
  return kind_case() == kSetUserActions;
}
inline bool CallbackProto::has_set_user_actions() const {
  return _internal_has_set_user_actions();
}
inline void CallbackProto::set_has_set_user_actions() {
  _oneof_case_[0] = kSetUserActions;
}
inline void CallbackProto::clear_set_user_actions() {
  if (_internal_has_set_user_actions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.set_user_actions_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::SetUserActionsProto* CallbackProto::release_set_user_actions() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.set_user_actions)
  if (_internal_has_set_user_actions()) {
    clear_has_kind();
    ::autofill_assistant::SetUserActionsProto* temp = kind_.set_user_actions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.set_user_actions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetUserActionsProto& CallbackProto::_internal_set_user_actions() const {
  return _internal_has_set_user_actions()
      ? *kind_.set_user_actions_
      : reinterpret_cast< ::autofill_assistant::SetUserActionsProto&>(::autofill_assistant::_SetUserActionsProto_default_instance_);
}
inline const ::autofill_assistant::SetUserActionsProto& CallbackProto::set_user_actions() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.set_user_actions)
  return _internal_set_user_actions();
}
inline ::autofill_assistant::SetUserActionsProto* CallbackProto::unsafe_arena_release_set_user_actions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.set_user_actions)
  if (_internal_has_set_user_actions()) {
    clear_has_kind();
    ::autofill_assistant::SetUserActionsProto* temp = kind_.set_user_actions_;
    kind_.set_user_actions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_set_user_actions(::autofill_assistant::SetUserActionsProto* set_user_actions) {
  clear_kind();
  if (set_user_actions) {
    set_has_set_user_actions();
    kind_.set_user_actions_ = set_user_actions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.set_user_actions)
}
inline ::autofill_assistant::SetUserActionsProto* CallbackProto::_internal_mutable_set_user_actions() {
  if (!_internal_has_set_user_actions()) {
    clear_kind();
    set_has_set_user_actions();
    kind_.set_user_actions_ = CreateMaybeMessage< ::autofill_assistant::SetUserActionsProto >(GetArenaForAllocation());
  }
  return kind_.set_user_actions_;
}
inline ::autofill_assistant::SetUserActionsProto* CallbackProto::mutable_set_user_actions() {
  ::autofill_assistant::SetUserActionsProto* _msg = _internal_mutable_set_user_actions();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.set_user_actions)
  return _msg;
}

// .autofill_assistant.EndActionProto end_action = 6;
inline bool CallbackProto::_internal_has_end_action() const {
  return kind_case() == kEndAction;
}
inline bool CallbackProto::has_end_action() const {
  return _internal_has_end_action();
}
inline void CallbackProto::set_has_end_action() {
  _oneof_case_[0] = kEndAction;
}
inline void CallbackProto::clear_end_action() {
  if (_internal_has_end_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.end_action_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::EndActionProto* CallbackProto::release_end_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.end_action)
  if (_internal_has_end_action()) {
    clear_has_kind();
    ::autofill_assistant::EndActionProto* temp = kind_.end_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.end_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::EndActionProto& CallbackProto::_internal_end_action() const {
  return _internal_has_end_action()
      ? *kind_.end_action_
      : reinterpret_cast< ::autofill_assistant::EndActionProto&>(::autofill_assistant::_EndActionProto_default_instance_);
}
inline const ::autofill_assistant::EndActionProto& CallbackProto::end_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.end_action)
  return _internal_end_action();
}
inline ::autofill_assistant::EndActionProto* CallbackProto::unsafe_arena_release_end_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.end_action)
  if (_internal_has_end_action()) {
    clear_has_kind();
    ::autofill_assistant::EndActionProto* temp = kind_.end_action_;
    kind_.end_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_end_action(::autofill_assistant::EndActionProto* end_action) {
  clear_kind();
  if (end_action) {
    set_has_end_action();
    kind_.end_action_ = end_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.end_action)
}
inline ::autofill_assistant::EndActionProto* CallbackProto::_internal_mutable_end_action() {
  if (!_internal_has_end_action()) {
    clear_kind();
    set_has_end_action();
    kind_.end_action_ = CreateMaybeMessage< ::autofill_assistant::EndActionProto >(GetArenaForAllocation());
  }
  return kind_.end_action_;
}
inline ::autofill_assistant::EndActionProto* CallbackProto::mutable_end_action() {
  ::autofill_assistant::EndActionProto* _msg = _internal_mutable_end_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.end_action)
  return _msg;
}

// .autofill_assistant.ShowCalendarPopupProto show_calendar_popup = 7;
inline bool CallbackProto::_internal_has_show_calendar_popup() const {
  return kind_case() == kShowCalendarPopup;
}
inline bool CallbackProto::has_show_calendar_popup() const {
  return _internal_has_show_calendar_popup();
}
inline void CallbackProto::set_has_show_calendar_popup() {
  _oneof_case_[0] = kShowCalendarPopup;
}
inline void CallbackProto::clear_show_calendar_popup() {
  if (_internal_has_show_calendar_popup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.show_calendar_popup_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ShowCalendarPopupProto* CallbackProto::release_show_calendar_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.show_calendar_popup)
  if (_internal_has_show_calendar_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowCalendarPopupProto* temp = kind_.show_calendar_popup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.show_calendar_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowCalendarPopupProto& CallbackProto::_internal_show_calendar_popup() const {
  return _internal_has_show_calendar_popup()
      ? *kind_.show_calendar_popup_
      : reinterpret_cast< ::autofill_assistant::ShowCalendarPopupProto&>(::autofill_assistant::_ShowCalendarPopupProto_default_instance_);
}
inline const ::autofill_assistant::ShowCalendarPopupProto& CallbackProto::show_calendar_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.show_calendar_popup)
  return _internal_show_calendar_popup();
}
inline ::autofill_assistant::ShowCalendarPopupProto* CallbackProto::unsafe_arena_release_show_calendar_popup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.show_calendar_popup)
  if (_internal_has_show_calendar_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowCalendarPopupProto* temp = kind_.show_calendar_popup_;
    kind_.show_calendar_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_show_calendar_popup(::autofill_assistant::ShowCalendarPopupProto* show_calendar_popup) {
  clear_kind();
  if (show_calendar_popup) {
    set_has_show_calendar_popup();
    kind_.show_calendar_popup_ = show_calendar_popup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.show_calendar_popup)
}
inline ::autofill_assistant::ShowCalendarPopupProto* CallbackProto::_internal_mutable_show_calendar_popup() {
  if (!_internal_has_show_calendar_popup()) {
    clear_kind();
    set_has_show_calendar_popup();
    kind_.show_calendar_popup_ = CreateMaybeMessage< ::autofill_assistant::ShowCalendarPopupProto >(GetArenaForAllocation());
  }
  return kind_.show_calendar_popup_;
}
inline ::autofill_assistant::ShowCalendarPopupProto* CallbackProto::mutable_show_calendar_popup() {
  ::autofill_assistant::ShowCalendarPopupProto* _msg = _internal_mutable_show_calendar_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.show_calendar_popup)
  return _msg;
}

// .autofill_assistant.SetTextProto set_text = 8;
inline bool CallbackProto::_internal_has_set_text() const {
  return kind_case() == kSetText;
}
inline bool CallbackProto::has_set_text() const {
  return _internal_has_set_text();
}
inline void CallbackProto::set_has_set_text() {
  _oneof_case_[0] = kSetText;
}
inline void CallbackProto::clear_set_text() {
  if (_internal_has_set_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.set_text_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::SetTextProto* CallbackProto::release_set_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.set_text)
  if (_internal_has_set_text()) {
    clear_has_kind();
    ::autofill_assistant::SetTextProto* temp = kind_.set_text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.set_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetTextProto& CallbackProto::_internal_set_text() const {
  return _internal_has_set_text()
      ? *kind_.set_text_
      : reinterpret_cast< ::autofill_assistant::SetTextProto&>(::autofill_assistant::_SetTextProto_default_instance_);
}
inline const ::autofill_assistant::SetTextProto& CallbackProto::set_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.set_text)
  return _internal_set_text();
}
inline ::autofill_assistant::SetTextProto* CallbackProto::unsafe_arena_release_set_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.set_text)
  if (_internal_has_set_text()) {
    clear_has_kind();
    ::autofill_assistant::SetTextProto* temp = kind_.set_text_;
    kind_.set_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_set_text(::autofill_assistant::SetTextProto* set_text) {
  clear_kind();
  if (set_text) {
    set_has_set_text();
    kind_.set_text_ = set_text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.set_text)
}
inline ::autofill_assistant::SetTextProto* CallbackProto::_internal_mutable_set_text() {
  if (!_internal_has_set_text()) {
    clear_kind();
    set_has_set_text();
    kind_.set_text_ = CreateMaybeMessage< ::autofill_assistant::SetTextProto >(GetArenaForAllocation());
  }
  return kind_.set_text_;
}
inline ::autofill_assistant::SetTextProto* CallbackProto::mutable_set_text() {
  ::autofill_assistant::SetTextProto* _msg = _internal_mutable_set_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.set_text)
  return _msg;
}

// .autofill_assistant.ToggleUserActionProto toggle_user_action = 9;
inline bool CallbackProto::_internal_has_toggle_user_action() const {
  return kind_case() == kToggleUserAction;
}
inline bool CallbackProto::has_toggle_user_action() const {
  return _internal_has_toggle_user_action();
}
inline void CallbackProto::set_has_toggle_user_action() {
  _oneof_case_[0] = kToggleUserAction;
}
inline void CallbackProto::clear_toggle_user_action() {
  if (_internal_has_toggle_user_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.toggle_user_action_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ToggleUserActionProto* CallbackProto::release_toggle_user_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.toggle_user_action)
  if (_internal_has_toggle_user_action()) {
    clear_has_kind();
    ::autofill_assistant::ToggleUserActionProto* temp = kind_.toggle_user_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.toggle_user_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ToggleUserActionProto& CallbackProto::_internal_toggle_user_action() const {
  return _internal_has_toggle_user_action()
      ? *kind_.toggle_user_action_
      : reinterpret_cast< ::autofill_assistant::ToggleUserActionProto&>(::autofill_assistant::_ToggleUserActionProto_default_instance_);
}
inline const ::autofill_assistant::ToggleUserActionProto& CallbackProto::toggle_user_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.toggle_user_action)
  return _internal_toggle_user_action();
}
inline ::autofill_assistant::ToggleUserActionProto* CallbackProto::unsafe_arena_release_toggle_user_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.toggle_user_action)
  if (_internal_has_toggle_user_action()) {
    clear_has_kind();
    ::autofill_assistant::ToggleUserActionProto* temp = kind_.toggle_user_action_;
    kind_.toggle_user_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_toggle_user_action(::autofill_assistant::ToggleUserActionProto* toggle_user_action) {
  clear_kind();
  if (toggle_user_action) {
    set_has_toggle_user_action();
    kind_.toggle_user_action_ = toggle_user_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.toggle_user_action)
}
inline ::autofill_assistant::ToggleUserActionProto* CallbackProto::_internal_mutable_toggle_user_action() {
  if (!_internal_has_toggle_user_action()) {
    clear_kind();
    set_has_toggle_user_action();
    kind_.toggle_user_action_ = CreateMaybeMessage< ::autofill_assistant::ToggleUserActionProto >(GetArenaForAllocation());
  }
  return kind_.toggle_user_action_;
}
inline ::autofill_assistant::ToggleUserActionProto* CallbackProto::mutable_toggle_user_action() {
  ::autofill_assistant::ToggleUserActionProto* _msg = _internal_mutable_toggle_user_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.toggle_user_action)
  return _msg;
}

// .autofill_assistant.SetViewVisibilityProto set_view_visibility = 11;
inline bool CallbackProto::_internal_has_set_view_visibility() const {
  return kind_case() == kSetViewVisibility;
}
inline bool CallbackProto::has_set_view_visibility() const {
  return _internal_has_set_view_visibility();
}
inline void CallbackProto::set_has_set_view_visibility() {
  _oneof_case_[0] = kSetViewVisibility;
}
inline void CallbackProto::clear_set_view_visibility() {
  if (_internal_has_set_view_visibility()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.set_view_visibility_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::SetViewVisibilityProto* CallbackProto::release_set_view_visibility() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.set_view_visibility)
  if (_internal_has_set_view_visibility()) {
    clear_has_kind();
    ::autofill_assistant::SetViewVisibilityProto* temp = kind_.set_view_visibility_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.set_view_visibility_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetViewVisibilityProto& CallbackProto::_internal_set_view_visibility() const {
  return _internal_has_set_view_visibility()
      ? *kind_.set_view_visibility_
      : reinterpret_cast< ::autofill_assistant::SetViewVisibilityProto&>(::autofill_assistant::_SetViewVisibilityProto_default_instance_);
}
inline const ::autofill_assistant::SetViewVisibilityProto& CallbackProto::set_view_visibility() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.set_view_visibility)
  return _internal_set_view_visibility();
}
inline ::autofill_assistant::SetViewVisibilityProto* CallbackProto::unsafe_arena_release_set_view_visibility() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.set_view_visibility)
  if (_internal_has_set_view_visibility()) {
    clear_has_kind();
    ::autofill_assistant::SetViewVisibilityProto* temp = kind_.set_view_visibility_;
    kind_.set_view_visibility_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_set_view_visibility(::autofill_assistant::SetViewVisibilityProto* set_view_visibility) {
  clear_kind();
  if (set_view_visibility) {
    set_has_set_view_visibility();
    kind_.set_view_visibility_ = set_view_visibility;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.set_view_visibility)
}
inline ::autofill_assistant::SetViewVisibilityProto* CallbackProto::_internal_mutable_set_view_visibility() {
  if (!_internal_has_set_view_visibility()) {
    clear_kind();
    set_has_set_view_visibility();
    kind_.set_view_visibility_ = CreateMaybeMessage< ::autofill_assistant::SetViewVisibilityProto >(GetArenaForAllocation());
  }
  return kind_.set_view_visibility_;
}
inline ::autofill_assistant::SetViewVisibilityProto* CallbackProto::mutable_set_view_visibility() {
  ::autofill_assistant::SetViewVisibilityProto* _msg = _internal_mutable_set_view_visibility();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.set_view_visibility)
  return _msg;
}

// .autofill_assistant.SetViewEnabledProto set_view_enabled = 12;
inline bool CallbackProto::_internal_has_set_view_enabled() const {
  return kind_case() == kSetViewEnabled;
}
inline bool CallbackProto::has_set_view_enabled() const {
  return _internal_has_set_view_enabled();
}
inline void CallbackProto::set_has_set_view_enabled() {
  _oneof_case_[0] = kSetViewEnabled;
}
inline void CallbackProto::clear_set_view_enabled() {
  if (_internal_has_set_view_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.set_view_enabled_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::SetViewEnabledProto* CallbackProto::release_set_view_enabled() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.set_view_enabled)
  if (_internal_has_set_view_enabled()) {
    clear_has_kind();
    ::autofill_assistant::SetViewEnabledProto* temp = kind_.set_view_enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.set_view_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetViewEnabledProto& CallbackProto::_internal_set_view_enabled() const {
  return _internal_has_set_view_enabled()
      ? *kind_.set_view_enabled_
      : reinterpret_cast< ::autofill_assistant::SetViewEnabledProto&>(::autofill_assistant::_SetViewEnabledProto_default_instance_);
}
inline const ::autofill_assistant::SetViewEnabledProto& CallbackProto::set_view_enabled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.set_view_enabled)
  return _internal_set_view_enabled();
}
inline ::autofill_assistant::SetViewEnabledProto* CallbackProto::unsafe_arena_release_set_view_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.set_view_enabled)
  if (_internal_has_set_view_enabled()) {
    clear_has_kind();
    ::autofill_assistant::SetViewEnabledProto* temp = kind_.set_view_enabled_;
    kind_.set_view_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_set_view_enabled(::autofill_assistant::SetViewEnabledProto* set_view_enabled) {
  clear_kind();
  if (set_view_enabled) {
    set_has_set_view_enabled();
    kind_.set_view_enabled_ = set_view_enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.set_view_enabled)
}
inline ::autofill_assistant::SetViewEnabledProto* CallbackProto::_internal_mutable_set_view_enabled() {
  if (!_internal_has_set_view_enabled()) {
    clear_kind();
    set_has_set_view_enabled();
    kind_.set_view_enabled_ = CreateMaybeMessage< ::autofill_assistant::SetViewEnabledProto >(GetArenaForAllocation());
  }
  return kind_.set_view_enabled_;
}
inline ::autofill_assistant::SetViewEnabledProto* CallbackProto::mutable_set_view_enabled() {
  ::autofill_assistant::SetViewEnabledProto* _msg = _internal_mutable_set_view_enabled();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.set_view_enabled)
  return _msg;
}

// .autofill_assistant.ShowGenericUiPopupProto show_generic_popup = 13;
inline bool CallbackProto::_internal_has_show_generic_popup() const {
  return kind_case() == kShowGenericPopup;
}
inline bool CallbackProto::has_show_generic_popup() const {
  return _internal_has_show_generic_popup();
}
inline void CallbackProto::set_has_show_generic_popup() {
  _oneof_case_[0] = kShowGenericPopup;
}
inline void CallbackProto::clear_show_generic_popup() {
  if (_internal_has_show_generic_popup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.show_generic_popup_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ShowGenericUiPopupProto* CallbackProto::release_show_generic_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.show_generic_popup)
  if (_internal_has_show_generic_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowGenericUiPopupProto* temp = kind_.show_generic_popup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.show_generic_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowGenericUiPopupProto& CallbackProto::_internal_show_generic_popup() const {
  return _internal_has_show_generic_popup()
      ? *kind_.show_generic_popup_
      : reinterpret_cast< ::autofill_assistant::ShowGenericUiPopupProto&>(::autofill_assistant::_ShowGenericUiPopupProto_default_instance_);
}
inline const ::autofill_assistant::ShowGenericUiPopupProto& CallbackProto::show_generic_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.show_generic_popup)
  return _internal_show_generic_popup();
}
inline ::autofill_assistant::ShowGenericUiPopupProto* CallbackProto::unsafe_arena_release_show_generic_popup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.show_generic_popup)
  if (_internal_has_show_generic_popup()) {
    clear_has_kind();
    ::autofill_assistant::ShowGenericUiPopupProto* temp = kind_.show_generic_popup_;
    kind_.show_generic_popup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_show_generic_popup(::autofill_assistant::ShowGenericUiPopupProto* show_generic_popup) {
  clear_kind();
  if (show_generic_popup) {
    set_has_show_generic_popup();
    kind_.show_generic_popup_ = show_generic_popup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.show_generic_popup)
}
inline ::autofill_assistant::ShowGenericUiPopupProto* CallbackProto::_internal_mutable_show_generic_popup() {
  if (!_internal_has_show_generic_popup()) {
    clear_kind();
    set_has_show_generic_popup();
    kind_.show_generic_popup_ = CreateMaybeMessage< ::autofill_assistant::ShowGenericUiPopupProto >(GetArenaForAllocation());
  }
  return kind_.show_generic_popup_;
}
inline ::autofill_assistant::ShowGenericUiPopupProto* CallbackProto::mutable_show_generic_popup() {
  ::autofill_assistant::ShowGenericUiPopupProto* _msg = _internal_mutable_show_generic_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.show_generic_popup)
  return _msg;
}

// .autofill_assistant.CreateNestedGenericUiProto create_nested_ui = 14;
inline bool CallbackProto::_internal_has_create_nested_ui() const {
  return kind_case() == kCreateNestedUi;
}
inline bool CallbackProto::has_create_nested_ui() const {
  return _internal_has_create_nested_ui();
}
inline void CallbackProto::set_has_create_nested_ui() {
  _oneof_case_[0] = kCreateNestedUi;
}
inline void CallbackProto::clear_create_nested_ui() {
  if (_internal_has_create_nested_ui()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.create_nested_ui_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::CreateNestedGenericUiProto* CallbackProto::release_create_nested_ui() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.create_nested_ui)
  if (_internal_has_create_nested_ui()) {
    clear_has_kind();
    ::autofill_assistant::CreateNestedGenericUiProto* temp = kind_.create_nested_ui_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.create_nested_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CreateNestedGenericUiProto& CallbackProto::_internal_create_nested_ui() const {
  return _internal_has_create_nested_ui()
      ? *kind_.create_nested_ui_
      : reinterpret_cast< ::autofill_assistant::CreateNestedGenericUiProto&>(::autofill_assistant::_CreateNestedGenericUiProto_default_instance_);
}
inline const ::autofill_assistant::CreateNestedGenericUiProto& CallbackProto::create_nested_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.create_nested_ui)
  return _internal_create_nested_ui();
}
inline ::autofill_assistant::CreateNestedGenericUiProto* CallbackProto::unsafe_arena_release_create_nested_ui() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.create_nested_ui)
  if (_internal_has_create_nested_ui()) {
    clear_has_kind();
    ::autofill_assistant::CreateNestedGenericUiProto* temp = kind_.create_nested_ui_;
    kind_.create_nested_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_create_nested_ui(::autofill_assistant::CreateNestedGenericUiProto* create_nested_ui) {
  clear_kind();
  if (create_nested_ui) {
    set_has_create_nested_ui();
    kind_.create_nested_ui_ = create_nested_ui;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.create_nested_ui)
}
inline ::autofill_assistant::CreateNestedGenericUiProto* CallbackProto::_internal_mutable_create_nested_ui() {
  if (!_internal_has_create_nested_ui()) {
    clear_kind();
    set_has_create_nested_ui();
    kind_.create_nested_ui_ = CreateMaybeMessage< ::autofill_assistant::CreateNestedGenericUiProto >(GetArenaForAllocation());
  }
  return kind_.create_nested_ui_;
}
inline ::autofill_assistant::CreateNestedGenericUiProto* CallbackProto::mutable_create_nested_ui() {
  ::autofill_assistant::CreateNestedGenericUiProto* _msg = _internal_mutable_create_nested_ui();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.create_nested_ui)
  return _msg;
}

// .autofill_assistant.ClearViewContainerProto clear_view_container = 15;
inline bool CallbackProto::_internal_has_clear_view_container() const {
  return kind_case() == kClearViewContainer;
}
inline bool CallbackProto::has_clear_view_container() const {
  return _internal_has_clear_view_container();
}
inline void CallbackProto::set_has_clear_view_container() {
  _oneof_case_[0] = kClearViewContainer;
}
inline void CallbackProto::clear_clear_view_container() {
  if (_internal_has_clear_view_container()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.clear_view_container_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ClearViewContainerProto* CallbackProto::release_clear_view_container() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.clear_view_container)
  if (_internal_has_clear_view_container()) {
    clear_has_kind();
    ::autofill_assistant::ClearViewContainerProto* temp = kind_.clear_view_container_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.clear_view_container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ClearViewContainerProto& CallbackProto::_internal_clear_view_container() const {
  return _internal_has_clear_view_container()
      ? *kind_.clear_view_container_
      : reinterpret_cast< ::autofill_assistant::ClearViewContainerProto&>(::autofill_assistant::_ClearViewContainerProto_default_instance_);
}
inline const ::autofill_assistant::ClearViewContainerProto& CallbackProto::clear_view_container() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.clear_view_container)
  return _internal_clear_view_container();
}
inline ::autofill_assistant::ClearViewContainerProto* CallbackProto::unsafe_arena_release_clear_view_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.clear_view_container)
  if (_internal_has_clear_view_container()) {
    clear_has_kind();
    ::autofill_assistant::ClearViewContainerProto* temp = kind_.clear_view_container_;
    kind_.clear_view_container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_clear_view_container(::autofill_assistant::ClearViewContainerProto* clear_view_container) {
  clear_kind();
  if (clear_view_container) {
    set_has_clear_view_container();
    kind_.clear_view_container_ = clear_view_container;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.clear_view_container)
}
inline ::autofill_assistant::ClearViewContainerProto* CallbackProto::_internal_mutable_clear_view_container() {
  if (!_internal_has_clear_view_container()) {
    clear_kind();
    set_has_clear_view_container();
    kind_.clear_view_container_ = CreateMaybeMessage< ::autofill_assistant::ClearViewContainerProto >(GetArenaForAllocation());
  }
  return kind_.clear_view_container_;
}
inline ::autofill_assistant::ClearViewContainerProto* CallbackProto::mutable_clear_view_container() {
  ::autofill_assistant::ClearViewContainerProto* _msg = _internal_mutable_clear_view_container();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.clear_view_container)
  return _msg;
}

// .autofill_assistant.ForEachProto for_each = 16;
inline bool CallbackProto::_internal_has_for_each() const {
  return kind_case() == kForEach;
}
inline bool CallbackProto::has_for_each() const {
  return _internal_has_for_each();
}
inline void CallbackProto::set_has_for_each() {
  _oneof_case_[0] = kForEach;
}
inline void CallbackProto::clear_for_each() {
  if (_internal_has_for_each()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.for_each_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ForEachProto* CallbackProto::release_for_each() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.for_each)
  if (_internal_has_for_each()) {
    clear_has_kind();
    ::autofill_assistant::ForEachProto* temp = kind_.for_each_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.for_each_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ForEachProto& CallbackProto::_internal_for_each() const {
  return _internal_has_for_each()
      ? *kind_.for_each_
      : reinterpret_cast< ::autofill_assistant::ForEachProto&>(::autofill_assistant::_ForEachProto_default_instance_);
}
inline const ::autofill_assistant::ForEachProto& CallbackProto::for_each() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.for_each)
  return _internal_for_each();
}
inline ::autofill_assistant::ForEachProto* CallbackProto::unsafe_arena_release_for_each() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CallbackProto.for_each)
  if (_internal_has_for_each()) {
    clear_has_kind();
    ::autofill_assistant::ForEachProto* temp = kind_.for_each_;
    kind_.for_each_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackProto::unsafe_arena_set_allocated_for_each(::autofill_assistant::ForEachProto* for_each) {
  clear_kind();
  if (for_each) {
    set_has_for_each();
    kind_.for_each_ = for_each;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CallbackProto.for_each)
}
inline ::autofill_assistant::ForEachProto* CallbackProto::_internal_mutable_for_each() {
  if (!_internal_has_for_each()) {
    clear_kind();
    set_has_for_each();
    kind_.for_each_ = CreateMaybeMessage< ::autofill_assistant::ForEachProto >(GetArenaForAllocation());
  }
  return kind_.for_each_;
}
inline ::autofill_assistant::ForEachProto* CallbackProto::mutable_for_each() {
  ::autofill_assistant::ForEachProto* _msg = _internal_mutable_for_each();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.for_each)
  return _msg;
}

// optional string condition_model_identifier = 10;
inline bool CallbackProto::_internal_has_condition_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CallbackProto::has_condition_model_identifier() const {
  return _internal_has_condition_model_identifier();
}
inline void CallbackProto::clear_condition_model_identifier() {
  condition_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CallbackProto::condition_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CallbackProto.condition_model_identifier)
  return _internal_condition_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CallbackProto::set_condition_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 condition_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CallbackProto.condition_model_identifier)
}
inline std::string* CallbackProto::mutable_condition_model_identifier() {
  std::string* _s = _internal_mutable_condition_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CallbackProto.condition_model_identifier)
  return _s;
}
inline const std::string& CallbackProto::_internal_condition_model_identifier() const {
  return condition_model_identifier_.Get();
}
inline void CallbackProto::_internal_set_condition_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  condition_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* CallbackProto::_internal_mutable_condition_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return condition_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* CallbackProto::release_condition_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CallbackProto.condition_model_identifier)
  if (!_internal_has_condition_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = condition_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (condition_model_identifier_.IsDefault()) {
    condition_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CallbackProto::set_allocated_condition_model_identifier(std::string* condition_model_identifier) {
  if (condition_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  condition_model_identifier_.SetAllocated(condition_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (condition_model_identifier_.IsDefault()) {
    condition_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.condition_model_identifier)
}

inline bool CallbackProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CallbackProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline CallbackProto::KindCase CallbackProto::kind_case() const {
  return CallbackProto::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EventProto

// .autofill_assistant.OnModelValueChangedEventProto on_value_changed = 1;
inline bool EventProto::_internal_has_on_value_changed() const {
  return kind_case() == kOnValueChanged;
}
inline bool EventProto::has_on_value_changed() const {
  return _internal_has_on_value_changed();
}
inline void EventProto::set_has_on_value_changed() {
  _oneof_case_[0] = kOnValueChanged;
}
inline void EventProto::clear_on_value_changed() {
  if (_internal_has_on_value_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.on_value_changed_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::OnModelValueChangedEventProto* EventProto::release_on_value_changed() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EventProto.on_value_changed)
  if (_internal_has_on_value_changed()) {
    clear_has_kind();
    ::autofill_assistant::OnModelValueChangedEventProto* temp = kind_.on_value_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.on_value_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::OnModelValueChangedEventProto& EventProto::_internal_on_value_changed() const {
  return _internal_has_on_value_changed()
      ? *kind_.on_value_changed_
      : reinterpret_cast< ::autofill_assistant::OnModelValueChangedEventProto&>(::autofill_assistant::_OnModelValueChangedEventProto_default_instance_);
}
inline const ::autofill_assistant::OnModelValueChangedEventProto& EventProto::on_value_changed() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EventProto.on_value_changed)
  return _internal_on_value_changed();
}
inline ::autofill_assistant::OnModelValueChangedEventProto* EventProto::unsafe_arena_release_on_value_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.EventProto.on_value_changed)
  if (_internal_has_on_value_changed()) {
    clear_has_kind();
    ::autofill_assistant::OnModelValueChangedEventProto* temp = kind_.on_value_changed_;
    kind_.on_value_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventProto::unsafe_arena_set_allocated_on_value_changed(::autofill_assistant::OnModelValueChangedEventProto* on_value_changed) {
  clear_kind();
  if (on_value_changed) {
    set_has_on_value_changed();
    kind_.on_value_changed_ = on_value_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.EventProto.on_value_changed)
}
inline ::autofill_assistant::OnModelValueChangedEventProto* EventProto::_internal_mutable_on_value_changed() {
  if (!_internal_has_on_value_changed()) {
    clear_kind();
    set_has_on_value_changed();
    kind_.on_value_changed_ = CreateMaybeMessage< ::autofill_assistant::OnModelValueChangedEventProto >(GetArenaForAllocation());
  }
  return kind_.on_value_changed_;
}
inline ::autofill_assistant::OnModelValueChangedEventProto* EventProto::mutable_on_value_changed() {
  ::autofill_assistant::OnModelValueChangedEventProto* _msg = _internal_mutable_on_value_changed();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EventProto.on_value_changed)
  return _msg;
}

// .autofill_assistant.OnViewClickedEventProto on_view_clicked = 2;
inline bool EventProto::_internal_has_on_view_clicked() const {
  return kind_case() == kOnViewClicked;
}
inline bool EventProto::has_on_view_clicked() const {
  return _internal_has_on_view_clicked();
}
inline void EventProto::set_has_on_view_clicked() {
  _oneof_case_[0] = kOnViewClicked;
}
inline void EventProto::clear_on_view_clicked() {
  if (_internal_has_on_view_clicked()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.on_view_clicked_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::OnViewClickedEventProto* EventProto::release_on_view_clicked() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EventProto.on_view_clicked)
  if (_internal_has_on_view_clicked()) {
    clear_has_kind();
    ::autofill_assistant::OnViewClickedEventProto* temp = kind_.on_view_clicked_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.on_view_clicked_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::OnViewClickedEventProto& EventProto::_internal_on_view_clicked() const {
  return _internal_has_on_view_clicked()
      ? *kind_.on_view_clicked_
      : reinterpret_cast< ::autofill_assistant::OnViewClickedEventProto&>(::autofill_assistant::_OnViewClickedEventProto_default_instance_);
}
inline const ::autofill_assistant::OnViewClickedEventProto& EventProto::on_view_clicked() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EventProto.on_view_clicked)
  return _internal_on_view_clicked();
}
inline ::autofill_assistant::OnViewClickedEventProto* EventProto::unsafe_arena_release_on_view_clicked() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.EventProto.on_view_clicked)
  if (_internal_has_on_view_clicked()) {
    clear_has_kind();
    ::autofill_assistant::OnViewClickedEventProto* temp = kind_.on_view_clicked_;
    kind_.on_view_clicked_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventProto::unsafe_arena_set_allocated_on_view_clicked(::autofill_assistant::OnViewClickedEventProto* on_view_clicked) {
  clear_kind();
  if (on_view_clicked) {
    set_has_on_view_clicked();
    kind_.on_view_clicked_ = on_view_clicked;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.EventProto.on_view_clicked)
}
inline ::autofill_assistant::OnViewClickedEventProto* EventProto::_internal_mutable_on_view_clicked() {
  if (!_internal_has_on_view_clicked()) {
    clear_kind();
    set_has_on_view_clicked();
    kind_.on_view_clicked_ = CreateMaybeMessage< ::autofill_assistant::OnViewClickedEventProto >(GetArenaForAllocation());
  }
  return kind_.on_view_clicked_;
}
inline ::autofill_assistant::OnViewClickedEventProto* EventProto::mutable_on_view_clicked() {
  ::autofill_assistant::OnViewClickedEventProto* _msg = _internal_mutable_on_view_clicked();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EventProto.on_view_clicked)
  return _msg;
}

// .autofill_assistant.OnUserActionCalled on_user_action_called = 3;
inline bool EventProto::_internal_has_on_user_action_called() const {
  return kind_case() == kOnUserActionCalled;
}
inline bool EventProto::has_on_user_action_called() const {
  return _internal_has_on_user_action_called();
}
inline void EventProto::set_has_on_user_action_called() {
  _oneof_case_[0] = kOnUserActionCalled;
}
inline void EventProto::clear_on_user_action_called() {
  if (_internal_has_on_user_action_called()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.on_user_action_called_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::OnUserActionCalled* EventProto::release_on_user_action_called() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EventProto.on_user_action_called)
  if (_internal_has_on_user_action_called()) {
    clear_has_kind();
    ::autofill_assistant::OnUserActionCalled* temp = kind_.on_user_action_called_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.on_user_action_called_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::OnUserActionCalled& EventProto::_internal_on_user_action_called() const {
  return _internal_has_on_user_action_called()
      ? *kind_.on_user_action_called_
      : reinterpret_cast< ::autofill_assistant::OnUserActionCalled&>(::autofill_assistant::_OnUserActionCalled_default_instance_);
}
inline const ::autofill_assistant::OnUserActionCalled& EventProto::on_user_action_called() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EventProto.on_user_action_called)
  return _internal_on_user_action_called();
}
inline ::autofill_assistant::OnUserActionCalled* EventProto::unsafe_arena_release_on_user_action_called() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.EventProto.on_user_action_called)
  if (_internal_has_on_user_action_called()) {
    clear_has_kind();
    ::autofill_assistant::OnUserActionCalled* temp = kind_.on_user_action_called_;
    kind_.on_user_action_called_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventProto::unsafe_arena_set_allocated_on_user_action_called(::autofill_assistant::OnUserActionCalled* on_user_action_called) {
  clear_kind();
  if (on_user_action_called) {
    set_has_on_user_action_called();
    kind_.on_user_action_called_ = on_user_action_called;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.EventProto.on_user_action_called)
}
inline ::autofill_assistant::OnUserActionCalled* EventProto::_internal_mutable_on_user_action_called() {
  if (!_internal_has_on_user_action_called()) {
    clear_kind();
    set_has_on_user_action_called();
    kind_.on_user_action_called_ = CreateMaybeMessage< ::autofill_assistant::OnUserActionCalled >(GetArenaForAllocation());
  }
  return kind_.on_user_action_called_;
}
inline ::autofill_assistant::OnUserActionCalled* EventProto::mutable_on_user_action_called() {
  ::autofill_assistant::OnUserActionCalled* _msg = _internal_mutable_on_user_action_called();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EventProto.on_user_action_called)
  return _msg;
}

// .autofill_assistant.OnTextLinkClickedProto on_text_link_clicked = 4;
inline bool EventProto::_internal_has_on_text_link_clicked() const {
  return kind_case() == kOnTextLinkClicked;
}
inline bool EventProto::has_on_text_link_clicked() const {
  return _internal_has_on_text_link_clicked();
}
inline void EventProto::set_has_on_text_link_clicked() {
  _oneof_case_[0] = kOnTextLinkClicked;
}
inline void EventProto::clear_on_text_link_clicked() {
  if (_internal_has_on_text_link_clicked()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.on_text_link_clicked_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::OnTextLinkClickedProto* EventProto::release_on_text_link_clicked() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EventProto.on_text_link_clicked)
  if (_internal_has_on_text_link_clicked()) {
    clear_has_kind();
    ::autofill_assistant::OnTextLinkClickedProto* temp = kind_.on_text_link_clicked_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.on_text_link_clicked_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::OnTextLinkClickedProto& EventProto::_internal_on_text_link_clicked() const {
  return _internal_has_on_text_link_clicked()
      ? *kind_.on_text_link_clicked_
      : reinterpret_cast< ::autofill_assistant::OnTextLinkClickedProto&>(::autofill_assistant::_OnTextLinkClickedProto_default_instance_);
}
inline const ::autofill_assistant::OnTextLinkClickedProto& EventProto::on_text_link_clicked() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EventProto.on_text_link_clicked)
  return _internal_on_text_link_clicked();
}
inline ::autofill_assistant::OnTextLinkClickedProto* EventProto::unsafe_arena_release_on_text_link_clicked() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.EventProto.on_text_link_clicked)
  if (_internal_has_on_text_link_clicked()) {
    clear_has_kind();
    ::autofill_assistant::OnTextLinkClickedProto* temp = kind_.on_text_link_clicked_;
    kind_.on_text_link_clicked_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventProto::unsafe_arena_set_allocated_on_text_link_clicked(::autofill_assistant::OnTextLinkClickedProto* on_text_link_clicked) {
  clear_kind();
  if (on_text_link_clicked) {
    set_has_on_text_link_clicked();
    kind_.on_text_link_clicked_ = on_text_link_clicked;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.EventProto.on_text_link_clicked)
}
inline ::autofill_assistant::OnTextLinkClickedProto* EventProto::_internal_mutable_on_text_link_clicked() {
  if (!_internal_has_on_text_link_clicked()) {
    clear_kind();
    set_has_on_text_link_clicked();
    kind_.on_text_link_clicked_ = CreateMaybeMessage< ::autofill_assistant::OnTextLinkClickedProto >(GetArenaForAllocation());
  }
  return kind_.on_text_link_clicked_;
}
inline ::autofill_assistant::OnTextLinkClickedProto* EventProto::mutable_on_text_link_clicked() {
  ::autofill_assistant::OnTextLinkClickedProto* _msg = _internal_mutable_on_text_link_clicked();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EventProto.on_text_link_clicked)
  return _msg;
}

// .autofill_assistant.OnPopupDismissedProto on_popup_dismissed = 5;
inline bool EventProto::_internal_has_on_popup_dismissed() const {
  return kind_case() == kOnPopupDismissed;
}
inline bool EventProto::has_on_popup_dismissed() const {
  return _internal_has_on_popup_dismissed();
}
inline void EventProto::set_has_on_popup_dismissed() {
  _oneof_case_[0] = kOnPopupDismissed;
}
inline void EventProto::clear_on_popup_dismissed() {
  if (_internal_has_on_popup_dismissed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.on_popup_dismissed_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::OnPopupDismissedProto* EventProto::release_on_popup_dismissed() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EventProto.on_popup_dismissed)
  if (_internal_has_on_popup_dismissed()) {
    clear_has_kind();
    ::autofill_assistant::OnPopupDismissedProto* temp = kind_.on_popup_dismissed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.on_popup_dismissed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::OnPopupDismissedProto& EventProto::_internal_on_popup_dismissed() const {
  return _internal_has_on_popup_dismissed()
      ? *kind_.on_popup_dismissed_
      : reinterpret_cast< ::autofill_assistant::OnPopupDismissedProto&>(::autofill_assistant::_OnPopupDismissedProto_default_instance_);
}
inline const ::autofill_assistant::OnPopupDismissedProto& EventProto::on_popup_dismissed() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EventProto.on_popup_dismissed)
  return _internal_on_popup_dismissed();
}
inline ::autofill_assistant::OnPopupDismissedProto* EventProto::unsafe_arena_release_on_popup_dismissed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.EventProto.on_popup_dismissed)
  if (_internal_has_on_popup_dismissed()) {
    clear_has_kind();
    ::autofill_assistant::OnPopupDismissedProto* temp = kind_.on_popup_dismissed_;
    kind_.on_popup_dismissed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventProto::unsafe_arena_set_allocated_on_popup_dismissed(::autofill_assistant::OnPopupDismissedProto* on_popup_dismissed) {
  clear_kind();
  if (on_popup_dismissed) {
    set_has_on_popup_dismissed();
    kind_.on_popup_dismissed_ = on_popup_dismissed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.EventProto.on_popup_dismissed)
}
inline ::autofill_assistant::OnPopupDismissedProto* EventProto::_internal_mutable_on_popup_dismissed() {
  if (!_internal_has_on_popup_dismissed()) {
    clear_kind();
    set_has_on_popup_dismissed();
    kind_.on_popup_dismissed_ = CreateMaybeMessage< ::autofill_assistant::OnPopupDismissedProto >(GetArenaForAllocation());
  }
  return kind_.on_popup_dismissed_;
}
inline ::autofill_assistant::OnPopupDismissedProto* EventProto::mutable_on_popup_dismissed() {
  ::autofill_assistant::OnPopupDismissedProto* _msg = _internal_mutable_on_popup_dismissed();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EventProto.on_popup_dismissed)
  return _msg;
}

// .autofill_assistant.OnViewContainerClearedProto on_view_container_cleared = 6;
inline bool EventProto::_internal_has_on_view_container_cleared() const {
  return kind_case() == kOnViewContainerCleared;
}
inline bool EventProto::has_on_view_container_cleared() const {
  return _internal_has_on_view_container_cleared();
}
inline void EventProto::set_has_on_view_container_cleared() {
  _oneof_case_[0] = kOnViewContainerCleared;
}
inline void EventProto::clear_on_view_container_cleared() {
  if (_internal_has_on_view_container_cleared()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.on_view_container_cleared_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::OnViewContainerClearedProto* EventProto::release_on_view_container_cleared() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EventProto.on_view_container_cleared)
  if (_internal_has_on_view_container_cleared()) {
    clear_has_kind();
    ::autofill_assistant::OnViewContainerClearedProto* temp = kind_.on_view_container_cleared_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.on_view_container_cleared_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::OnViewContainerClearedProto& EventProto::_internal_on_view_container_cleared() const {
  return _internal_has_on_view_container_cleared()
      ? *kind_.on_view_container_cleared_
      : reinterpret_cast< ::autofill_assistant::OnViewContainerClearedProto&>(::autofill_assistant::_OnViewContainerClearedProto_default_instance_);
}
inline const ::autofill_assistant::OnViewContainerClearedProto& EventProto::on_view_container_cleared() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EventProto.on_view_container_cleared)
  return _internal_on_view_container_cleared();
}
inline ::autofill_assistant::OnViewContainerClearedProto* EventProto::unsafe_arena_release_on_view_container_cleared() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.EventProto.on_view_container_cleared)
  if (_internal_has_on_view_container_cleared()) {
    clear_has_kind();
    ::autofill_assistant::OnViewContainerClearedProto* temp = kind_.on_view_container_cleared_;
    kind_.on_view_container_cleared_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventProto::unsafe_arena_set_allocated_on_view_container_cleared(::autofill_assistant::OnViewContainerClearedProto* on_view_container_cleared) {
  clear_kind();
  if (on_view_container_cleared) {
    set_has_on_view_container_cleared();
    kind_.on_view_container_cleared_ = on_view_container_cleared;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.EventProto.on_view_container_cleared)
}
inline ::autofill_assistant::OnViewContainerClearedProto* EventProto::_internal_mutable_on_view_container_cleared() {
  if (!_internal_has_on_view_container_cleared()) {
    clear_kind();
    set_has_on_view_container_cleared();
    kind_.on_view_container_cleared_ = CreateMaybeMessage< ::autofill_assistant::OnViewContainerClearedProto >(GetArenaForAllocation());
  }
  return kind_.on_view_container_cleared_;
}
inline ::autofill_assistant::OnViewContainerClearedProto* EventProto::mutable_on_view_container_cleared() {
  ::autofill_assistant::OnViewContainerClearedProto* _msg = _internal_mutable_on_view_container_cleared();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EventProto.on_view_container_cleared)
  return _msg;
}

inline bool EventProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void EventProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline EventProto::KindCase EventProto::kind_case() const {
  return EventProto::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OnModelValueChangedEventProto

// optional string model_identifier = 1;
inline bool OnModelValueChangedEventProto::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnModelValueChangedEventProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void OnModelValueChangedEventProto::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OnModelValueChangedEventProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OnModelValueChangedEventProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnModelValueChangedEventProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OnModelValueChangedEventProto.model_identifier)
}
inline std::string* OnModelValueChangedEventProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OnModelValueChangedEventProto.model_identifier)
  return _s;
}
inline const std::string& OnModelValueChangedEventProto::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void OnModelValueChangedEventProto::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* OnModelValueChangedEventProto::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* OnModelValueChangedEventProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OnModelValueChangedEventProto.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OnModelValueChangedEventProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OnModelValueChangedEventProto.model_identifier)
}

// -------------------------------------------------------------------

// OnViewClickedEventProto

// optional string view_identifier = 1;
inline bool OnViewClickedEventProto::_internal_has_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnViewClickedEventProto::has_view_identifier() const {
  return _internal_has_view_identifier();
}
inline void OnViewClickedEventProto::clear_view_identifier() {
  view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OnViewClickedEventProto::view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OnViewClickedEventProto.view_identifier)
  return _internal_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnViewClickedEventProto::set_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OnViewClickedEventProto.view_identifier)
}
inline std::string* OnViewClickedEventProto::mutable_view_identifier() {
  std::string* _s = _internal_mutable_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OnViewClickedEventProto.view_identifier)
  return _s;
}
inline const std::string& OnViewClickedEventProto::_internal_view_identifier() const {
  return view_identifier_.Get();
}
inline void OnViewClickedEventProto::_internal_set_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* OnViewClickedEventProto::_internal_mutable_view_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* OnViewClickedEventProto::release_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OnViewClickedEventProto.view_identifier)
  if (!_internal_has_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OnViewClickedEventProto::set_allocated_view_identifier(std::string* view_identifier) {
  if (view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_identifier_.SetAllocated(view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OnViewClickedEventProto.view_identifier)
}

// -------------------------------------------------------------------

// OnUserActionCalled

// optional string user_action_identifier = 1;
inline bool OnUserActionCalled::_internal_has_user_action_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnUserActionCalled::has_user_action_identifier() const {
  return _internal_has_user_action_identifier();
}
inline void OnUserActionCalled::clear_user_action_identifier() {
  user_action_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OnUserActionCalled::user_action_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OnUserActionCalled.user_action_identifier)
  return _internal_user_action_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnUserActionCalled::set_user_action_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_action_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OnUserActionCalled.user_action_identifier)
}
inline std::string* OnUserActionCalled::mutable_user_action_identifier() {
  std::string* _s = _internal_mutable_user_action_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OnUserActionCalled.user_action_identifier)
  return _s;
}
inline const std::string& OnUserActionCalled::_internal_user_action_identifier() const {
  return user_action_identifier_.Get();
}
inline void OnUserActionCalled::_internal_set_user_action_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_action_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* OnUserActionCalled::_internal_mutable_user_action_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return user_action_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* OnUserActionCalled::release_user_action_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OnUserActionCalled.user_action_identifier)
  if (!_internal_has_user_action_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_action_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_action_identifier_.IsDefault()) {
    user_action_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OnUserActionCalled::set_allocated_user_action_identifier(std::string* user_action_identifier) {
  if (user_action_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_action_identifier_.SetAllocated(user_action_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_action_identifier_.IsDefault()) {
    user_action_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OnUserActionCalled.user_action_identifier)
}

// -------------------------------------------------------------------

// OnTextLinkClickedProto

// optional int32 text_link = 1;
inline bool OnTextLinkClickedProto::_internal_has_text_link() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnTextLinkClickedProto::has_text_link() const {
  return _internal_has_text_link();
}
inline void OnTextLinkClickedProto::clear_text_link() {
  text_link_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t OnTextLinkClickedProto::_internal_text_link() const {
  return text_link_;
}
inline int32_t OnTextLinkClickedProto::text_link() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OnTextLinkClickedProto.text_link)
  return _internal_text_link();
}
inline void OnTextLinkClickedProto::_internal_set_text_link(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  text_link_ = value;
}
inline void OnTextLinkClickedProto::set_text_link(int32_t value) {
  _internal_set_text_link(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.OnTextLinkClickedProto.text_link)
}

// -------------------------------------------------------------------

// OnPopupDismissedProto

// optional string popup_identifier = 1;
inline bool OnPopupDismissedProto::_internal_has_popup_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnPopupDismissedProto::has_popup_identifier() const {
  return _internal_has_popup_identifier();
}
inline void OnPopupDismissedProto::clear_popup_identifier() {
  popup_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OnPopupDismissedProto::popup_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OnPopupDismissedProto.popup_identifier)
  return _internal_popup_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnPopupDismissedProto::set_popup_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 popup_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OnPopupDismissedProto.popup_identifier)
}
inline std::string* OnPopupDismissedProto::mutable_popup_identifier() {
  std::string* _s = _internal_mutable_popup_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OnPopupDismissedProto.popup_identifier)
  return _s;
}
inline const std::string& OnPopupDismissedProto::_internal_popup_identifier() const {
  return popup_identifier_.Get();
}
inline void OnPopupDismissedProto::_internal_set_popup_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  popup_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* OnPopupDismissedProto::_internal_mutable_popup_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return popup_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* OnPopupDismissedProto::release_popup_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OnPopupDismissedProto.popup_identifier)
  if (!_internal_has_popup_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = popup_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (popup_identifier_.IsDefault()) {
    popup_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OnPopupDismissedProto::set_allocated_popup_identifier(std::string* popup_identifier) {
  if (popup_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  popup_identifier_.SetAllocated(popup_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (popup_identifier_.IsDefault()) {
    popup_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OnPopupDismissedProto.popup_identifier)
}

// -------------------------------------------------------------------

// OnViewContainerClearedProto

// optional string view_identifier = 1;
inline bool OnViewContainerClearedProto::_internal_has_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnViewContainerClearedProto::has_view_identifier() const {
  return _internal_has_view_identifier();
}
inline void OnViewContainerClearedProto::clear_view_identifier() {
  view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OnViewContainerClearedProto::view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OnViewContainerClearedProto.view_identifier)
  return _internal_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnViewContainerClearedProto::set_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OnViewContainerClearedProto.view_identifier)
}
inline std::string* OnViewContainerClearedProto::mutable_view_identifier() {
  std::string* _s = _internal_mutable_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OnViewContainerClearedProto.view_identifier)
  return _s;
}
inline const std::string& OnViewContainerClearedProto::_internal_view_identifier() const {
  return view_identifier_.Get();
}
inline void OnViewContainerClearedProto::_internal_set_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* OnViewContainerClearedProto::_internal_mutable_view_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* OnViewContainerClearedProto::release_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OnViewContainerClearedProto.view_identifier)
  if (!_internal_has_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OnViewContainerClearedProto::set_allocated_view_identifier(std::string* view_identifier) {
  if (view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_identifier_.SetAllocated(view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OnViewContainerClearedProto.view_identifier)
}

// -------------------------------------------------------------------

// SetModelValueProto

// optional string model_identifier = 1;
inline bool SetModelValueProto::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetModelValueProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void SetModelValueProto::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetModelValueProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetModelValueProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetModelValueProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SetModelValueProto.model_identifier)
}
inline std::string* SetModelValueProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetModelValueProto.model_identifier)
  return _s;
}
inline const std::string& SetModelValueProto::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void SetModelValueProto::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* SetModelValueProto::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* SetModelValueProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetModelValueProto.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetModelValueProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetModelValueProto.model_identifier)
}

// optional .autofill_assistant.ValueReferenceProto value = 3;
inline bool SetModelValueProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool SetModelValueProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::ValueReferenceProto& SetModelValueProto::_internal_value() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& SetModelValueProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetModelValueProto.value)
  return _internal_value();
}
inline void SetModelValueProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueReferenceProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetModelValueProto.value)
}
inline ::autofill_assistant::ValueReferenceProto* SetModelValueProto::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetModelValueProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetModelValueProto.value)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetModelValueProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueReferenceProto* SetModelValueProto::mutable_value() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetModelValueProto.value)
  return _msg;
}
inline void SetModelValueProto::set_allocated_value(::autofill_assistant::ValueReferenceProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetModelValueProto.value)
}

// -------------------------------------------------------------------

// ComputeValueProto

// .autofill_assistant.BooleanAndProto boolean_and = 2;
inline bool ComputeValueProto::_internal_has_boolean_and() const {
  return kind_case() == kBooleanAnd;
}
inline bool ComputeValueProto::has_boolean_and() const {
  return _internal_has_boolean_and();
}
inline void ComputeValueProto::set_has_boolean_and() {
  _oneof_case_[0] = kBooleanAnd;
}
inline void ComputeValueProto::clear_boolean_and() {
  if (_internal_has_boolean_and()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.boolean_and_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::BooleanAndProto* ComputeValueProto::release_boolean_and() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.boolean_and)
  if (_internal_has_boolean_and()) {
    clear_has_kind();
    ::autofill_assistant::BooleanAndProto* temp = kind_.boolean_and_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.boolean_and_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::BooleanAndProto& ComputeValueProto::_internal_boolean_and() const {
  return _internal_has_boolean_and()
      ? *kind_.boolean_and_
      : reinterpret_cast< ::autofill_assistant::BooleanAndProto&>(::autofill_assistant::_BooleanAndProto_default_instance_);
}
inline const ::autofill_assistant::BooleanAndProto& ComputeValueProto::boolean_and() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.boolean_and)
  return _internal_boolean_and();
}
inline ::autofill_assistant::BooleanAndProto* ComputeValueProto::unsafe_arena_release_boolean_and() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.boolean_and)
  if (_internal_has_boolean_and()) {
    clear_has_kind();
    ::autofill_assistant::BooleanAndProto* temp = kind_.boolean_and_;
    kind_.boolean_and_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_boolean_and(::autofill_assistant::BooleanAndProto* boolean_and) {
  clear_kind();
  if (boolean_and) {
    set_has_boolean_and();
    kind_.boolean_and_ = boolean_and;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.boolean_and)
}
inline ::autofill_assistant::BooleanAndProto* ComputeValueProto::_internal_mutable_boolean_and() {
  if (!_internal_has_boolean_and()) {
    clear_kind();
    set_has_boolean_and();
    kind_.boolean_and_ = CreateMaybeMessage< ::autofill_assistant::BooleanAndProto >(GetArenaForAllocation());
  }
  return kind_.boolean_and_;
}
inline ::autofill_assistant::BooleanAndProto* ComputeValueProto::mutable_boolean_and() {
  ::autofill_assistant::BooleanAndProto* _msg = _internal_mutable_boolean_and();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.boolean_and)
  return _msg;
}

// .autofill_assistant.BooleanOrProto boolean_or = 3;
inline bool ComputeValueProto::_internal_has_boolean_or() const {
  return kind_case() == kBooleanOr;
}
inline bool ComputeValueProto::has_boolean_or() const {
  return _internal_has_boolean_or();
}
inline void ComputeValueProto::set_has_boolean_or() {
  _oneof_case_[0] = kBooleanOr;
}
inline void ComputeValueProto::clear_boolean_or() {
  if (_internal_has_boolean_or()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.boolean_or_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::BooleanOrProto* ComputeValueProto::release_boolean_or() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.boolean_or)
  if (_internal_has_boolean_or()) {
    clear_has_kind();
    ::autofill_assistant::BooleanOrProto* temp = kind_.boolean_or_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.boolean_or_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::BooleanOrProto& ComputeValueProto::_internal_boolean_or() const {
  return _internal_has_boolean_or()
      ? *kind_.boolean_or_
      : reinterpret_cast< ::autofill_assistant::BooleanOrProto&>(::autofill_assistant::_BooleanOrProto_default_instance_);
}
inline const ::autofill_assistant::BooleanOrProto& ComputeValueProto::boolean_or() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.boolean_or)
  return _internal_boolean_or();
}
inline ::autofill_assistant::BooleanOrProto* ComputeValueProto::unsafe_arena_release_boolean_or() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.boolean_or)
  if (_internal_has_boolean_or()) {
    clear_has_kind();
    ::autofill_assistant::BooleanOrProto* temp = kind_.boolean_or_;
    kind_.boolean_or_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_boolean_or(::autofill_assistant::BooleanOrProto* boolean_or) {
  clear_kind();
  if (boolean_or) {
    set_has_boolean_or();
    kind_.boolean_or_ = boolean_or;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.boolean_or)
}
inline ::autofill_assistant::BooleanOrProto* ComputeValueProto::_internal_mutable_boolean_or() {
  if (!_internal_has_boolean_or()) {
    clear_kind();
    set_has_boolean_or();
    kind_.boolean_or_ = CreateMaybeMessage< ::autofill_assistant::BooleanOrProto >(GetArenaForAllocation());
  }
  return kind_.boolean_or_;
}
inline ::autofill_assistant::BooleanOrProto* ComputeValueProto::mutable_boolean_or() {
  ::autofill_assistant::BooleanOrProto* _msg = _internal_mutable_boolean_or();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.boolean_or)
  return _msg;
}

// .autofill_assistant.BooleanNotProto boolean_not = 4;
inline bool ComputeValueProto::_internal_has_boolean_not() const {
  return kind_case() == kBooleanNot;
}
inline bool ComputeValueProto::has_boolean_not() const {
  return _internal_has_boolean_not();
}
inline void ComputeValueProto::set_has_boolean_not() {
  _oneof_case_[0] = kBooleanNot;
}
inline void ComputeValueProto::clear_boolean_not() {
  if (_internal_has_boolean_not()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.boolean_not_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::BooleanNotProto* ComputeValueProto::release_boolean_not() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.boolean_not)
  if (_internal_has_boolean_not()) {
    clear_has_kind();
    ::autofill_assistant::BooleanNotProto* temp = kind_.boolean_not_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.boolean_not_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::BooleanNotProto& ComputeValueProto::_internal_boolean_not() const {
  return _internal_has_boolean_not()
      ? *kind_.boolean_not_
      : reinterpret_cast< ::autofill_assistant::BooleanNotProto&>(::autofill_assistant::_BooleanNotProto_default_instance_);
}
inline const ::autofill_assistant::BooleanNotProto& ComputeValueProto::boolean_not() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.boolean_not)
  return _internal_boolean_not();
}
inline ::autofill_assistant::BooleanNotProto* ComputeValueProto::unsafe_arena_release_boolean_not() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.boolean_not)
  if (_internal_has_boolean_not()) {
    clear_has_kind();
    ::autofill_assistant::BooleanNotProto* temp = kind_.boolean_not_;
    kind_.boolean_not_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_boolean_not(::autofill_assistant::BooleanNotProto* boolean_not) {
  clear_kind();
  if (boolean_not) {
    set_has_boolean_not();
    kind_.boolean_not_ = boolean_not;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.boolean_not)
}
inline ::autofill_assistant::BooleanNotProto* ComputeValueProto::_internal_mutable_boolean_not() {
  if (!_internal_has_boolean_not()) {
    clear_kind();
    set_has_boolean_not();
    kind_.boolean_not_ = CreateMaybeMessage< ::autofill_assistant::BooleanNotProto >(GetArenaForAllocation());
  }
  return kind_.boolean_not_;
}
inline ::autofill_assistant::BooleanNotProto* ComputeValueProto::mutable_boolean_not() {
  ::autofill_assistant::BooleanNotProto* _msg = _internal_mutable_boolean_not();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.boolean_not)
  return _msg;
}

// .autofill_assistant.ToStringProto to_string = 5;
inline bool ComputeValueProto::_internal_has_to_string() const {
  return kind_case() == kToString;
}
inline bool ComputeValueProto::has_to_string() const {
  return _internal_has_to_string();
}
inline void ComputeValueProto::set_has_to_string() {
  _oneof_case_[0] = kToString;
}
inline void ComputeValueProto::clear_to_string() {
  if (_internal_has_to_string()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.to_string_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ToStringProto* ComputeValueProto::release_to_string() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.to_string)
  if (_internal_has_to_string()) {
    clear_has_kind();
    ::autofill_assistant::ToStringProto* temp = kind_.to_string_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.to_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ToStringProto& ComputeValueProto::_internal_to_string() const {
  return _internal_has_to_string()
      ? *kind_.to_string_
      : reinterpret_cast< ::autofill_assistant::ToStringProto&>(::autofill_assistant::_ToStringProto_default_instance_);
}
inline const ::autofill_assistant::ToStringProto& ComputeValueProto::to_string() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.to_string)
  return _internal_to_string();
}
inline ::autofill_assistant::ToStringProto* ComputeValueProto::unsafe_arena_release_to_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.to_string)
  if (_internal_has_to_string()) {
    clear_has_kind();
    ::autofill_assistant::ToStringProto* temp = kind_.to_string_;
    kind_.to_string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_to_string(::autofill_assistant::ToStringProto* to_string) {
  clear_kind();
  if (to_string) {
    set_has_to_string();
    kind_.to_string_ = to_string;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.to_string)
}
inline ::autofill_assistant::ToStringProto* ComputeValueProto::_internal_mutable_to_string() {
  if (!_internal_has_to_string()) {
    clear_kind();
    set_has_to_string();
    kind_.to_string_ = CreateMaybeMessage< ::autofill_assistant::ToStringProto >(GetArenaForAllocation());
  }
  return kind_.to_string_;
}
inline ::autofill_assistant::ToStringProto* ComputeValueProto::mutable_to_string() {
  ::autofill_assistant::ToStringProto* _msg = _internal_mutable_to_string();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.to_string)
  return _msg;
}

// .autofill_assistant.ValueComparisonProto comparison = 6;
inline bool ComputeValueProto::_internal_has_comparison() const {
  return kind_case() == kComparison;
}
inline bool ComputeValueProto::has_comparison() const {
  return _internal_has_comparison();
}
inline void ComputeValueProto::set_has_comparison() {
  _oneof_case_[0] = kComparison;
}
inline void ComputeValueProto::clear_comparison() {
  if (_internal_has_comparison()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.comparison_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ValueComparisonProto* ComputeValueProto::release_comparison() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.comparison)
  if (_internal_has_comparison()) {
    clear_has_kind();
    ::autofill_assistant::ValueComparisonProto* temp = kind_.comparison_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.comparison_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ValueComparisonProto& ComputeValueProto::_internal_comparison() const {
  return _internal_has_comparison()
      ? *kind_.comparison_
      : reinterpret_cast< ::autofill_assistant::ValueComparisonProto&>(::autofill_assistant::_ValueComparisonProto_default_instance_);
}
inline const ::autofill_assistant::ValueComparisonProto& ComputeValueProto::comparison() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.comparison)
  return _internal_comparison();
}
inline ::autofill_assistant::ValueComparisonProto* ComputeValueProto::unsafe_arena_release_comparison() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.comparison)
  if (_internal_has_comparison()) {
    clear_has_kind();
    ::autofill_assistant::ValueComparisonProto* temp = kind_.comparison_;
    kind_.comparison_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_comparison(::autofill_assistant::ValueComparisonProto* comparison) {
  clear_kind();
  if (comparison) {
    set_has_comparison();
    kind_.comparison_ = comparison;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.comparison)
}
inline ::autofill_assistant::ValueComparisonProto* ComputeValueProto::_internal_mutable_comparison() {
  if (!_internal_has_comparison()) {
    clear_kind();
    set_has_comparison();
    kind_.comparison_ = CreateMaybeMessage< ::autofill_assistant::ValueComparisonProto >(GetArenaForAllocation());
  }
  return kind_.comparison_;
}
inline ::autofill_assistant::ValueComparisonProto* ComputeValueProto::mutable_comparison() {
  ::autofill_assistant::ValueComparisonProto* _msg = _internal_mutable_comparison();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.comparison)
  return _msg;
}

// .autofill_assistant.IntegerSumProto integer_sum = 7;
inline bool ComputeValueProto::_internal_has_integer_sum() const {
  return kind_case() == kIntegerSum;
}
inline bool ComputeValueProto::has_integer_sum() const {
  return _internal_has_integer_sum();
}
inline void ComputeValueProto::set_has_integer_sum() {
  _oneof_case_[0] = kIntegerSum;
}
inline void ComputeValueProto::clear_integer_sum() {
  if (_internal_has_integer_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.integer_sum_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::IntegerSumProto* ComputeValueProto::release_integer_sum() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.integer_sum)
  if (_internal_has_integer_sum()) {
    clear_has_kind();
    ::autofill_assistant::IntegerSumProto* temp = kind_.integer_sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.integer_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::IntegerSumProto& ComputeValueProto::_internal_integer_sum() const {
  return _internal_has_integer_sum()
      ? *kind_.integer_sum_
      : reinterpret_cast< ::autofill_assistant::IntegerSumProto&>(::autofill_assistant::_IntegerSumProto_default_instance_);
}
inline const ::autofill_assistant::IntegerSumProto& ComputeValueProto::integer_sum() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.integer_sum)
  return _internal_integer_sum();
}
inline ::autofill_assistant::IntegerSumProto* ComputeValueProto::unsafe_arena_release_integer_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.integer_sum)
  if (_internal_has_integer_sum()) {
    clear_has_kind();
    ::autofill_assistant::IntegerSumProto* temp = kind_.integer_sum_;
    kind_.integer_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_integer_sum(::autofill_assistant::IntegerSumProto* integer_sum) {
  clear_kind();
  if (integer_sum) {
    set_has_integer_sum();
    kind_.integer_sum_ = integer_sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.integer_sum)
}
inline ::autofill_assistant::IntegerSumProto* ComputeValueProto::_internal_mutable_integer_sum() {
  if (!_internal_has_integer_sum()) {
    clear_kind();
    set_has_integer_sum();
    kind_.integer_sum_ = CreateMaybeMessage< ::autofill_assistant::IntegerSumProto >(GetArenaForAllocation());
  }
  return kind_.integer_sum_;
}
inline ::autofill_assistant::IntegerSumProto* ComputeValueProto::mutable_integer_sum() {
  ::autofill_assistant::IntegerSumProto* _msg = _internal_mutable_integer_sum();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.integer_sum)
  return _msg;
}

// .autofill_assistant.CreateCreditCardResponseProto create_credit_card_response = 8;
inline bool ComputeValueProto::_internal_has_create_credit_card_response() const {
  return kind_case() == kCreateCreditCardResponse;
}
inline bool ComputeValueProto::has_create_credit_card_response() const {
  return _internal_has_create_credit_card_response();
}
inline void ComputeValueProto::set_has_create_credit_card_response() {
  _oneof_case_[0] = kCreateCreditCardResponse;
}
inline void ComputeValueProto::clear_create_credit_card_response() {
  if (_internal_has_create_credit_card_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.create_credit_card_response_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::CreateCreditCardResponseProto* ComputeValueProto::release_create_credit_card_response() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.create_credit_card_response)
  if (_internal_has_create_credit_card_response()) {
    clear_has_kind();
    ::autofill_assistant::CreateCreditCardResponseProto* temp = kind_.create_credit_card_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.create_credit_card_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CreateCreditCardResponseProto& ComputeValueProto::_internal_create_credit_card_response() const {
  return _internal_has_create_credit_card_response()
      ? *kind_.create_credit_card_response_
      : reinterpret_cast< ::autofill_assistant::CreateCreditCardResponseProto&>(::autofill_assistant::_CreateCreditCardResponseProto_default_instance_);
}
inline const ::autofill_assistant::CreateCreditCardResponseProto& ComputeValueProto::create_credit_card_response() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.create_credit_card_response)
  return _internal_create_credit_card_response();
}
inline ::autofill_assistant::CreateCreditCardResponseProto* ComputeValueProto::unsafe_arena_release_create_credit_card_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.create_credit_card_response)
  if (_internal_has_create_credit_card_response()) {
    clear_has_kind();
    ::autofill_assistant::CreateCreditCardResponseProto* temp = kind_.create_credit_card_response_;
    kind_.create_credit_card_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_create_credit_card_response(::autofill_assistant::CreateCreditCardResponseProto* create_credit_card_response) {
  clear_kind();
  if (create_credit_card_response) {
    set_has_create_credit_card_response();
    kind_.create_credit_card_response_ = create_credit_card_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.create_credit_card_response)
}
inline ::autofill_assistant::CreateCreditCardResponseProto* ComputeValueProto::_internal_mutable_create_credit_card_response() {
  if (!_internal_has_create_credit_card_response()) {
    clear_kind();
    set_has_create_credit_card_response();
    kind_.create_credit_card_response_ = CreateMaybeMessage< ::autofill_assistant::CreateCreditCardResponseProto >(GetArenaForAllocation());
  }
  return kind_.create_credit_card_response_;
}
inline ::autofill_assistant::CreateCreditCardResponseProto* ComputeValueProto::mutable_create_credit_card_response() {
  ::autofill_assistant::CreateCreditCardResponseProto* _msg = _internal_mutable_create_credit_card_response();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.create_credit_card_response)
  return _msg;
}

// .autofill_assistant.CreateLoginOptionResponseProto create_login_option_response = 9;
inline bool ComputeValueProto::_internal_has_create_login_option_response() const {
  return kind_case() == kCreateLoginOptionResponse;
}
inline bool ComputeValueProto::has_create_login_option_response() const {
  return _internal_has_create_login_option_response();
}
inline void ComputeValueProto::set_has_create_login_option_response() {
  _oneof_case_[0] = kCreateLoginOptionResponse;
}
inline void ComputeValueProto::clear_create_login_option_response() {
  if (_internal_has_create_login_option_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.create_login_option_response_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::CreateLoginOptionResponseProto* ComputeValueProto::release_create_login_option_response() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.create_login_option_response)
  if (_internal_has_create_login_option_response()) {
    clear_has_kind();
    ::autofill_assistant::CreateLoginOptionResponseProto* temp = kind_.create_login_option_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.create_login_option_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CreateLoginOptionResponseProto& ComputeValueProto::_internal_create_login_option_response() const {
  return _internal_has_create_login_option_response()
      ? *kind_.create_login_option_response_
      : reinterpret_cast< ::autofill_assistant::CreateLoginOptionResponseProto&>(::autofill_assistant::_CreateLoginOptionResponseProto_default_instance_);
}
inline const ::autofill_assistant::CreateLoginOptionResponseProto& ComputeValueProto::create_login_option_response() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.create_login_option_response)
  return _internal_create_login_option_response();
}
inline ::autofill_assistant::CreateLoginOptionResponseProto* ComputeValueProto::unsafe_arena_release_create_login_option_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.create_login_option_response)
  if (_internal_has_create_login_option_response()) {
    clear_has_kind();
    ::autofill_assistant::CreateLoginOptionResponseProto* temp = kind_.create_login_option_response_;
    kind_.create_login_option_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_create_login_option_response(::autofill_assistant::CreateLoginOptionResponseProto* create_login_option_response) {
  clear_kind();
  if (create_login_option_response) {
    set_has_create_login_option_response();
    kind_.create_login_option_response_ = create_login_option_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.create_login_option_response)
}
inline ::autofill_assistant::CreateLoginOptionResponseProto* ComputeValueProto::_internal_mutable_create_login_option_response() {
  if (!_internal_has_create_login_option_response()) {
    clear_kind();
    set_has_create_login_option_response();
    kind_.create_login_option_response_ = CreateMaybeMessage< ::autofill_assistant::CreateLoginOptionResponseProto >(GetArenaForAllocation());
  }
  return kind_.create_login_option_response_;
}
inline ::autofill_assistant::CreateLoginOptionResponseProto* ComputeValueProto::mutable_create_login_option_response() {
  ::autofill_assistant::CreateLoginOptionResponseProto* _msg = _internal_mutable_create_login_option_response();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.create_login_option_response)
  return _msg;
}

// .autofill_assistant.StringEmptyProto string_empty = 10;
inline bool ComputeValueProto::_internal_has_string_empty() const {
  return kind_case() == kStringEmpty;
}
inline bool ComputeValueProto::has_string_empty() const {
  return _internal_has_string_empty();
}
inline void ComputeValueProto::set_has_string_empty() {
  _oneof_case_[0] = kStringEmpty;
}
inline void ComputeValueProto::clear_string_empty() {
  if (_internal_has_string_empty()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.string_empty_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::StringEmptyProto* ComputeValueProto::release_string_empty() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.string_empty)
  if (_internal_has_string_empty()) {
    clear_has_kind();
    ::autofill_assistant::StringEmptyProto* temp = kind_.string_empty_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.string_empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::StringEmptyProto& ComputeValueProto::_internal_string_empty() const {
  return _internal_has_string_empty()
      ? *kind_.string_empty_
      : reinterpret_cast< ::autofill_assistant::StringEmptyProto&>(::autofill_assistant::_StringEmptyProto_default_instance_);
}
inline const ::autofill_assistant::StringEmptyProto& ComputeValueProto::string_empty() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.string_empty)
  return _internal_string_empty();
}
inline ::autofill_assistant::StringEmptyProto* ComputeValueProto::unsafe_arena_release_string_empty() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ComputeValueProto.string_empty)
  if (_internal_has_string_empty()) {
    clear_has_kind();
    ::autofill_assistant::StringEmptyProto* temp = kind_.string_empty_;
    kind_.string_empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ComputeValueProto::unsafe_arena_set_allocated_string_empty(::autofill_assistant::StringEmptyProto* string_empty) {
  clear_kind();
  if (string_empty) {
    set_has_string_empty();
    kind_.string_empty_ = string_empty;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ComputeValueProto.string_empty)
}
inline ::autofill_assistant::StringEmptyProto* ComputeValueProto::_internal_mutable_string_empty() {
  if (!_internal_has_string_empty()) {
    clear_kind();
    set_has_string_empty();
    kind_.string_empty_ = CreateMaybeMessage< ::autofill_assistant::StringEmptyProto >(GetArenaForAllocation());
  }
  return kind_.string_empty_;
}
inline ::autofill_assistant::StringEmptyProto* ComputeValueProto::mutable_string_empty() {
  ::autofill_assistant::StringEmptyProto* _msg = _internal_mutable_string_empty();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.string_empty)
  return _msg;
}

// optional string result_model_identifier = 1;
inline bool ComputeValueProto::_internal_has_result_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ComputeValueProto::has_result_model_identifier() const {
  return _internal_has_result_model_identifier();
}
inline void ComputeValueProto::clear_result_model_identifier() {
  result_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ComputeValueProto::result_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ComputeValueProto.result_model_identifier)
  return _internal_result_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputeValueProto::set_result_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 result_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ComputeValueProto.result_model_identifier)
}
inline std::string* ComputeValueProto::mutable_result_model_identifier() {
  std::string* _s = _internal_mutable_result_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ComputeValueProto.result_model_identifier)
  return _s;
}
inline const std::string& ComputeValueProto::_internal_result_model_identifier() const {
  return result_model_identifier_.Get();
}
inline void ComputeValueProto::_internal_set_result_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  result_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputeValueProto::_internal_mutable_result_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return result_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputeValueProto::release_result_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ComputeValueProto.result_model_identifier)
  if (!_internal_has_result_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = result_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_model_identifier_.IsDefault()) {
    result_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ComputeValueProto::set_allocated_result_model_identifier(std::string* result_model_identifier) {
  if (result_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_model_identifier_.SetAllocated(result_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_model_identifier_.IsDefault()) {
    result_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.result_model_identifier)
}

inline bool ComputeValueProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ComputeValueProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline ComputeValueProto::KindCase ComputeValueProto::kind_case() const {
  return ComputeValueProto::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BooleanAndProto

// repeated .autofill_assistant.ValueReferenceProto values = 2;
inline int BooleanAndProto::_internal_values_size() const {
  return values_.size();
}
inline int BooleanAndProto::values_size() const {
  return _internal_values_size();
}
inline ::autofill_assistant::ValueReferenceProto* BooleanAndProto::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BooleanAndProto.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >*
BooleanAndProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.BooleanAndProto.values)
  return &values_;
}
inline const ::autofill_assistant::ValueReferenceProto& BooleanAndProto::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::ValueReferenceProto& BooleanAndProto::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BooleanAndProto.values)
  return _internal_values(index);
}
inline ::autofill_assistant::ValueReferenceProto* BooleanAndProto::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::ValueReferenceProto* BooleanAndProto::add_values() {
  ::autofill_assistant::ValueReferenceProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.BooleanAndProto.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >&
BooleanAndProto::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.BooleanAndProto.values)
  return values_;
}

// -------------------------------------------------------------------

// BooleanOrProto

// repeated .autofill_assistant.ValueReferenceProto values = 2;
inline int BooleanOrProto::_internal_values_size() const {
  return values_.size();
}
inline int BooleanOrProto::values_size() const {
  return _internal_values_size();
}
inline ::autofill_assistant::ValueReferenceProto* BooleanOrProto::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BooleanOrProto.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >*
BooleanOrProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.BooleanOrProto.values)
  return &values_;
}
inline const ::autofill_assistant::ValueReferenceProto& BooleanOrProto::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::ValueReferenceProto& BooleanOrProto::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BooleanOrProto.values)
  return _internal_values(index);
}
inline ::autofill_assistant::ValueReferenceProto* BooleanOrProto::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::ValueReferenceProto* BooleanOrProto::add_values() {
  ::autofill_assistant::ValueReferenceProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.BooleanOrProto.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >&
BooleanOrProto::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.BooleanOrProto.values)
  return values_;
}

// -------------------------------------------------------------------

// BooleanNotProto

// optional .autofill_assistant.ValueReferenceProto value = 2;
inline bool BooleanNotProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool BooleanNotProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::ValueReferenceProto& BooleanNotProto::_internal_value() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& BooleanNotProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BooleanNotProto.value)
  return _internal_value();
}
inline void BooleanNotProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueReferenceProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.BooleanNotProto.value)
}
inline ::autofill_assistant::ValueReferenceProto* BooleanNotProto::release_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* BooleanNotProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.BooleanNotProto.value)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* BooleanNotProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueReferenceProto* BooleanNotProto::mutable_value() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BooleanNotProto.value)
  return _msg;
}
inline void BooleanNotProto::set_allocated_value(::autofill_assistant::ValueReferenceProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.BooleanNotProto.value)
}

// -------------------------------------------------------------------

// ToStringProto

// optional .autofill_assistant.ValueReferenceProto value = 3;
inline bool ToStringProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool ToStringProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::ValueReferenceProto& ToStringProto::_internal_value() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ToStringProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToStringProto.value)
  return _internal_value();
}
inline void ToStringProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueReferenceProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToStringProto.value)
}
inline ::autofill_assistant::ValueReferenceProto* ToStringProto::release_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ToStringProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToStringProto.value)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ToStringProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueReferenceProto* ToStringProto::mutable_value() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToStringProto.value)
  return _msg;
}
inline void ToStringProto::set_allocated_value(::autofill_assistant::ValueReferenceProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToStringProto.value)
}

// .autofill_assistant.DateFormatProto date_format = 2;
inline bool ToStringProto::_internal_has_date_format() const {
  return format_options_case() == kDateFormat;
}
inline bool ToStringProto::has_date_format() const {
  return _internal_has_date_format();
}
inline void ToStringProto::set_has_date_format() {
  _oneof_case_[0] = kDateFormat;
}
inline void ToStringProto::clear_date_format() {
  if (_internal_has_date_format()) {
    if (GetArenaForAllocation() == nullptr) {
      delete format_options_.date_format_;
    }
    clear_has_format_options();
  }
}
inline ::autofill_assistant::DateFormatProto* ToStringProto::release_date_format() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToStringProto.date_format)
  if (_internal_has_date_format()) {
    clear_has_format_options();
    ::autofill_assistant::DateFormatProto* temp = format_options_.date_format_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    format_options_.date_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DateFormatProto& ToStringProto::_internal_date_format() const {
  return _internal_has_date_format()
      ? *format_options_.date_format_
      : reinterpret_cast< ::autofill_assistant::DateFormatProto&>(::autofill_assistant::_DateFormatProto_default_instance_);
}
inline const ::autofill_assistant::DateFormatProto& ToStringProto::date_format() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToStringProto.date_format)
  return _internal_date_format();
}
inline ::autofill_assistant::DateFormatProto* ToStringProto::unsafe_arena_release_date_format() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ToStringProto.date_format)
  if (_internal_has_date_format()) {
    clear_has_format_options();
    ::autofill_assistant::DateFormatProto* temp = format_options_.date_format_;
    format_options_.date_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToStringProto::unsafe_arena_set_allocated_date_format(::autofill_assistant::DateFormatProto* date_format) {
  clear_format_options();
  if (date_format) {
    set_has_date_format();
    format_options_.date_format_ = date_format;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToStringProto.date_format)
}
inline ::autofill_assistant::DateFormatProto* ToStringProto::_internal_mutable_date_format() {
  if (!_internal_has_date_format()) {
    clear_format_options();
    set_has_date_format();
    format_options_.date_format_ = CreateMaybeMessage< ::autofill_assistant::DateFormatProto >(GetArenaForAllocation());
  }
  return format_options_.date_format_;
}
inline ::autofill_assistant::DateFormatProto* ToStringProto::mutable_date_format() {
  ::autofill_assistant::DateFormatProto* _msg = _internal_mutable_date_format();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToStringProto.date_format)
  return _msg;
}

// .autofill_assistant.AutofillFormatProto autofill_format = 4;
inline bool ToStringProto::_internal_has_autofill_format() const {
  return format_options_case() == kAutofillFormat;
}
inline bool ToStringProto::has_autofill_format() const {
  return _internal_has_autofill_format();
}
inline void ToStringProto::set_has_autofill_format() {
  _oneof_case_[0] = kAutofillFormat;
}
inline void ToStringProto::clear_autofill_format() {
  if (_internal_has_autofill_format()) {
    if (GetArenaForAllocation() == nullptr) {
      delete format_options_.autofill_format_;
    }
    clear_has_format_options();
  }
}
inline ::autofill_assistant::AutofillFormatProto* ToStringProto::release_autofill_format() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToStringProto.autofill_format)
  if (_internal_has_autofill_format()) {
    clear_has_format_options();
    ::autofill_assistant::AutofillFormatProto* temp = format_options_.autofill_format_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    format_options_.autofill_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::AutofillFormatProto& ToStringProto::_internal_autofill_format() const {
  return _internal_has_autofill_format()
      ? *format_options_.autofill_format_
      : reinterpret_cast< ::autofill_assistant::AutofillFormatProto&>(::autofill_assistant::_AutofillFormatProto_default_instance_);
}
inline const ::autofill_assistant::AutofillFormatProto& ToStringProto::autofill_format() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToStringProto.autofill_format)
  return _internal_autofill_format();
}
inline ::autofill_assistant::AutofillFormatProto* ToStringProto::unsafe_arena_release_autofill_format() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ToStringProto.autofill_format)
  if (_internal_has_autofill_format()) {
    clear_has_format_options();
    ::autofill_assistant::AutofillFormatProto* temp = format_options_.autofill_format_;
    format_options_.autofill_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToStringProto::unsafe_arena_set_allocated_autofill_format(::autofill_assistant::AutofillFormatProto* autofill_format) {
  clear_format_options();
  if (autofill_format) {
    set_has_autofill_format();
    format_options_.autofill_format_ = autofill_format;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToStringProto.autofill_format)
}
inline ::autofill_assistant::AutofillFormatProto* ToStringProto::_internal_mutable_autofill_format() {
  if (!_internal_has_autofill_format()) {
    clear_format_options();
    set_has_autofill_format();
    format_options_.autofill_format_ = CreateMaybeMessage< ::autofill_assistant::AutofillFormatProto >(GetArenaForAllocation());
  }
  return format_options_.autofill_format_;
}
inline ::autofill_assistant::AutofillFormatProto* ToStringProto::mutable_autofill_format() {
  ::autofill_assistant::AutofillFormatProto* _msg = _internal_mutable_autofill_format();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToStringProto.autofill_format)
  return _msg;
}

inline bool ToStringProto::has_format_options() const {
  return format_options_case() != FORMAT_OPTIONS_NOT_SET;
}
inline void ToStringProto::clear_has_format_options() {
  _oneof_case_[0] = FORMAT_OPTIONS_NOT_SET;
}
inline ToStringProto::FormatOptionsCase ToStringProto::format_options_case() const {
  return ToStringProto::FormatOptionsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DateFormatProto

// optional string date_format = 1;
inline bool DateFormatProto::_internal_has_date_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DateFormatProto::has_date_format() const {
  return _internal_has_date_format();
}
inline void DateFormatProto::clear_date_format() {
  date_format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DateFormatProto::date_format() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateFormatProto.date_format)
  return _internal_date_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DateFormatProto::set_date_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 date_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DateFormatProto.date_format)
}
inline std::string* DateFormatProto::mutable_date_format() {
  std::string* _s = _internal_mutable_date_format();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DateFormatProto.date_format)
  return _s;
}
inline const std::string& DateFormatProto::_internal_date_format() const {
  return date_format_.Get();
}
inline void DateFormatProto::_internal_set_date_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  date_format_.Set(value, GetArenaForAllocation());
}
inline std::string* DateFormatProto::_internal_mutable_date_format() {
  _has_bits_[0] |= 0x00000001u;
  return date_format_.Mutable(GetArenaForAllocation());
}
inline std::string* DateFormatProto::release_date_format() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DateFormatProto.date_format)
  if (!_internal_has_date_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = date_format_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_format_.IsDefault()) {
    date_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DateFormatProto::set_allocated_date_format(std::string* date_format) {
  if (date_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  date_format_.SetAllocated(date_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_format_.IsDefault()) {
    date_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DateFormatProto.date_format)
}

// -------------------------------------------------------------------

// AutofillFormatProto

// optional .autofill_assistant.ValueExpression value_expression = 3;
inline bool AutofillFormatProto::_internal_has_value_expression() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_expression_ != nullptr);
  return value;
}
inline bool AutofillFormatProto::has_value_expression() const {
  return _internal_has_value_expression();
}
inline const ::autofill_assistant::ValueExpression& AutofillFormatProto::_internal_value_expression() const {
  const ::autofill_assistant::ValueExpression* p = value_expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueExpression&>(
      ::autofill_assistant::_ValueExpression_default_instance_);
}
inline const ::autofill_assistant::ValueExpression& AutofillFormatProto::value_expression() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillFormatProto.value_expression)
  return _internal_value_expression();
}
inline void AutofillFormatProto::unsafe_arena_set_allocated_value_expression(
    ::autofill_assistant::ValueExpression* value_expression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_);
  }
  value_expression_ = value_expression;
  if (value_expression) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillFormatProto.value_expression)
}
inline ::autofill_assistant::ValueExpression* AutofillFormatProto::release_value_expression() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueExpression* AutofillFormatProto::unsafe_arena_release_value_expression() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillFormatProto.value_expression)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueExpression* AutofillFormatProto::_internal_mutable_value_expression() {
  _has_bits_[0] |= 0x00000002u;
  if (value_expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueExpression>(GetArenaForAllocation());
    value_expression_ = p;
  }
  return value_expression_;
}
inline ::autofill_assistant::ValueExpression* AutofillFormatProto::mutable_value_expression() {
  ::autofill_assistant::ValueExpression* _msg = _internal_mutable_value_expression();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillFormatProto.value_expression)
  return _msg;
}
inline void AutofillFormatProto::set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_);
  }
  if (value_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression));
    if (message_arena != submessage_arena) {
      value_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_expression, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_expression_ = value_expression;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillFormatProto.value_expression)
}

// optional string locale = 2;
inline bool AutofillFormatProto::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillFormatProto::has_locale() const {
  return _internal_has_locale();
}
inline void AutofillFormatProto::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillFormatProto::locale() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillFormatProto.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillFormatProto::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillFormatProto.locale)
}
inline std::string* AutofillFormatProto::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillFormatProto.locale)
  return _s;
}
inline const std::string& AutofillFormatProto::_internal_locale() const {
  return locale_.Get();
}
inline void AutofillFormatProto::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillFormatProto::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillFormatProto::release_locale() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillFormatProto.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillFormatProto::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillFormatProto.locale)
}

// -------------------------------------------------------------------

// ValueComparisonProto

// optional .autofill_assistant.ValueReferenceProto value_a = 4;
inline bool ValueComparisonProto::_internal_has_value_a() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_a_ != nullptr);
  return value;
}
inline bool ValueComparisonProto::has_value_a() const {
  return _internal_has_value_a();
}
inline const ::autofill_assistant::ValueReferenceProto& ValueComparisonProto::_internal_value_a() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_a_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ValueComparisonProto::value_a() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueComparisonProto.value_a)
  return _internal_value_a();
}
inline void ValueComparisonProto::unsafe_arena_set_allocated_value_a(
    ::autofill_assistant::ValueReferenceProto* value_a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_a_);
  }
  value_a_ = value_a;
  if (value_a) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueComparisonProto.value_a)
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::release_value_a() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_a_;
  value_a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::unsafe_arena_release_value_a() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueComparisonProto.value_a)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_a_;
  value_a_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::_internal_mutable_value_a() {
  _has_bits_[0] |= 0x00000001u;
  if (value_a_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_a_ = p;
  }
  return value_a_;
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::mutable_value_a() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value_a();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueComparisonProto.value_a)
  return _msg;
}
inline void ValueComparisonProto::set_allocated_value_a(::autofill_assistant::ValueReferenceProto* value_a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_a_);
  }
  if (value_a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_a));
    if (message_arena != submessage_arena) {
      value_a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_a, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_a_ = value_a;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueComparisonProto.value_a)
}

// optional .autofill_assistant.ValueReferenceProto value_b = 5;
inline bool ValueComparisonProto::_internal_has_value_b() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_b_ != nullptr);
  return value;
}
inline bool ValueComparisonProto::has_value_b() const {
  return _internal_has_value_b();
}
inline const ::autofill_assistant::ValueReferenceProto& ValueComparisonProto::_internal_value_b() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_b_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ValueComparisonProto::value_b() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueComparisonProto.value_b)
  return _internal_value_b();
}
inline void ValueComparisonProto::unsafe_arena_set_allocated_value_b(
    ::autofill_assistant::ValueReferenceProto* value_b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_b_);
  }
  value_b_ = value_b;
  if (value_b) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueComparisonProto.value_b)
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::release_value_b() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = value_b_;
  value_b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::unsafe_arena_release_value_b() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueComparisonProto.value_b)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = value_b_;
  value_b_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::_internal_mutable_value_b() {
  _has_bits_[0] |= 0x00000002u;
  if (value_b_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_b_ = p;
  }
  return value_b_;
}
inline ::autofill_assistant::ValueReferenceProto* ValueComparisonProto::mutable_value_b() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value_b();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueComparisonProto.value_b)
  return _msg;
}
inline void ValueComparisonProto::set_allocated_value_b(::autofill_assistant::ValueReferenceProto* value_b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_b_);
  }
  if (value_b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_b));
    if (message_arena != submessage_arena) {
      value_b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_b, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_b_ = value_b;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueComparisonProto.value_b)
}

// optional .autofill_assistant.ValueComparisonProto.Mode mode = 3;
inline bool ValueComparisonProto::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ValueComparisonProto::has_mode() const {
  return _internal_has_mode();
}
inline void ValueComparisonProto::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::ValueComparisonProto_Mode ValueComparisonProto::_internal_mode() const {
  return static_cast< ::autofill_assistant::ValueComparisonProto_Mode >(mode_);
}
inline ::autofill_assistant::ValueComparisonProto_Mode ValueComparisonProto::mode() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueComparisonProto.mode)
  return _internal_mode();
}
inline void ValueComparisonProto::_internal_set_mode(::autofill_assistant::ValueComparisonProto_Mode value) {
  assert(::autofill_assistant::ValueComparisonProto_Mode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  mode_ = value;
}
inline void ValueComparisonProto::set_mode(::autofill_assistant::ValueComparisonProto_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueComparisonProto.mode)
}

// -------------------------------------------------------------------

// IntegerSumProto

// repeated .autofill_assistant.ValueReferenceProto values = 3;
inline int IntegerSumProto::_internal_values_size() const {
  return values_.size();
}
inline int IntegerSumProto::values_size() const {
  return _internal_values_size();
}
inline ::autofill_assistant::ValueReferenceProto* IntegerSumProto::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.IntegerSumProto.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >*
IntegerSumProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.IntegerSumProto.values)
  return &values_;
}
inline const ::autofill_assistant::ValueReferenceProto& IntegerSumProto::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::ValueReferenceProto& IntegerSumProto::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.IntegerSumProto.values)
  return _internal_values(index);
}
inline ::autofill_assistant::ValueReferenceProto* IntegerSumProto::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::ValueReferenceProto* IntegerSumProto::add_values() {
  ::autofill_assistant::ValueReferenceProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.IntegerSumProto.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueReferenceProto >&
IntegerSumProto::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.IntegerSumProto.values)
  return values_;
}

// -------------------------------------------------------------------

// CreateCreditCardResponseProto

// optional .autofill_assistant.ValueReferenceProto value = 1;
inline bool CreateCreditCardResponseProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool CreateCreditCardResponseProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::ValueReferenceProto& CreateCreditCardResponseProto::_internal_value() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& CreateCreditCardResponseProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreateCreditCardResponseProto.value)
  return _internal_value();
}
inline void CreateCreditCardResponseProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueReferenceProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CreateCreditCardResponseProto.value)
}
inline ::autofill_assistant::ValueReferenceProto* CreateCreditCardResponseProto::release_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* CreateCreditCardResponseProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CreateCreditCardResponseProto.value)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* CreateCreditCardResponseProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueReferenceProto* CreateCreditCardResponseProto::mutable_value() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreateCreditCardResponseProto.value)
  return _msg;
}
inline void CreateCreditCardResponseProto::set_allocated_value(::autofill_assistant::ValueReferenceProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CreateCreditCardResponseProto.value)
}

// -------------------------------------------------------------------

// CreateLoginOptionResponseProto

// optional .autofill_assistant.ValueReferenceProto value = 1;
inline bool CreateLoginOptionResponseProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool CreateLoginOptionResponseProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::ValueReferenceProto& CreateLoginOptionResponseProto::_internal_value() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& CreateLoginOptionResponseProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreateLoginOptionResponseProto.value)
  return _internal_value();
}
inline void CreateLoginOptionResponseProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueReferenceProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CreateLoginOptionResponseProto.value)
}
inline ::autofill_assistant::ValueReferenceProto* CreateLoginOptionResponseProto::release_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* CreateLoginOptionResponseProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CreateLoginOptionResponseProto.value)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* CreateLoginOptionResponseProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueReferenceProto* CreateLoginOptionResponseProto::mutable_value() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreateLoginOptionResponseProto.value)
  return _msg;
}
inline void CreateLoginOptionResponseProto::set_allocated_value(::autofill_assistant::ValueReferenceProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CreateLoginOptionResponseProto.value)
}

// -------------------------------------------------------------------

// StringEmptyProto

// optional .autofill_assistant.ValueReferenceProto value = 1;
inline bool StringEmptyProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool StringEmptyProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::ValueReferenceProto& StringEmptyProto::_internal_value() const {
  const ::autofill_assistant::ValueReferenceProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& StringEmptyProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.StringEmptyProto.value)
  return _internal_value();
}
inline void StringEmptyProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueReferenceProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.StringEmptyProto.value)
}
inline ::autofill_assistant::ValueReferenceProto* StringEmptyProto::release_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* StringEmptyProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.StringEmptyProto.value)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* StringEmptyProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueReferenceProto* StringEmptyProto::mutable_value() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.StringEmptyProto.value)
  return _msg;
}
inline void StringEmptyProto::set_allocated_value(::autofill_assistant::ValueReferenceProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.StringEmptyProto.value)
}

// -------------------------------------------------------------------

// ShowInfoPopupProto

// optional .autofill_assistant.InfoPopupProto info_popup = 1;
inline bool ShowInfoPopupProto::_internal_has_info_popup() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_popup_ != nullptr);
  return value;
}
inline bool ShowInfoPopupProto::has_info_popup() const {
  return _internal_has_info_popup();
}
inline const ::autofill_assistant::InfoPopupProto& ShowInfoPopupProto::_internal_info_popup() const {
  const ::autofill_assistant::InfoPopupProto* p = info_popup_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoPopupProto&>(
      ::autofill_assistant::_InfoPopupProto_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto& ShowInfoPopupProto::info_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowInfoPopupProto.info_popup)
  return _internal_info_popup();
}
inline void ShowInfoPopupProto::unsafe_arena_set_allocated_info_popup(
    ::autofill_assistant::InfoPopupProto* info_popup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup_);
  }
  info_popup_ = info_popup;
  if (info_popup) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowInfoPopupProto.info_popup)
}
inline ::autofill_assistant::InfoPopupProto* ShowInfoPopupProto::release_info_popup() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::InfoPopupProto* temp = info_popup_;
  info_popup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoPopupProto* ShowInfoPopupProto::unsafe_arena_release_info_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowInfoPopupProto.info_popup)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::InfoPopupProto* temp = info_popup_;
  info_popup_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoPopupProto* ShowInfoPopupProto::_internal_mutable_info_popup() {
  _has_bits_[0] |= 0x00000001u;
  if (info_popup_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoPopupProto>(GetArenaForAllocation());
    info_popup_ = p;
  }
  return info_popup_;
}
inline ::autofill_assistant::InfoPopupProto* ShowInfoPopupProto::mutable_info_popup() {
  ::autofill_assistant::InfoPopupProto* _msg = _internal_mutable_info_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowInfoPopupProto.info_popup)
  return _msg;
}
inline void ShowInfoPopupProto::set_allocated_info_popup(::autofill_assistant::InfoPopupProto* info_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup_);
  }
  if (info_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup));
    if (message_arena != submessage_arena) {
      info_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info_popup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_popup_ = info_popup;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowInfoPopupProto.info_popup)
}

// -------------------------------------------------------------------

// ShowListPopupProto

// optional .autofill_assistant.ValueReferenceProto item_names = 6;
inline bool ShowListPopupProto::_internal_has_item_names() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || item_names_ != nullptr);
  return value;
}
inline bool ShowListPopupProto::has_item_names() const {
  return _internal_has_item_names();
}
inline const ::autofill_assistant::ValueReferenceProto& ShowListPopupProto::_internal_item_names() const {
  const ::autofill_assistant::ValueReferenceProto* p = item_names_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ShowListPopupProto::item_names() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowListPopupProto.item_names)
  return _internal_item_names();
}
inline void ShowListPopupProto::unsafe_arena_set_allocated_item_names(
    ::autofill_assistant::ValueReferenceProto* item_names) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_names_);
  }
  item_names_ = item_names;
  if (item_names) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowListPopupProto.item_names)
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::release_item_names() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueReferenceProto* temp = item_names_;
  item_names_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::unsafe_arena_release_item_names() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowListPopupProto.item_names)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueReferenceProto* temp = item_names_;
  item_names_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::_internal_mutable_item_names() {
  _has_bits_[0] |= 0x00000004u;
  if (item_names_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    item_names_ = p;
  }
  return item_names_;
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::mutable_item_names() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_item_names();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowListPopupProto.item_names)
  return _msg;
}
inline void ShowListPopupProto::set_allocated_item_names(::autofill_assistant::ValueReferenceProto* item_names) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_names_);
  }
  if (item_names) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_names));
    if (message_arena != submessage_arena) {
      item_names = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_names, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  item_names_ = item_names;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowListPopupProto.item_names)
}

// optional .autofill_assistant.ValueReferenceProto item_types = 7;
inline bool ShowListPopupProto::_internal_has_item_types() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || item_types_ != nullptr);
  return value;
}
inline bool ShowListPopupProto::has_item_types() const {
  return _internal_has_item_types();
}
inline const ::autofill_assistant::ValueReferenceProto& ShowListPopupProto::_internal_item_types() const {
  const ::autofill_assistant::ValueReferenceProto* p = item_types_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ShowListPopupProto::item_types() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowListPopupProto.item_types)
  return _internal_item_types();
}
inline void ShowListPopupProto::unsafe_arena_set_allocated_item_types(
    ::autofill_assistant::ValueReferenceProto* item_types) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_types_);
  }
  item_types_ = item_types;
  if (item_types) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowListPopupProto.item_types)
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::release_item_types() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ValueReferenceProto* temp = item_types_;
  item_types_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::unsafe_arena_release_item_types() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowListPopupProto.item_types)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ValueReferenceProto* temp = item_types_;
  item_types_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::_internal_mutable_item_types() {
  _has_bits_[0] |= 0x00000008u;
  if (item_types_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    item_types_ = p;
  }
  return item_types_;
}
inline ::autofill_assistant::ValueReferenceProto* ShowListPopupProto::mutable_item_types() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_item_types();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowListPopupProto.item_types)
  return _msg;
}
inline void ShowListPopupProto::set_allocated_item_types(::autofill_assistant::ValueReferenceProto* item_types) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_types_);
  }
  if (item_types) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item_types));
    if (message_arena != submessage_arena) {
      item_types = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_types, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  item_types_ = item_types;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowListPopupProto.item_types)
}

// optional string selected_item_indices_model_identifier = 3;
inline bool ShowListPopupProto::_internal_has_selected_item_indices_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowListPopupProto::has_selected_item_indices_model_identifier() const {
  return _internal_has_selected_item_indices_model_identifier();
}
inline void ShowListPopupProto::clear_selected_item_indices_model_identifier() {
  selected_item_indices_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowListPopupProto::selected_item_indices_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowListPopupProto.selected_item_indices_model_identifier)
  return _internal_selected_item_indices_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowListPopupProto::set_selected_item_indices_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 selected_item_indices_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowListPopupProto.selected_item_indices_model_identifier)
}
inline std::string* ShowListPopupProto::mutable_selected_item_indices_model_identifier() {
  std::string* _s = _internal_mutable_selected_item_indices_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowListPopupProto.selected_item_indices_model_identifier)
  return _s;
}
inline const std::string& ShowListPopupProto::_internal_selected_item_indices_model_identifier() const {
  return selected_item_indices_model_identifier_.Get();
}
inline void ShowListPopupProto::_internal_set_selected_item_indices_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  selected_item_indices_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowListPopupProto::_internal_mutable_selected_item_indices_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return selected_item_indices_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowListPopupProto::release_selected_item_indices_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowListPopupProto.selected_item_indices_model_identifier)
  if (!_internal_has_selected_item_indices_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = selected_item_indices_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_item_indices_model_identifier_.IsDefault()) {
    selected_item_indices_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowListPopupProto::set_allocated_selected_item_indices_model_identifier(std::string* selected_item_indices_model_identifier) {
  if (selected_item_indices_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  selected_item_indices_model_identifier_.SetAllocated(selected_item_indices_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_item_indices_model_identifier_.IsDefault()) {
    selected_item_indices_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowListPopupProto.selected_item_indices_model_identifier)
}

// optional bool allow_multiselect = 4;
inline bool ShowListPopupProto::_internal_has_allow_multiselect() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShowListPopupProto::has_allow_multiselect() const {
  return _internal_has_allow_multiselect();
}
inline void ShowListPopupProto::clear_allow_multiselect() {
  allow_multiselect_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ShowListPopupProto::_internal_allow_multiselect() const {
  return allow_multiselect_;
}
inline bool ShowListPopupProto::allow_multiselect() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowListPopupProto.allow_multiselect)
  return _internal_allow_multiselect();
}
inline void ShowListPopupProto::_internal_set_allow_multiselect(bool value) {
  _has_bits_[0] |= 0x00000010u;
  allow_multiselect_ = value;
}
inline void ShowListPopupProto::set_allow_multiselect(bool value) {
  _internal_set_allow_multiselect(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowListPopupProto.allow_multiselect)
}

// optional string selected_item_names_model_identifier = 5;
inline bool ShowListPopupProto::_internal_has_selected_item_names_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowListPopupProto::has_selected_item_names_model_identifier() const {
  return _internal_has_selected_item_names_model_identifier();
}
inline void ShowListPopupProto::clear_selected_item_names_model_identifier() {
  selected_item_names_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShowListPopupProto::selected_item_names_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowListPopupProto.selected_item_names_model_identifier)
  return _internal_selected_item_names_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowListPopupProto::set_selected_item_names_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 selected_item_names_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowListPopupProto.selected_item_names_model_identifier)
}
inline std::string* ShowListPopupProto::mutable_selected_item_names_model_identifier() {
  std::string* _s = _internal_mutable_selected_item_names_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowListPopupProto.selected_item_names_model_identifier)
  return _s;
}
inline const std::string& ShowListPopupProto::_internal_selected_item_names_model_identifier() const {
  return selected_item_names_model_identifier_.Get();
}
inline void ShowListPopupProto::_internal_set_selected_item_names_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  selected_item_names_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowListPopupProto::_internal_mutable_selected_item_names_model_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return selected_item_names_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowListPopupProto::release_selected_item_names_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowListPopupProto.selected_item_names_model_identifier)
  if (!_internal_has_selected_item_names_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = selected_item_names_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_item_names_model_identifier_.IsDefault()) {
    selected_item_names_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowListPopupProto::set_allocated_selected_item_names_model_identifier(std::string* selected_item_names_model_identifier) {
  if (selected_item_names_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  selected_item_names_model_identifier_.SetAllocated(selected_item_names_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_item_names_model_identifier_.IsDefault()) {
    selected_item_names_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowListPopupProto.selected_item_names_model_identifier)
}

// -------------------------------------------------------------------

// SetUserActionsProto

// optional .autofill_assistant.ValueReferenceProto user_actions = 2;
inline bool SetUserActionsProto::_internal_has_user_actions() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || user_actions_ != nullptr);
  return value;
}
inline bool SetUserActionsProto::has_user_actions() const {
  return _internal_has_user_actions();
}
inline const ::autofill_assistant::ValueReferenceProto& SetUserActionsProto::_internal_user_actions() const {
  const ::autofill_assistant::ValueReferenceProto* p = user_actions_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& SetUserActionsProto::user_actions() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetUserActionsProto.user_actions)
  return _internal_user_actions();
}
inline void SetUserActionsProto::unsafe_arena_set_allocated_user_actions(
    ::autofill_assistant::ValueReferenceProto* user_actions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_actions_);
  }
  user_actions_ = user_actions;
  if (user_actions) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetUserActionsProto.user_actions)
}
inline ::autofill_assistant::ValueReferenceProto* SetUserActionsProto::release_user_actions() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = user_actions_;
  user_actions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetUserActionsProto::unsafe_arena_release_user_actions() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetUserActionsProto.user_actions)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueReferenceProto* temp = user_actions_;
  user_actions_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetUserActionsProto::_internal_mutable_user_actions() {
  _has_bits_[0] |= 0x00000001u;
  if (user_actions_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    user_actions_ = p;
  }
  return user_actions_;
}
inline ::autofill_assistant::ValueReferenceProto* SetUserActionsProto::mutable_user_actions() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_user_actions();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetUserActionsProto.user_actions)
  return _msg;
}
inline void SetUserActionsProto::set_allocated_user_actions(::autofill_assistant::ValueReferenceProto* user_actions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_actions_);
  }
  if (user_actions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_actions));
    if (message_arena != submessage_arena) {
      user_actions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_actions, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_actions_ = user_actions;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetUserActionsProto.user_actions)
}

// -------------------------------------------------------------------

// ToggleUserActionProto

// optional string user_actions_model_identifier = 1;
inline bool ToggleUserActionProto::_internal_has_user_actions_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ToggleUserActionProto::has_user_actions_model_identifier() const {
  return _internal_has_user_actions_model_identifier();
}
inline void ToggleUserActionProto::clear_user_actions_model_identifier() {
  user_actions_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ToggleUserActionProto::user_actions_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleUserActionProto.user_actions_model_identifier)
  return _internal_user_actions_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToggleUserActionProto::set_user_actions_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_actions_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ToggleUserActionProto.user_actions_model_identifier)
}
inline std::string* ToggleUserActionProto::mutable_user_actions_model_identifier() {
  std::string* _s = _internal_mutable_user_actions_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleUserActionProto.user_actions_model_identifier)
  return _s;
}
inline const std::string& ToggleUserActionProto::_internal_user_actions_model_identifier() const {
  return user_actions_model_identifier_.Get();
}
inline void ToggleUserActionProto::_internal_set_user_actions_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_actions_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ToggleUserActionProto::_internal_mutable_user_actions_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return user_actions_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ToggleUserActionProto::release_user_actions_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleUserActionProto.user_actions_model_identifier)
  if (!_internal_has_user_actions_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_actions_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_actions_model_identifier_.IsDefault()) {
    user_actions_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ToggleUserActionProto::set_allocated_user_actions_model_identifier(std::string* user_actions_model_identifier) {
  if (user_actions_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_actions_model_identifier_.SetAllocated(user_actions_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_actions_model_identifier_.IsDefault()) {
    user_actions_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleUserActionProto.user_actions_model_identifier)
}

// optional string user_action_identifier = 2;
inline bool ToggleUserActionProto::_internal_has_user_action_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ToggleUserActionProto::has_user_action_identifier() const {
  return _internal_has_user_action_identifier();
}
inline void ToggleUserActionProto::clear_user_action_identifier() {
  user_action_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ToggleUserActionProto::user_action_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleUserActionProto.user_action_identifier)
  return _internal_user_action_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToggleUserActionProto::set_user_action_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_action_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ToggleUserActionProto.user_action_identifier)
}
inline std::string* ToggleUserActionProto::mutable_user_action_identifier() {
  std::string* _s = _internal_mutable_user_action_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleUserActionProto.user_action_identifier)
  return _s;
}
inline const std::string& ToggleUserActionProto::_internal_user_action_identifier() const {
  return user_action_identifier_.Get();
}
inline void ToggleUserActionProto::_internal_set_user_action_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_action_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ToggleUserActionProto::_internal_mutable_user_action_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return user_action_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ToggleUserActionProto::release_user_action_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleUserActionProto.user_action_identifier)
  if (!_internal_has_user_action_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_action_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_action_identifier_.IsDefault()) {
    user_action_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ToggleUserActionProto::set_allocated_user_action_identifier(std::string* user_action_identifier) {
  if (user_action_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_action_identifier_.SetAllocated(user_action_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_action_identifier_.IsDefault()) {
    user_action_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleUserActionProto.user_action_identifier)
}

// optional .autofill_assistant.ValueReferenceProto enabled = 4;
inline bool ToggleUserActionProto::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || enabled_ != nullptr);
  return value;
}
inline bool ToggleUserActionProto::has_enabled() const {
  return _internal_has_enabled();
}
inline const ::autofill_assistant::ValueReferenceProto& ToggleUserActionProto::_internal_enabled() const {
  const ::autofill_assistant::ValueReferenceProto* p = enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ToggleUserActionProto::enabled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleUserActionProto.enabled)
  return _internal_enabled();
}
inline void ToggleUserActionProto::unsafe_arena_set_allocated_enabled(
    ::autofill_assistant::ValueReferenceProto* enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled_);
  }
  enabled_ = enabled;
  if (enabled) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToggleUserActionProto.enabled)
}
inline ::autofill_assistant::ValueReferenceProto* ToggleUserActionProto::release_enabled() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueReferenceProto* temp = enabled_;
  enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ToggleUserActionProto::unsafe_arena_release_enabled() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleUserActionProto.enabled)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueReferenceProto* temp = enabled_;
  enabled_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ToggleUserActionProto::_internal_mutable_enabled() {
  _has_bits_[0] |= 0x00000004u;
  if (enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    enabled_ = p;
  }
  return enabled_;
}
inline ::autofill_assistant::ValueReferenceProto* ToggleUserActionProto::mutable_enabled() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_enabled();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleUserActionProto.enabled)
  return _msg;
}
inline void ToggleUserActionProto::set_allocated_enabled(::autofill_assistant::ValueReferenceProto* enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled_);
  }
  if (enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled));
    if (message_arena != submessage_arena) {
      enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enabled, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  enabled_ = enabled;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleUserActionProto.enabled)
}

// -------------------------------------------------------------------

// EndActionProto

// optional .autofill_assistant.ProcessedActionStatusProto status = 1;
inline bool EndActionProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EndActionProto::has_status() const {
  return _internal_has_status();
}
inline void EndActionProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::ProcessedActionStatusProto EndActionProto::_internal_status() const {
  return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(status_);
}
inline ::autofill_assistant::ProcessedActionStatusProto EndActionProto::status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EndActionProto.status)
  return _internal_status();
}
inline void EndActionProto::_internal_set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  assert(::autofill_assistant::ProcessedActionStatusProto_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void EndActionProto::set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.EndActionProto.status)
}

// -------------------------------------------------------------------

// ShowCalendarPopupProto

// optional string date_model_identifier = 1;
inline bool ShowCalendarPopupProto::_internal_has_date_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowCalendarPopupProto::has_date_model_identifier() const {
  return _internal_has_date_model_identifier();
}
inline void ShowCalendarPopupProto::clear_date_model_identifier() {
  date_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowCalendarPopupProto::date_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCalendarPopupProto.date_model_identifier)
  return _internal_date_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowCalendarPopupProto::set_date_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 date_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowCalendarPopupProto.date_model_identifier)
}
inline std::string* ShowCalendarPopupProto::mutable_date_model_identifier() {
  std::string* _s = _internal_mutable_date_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCalendarPopupProto.date_model_identifier)
  return _s;
}
inline const std::string& ShowCalendarPopupProto::_internal_date_model_identifier() const {
  return date_model_identifier_.Get();
}
inline void ShowCalendarPopupProto::_internal_set_date_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  date_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowCalendarPopupProto::_internal_mutable_date_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return date_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowCalendarPopupProto::release_date_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCalendarPopupProto.date_model_identifier)
  if (!_internal_has_date_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = date_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_model_identifier_.IsDefault()) {
    date_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowCalendarPopupProto::set_allocated_date_model_identifier(std::string* date_model_identifier) {
  if (date_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  date_model_identifier_.SetAllocated(date_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_model_identifier_.IsDefault()) {
    date_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCalendarPopupProto.date_model_identifier)
}

// optional .autofill_assistant.ValueReferenceProto min_date = 4;
inline bool ShowCalendarPopupProto::_internal_has_min_date() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || min_date_ != nullptr);
  return value;
}
inline bool ShowCalendarPopupProto::has_min_date() const {
  return _internal_has_min_date();
}
inline const ::autofill_assistant::ValueReferenceProto& ShowCalendarPopupProto::_internal_min_date() const {
  const ::autofill_assistant::ValueReferenceProto* p = min_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ShowCalendarPopupProto::min_date() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCalendarPopupProto.min_date)
  return _internal_min_date();
}
inline void ShowCalendarPopupProto::unsafe_arena_set_allocated_min_date(
    ::autofill_assistant::ValueReferenceProto* min_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_date_);
  }
  min_date_ = min_date;
  if (min_date) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowCalendarPopupProto.min_date)
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::release_min_date() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = min_date_;
  min_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::unsafe_arena_release_min_date() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCalendarPopupProto.min_date)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = min_date_;
  min_date_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::_internal_mutable_min_date() {
  _has_bits_[0] |= 0x00000002u;
  if (min_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    min_date_ = p;
  }
  return min_date_;
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::mutable_min_date() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_min_date();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCalendarPopupProto.min_date)
  return _msg;
}
inline void ShowCalendarPopupProto::set_allocated_min_date(::autofill_assistant::ValueReferenceProto* min_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_date_);
  }
  if (min_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_date));
    if (message_arena != submessage_arena) {
      min_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  min_date_ = min_date;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCalendarPopupProto.min_date)
}

// optional .autofill_assistant.ValueReferenceProto max_date = 5;
inline bool ShowCalendarPopupProto::_internal_has_max_date() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || max_date_ != nullptr);
  return value;
}
inline bool ShowCalendarPopupProto::has_max_date() const {
  return _internal_has_max_date();
}
inline const ::autofill_assistant::ValueReferenceProto& ShowCalendarPopupProto::_internal_max_date() const {
  const ::autofill_assistant::ValueReferenceProto* p = max_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& ShowCalendarPopupProto::max_date() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCalendarPopupProto.max_date)
  return _internal_max_date();
}
inline void ShowCalendarPopupProto::unsafe_arena_set_allocated_max_date(
    ::autofill_assistant::ValueReferenceProto* max_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_date_);
  }
  max_date_ = max_date;
  if (max_date) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowCalendarPopupProto.max_date)
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::release_max_date() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueReferenceProto* temp = max_date_;
  max_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::unsafe_arena_release_max_date() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCalendarPopupProto.max_date)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueReferenceProto* temp = max_date_;
  max_date_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::_internal_mutable_max_date() {
  _has_bits_[0] |= 0x00000004u;
  if (max_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    max_date_ = p;
  }
  return max_date_;
}
inline ::autofill_assistant::ValueReferenceProto* ShowCalendarPopupProto::mutable_max_date() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_max_date();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCalendarPopupProto.max_date)
  return _msg;
}
inline void ShowCalendarPopupProto::set_allocated_max_date(::autofill_assistant::ValueReferenceProto* max_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_date_);
  }
  if (max_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_date));
    if (message_arena != submessage_arena) {
      max_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  max_date_ = max_date;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCalendarPopupProto.max_date)
}

// -------------------------------------------------------------------

// SetTextProto

// optional .autofill_assistant.ValueReferenceProto text = 3;
inline bool SetTextProto::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || text_ != nullptr);
  return value;
}
inline bool SetTextProto::has_text() const {
  return _internal_has_text();
}
inline const ::autofill_assistant::ValueReferenceProto& SetTextProto::_internal_text() const {
  const ::autofill_assistant::ValueReferenceProto* p = text_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& SetTextProto::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetTextProto.text)
  return _internal_text();
}
inline void SetTextProto::unsafe_arena_set_allocated_text(
    ::autofill_assistant::ValueReferenceProto* text) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_);
  }
  text_ = text;
  if (text) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetTextProto.text)
}
inline ::autofill_assistant::ValueReferenceProto* SetTextProto::release_text() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = text_;
  text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetTextProto::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetTextProto.text)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = text_;
  text_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetTextProto::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  if (text_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    text_ = p;
  }
  return text_;
}
inline ::autofill_assistant::ValueReferenceProto* SetTextProto::mutable_text() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetTextProto.text)
  return _msg;
}
inline void SetTextProto::set_allocated_text(::autofill_assistant::ValueReferenceProto* text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_);
  }
  if (text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text));
    if (message_arena != submessage_arena) {
      text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetTextProto.text)
}

// optional string view_identifier = 2;
inline bool SetTextProto::_internal_has_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetTextProto::has_view_identifier() const {
  return _internal_has_view_identifier();
}
inline void SetTextProto::clear_view_identifier() {
  view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetTextProto::view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetTextProto.view_identifier)
  return _internal_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetTextProto::set_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SetTextProto.view_identifier)
}
inline std::string* SetTextProto::mutable_view_identifier() {
  std::string* _s = _internal_mutable_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetTextProto.view_identifier)
  return _s;
}
inline const std::string& SetTextProto::_internal_view_identifier() const {
  return view_identifier_.Get();
}
inline void SetTextProto::_internal_set_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* SetTextProto::_internal_mutable_view_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* SetTextProto::release_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetTextProto.view_identifier)
  if (!_internal_has_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetTextProto::set_allocated_view_identifier(std::string* view_identifier) {
  if (view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_identifier_.SetAllocated(view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetTextProto.view_identifier)
}

// -------------------------------------------------------------------

// SetViewVisibilityProto

// optional string view_identifier = 1;
inline bool SetViewVisibilityProto::_internal_has_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetViewVisibilityProto::has_view_identifier() const {
  return _internal_has_view_identifier();
}
inline void SetViewVisibilityProto::clear_view_identifier() {
  view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetViewVisibilityProto::view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetViewVisibilityProto.view_identifier)
  return _internal_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetViewVisibilityProto::set_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SetViewVisibilityProto.view_identifier)
}
inline std::string* SetViewVisibilityProto::mutable_view_identifier() {
  std::string* _s = _internal_mutable_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetViewVisibilityProto.view_identifier)
  return _s;
}
inline const std::string& SetViewVisibilityProto::_internal_view_identifier() const {
  return view_identifier_.Get();
}
inline void SetViewVisibilityProto::_internal_set_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* SetViewVisibilityProto::_internal_mutable_view_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* SetViewVisibilityProto::release_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetViewVisibilityProto.view_identifier)
  if (!_internal_has_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetViewVisibilityProto::set_allocated_view_identifier(std::string* view_identifier) {
  if (view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_identifier_.SetAllocated(view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetViewVisibilityProto.view_identifier)
}

// optional .autofill_assistant.ValueReferenceProto visible = 3;
inline bool SetViewVisibilityProto::_internal_has_visible() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || visible_ != nullptr);
  return value;
}
inline bool SetViewVisibilityProto::has_visible() const {
  return _internal_has_visible();
}
inline const ::autofill_assistant::ValueReferenceProto& SetViewVisibilityProto::_internal_visible() const {
  const ::autofill_assistant::ValueReferenceProto* p = visible_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& SetViewVisibilityProto::visible() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetViewVisibilityProto.visible)
  return _internal_visible();
}
inline void SetViewVisibilityProto::unsafe_arena_set_allocated_visible(
    ::autofill_assistant::ValueReferenceProto* visible) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visible_);
  }
  visible_ = visible;
  if (visible) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetViewVisibilityProto.visible)
}
inline ::autofill_assistant::ValueReferenceProto* SetViewVisibilityProto::release_visible() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = visible_;
  visible_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetViewVisibilityProto::unsafe_arena_release_visible() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetViewVisibilityProto.visible)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = visible_;
  visible_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetViewVisibilityProto::_internal_mutable_visible() {
  _has_bits_[0] |= 0x00000002u;
  if (visible_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    visible_ = p;
  }
  return visible_;
}
inline ::autofill_assistant::ValueReferenceProto* SetViewVisibilityProto::mutable_visible() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_visible();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetViewVisibilityProto.visible)
  return _msg;
}
inline void SetViewVisibilityProto::set_allocated_visible(::autofill_assistant::ValueReferenceProto* visible) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(visible_);
  }
  if (visible) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visible));
    if (message_arena != submessage_arena) {
      visible = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visible, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  visible_ = visible;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetViewVisibilityProto.visible)
}

// -------------------------------------------------------------------

// ShowGenericUiPopupProto

// optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 1;
inline bool ShowGenericUiPopupProto::_internal_has_generic_ui() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || generic_ui_ != nullptr);
  return value;
}
inline bool ShowGenericUiPopupProto::has_generic_ui() const {
  return _internal_has_generic_ui();
}
inline void ShowGenericUiPopupProto::clear_generic_ui() {
  if (generic_ui_ != nullptr) generic_ui_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::GenericUserInterfaceProto& ShowGenericUiPopupProto::_internal_generic_ui() const {
  const ::autofill_assistant::GenericUserInterfaceProto* p = generic_ui_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GenericUserInterfaceProto&>(
      ::autofill_assistant::_GenericUserInterfaceProto_default_instance_);
}
inline const ::autofill_assistant::GenericUserInterfaceProto& ShowGenericUiPopupProto::generic_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiPopupProto.generic_ui)
  return _internal_generic_ui();
}
inline void ShowGenericUiPopupProto::unsafe_arena_set_allocated_generic_ui(
    ::autofill_assistant::GenericUserInterfaceProto* generic_ui) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_ui_);
  }
  generic_ui_ = generic_ui;
  if (generic_ui) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowGenericUiPopupProto.generic_ui)
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiPopupProto::release_generic_ui() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_ui_;
  generic_ui_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiPopupProto::unsafe_arena_release_generic_ui() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiPopupProto.generic_ui)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_ui_;
  generic_ui_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiPopupProto::_internal_mutable_generic_ui() {
  _has_bits_[0] |= 0x00000002u;
  if (generic_ui_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(GetArenaForAllocation());
    generic_ui_ = p;
  }
  return generic_ui_;
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiPopupProto::mutable_generic_ui() {
  ::autofill_assistant::GenericUserInterfaceProto* _msg = _internal_mutable_generic_ui();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiPopupProto.generic_ui)
  return _msg;
}
inline void ShowGenericUiPopupProto::set_allocated_generic_ui(::autofill_assistant::GenericUserInterfaceProto* generic_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete generic_ui_;
  }
  if (generic_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(generic_ui);
    if (message_arena != submessage_arena) {
      generic_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_ui, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  generic_ui_ = generic_ui;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiPopupProto.generic_ui)
}

// optional string popup_identifier = 2;
inline bool ShowGenericUiPopupProto::_internal_has_popup_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowGenericUiPopupProto::has_popup_identifier() const {
  return _internal_has_popup_identifier();
}
inline void ShowGenericUiPopupProto::clear_popup_identifier() {
  popup_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowGenericUiPopupProto::popup_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiPopupProto.popup_identifier)
  return _internal_popup_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowGenericUiPopupProto::set_popup_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 popup_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiPopupProto.popup_identifier)
}
inline std::string* ShowGenericUiPopupProto::mutable_popup_identifier() {
  std::string* _s = _internal_mutable_popup_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiPopupProto.popup_identifier)
  return _s;
}
inline const std::string& ShowGenericUiPopupProto::_internal_popup_identifier() const {
  return popup_identifier_.Get();
}
inline void ShowGenericUiPopupProto::_internal_set_popup_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  popup_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowGenericUiPopupProto::_internal_mutable_popup_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return popup_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowGenericUiPopupProto::release_popup_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiPopupProto.popup_identifier)
  if (!_internal_has_popup_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = popup_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (popup_identifier_.IsDefault()) {
    popup_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowGenericUiPopupProto::set_allocated_popup_identifier(std::string* popup_identifier) {
  if (popup_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  popup_identifier_.SetAllocated(popup_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (popup_identifier_.IsDefault()) {
    popup_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiPopupProto.popup_identifier)
}

// -------------------------------------------------------------------

// SetViewEnabledProto

// optional string view_identifier = 1;
inline bool SetViewEnabledProto::_internal_has_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetViewEnabledProto::has_view_identifier() const {
  return _internal_has_view_identifier();
}
inline void SetViewEnabledProto::clear_view_identifier() {
  view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetViewEnabledProto::view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetViewEnabledProto.view_identifier)
  return _internal_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetViewEnabledProto::set_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SetViewEnabledProto.view_identifier)
}
inline std::string* SetViewEnabledProto::mutable_view_identifier() {
  std::string* _s = _internal_mutable_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetViewEnabledProto.view_identifier)
  return _s;
}
inline const std::string& SetViewEnabledProto::_internal_view_identifier() const {
  return view_identifier_.Get();
}
inline void SetViewEnabledProto::_internal_set_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* SetViewEnabledProto::_internal_mutable_view_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* SetViewEnabledProto::release_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetViewEnabledProto.view_identifier)
  if (!_internal_has_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetViewEnabledProto::set_allocated_view_identifier(std::string* view_identifier) {
  if (view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_identifier_.SetAllocated(view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetViewEnabledProto.view_identifier)
}

// optional .autofill_assistant.ValueReferenceProto enabled = 2;
inline bool SetViewEnabledProto::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || enabled_ != nullptr);
  return value;
}
inline bool SetViewEnabledProto::has_enabled() const {
  return _internal_has_enabled();
}
inline const ::autofill_assistant::ValueReferenceProto& SetViewEnabledProto::_internal_enabled() const {
  const ::autofill_assistant::ValueReferenceProto* p = enabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueReferenceProto&>(
      ::autofill_assistant::_ValueReferenceProto_default_instance_);
}
inline const ::autofill_assistant::ValueReferenceProto& SetViewEnabledProto::enabled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetViewEnabledProto.enabled)
  return _internal_enabled();
}
inline void SetViewEnabledProto::unsafe_arena_set_allocated_enabled(
    ::autofill_assistant::ValueReferenceProto* enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled_);
  }
  enabled_ = enabled;
  if (enabled) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetViewEnabledProto.enabled)
}
inline ::autofill_assistant::ValueReferenceProto* SetViewEnabledProto::release_enabled() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = enabled_;
  enabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetViewEnabledProto::unsafe_arena_release_enabled() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetViewEnabledProto.enabled)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueReferenceProto* temp = enabled_;
  enabled_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueReferenceProto* SetViewEnabledProto::_internal_mutable_enabled() {
  _has_bits_[0] |= 0x00000002u;
  if (enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(GetArenaForAllocation());
    enabled_ = p;
  }
  return enabled_;
}
inline ::autofill_assistant::ValueReferenceProto* SetViewEnabledProto::mutable_enabled() {
  ::autofill_assistant::ValueReferenceProto* _msg = _internal_mutable_enabled();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetViewEnabledProto.enabled)
  return _msg;
}
inline void SetViewEnabledProto::set_allocated_enabled(::autofill_assistant::ValueReferenceProto* enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled_);
  }
  if (enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled));
    if (message_arena != submessage_arena) {
      enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enabled, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  enabled_ = enabled;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetViewEnabledProto.enabled)
}

// -------------------------------------------------------------------

// CreateNestedGenericUiProto

// optional string generic_ui_identifier = 1;
inline bool CreateNestedGenericUiProto::_internal_has_generic_ui_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateNestedGenericUiProto::has_generic_ui_identifier() const {
  return _internal_has_generic_ui_identifier();
}
inline void CreateNestedGenericUiProto::clear_generic_ui_identifier() {
  generic_ui_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateNestedGenericUiProto::generic_ui_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreateNestedGenericUiProto.generic_ui_identifier)
  return _internal_generic_ui_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNestedGenericUiProto::set_generic_ui_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 generic_ui_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CreateNestedGenericUiProto.generic_ui_identifier)
}
inline std::string* CreateNestedGenericUiProto::mutable_generic_ui_identifier() {
  std::string* _s = _internal_mutable_generic_ui_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreateNestedGenericUiProto.generic_ui_identifier)
  return _s;
}
inline const std::string& CreateNestedGenericUiProto::_internal_generic_ui_identifier() const {
  return generic_ui_identifier_.Get();
}
inline void CreateNestedGenericUiProto::_internal_set_generic_ui_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  generic_ui_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNestedGenericUiProto::_internal_mutable_generic_ui_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return generic_ui_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNestedGenericUiProto::release_generic_ui_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CreateNestedGenericUiProto.generic_ui_identifier)
  if (!_internal_has_generic_ui_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = generic_ui_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (generic_ui_identifier_.IsDefault()) {
    generic_ui_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateNestedGenericUiProto::set_allocated_generic_ui_identifier(std::string* generic_ui_identifier) {
  if (generic_ui_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  generic_ui_identifier_.SetAllocated(generic_ui_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (generic_ui_identifier_.IsDefault()) {
    generic_ui_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CreateNestedGenericUiProto.generic_ui_identifier)
}

// optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 2;
inline bool CreateNestedGenericUiProto::_internal_has_generic_ui() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || generic_ui_ != nullptr);
  return value;
}
inline bool CreateNestedGenericUiProto::has_generic_ui() const {
  return _internal_has_generic_ui();
}
inline void CreateNestedGenericUiProto::clear_generic_ui() {
  if (generic_ui_ != nullptr) generic_ui_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::GenericUserInterfaceProto& CreateNestedGenericUiProto::_internal_generic_ui() const {
  const ::autofill_assistant::GenericUserInterfaceProto* p = generic_ui_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GenericUserInterfaceProto&>(
      ::autofill_assistant::_GenericUserInterfaceProto_default_instance_);
}
inline const ::autofill_assistant::GenericUserInterfaceProto& CreateNestedGenericUiProto::generic_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreateNestedGenericUiProto.generic_ui)
  return _internal_generic_ui();
}
inline void CreateNestedGenericUiProto::unsafe_arena_set_allocated_generic_ui(
    ::autofill_assistant::GenericUserInterfaceProto* generic_ui) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_ui_);
  }
  generic_ui_ = generic_ui;
  if (generic_ui) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CreateNestedGenericUiProto.generic_ui)
}
inline ::autofill_assistant::GenericUserInterfaceProto* CreateNestedGenericUiProto::release_generic_ui() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_ui_;
  generic_ui_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CreateNestedGenericUiProto::unsafe_arena_release_generic_ui() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CreateNestedGenericUiProto.generic_ui)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_ui_;
  generic_ui_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CreateNestedGenericUiProto::_internal_mutable_generic_ui() {
  _has_bits_[0] |= 0x00000004u;
  if (generic_ui_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(GetArenaForAllocation());
    generic_ui_ = p;
  }
  return generic_ui_;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CreateNestedGenericUiProto::mutable_generic_ui() {
  ::autofill_assistant::GenericUserInterfaceProto* _msg = _internal_mutable_generic_ui();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreateNestedGenericUiProto.generic_ui)
  return _msg;
}
inline void CreateNestedGenericUiProto::set_allocated_generic_ui(::autofill_assistant::GenericUserInterfaceProto* generic_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete generic_ui_;
  }
  if (generic_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(generic_ui);
    if (message_arena != submessage_arena) {
      generic_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_ui, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  generic_ui_ = generic_ui;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CreateNestedGenericUiProto.generic_ui)
}

// optional string parent_view_identifier = 3;
inline bool CreateNestedGenericUiProto::_internal_has_parent_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateNestedGenericUiProto::has_parent_view_identifier() const {
  return _internal_has_parent_view_identifier();
}
inline void CreateNestedGenericUiProto::clear_parent_view_identifier() {
  parent_view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateNestedGenericUiProto::parent_view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreateNestedGenericUiProto.parent_view_identifier)
  return _internal_parent_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNestedGenericUiProto::set_parent_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 parent_view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CreateNestedGenericUiProto.parent_view_identifier)
}
inline std::string* CreateNestedGenericUiProto::mutable_parent_view_identifier() {
  std::string* _s = _internal_mutable_parent_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreateNestedGenericUiProto.parent_view_identifier)
  return _s;
}
inline const std::string& CreateNestedGenericUiProto::_internal_parent_view_identifier() const {
  return parent_view_identifier_.Get();
}
inline void CreateNestedGenericUiProto::_internal_set_parent_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  parent_view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNestedGenericUiProto::_internal_mutable_parent_view_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return parent_view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNestedGenericUiProto::release_parent_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CreateNestedGenericUiProto.parent_view_identifier)
  if (!_internal_has_parent_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = parent_view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_view_identifier_.IsDefault()) {
    parent_view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateNestedGenericUiProto::set_allocated_parent_view_identifier(std::string* parent_view_identifier) {
  if (parent_view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  parent_view_identifier_.SetAllocated(parent_view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_view_identifier_.IsDefault()) {
    parent_view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CreateNestedGenericUiProto.parent_view_identifier)
}

// -------------------------------------------------------------------

// ClearViewContainerProto

// optional string view_identifier = 1;
inline bool ClearViewContainerProto::_internal_has_view_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClearViewContainerProto::has_view_identifier() const {
  return _internal_has_view_identifier();
}
inline void ClearViewContainerProto::clear_view_identifier() {
  view_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClearViewContainerProto::view_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClearViewContainerProto.view_identifier)
  return _internal_view_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClearViewContainerProto::set_view_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClearViewContainerProto.view_identifier)
}
inline std::string* ClearViewContainerProto::mutable_view_identifier() {
  std::string* _s = _internal_mutable_view_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClearViewContainerProto.view_identifier)
  return _s;
}
inline const std::string& ClearViewContainerProto::_internal_view_identifier() const {
  return view_identifier_.Get();
}
inline void ClearViewContainerProto::_internal_set_view_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ClearViewContainerProto::_internal_mutable_view_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return view_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ClearViewContainerProto::release_view_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClearViewContainerProto.view_identifier)
  if (!_internal_has_view_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClearViewContainerProto::set_allocated_view_identifier(std::string* view_identifier) {
  if (view_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_identifier_.SetAllocated(view_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_identifier_.IsDefault()) {
    view_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClearViewContainerProto.view_identifier)
}

// -------------------------------------------------------------------

// ForEachProto

// optional string loop_counter = 1;
inline bool ForEachProto::_internal_has_loop_counter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ForEachProto::has_loop_counter() const {
  return _internal_has_loop_counter();
}
inline void ForEachProto::clear_loop_counter() {
  loop_counter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ForEachProto::loop_counter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ForEachProto.loop_counter)
  return _internal_loop_counter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForEachProto::set_loop_counter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 loop_counter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ForEachProto.loop_counter)
}
inline std::string* ForEachProto::mutable_loop_counter() {
  std::string* _s = _internal_mutable_loop_counter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ForEachProto.loop_counter)
  return _s;
}
inline const std::string& ForEachProto::_internal_loop_counter() const {
  return loop_counter_.Get();
}
inline void ForEachProto::_internal_set_loop_counter(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  loop_counter_.Set(value, GetArenaForAllocation());
}
inline std::string* ForEachProto::_internal_mutable_loop_counter() {
  _has_bits_[0] |= 0x00000001u;
  return loop_counter_.Mutable(GetArenaForAllocation());
}
inline std::string* ForEachProto::release_loop_counter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ForEachProto.loop_counter)
  if (!_internal_has_loop_counter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = loop_counter_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loop_counter_.IsDefault()) {
    loop_counter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ForEachProto::set_allocated_loop_counter(std::string* loop_counter) {
  if (loop_counter != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  loop_counter_.SetAllocated(loop_counter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loop_counter_.IsDefault()) {
    loop_counter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ForEachProto.loop_counter)
}

// optional string loop_value_model_identifier = 2;
inline bool ForEachProto::_internal_has_loop_value_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ForEachProto::has_loop_value_model_identifier() const {
  return _internal_has_loop_value_model_identifier();
}
inline void ForEachProto::clear_loop_value_model_identifier() {
  loop_value_model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ForEachProto::loop_value_model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ForEachProto.loop_value_model_identifier)
  return _internal_loop_value_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForEachProto::set_loop_value_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 loop_value_model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ForEachProto.loop_value_model_identifier)
}
inline std::string* ForEachProto::mutable_loop_value_model_identifier() {
  std::string* _s = _internal_mutable_loop_value_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ForEachProto.loop_value_model_identifier)
  return _s;
}
inline const std::string& ForEachProto::_internal_loop_value_model_identifier() const {
  return loop_value_model_identifier_.Get();
}
inline void ForEachProto::_internal_set_loop_value_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  loop_value_model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ForEachProto::_internal_mutable_loop_value_model_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return loop_value_model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ForEachProto::release_loop_value_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ForEachProto.loop_value_model_identifier)
  if (!_internal_has_loop_value_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = loop_value_model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loop_value_model_identifier_.IsDefault()) {
    loop_value_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ForEachProto::set_allocated_loop_value_model_identifier(std::string* loop_value_model_identifier) {
  if (loop_value_model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  loop_value_model_identifier_.SetAllocated(loop_value_model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loop_value_model_identifier_.IsDefault()) {
    loop_value_model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ForEachProto.loop_value_model_identifier)
}

// repeated .autofill_assistant.CallbackProto callbacks = 3;
inline int ForEachProto::_internal_callbacks_size() const {
  return callbacks_.size();
}
inline int ForEachProto::callbacks_size() const {
  return _internal_callbacks_size();
}
inline void ForEachProto::clear_callbacks() {
  callbacks_.Clear();
}
inline ::autofill_assistant::CallbackProto* ForEachProto::mutable_callbacks(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ForEachProto.callbacks)
  return callbacks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >*
ForEachProto::mutable_callbacks() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ForEachProto.callbacks)
  return &callbacks_;
}
inline const ::autofill_assistant::CallbackProto& ForEachProto::_internal_callbacks(int index) const {
  return callbacks_.Get(index);
}
inline const ::autofill_assistant::CallbackProto& ForEachProto::callbacks(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ForEachProto.callbacks)
  return _internal_callbacks(index);
}
inline ::autofill_assistant::CallbackProto* ForEachProto::_internal_add_callbacks() {
  return callbacks_.Add();
}
inline ::autofill_assistant::CallbackProto* ForEachProto::add_callbacks() {
  ::autofill_assistant::CallbackProto* _add = _internal_add_callbacks();
  // @@protoc_insertion_point(field_add:autofill_assistant.ForEachProto.callbacks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CallbackProto >&
ForEachProto::callbacks() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ForEachProto.callbacks)
  return callbacks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill_assistant

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill_assistant::AutofillFormatProto_AutofillAssistantCustomField> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ValueComparisonProto_Mode> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ShowListPopupProto_ItemType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fgeneric_5fui_2eproto
