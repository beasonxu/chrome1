// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/action_value.proto

#include "components/autofill_assistant/browser/action_value.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
PROTOBUF_CONSTEXPR AutofillProfile::AutofillProfile(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct AutofillProfileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillProfileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillProfileDefaultTypeInternal() {}
  union {
    AutofillProfile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillProfileDefaultTypeInternal _AutofillProfile_default_instance_;
PROTOBUF_CONSTEXPR ValueExpression_RegexpReplacement::ValueExpression_RegexpReplacement(
    ::_pbi::ConstantInitialized)
  : replacement_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_filter_(nullptr)
  , global_(false){}
struct ValueExpression_RegexpReplacementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueExpression_RegexpReplacementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueExpression_RegexpReplacementDefaultTypeInternal() {}
  union {
    ValueExpression_RegexpReplacement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueExpression_RegexpReplacementDefaultTypeInternal _ValueExpression_RegexpReplacement_default_instance_;
PROTOBUF_CONSTEXPR ValueExpression_Chunk_ReplacementsEntry_DoNotUse::ValueExpression_Chunk_ReplacementsEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct ValueExpression_Chunk_ReplacementsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueExpression_Chunk_ReplacementsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueExpression_Chunk_ReplacementsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ValueExpression_Chunk_ReplacementsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueExpression_Chunk_ReplacementsEntry_DoNotUseDefaultTypeInternal _ValueExpression_Chunk_ReplacementsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ValueExpression_Chunk::ValueExpression_Chunk(
    ::_pbi::ConstantInitialized)
  : replacements_()
  , regexp_replacements_()
  , _oneof_case_{}{}
struct ValueExpression_ChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueExpression_ChunkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueExpression_ChunkDefaultTypeInternal() {}
  union {
    ValueExpression_Chunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueExpression_ChunkDefaultTypeInternal _ValueExpression_Chunk_default_instance_;
PROTOBUF_CONSTEXPR ValueExpression::ValueExpression(
    ::_pbi::ConstantInitialized)
  : chunk_(){}
struct ValueExpressionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueExpressionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueExpressionDefaultTypeInternal() {}
  union {
    ValueExpression _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueExpressionDefaultTypeInternal _ValueExpression_default_instance_;
PROTOBUF_CONSTEXPR ValueExpressionRegexp::ValueExpressionRegexp(
    ::_pbi::ConstantInitialized)
  : value_expression_(nullptr)
  , case_sensitive_(false){}
struct ValueExpressionRegexpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueExpressionRegexpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueExpressionRegexpDefaultTypeInternal() {}
  union {
    ValueExpressionRegexp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueExpressionRegexpDefaultTypeInternal _ValueExpressionRegexp_default_instance_;
PROTOBUF_CONSTEXPR AutofillValue::AutofillValue(
    ::_pbi::ConstantInitialized)
  : locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , profile_(nullptr)
  , value_expression_(nullptr){}
struct AutofillValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillValueDefaultTypeInternal() {}
  union {
    AutofillValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillValueDefaultTypeInternal _AutofillValue_default_instance_;
PROTOBUF_CONSTEXPR AutofillValueRegexp::AutofillValueRegexp(
    ::_pbi::ConstantInitialized)
  : locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , profile_(nullptr)
  , value_expression_re2_(nullptr){}
struct AutofillValueRegexpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillValueRegexpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillValueRegexpDefaultTypeInternal() {}
  union {
    AutofillValueRegexp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillValueRegexpDefaultTypeInternal _AutofillValueRegexp_default_instance_;
PROTOBUF_CONSTEXPR TextFilter::TextFilter(
    ::_pbi::ConstantInitialized)
  : re2_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , case_sensitive_(false){}
struct TextFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextFilterDefaultTypeInternal() {}
  union {
    TextFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextFilterDefaultTypeInternal _TextFilter_default_instance_;
PROTOBUF_CONSTEXPR PasswordManagerValue::PasswordManagerValue(
    ::_pbi::ConstantInitialized)
  : credential_type_(0)
{}
struct PasswordManagerValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordManagerValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordManagerValueDefaultTypeInternal() {}
  union {
    PasswordManagerValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordManagerValueDefaultTypeInternal _PasswordManagerValue_default_instance_;
PROTOBUF_CONSTEXPR TextValue::TextValue(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct TextValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextValueDefaultTypeInternal() {}
  union {
    TextValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextValueDefaultTypeInternal _TextValue_default_instance_;
PROTOBUF_CONSTEXPR KeyEvent::KeyEvent(
    ::_pbi::ConstantInitialized)
  : command_()
  , code_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_code_(0){}
struct KeyEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyEventDefaultTypeInternal() {}
  union {
    KeyEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
}  // namespace autofill_assistant
namespace autofill_assistant {
bool PasswordManagerValue_CredentialType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PasswordManagerValue_CredentialType_strings[3] = {};

static const char PasswordManagerValue_CredentialType_names[] =
  "NOT_SET"
  "PASSWORD"
  "USERNAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PasswordManagerValue_CredentialType_entries[] = {
  { {PasswordManagerValue_CredentialType_names + 0, 7}, 0 },
  { {PasswordManagerValue_CredentialType_names + 7, 8}, 1 },
  { {PasswordManagerValue_CredentialType_names + 15, 8}, 2 },
};

static const int PasswordManagerValue_CredentialType_entries_by_number[] = {
  0, // 0 -> NOT_SET
  1, // 1 -> PASSWORD
  2, // 2 -> USERNAME
};

const std::string& PasswordManagerValue_CredentialType_Name(
    PasswordManagerValue_CredentialType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PasswordManagerValue_CredentialType_entries,
          PasswordManagerValue_CredentialType_entries_by_number,
          3, PasswordManagerValue_CredentialType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PasswordManagerValue_CredentialType_entries,
      PasswordManagerValue_CredentialType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PasswordManagerValue_CredentialType_strings[idx].get();
}
bool PasswordManagerValue_CredentialType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PasswordManagerValue_CredentialType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PasswordManagerValue_CredentialType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<PasswordManagerValue_CredentialType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PasswordManagerValue_CredentialType PasswordManagerValue::NOT_SET;
constexpr PasswordManagerValue_CredentialType PasswordManagerValue::PASSWORD;
constexpr PasswordManagerValue_CredentialType PasswordManagerValue::USERNAME;
constexpr PasswordManagerValue_CredentialType PasswordManagerValue::CredentialType_MIN;
constexpr PasswordManagerValue_CredentialType PasswordManagerValue::CredentialType_MAX;
constexpr int PasswordManagerValue::CredentialType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class AutofillProfile::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillProfile>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AutofillProfile::AutofillProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillProfile)
}
AutofillProfile::AutofillProfile(const AutofillProfile& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillProfile)
}

inline void AutofillProfile::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillProfile::~AutofillProfile() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillProfile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillProfile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
}

void AutofillProfile::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillProfile::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillProfile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillProfile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillProfile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillProfile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillProfile)
  return target;
}

size_t AutofillProfile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillProfile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillProfile::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillProfile*>(
      &from));
}

void AutofillProfile::MergeFrom(const AutofillProfile& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillProfile)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_identifier()) {
    _internal_set_identifier(from._internal_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillProfile::CopyFrom(const AutofillProfile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillProfile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillProfile::IsInitialized() const {
  return true;
}

void AutofillProfile::InternalSwap(AutofillProfile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
}

std::string AutofillProfile::GetTypeName() const {
  return "autofill_assistant.AutofillProfile";
}


// ===================================================================

class ValueExpression_RegexpReplacement::_Internal {
 public:
  using HasBits = decltype(std::declval<ValueExpression_RegexpReplacement>()._has_bits_);
  static const ::autofill_assistant::TextFilter& text_filter(const ValueExpression_RegexpReplacement* msg);
  static void set_has_text_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_replacement(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_global(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::TextFilter&
ValueExpression_RegexpReplacement::_Internal::text_filter(const ValueExpression_RegexpReplacement* msg) {
  return *msg->text_filter_;
}
ValueExpression_RegexpReplacement::ValueExpression_RegexpReplacement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueExpression.RegexpReplacement)
}
ValueExpression_RegexpReplacement::ValueExpression_RegexpReplacement(const ValueExpression_RegexpReplacement& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  replacement_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    replacement_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_replacement()) {
    replacement_.Set(from._internal_replacement(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_text_filter()) {
    text_filter_ = new ::autofill_assistant::TextFilter(*from.text_filter_);
  } else {
    text_filter_ = nullptr;
  }
  global_ = from.global_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueExpression.RegexpReplacement)
}

inline void ValueExpression_RegexpReplacement::SharedCtor() {
replacement_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  replacement_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&text_filter_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&global_) -
    reinterpret_cast<char*>(&text_filter_)) + sizeof(global_));
}

ValueExpression_RegexpReplacement::~ValueExpression_RegexpReplacement() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueExpression.RegexpReplacement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueExpression_RegexpReplacement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  replacement_.Destroy();
  if (this != internal_default_instance()) delete text_filter_;
}

void ValueExpression_RegexpReplacement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueExpression_RegexpReplacement::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueExpression.RegexpReplacement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      replacement_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(text_filter_ != nullptr);
      text_filter_->Clear();
    }
  }
  global_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueExpression_RegexpReplacement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.TextFilter text_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string replacement = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_replacement();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool global = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_global(&has_bits);
          global_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueExpression_RegexpReplacement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueExpression.RegexpReplacement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.TextFilter text_filter = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::text_filter(this),
        _Internal::text_filter(this).GetCachedSize(), target, stream);
  }

  // optional string replacement = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_replacement(), target);
  }

  // optional bool global = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_global(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueExpression.RegexpReplacement)
  return target;
}

size_t ValueExpression_RegexpReplacement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueExpression.RegexpReplacement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string replacement = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_replacement());
    }

    // optional .autofill_assistant.TextFilter text_filter = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *text_filter_);
    }

    // optional bool global = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueExpression_RegexpReplacement::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueExpression_RegexpReplacement*>(
      &from));
}

void ValueExpression_RegexpReplacement::MergeFrom(const ValueExpression_RegexpReplacement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueExpression.RegexpReplacement)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_replacement(from._internal_replacement());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_text_filter()->::autofill_assistant::TextFilter::MergeFrom(from._internal_text_filter());
    }
    if (cached_has_bits & 0x00000004u) {
      global_ = from.global_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueExpression_RegexpReplacement::CopyFrom(const ValueExpression_RegexpReplacement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueExpression.RegexpReplacement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueExpression_RegexpReplacement::IsInitialized() const {
  return true;
}

void ValueExpression_RegexpReplacement::InternalSwap(ValueExpression_RegexpReplacement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &replacement_, lhs_arena,
      &other->replacement_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ValueExpression_RegexpReplacement, global_)
      + sizeof(ValueExpression_RegexpReplacement::global_)
      - PROTOBUF_FIELD_OFFSET(ValueExpression_RegexpReplacement, text_filter_)>(
          reinterpret_cast<char*>(&text_filter_),
          reinterpret_cast<char*>(&other->text_filter_));
}

std::string ValueExpression_RegexpReplacement::GetTypeName() const {
  return "autofill_assistant.ValueExpression.RegexpReplacement";
}


// ===================================================================

ValueExpression_Chunk_ReplacementsEntry_DoNotUse::ValueExpression_Chunk_ReplacementsEntry_DoNotUse() {}
ValueExpression_Chunk_ReplacementsEntry_DoNotUse::ValueExpression_Chunk_ReplacementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ValueExpression_Chunk_ReplacementsEntry_DoNotUse::MergeFrom(const ValueExpression_Chunk_ReplacementsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class ValueExpression_Chunk::_Internal {
 public:
};

ValueExpression_Chunk::ValueExpression_Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  replacements_(arena),
  regexp_replacements_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueExpression.Chunk)
}
ValueExpression_Chunk::ValueExpression_Chunk(const ValueExpression_Chunk& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      regexp_replacements_(from.regexp_replacements_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  replacements_.MergeFrom(from.replacements_);
  clear_has_chunk();
  switch (from.chunk_case()) {
    case kKey: {
      _internal_set_key(from._internal_key());
      break;
    }
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kMemoryKey: {
      _internal_set_memory_key(from._internal_memory_key());
      break;
    }
    case CHUNK_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueExpression.Chunk)
}

inline void ValueExpression_Chunk::SharedCtor() {
clear_has_chunk();
}

ValueExpression_Chunk::~ValueExpression_Chunk() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueExpression.Chunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueExpression_Chunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  replacements_.Destruct();
  if (has_chunk()) {
    clear_chunk();
  }
}

void ValueExpression_Chunk::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueExpression_Chunk::clear_chunk() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ValueExpression.Chunk)
  switch (chunk_case()) {
    case kKey: {
      // No need to clear
      break;
    }
    case kText: {
      chunk_.text_.Destroy();
      break;
    }
    case kMemoryKey: {
      chunk_.memory_key_.Destroy();
      break;
    }
    case CHUNK_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CHUNK_NOT_SET;
}


void ValueExpression_Chunk::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueExpression.Chunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  replacements_.Clear();
  regexp_replacements_.Clear();
  clear_chunk();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueExpression_Chunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_key(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> replacements = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&replacements_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string memory_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ValueExpression.RegexpReplacement regexp_replacements = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_regexp_replacements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueExpression_Chunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueExpression.Chunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (chunk_case()) {
    case kKey: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_key(), target);
      break;
    }
    case kText: {
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_text(), target);
      break;
    }
    default: ;
  }
  // map<string, string> replacements = 3;
  if (!this->_internal_replacements().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ValueExpression_Chunk_ReplacementsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_replacements();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string memory_key = 4;
  if (_internal_has_memory_key()) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_memory_key(), target);
  }

  // repeated .autofill_assistant.ValueExpression.RegexpReplacement regexp_replacements = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_regexp_replacements_size()); i < n; i++) {
    const auto& repfield = this->_internal_regexp_replacements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueExpression.Chunk)
  return target;
}

size_t ValueExpression_Chunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueExpression.Chunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> replacements = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_replacements_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_replacements().begin();
      it != this->_internal_replacements().end(); ++it) {
    total_size += ValueExpression_Chunk_ReplacementsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .autofill_assistant.ValueExpression.RegexpReplacement regexp_replacements = 5;
  total_size += 1UL * this->_internal_regexp_replacements_size();
  for (const auto& msg : this->regexp_replacements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  switch (chunk_case()) {
    // int32 key = 1;
    case kKey: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key());
      break;
    }
    // string text = 2;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    // string memory_key = 4;
    case kMemoryKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_memory_key());
      break;
    }
    case CHUNK_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueExpression_Chunk::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueExpression_Chunk*>(
      &from));
}

void ValueExpression_Chunk::MergeFrom(const ValueExpression_Chunk& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueExpression.Chunk)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  replacements_.MergeFrom(from.replacements_);
  regexp_replacements_.MergeFrom(from.regexp_replacements_);
  switch (from.chunk_case()) {
    case kKey: {
      _internal_set_key(from._internal_key());
      break;
    }
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kMemoryKey: {
      _internal_set_memory_key(from._internal_memory_key());
      break;
    }
    case CHUNK_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueExpression_Chunk::CopyFrom(const ValueExpression_Chunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueExpression.Chunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueExpression_Chunk::IsInitialized() const {
  return true;
}

void ValueExpression_Chunk::InternalSwap(ValueExpression_Chunk* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  replacements_.InternalSwap(&other->replacements_);
  regexp_replacements_.InternalSwap(&other->regexp_replacements_);
  swap(chunk_, other->chunk_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ValueExpression_Chunk::GetTypeName() const {
  return "autofill_assistant.ValueExpression.Chunk";
}


// ===================================================================

class ValueExpression::_Internal {
 public:
};

ValueExpression::ValueExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  chunk_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueExpression)
}
ValueExpression::ValueExpression(const ValueExpression& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      chunk_(from.chunk_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueExpression)
}

inline void ValueExpression::SharedCtor() {
}

ValueExpression::~ValueExpression() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueExpression)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueExpression::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ValueExpression::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueExpression::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueExpression)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  chunk_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueExpression::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ValueExpression.Chunk chunk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_chunk(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueExpression::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueExpression)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueExpression.Chunk chunk = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_chunk_size()); i < n; i++) {
    const auto& repfield = this->_internal_chunk(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueExpression)
  return target;
}

size_t ValueExpression::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueExpression)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueExpression.Chunk chunk = 1;
  total_size += 1UL * this->_internal_chunk_size();
  for (const auto& msg : this->chunk_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueExpression::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueExpression*>(
      &from));
}

void ValueExpression::MergeFrom(const ValueExpression& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueExpression)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  chunk_.MergeFrom(from.chunk_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueExpression::CopyFrom(const ValueExpression& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueExpression)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueExpression::IsInitialized() const {
  return true;
}

void ValueExpression::InternalSwap(ValueExpression* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  chunk_.InternalSwap(&other->chunk_);
}

std::string ValueExpression::GetTypeName() const {
  return "autofill_assistant.ValueExpression";
}


// ===================================================================

class ValueExpressionRegexp::_Internal {
 public:
  using HasBits = decltype(std::declval<ValueExpressionRegexp>()._has_bits_);
  static const ::autofill_assistant::ValueExpression& value_expression(const ValueExpressionRegexp* msg);
  static void set_has_value_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_case_sensitive(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ValueExpression&
ValueExpressionRegexp::_Internal::value_expression(const ValueExpressionRegexp* msg) {
  return *msg->value_expression_;
}
ValueExpressionRegexp::ValueExpressionRegexp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueExpressionRegexp)
}
ValueExpressionRegexp::ValueExpressionRegexp(const ValueExpressionRegexp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value_expression()) {
    value_expression_ = new ::autofill_assistant::ValueExpression(*from.value_expression_);
  } else {
    value_expression_ = nullptr;
  }
  case_sensitive_ = from.case_sensitive_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueExpressionRegexp)
}

inline void ValueExpressionRegexp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&value_expression_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&case_sensitive_) -
    reinterpret_cast<char*>(&value_expression_)) + sizeof(case_sensitive_));
}

ValueExpressionRegexp::~ValueExpressionRegexp() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueExpressionRegexp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueExpressionRegexp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_expression_;
}

void ValueExpressionRegexp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueExpressionRegexp::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueExpressionRegexp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_expression_ != nullptr);
    value_expression_->Clear();
  }
  case_sensitive_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueExpressionRegexp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueExpression value_expression = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_expression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool case_sensitive = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_case_sensitive(&has_bits);
          case_sensitive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueExpressionRegexp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueExpressionRegexp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueExpression value_expression = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value_expression(this),
        _Internal::value_expression(this).GetCachedSize(), target, stream);
  }

  // optional bool case_sensitive = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_case_sensitive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueExpressionRegexp)
  return target;
}

size_t ValueExpressionRegexp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueExpressionRegexp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.ValueExpression value_expression = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_expression_);
    }

    // optional bool case_sensitive = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueExpressionRegexp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueExpressionRegexp*>(
      &from));
}

void ValueExpressionRegexp::MergeFrom(const ValueExpressionRegexp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueExpressionRegexp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_value_expression()->::autofill_assistant::ValueExpression::MergeFrom(from._internal_value_expression());
    }
    if (cached_has_bits & 0x00000002u) {
      case_sensitive_ = from.case_sensitive_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueExpressionRegexp::CopyFrom(const ValueExpressionRegexp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueExpressionRegexp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueExpressionRegexp::IsInitialized() const {
  return true;
}

void ValueExpressionRegexp::InternalSwap(ValueExpressionRegexp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ValueExpressionRegexp, case_sensitive_)
      + sizeof(ValueExpressionRegexp::case_sensitive_)
      - PROTOBUF_FIELD_OFFSET(ValueExpressionRegexp, value_expression_)>(
          reinterpret_cast<char*>(&value_expression_),
          reinterpret_cast<char*>(&other->value_expression_));
}

std::string ValueExpressionRegexp::GetTypeName() const {
  return "autofill_assistant.ValueExpressionRegexp";
}


// ===================================================================

class AutofillValue::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillValue>()._has_bits_);
  static const ::autofill_assistant::AutofillProfile& profile(const AutofillValue* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ValueExpression& value_expression(const AutofillValue* msg);
  static void set_has_value_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::AutofillProfile&
AutofillValue::_Internal::profile(const AutofillValue* msg) {
  return *msg->profile_;
}
const ::autofill_assistant::ValueExpression&
AutofillValue::_Internal::value_expression(const AutofillValue* msg) {
  return *msg->value_expression_;
}
AutofillValue::AutofillValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillValue)
}
AutofillValue::AutofillValue(const AutofillValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(from._internal_locale(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_profile()) {
    profile_ = new ::autofill_assistant::AutofillProfile(*from.profile_);
  } else {
    profile_ = nullptr;
  }
  if (from._internal_has_value_expression()) {
    value_expression_ = new ::autofill_assistant::ValueExpression(*from.value_expression_);
  } else {
    value_expression_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillValue)
}

inline void AutofillValue::SharedCtor() {
locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&profile_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_expression_) -
    reinterpret_cast<char*>(&profile_)) + sizeof(value_expression_));
}

AutofillValue::~AutofillValue() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.Destroy();
  if (this != internal_default_instance()) delete profile_;
  if (this != internal_default_instance()) delete value_expression_;
}

void AutofillValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillValue::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(profile_ != nullptr);
      profile_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(value_expression_ != nullptr);
      value_expression_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.AutofillProfile profile = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueExpression value_expression = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_expression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.AutofillProfile profile = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::profile(this),
        _Internal::profile(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ValueExpression value_expression = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::value_expression(this),
        _Internal::value_expression(this).GetCachedSize(), target, stream);
  }

  // optional string locale = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_locale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillValue)
  return target;
}

size_t AutofillValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string locale = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional .autofill_assistant.AutofillProfile profile = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *profile_);
    }

    // optional .autofill_assistant.ValueExpression value_expression = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_expression_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillValue*>(
      &from));
}

void AutofillValue::MergeFrom(const AutofillValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_profile()->::autofill_assistant::AutofillProfile::MergeFrom(from._internal_profile());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_value_expression()->::autofill_assistant::ValueExpression::MergeFrom(from._internal_value_expression());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillValue::CopyFrom(const AutofillValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillValue::IsInitialized() const {
  return true;
}

void AutofillValue::InternalSwap(AutofillValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutofillValue, value_expression_)
      + sizeof(AutofillValue::value_expression_)
      - PROTOBUF_FIELD_OFFSET(AutofillValue, profile_)>(
          reinterpret_cast<char*>(&profile_),
          reinterpret_cast<char*>(&other->profile_));
}

std::string AutofillValue::GetTypeName() const {
  return "autofill_assistant.AutofillValue";
}


// ===================================================================

class AutofillValueRegexp::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillValueRegexp>()._has_bits_);
  static const ::autofill_assistant::AutofillProfile& profile(const AutofillValueRegexp* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ValueExpressionRegexp& value_expression_re2(const AutofillValueRegexp* msg);
  static void set_has_value_expression_re2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::AutofillProfile&
AutofillValueRegexp::_Internal::profile(const AutofillValueRegexp* msg) {
  return *msg->profile_;
}
const ::autofill_assistant::ValueExpressionRegexp&
AutofillValueRegexp::_Internal::value_expression_re2(const AutofillValueRegexp* msg) {
  return *msg->value_expression_re2_;
}
AutofillValueRegexp::AutofillValueRegexp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillValueRegexp)
}
AutofillValueRegexp::AutofillValueRegexp(const AutofillValueRegexp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(from._internal_locale(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_profile()) {
    profile_ = new ::autofill_assistant::AutofillProfile(*from.profile_);
  } else {
    profile_ = nullptr;
  }
  if (from._internal_has_value_expression_re2()) {
    value_expression_re2_ = new ::autofill_assistant::ValueExpressionRegexp(*from.value_expression_re2_);
  } else {
    value_expression_re2_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillValueRegexp)
}

inline void AutofillValueRegexp::SharedCtor() {
locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&profile_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_expression_re2_) -
    reinterpret_cast<char*>(&profile_)) + sizeof(value_expression_re2_));
}

AutofillValueRegexp::~AutofillValueRegexp() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillValueRegexp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillValueRegexp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.Destroy();
  if (this != internal_default_instance()) delete profile_;
  if (this != internal_default_instance()) delete value_expression_re2_;
}

void AutofillValueRegexp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillValueRegexp::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillValueRegexp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(profile_ != nullptr);
      profile_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(value_expression_re2_ != nullptr);
      value_expression_re2_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillValueRegexp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.AutofillProfile profile = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueExpressionRegexp value_expression_re2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_expression_re2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillValueRegexp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillValueRegexp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.AutofillProfile profile = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::profile(this),
        _Internal::profile(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ValueExpressionRegexp value_expression_re2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value_expression_re2(this),
        _Internal::value_expression_re2(this).GetCachedSize(), target, stream);
  }

  // optional string locale = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_locale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillValueRegexp)
  return target;
}

size_t AutofillValueRegexp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillValueRegexp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string locale = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional .autofill_assistant.AutofillProfile profile = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *profile_);
    }

    // optional .autofill_assistant.ValueExpressionRegexp value_expression_re2 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_expression_re2_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillValueRegexp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillValueRegexp*>(
      &from));
}

void AutofillValueRegexp::MergeFrom(const AutofillValueRegexp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillValueRegexp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_profile()->::autofill_assistant::AutofillProfile::MergeFrom(from._internal_profile());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_value_expression_re2()->::autofill_assistant::ValueExpressionRegexp::MergeFrom(from._internal_value_expression_re2());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillValueRegexp::CopyFrom(const AutofillValueRegexp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillValueRegexp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillValueRegexp::IsInitialized() const {
  return true;
}

void AutofillValueRegexp::InternalSwap(AutofillValueRegexp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutofillValueRegexp, value_expression_re2_)
      + sizeof(AutofillValueRegexp::value_expression_re2_)
      - PROTOBUF_FIELD_OFFSET(AutofillValueRegexp, profile_)>(
          reinterpret_cast<char*>(&profile_),
          reinterpret_cast<char*>(&other->profile_));
}

std::string AutofillValueRegexp::GetTypeName() const {
  return "autofill_assistant.AutofillValueRegexp";
}


// ===================================================================

class TextFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<TextFilter>()._has_bits_);
  static void set_has_re2(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_case_sensitive(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TextFilter::TextFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TextFilter)
}
TextFilter::TextFilter(const TextFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  re2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    re2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_re2()) {
    re2_.Set(from._internal_re2(), 
      GetArenaForAllocation());
  }
  case_sensitive_ = from.case_sensitive_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TextFilter)
}

inline void TextFilter::SharedCtor() {
re2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  re2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
case_sensitive_ = false;
}

TextFilter::~TextFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TextFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  re2_.Destroy();
}

void TextFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TextFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TextFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    re2_.ClearNonDefaultToEmpty();
  }
  case_sensitive_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TextFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string re2 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_re2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool case_sensitive = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_case_sensitive(&has_bits);
          case_sensitive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TextFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string re2 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_re2(), target);
  }

  // optional bool case_sensitive = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_case_sensitive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TextFilter)
  return target;
}

size_t TextFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TextFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string re2 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_re2());
    }

    // optional bool case_sensitive = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextFilter*>(
      &from));
}

void TextFilter::MergeFrom(const TextFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TextFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_re2(from._internal_re2());
    }
    if (cached_has_bits & 0x00000002u) {
      case_sensitive_ = from.case_sensitive_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextFilter::CopyFrom(const TextFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TextFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextFilter::IsInitialized() const {
  return true;
}

void TextFilter::InternalSwap(TextFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &re2_, lhs_arena,
      &other->re2_, rhs_arena
  );
  swap(case_sensitive_, other->case_sensitive_);
}

std::string TextFilter::GetTypeName() const {
  return "autofill_assistant.TextFilter";
}


// ===================================================================

class PasswordManagerValue::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordManagerValue>()._has_bits_);
  static void set_has_credential_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PasswordManagerValue::PasswordManagerValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PasswordManagerValue)
}
PasswordManagerValue::PasswordManagerValue(const PasswordManagerValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  credential_type_ = from.credential_type_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PasswordManagerValue)
}

inline void PasswordManagerValue::SharedCtor() {
credential_type_ = 0;
}

PasswordManagerValue::~PasswordManagerValue() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PasswordManagerValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordManagerValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PasswordManagerValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordManagerValue::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PasswordManagerValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  credential_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordManagerValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.PasswordManagerValue.CredentialType credential_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::PasswordManagerValue_CredentialType_IsValid(val))) {
            _internal_set_credential_type(static_cast<::autofill_assistant::PasswordManagerValue_CredentialType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordManagerValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PasswordManagerValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.PasswordManagerValue.CredentialType credential_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_credential_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PasswordManagerValue)
  return target;
}

size_t PasswordManagerValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PasswordManagerValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.PasswordManagerValue.CredentialType credential_type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_credential_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordManagerValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordManagerValue*>(
      &from));
}

void PasswordManagerValue::MergeFrom(const PasswordManagerValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PasswordManagerValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_credential_type()) {
    _internal_set_credential_type(from._internal_credential_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordManagerValue::CopyFrom(const PasswordManagerValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PasswordManagerValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordManagerValue::IsInitialized() const {
  return true;
}

void PasswordManagerValue::InternalSwap(PasswordManagerValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(credential_type_, other->credential_type_);
}

std::string PasswordManagerValue::GetTypeName() const {
  return "autofill_assistant.PasswordManagerValue";
}


// ===================================================================

class TextValue::_Internal {
 public:
  static const ::autofill_assistant::AutofillValue& autofill_value(const TextValue* msg);
  static const ::autofill_assistant::PasswordManagerValue& password_manager_value(const TextValue* msg);
};

const ::autofill_assistant::AutofillValue&
TextValue::_Internal::autofill_value(const TextValue* msg) {
  return *msg->value_.autofill_value_;
}
const ::autofill_assistant::PasswordManagerValue&
TextValue::_Internal::password_manager_value(const TextValue* msg) {
  return *msg->value_.password_manager_value_;
}
void TextValue::set_allocated_autofill_value(::autofill_assistant::AutofillValue* autofill_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (autofill_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(autofill_value);
    if (message_arena != submessage_arena) {
      autofill_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autofill_value, submessage_arena);
    }
    set_has_autofill_value();
    value_.autofill_value_ = autofill_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextValue.autofill_value)
}
void TextValue::set_allocated_password_manager_value(::autofill_assistant::PasswordManagerValue* password_manager_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (password_manager_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(password_manager_value);
    if (message_arena != submessage_arena) {
      password_manager_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, password_manager_value, submessage_arena);
    }
    set_has_password_manager_value();
    value_.password_manager_value_ = password_manager_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextValue.password_manager_value)
}
TextValue::TextValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TextValue)
}
TextValue::TextValue(const TextValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kAutofillValue: {
      _internal_mutable_autofill_value()->::autofill_assistant::AutofillValue::MergeFrom(from._internal_autofill_value());
      break;
    }
    case kPasswordManagerValue: {
      _internal_mutable_password_manager_value()->::autofill_assistant::PasswordManagerValue::MergeFrom(from._internal_password_manager_value());
      break;
    }
    case kClientMemoryKey: {
      _internal_set_client_memory_key(from._internal_client_memory_key());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TextValue)
}

inline void TextValue::SharedCtor() {
clear_has_value();
}

TextValue::~TextValue() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TextValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void TextValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TextValue::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.TextValue)
  switch (value_case()) {
    case kText: {
      value_.text_.Destroy();
      break;
    }
    case kAutofillValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.autofill_value_;
      }
      break;
    }
    case kPasswordManagerValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.password_manager_value_;
      }
      break;
    }
    case kClientMemoryKey: {
      value_.client_memory_key_.Destroy();
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void TextValue::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TextValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* TextValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.AutofillValue autofill_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_autofill_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PasswordManagerValue password_manager_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_password_manager_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string client_memory_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_client_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TextValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (value_case()) {
    case kText: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_text(), target);
      break;
    }
    case kAutofillValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::autofill_value(this),
          _Internal::autofill_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kPasswordManagerValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::password_manager_value(this),
          _Internal::password_manager_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kClientMemoryKey: {
      target = stream->WriteStringMaybeAliased(
          4, this->_internal_client_memory_key(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TextValue)
  return target;
}

size_t TextValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TextValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // string text = 1;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    // .autofill_assistant.AutofillValue autofill_value = 2;
    case kAutofillValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.autofill_value_);
      break;
    }
    // .autofill_assistant.PasswordManagerValue password_manager_value = 3;
    case kPasswordManagerValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.password_manager_value_);
      break;
    }
    // string client_memory_key = 4;
    case kClientMemoryKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_memory_key());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextValue*>(
      &from));
}

void TextValue::MergeFrom(const TextValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TextValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kAutofillValue: {
      _internal_mutable_autofill_value()->::autofill_assistant::AutofillValue::MergeFrom(from._internal_autofill_value());
      break;
    }
    case kPasswordManagerValue: {
      _internal_mutable_password_manager_value()->::autofill_assistant::PasswordManagerValue::MergeFrom(from._internal_password_manager_value());
      break;
    }
    case kClientMemoryKey: {
      _internal_set_client_memory_key(from._internal_client_memory_key());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextValue::CopyFrom(const TextValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TextValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextValue::IsInitialized() const {
  return true;
}

void TextValue::InternalSwap(TextValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string TextValue::GetTypeName() const {
  return "autofill_assistant.TextValue";
}


// ===================================================================

class KeyEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyEvent>()._has_bits_);
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

KeyEvent::KeyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  command_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.KeyEvent)
}
KeyEvent::KeyEvent(const KeyEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      command_(from.command_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_code()) {
    code_.Set(from._internal_code(), 
      GetArenaForAllocation());
  }
  text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(from._internal_text(), 
      GetArenaForAllocation());
  }
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  key_code_ = from.key_code_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.KeyEvent)
}

inline void KeyEvent::SharedCtor() {
code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_code_ = 0;
}

KeyEvent::~KeyEvent() {
  // @@protoc_insertion_point(destructor:autofill_assistant.KeyEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  code_.Destroy();
  text_.Destroy();
  key_.Destroy();
}

void KeyEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.KeyEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  command_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      key_.ClearNonDefaultToEmpty();
    }
  }
  key_code_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* KeyEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string command = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_command();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 key_code = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_key_code(&has_bits);
          key_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.KeyEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string code = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_code(), target);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  // optional string key = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_key(), target);
  }

  // repeated string command = 5;
  for (int i = 0, n = this->_internal_command_size(); i < n; i++) {
    const auto& s = this->_internal_command(i);
    target = stream->WriteString(5, s, target);
  }

  // optional int32 key_code = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_key_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.KeyEvent)
  return target;
}

size_t KeyEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.KeyEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string command = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(command_.size());
  for (int i = 0, n = command_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      command_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string code = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_code());
    }

    // optional string text = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional string key = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional int32 key_code = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KeyEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KeyEvent*>(
      &from));
}

void KeyEvent::MergeFrom(const KeyEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.KeyEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  command_.MergeFrom(from.command_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_code(from._internal_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000008u) {
      key_code_ = from.key_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyEvent::CopyFrom(const KeyEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.KeyEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyEvent::IsInitialized() const {
  return true;
}

void KeyEvent::InternalSwap(KeyEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  command_.InternalSwap(&other->command_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &code_, lhs_arena,
      &other->code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  swap(key_code_, other->key_code_);
}

std::string KeyEvent::GetTypeName() const {
  return "autofill_assistant.KeyEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillProfile*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillProfile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillProfile >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueExpression_RegexpReplacement*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueExpression_RegexpReplacement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueExpression_RegexpReplacement >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueExpression_Chunk_ReplacementsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueExpression_Chunk_ReplacementsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueExpression_Chunk_ReplacementsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueExpression_Chunk*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueExpression_Chunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueExpression_Chunk >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueExpression*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueExpression >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueExpression >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueExpressionRegexp*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueExpressionRegexp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueExpressionRegexp >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillValue*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillValue >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillValueRegexp*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillValueRegexp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillValueRegexp >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TextFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::TextFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TextFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PasswordManagerValue*
Arena::CreateMaybeMessage< ::autofill_assistant::PasswordManagerValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PasswordManagerValue >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TextValue*
Arena::CreateMaybeMessage< ::autofill_assistant::TextValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TextValue >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::KeyEvent*
Arena::CreateMaybeMessage< ::autofill_assistant::KeyEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::KeyEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
