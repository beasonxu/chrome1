// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/cud_condition.proto

#include "components/autofill_assistant/browser/cud_condition.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
PROTOBUF_CONSTEXPR RequiredDataPiece_Condition::RequiredDataPiece_Condition(
    ::_pbi::ConstantInitialized)
  : key_(0)
  , _oneof_case_{}{}
struct RequiredDataPiece_ConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredDataPiece_ConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredDataPiece_ConditionDefaultTypeInternal() {}
  union {
    RequiredDataPiece_Condition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredDataPiece_ConditionDefaultTypeInternal _RequiredDataPiece_Condition_default_instance_;
PROTOBUF_CONSTEXPR RequiredDataPiece_NotEmptyCondition::RequiredDataPiece_NotEmptyCondition(
    ::_pbi::ConstantInitialized){}
struct RequiredDataPiece_NotEmptyConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredDataPiece_NotEmptyConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredDataPiece_NotEmptyConditionDefaultTypeInternal() {}
  union {
    RequiredDataPiece_NotEmptyCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredDataPiece_NotEmptyConditionDefaultTypeInternal _RequiredDataPiece_NotEmptyCondition_default_instance_;
PROTOBUF_CONSTEXPR RequiredDataPiece_RegexpCondition::RequiredDataPiece_RegexpCondition(
    ::_pbi::ConstantInitialized)
  : text_filter_(nullptr){}
struct RequiredDataPiece_RegexpConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredDataPiece_RegexpConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredDataPiece_RegexpConditionDefaultTypeInternal() {}
  union {
    RequiredDataPiece_RegexpCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredDataPiece_RegexpConditionDefaultTypeInternal _RequiredDataPiece_RegexpCondition_default_instance_;
PROTOBUF_CONSTEXPR RequiredDataPiece::RequiredDataPiece(
    ::_pbi::ConstantInitialized)
  : error_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , condition_(nullptr){}
struct RequiredDataPieceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredDataPieceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredDataPieceDefaultTypeInternal() {}
  union {
    RequiredDataPiece _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredDataPieceDefaultTypeInternal _RequiredDataPiece_default_instance_;
}  // namespace autofill_assistant
namespace autofill_assistant {

// ===================================================================

class RequiredDataPiece_Condition::_Internal {
 public:
  using HasBits = decltype(std::declval<RequiredDataPiece_Condition>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::RequiredDataPiece_NotEmptyCondition& not_empty(const RequiredDataPiece_Condition* msg);
  static const ::autofill_assistant::RequiredDataPiece_RegexpCondition& regexp(const RequiredDataPiece_Condition* msg);
};

const ::autofill_assistant::RequiredDataPiece_NotEmptyCondition&
RequiredDataPiece_Condition::_Internal::not_empty(const RequiredDataPiece_Condition* msg) {
  return *msg->condition_.not_empty_;
}
const ::autofill_assistant::RequiredDataPiece_RegexpCondition&
RequiredDataPiece_Condition::_Internal::regexp(const RequiredDataPiece_Condition* msg) {
  return *msg->condition_.regexp_;
}
void RequiredDataPiece_Condition::set_allocated_not_empty(::autofill_assistant::RequiredDataPiece_NotEmptyCondition* not_empty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_condition();
  if (not_empty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(not_empty);
    if (message_arena != submessage_arena) {
      not_empty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, not_empty, submessage_arena);
    }
    set_has_not_empty();
    condition_.not_empty_ = not_empty;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.RequiredDataPiece.Condition.not_empty)
}
void RequiredDataPiece_Condition::set_allocated_regexp(::autofill_assistant::RequiredDataPiece_RegexpCondition* regexp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_condition();
  if (regexp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regexp);
    if (message_arena != submessage_arena) {
      regexp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regexp, submessage_arena);
    }
    set_has_regexp();
    condition_.regexp_ = regexp;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.RequiredDataPiece.Condition.regexp)
}
RequiredDataPiece_Condition::RequiredDataPiece_Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RequiredDataPiece.Condition)
}
RequiredDataPiece_Condition::RequiredDataPiece_Condition(const RequiredDataPiece_Condition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_ = from.key_;
  clear_has_condition();
  switch (from.condition_case()) {
    case kNotEmpty: {
      _internal_mutable_not_empty()->::autofill_assistant::RequiredDataPiece_NotEmptyCondition::MergeFrom(from._internal_not_empty());
      break;
    }
    case kRegexp: {
      _internal_mutable_regexp()->::autofill_assistant::RequiredDataPiece_RegexpCondition::MergeFrom(from._internal_regexp());
      break;
    }
    case CONDITION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RequiredDataPiece.Condition)
}

inline void RequiredDataPiece_Condition::SharedCtor() {
key_ = 0;
clear_has_condition();
}

RequiredDataPiece_Condition::~RequiredDataPiece_Condition() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RequiredDataPiece.Condition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredDataPiece_Condition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_condition()) {
    clear_condition();
  }
}

void RequiredDataPiece_Condition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequiredDataPiece_Condition::clear_condition() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.RequiredDataPiece.Condition)
  switch (condition_case()) {
    case kNotEmpty: {
      if (GetArenaForAllocation() == nullptr) {
        delete condition_.not_empty_;
      }
      break;
    }
    case kRegexp: {
      if (GetArenaForAllocation() == nullptr) {
        delete condition_.regexp_;
      }
      break;
    }
    case CONDITION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CONDITION_NOT_SET;
}


void RequiredDataPiece_Condition::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RequiredDataPiece.Condition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_ = 0;
  clear_condition();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequiredDataPiece_Condition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key(&has_bits);
          key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.RequiredDataPiece.NotEmptyCondition not_empty = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_not_empty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.RequiredDataPiece.RegexpCondition regexp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_regexp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredDataPiece_Condition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RequiredDataPiece.Condition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_key(), target);
  }

  switch (condition_case()) {
    case kNotEmpty: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::not_empty(this),
          _Internal::not_empty(this).GetCachedSize(), target, stream);
      break;
    }
    case kRegexp: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::regexp(this),
          _Internal::regexp(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RequiredDataPiece.Condition)
  return target;
}

size_t RequiredDataPiece_Condition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RequiredDataPiece.Condition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 key = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key());
  }

  switch (condition_case()) {
    // .autofill_assistant.RequiredDataPiece.NotEmptyCondition not_empty = 2;
    case kNotEmpty: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *condition_.not_empty_);
      break;
    }
    // .autofill_assistant.RequiredDataPiece.RegexpCondition regexp = 3;
    case kRegexp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *condition_.regexp_);
      break;
    }
    case CONDITION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequiredDataPiece_Condition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RequiredDataPiece_Condition*>(
      &from));
}

void RequiredDataPiece_Condition::MergeFrom(const RequiredDataPiece_Condition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RequiredDataPiece.Condition)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key()) {
    _internal_set_key(from._internal_key());
  }
  switch (from.condition_case()) {
    case kNotEmpty: {
      _internal_mutable_not_empty()->::autofill_assistant::RequiredDataPiece_NotEmptyCondition::MergeFrom(from._internal_not_empty());
      break;
    }
    case kRegexp: {
      _internal_mutable_regexp()->::autofill_assistant::RequiredDataPiece_RegexpCondition::MergeFrom(from._internal_regexp());
      break;
    }
    case CONDITION_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequiredDataPiece_Condition::CopyFrom(const RequiredDataPiece_Condition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RequiredDataPiece.Condition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredDataPiece_Condition::IsInitialized() const {
  return true;
}

void RequiredDataPiece_Condition::InternalSwap(RequiredDataPiece_Condition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(key_, other->key_);
  swap(condition_, other->condition_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string RequiredDataPiece_Condition::GetTypeName() const {
  return "autofill_assistant.RequiredDataPiece.Condition";
}


// ===================================================================

class RequiredDataPiece_NotEmptyCondition::_Internal {
 public:
};

RequiredDataPiece_NotEmptyCondition::RequiredDataPiece_NotEmptyCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
}
RequiredDataPiece_NotEmptyCondition::RequiredDataPiece_NotEmptyCondition(const RequiredDataPiece_NotEmptyCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
}

inline void RequiredDataPiece_NotEmptyCondition::SharedCtor() {
}

RequiredDataPiece_NotEmptyCondition::~RequiredDataPiece_NotEmptyCondition() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredDataPiece_NotEmptyCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RequiredDataPiece_NotEmptyCondition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequiredDataPiece_NotEmptyCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* RequiredDataPiece_NotEmptyCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredDataPiece_NotEmptyCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  return target;
}

size_t RequiredDataPiece_NotEmptyCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequiredDataPiece_NotEmptyCondition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RequiredDataPiece_NotEmptyCondition*>(
      &from));
}

void RequiredDataPiece_NotEmptyCondition::MergeFrom(const RequiredDataPiece_NotEmptyCondition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequiredDataPiece_NotEmptyCondition::CopyFrom(const RequiredDataPiece_NotEmptyCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RequiredDataPiece.NotEmptyCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredDataPiece_NotEmptyCondition::IsInitialized() const {
  return true;
}

void RequiredDataPiece_NotEmptyCondition::InternalSwap(RequiredDataPiece_NotEmptyCondition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string RequiredDataPiece_NotEmptyCondition::GetTypeName() const {
  return "autofill_assistant.RequiredDataPiece.NotEmptyCondition";
}


// ===================================================================

class RequiredDataPiece_RegexpCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<RequiredDataPiece_RegexpCondition>()._has_bits_);
  static const ::autofill_assistant::TextFilter& text_filter(const RequiredDataPiece_RegexpCondition* msg);
  static void set_has_text_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::TextFilter&
RequiredDataPiece_RegexpCondition::_Internal::text_filter(const RequiredDataPiece_RegexpCondition* msg) {
  return *msg->text_filter_;
}
void RequiredDataPiece_RegexpCondition::clear_text_filter() {
  if (text_filter_ != nullptr) text_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
RequiredDataPiece_RegexpCondition::RequiredDataPiece_RegexpCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RequiredDataPiece.RegexpCondition)
}
RequiredDataPiece_RegexpCondition::RequiredDataPiece_RegexpCondition(const RequiredDataPiece_RegexpCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_text_filter()) {
    text_filter_ = new ::autofill_assistant::TextFilter(*from.text_filter_);
  } else {
    text_filter_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RequiredDataPiece.RegexpCondition)
}

inline void RequiredDataPiece_RegexpCondition::SharedCtor() {
text_filter_ = nullptr;
}

RequiredDataPiece_RegexpCondition::~RequiredDataPiece_RegexpCondition() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RequiredDataPiece.RegexpCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredDataPiece_RegexpCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete text_filter_;
}

void RequiredDataPiece_RegexpCondition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequiredDataPiece_RegexpCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RequiredDataPiece.RegexpCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(text_filter_ != nullptr);
    text_filter_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequiredDataPiece_RegexpCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.TextFilter text_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredDataPiece_RegexpCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RequiredDataPiece.RegexpCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.TextFilter text_filter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::text_filter(this),
        _Internal::text_filter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RequiredDataPiece.RegexpCondition)
  return target;
}

size_t RequiredDataPiece_RegexpCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RequiredDataPiece.RegexpCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.TextFilter text_filter = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *text_filter_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequiredDataPiece_RegexpCondition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RequiredDataPiece_RegexpCondition*>(
      &from));
}

void RequiredDataPiece_RegexpCondition::MergeFrom(const RequiredDataPiece_RegexpCondition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RequiredDataPiece.RegexpCondition)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text_filter()) {
    _internal_mutable_text_filter()->::autofill_assistant::TextFilter::MergeFrom(from._internal_text_filter());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequiredDataPiece_RegexpCondition::CopyFrom(const RequiredDataPiece_RegexpCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RequiredDataPiece.RegexpCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredDataPiece_RegexpCondition::IsInitialized() const {
  return true;
}

void RequiredDataPiece_RegexpCondition::InternalSwap(RequiredDataPiece_RegexpCondition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(text_filter_, other->text_filter_);
}

std::string RequiredDataPiece_RegexpCondition::GetTypeName() const {
  return "autofill_assistant.RequiredDataPiece.RegexpCondition";
}


// ===================================================================

class RequiredDataPiece::_Internal {
 public:
  using HasBits = decltype(std::declval<RequiredDataPiece>()._has_bits_);
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::RequiredDataPiece_Condition& condition(const RequiredDataPiece* msg);
  static void set_has_condition(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::RequiredDataPiece_Condition&
RequiredDataPiece::_Internal::condition(const RequiredDataPiece* msg) {
  return *msg->condition_;
}
RequiredDataPiece::RequiredDataPiece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RequiredDataPiece)
}
RequiredDataPiece::RequiredDataPiece(const RequiredDataPiece& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    error_message_.Set(from._internal_error_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_condition()) {
    condition_ = new ::autofill_assistant::RequiredDataPiece_Condition(*from.condition_);
  } else {
    condition_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RequiredDataPiece)
}

inline void RequiredDataPiece::SharedCtor() {
error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
condition_ = nullptr;
}

RequiredDataPiece::~RequiredDataPiece() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RequiredDataPiece)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredDataPiece::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_message_.Destroy();
  if (this != internal_default_instance()) delete condition_;
}

void RequiredDataPiece::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequiredDataPiece::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RequiredDataPiece)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(condition_ != nullptr);
      condition_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequiredDataPiece::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string error_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.RequiredDataPiece.Condition condition = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredDataPiece::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RequiredDataPiece)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string error_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error_message(), target);
  }

  // optional .autofill_assistant.RequiredDataPiece.Condition condition = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::condition(this),
        _Internal::condition(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RequiredDataPiece)
  return target;
}

size_t RequiredDataPiece::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RequiredDataPiece)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string error_message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional .autofill_assistant.RequiredDataPiece.Condition condition = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *condition_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequiredDataPiece::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RequiredDataPiece*>(
      &from));
}

void RequiredDataPiece::MergeFrom(const RequiredDataPiece& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RequiredDataPiece)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_condition()->::autofill_assistant::RequiredDataPiece_Condition::MergeFrom(from._internal_condition());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequiredDataPiece::CopyFrom(const RequiredDataPiece& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RequiredDataPiece)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredDataPiece::IsInitialized() const {
  return true;
}

void RequiredDataPiece::InternalSwap(RequiredDataPiece* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &error_message_, lhs_arena,
      &other->error_message_, rhs_arena
  );
  swap(condition_, other->condition_);
}

std::string RequiredDataPiece::GetTypeName() const {
  return "autofill_assistant.RequiredDataPiece";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill_assistant::RequiredDataPiece_Condition*
Arena::CreateMaybeMessage< ::autofill_assistant::RequiredDataPiece_Condition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RequiredDataPiece_Condition >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RequiredDataPiece_NotEmptyCondition*
Arena::CreateMaybeMessage< ::autofill_assistant::RequiredDataPiece_NotEmptyCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RequiredDataPiece_NotEmptyCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RequiredDataPiece_RegexpCondition*
Arena::CreateMaybeMessage< ::autofill_assistant::RequiredDataPiece_RegexpCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RequiredDataPiece_RegexpCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RequiredDataPiece*
Arena::CreateMaybeMessage< ::autofill_assistant::RequiredDataPiece >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RequiredDataPiece >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
