// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
class AutofillCreditCardProto;
struct AutofillCreditCardProtoDefaultTypeInternal;
extern AutofillCreditCardProtoDefaultTypeInternal _AutofillCreditCardProto_default_instance_;
class AutofillProfileProto;
struct AutofillProfileProtoDefaultTypeInternal;
extern AutofillProfileProtoDefaultTypeInternal _AutofillProfileProto_default_instance_;
class BooleanList;
struct BooleanListDefaultTypeInternal;
extern BooleanListDefaultTypeInternal _BooleanList_default_instance_;
class ChipProto;
struct ChipProtoDefaultTypeInternal;
extern ChipProtoDefaultTypeInternal _ChipProto_default_instance_;
class CreditCardList;
struct CreditCardListDefaultTypeInternal;
extern CreditCardListDefaultTypeInternal _CreditCardList_default_instance_;
class CreditCardResponseProto;
struct CreditCardResponseProtoDefaultTypeInternal;
extern CreditCardResponseProtoDefaultTypeInternal _CreditCardResponseProto_default_instance_;
class DateList;
struct DateListDefaultTypeInternal;
extern DateListDefaultTypeInternal _DateList_default_instance_;
class DateProto;
struct DateProtoDefaultTypeInternal;
extern DateProtoDefaultTypeInternal _DateProto_default_instance_;
class DateTimeProto;
struct DateTimeProtoDefaultTypeInternal;
extern DateTimeProtoDefaultTypeInternal _DateTimeProto_default_instance_;
class DirectActionProto;
struct DirectActionProtoDefaultTypeInternal;
extern DirectActionProtoDefaultTypeInternal _DirectActionProto_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class IntList;
struct IntListDefaultTypeInternal;
extern IntListDefaultTypeInternal _IntList_default_instance_;
class LoginOptionList;
struct LoginOptionListDefaultTypeInternal;
extern LoginOptionListDefaultTypeInternal _LoginOptionList_default_instance_;
class LoginOptionProto;
struct LoginOptionProtoDefaultTypeInternal;
extern LoginOptionProtoDefaultTypeInternal _LoginOptionProto_default_instance_;
class ModelProto;
struct ModelProtoDefaultTypeInternal;
extern ModelProtoDefaultTypeInternal _ModelProto_default_instance_;
class ModelProto_ModelValue;
struct ModelProto_ModelValueDefaultTypeInternal;
extern ModelProto_ModelValueDefaultTypeInternal _ModelProto_ModelValue_default_instance_;
class ProfileList;
struct ProfileListDefaultTypeInternal;
extern ProfileListDefaultTypeInternal _ProfileList_default_instance_;
class StringList;
struct StringListDefaultTypeInternal;
extern StringListDefaultTypeInternal _StringList_default_instance_;
class TimeProto;
struct TimeProtoDefaultTypeInternal;
extern TimeProtoDefaultTypeInternal _TimeProto_default_instance_;
class UserActionList;
struct UserActionListDefaultTypeInternal;
extern UserActionListDefaultTypeInternal _UserActionList_default_instance_;
class UserActionProto;
struct UserActionProtoDefaultTypeInternal;
extern UserActionProtoDefaultTypeInternal _UserActionProto_default_instance_;
class ValueProto;
struct ValueProtoDefaultTypeInternal;
extern ValueProtoDefaultTypeInternal _ValueProto_default_instance_;
class ValueReferenceProto;
struct ValueReferenceProtoDefaultTypeInternal;
extern ValueReferenceProtoDefaultTypeInternal _ValueReferenceProto_default_instance_;
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::AutofillCreditCardProto* Arena::CreateMaybeMessage<::autofill_assistant::AutofillCreditCardProto>(Arena*);
template<> ::autofill_assistant::AutofillProfileProto* Arena::CreateMaybeMessage<::autofill_assistant::AutofillProfileProto>(Arena*);
template<> ::autofill_assistant::BooleanList* Arena::CreateMaybeMessage<::autofill_assistant::BooleanList>(Arena*);
template<> ::autofill_assistant::ChipProto* Arena::CreateMaybeMessage<::autofill_assistant::ChipProto>(Arena*);
template<> ::autofill_assistant::CreditCardList* Arena::CreateMaybeMessage<::autofill_assistant::CreditCardList>(Arena*);
template<> ::autofill_assistant::CreditCardResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::CreditCardResponseProto>(Arena*);
template<> ::autofill_assistant::DateList* Arena::CreateMaybeMessage<::autofill_assistant::DateList>(Arena*);
template<> ::autofill_assistant::DateProto* Arena::CreateMaybeMessage<::autofill_assistant::DateProto>(Arena*);
template<> ::autofill_assistant::DateTimeProto* Arena::CreateMaybeMessage<::autofill_assistant::DateTimeProto>(Arena*);
template<> ::autofill_assistant::DirectActionProto* Arena::CreateMaybeMessage<::autofill_assistant::DirectActionProto>(Arena*);
template<> ::autofill_assistant::Empty* Arena::CreateMaybeMessage<::autofill_assistant::Empty>(Arena*);
template<> ::autofill_assistant::IntList* Arena::CreateMaybeMessage<::autofill_assistant::IntList>(Arena*);
template<> ::autofill_assistant::LoginOptionList* Arena::CreateMaybeMessage<::autofill_assistant::LoginOptionList>(Arena*);
template<> ::autofill_assistant::LoginOptionProto* Arena::CreateMaybeMessage<::autofill_assistant::LoginOptionProto>(Arena*);
template<> ::autofill_assistant::ModelProto* Arena::CreateMaybeMessage<::autofill_assistant::ModelProto>(Arena*);
template<> ::autofill_assistant::ModelProto_ModelValue* Arena::CreateMaybeMessage<::autofill_assistant::ModelProto_ModelValue>(Arena*);
template<> ::autofill_assistant::ProfileList* Arena::CreateMaybeMessage<::autofill_assistant::ProfileList>(Arena*);
template<> ::autofill_assistant::StringList* Arena::CreateMaybeMessage<::autofill_assistant::StringList>(Arena*);
template<> ::autofill_assistant::TimeProto* Arena::CreateMaybeMessage<::autofill_assistant::TimeProto>(Arena*);
template<> ::autofill_assistant::UserActionList* Arena::CreateMaybeMessage<::autofill_assistant::UserActionList>(Arena*);
template<> ::autofill_assistant::UserActionProto* Arena::CreateMaybeMessage<::autofill_assistant::UserActionProto>(Arena*);
template<> ::autofill_assistant::ValueProto* Arena::CreateMaybeMessage<::autofill_assistant::ValueProto>(Arena*);
template<> ::autofill_assistant::ValueReferenceProto* Arena::CreateMaybeMessage<::autofill_assistant::ValueReferenceProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {

enum ProcessedActionStatusProto : int {
  UNKNOWN_ACTION_STATUS = 0,
  ELEMENT_RESOLUTION_FAILED = 1,
  ACTION_APPLIED = 2,
  OTHER_ACTION_STATUS = 3,
  COLLECT_USER_DATA_ERROR = 4,
  UNSUPPORTED_ACTION = 5,
  MANUAL_FALLBACK = 6,
  INTERRUPT_FAILED = 7,
  USER_ABORTED_ACTION = 8,
  GET_FULL_CARD_FAILED = 9,
  PRECONDITION_FAILED = 10,
  INVALID_ACTION = 11,
  UNSUPPORTED = 12,
  TIMED_OUT = 13,
  ELEMENT_UNSTABLE = 14,
  OPTION_VALUE_NOT_FOUND = 16,
  UNEXPECTED_JS_ERROR = 17,
  TOO_MANY_ELEMENTS = 18,
  NAVIGATION_ERROR = 19,
  INVALID_SELECTOR = 20,
  AUTOFILL_INFO_NOT_AVAILABLE = 21,
  FRAME_HOST_NOT_FOUND = 22,
  AUTOFILL_INCOMPLETE = 24,
  ELEMENT_MISMATCH = 26,
  ELEMENT_NOT_ON_TOP = 27,
  CLIENT_ID_RESOLUTION_FAILED = 28,
  PASSWORD_ORIGIN_MISMATCH = 29,
  TOO_MANY_OPTION_VALUES_FOUND = 30,
  INVALID_TARGET = 31,
  ELEMENT_POSITION_NOT_FOUND = 33,
  CLIENT_MEMORY_KEY_NOT_AVAILABLE = 34,
  EMPTY_VALUE_EXPRESSION_RESULT = 35,
  NO_RENDER_FRAME = 37,
  USER_DATA_REQUEST_FAILED = 38,
  JS_FORCED_ROUNDTRIP = 39,
  QR_CODE_SCAN_FAILURE = 40,
  QR_CODE_SCAN_CANCELLED = 41,
  QR_CODE_SCAN_CAMERA_ERROR = 42
};
bool ProcessedActionStatusProto_IsValid(int value);
constexpr ProcessedActionStatusProto ProcessedActionStatusProto_MIN = UNKNOWN_ACTION_STATUS;
constexpr ProcessedActionStatusProto ProcessedActionStatusProto_MAX = QR_CODE_SCAN_CAMERA_ERROR;
constexpr int ProcessedActionStatusProto_ARRAYSIZE = ProcessedActionStatusProto_MAX + 1;

const std::string& ProcessedActionStatusProto_Name(ProcessedActionStatusProto value);
template<typename T>
inline const std::string& ProcessedActionStatusProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessedActionStatusProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessedActionStatusProto_Name.");
  return ProcessedActionStatusProto_Name(static_cast<ProcessedActionStatusProto>(enum_t_value));
}
bool ProcessedActionStatusProto_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessedActionStatusProto* value);
enum ChipType : int {
  UNKNOWN_CHIP_TYPE = 0,
  HIGHLIGHTED_ACTION = 1,
  NORMAL_ACTION = 3,
  CANCEL_ACTION = 4,
  CLOSE_ACTION = 5,
  DONE_ACTION = 6,
  FEEDBACK_ACTION = 7
};
bool ChipType_IsValid(int value);
constexpr ChipType ChipType_MIN = UNKNOWN_CHIP_TYPE;
constexpr ChipType ChipType_MAX = FEEDBACK_ACTION;
constexpr int ChipType_ARRAYSIZE = ChipType_MAX + 1;

const std::string& ChipType_Name(ChipType value);
template<typename T>
inline const std::string& ChipType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChipType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChipType_Name.");
  return ChipType_Name(static_cast<ChipType>(enum_t_value));
}
bool ChipType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChipType* value);
enum ChipIcon : int {
  NO_ICON = 0,
  ICON_CLEAR = 1,
  ICON_DONE = 2,
  ICON_REFRESH = 3,
  ICON_OVERFLOW = 4
};
bool ChipIcon_IsValid(int value);
constexpr ChipIcon ChipIcon_MIN = NO_ICON;
constexpr ChipIcon ChipIcon_MAX = ICON_OVERFLOW;
constexpr int ChipIcon_ARRAYSIZE = ChipIcon_MAX + 1;

const std::string& ChipIcon_Name(ChipIcon value);
template<typename T>
inline const std::string& ChipIcon_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChipIcon>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChipIcon_Name.");
  return ChipIcon_Name(static_cast<ChipIcon>(enum_t_value));
}
bool ChipIcon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChipIcon* value);
// ===================================================================

class ModelProto_ModelValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ModelProto.ModelValue) */ {
 public:
  inline ModelProto_ModelValue() : ModelProto_ModelValue(nullptr) {}
  ~ModelProto_ModelValue() override;
  explicit PROTOBUF_CONSTEXPR ModelProto_ModelValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelProto_ModelValue(const ModelProto_ModelValue& from);
  ModelProto_ModelValue(ModelProto_ModelValue&& from) noexcept
    : ModelProto_ModelValue() {
    *this = ::std::move(from);
  }

  inline ModelProto_ModelValue& operator=(const ModelProto_ModelValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelProto_ModelValue& operator=(ModelProto_ModelValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ModelProto_ModelValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelProto_ModelValue* internal_default_instance() {
    return reinterpret_cast<const ModelProto_ModelValue*>(
               &_ModelProto_ModelValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModelProto_ModelValue& a, ModelProto_ModelValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ModelProto_ModelValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelProto_ModelValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelProto_ModelValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelProto_ModelValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelProto_ModelValue& from);
  void MergeFrom(const ModelProto_ModelValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelProto_ModelValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ModelProto.ModelValue";
  }
  protected:
  explicit ModelProto_ModelValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .autofill_assistant.ValueProto value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueProto* release_value();
  ::autofill_assistant::ValueProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueProto* value);
  private:
  const ::autofill_assistant::ValueProto& _internal_value() const;
  ::autofill_assistant::ValueProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueProto* value);
  ::autofill_assistant::ValueProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ModelProto.ModelValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::autofill_assistant::ValueProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class ModelProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ModelProto) */ {
 public:
  inline ModelProto() : ModelProto(nullptr) {}
  ~ModelProto() override;
  explicit PROTOBUF_CONSTEXPR ModelProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelProto(const ModelProto& from);
  ModelProto(ModelProto&& from) noexcept
    : ModelProto() {
    *this = ::std::move(from);
  }

  inline ModelProto& operator=(const ModelProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelProto& operator=(ModelProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ModelProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelProto* internal_default_instance() {
    return reinterpret_cast<const ModelProto*>(
               &_ModelProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ModelProto& a, ModelProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ModelProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelProto& from);
  void MergeFrom(const ModelProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ModelProto";
  }
  protected:
  explicit ModelProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ModelProto_ModelValue ModelValue;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.ModelProto.ModelValue values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::ModelProto_ModelValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >*
      mutable_values();
  private:
  const ::autofill_assistant::ModelProto_ModelValue& _internal_values(int index) const;
  ::autofill_assistant::ModelProto_ModelValue* _internal_add_values();
  public:
  const ::autofill_assistant::ModelProto_ModelValue& values(int index) const;
  ::autofill_assistant::ModelProto_ModelValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ModelProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class ValueProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueProto) */ {
 public:
  inline ValueProto() : ValueProto(nullptr) {}
  ~ValueProto() override;
  explicit PROTOBUF_CONSTEXPR ValueProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueProto(const ValueProto& from);
  ValueProto(ValueProto&& from) noexcept
    : ValueProto() {
    *this = ::std::move(from);
  }

  inline ValueProto& operator=(const ValueProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueProto& operator=(ValueProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kStrings = 1,
    kBooleans = 2,
    kInts = 3,
    kUserActions = 4,
    kDates = 5,
    kCreditCards = 7,
    kProfiles = 8,
    kLoginOptions = 9,
    kCreditCardResponse = 10,
    kServerPayload = 12,
    KIND_NOT_SET = 0,
  };

  static inline const ValueProto* internal_default_instance() {
    return reinterpret_cast<const ValueProto*>(
               &_ValueProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ValueProto& a, ValueProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueProto& from);
  void MergeFrom(const ValueProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueProto";
  }
  protected:
  explicit ValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsClientSideOnlyFieldNumber = 6,
    kStringsFieldNumber = 1,
    kBooleansFieldNumber = 2,
    kIntsFieldNumber = 3,
    kUserActionsFieldNumber = 4,
    kDatesFieldNumber = 5,
    kCreditCardsFieldNumber = 7,
    kProfilesFieldNumber = 8,
    kLoginOptionsFieldNumber = 9,
    kCreditCardResponseFieldNumber = 10,
    kServerPayloadFieldNumber = 12,
  };
  // optional bool is_client_side_only = 6;
  bool has_is_client_side_only() const;
  private:
  bool _internal_has_is_client_side_only() const;
  public:
  void clear_is_client_side_only();
  bool is_client_side_only() const;
  void set_is_client_side_only(bool value);
  private:
  bool _internal_is_client_side_only() const;
  void _internal_set_is_client_side_only(bool value);
  public:

  // .autofill_assistant.StringList strings = 1;
  bool has_strings() const;
  private:
  bool _internal_has_strings() const;
  public:
  void clear_strings();
  const ::autofill_assistant::StringList& strings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::StringList* release_strings();
  ::autofill_assistant::StringList* mutable_strings();
  void set_allocated_strings(::autofill_assistant::StringList* strings);
  private:
  const ::autofill_assistant::StringList& _internal_strings() const;
  ::autofill_assistant::StringList* _internal_mutable_strings();
  public:
  void unsafe_arena_set_allocated_strings(
      ::autofill_assistant::StringList* strings);
  ::autofill_assistant::StringList* unsafe_arena_release_strings();

  // .autofill_assistant.BooleanList booleans = 2;
  bool has_booleans() const;
  private:
  bool _internal_has_booleans() const;
  public:
  void clear_booleans();
  const ::autofill_assistant::BooleanList& booleans() const;
  PROTOBUF_NODISCARD ::autofill_assistant::BooleanList* release_booleans();
  ::autofill_assistant::BooleanList* mutable_booleans();
  void set_allocated_booleans(::autofill_assistant::BooleanList* booleans);
  private:
  const ::autofill_assistant::BooleanList& _internal_booleans() const;
  ::autofill_assistant::BooleanList* _internal_mutable_booleans();
  public:
  void unsafe_arena_set_allocated_booleans(
      ::autofill_assistant::BooleanList* booleans);
  ::autofill_assistant::BooleanList* unsafe_arena_release_booleans();

  // .autofill_assistant.IntList ints = 3;
  bool has_ints() const;
  private:
  bool _internal_has_ints() const;
  public:
  void clear_ints();
  const ::autofill_assistant::IntList& ints() const;
  PROTOBUF_NODISCARD ::autofill_assistant::IntList* release_ints();
  ::autofill_assistant::IntList* mutable_ints();
  void set_allocated_ints(::autofill_assistant::IntList* ints);
  private:
  const ::autofill_assistant::IntList& _internal_ints() const;
  ::autofill_assistant::IntList* _internal_mutable_ints();
  public:
  void unsafe_arena_set_allocated_ints(
      ::autofill_assistant::IntList* ints);
  ::autofill_assistant::IntList* unsafe_arena_release_ints();

  // .autofill_assistant.UserActionList user_actions = 4;
  bool has_user_actions() const;
  private:
  bool _internal_has_user_actions() const;
  public:
  void clear_user_actions();
  const ::autofill_assistant::UserActionList& user_actions() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UserActionList* release_user_actions();
  ::autofill_assistant::UserActionList* mutable_user_actions();
  void set_allocated_user_actions(::autofill_assistant::UserActionList* user_actions);
  private:
  const ::autofill_assistant::UserActionList& _internal_user_actions() const;
  ::autofill_assistant::UserActionList* _internal_mutable_user_actions();
  public:
  void unsafe_arena_set_allocated_user_actions(
      ::autofill_assistant::UserActionList* user_actions);
  ::autofill_assistant::UserActionList* unsafe_arena_release_user_actions();

  // .autofill_assistant.DateList dates = 5;
  bool has_dates() const;
  private:
  bool _internal_has_dates() const;
  public:
  void clear_dates();
  const ::autofill_assistant::DateList& dates() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DateList* release_dates();
  ::autofill_assistant::DateList* mutable_dates();
  void set_allocated_dates(::autofill_assistant::DateList* dates);
  private:
  const ::autofill_assistant::DateList& _internal_dates() const;
  ::autofill_assistant::DateList* _internal_mutable_dates();
  public:
  void unsafe_arena_set_allocated_dates(
      ::autofill_assistant::DateList* dates);
  ::autofill_assistant::DateList* unsafe_arena_release_dates();

  // .autofill_assistant.CreditCardList credit_cards = 7;
  bool has_credit_cards() const;
  private:
  bool _internal_has_credit_cards() const;
  public:
  void clear_credit_cards();
  const ::autofill_assistant::CreditCardList& credit_cards() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CreditCardList* release_credit_cards();
  ::autofill_assistant::CreditCardList* mutable_credit_cards();
  void set_allocated_credit_cards(::autofill_assistant::CreditCardList* credit_cards);
  private:
  const ::autofill_assistant::CreditCardList& _internal_credit_cards() const;
  ::autofill_assistant::CreditCardList* _internal_mutable_credit_cards();
  public:
  void unsafe_arena_set_allocated_credit_cards(
      ::autofill_assistant::CreditCardList* credit_cards);
  ::autofill_assistant::CreditCardList* unsafe_arena_release_credit_cards();

  // .autofill_assistant.ProfileList profiles = 8;
  bool has_profiles() const;
  private:
  bool _internal_has_profiles() const;
  public:
  void clear_profiles();
  const ::autofill_assistant::ProfileList& profiles() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ProfileList* release_profiles();
  ::autofill_assistant::ProfileList* mutable_profiles();
  void set_allocated_profiles(::autofill_assistant::ProfileList* profiles);
  private:
  const ::autofill_assistant::ProfileList& _internal_profiles() const;
  ::autofill_assistant::ProfileList* _internal_mutable_profiles();
  public:
  void unsafe_arena_set_allocated_profiles(
      ::autofill_assistant::ProfileList* profiles);
  ::autofill_assistant::ProfileList* unsafe_arena_release_profiles();

  // .autofill_assistant.LoginOptionList login_options = 9;
  bool has_login_options() const;
  private:
  bool _internal_has_login_options() const;
  public:
  void clear_login_options();
  const ::autofill_assistant::LoginOptionList& login_options() const;
  PROTOBUF_NODISCARD ::autofill_assistant::LoginOptionList* release_login_options();
  ::autofill_assistant::LoginOptionList* mutable_login_options();
  void set_allocated_login_options(::autofill_assistant::LoginOptionList* login_options);
  private:
  const ::autofill_assistant::LoginOptionList& _internal_login_options() const;
  ::autofill_assistant::LoginOptionList* _internal_mutable_login_options();
  public:
  void unsafe_arena_set_allocated_login_options(
      ::autofill_assistant::LoginOptionList* login_options);
  ::autofill_assistant::LoginOptionList* unsafe_arena_release_login_options();

  // .autofill_assistant.CreditCardResponseProto credit_card_response = 10;
  bool has_credit_card_response() const;
  private:
  bool _internal_has_credit_card_response() const;
  public:
  void clear_credit_card_response();
  const ::autofill_assistant::CreditCardResponseProto& credit_card_response() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CreditCardResponseProto* release_credit_card_response();
  ::autofill_assistant::CreditCardResponseProto* mutable_credit_card_response();
  void set_allocated_credit_card_response(::autofill_assistant::CreditCardResponseProto* credit_card_response);
  private:
  const ::autofill_assistant::CreditCardResponseProto& _internal_credit_card_response() const;
  ::autofill_assistant::CreditCardResponseProto* _internal_mutable_credit_card_response();
  public:
  void unsafe_arena_set_allocated_credit_card_response(
      ::autofill_assistant::CreditCardResponseProto* credit_card_response);
  ::autofill_assistant::CreditCardResponseProto* unsafe_arena_release_credit_card_response();

  // bytes server_payload = 12;
  bool has_server_payload() const;
  private:
  bool _internal_has_server_payload() const;
  public:
  void clear_server_payload();
  const std::string& server_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_payload();
  PROTOBUF_NODISCARD std::string* release_server_payload();
  void set_allocated_server_payload(std::string* server_payload);
  private:
  const std::string& _internal_server_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_payload(const std::string& value);
  std::string* _internal_mutable_server_payload();
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueProto)
 private:
  class _Internal;
  void set_has_strings();
  void set_has_booleans();
  void set_has_ints();
  void set_has_user_actions();
  void set_has_dates();
  void set_has_credit_cards();
  void set_has_profiles();
  void set_has_login_options();
  void set_has_credit_card_response();
  void set_has_server_payload();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_client_side_only_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::StringList* strings_;
    ::autofill_assistant::BooleanList* booleans_;
    ::autofill_assistant::IntList* ints_;
    ::autofill_assistant::UserActionList* user_actions_;
    ::autofill_assistant::DateList* dates_;
    ::autofill_assistant::CreditCardList* credit_cards_;
    ::autofill_assistant::ProfileList* profiles_;
    ::autofill_assistant::LoginOptionList* login_options_;
    ::autofill_assistant::CreditCardResponseProto* credit_card_response_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_payload_;
  } kind_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class ValueReferenceProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueReferenceProto) */ {
 public:
  inline ValueReferenceProto() : ValueReferenceProto(nullptr) {}
  ~ValueReferenceProto() override;
  explicit PROTOBUF_CONSTEXPR ValueReferenceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueReferenceProto(const ValueReferenceProto& from);
  ValueReferenceProto(ValueReferenceProto&& from) noexcept
    : ValueReferenceProto() {
    *this = ::std::move(from);
  }

  inline ValueReferenceProto& operator=(const ValueReferenceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueReferenceProto& operator=(ValueReferenceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueReferenceProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kValue = 1,
    kModelIdentifier = 2,
    KIND_NOT_SET = 0,
  };

  static inline const ValueReferenceProto* internal_default_instance() {
    return reinterpret_cast<const ValueReferenceProto*>(
               &_ValueReferenceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ValueReferenceProto& a, ValueReferenceProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueReferenceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueReferenceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueReferenceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueReferenceProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueReferenceProto& from);
  void MergeFrom(const ValueReferenceProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueReferenceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueReferenceProto";
  }
  protected:
  explicit ValueReferenceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kModelIdentifierFieldNumber = 2,
  };
  // .autofill_assistant.ValueProto value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::ValueProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueProto* release_value();
  ::autofill_assistant::ValueProto* mutable_value();
  void set_allocated_value(::autofill_assistant::ValueProto* value);
  private:
  const ::autofill_assistant::ValueProto& _internal_value() const;
  ::autofill_assistant::ValueProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::ValueProto* value);
  ::autofill_assistant::ValueProto* unsafe_arena_release_value();

  // string model_identifier = 2;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueReferenceProto)
 private:
  class _Internal;
  void set_has_value();
  void set_has_model_identifier();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::ValueProto* value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class StringList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.StringList) */ {
 public:
  inline StringList() : StringList(nullptr) {}
  ~StringList() override;
  explicit PROTOBUF_CONSTEXPR StringList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringList(const StringList& from);
  StringList(StringList&& from) noexcept
    : StringList() {
    *this = ::std::move(from);
  }

  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringList& operator=(StringList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StringList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringList* internal_default_instance() {
    return reinterpret_cast<const StringList*>(
               &_StringList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StringList& a, StringList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StringList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StringList& from);
  void MergeFrom(const StringList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.StringList";
  }
  protected:
  explicit StringList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.StringList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class BooleanList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.BooleanList) */ {
 public:
  inline BooleanList() : BooleanList(nullptr) {}
  ~BooleanList() override;
  explicit PROTOBUF_CONSTEXPR BooleanList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BooleanList(const BooleanList& from);
  BooleanList(BooleanList&& from) noexcept
    : BooleanList() {
    *this = ::std::move(from);
  }

  inline BooleanList& operator=(const BooleanList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanList& operator=(BooleanList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BooleanList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanList* internal_default_instance() {
    return reinterpret_cast<const BooleanList*>(
               &_BooleanList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BooleanList& a, BooleanList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BooleanList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BooleanList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BooleanList& from);
  void MergeFrom(const BooleanList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BooleanList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.BooleanList";
  }
  protected:
  explicit BooleanList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:autofill_assistant.BooleanList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class IntList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.IntList) */ {
 public:
  inline IntList() : IntList(nullptr) {}
  ~IntList() override;
  explicit PROTOBUF_CONSTEXPR IntList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntList(const IntList& from);
  IntList(IntList&& from) noexcept
    : IntList() {
    *this = ::std::move(from);
  }

  inline IntList& operator=(const IntList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntList& operator=(IntList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IntList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntList* internal_default_instance() {
    return reinterpret_cast<const IntList*>(
               &_IntList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IntList& a, IntList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(IntList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IntList& from);
  void MergeFrom(const IntList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IntList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.IntList";
  }
  protected:
  explicit IntList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:autofill_assistant.IntList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class UserActionList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UserActionList) */ {
 public:
  inline UserActionList() : UserActionList(nullptr) {}
  ~UserActionList() override;
  explicit PROTOBUF_CONSTEXPR UserActionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserActionList(const UserActionList& from);
  UserActionList(UserActionList&& from) noexcept
    : UserActionList() {
    *this = ::std::move(from);
  }

  inline UserActionList& operator=(const UserActionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserActionList& operator=(UserActionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserActionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserActionList* internal_default_instance() {
    return reinterpret_cast<const UserActionList*>(
               &_UserActionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserActionList& a, UserActionList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UserActionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserActionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserActionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserActionList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserActionList& from);
  void MergeFrom(const UserActionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserActionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UserActionList";
  }
  protected:
  explicit UserActionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.UserActionProto values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::UserActionProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >*
      mutable_values();
  private:
  const ::autofill_assistant::UserActionProto& _internal_values(int index) const;
  ::autofill_assistant::UserActionProto* _internal_add_values();
  public:
  const ::autofill_assistant::UserActionProto& values(int index) const;
  ::autofill_assistant::UserActionProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.UserActionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class DateList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DateList) */ {
 public:
  inline DateList() : DateList(nullptr) {}
  ~DateList() override;
  explicit PROTOBUF_CONSTEXPR DateList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateList(const DateList& from);
  DateList(DateList&& from) noexcept
    : DateList() {
    *this = ::std::move(from);
  }

  inline DateList& operator=(const DateList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateList& operator=(DateList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DateList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateList* internal_default_instance() {
    return reinterpret_cast<const DateList*>(
               &_DateList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DateList& a, DateList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DateList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DateList& from);
  void MergeFrom(const DateList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DateList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DateList";
  }
  protected:
  explicit DateList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.DateProto values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::DateProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DateProto >*
      mutable_values();
  private:
  const ::autofill_assistant::DateProto& _internal_values(int index) const;
  ::autofill_assistant::DateProto* _internal_add_values();
  public:
  const ::autofill_assistant::DateProto& values(int index) const;
  ::autofill_assistant::DateProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DateProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.DateList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DateProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class CreditCardList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CreditCardList) */ {
 public:
  inline CreditCardList() : CreditCardList(nullptr) {}
  ~CreditCardList() override;
  explicit PROTOBUF_CONSTEXPR CreditCardList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreditCardList(const CreditCardList& from);
  CreditCardList(CreditCardList&& from) noexcept
    : CreditCardList() {
    *this = ::std::move(from);
  }

  inline CreditCardList& operator=(const CreditCardList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreditCardList& operator=(CreditCardList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CreditCardList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreditCardList* internal_default_instance() {
    return reinterpret_cast<const CreditCardList*>(
               &_CreditCardList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreditCardList& a, CreditCardList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreditCardList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreditCardList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreditCardList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreditCardList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreditCardList& from);
  void MergeFrom(const CreditCardList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreditCardList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CreditCardList";
  }
  protected:
  explicit CreditCardList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.AutofillCreditCardProto values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::AutofillCreditCardProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillCreditCardProto >*
      mutable_values();
  private:
  const ::autofill_assistant::AutofillCreditCardProto& _internal_values(int index) const;
  ::autofill_assistant::AutofillCreditCardProto* _internal_add_values();
  public:
  const ::autofill_assistant::AutofillCreditCardProto& values(int index) const;
  ::autofill_assistant::AutofillCreditCardProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillCreditCardProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.CreditCardList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillCreditCardProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class ProfileList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ProfileList) */ {
 public:
  inline ProfileList() : ProfileList(nullptr) {}
  ~ProfileList() override;
  explicit PROTOBUF_CONSTEXPR ProfileList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileList(const ProfileList& from);
  ProfileList(ProfileList&& from) noexcept
    : ProfileList() {
    *this = ::std::move(from);
  }

  inline ProfileList& operator=(const ProfileList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileList& operator=(ProfileList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProfileList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileList* internal_default_instance() {
    return reinterpret_cast<const ProfileList*>(
               &_ProfileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProfileList& a, ProfileList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ProfileList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProfileList& from);
  void MergeFrom(const ProfileList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ProfileList";
  }
  protected:
  explicit ProfileList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.AutofillProfileProto values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::AutofillProfileProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillProfileProto >*
      mutable_values();
  private:
  const ::autofill_assistant::AutofillProfileProto& _internal_values(int index) const;
  ::autofill_assistant::AutofillProfileProto* _internal_add_values();
  public:
  const ::autofill_assistant::AutofillProfileProto& values(int index) const;
  ::autofill_assistant::AutofillProfileProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillProfileProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ProfileList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillProfileProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class LoginOptionList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LoginOptionList) */ {
 public:
  inline LoginOptionList() : LoginOptionList(nullptr) {}
  ~LoginOptionList() override;
  explicit PROTOBUF_CONSTEXPR LoginOptionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginOptionList(const LoginOptionList& from);
  LoginOptionList(LoginOptionList&& from) noexcept
    : LoginOptionList() {
    *this = ::std::move(from);
  }

  inline LoginOptionList& operator=(const LoginOptionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginOptionList& operator=(LoginOptionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginOptionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginOptionList* internal_default_instance() {
    return reinterpret_cast<const LoginOptionList*>(
               &_LoginOptionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LoginOptionList& a, LoginOptionList& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LoginOptionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginOptionList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginOptionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginOptionList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginOptionList& from);
  void MergeFrom(const LoginOptionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginOptionList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LoginOptionList";
  }
  protected:
  explicit LoginOptionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.LoginOptionProto values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::autofill_assistant::LoginOptionProto* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginOptionProto >*
      mutable_values();
  private:
  const ::autofill_assistant::LoginOptionProto& _internal_values(int index) const;
  ::autofill_assistant::LoginOptionProto* _internal_add_values();
  public:
  const ::autofill_assistant::LoginOptionProto& values(int index) const;
  ::autofill_assistant::LoginOptionProto* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginOptionProto >&
      values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.LoginOptionList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginOptionProto > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  ~Empty() override;
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Empty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class ChipProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ChipProto) */ {
 public:
  inline ChipProto() : ChipProto(nullptr) {}
  ~ChipProto() override;
  explicit PROTOBUF_CONSTEXPR ChipProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChipProto(const ChipProto& from);
  ChipProto(ChipProto&& from) noexcept
    : ChipProto() {
    *this = ::std::move(from);
  }

  inline ChipProto& operator=(const ChipProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChipProto& operator=(ChipProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChipProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChipProto* internal_default_instance() {
    return reinterpret_cast<const ChipProto*>(
               &_ChipProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChipProto& a, ChipProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ChipProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChipProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChipProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChipProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChipProto& from);
  void MergeFrom(const ChipProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChipProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ChipProto";
  }
  protected:
  explicit ChipProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kContentDescriptionFieldNumber = 5,
    kTypeFieldNumber = 1,
    kIconFieldNumber = 2,
    kStickyFieldNumber = 4,
  };
  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string content_description = 5;
  bool has_content_description() const;
  private:
  bool _internal_has_content_description() const;
  public:
  void clear_content_description();
  const std::string& content_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_description();
  PROTOBUF_NODISCARD std::string* release_content_description();
  void set_allocated_content_description(std::string* content_description);
  private:
  const std::string& _internal_content_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_description(const std::string& value);
  std::string* _internal_mutable_content_description();
  public:

  // optional .autofill_assistant.ChipType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::autofill_assistant::ChipType type() const;
  void set_type(::autofill_assistant::ChipType value);
  private:
  ::autofill_assistant::ChipType _internal_type() const;
  void _internal_set_type(::autofill_assistant::ChipType value);
  public:

  // optional .autofill_assistant.ChipIcon icon = 2;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  ::autofill_assistant::ChipIcon icon() const;
  void set_icon(::autofill_assistant::ChipIcon value);
  private:
  ::autofill_assistant::ChipIcon _internal_icon() const;
  void _internal_set_icon(::autofill_assistant::ChipIcon value);
  public:

  // optional bool sticky = 4;
  bool has_sticky() const;
  private:
  bool _internal_has_sticky() const;
  public:
  void clear_sticky();
  bool sticky() const;
  void set_sticky(bool value);
  private:
  bool _internal_sticky() const;
  void _internal_set_sticky(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ChipProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_description_;
  int type_;
  int icon_;
  bool sticky_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class DirectActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DirectActionProto) */ {
 public:
  inline DirectActionProto() : DirectActionProto(nullptr) {}
  ~DirectActionProto() override;
  explicit PROTOBUF_CONSTEXPR DirectActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectActionProto(const DirectActionProto& from);
  DirectActionProto(DirectActionProto&& from) noexcept
    : DirectActionProto() {
    *this = ::std::move(from);
  }

  inline DirectActionProto& operator=(const DirectActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectActionProto& operator=(DirectActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectActionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectActionProto* internal_default_instance() {
    return reinterpret_cast<const DirectActionProto*>(
               &_DirectActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DirectActionProto& a, DirectActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DirectActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectActionProto& from);
  void MergeFrom(const DirectActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DirectActionProto";
  }
  protected:
  explicit DirectActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
    kRequiredArgumentsFieldNumber = 2,
    kOptionalArgumentsFieldNumber = 3,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // repeated string required_arguments = 2;
  int required_arguments_size() const;
  private:
  int _internal_required_arguments_size() const;
  public:
  void clear_required_arguments();
  const std::string& required_arguments(int index) const;
  std::string* mutable_required_arguments(int index);
  void set_required_arguments(int index, const std::string& value);
  void set_required_arguments(int index, std::string&& value);
  void set_required_arguments(int index, const char* value);
  void set_required_arguments(int index, const char* value, size_t size);
  std::string* add_required_arguments();
  void add_required_arguments(const std::string& value);
  void add_required_arguments(std::string&& value);
  void add_required_arguments(const char* value);
  void add_required_arguments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_arguments();
  private:
  const std::string& _internal_required_arguments(int index) const;
  std::string* _internal_add_required_arguments();
  public:

  // repeated string optional_arguments = 3;
  int optional_arguments_size() const;
  private:
  int _internal_optional_arguments_size() const;
  public:
  void clear_optional_arguments();
  const std::string& optional_arguments(int index) const;
  std::string* mutable_optional_arguments(int index);
  void set_optional_arguments(int index, const std::string& value);
  void set_optional_arguments(int index, std::string&& value);
  void set_optional_arguments(int index, const char* value);
  void set_optional_arguments(int index, const char* value, size_t size);
  std::string* add_optional_arguments();
  void add_optional_arguments(const std::string& value);
  void add_optional_arguments(std::string&& value);
  void add_optional_arguments(const char* value);
  void add_optional_arguments(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& optional_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_optional_arguments();
  private:
  const std::string& _internal_optional_arguments(int index) const;
  std::string* _internal_add_optional_arguments();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DirectActionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_arguments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> optional_arguments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class UserActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UserActionProto) */ {
 public:
  inline UserActionProto() : UserActionProto(nullptr) {}
  ~UserActionProto() override;
  explicit PROTOBUF_CONSTEXPR UserActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserActionProto(const UserActionProto& from);
  UserActionProto(UserActionProto&& from) noexcept
    : UserActionProto() {
    *this = ::std::move(from);
  }

  inline UserActionProto& operator=(const UserActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserActionProto& operator=(UserActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserActionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserActionProto* internal_default_instance() {
    return reinterpret_cast<const UserActionProto*>(
               &_UserActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UserActionProto& a, UserActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UserActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserActionProto& from);
  void MergeFrom(const UserActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UserActionProto";
  }
  protected:
  explicit UserActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 3,
    kChipFieldNumber = 1,
    kDirectActionFieldNumber = 2,
    kEnabledFieldNumber = 4,
  };
  // optional string identifier = 3;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .autofill_assistant.ChipProto chip = 1;
  bool has_chip() const;
  private:
  bool _internal_has_chip() const;
  public:
  void clear_chip();
  const ::autofill_assistant::ChipProto& chip() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ChipProto* release_chip();
  ::autofill_assistant::ChipProto* mutable_chip();
  void set_allocated_chip(::autofill_assistant::ChipProto* chip);
  private:
  const ::autofill_assistant::ChipProto& _internal_chip() const;
  ::autofill_assistant::ChipProto* _internal_mutable_chip();
  public:
  void unsafe_arena_set_allocated_chip(
      ::autofill_assistant::ChipProto* chip);
  ::autofill_assistant::ChipProto* unsafe_arena_release_chip();

  // optional .autofill_assistant.DirectActionProto direct_action = 2;
  bool has_direct_action() const;
  private:
  bool _internal_has_direct_action() const;
  public:
  void clear_direct_action();
  const ::autofill_assistant::DirectActionProto& direct_action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DirectActionProto* release_direct_action();
  ::autofill_assistant::DirectActionProto* mutable_direct_action();
  void set_allocated_direct_action(::autofill_assistant::DirectActionProto* direct_action);
  private:
  const ::autofill_assistant::DirectActionProto& _internal_direct_action() const;
  ::autofill_assistant::DirectActionProto* _internal_mutable_direct_action();
  public:
  void unsafe_arena_set_allocated_direct_action(
      ::autofill_assistant::DirectActionProto* direct_action);
  ::autofill_assistant::DirectActionProto* unsafe_arena_release_direct_action();

  // optional bool enabled = 4 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.UserActionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::autofill_assistant::ChipProto* chip_;
  ::autofill_assistant::DirectActionProto* direct_action_;
  bool enabled_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class DateProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DateProto) */ {
 public:
  inline DateProto() : DateProto(nullptr) {}
  ~DateProto() override;
  explicit PROTOBUF_CONSTEXPR DateProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateProto(const DateProto& from);
  DateProto(DateProto&& from) noexcept
    : DateProto() {
    *this = ::std::move(from);
  }

  inline DateProto& operator=(const DateProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateProto& operator=(DateProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DateProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateProto* internal_default_instance() {
    return reinterpret_cast<const DateProto*>(
               &_DateProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DateProto& a, DateProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DateProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DateProto& from);
  void MergeFrom(const DateProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DateProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DateProto";
  }
  protected:
  explicit DateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 1,
    kMonthFieldNumber = 2,
    kDayFieldNumber = 3,
  };
  // optional int64 year = 1;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  int64_t year() const;
  void set_year(int64_t value);
  private:
  int64_t _internal_year() const;
  void _internal_set_year(int64_t value);
  public:

  // optional int32 month = 2;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  int32_t month() const;
  void set_month(int32_t value);
  private:
  int32_t _internal_month() const;
  void _internal_set_month(int32_t value);
  public:

  // optional int32 day = 3;
  bool has_day() const;
  private:
  bool _internal_has_day() const;
  public:
  void clear_day();
  int32_t day() const;
  void set_day(int32_t value);
  private:
  int32_t _internal_day() const;
  void _internal_set_day(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DateProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t year_;
  int32_t month_;
  int32_t day_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class TimeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TimeProto) */ {
 public:
  inline TimeProto() : TimeProto(nullptr) {}
  ~TimeProto() override;
  explicit PROTOBUF_CONSTEXPR TimeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeProto(const TimeProto& from);
  TimeProto(TimeProto&& from) noexcept
    : TimeProto() {
    *this = ::std::move(from);
  }

  inline TimeProto& operator=(const TimeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeProto& operator=(TimeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeProto* internal_default_instance() {
    return reinterpret_cast<const TimeProto*>(
               &_TimeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TimeProto& a, TimeProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TimeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimeProto& from);
  void MergeFrom(const TimeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TimeProto";
  }
  protected:
  explicit TimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHourFieldNumber = 1,
    kMinuteFieldNumber = 2,
    kSecondFieldNumber = 3,
  };
  // optional int32 hour = 1;
  bool has_hour() const;
  private:
  bool _internal_has_hour() const;
  public:
  void clear_hour();
  int32_t hour() const;
  void set_hour(int32_t value);
  private:
  int32_t _internal_hour() const;
  void _internal_set_hour(int32_t value);
  public:

  // optional int32 minute = 2;
  bool has_minute() const;
  private:
  bool _internal_has_minute() const;
  public:
  void clear_minute();
  int32_t minute() const;
  void set_minute(int32_t value);
  private:
  int32_t _internal_minute() const;
  void _internal_set_minute(int32_t value);
  public:

  // optional int32 second = 3;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  int32_t second() const;
  void set_second(int32_t value);
  private:
  int32_t _internal_second() const;
  void _internal_set_second(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TimeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t hour_;
  int32_t minute_;
  int32_t second_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class DateTimeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DateTimeProto) */ {
 public:
  inline DateTimeProto() : DateTimeProto(nullptr) {}
  ~DateTimeProto() override;
  explicit PROTOBUF_CONSTEXPR DateTimeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateTimeProto(const DateTimeProto& from);
  DateTimeProto(DateTimeProto&& from) noexcept
    : DateTimeProto() {
    *this = ::std::move(from);
  }

  inline DateTimeProto& operator=(const DateTimeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateTimeProto& operator=(DateTimeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DateTimeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateTimeProto* internal_default_instance() {
    return reinterpret_cast<const DateTimeProto*>(
               &_DateTimeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DateTimeProto& a, DateTimeProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DateTimeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateTimeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateTimeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateTimeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DateTimeProto& from);
  void MergeFrom(const DateTimeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DateTimeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DateTimeProto";
  }
  protected:
  explicit DateTimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDateFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // optional .autofill_assistant.DateProto date = 1;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::autofill_assistant::DateProto& date() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DateProto* release_date();
  ::autofill_assistant::DateProto* mutable_date();
  void set_allocated_date(::autofill_assistant::DateProto* date);
  private:
  const ::autofill_assistant::DateProto& _internal_date() const;
  ::autofill_assistant::DateProto* _internal_mutable_date();
  public:
  void unsafe_arena_set_allocated_date(
      ::autofill_assistant::DateProto* date);
  ::autofill_assistant::DateProto* unsafe_arena_release_date();

  // optional .autofill_assistant.TimeProto time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::autofill_assistant::TimeProto& time() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TimeProto* release_time();
  ::autofill_assistant::TimeProto* mutable_time();
  void set_allocated_time(::autofill_assistant::TimeProto* time);
  private:
  const ::autofill_assistant::TimeProto& _internal_time() const;
  ::autofill_assistant::TimeProto* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::autofill_assistant::TimeProto* time);
  ::autofill_assistant::TimeProto* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:autofill_assistant.DateTimeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::DateProto* date_;
  ::autofill_assistant::TimeProto* time_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class AutofillCreditCardProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillCreditCardProto) */ {
 public:
  inline AutofillCreditCardProto() : AutofillCreditCardProto(nullptr) {}
  ~AutofillCreditCardProto() override;
  explicit PROTOBUF_CONSTEXPR AutofillCreditCardProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillCreditCardProto(const AutofillCreditCardProto& from);
  AutofillCreditCardProto(AutofillCreditCardProto&& from) noexcept
    : AutofillCreditCardProto() {
    *this = ::std::move(from);
  }

  inline AutofillCreditCardProto& operator=(const AutofillCreditCardProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillCreditCardProto& operator=(AutofillCreditCardProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillCreditCardProto& default_instance() {
    return *internal_default_instance();
  }
  enum IdentifierCase {
    kGuid = 1,
    kSelectedCreditCard = 2,
    IDENTIFIER_NOT_SET = 0,
  };

  static inline const AutofillCreditCardProto* internal_default_instance() {
    return reinterpret_cast<const AutofillCreditCardProto*>(
               &_AutofillCreditCardProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AutofillCreditCardProto& a, AutofillCreditCardProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillCreditCardProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillCreditCardProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillCreditCardProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillCreditCardProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillCreditCardProto& from);
  void MergeFrom(const AutofillCreditCardProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillCreditCardProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillCreditCardProto";
  }
  protected:
  explicit AutofillCreditCardProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuidFieldNumber = 1,
    kSelectedCreditCardFieldNumber = 2,
  };
  // string guid = 1;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // .autofill_assistant.Empty selected_credit_card = 2;
  bool has_selected_credit_card() const;
  private:
  bool _internal_has_selected_credit_card() const;
  public:
  void clear_selected_credit_card();
  const ::autofill_assistant::Empty& selected_credit_card() const;
  PROTOBUF_NODISCARD ::autofill_assistant::Empty* release_selected_credit_card();
  ::autofill_assistant::Empty* mutable_selected_credit_card();
  void set_allocated_selected_credit_card(::autofill_assistant::Empty* selected_credit_card);
  private:
  const ::autofill_assistant::Empty& _internal_selected_credit_card() const;
  ::autofill_assistant::Empty* _internal_mutable_selected_credit_card();
  public:
  void unsafe_arena_set_allocated_selected_credit_card(
      ::autofill_assistant::Empty* selected_credit_card);
  ::autofill_assistant::Empty* unsafe_arena_release_selected_credit_card();

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillCreditCardProto)
 private:
  class _Internal;
  void set_has_guid();
  void set_has_selected_credit_card();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IdentifierUnion {
    constexpr IdentifierUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
    ::autofill_assistant::Empty* selected_credit_card_;
  } identifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class CreditCardResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CreditCardResponseProto) */ {
 public:
  inline CreditCardResponseProto() : CreditCardResponseProto(nullptr) {}
  ~CreditCardResponseProto() override;
  explicit PROTOBUF_CONSTEXPR CreditCardResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreditCardResponseProto(const CreditCardResponseProto& from);
  CreditCardResponseProto(CreditCardResponseProto&& from) noexcept
    : CreditCardResponseProto() {
    *this = ::std::move(from);
  }

  inline CreditCardResponseProto& operator=(const CreditCardResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreditCardResponseProto& operator=(CreditCardResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CreditCardResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreditCardResponseProto* internal_default_instance() {
    return reinterpret_cast<const CreditCardResponseProto*>(
               &_CreditCardResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreditCardResponseProto& a, CreditCardResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreditCardResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreditCardResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreditCardResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreditCardResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreditCardResponseProto& from);
  void MergeFrom(const CreditCardResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreditCardResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CreditCardResponseProto";
  }
  protected:
  explicit CreditCardResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 1,
  };
  // optional string network = 1;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CreditCardResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class AutofillProfileProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillProfileProto) */ {
 public:
  inline AutofillProfileProto() : AutofillProfileProto(nullptr) {}
  ~AutofillProfileProto() override;
  explicit PROTOBUF_CONSTEXPR AutofillProfileProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillProfileProto(const AutofillProfileProto& from);
  AutofillProfileProto(AutofillProfileProto&& from) noexcept
    : AutofillProfileProto() {
    *this = ::std::move(from);
  }

  inline AutofillProfileProto& operator=(const AutofillProfileProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillProfileProto& operator=(AutofillProfileProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillProfileProto& default_instance() {
    return *internal_default_instance();
  }
  enum IdentifierCase {
    kGuid = 1,
    kSelectedProfileName = 2,
    IDENTIFIER_NOT_SET = 0,
  };

  static inline const AutofillProfileProto* internal_default_instance() {
    return reinterpret_cast<const AutofillProfileProto*>(
               &_AutofillProfileProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AutofillProfileProto& a, AutofillProfileProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillProfileProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillProfileProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillProfileProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillProfileProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillProfileProto& from);
  void MergeFrom(const AutofillProfileProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillProfileProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillProfileProto";
  }
  protected:
  explicit AutofillProfileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuidFieldNumber = 1,
    kSelectedProfileNameFieldNumber = 2,
  };
  // string guid = 1;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // string selected_profile_name = 2;
  bool has_selected_profile_name() const;
  private:
  bool _internal_has_selected_profile_name() const;
  public:
  void clear_selected_profile_name();
  const std::string& selected_profile_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_profile_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_profile_name();
  PROTOBUF_NODISCARD std::string* release_selected_profile_name();
  void set_allocated_selected_profile_name(std::string* selected_profile_name);
  private:
  const std::string& _internal_selected_profile_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_profile_name(const std::string& value);
  std::string* _internal_mutable_selected_profile_name();
  public:

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillProfileProto)
 private:
  class _Internal;
  void set_has_guid();
  void set_has_selected_profile_name();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union IdentifierUnion {
    constexpr IdentifierUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_profile_name_;
  } identifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// -------------------------------------------------------------------

class LoginOptionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LoginOptionProto) */ {
 public:
  inline LoginOptionProto() : LoginOptionProto(nullptr) {}
  ~LoginOptionProto() override;
  explicit PROTOBUF_CONSTEXPR LoginOptionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginOptionProto(const LoginOptionProto& from);
  LoginOptionProto(LoginOptionProto&& from) noexcept
    : LoginOptionProto() {
    *this = ::std::move(from);
  }

  inline LoginOptionProto& operator=(const LoginOptionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginOptionProto& operator=(LoginOptionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginOptionProto& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadOrTagCase {
    kPayload = 3,
    kTag = 4,
    PAYLOAD_OR_TAG_NOT_SET = 0,
  };

  static inline const LoginOptionProto* internal_default_instance() {
    return reinterpret_cast<const LoginOptionProto*>(
               &_LoginOptionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LoginOptionProto& a, LoginOptionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LoginOptionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginOptionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginOptionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginOptionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginOptionProto& from);
  void MergeFrom(const LoginOptionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginOptionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LoginOptionProto";
  }
  protected:
  explicit LoginOptionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kSublabelFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kTagFieldNumber = 4,
  };
  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional string sublabel = 2;
  bool has_sublabel() const;
  private:
  bool _internal_has_sublabel() const;
  public:
  void clear_sublabel();
  const std::string& sublabel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sublabel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sublabel();
  PROTOBUF_NODISCARD std::string* release_sublabel();
  void set_allocated_sublabel(std::string* sublabel);
  private:
  const std::string& _internal_sublabel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sublabel(const std::string& value);
  std::string* _internal_mutable_sublabel();
  public:

  // bytes payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // string tag = 4;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  void clear_payload_or_tag();
  PayloadOrTagCase payload_or_tag_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.LoginOptionProto)
 private:
  class _Internal;
  void set_has_payload();
  void set_has_tag();

  inline bool has_payload_or_tag() const;
  inline void clear_has_payload_or_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sublabel_;
  union PayloadOrTagUnion {
    constexpr PayloadOrTagUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  } payload_or_tag_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelProto_ModelValue

// optional string identifier = 1;
inline bool ModelProto_ModelValue::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelProto_ModelValue::has_identifier() const {
  return _internal_has_identifier();
}
inline void ModelProto_ModelValue::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelProto_ModelValue::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ModelProto.ModelValue.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelProto_ModelValue::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ModelProto.ModelValue.identifier)
}
inline std::string* ModelProto_ModelValue::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ModelProto.ModelValue.identifier)
  return _s;
}
inline const std::string& ModelProto_ModelValue::_internal_identifier() const {
  return identifier_.Get();
}
inline void ModelProto_ModelValue::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelProto_ModelValue::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelProto_ModelValue::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ModelProto.ModelValue.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModelProto_ModelValue::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ModelProto.ModelValue.identifier)
}

// optional .autofill_assistant.ValueProto value = 2;
inline bool ModelProto_ModelValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool ModelProto_ModelValue::has_value() const {
  return _internal_has_value();
}
inline void ModelProto_ModelValue::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ValueProto& ModelProto_ModelValue::_internal_value() const {
  const ::autofill_assistant::ValueProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueProto&>(
      ::autofill_assistant::_ValueProto_default_instance_);
}
inline const ::autofill_assistant::ValueProto& ModelProto_ModelValue::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ModelProto.ModelValue.value)
  return _internal_value();
}
inline void ModelProto_ModelValue::unsafe_arena_set_allocated_value(
    ::autofill_assistant::ValueProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ModelProto.ModelValue.value)
}
inline ::autofill_assistant::ValueProto* ModelProto_ModelValue::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueProto* ModelProto_ModelValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ModelProto.ModelValue.value)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ValueProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueProto* ModelProto_ModelValue::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::ValueProto* ModelProto_ModelValue::mutable_value() {
  ::autofill_assistant::ValueProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ModelProto.ModelValue.value)
  return _msg;
}
inline void ModelProto_ModelValue::set_allocated_value(::autofill_assistant::ValueProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ModelProto.ModelValue.value)
}

// -------------------------------------------------------------------

// ModelProto

// repeated .autofill_assistant.ModelProto.ModelValue values = 1;
inline int ModelProto::_internal_values_size() const {
  return values_.size();
}
inline int ModelProto::values_size() const {
  return _internal_values_size();
}
inline void ModelProto::clear_values() {
  values_.Clear();
}
inline ::autofill_assistant::ModelProto_ModelValue* ModelProto::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ModelProto.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >*
ModelProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ModelProto.values)
  return &values_;
}
inline const ::autofill_assistant::ModelProto_ModelValue& ModelProto::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::ModelProto_ModelValue& ModelProto::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ModelProto.values)
  return _internal_values(index);
}
inline ::autofill_assistant::ModelProto_ModelValue* ModelProto::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::ModelProto_ModelValue* ModelProto::add_values() {
  ::autofill_assistant::ModelProto_ModelValue* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.ModelProto.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >&
ModelProto::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ModelProto.values)
  return values_;
}

// -------------------------------------------------------------------

// ValueProto

// .autofill_assistant.StringList strings = 1;
inline bool ValueProto::_internal_has_strings() const {
  return kind_case() == kStrings;
}
inline bool ValueProto::has_strings() const {
  return _internal_has_strings();
}
inline void ValueProto::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void ValueProto::clear_strings() {
  if (_internal_has_strings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.strings_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::StringList* ValueProto::release_strings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.strings)
  if (_internal_has_strings()) {
    clear_has_kind();
    ::autofill_assistant::StringList* temp = kind_.strings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.strings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::StringList& ValueProto::_internal_strings() const {
  return _internal_has_strings()
      ? *kind_.strings_
      : reinterpret_cast< ::autofill_assistant::StringList&>(::autofill_assistant::_StringList_default_instance_);
}
inline const ::autofill_assistant::StringList& ValueProto::strings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.strings)
  return _internal_strings();
}
inline ::autofill_assistant::StringList* ValueProto::unsafe_arena_release_strings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.strings)
  if (_internal_has_strings()) {
    clear_has_kind();
    ::autofill_assistant::StringList* temp = kind_.strings_;
    kind_.strings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_strings(::autofill_assistant::StringList* strings) {
  clear_kind();
  if (strings) {
    set_has_strings();
    kind_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.strings)
}
inline ::autofill_assistant::StringList* ValueProto::_internal_mutable_strings() {
  if (!_internal_has_strings()) {
    clear_kind();
    set_has_strings();
    kind_.strings_ = CreateMaybeMessage< ::autofill_assistant::StringList >(GetArenaForAllocation());
  }
  return kind_.strings_;
}
inline ::autofill_assistant::StringList* ValueProto::mutable_strings() {
  ::autofill_assistant::StringList* _msg = _internal_mutable_strings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.strings)
  return _msg;
}

// .autofill_assistant.BooleanList booleans = 2;
inline bool ValueProto::_internal_has_booleans() const {
  return kind_case() == kBooleans;
}
inline bool ValueProto::has_booleans() const {
  return _internal_has_booleans();
}
inline void ValueProto::set_has_booleans() {
  _oneof_case_[0] = kBooleans;
}
inline void ValueProto::clear_booleans() {
  if (_internal_has_booleans()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.booleans_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::BooleanList* ValueProto::release_booleans() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.booleans)
  if (_internal_has_booleans()) {
    clear_has_kind();
    ::autofill_assistant::BooleanList* temp = kind_.booleans_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.booleans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::BooleanList& ValueProto::_internal_booleans() const {
  return _internal_has_booleans()
      ? *kind_.booleans_
      : reinterpret_cast< ::autofill_assistant::BooleanList&>(::autofill_assistant::_BooleanList_default_instance_);
}
inline const ::autofill_assistant::BooleanList& ValueProto::booleans() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.booleans)
  return _internal_booleans();
}
inline ::autofill_assistant::BooleanList* ValueProto::unsafe_arena_release_booleans() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.booleans)
  if (_internal_has_booleans()) {
    clear_has_kind();
    ::autofill_assistant::BooleanList* temp = kind_.booleans_;
    kind_.booleans_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_booleans(::autofill_assistant::BooleanList* booleans) {
  clear_kind();
  if (booleans) {
    set_has_booleans();
    kind_.booleans_ = booleans;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.booleans)
}
inline ::autofill_assistant::BooleanList* ValueProto::_internal_mutable_booleans() {
  if (!_internal_has_booleans()) {
    clear_kind();
    set_has_booleans();
    kind_.booleans_ = CreateMaybeMessage< ::autofill_assistant::BooleanList >(GetArenaForAllocation());
  }
  return kind_.booleans_;
}
inline ::autofill_assistant::BooleanList* ValueProto::mutable_booleans() {
  ::autofill_assistant::BooleanList* _msg = _internal_mutable_booleans();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.booleans)
  return _msg;
}

// .autofill_assistant.IntList ints = 3;
inline bool ValueProto::_internal_has_ints() const {
  return kind_case() == kInts;
}
inline bool ValueProto::has_ints() const {
  return _internal_has_ints();
}
inline void ValueProto::set_has_ints() {
  _oneof_case_[0] = kInts;
}
inline void ValueProto::clear_ints() {
  if (_internal_has_ints()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.ints_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::IntList* ValueProto::release_ints() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.ints)
  if (_internal_has_ints()) {
    clear_has_kind();
    ::autofill_assistant::IntList* temp = kind_.ints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.ints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::IntList& ValueProto::_internal_ints() const {
  return _internal_has_ints()
      ? *kind_.ints_
      : reinterpret_cast< ::autofill_assistant::IntList&>(::autofill_assistant::_IntList_default_instance_);
}
inline const ::autofill_assistant::IntList& ValueProto::ints() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.ints)
  return _internal_ints();
}
inline ::autofill_assistant::IntList* ValueProto::unsafe_arena_release_ints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.ints)
  if (_internal_has_ints()) {
    clear_has_kind();
    ::autofill_assistant::IntList* temp = kind_.ints_;
    kind_.ints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_ints(::autofill_assistant::IntList* ints) {
  clear_kind();
  if (ints) {
    set_has_ints();
    kind_.ints_ = ints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.ints)
}
inline ::autofill_assistant::IntList* ValueProto::_internal_mutable_ints() {
  if (!_internal_has_ints()) {
    clear_kind();
    set_has_ints();
    kind_.ints_ = CreateMaybeMessage< ::autofill_assistant::IntList >(GetArenaForAllocation());
  }
  return kind_.ints_;
}
inline ::autofill_assistant::IntList* ValueProto::mutable_ints() {
  ::autofill_assistant::IntList* _msg = _internal_mutable_ints();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.ints)
  return _msg;
}

// .autofill_assistant.UserActionList user_actions = 4;
inline bool ValueProto::_internal_has_user_actions() const {
  return kind_case() == kUserActions;
}
inline bool ValueProto::has_user_actions() const {
  return _internal_has_user_actions();
}
inline void ValueProto::set_has_user_actions() {
  _oneof_case_[0] = kUserActions;
}
inline void ValueProto::clear_user_actions() {
  if (_internal_has_user_actions()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.user_actions_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::UserActionList* ValueProto::release_user_actions() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.user_actions)
  if (_internal_has_user_actions()) {
    clear_has_kind();
    ::autofill_assistant::UserActionList* temp = kind_.user_actions_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.user_actions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::UserActionList& ValueProto::_internal_user_actions() const {
  return _internal_has_user_actions()
      ? *kind_.user_actions_
      : reinterpret_cast< ::autofill_assistant::UserActionList&>(::autofill_assistant::_UserActionList_default_instance_);
}
inline const ::autofill_assistant::UserActionList& ValueProto::user_actions() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.user_actions)
  return _internal_user_actions();
}
inline ::autofill_assistant::UserActionList* ValueProto::unsafe_arena_release_user_actions() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.user_actions)
  if (_internal_has_user_actions()) {
    clear_has_kind();
    ::autofill_assistant::UserActionList* temp = kind_.user_actions_;
    kind_.user_actions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_user_actions(::autofill_assistant::UserActionList* user_actions) {
  clear_kind();
  if (user_actions) {
    set_has_user_actions();
    kind_.user_actions_ = user_actions;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.user_actions)
}
inline ::autofill_assistant::UserActionList* ValueProto::_internal_mutable_user_actions() {
  if (!_internal_has_user_actions()) {
    clear_kind();
    set_has_user_actions();
    kind_.user_actions_ = CreateMaybeMessage< ::autofill_assistant::UserActionList >(GetArenaForAllocation());
  }
  return kind_.user_actions_;
}
inline ::autofill_assistant::UserActionList* ValueProto::mutable_user_actions() {
  ::autofill_assistant::UserActionList* _msg = _internal_mutable_user_actions();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.user_actions)
  return _msg;
}

// .autofill_assistant.DateList dates = 5;
inline bool ValueProto::_internal_has_dates() const {
  return kind_case() == kDates;
}
inline bool ValueProto::has_dates() const {
  return _internal_has_dates();
}
inline void ValueProto::set_has_dates() {
  _oneof_case_[0] = kDates;
}
inline void ValueProto::clear_dates() {
  if (_internal_has_dates()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.dates_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::DateList* ValueProto::release_dates() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.dates)
  if (_internal_has_dates()) {
    clear_has_kind();
    ::autofill_assistant::DateList* temp = kind_.dates_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.dates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DateList& ValueProto::_internal_dates() const {
  return _internal_has_dates()
      ? *kind_.dates_
      : reinterpret_cast< ::autofill_assistant::DateList&>(::autofill_assistant::_DateList_default_instance_);
}
inline const ::autofill_assistant::DateList& ValueProto::dates() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.dates)
  return _internal_dates();
}
inline ::autofill_assistant::DateList* ValueProto::unsafe_arena_release_dates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.dates)
  if (_internal_has_dates()) {
    clear_has_kind();
    ::autofill_assistant::DateList* temp = kind_.dates_;
    kind_.dates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_dates(::autofill_assistant::DateList* dates) {
  clear_kind();
  if (dates) {
    set_has_dates();
    kind_.dates_ = dates;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.dates)
}
inline ::autofill_assistant::DateList* ValueProto::_internal_mutable_dates() {
  if (!_internal_has_dates()) {
    clear_kind();
    set_has_dates();
    kind_.dates_ = CreateMaybeMessage< ::autofill_assistant::DateList >(GetArenaForAllocation());
  }
  return kind_.dates_;
}
inline ::autofill_assistant::DateList* ValueProto::mutable_dates() {
  ::autofill_assistant::DateList* _msg = _internal_mutable_dates();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.dates)
  return _msg;
}

// .autofill_assistant.CreditCardList credit_cards = 7;
inline bool ValueProto::_internal_has_credit_cards() const {
  return kind_case() == kCreditCards;
}
inline bool ValueProto::has_credit_cards() const {
  return _internal_has_credit_cards();
}
inline void ValueProto::set_has_credit_cards() {
  _oneof_case_[0] = kCreditCards;
}
inline void ValueProto::clear_credit_cards() {
  if (_internal_has_credit_cards()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.credit_cards_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::CreditCardList* ValueProto::release_credit_cards() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.credit_cards)
  if (_internal_has_credit_cards()) {
    clear_has_kind();
    ::autofill_assistant::CreditCardList* temp = kind_.credit_cards_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.credit_cards_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CreditCardList& ValueProto::_internal_credit_cards() const {
  return _internal_has_credit_cards()
      ? *kind_.credit_cards_
      : reinterpret_cast< ::autofill_assistant::CreditCardList&>(::autofill_assistant::_CreditCardList_default_instance_);
}
inline const ::autofill_assistant::CreditCardList& ValueProto::credit_cards() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.credit_cards)
  return _internal_credit_cards();
}
inline ::autofill_assistant::CreditCardList* ValueProto::unsafe_arena_release_credit_cards() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.credit_cards)
  if (_internal_has_credit_cards()) {
    clear_has_kind();
    ::autofill_assistant::CreditCardList* temp = kind_.credit_cards_;
    kind_.credit_cards_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_credit_cards(::autofill_assistant::CreditCardList* credit_cards) {
  clear_kind();
  if (credit_cards) {
    set_has_credit_cards();
    kind_.credit_cards_ = credit_cards;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.credit_cards)
}
inline ::autofill_assistant::CreditCardList* ValueProto::_internal_mutable_credit_cards() {
  if (!_internal_has_credit_cards()) {
    clear_kind();
    set_has_credit_cards();
    kind_.credit_cards_ = CreateMaybeMessage< ::autofill_assistant::CreditCardList >(GetArenaForAllocation());
  }
  return kind_.credit_cards_;
}
inline ::autofill_assistant::CreditCardList* ValueProto::mutable_credit_cards() {
  ::autofill_assistant::CreditCardList* _msg = _internal_mutable_credit_cards();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.credit_cards)
  return _msg;
}

// .autofill_assistant.ProfileList profiles = 8;
inline bool ValueProto::_internal_has_profiles() const {
  return kind_case() == kProfiles;
}
inline bool ValueProto::has_profiles() const {
  return _internal_has_profiles();
}
inline void ValueProto::set_has_profiles() {
  _oneof_case_[0] = kProfiles;
}
inline void ValueProto::clear_profiles() {
  if (_internal_has_profiles()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.profiles_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ProfileList* ValueProto::release_profiles() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.profiles)
  if (_internal_has_profiles()) {
    clear_has_kind();
    ::autofill_assistant::ProfileList* temp = kind_.profiles_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.profiles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ProfileList& ValueProto::_internal_profiles() const {
  return _internal_has_profiles()
      ? *kind_.profiles_
      : reinterpret_cast< ::autofill_assistant::ProfileList&>(::autofill_assistant::_ProfileList_default_instance_);
}
inline const ::autofill_assistant::ProfileList& ValueProto::profiles() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.profiles)
  return _internal_profiles();
}
inline ::autofill_assistant::ProfileList* ValueProto::unsafe_arena_release_profiles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.profiles)
  if (_internal_has_profiles()) {
    clear_has_kind();
    ::autofill_assistant::ProfileList* temp = kind_.profiles_;
    kind_.profiles_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_profiles(::autofill_assistant::ProfileList* profiles) {
  clear_kind();
  if (profiles) {
    set_has_profiles();
    kind_.profiles_ = profiles;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.profiles)
}
inline ::autofill_assistant::ProfileList* ValueProto::_internal_mutable_profiles() {
  if (!_internal_has_profiles()) {
    clear_kind();
    set_has_profiles();
    kind_.profiles_ = CreateMaybeMessage< ::autofill_assistant::ProfileList >(GetArenaForAllocation());
  }
  return kind_.profiles_;
}
inline ::autofill_assistant::ProfileList* ValueProto::mutable_profiles() {
  ::autofill_assistant::ProfileList* _msg = _internal_mutable_profiles();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.profiles)
  return _msg;
}

// .autofill_assistant.LoginOptionList login_options = 9;
inline bool ValueProto::_internal_has_login_options() const {
  return kind_case() == kLoginOptions;
}
inline bool ValueProto::has_login_options() const {
  return _internal_has_login_options();
}
inline void ValueProto::set_has_login_options() {
  _oneof_case_[0] = kLoginOptions;
}
inline void ValueProto::clear_login_options() {
  if (_internal_has_login_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.login_options_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::LoginOptionList* ValueProto::release_login_options() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.login_options)
  if (_internal_has_login_options()) {
    clear_has_kind();
    ::autofill_assistant::LoginOptionList* temp = kind_.login_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.login_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::LoginOptionList& ValueProto::_internal_login_options() const {
  return _internal_has_login_options()
      ? *kind_.login_options_
      : reinterpret_cast< ::autofill_assistant::LoginOptionList&>(::autofill_assistant::_LoginOptionList_default_instance_);
}
inline const ::autofill_assistant::LoginOptionList& ValueProto::login_options() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.login_options)
  return _internal_login_options();
}
inline ::autofill_assistant::LoginOptionList* ValueProto::unsafe_arena_release_login_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.login_options)
  if (_internal_has_login_options()) {
    clear_has_kind();
    ::autofill_assistant::LoginOptionList* temp = kind_.login_options_;
    kind_.login_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_login_options(::autofill_assistant::LoginOptionList* login_options) {
  clear_kind();
  if (login_options) {
    set_has_login_options();
    kind_.login_options_ = login_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.login_options)
}
inline ::autofill_assistant::LoginOptionList* ValueProto::_internal_mutable_login_options() {
  if (!_internal_has_login_options()) {
    clear_kind();
    set_has_login_options();
    kind_.login_options_ = CreateMaybeMessage< ::autofill_assistant::LoginOptionList >(GetArenaForAllocation());
  }
  return kind_.login_options_;
}
inline ::autofill_assistant::LoginOptionList* ValueProto::mutable_login_options() {
  ::autofill_assistant::LoginOptionList* _msg = _internal_mutable_login_options();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.login_options)
  return _msg;
}

// .autofill_assistant.CreditCardResponseProto credit_card_response = 10;
inline bool ValueProto::_internal_has_credit_card_response() const {
  return kind_case() == kCreditCardResponse;
}
inline bool ValueProto::has_credit_card_response() const {
  return _internal_has_credit_card_response();
}
inline void ValueProto::set_has_credit_card_response() {
  _oneof_case_[0] = kCreditCardResponse;
}
inline void ValueProto::clear_credit_card_response() {
  if (_internal_has_credit_card_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.credit_card_response_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::CreditCardResponseProto* ValueProto::release_credit_card_response() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.credit_card_response)
  if (_internal_has_credit_card_response()) {
    clear_has_kind();
    ::autofill_assistant::CreditCardResponseProto* temp = kind_.credit_card_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.credit_card_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CreditCardResponseProto& ValueProto::_internal_credit_card_response() const {
  return _internal_has_credit_card_response()
      ? *kind_.credit_card_response_
      : reinterpret_cast< ::autofill_assistant::CreditCardResponseProto&>(::autofill_assistant::_CreditCardResponseProto_default_instance_);
}
inline const ::autofill_assistant::CreditCardResponseProto& ValueProto::credit_card_response() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.credit_card_response)
  return _internal_credit_card_response();
}
inline ::autofill_assistant::CreditCardResponseProto* ValueProto::unsafe_arena_release_credit_card_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueProto.credit_card_response)
  if (_internal_has_credit_card_response()) {
    clear_has_kind();
    ::autofill_assistant::CreditCardResponseProto* temp = kind_.credit_card_response_;
    kind_.credit_card_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueProto::unsafe_arena_set_allocated_credit_card_response(::autofill_assistant::CreditCardResponseProto* credit_card_response) {
  clear_kind();
  if (credit_card_response) {
    set_has_credit_card_response();
    kind_.credit_card_response_ = credit_card_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueProto.credit_card_response)
}
inline ::autofill_assistant::CreditCardResponseProto* ValueProto::_internal_mutable_credit_card_response() {
  if (!_internal_has_credit_card_response()) {
    clear_kind();
    set_has_credit_card_response();
    kind_.credit_card_response_ = CreateMaybeMessage< ::autofill_assistant::CreditCardResponseProto >(GetArenaForAllocation());
  }
  return kind_.credit_card_response_;
}
inline ::autofill_assistant::CreditCardResponseProto* ValueProto::mutable_credit_card_response() {
  ::autofill_assistant::CreditCardResponseProto* _msg = _internal_mutable_credit_card_response();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.credit_card_response)
  return _msg;
}

// bytes server_payload = 12;
inline bool ValueProto::_internal_has_server_payload() const {
  return kind_case() == kServerPayload;
}
inline bool ValueProto::has_server_payload() const {
  return _internal_has_server_payload();
}
inline void ValueProto::set_has_server_payload() {
  _oneof_case_[0] = kServerPayload;
}
inline void ValueProto::clear_server_payload() {
  if (_internal_has_server_payload()) {
    kind_.server_payload_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& ValueProto::server_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.server_payload)
  return _internal_server_payload();
}
template <typename ArgT0, typename... ArgT>
inline void ValueProto::set_server_payload(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_server_payload()) {
    clear_kind();
    set_has_server_payload();
    kind_.server_payload_.InitDefault();
  }
  kind_.server_payload_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueProto.server_payload)
}
inline std::string* ValueProto::mutable_server_payload() {
  std::string* _s = _internal_mutable_server_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueProto.server_payload)
  return _s;
}
inline const std::string& ValueProto::_internal_server_payload() const {
  if (_internal_has_server_payload()) {
    return kind_.server_payload_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValueProto::_internal_set_server_payload(const std::string& value) {
  if (!_internal_has_server_payload()) {
    clear_kind();
    set_has_server_payload();
    kind_.server_payload_.InitDefault();
  }
  kind_.server_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueProto::_internal_mutable_server_payload() {
  if (!_internal_has_server_payload()) {
    clear_kind();
    set_has_server_payload();
    kind_.server_payload_.InitDefault();
  }
  return kind_.server_payload_.Mutable(      GetArenaForAllocation());
}
inline std::string* ValueProto::release_server_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueProto.server_payload)
  if (_internal_has_server_payload()) {
    clear_has_kind();
    return kind_.server_payload_.Release();
  } else {
    return nullptr;
  }
}
inline void ValueProto::set_allocated_server_payload(std::string* server_payload) {
  if (has_kind()) {
    clear_kind();
  }
  if (server_payload != nullptr) {
    set_has_server_payload();
    kind_.server_payload_.InitAllocated(server_payload, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.server_payload)
}

// optional bool is_client_side_only = 6;
inline bool ValueProto::_internal_has_is_client_side_only() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ValueProto::has_is_client_side_only() const {
  return _internal_has_is_client_side_only();
}
inline void ValueProto::clear_is_client_side_only() {
  is_client_side_only_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ValueProto::_internal_is_client_side_only() const {
  return is_client_side_only_;
}
inline bool ValueProto::is_client_side_only() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueProto.is_client_side_only)
  return _internal_is_client_side_only();
}
inline void ValueProto::_internal_set_is_client_side_only(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_client_side_only_ = value;
}
inline void ValueProto::set_is_client_side_only(bool value) {
  _internal_set_is_client_side_only(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueProto.is_client_side_only)
}

inline bool ValueProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ValueProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline ValueProto::KindCase ValueProto::kind_case() const {
  return ValueProto::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValueReferenceProto

// .autofill_assistant.ValueProto value = 1;
inline bool ValueReferenceProto::_internal_has_value() const {
  return kind_case() == kValue;
}
inline bool ValueReferenceProto::has_value() const {
  return _internal_has_value();
}
inline void ValueReferenceProto::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void ValueReferenceProto::clear_value() {
  if (_internal_has_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.value_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ValueProto* ValueReferenceProto::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueReferenceProto.value)
  if (_internal_has_value()) {
    clear_has_kind();
    ::autofill_assistant::ValueProto* temp = kind_.value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ValueProto& ValueReferenceProto::_internal_value() const {
  return _internal_has_value()
      ? *kind_.value_
      : reinterpret_cast< ::autofill_assistant::ValueProto&>(::autofill_assistant::_ValueProto_default_instance_);
}
inline const ::autofill_assistant::ValueProto& ValueReferenceProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueReferenceProto.value)
  return _internal_value();
}
inline ::autofill_assistant::ValueProto* ValueReferenceProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ValueReferenceProto.value)
  if (_internal_has_value()) {
    clear_has_kind();
    ::autofill_assistant::ValueProto* temp = kind_.value_;
    kind_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueReferenceProto::unsafe_arena_set_allocated_value(::autofill_assistant::ValueProto* value) {
  clear_kind();
  if (value) {
    set_has_value();
    kind_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueReferenceProto.value)
}
inline ::autofill_assistant::ValueProto* ValueReferenceProto::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_kind();
    set_has_value();
    kind_.value_ = CreateMaybeMessage< ::autofill_assistant::ValueProto >(GetArenaForAllocation());
  }
  return kind_.value_;
}
inline ::autofill_assistant::ValueProto* ValueReferenceProto::mutable_value() {
  ::autofill_assistant::ValueProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueReferenceProto.value)
  return _msg;
}

// string model_identifier = 2;
inline bool ValueReferenceProto::_internal_has_model_identifier() const {
  return kind_case() == kModelIdentifier;
}
inline bool ValueReferenceProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void ValueReferenceProto::set_has_model_identifier() {
  _oneof_case_[0] = kModelIdentifier;
}
inline void ValueReferenceProto::clear_model_identifier() {
  if (_internal_has_model_identifier()) {
    kind_.model_identifier_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& ValueReferenceProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueReferenceProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline void ValueReferenceProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_model_identifier()) {
    clear_kind();
    set_has_model_identifier();
    kind_.model_identifier_.InitDefault();
  }
  kind_.model_identifier_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueReferenceProto.model_identifier)
}
inline std::string* ValueReferenceProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueReferenceProto.model_identifier)
  return _s;
}
inline const std::string& ValueReferenceProto::_internal_model_identifier() const {
  if (_internal_has_model_identifier()) {
    return kind_.model_identifier_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValueReferenceProto::_internal_set_model_identifier(const std::string& value) {
  if (!_internal_has_model_identifier()) {
    clear_kind();
    set_has_model_identifier();
    kind_.model_identifier_.InitDefault();
  }
  kind_.model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueReferenceProto::_internal_mutable_model_identifier() {
  if (!_internal_has_model_identifier()) {
    clear_kind();
    set_has_model_identifier();
    kind_.model_identifier_.InitDefault();
  }
  return kind_.model_identifier_.Mutable(      GetArenaForAllocation());
}
inline std::string* ValueReferenceProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueReferenceProto.model_identifier)
  if (_internal_has_model_identifier()) {
    clear_has_kind();
    return kind_.model_identifier_.Release();
  } else {
    return nullptr;
  }
}
inline void ValueReferenceProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (has_kind()) {
    clear_kind();
  }
  if (model_identifier != nullptr) {
    set_has_model_identifier();
    kind_.model_identifier_.InitAllocated(model_identifier, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueReferenceProto.model_identifier)
}

inline bool ValueReferenceProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ValueReferenceProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline ValueReferenceProto::KindCase ValueReferenceProto::kind_case() const {
  return ValueReferenceProto::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StringList

// repeated string values = 1;
inline int StringList::_internal_values_size() const {
  return values_.size();
}
inline int StringList::values_size() const {
  return _internal_values_size();
}
inline void StringList::clear_values() {
  values_.Clear();
}
inline std::string* StringList::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.StringList.values)
  return _s;
}
inline const std::string& StringList::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& StringList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.StringList.values)
  return _internal_values(index);
}
inline std::string* StringList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.StringList.values)
  return values_.Mutable(index);
}
inline void StringList::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.StringList.values)
}
inline void StringList::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.StringList.values)
}
inline void StringList::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.StringList.values)
}
inline void StringList::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.StringList.values)
}
inline std::string* StringList::_internal_add_values() {
  return values_.Add();
}
inline void StringList::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.StringList.values)
}
inline void StringList::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.StringList.values)
}
inline void StringList::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.StringList.values)
}
inline void StringList::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.StringList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StringList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.StringList.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StringList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.StringList.values)
  return &values_;
}

// -------------------------------------------------------------------

// BooleanList

// repeated bool values = 1;
inline int BooleanList::_internal_values_size() const {
  return values_.size();
}
inline int BooleanList::values_size() const {
  return _internal_values_size();
}
inline void BooleanList::clear_values() {
  values_.Clear();
}
inline bool BooleanList::_internal_values(int index) const {
  return values_.Get(index);
}
inline bool BooleanList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BooleanList.values)
  return _internal_values(index);
}
inline void BooleanList::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.BooleanList.values)
}
inline void BooleanList::_internal_add_values(bool value) {
  values_.Add(value);
}
inline void BooleanList::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.BooleanList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BooleanList::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BooleanList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.BooleanList.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BooleanList::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BooleanList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.BooleanList.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// IntList

// repeated int32 values = 1;
inline int IntList::_internal_values_size() const {
  return values_.size();
}
inline int IntList::values_size() const {
  return _internal_values_size();
}
inline void IntList::clear_values() {
  values_.Clear();
}
inline int32_t IntList::_internal_values(int index) const {
  return values_.Get(index);
}
inline int32_t IntList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.IntList.values)
  return _internal_values(index);
}
inline void IntList::set_values(int index, int32_t value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.IntList.values)
}
inline void IntList::_internal_add_values(int32_t value) {
  values_.Add(value);
}
inline void IntList::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.IntList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntList::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.IntList.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntList::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.IntList.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// UserActionList

// repeated .autofill_assistant.UserActionProto values = 1;
inline int UserActionList::_internal_values_size() const {
  return values_.size();
}
inline int UserActionList::values_size() const {
  return _internal_values_size();
}
inline void UserActionList::clear_values() {
  values_.Clear();
}
inline ::autofill_assistant::UserActionProto* UserActionList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserActionList.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >*
UserActionList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UserActionList.values)
  return &values_;
}
inline const ::autofill_assistant::UserActionProto& UserActionList::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::UserActionProto& UserActionList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserActionList.values)
  return _internal_values(index);
}
inline ::autofill_assistant::UserActionProto* UserActionList::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::UserActionProto* UserActionList::add_values() {
  ::autofill_assistant::UserActionProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.UserActionList.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >&
UserActionList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UserActionList.values)
  return values_;
}

// -------------------------------------------------------------------

// DateList

// repeated .autofill_assistant.DateProto values = 1;
inline int DateList::_internal_values_size() const {
  return values_.size();
}
inline int DateList::values_size() const {
  return _internal_values_size();
}
inline void DateList::clear_values() {
  values_.Clear();
}
inline ::autofill_assistant::DateProto* DateList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DateList.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DateProto >*
DateList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.DateList.values)
  return &values_;
}
inline const ::autofill_assistant::DateProto& DateList::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::DateProto& DateList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateList.values)
  return _internal_values(index);
}
inline ::autofill_assistant::DateProto* DateList::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::DateProto* DateList::add_values() {
  ::autofill_assistant::DateProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.DateList.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DateProto >&
DateList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.DateList.values)
  return values_;
}

// -------------------------------------------------------------------

// CreditCardList

// repeated .autofill_assistant.AutofillCreditCardProto values = 1;
inline int CreditCardList::_internal_values_size() const {
  return values_.size();
}
inline int CreditCardList::values_size() const {
  return _internal_values_size();
}
inline void CreditCardList::clear_values() {
  values_.Clear();
}
inline ::autofill_assistant::AutofillCreditCardProto* CreditCardList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreditCardList.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillCreditCardProto >*
CreditCardList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CreditCardList.values)
  return &values_;
}
inline const ::autofill_assistant::AutofillCreditCardProto& CreditCardList::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::AutofillCreditCardProto& CreditCardList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreditCardList.values)
  return _internal_values(index);
}
inline ::autofill_assistant::AutofillCreditCardProto* CreditCardList::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::AutofillCreditCardProto* CreditCardList::add_values() {
  ::autofill_assistant::AutofillCreditCardProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.CreditCardList.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillCreditCardProto >&
CreditCardList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CreditCardList.values)
  return values_;
}

// -------------------------------------------------------------------

// ProfileList

// repeated .autofill_assistant.AutofillProfileProto values = 1;
inline int ProfileList::_internal_values_size() const {
  return values_.size();
}
inline int ProfileList::values_size() const {
  return _internal_values_size();
}
inline void ProfileList::clear_values() {
  values_.Clear();
}
inline ::autofill_assistant::AutofillProfileProto* ProfileList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProfileList.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillProfileProto >*
ProfileList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ProfileList.values)
  return &values_;
}
inline const ::autofill_assistant::AutofillProfileProto& ProfileList::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::AutofillProfileProto& ProfileList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProfileList.values)
  return _internal_values(index);
}
inline ::autofill_assistant::AutofillProfileProto* ProfileList::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::AutofillProfileProto* ProfileList::add_values() {
  ::autofill_assistant::AutofillProfileProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.ProfileList.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillProfileProto >&
ProfileList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ProfileList.values)
  return values_;
}

// -------------------------------------------------------------------

// LoginOptionList

// repeated .autofill_assistant.LoginOptionProto values = 1;
inline int LoginOptionList::_internal_values_size() const {
  return values_.size();
}
inline int LoginOptionList::values_size() const {
  return _internal_values_size();
}
inline void LoginOptionList::clear_values() {
  values_.Clear();
}
inline ::autofill_assistant::LoginOptionProto* LoginOptionList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginOptionList.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginOptionProto >*
LoginOptionList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.LoginOptionList.values)
  return &values_;
}
inline const ::autofill_assistant::LoginOptionProto& LoginOptionList::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::autofill_assistant::LoginOptionProto& LoginOptionList::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginOptionList.values)
  return _internal_values(index);
}
inline ::autofill_assistant::LoginOptionProto* LoginOptionList::_internal_add_values() {
  return values_.Add();
}
inline ::autofill_assistant::LoginOptionProto* LoginOptionList::add_values() {
  ::autofill_assistant::LoginOptionProto* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.LoginOptionList.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginOptionProto >&
LoginOptionList::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.LoginOptionList.values)
  return values_;
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ChipProto

// optional .autofill_assistant.ChipType type = 1;
inline bool ChipProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChipProto::has_type() const {
  return _internal_has_type();
}
inline void ChipProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::ChipType ChipProto::_internal_type() const {
  return static_cast< ::autofill_assistant::ChipType >(type_);
}
inline ::autofill_assistant::ChipType ChipProto::type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ChipProto.type)
  return _internal_type();
}
inline void ChipProto::_internal_set_type(::autofill_assistant::ChipType value) {
  assert(::autofill_assistant::ChipType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void ChipProto::set_type(::autofill_assistant::ChipType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ChipProto.type)
}

// optional .autofill_assistant.ChipIcon icon = 2;
inline bool ChipProto::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChipProto::has_icon() const {
  return _internal_has_icon();
}
inline void ChipProto::clear_icon() {
  icon_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::ChipIcon ChipProto::_internal_icon() const {
  return static_cast< ::autofill_assistant::ChipIcon >(icon_);
}
inline ::autofill_assistant::ChipIcon ChipProto::icon() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ChipProto.icon)
  return _internal_icon();
}
inline void ChipProto::_internal_set_icon(::autofill_assistant::ChipIcon value) {
  assert(::autofill_assistant::ChipIcon_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  icon_ = value;
}
inline void ChipProto::set_icon(::autofill_assistant::ChipIcon value) {
  _internal_set_icon(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ChipProto.icon)
}

// optional string text = 3;
inline bool ChipProto::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChipProto::has_text() const {
  return _internal_has_text();
}
inline void ChipProto::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChipProto::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ChipProto.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChipProto::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ChipProto.text)
}
inline std::string* ChipProto::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ChipProto.text)
  return _s;
}
inline const std::string& ChipProto::_internal_text() const {
  return text_.Get();
}
inline void ChipProto::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* ChipProto::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* ChipProto::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ChipProto.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChipProto::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ChipProto.text)
}

// optional bool sticky = 4;
inline bool ChipProto::_internal_has_sticky() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChipProto::has_sticky() const {
  return _internal_has_sticky();
}
inline void ChipProto::clear_sticky() {
  sticky_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ChipProto::_internal_sticky() const {
  return sticky_;
}
inline bool ChipProto::sticky() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ChipProto.sticky)
  return _internal_sticky();
}
inline void ChipProto::_internal_set_sticky(bool value) {
  _has_bits_[0] |= 0x00000010u;
  sticky_ = value;
}
inline void ChipProto::set_sticky(bool value) {
  _internal_set_sticky(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ChipProto.sticky)
}

// optional string content_description = 5;
inline bool ChipProto::_internal_has_content_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChipProto::has_content_description() const {
  return _internal_has_content_description();
}
inline void ChipProto::clear_content_description() {
  content_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChipProto::content_description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ChipProto.content_description)
  return _internal_content_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChipProto::set_content_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 content_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ChipProto.content_description)
}
inline std::string* ChipProto::mutable_content_description() {
  std::string* _s = _internal_mutable_content_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ChipProto.content_description)
  return _s;
}
inline const std::string& ChipProto::_internal_content_description() const {
  return content_description_.Get();
}
inline void ChipProto::_internal_set_content_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  content_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ChipProto::_internal_mutable_content_description() {
  _has_bits_[0] |= 0x00000002u;
  return content_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ChipProto::release_content_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ChipProto.content_description)
  if (!_internal_has_content_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = content_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_description_.IsDefault()) {
    content_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChipProto::set_allocated_content_description(std::string* content_description) {
  if (content_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  content_description_.SetAllocated(content_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_description_.IsDefault()) {
    content_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ChipProto.content_description)
}

// -------------------------------------------------------------------

// DirectActionProto

// repeated string names = 1;
inline int DirectActionProto::_internal_names_size() const {
  return names_.size();
}
inline int DirectActionProto::names_size() const {
  return _internal_names_size();
}
inline void DirectActionProto::clear_names() {
  names_.Clear();
}
inline std::string* DirectActionProto::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.DirectActionProto.names)
  return _s;
}
inline const std::string& DirectActionProto::_internal_names(int index) const {
  return names_.Get(index);
}
inline const std::string& DirectActionProto::names(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DirectActionProto.names)
  return _internal_names(index);
}
inline std::string* DirectActionProto::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DirectActionProto.names)
  return names_.Mutable(index);
}
inline void DirectActionProto::set_names(int index, const std::string& value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DirectActionProto.names)
}
inline void DirectActionProto::set_names(int index, std::string&& value) {
  names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.DirectActionProto.names)
}
inline void DirectActionProto::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.DirectActionProto.names)
}
inline void DirectActionProto::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.DirectActionProto.names)
}
inline std::string* DirectActionProto::_internal_add_names() {
  return names_.Add();
}
inline void DirectActionProto::add_names(const std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.DirectActionProto.names)
}
inline void DirectActionProto::add_names(std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.DirectActionProto.names)
}
inline void DirectActionProto::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.DirectActionProto.names)
}
inline void DirectActionProto::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.DirectActionProto.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DirectActionProto::names() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.DirectActionProto.names)
  return names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DirectActionProto::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.DirectActionProto.names)
  return &names_;
}

// repeated string required_arguments = 2;
inline int DirectActionProto::_internal_required_arguments_size() const {
  return required_arguments_.size();
}
inline int DirectActionProto::required_arguments_size() const {
  return _internal_required_arguments_size();
}
inline void DirectActionProto::clear_required_arguments() {
  required_arguments_.Clear();
}
inline std::string* DirectActionProto::add_required_arguments() {
  std::string* _s = _internal_add_required_arguments();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.DirectActionProto.required_arguments)
  return _s;
}
inline const std::string& DirectActionProto::_internal_required_arguments(int index) const {
  return required_arguments_.Get(index);
}
inline const std::string& DirectActionProto::required_arguments(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DirectActionProto.required_arguments)
  return _internal_required_arguments(index);
}
inline std::string* DirectActionProto::mutable_required_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DirectActionProto.required_arguments)
  return required_arguments_.Mutable(index);
}
inline void DirectActionProto::set_required_arguments(int index, const std::string& value) {
  required_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DirectActionProto.required_arguments)
}
inline void DirectActionProto::set_required_arguments(int index, std::string&& value) {
  required_arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.DirectActionProto.required_arguments)
}
inline void DirectActionProto::set_required_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.DirectActionProto.required_arguments)
}
inline void DirectActionProto::set_required_arguments(int index, const char* value, size_t size) {
  required_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.DirectActionProto.required_arguments)
}
inline std::string* DirectActionProto::_internal_add_required_arguments() {
  return required_arguments_.Add();
}
inline void DirectActionProto::add_required_arguments(const std::string& value) {
  required_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.DirectActionProto.required_arguments)
}
inline void DirectActionProto::add_required_arguments(std::string&& value) {
  required_arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.DirectActionProto.required_arguments)
}
inline void DirectActionProto::add_required_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.DirectActionProto.required_arguments)
}
inline void DirectActionProto::add_required_arguments(const char* value, size_t size) {
  required_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.DirectActionProto.required_arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DirectActionProto::required_arguments() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.DirectActionProto.required_arguments)
  return required_arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DirectActionProto::mutable_required_arguments() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.DirectActionProto.required_arguments)
  return &required_arguments_;
}

// repeated string optional_arguments = 3;
inline int DirectActionProto::_internal_optional_arguments_size() const {
  return optional_arguments_.size();
}
inline int DirectActionProto::optional_arguments_size() const {
  return _internal_optional_arguments_size();
}
inline void DirectActionProto::clear_optional_arguments() {
  optional_arguments_.Clear();
}
inline std::string* DirectActionProto::add_optional_arguments() {
  std::string* _s = _internal_add_optional_arguments();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.DirectActionProto.optional_arguments)
  return _s;
}
inline const std::string& DirectActionProto::_internal_optional_arguments(int index) const {
  return optional_arguments_.Get(index);
}
inline const std::string& DirectActionProto::optional_arguments(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DirectActionProto.optional_arguments)
  return _internal_optional_arguments(index);
}
inline std::string* DirectActionProto::mutable_optional_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DirectActionProto.optional_arguments)
  return optional_arguments_.Mutable(index);
}
inline void DirectActionProto::set_optional_arguments(int index, const std::string& value) {
  optional_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DirectActionProto.optional_arguments)
}
inline void DirectActionProto::set_optional_arguments(int index, std::string&& value) {
  optional_arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.DirectActionProto.optional_arguments)
}
inline void DirectActionProto::set_optional_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  optional_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.DirectActionProto.optional_arguments)
}
inline void DirectActionProto::set_optional_arguments(int index, const char* value, size_t size) {
  optional_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.DirectActionProto.optional_arguments)
}
inline std::string* DirectActionProto::_internal_add_optional_arguments() {
  return optional_arguments_.Add();
}
inline void DirectActionProto::add_optional_arguments(const std::string& value) {
  optional_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.DirectActionProto.optional_arguments)
}
inline void DirectActionProto::add_optional_arguments(std::string&& value) {
  optional_arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.DirectActionProto.optional_arguments)
}
inline void DirectActionProto::add_optional_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  optional_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.DirectActionProto.optional_arguments)
}
inline void DirectActionProto::add_optional_arguments(const char* value, size_t size) {
  optional_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.DirectActionProto.optional_arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DirectActionProto::optional_arguments() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.DirectActionProto.optional_arguments)
  return optional_arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DirectActionProto::mutable_optional_arguments() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.DirectActionProto.optional_arguments)
  return &optional_arguments_;
}

// -------------------------------------------------------------------

// UserActionProto

// optional .autofill_assistant.ChipProto chip = 1;
inline bool UserActionProto::_internal_has_chip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || chip_ != nullptr);
  return value;
}
inline bool UserActionProto::has_chip() const {
  return _internal_has_chip();
}
inline void UserActionProto::clear_chip() {
  if (chip_ != nullptr) chip_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ChipProto& UserActionProto::_internal_chip() const {
  const ::autofill_assistant::ChipProto* p = chip_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ChipProto&>(
      ::autofill_assistant::_ChipProto_default_instance_);
}
inline const ::autofill_assistant::ChipProto& UserActionProto::chip() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserActionProto.chip)
  return _internal_chip();
}
inline void UserActionProto::unsafe_arena_set_allocated_chip(
    ::autofill_assistant::ChipProto* chip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  chip_ = chip;
  if (chip) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UserActionProto.chip)
}
inline ::autofill_assistant::ChipProto* UserActionProto::release_chip() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ChipProto* UserActionProto::unsafe_arena_release_chip() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserActionProto.chip)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ChipProto* UserActionProto::_internal_mutable_chip() {
  _has_bits_[0] |= 0x00000002u;
  if (chip_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ChipProto>(GetArenaForAllocation());
    chip_ = p;
  }
  return chip_;
}
inline ::autofill_assistant::ChipProto* UserActionProto::mutable_chip() {
  ::autofill_assistant::ChipProto* _msg = _internal_mutable_chip();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserActionProto.chip)
  return _msg;
}
inline void UserActionProto::set_allocated_chip(::autofill_assistant::ChipProto* chip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chip_;
  }
  if (chip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chip);
    if (message_arena != submessage_arena) {
      chip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  chip_ = chip;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserActionProto.chip)
}

// optional .autofill_assistant.DirectActionProto direct_action = 2;
inline bool UserActionProto::_internal_has_direct_action() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || direct_action_ != nullptr);
  return value;
}
inline bool UserActionProto::has_direct_action() const {
  return _internal_has_direct_action();
}
inline void UserActionProto::clear_direct_action() {
  if (direct_action_ != nullptr) direct_action_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::DirectActionProto& UserActionProto::_internal_direct_action() const {
  const ::autofill_assistant::DirectActionProto* p = direct_action_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DirectActionProto&>(
      ::autofill_assistant::_DirectActionProto_default_instance_);
}
inline const ::autofill_assistant::DirectActionProto& UserActionProto::direct_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserActionProto.direct_action)
  return _internal_direct_action();
}
inline void UserActionProto::unsafe_arena_set_allocated_direct_action(
    ::autofill_assistant::DirectActionProto* direct_action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direct_action_);
  }
  direct_action_ = direct_action;
  if (direct_action) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UserActionProto.direct_action)
}
inline ::autofill_assistant::DirectActionProto* UserActionProto::release_direct_action() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::DirectActionProto* temp = direct_action_;
  direct_action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DirectActionProto* UserActionProto::unsafe_arena_release_direct_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserActionProto.direct_action)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::DirectActionProto* temp = direct_action_;
  direct_action_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DirectActionProto* UserActionProto::_internal_mutable_direct_action() {
  _has_bits_[0] |= 0x00000004u;
  if (direct_action_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DirectActionProto>(GetArenaForAllocation());
    direct_action_ = p;
  }
  return direct_action_;
}
inline ::autofill_assistant::DirectActionProto* UserActionProto::mutable_direct_action() {
  ::autofill_assistant::DirectActionProto* _msg = _internal_mutable_direct_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserActionProto.direct_action)
  return _msg;
}
inline void UserActionProto::set_allocated_direct_action(::autofill_assistant::DirectActionProto* direct_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direct_action_;
  }
  if (direct_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(direct_action);
    if (message_arena != submessage_arena) {
      direct_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direct_action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  direct_action_ = direct_action;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserActionProto.direct_action)
}

// optional string identifier = 3;
inline bool UserActionProto::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserActionProto::has_identifier() const {
  return _internal_has_identifier();
}
inline void UserActionProto::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserActionProto::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserActionProto.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserActionProto::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UserActionProto.identifier)
}
inline std::string* UserActionProto::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserActionProto.identifier)
  return _s;
}
inline const std::string& UserActionProto::_internal_identifier() const {
  return identifier_.Get();
}
inline void UserActionProto::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* UserActionProto::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* UserActionProto::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserActionProto.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserActionProto::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserActionProto.identifier)
}

// optional bool enabled = 4 [default = true];
inline bool UserActionProto::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserActionProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void UserActionProto::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool UserActionProto::_internal_enabled() const {
  return enabled_;
}
inline bool UserActionProto::enabled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserActionProto.enabled)
  return _internal_enabled();
}
inline void UserActionProto::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enabled_ = value;
}
inline void UserActionProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UserActionProto.enabled)
}

// -------------------------------------------------------------------

// DateProto

// optional int64 year = 1;
inline bool DateProto::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DateProto::has_year() const {
  return _internal_has_year();
}
inline void DateProto::clear_year() {
  year_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t DateProto::_internal_year() const {
  return year_;
}
inline int64_t DateProto::year() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateProto.year)
  return _internal_year();
}
inline void DateProto::_internal_set_year(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  year_ = value;
}
inline void DateProto::set_year(int64_t value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DateProto.year)
}

// optional int32 month = 2;
inline bool DateProto::_internal_has_month() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DateProto::has_month() const {
  return _internal_has_month();
}
inline void DateProto::clear_month() {
  month_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t DateProto::_internal_month() const {
  return month_;
}
inline int32_t DateProto::month() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateProto.month)
  return _internal_month();
}
inline void DateProto::_internal_set_month(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  month_ = value;
}
inline void DateProto::set_month(int32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DateProto.month)
}

// optional int32 day = 3;
inline bool DateProto::_internal_has_day() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DateProto::has_day() const {
  return _internal_has_day();
}
inline void DateProto::clear_day() {
  day_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t DateProto::_internal_day() const {
  return day_;
}
inline int32_t DateProto::day() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateProto.day)
  return _internal_day();
}
inline void DateProto::_internal_set_day(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  day_ = value;
}
inline void DateProto::set_day(int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DateProto.day)
}

// -------------------------------------------------------------------

// TimeProto

// optional int32 hour = 1;
inline bool TimeProto::_internal_has_hour() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimeProto::has_hour() const {
  return _internal_has_hour();
}
inline void TimeProto::clear_hour() {
  hour_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t TimeProto::_internal_hour() const {
  return hour_;
}
inline int32_t TimeProto::hour() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TimeProto.hour)
  return _internal_hour();
}
inline void TimeProto::_internal_set_hour(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  hour_ = value;
}
inline void TimeProto::set_hour(int32_t value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TimeProto.hour)
}

// optional int32 minute = 2;
inline bool TimeProto::_internal_has_minute() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimeProto::has_minute() const {
  return _internal_has_minute();
}
inline void TimeProto::clear_minute() {
  minute_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t TimeProto::_internal_minute() const {
  return minute_;
}
inline int32_t TimeProto::minute() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TimeProto.minute)
  return _internal_minute();
}
inline void TimeProto::_internal_set_minute(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  minute_ = value;
}
inline void TimeProto::set_minute(int32_t value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TimeProto.minute)
}

// optional int32 second = 3;
inline bool TimeProto::_internal_has_second() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TimeProto::has_second() const {
  return _internal_has_second();
}
inline void TimeProto::clear_second() {
  second_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t TimeProto::_internal_second() const {
  return second_;
}
inline int32_t TimeProto::second() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TimeProto.second)
  return _internal_second();
}
inline void TimeProto::_internal_set_second(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  second_ = value;
}
inline void TimeProto::set_second(int32_t value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TimeProto.second)
}

// -------------------------------------------------------------------

// DateTimeProto

// optional .autofill_assistant.DateProto date = 1;
inline bool DateTimeProto::_internal_has_date() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || date_ != nullptr);
  return value;
}
inline bool DateTimeProto::has_date() const {
  return _internal_has_date();
}
inline void DateTimeProto::clear_date() {
  if (date_ != nullptr) date_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::DateProto& DateTimeProto::_internal_date() const {
  const ::autofill_assistant::DateProto* p = date_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DateProto&>(
      ::autofill_assistant::_DateProto_default_instance_);
}
inline const ::autofill_assistant::DateProto& DateTimeProto::date() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateTimeProto.date)
  return _internal_date();
}
inline void DateTimeProto::unsafe_arena_set_allocated_date(
    ::autofill_assistant::DateProto* date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_);
  }
  date_ = date;
  if (date) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DateTimeProto.date)
}
inline ::autofill_assistant::DateProto* DateTimeProto::release_date() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::DateProto* temp = date_;
  date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DateProto* DateTimeProto::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DateTimeProto.date)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::DateProto* temp = date_;
  date_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DateProto* DateTimeProto::_internal_mutable_date() {
  _has_bits_[0] |= 0x00000001u;
  if (date_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DateProto>(GetArenaForAllocation());
    date_ = p;
  }
  return date_;
}
inline ::autofill_assistant::DateProto* DateTimeProto::mutable_date() {
  ::autofill_assistant::DateProto* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DateTimeProto.date)
  return _msg;
}
inline void DateTimeProto::set_allocated_date(::autofill_assistant::DateProto* date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete date_;
  }
  if (date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(date);
    if (message_arena != submessage_arena) {
      date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  date_ = date;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DateTimeProto.date)
}

// optional .autofill_assistant.TimeProto time = 2;
inline bool DateTimeProto::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool DateTimeProto::has_time() const {
  return _internal_has_time();
}
inline void DateTimeProto::clear_time() {
  if (time_ != nullptr) time_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::TimeProto& DateTimeProto::_internal_time() const {
  const ::autofill_assistant::TimeProto* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TimeProto&>(
      ::autofill_assistant::_TimeProto_default_instance_);
}
inline const ::autofill_assistant::TimeProto& DateTimeProto::time() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DateTimeProto.time)
  return _internal_time();
}
inline void DateTimeProto::unsafe_arena_set_allocated_time(
    ::autofill_assistant::TimeProto* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DateTimeProto.time)
}
inline ::autofill_assistant::TimeProto* DateTimeProto::release_time() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TimeProto* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TimeProto* DateTimeProto::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DateTimeProto.time)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TimeProto* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TimeProto* DateTimeProto::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000002u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TimeProto>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::autofill_assistant::TimeProto* DateTimeProto::mutable_time() {
  ::autofill_assistant::TimeProto* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DateTimeProto.time)
  return _msg;
}
inline void DateTimeProto::set_allocated_time(::autofill_assistant::TimeProto* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete time_;
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(time);
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DateTimeProto.time)
}

// -------------------------------------------------------------------

// AutofillCreditCardProto

// string guid = 1;
inline bool AutofillCreditCardProto::_internal_has_guid() const {
  return identifier_case() == kGuid;
}
inline bool AutofillCreditCardProto::has_guid() const {
  return _internal_has_guid();
}
inline void AutofillCreditCardProto::set_has_guid() {
  _oneof_case_[0] = kGuid;
}
inline void AutofillCreditCardProto::clear_guid() {
  if (_internal_has_guid()) {
    identifier_.guid_.Destroy();
    clear_has_identifier();
  }
}
inline const std::string& AutofillCreditCardProto::guid() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillCreditCardProto.guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline void AutofillCreditCardProto::set_guid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_.InitDefault();
  }
  identifier_.guid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillCreditCardProto.guid)
}
inline std::string* AutofillCreditCardProto::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillCreditCardProto.guid)
  return _s;
}
inline const std::string& AutofillCreditCardProto::_internal_guid() const {
  if (_internal_has_guid()) {
    return identifier_.guid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AutofillCreditCardProto::_internal_set_guid(const std::string& value) {
  if (!_internal_has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_.InitDefault();
  }
  identifier_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillCreditCardProto::_internal_mutable_guid() {
  if (!_internal_has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_.InitDefault();
  }
  return identifier_.guid_.Mutable(      GetArenaForAllocation());
}
inline std::string* AutofillCreditCardProto::release_guid() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillCreditCardProto.guid)
  if (_internal_has_guid()) {
    clear_has_identifier();
    return identifier_.guid_.Release();
  } else {
    return nullptr;
  }
}
inline void AutofillCreditCardProto::set_allocated_guid(std::string* guid) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (guid != nullptr) {
    set_has_guid();
    identifier_.guid_.InitAllocated(guid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillCreditCardProto.guid)
}

// .autofill_assistant.Empty selected_credit_card = 2;
inline bool AutofillCreditCardProto::_internal_has_selected_credit_card() const {
  return identifier_case() == kSelectedCreditCard;
}
inline bool AutofillCreditCardProto::has_selected_credit_card() const {
  return _internal_has_selected_credit_card();
}
inline void AutofillCreditCardProto::set_has_selected_credit_card() {
  _oneof_case_[0] = kSelectedCreditCard;
}
inline void AutofillCreditCardProto::clear_selected_credit_card() {
  if (_internal_has_selected_credit_card()) {
    if (GetArenaForAllocation() == nullptr) {
      delete identifier_.selected_credit_card_;
    }
    clear_has_identifier();
  }
}
inline ::autofill_assistant::Empty* AutofillCreditCardProto::release_selected_credit_card() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillCreditCardProto.selected_credit_card)
  if (_internal_has_selected_credit_card()) {
    clear_has_identifier();
    ::autofill_assistant::Empty* temp = identifier_.selected_credit_card_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    identifier_.selected_credit_card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::Empty& AutofillCreditCardProto::_internal_selected_credit_card() const {
  return _internal_has_selected_credit_card()
      ? *identifier_.selected_credit_card_
      : reinterpret_cast< ::autofill_assistant::Empty&>(::autofill_assistant::_Empty_default_instance_);
}
inline const ::autofill_assistant::Empty& AutofillCreditCardProto::selected_credit_card() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillCreditCardProto.selected_credit_card)
  return _internal_selected_credit_card();
}
inline ::autofill_assistant::Empty* AutofillCreditCardProto::unsafe_arena_release_selected_credit_card() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.AutofillCreditCardProto.selected_credit_card)
  if (_internal_has_selected_credit_card()) {
    clear_has_identifier();
    ::autofill_assistant::Empty* temp = identifier_.selected_credit_card_;
    identifier_.selected_credit_card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutofillCreditCardProto::unsafe_arena_set_allocated_selected_credit_card(::autofill_assistant::Empty* selected_credit_card) {
  clear_identifier();
  if (selected_credit_card) {
    set_has_selected_credit_card();
    identifier_.selected_credit_card_ = selected_credit_card;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillCreditCardProto.selected_credit_card)
}
inline ::autofill_assistant::Empty* AutofillCreditCardProto::_internal_mutable_selected_credit_card() {
  if (!_internal_has_selected_credit_card()) {
    clear_identifier();
    set_has_selected_credit_card();
    identifier_.selected_credit_card_ = CreateMaybeMessage< ::autofill_assistant::Empty >(GetArenaForAllocation());
  }
  return identifier_.selected_credit_card_;
}
inline ::autofill_assistant::Empty* AutofillCreditCardProto::mutable_selected_credit_card() {
  ::autofill_assistant::Empty* _msg = _internal_mutable_selected_credit_card();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillCreditCardProto.selected_credit_card)
  return _msg;
}

inline bool AutofillCreditCardProto::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void AutofillCreditCardProto::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline AutofillCreditCardProto::IdentifierCase AutofillCreditCardProto::identifier_case() const {
  return AutofillCreditCardProto::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreditCardResponseProto

// optional string network = 1;
inline bool CreditCardResponseProto::_internal_has_network() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreditCardResponseProto::has_network() const {
  return _internal_has_network();
}
inline void CreditCardResponseProto::clear_network() {
  network_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreditCardResponseProto::network() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CreditCardResponseProto.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreditCardResponseProto::set_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CreditCardResponseProto.network)
}
inline std::string* CreditCardResponseProto::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CreditCardResponseProto.network)
  return _s;
}
inline const std::string& CreditCardResponseProto::_internal_network() const {
  return network_.Get();
}
inline void CreditCardResponseProto::_internal_set_network(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  network_.Set(value, GetArenaForAllocation());
}
inline std::string* CreditCardResponseProto::_internal_mutable_network() {
  _has_bits_[0] |= 0x00000001u;
  return network_.Mutable(GetArenaForAllocation());
}
inline std::string* CreditCardResponseProto::release_network() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CreditCardResponseProto.network)
  if (!_internal_has_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = network_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault()) {
    network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreditCardResponseProto::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault()) {
    network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CreditCardResponseProto.network)
}

// -------------------------------------------------------------------

// AutofillProfileProto

// string guid = 1;
inline bool AutofillProfileProto::_internal_has_guid() const {
  return identifier_case() == kGuid;
}
inline bool AutofillProfileProto::has_guid() const {
  return _internal_has_guid();
}
inline void AutofillProfileProto::set_has_guid() {
  _oneof_case_[0] = kGuid;
}
inline void AutofillProfileProto::clear_guid() {
  if (_internal_has_guid()) {
    identifier_.guid_.Destroy();
    clear_has_identifier();
  }
}
inline const std::string& AutofillProfileProto::guid() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillProfileProto.guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline void AutofillProfileProto::set_guid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_.InitDefault();
  }
  identifier_.guid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillProfileProto.guid)
}
inline std::string* AutofillProfileProto::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillProfileProto.guid)
  return _s;
}
inline const std::string& AutofillProfileProto::_internal_guid() const {
  if (_internal_has_guid()) {
    return identifier_.guid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AutofillProfileProto::_internal_set_guid(const std::string& value) {
  if (!_internal_has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_.InitDefault();
  }
  identifier_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillProfileProto::_internal_mutable_guid() {
  if (!_internal_has_guid()) {
    clear_identifier();
    set_has_guid();
    identifier_.guid_.InitDefault();
  }
  return identifier_.guid_.Mutable(      GetArenaForAllocation());
}
inline std::string* AutofillProfileProto::release_guid() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillProfileProto.guid)
  if (_internal_has_guid()) {
    clear_has_identifier();
    return identifier_.guid_.Release();
  } else {
    return nullptr;
  }
}
inline void AutofillProfileProto::set_allocated_guid(std::string* guid) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (guid != nullptr) {
    set_has_guid();
    identifier_.guid_.InitAllocated(guid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillProfileProto.guid)
}

// string selected_profile_name = 2;
inline bool AutofillProfileProto::_internal_has_selected_profile_name() const {
  return identifier_case() == kSelectedProfileName;
}
inline bool AutofillProfileProto::has_selected_profile_name() const {
  return _internal_has_selected_profile_name();
}
inline void AutofillProfileProto::set_has_selected_profile_name() {
  _oneof_case_[0] = kSelectedProfileName;
}
inline void AutofillProfileProto::clear_selected_profile_name() {
  if (_internal_has_selected_profile_name()) {
    identifier_.selected_profile_name_.Destroy();
    clear_has_identifier();
  }
}
inline const std::string& AutofillProfileProto::selected_profile_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillProfileProto.selected_profile_name)
  return _internal_selected_profile_name();
}
template <typename ArgT0, typename... ArgT>
inline void AutofillProfileProto::set_selected_profile_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_selected_profile_name()) {
    clear_identifier();
    set_has_selected_profile_name();
    identifier_.selected_profile_name_.InitDefault();
  }
  identifier_.selected_profile_name_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillProfileProto.selected_profile_name)
}
inline std::string* AutofillProfileProto::mutable_selected_profile_name() {
  std::string* _s = _internal_mutable_selected_profile_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillProfileProto.selected_profile_name)
  return _s;
}
inline const std::string& AutofillProfileProto::_internal_selected_profile_name() const {
  if (_internal_has_selected_profile_name()) {
    return identifier_.selected_profile_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AutofillProfileProto::_internal_set_selected_profile_name(const std::string& value) {
  if (!_internal_has_selected_profile_name()) {
    clear_identifier();
    set_has_selected_profile_name();
    identifier_.selected_profile_name_.InitDefault();
  }
  identifier_.selected_profile_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillProfileProto::_internal_mutable_selected_profile_name() {
  if (!_internal_has_selected_profile_name()) {
    clear_identifier();
    set_has_selected_profile_name();
    identifier_.selected_profile_name_.InitDefault();
  }
  return identifier_.selected_profile_name_.Mutable(      GetArenaForAllocation());
}
inline std::string* AutofillProfileProto::release_selected_profile_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillProfileProto.selected_profile_name)
  if (_internal_has_selected_profile_name()) {
    clear_has_identifier();
    return identifier_.selected_profile_name_.Release();
  } else {
    return nullptr;
  }
}
inline void AutofillProfileProto::set_allocated_selected_profile_name(std::string* selected_profile_name) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (selected_profile_name != nullptr) {
    set_has_selected_profile_name();
    identifier_.selected_profile_name_.InitAllocated(selected_profile_name, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillProfileProto.selected_profile_name)
}

inline bool AutofillProfileProto::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void AutofillProfileProto::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline AutofillProfileProto::IdentifierCase AutofillProfileProto::identifier_case() const {
  return AutofillProfileProto::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginOptionProto

// optional string label = 1;
inline bool LoginOptionProto::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginOptionProto::has_label() const {
  return _internal_has_label();
}
inline void LoginOptionProto::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginOptionProto::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginOptionProto.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginOptionProto::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginOptionProto.label)
}
inline std::string* LoginOptionProto::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginOptionProto.label)
  return _s;
}
inline const std::string& LoginOptionProto::_internal_label() const {
  return label_.Get();
}
inline void LoginOptionProto::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginOptionProto::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginOptionProto::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginOptionProto.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginOptionProto::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginOptionProto.label)
}

// optional string sublabel = 2;
inline bool LoginOptionProto::_internal_has_sublabel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginOptionProto::has_sublabel() const {
  return _internal_has_sublabel();
}
inline void LoginOptionProto::clear_sublabel() {
  sublabel_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginOptionProto::sublabel() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginOptionProto.sublabel)
  return _internal_sublabel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginOptionProto::set_sublabel(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sublabel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginOptionProto.sublabel)
}
inline std::string* LoginOptionProto::mutable_sublabel() {
  std::string* _s = _internal_mutable_sublabel();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginOptionProto.sublabel)
  return _s;
}
inline const std::string& LoginOptionProto::_internal_sublabel() const {
  return sublabel_.Get();
}
inline void LoginOptionProto::_internal_set_sublabel(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sublabel_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginOptionProto::_internal_mutable_sublabel() {
  _has_bits_[0] |= 0x00000002u;
  return sublabel_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginOptionProto::release_sublabel() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginOptionProto.sublabel)
  if (!_internal_has_sublabel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sublabel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sublabel_.IsDefault()) {
    sublabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginOptionProto::set_allocated_sublabel(std::string* sublabel) {
  if (sublabel != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sublabel_.SetAllocated(sublabel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sublabel_.IsDefault()) {
    sublabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginOptionProto.sublabel)
}

// bytes payload = 3;
inline bool LoginOptionProto::_internal_has_payload() const {
  return payload_or_tag_case() == kPayload;
}
inline bool LoginOptionProto::has_payload() const {
  return _internal_has_payload();
}
inline void LoginOptionProto::set_has_payload() {
  _oneof_case_[0] = kPayload;
}
inline void LoginOptionProto::clear_payload() {
  if (_internal_has_payload()) {
    payload_or_tag_.payload_.Destroy();
    clear_has_payload_or_tag();
  }
}
inline const std::string& LoginOptionProto::payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginOptionProto.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline void LoginOptionProto::set_payload(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_payload()) {
    clear_payload_or_tag();
    set_has_payload();
    payload_or_tag_.payload_.InitDefault();
  }
  payload_or_tag_.payload_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginOptionProto.payload)
}
inline std::string* LoginOptionProto::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginOptionProto.payload)
  return _s;
}
inline const std::string& LoginOptionProto::_internal_payload() const {
  if (_internal_has_payload()) {
    return payload_or_tag_.payload_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoginOptionProto::_internal_set_payload(const std::string& value) {
  if (!_internal_has_payload()) {
    clear_payload_or_tag();
    set_has_payload();
    payload_or_tag_.payload_.InitDefault();
  }
  payload_or_tag_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginOptionProto::_internal_mutable_payload() {
  if (!_internal_has_payload()) {
    clear_payload_or_tag();
    set_has_payload();
    payload_or_tag_.payload_.InitDefault();
  }
  return payload_or_tag_.payload_.Mutable(      GetArenaForAllocation());
}
inline std::string* LoginOptionProto::release_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginOptionProto.payload)
  if (_internal_has_payload()) {
    clear_has_payload_or_tag();
    return payload_or_tag_.payload_.Release();
  } else {
    return nullptr;
  }
}
inline void LoginOptionProto::set_allocated_payload(std::string* payload) {
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (payload != nullptr) {
    set_has_payload();
    payload_or_tag_.payload_.InitAllocated(payload, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginOptionProto.payload)
}

// string tag = 4;
inline bool LoginOptionProto::_internal_has_tag() const {
  return payload_or_tag_case() == kTag;
}
inline bool LoginOptionProto::has_tag() const {
  return _internal_has_tag();
}
inline void LoginOptionProto::set_has_tag() {
  _oneof_case_[0] = kTag;
}
inline void LoginOptionProto::clear_tag() {
  if (_internal_has_tag()) {
    payload_or_tag_.tag_.Destroy();
    clear_has_payload_or_tag();
  }
}
inline const std::string& LoginOptionProto::tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginOptionProto.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline void LoginOptionProto::set_tag(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tag()) {
    clear_payload_or_tag();
    set_has_tag();
    payload_or_tag_.tag_.InitDefault();
  }
  payload_or_tag_.tag_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginOptionProto.tag)
}
inline std::string* LoginOptionProto::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginOptionProto.tag)
  return _s;
}
inline const std::string& LoginOptionProto::_internal_tag() const {
  if (_internal_has_tag()) {
    return payload_or_tag_.tag_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoginOptionProto::_internal_set_tag(const std::string& value) {
  if (!_internal_has_tag()) {
    clear_payload_or_tag();
    set_has_tag();
    payload_or_tag_.tag_.InitDefault();
  }
  payload_or_tag_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginOptionProto::_internal_mutable_tag() {
  if (!_internal_has_tag()) {
    clear_payload_or_tag();
    set_has_tag();
    payload_or_tag_.tag_.InitDefault();
  }
  return payload_or_tag_.tag_.Mutable(      GetArenaForAllocation());
}
inline std::string* LoginOptionProto::release_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginOptionProto.tag)
  if (_internal_has_tag()) {
    clear_has_payload_or_tag();
    return payload_or_tag_.tag_.Release();
  } else {
    return nullptr;
  }
}
inline void LoginOptionProto::set_allocated_tag(std::string* tag) {
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (tag != nullptr) {
    set_has_tag();
    payload_or_tag_.tag_.InitAllocated(tag, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginOptionProto.tag)
}

inline bool LoginOptionProto::has_payload_or_tag() const {
  return payload_or_tag_case() != PAYLOAD_OR_TAG_NOT_SET;
}
inline void LoginOptionProto::clear_has_payload_or_tag() {
  _oneof_case_[0] = PAYLOAD_OR_TAG_NOT_SET;
}
inline LoginOptionProto::PayloadOrTagCase LoginOptionProto::payload_or_tag_case() const {
  return LoginOptionProto::PayloadOrTagCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill_assistant

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill_assistant::ProcessedActionStatusProto> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ChipType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ChipIcon> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fmodel_2eproto
