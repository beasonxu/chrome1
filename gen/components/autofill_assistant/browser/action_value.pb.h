// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/action_value.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
class AutofillProfile;
struct AutofillProfileDefaultTypeInternal;
extern AutofillProfileDefaultTypeInternal _AutofillProfile_default_instance_;
class AutofillValue;
struct AutofillValueDefaultTypeInternal;
extern AutofillValueDefaultTypeInternal _AutofillValue_default_instance_;
class AutofillValueRegexp;
struct AutofillValueRegexpDefaultTypeInternal;
extern AutofillValueRegexpDefaultTypeInternal _AutofillValueRegexp_default_instance_;
class KeyEvent;
struct KeyEventDefaultTypeInternal;
extern KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
class PasswordManagerValue;
struct PasswordManagerValueDefaultTypeInternal;
extern PasswordManagerValueDefaultTypeInternal _PasswordManagerValue_default_instance_;
class TextFilter;
struct TextFilterDefaultTypeInternal;
extern TextFilterDefaultTypeInternal _TextFilter_default_instance_;
class TextValue;
struct TextValueDefaultTypeInternal;
extern TextValueDefaultTypeInternal _TextValue_default_instance_;
class ValueExpression;
struct ValueExpressionDefaultTypeInternal;
extern ValueExpressionDefaultTypeInternal _ValueExpression_default_instance_;
class ValueExpressionRegexp;
struct ValueExpressionRegexpDefaultTypeInternal;
extern ValueExpressionRegexpDefaultTypeInternal _ValueExpressionRegexp_default_instance_;
class ValueExpression_Chunk;
struct ValueExpression_ChunkDefaultTypeInternal;
extern ValueExpression_ChunkDefaultTypeInternal _ValueExpression_Chunk_default_instance_;
class ValueExpression_Chunk_ReplacementsEntry_DoNotUse;
struct ValueExpression_Chunk_ReplacementsEntry_DoNotUseDefaultTypeInternal;
extern ValueExpression_Chunk_ReplacementsEntry_DoNotUseDefaultTypeInternal _ValueExpression_Chunk_ReplacementsEntry_DoNotUse_default_instance_;
class ValueExpression_RegexpReplacement;
struct ValueExpression_RegexpReplacementDefaultTypeInternal;
extern ValueExpression_RegexpReplacementDefaultTypeInternal _ValueExpression_RegexpReplacement_default_instance_;
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::AutofillProfile* Arena::CreateMaybeMessage<::autofill_assistant::AutofillProfile>(Arena*);
template<> ::autofill_assistant::AutofillValue* Arena::CreateMaybeMessage<::autofill_assistant::AutofillValue>(Arena*);
template<> ::autofill_assistant::AutofillValueRegexp* Arena::CreateMaybeMessage<::autofill_assistant::AutofillValueRegexp>(Arena*);
template<> ::autofill_assistant::KeyEvent* Arena::CreateMaybeMessage<::autofill_assistant::KeyEvent>(Arena*);
template<> ::autofill_assistant::PasswordManagerValue* Arena::CreateMaybeMessage<::autofill_assistant::PasswordManagerValue>(Arena*);
template<> ::autofill_assistant::TextFilter* Arena::CreateMaybeMessage<::autofill_assistant::TextFilter>(Arena*);
template<> ::autofill_assistant::TextValue* Arena::CreateMaybeMessage<::autofill_assistant::TextValue>(Arena*);
template<> ::autofill_assistant::ValueExpression* Arena::CreateMaybeMessage<::autofill_assistant::ValueExpression>(Arena*);
template<> ::autofill_assistant::ValueExpressionRegexp* Arena::CreateMaybeMessage<::autofill_assistant::ValueExpressionRegexp>(Arena*);
template<> ::autofill_assistant::ValueExpression_Chunk* Arena::CreateMaybeMessage<::autofill_assistant::ValueExpression_Chunk>(Arena*);
template<> ::autofill_assistant::ValueExpression_Chunk_ReplacementsEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::ValueExpression_Chunk_ReplacementsEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::ValueExpression_RegexpReplacement* Arena::CreateMaybeMessage<::autofill_assistant::ValueExpression_RegexpReplacement>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {

enum PasswordManagerValue_CredentialType : int {
  PasswordManagerValue_CredentialType_NOT_SET = 0,
  PasswordManagerValue_CredentialType_PASSWORD = 1,
  PasswordManagerValue_CredentialType_USERNAME = 2
};
bool PasswordManagerValue_CredentialType_IsValid(int value);
constexpr PasswordManagerValue_CredentialType PasswordManagerValue_CredentialType_CredentialType_MIN = PasswordManagerValue_CredentialType_NOT_SET;
constexpr PasswordManagerValue_CredentialType PasswordManagerValue_CredentialType_CredentialType_MAX = PasswordManagerValue_CredentialType_USERNAME;
constexpr int PasswordManagerValue_CredentialType_CredentialType_ARRAYSIZE = PasswordManagerValue_CredentialType_CredentialType_MAX + 1;

const std::string& PasswordManagerValue_CredentialType_Name(PasswordManagerValue_CredentialType value);
template<typename T>
inline const std::string& PasswordManagerValue_CredentialType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PasswordManagerValue_CredentialType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PasswordManagerValue_CredentialType_Name.");
  return PasswordManagerValue_CredentialType_Name(static_cast<PasswordManagerValue_CredentialType>(enum_t_value));
}
bool PasswordManagerValue_CredentialType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PasswordManagerValue_CredentialType* value);
// ===================================================================

class AutofillProfile final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillProfile) */ {
 public:
  inline AutofillProfile() : AutofillProfile(nullptr) {}
  ~AutofillProfile() override;
  explicit PROTOBUF_CONSTEXPR AutofillProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillProfile(const AutofillProfile& from);
  AutofillProfile(AutofillProfile&& from) noexcept
    : AutofillProfile() {
    *this = ::std::move(from);
  }

  inline AutofillProfile& operator=(const AutofillProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillProfile& operator=(AutofillProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillProfile* internal_default_instance() {
    return reinterpret_cast<const AutofillProfile*>(
               &_AutofillProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AutofillProfile& a, AutofillProfile& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillProfile>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillProfile& from);
  void MergeFrom(const AutofillProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillProfile";
  }
  protected:
  explicit AutofillProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class ValueExpression_RegexpReplacement final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueExpression.RegexpReplacement) */ {
 public:
  inline ValueExpression_RegexpReplacement() : ValueExpression_RegexpReplacement(nullptr) {}
  ~ValueExpression_RegexpReplacement() override;
  explicit PROTOBUF_CONSTEXPR ValueExpression_RegexpReplacement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueExpression_RegexpReplacement(const ValueExpression_RegexpReplacement& from);
  ValueExpression_RegexpReplacement(ValueExpression_RegexpReplacement&& from) noexcept
    : ValueExpression_RegexpReplacement() {
    *this = ::std::move(from);
  }

  inline ValueExpression_RegexpReplacement& operator=(const ValueExpression_RegexpReplacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueExpression_RegexpReplacement& operator=(ValueExpression_RegexpReplacement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueExpression_RegexpReplacement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueExpression_RegexpReplacement* internal_default_instance() {
    return reinterpret_cast<const ValueExpression_RegexpReplacement*>(
               &_ValueExpression_RegexpReplacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ValueExpression_RegexpReplacement& a, ValueExpression_RegexpReplacement& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueExpression_RegexpReplacement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueExpression_RegexpReplacement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueExpression_RegexpReplacement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueExpression_RegexpReplacement>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueExpression_RegexpReplacement& from);
  void MergeFrom(const ValueExpression_RegexpReplacement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueExpression_RegexpReplacement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueExpression.RegexpReplacement";
  }
  protected:
  explicit ValueExpression_RegexpReplacement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplacementFieldNumber = 2,
    kTextFilterFieldNumber = 1,
    kGlobalFieldNumber = 3,
  };
  // optional string replacement = 2;
  bool has_replacement() const;
  private:
  bool _internal_has_replacement() const;
  public:
  void clear_replacement();
  const std::string& replacement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_replacement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_replacement();
  PROTOBUF_NODISCARD std::string* release_replacement();
  void set_allocated_replacement(std::string* replacement);
  private:
  const std::string& _internal_replacement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replacement(const std::string& value);
  std::string* _internal_mutable_replacement();
  public:

  // optional .autofill_assistant.TextFilter text_filter = 1;
  bool has_text_filter() const;
  private:
  bool _internal_has_text_filter() const;
  public:
  void clear_text_filter();
  const ::autofill_assistant::TextFilter& text_filter() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_text_filter();
  ::autofill_assistant::TextFilter* mutable_text_filter();
  void set_allocated_text_filter(::autofill_assistant::TextFilter* text_filter);
  private:
  const ::autofill_assistant::TextFilter& _internal_text_filter() const;
  ::autofill_assistant::TextFilter* _internal_mutable_text_filter();
  public:
  void unsafe_arena_set_allocated_text_filter(
      ::autofill_assistant::TextFilter* text_filter);
  ::autofill_assistant::TextFilter* unsafe_arena_release_text_filter();

  // optional bool global = 3;
  bool has_global() const;
  private:
  bool _internal_has_global() const;
  public:
  void clear_global();
  bool global() const;
  void set_global(bool value);
  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueExpression.RegexpReplacement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replacement_;
  ::autofill_assistant::TextFilter* text_filter_;
  bool global_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class ValueExpression_Chunk_ReplacementsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ValueExpression_Chunk_ReplacementsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ValueExpression_Chunk_ReplacementsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ValueExpression_Chunk_ReplacementsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ValueExpression_Chunk_ReplacementsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ValueExpression_Chunk_ReplacementsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValueExpression_Chunk_ReplacementsEntry_DoNotUse& other);
  static const ValueExpression_Chunk_ReplacementsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValueExpression_Chunk_ReplacementsEntry_DoNotUse*>(&_ValueExpression_Chunk_ReplacementsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};

// -------------------------------------------------------------------

class ValueExpression_Chunk final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueExpression.Chunk) */ {
 public:
  inline ValueExpression_Chunk() : ValueExpression_Chunk(nullptr) {}
  ~ValueExpression_Chunk() override;
  explicit PROTOBUF_CONSTEXPR ValueExpression_Chunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueExpression_Chunk(const ValueExpression_Chunk& from);
  ValueExpression_Chunk(ValueExpression_Chunk&& from) noexcept
    : ValueExpression_Chunk() {
    *this = ::std::move(from);
  }

  inline ValueExpression_Chunk& operator=(const ValueExpression_Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueExpression_Chunk& operator=(ValueExpression_Chunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueExpression_Chunk& default_instance() {
    return *internal_default_instance();
  }
  enum ChunkCase {
    kKey = 1,
    kText = 2,
    kMemoryKey = 4,
    CHUNK_NOT_SET = 0,
  };

  static inline const ValueExpression_Chunk* internal_default_instance() {
    return reinterpret_cast<const ValueExpression_Chunk*>(
               &_ValueExpression_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ValueExpression_Chunk& a, ValueExpression_Chunk& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueExpression_Chunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueExpression_Chunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueExpression_Chunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueExpression_Chunk>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueExpression_Chunk& from);
  void MergeFrom(const ValueExpression_Chunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueExpression_Chunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueExpression.Chunk";
  }
  protected:
  explicit ValueExpression_Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kReplacementsFieldNumber = 3,
    kRegexpReplacementsFieldNumber = 5,
    kKeyFieldNumber = 1,
    kTextFieldNumber = 2,
    kMemoryKeyFieldNumber = 4,
  };
  // map<string, string> replacements = 3;
  int replacements_size() const;
  private:
  int _internal_replacements_size() const;
  public:
  void clear_replacements();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_replacements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_replacements();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      replacements() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_replacements();

  // repeated .autofill_assistant.ValueExpression.RegexpReplacement regexp_replacements = 5;
  int regexp_replacements_size() const;
  private:
  int _internal_regexp_replacements_size() const;
  public:
  void clear_regexp_replacements();
  ::autofill_assistant::ValueExpression_RegexpReplacement* mutable_regexp_replacements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_RegexpReplacement >*
      mutable_regexp_replacements();
  private:
  const ::autofill_assistant::ValueExpression_RegexpReplacement& _internal_regexp_replacements(int index) const;
  ::autofill_assistant::ValueExpression_RegexpReplacement* _internal_add_regexp_replacements();
  public:
  const ::autofill_assistant::ValueExpression_RegexpReplacement& regexp_replacements(int index) const;
  ::autofill_assistant::ValueExpression_RegexpReplacement* add_regexp_replacements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_RegexpReplacement >&
      regexp_replacements() const;

  // int32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string memory_key = 4;
  bool has_memory_key() const;
  private:
  bool _internal_has_memory_key() const;
  public:
  void clear_memory_key();
  const std::string& memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_key();
  PROTOBUF_NODISCARD std::string* release_memory_key();
  void set_allocated_memory_key(std::string* memory_key);
  private:
  const std::string& _internal_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_key(const std::string& value);
  std::string* _internal_mutable_memory_key();
  public:

  void clear_chunk();
  ChunkCase chunk_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueExpression.Chunk)
 private:
  class _Internal;
  void set_has_key();
  void set_has_text();
  void set_has_memory_key();

  inline bool has_chunk() const;
  inline void clear_has_chunk();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ValueExpression_Chunk_ReplacementsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> replacements_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_RegexpReplacement > regexp_replacements_;
  union ChunkUnion {
    constexpr ChunkUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_key_;
  } chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class ValueExpression final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueExpression) */ {
 public:
  inline ValueExpression() : ValueExpression(nullptr) {}
  ~ValueExpression() override;
  explicit PROTOBUF_CONSTEXPR ValueExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueExpression(const ValueExpression& from);
  ValueExpression(ValueExpression&& from) noexcept
    : ValueExpression() {
    *this = ::std::move(from);
  }

  inline ValueExpression& operator=(const ValueExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueExpression& operator=(ValueExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueExpression* internal_default_instance() {
    return reinterpret_cast<const ValueExpression*>(
               &_ValueExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ValueExpression& a, ValueExpression& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueExpression>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueExpression& from);
  void MergeFrom(const ValueExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueExpression* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueExpression";
  }
  protected:
  explicit ValueExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ValueExpression_RegexpReplacement RegexpReplacement;
  typedef ValueExpression_Chunk Chunk;

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // repeated .autofill_assistant.ValueExpression.Chunk chunk = 1;
  int chunk_size() const;
  private:
  int _internal_chunk_size() const;
  public:
  void clear_chunk();
  ::autofill_assistant::ValueExpression_Chunk* mutable_chunk(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_Chunk >*
      mutable_chunk();
  private:
  const ::autofill_assistant::ValueExpression_Chunk& _internal_chunk(int index) const;
  ::autofill_assistant::ValueExpression_Chunk* _internal_add_chunk();
  public:
  const ::autofill_assistant::ValueExpression_Chunk& chunk(int index) const;
  ::autofill_assistant::ValueExpression_Chunk* add_chunk();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_Chunk >&
      chunk() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_Chunk > chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class ValueExpressionRegexp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ValueExpressionRegexp) */ {
 public:
  inline ValueExpressionRegexp() : ValueExpressionRegexp(nullptr) {}
  ~ValueExpressionRegexp() override;
  explicit PROTOBUF_CONSTEXPR ValueExpressionRegexp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueExpressionRegexp(const ValueExpressionRegexp& from);
  ValueExpressionRegexp(ValueExpressionRegexp&& from) noexcept
    : ValueExpressionRegexp() {
    *this = ::std::move(from);
  }

  inline ValueExpressionRegexp& operator=(const ValueExpressionRegexp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueExpressionRegexp& operator=(ValueExpressionRegexp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ValueExpressionRegexp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueExpressionRegexp* internal_default_instance() {
    return reinterpret_cast<const ValueExpressionRegexp*>(
               &_ValueExpressionRegexp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ValueExpressionRegexp& a, ValueExpressionRegexp& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ValueExpressionRegexp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueExpressionRegexp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueExpressionRegexp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueExpressionRegexp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ValueExpressionRegexp& from);
  void MergeFrom(const ValueExpressionRegexp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ValueExpressionRegexp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ValueExpressionRegexp";
  }
  protected:
  explicit ValueExpressionRegexp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueExpressionFieldNumber = 1,
    kCaseSensitiveFieldNumber = 4,
  };
  // optional .autofill_assistant.ValueExpression value_expression = 1;
  bool has_value_expression() const;
  private:
  bool _internal_has_value_expression() const;
  public:
  void clear_value_expression();
  const ::autofill_assistant::ValueExpression& value_expression() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueExpression* release_value_expression();
  ::autofill_assistant::ValueExpression* mutable_value_expression();
  void set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression);
  private:
  const ::autofill_assistant::ValueExpression& _internal_value_expression() const;
  ::autofill_assistant::ValueExpression* _internal_mutable_value_expression();
  public:
  void unsafe_arena_set_allocated_value_expression(
      ::autofill_assistant::ValueExpression* value_expression);
  ::autofill_assistant::ValueExpression* unsafe_arena_release_value_expression();

  // optional bool case_sensitive = 4;
  bool has_case_sensitive() const;
  private:
  bool _internal_has_case_sensitive() const;
  public:
  void clear_case_sensitive();
  bool case_sensitive() const;
  void set_case_sensitive(bool value);
  private:
  bool _internal_case_sensitive() const;
  void _internal_set_case_sensitive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ValueExpressionRegexp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ValueExpression* value_expression_;
  bool case_sensitive_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class AutofillValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillValue) */ {
 public:
  inline AutofillValue() : AutofillValue(nullptr) {}
  ~AutofillValue() override;
  explicit PROTOBUF_CONSTEXPR AutofillValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillValue(const AutofillValue& from);
  AutofillValue(AutofillValue&& from) noexcept
    : AutofillValue() {
    *this = ::std::move(from);
  }

  inline AutofillValue& operator=(const AutofillValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillValue& operator=(AutofillValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillValue* internal_default_instance() {
    return reinterpret_cast<const AutofillValue*>(
               &_AutofillValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AutofillValue& a, AutofillValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillValue& from);
  void MergeFrom(const AutofillValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillValue";
  }
  protected:
  explicit AutofillValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 6,
    kProfileFieldNumber = 1,
    kValueExpressionFieldNumber = 5,
  };
  // optional string locale = 6;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional .autofill_assistant.AutofillProfile profile = 1;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::autofill_assistant::AutofillProfile& profile() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillProfile* release_profile();
  ::autofill_assistant::AutofillProfile* mutable_profile();
  void set_allocated_profile(::autofill_assistant::AutofillProfile* profile);
  private:
  const ::autofill_assistant::AutofillProfile& _internal_profile() const;
  ::autofill_assistant::AutofillProfile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::autofill_assistant::AutofillProfile* profile);
  ::autofill_assistant::AutofillProfile* unsafe_arena_release_profile();

  // optional .autofill_assistant.ValueExpression value_expression = 5;
  bool has_value_expression() const;
  private:
  bool _internal_has_value_expression() const;
  public:
  void clear_value_expression();
  const ::autofill_assistant::ValueExpression& value_expression() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueExpression* release_value_expression();
  ::autofill_assistant::ValueExpression* mutable_value_expression();
  void set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression);
  private:
  const ::autofill_assistant::ValueExpression& _internal_value_expression() const;
  ::autofill_assistant::ValueExpression* _internal_mutable_value_expression();
  public:
  void unsafe_arena_set_allocated_value_expression(
      ::autofill_assistant::ValueExpression* value_expression);
  ::autofill_assistant::ValueExpression* unsafe_arena_release_value_expression();

  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::autofill_assistant::AutofillProfile* profile_;
  ::autofill_assistant::ValueExpression* value_expression_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class AutofillValueRegexp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillValueRegexp) */ {
 public:
  inline AutofillValueRegexp() : AutofillValueRegexp(nullptr) {}
  ~AutofillValueRegexp() override;
  explicit PROTOBUF_CONSTEXPR AutofillValueRegexp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillValueRegexp(const AutofillValueRegexp& from);
  AutofillValueRegexp(AutofillValueRegexp&& from) noexcept
    : AutofillValueRegexp() {
    *this = ::std::move(from);
  }

  inline AutofillValueRegexp& operator=(const AutofillValueRegexp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillValueRegexp& operator=(AutofillValueRegexp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillValueRegexp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillValueRegexp* internal_default_instance() {
    return reinterpret_cast<const AutofillValueRegexp*>(
               &_AutofillValueRegexp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AutofillValueRegexp& a, AutofillValueRegexp& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillValueRegexp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillValueRegexp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillValueRegexp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillValueRegexp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillValueRegexp& from);
  void MergeFrom(const AutofillValueRegexp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillValueRegexp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillValueRegexp";
  }
  protected:
  explicit AutofillValueRegexp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 4,
    kProfileFieldNumber = 1,
    kValueExpressionRe2FieldNumber = 3,
  };
  // optional string locale = 4;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional .autofill_assistant.AutofillProfile profile = 1;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::autofill_assistant::AutofillProfile& profile() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillProfile* release_profile();
  ::autofill_assistant::AutofillProfile* mutable_profile();
  void set_allocated_profile(::autofill_assistant::AutofillProfile* profile);
  private:
  const ::autofill_assistant::AutofillProfile& _internal_profile() const;
  ::autofill_assistant::AutofillProfile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::autofill_assistant::AutofillProfile* profile);
  ::autofill_assistant::AutofillProfile* unsafe_arena_release_profile();

  // optional .autofill_assistant.ValueExpressionRegexp value_expression_re2 = 3;
  bool has_value_expression_re2() const;
  private:
  bool _internal_has_value_expression_re2() const;
  public:
  void clear_value_expression_re2();
  const ::autofill_assistant::ValueExpressionRegexp& value_expression_re2() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueExpressionRegexp* release_value_expression_re2();
  ::autofill_assistant::ValueExpressionRegexp* mutable_value_expression_re2();
  void set_allocated_value_expression_re2(::autofill_assistant::ValueExpressionRegexp* value_expression_re2);
  private:
  const ::autofill_assistant::ValueExpressionRegexp& _internal_value_expression_re2() const;
  ::autofill_assistant::ValueExpressionRegexp* _internal_mutable_value_expression_re2();
  public:
  void unsafe_arena_set_allocated_value_expression_re2(
      ::autofill_assistant::ValueExpressionRegexp* value_expression_re2);
  ::autofill_assistant::ValueExpressionRegexp* unsafe_arena_release_value_expression_re2();

  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillValueRegexp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::autofill_assistant::AutofillProfile* profile_;
  ::autofill_assistant::ValueExpressionRegexp* value_expression_re2_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class TextFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TextFilter) */ {
 public:
  inline TextFilter() : TextFilter(nullptr) {}
  ~TextFilter() override;
  explicit PROTOBUF_CONSTEXPR TextFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextFilter(const TextFilter& from);
  TextFilter(TextFilter&& from) noexcept
    : TextFilter() {
    *this = ::std::move(from);
  }

  inline TextFilter& operator=(const TextFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextFilter& operator=(TextFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextFilter* internal_default_instance() {
    return reinterpret_cast<const TextFilter*>(
               &_TextFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TextFilter& a, TextFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TextFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextFilter& from);
  void MergeFrom(const TextFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TextFilter";
  }
  protected:
  explicit TextFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRe2FieldNumber = 1,
    kCaseSensitiveFieldNumber = 2,
  };
  // optional string re2 = 1;
  bool has_re2() const;
  private:
  bool _internal_has_re2() const;
  public:
  void clear_re2();
  const std::string& re2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_re2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_re2();
  PROTOBUF_NODISCARD std::string* release_re2();
  void set_allocated_re2(std::string* re2);
  private:
  const std::string& _internal_re2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_re2(const std::string& value);
  std::string* _internal_mutable_re2();
  public:

  // optional bool case_sensitive = 2;
  bool has_case_sensitive() const;
  private:
  bool _internal_has_case_sensitive() const;
  public:
  void clear_case_sensitive();
  bool case_sensitive() const;
  void set_case_sensitive(bool value);
  private:
  bool _internal_case_sensitive() const;
  void _internal_set_case_sensitive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TextFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr re2_;
  bool case_sensitive_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class PasswordManagerValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PasswordManagerValue) */ {
 public:
  inline PasswordManagerValue() : PasswordManagerValue(nullptr) {}
  ~PasswordManagerValue() override;
  explicit PROTOBUF_CONSTEXPR PasswordManagerValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasswordManagerValue(const PasswordManagerValue& from);
  PasswordManagerValue(PasswordManagerValue&& from) noexcept
    : PasswordManagerValue() {
    *this = ::std::move(from);
  }

  inline PasswordManagerValue& operator=(const PasswordManagerValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasswordManagerValue& operator=(PasswordManagerValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PasswordManagerValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasswordManagerValue* internal_default_instance() {
    return reinterpret_cast<const PasswordManagerValue*>(
               &_PasswordManagerValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PasswordManagerValue& a, PasswordManagerValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PasswordManagerValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasswordManagerValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasswordManagerValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasswordManagerValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PasswordManagerValue& from);
  void MergeFrom(const PasswordManagerValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PasswordManagerValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PasswordManagerValue";
  }
  protected:
  explicit PasswordManagerValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PasswordManagerValue_CredentialType CredentialType;
  static constexpr CredentialType NOT_SET =
    PasswordManagerValue_CredentialType_NOT_SET;
  static constexpr CredentialType PASSWORD =
    PasswordManagerValue_CredentialType_PASSWORD;
  static constexpr CredentialType USERNAME =
    PasswordManagerValue_CredentialType_USERNAME;
  static inline bool CredentialType_IsValid(int value) {
    return PasswordManagerValue_CredentialType_IsValid(value);
  }
  static constexpr CredentialType CredentialType_MIN =
    PasswordManagerValue_CredentialType_CredentialType_MIN;
  static constexpr CredentialType CredentialType_MAX =
    PasswordManagerValue_CredentialType_CredentialType_MAX;
  static constexpr int CredentialType_ARRAYSIZE =
    PasswordManagerValue_CredentialType_CredentialType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CredentialType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CredentialType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CredentialType_Name.");
    return PasswordManagerValue_CredentialType_Name(enum_t_value);
  }
  static inline bool CredentialType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CredentialType* value) {
    return PasswordManagerValue_CredentialType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCredentialTypeFieldNumber = 1,
  };
  // optional .autofill_assistant.PasswordManagerValue.CredentialType credential_type = 1;
  bool has_credential_type() const;
  private:
  bool _internal_has_credential_type() const;
  public:
  void clear_credential_type();
  ::autofill_assistant::PasswordManagerValue_CredentialType credential_type() const;
  void set_credential_type(::autofill_assistant::PasswordManagerValue_CredentialType value);
  private:
  ::autofill_assistant::PasswordManagerValue_CredentialType _internal_credential_type() const;
  void _internal_set_credential_type(::autofill_assistant::PasswordManagerValue_CredentialType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PasswordManagerValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int credential_type_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class TextValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TextValue) */ {
 public:
  inline TextValue() : TextValue(nullptr) {}
  ~TextValue() override;
  explicit PROTOBUF_CONSTEXPR TextValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextValue(const TextValue& from);
  TextValue(TextValue&& from) noexcept
    : TextValue() {
    *this = ::std::move(from);
  }

  inline TextValue& operator=(const TextValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextValue& operator=(TextValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kText = 1,
    kAutofillValue = 2,
    kPasswordManagerValue = 3,
    kClientMemoryKey = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const TextValue* internal_default_instance() {
    return reinterpret_cast<const TextValue*>(
               &_TextValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TextValue& a, TextValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TextValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextValue& from);
  void MergeFrom(const TextValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TextValue";
  }
  protected:
  explicit TextValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kAutofillValueFieldNumber = 2,
    kPasswordManagerValueFieldNumber = 3,
    kClientMemoryKeyFieldNumber = 4,
  };
  // string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .autofill_assistant.AutofillValue autofill_value = 2;
  bool has_autofill_value() const;
  private:
  bool _internal_has_autofill_value() const;
  public:
  void clear_autofill_value();
  const ::autofill_assistant::AutofillValue& autofill_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillValue* release_autofill_value();
  ::autofill_assistant::AutofillValue* mutable_autofill_value();
  void set_allocated_autofill_value(::autofill_assistant::AutofillValue* autofill_value);
  private:
  const ::autofill_assistant::AutofillValue& _internal_autofill_value() const;
  ::autofill_assistant::AutofillValue* _internal_mutable_autofill_value();
  public:
  void unsafe_arena_set_allocated_autofill_value(
      ::autofill_assistant::AutofillValue* autofill_value);
  ::autofill_assistant::AutofillValue* unsafe_arena_release_autofill_value();

  // .autofill_assistant.PasswordManagerValue password_manager_value = 3;
  bool has_password_manager_value() const;
  private:
  bool _internal_has_password_manager_value() const;
  public:
  void clear_password_manager_value();
  const ::autofill_assistant::PasswordManagerValue& password_manager_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PasswordManagerValue* release_password_manager_value();
  ::autofill_assistant::PasswordManagerValue* mutable_password_manager_value();
  void set_allocated_password_manager_value(::autofill_assistant::PasswordManagerValue* password_manager_value);
  private:
  const ::autofill_assistant::PasswordManagerValue& _internal_password_manager_value() const;
  ::autofill_assistant::PasswordManagerValue* _internal_mutable_password_manager_value();
  public:
  void unsafe_arena_set_allocated_password_manager_value(
      ::autofill_assistant::PasswordManagerValue* password_manager_value);
  ::autofill_assistant::PasswordManagerValue* unsafe_arena_release_password_manager_value();

  // string client_memory_key = 4;
  bool has_client_memory_key() const;
  private:
  bool _internal_has_client_memory_key() const;
  public:
  void clear_client_memory_key();
  const std::string& client_memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_memory_key();
  PROTOBUF_NODISCARD std::string* release_client_memory_key();
  void set_allocated_client_memory_key(std::string* client_memory_key);
  private:
  const std::string& _internal_client_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_memory_key(const std::string& value);
  std::string* _internal_mutable_client_memory_key();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.TextValue)
 private:
  class _Internal;
  void set_has_text();
  void set_has_autofill_value();
  void set_has_password_manager_value();
  void set_has_client_memory_key();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::autofill_assistant::AutofillValue* autofill_value_;
    ::autofill_assistant::PasswordManagerValue* password_manager_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_memory_key_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// -------------------------------------------------------------------

class KeyEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.KeyEvent) */ {
 public:
  inline KeyEvent() : KeyEvent(nullptr) {}
  ~KeyEvent() override;
  explicit PROTOBUF_CONSTEXPR KeyEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyEvent(const KeyEvent& from);
  KeyEvent(KeyEvent&& from) noexcept
    : KeyEvent() {
    *this = ::std::move(from);
  }

  inline KeyEvent& operator=(const KeyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyEvent& operator=(KeyEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KeyEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyEvent* internal_default_instance() {
    return reinterpret_cast<const KeyEvent*>(
               &_KeyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KeyEvent& a, KeyEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(KeyEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KeyEvent& from);
  void MergeFrom(const KeyEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.KeyEvent";
  }
  protected:
  explicit KeyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 5,
    kCodeFieldNumber = 2,
    kTextFieldNumber = 3,
    kKeyFieldNumber = 4,
    kKeyCodeFieldNumber = 6,
  };
  // repeated string command = 5;
  int command_size() const;
  private:
  int _internal_command_size() const;
  public:
  void clear_command();
  const std::string& command(int index) const;
  std::string* mutable_command(int index);
  void set_command(int index, const std::string& value);
  void set_command(int index, std::string&& value);
  void set_command(int index, const char* value);
  void set_command(int index, const char* value, size_t size);
  std::string* add_command();
  void add_command(const std::string& value);
  void add_command(std::string&& value);
  void add_command(const char* value);
  void add_command(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& command() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_command();
  private:
  const std::string& _internal_command(int index) const;
  std::string* _internal_add_command();
  public:

  // optional string code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional string text = 3;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string key = 4;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional int32 key_code = 6;
  bool has_key_code() const;
  private:
  bool _internal_has_key_code() const;
  public:
  void clear_key_code();
  int32_t key_code() const;
  void set_key_code(int32_t value);
  private:
  int32_t _internal_key_code() const;
  void _internal_set_key_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.KeyEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> command_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int32_t key_code_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AutofillProfile

// optional string identifier = 1;
inline bool AutofillProfile::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillProfile::has_identifier() const {
  return _internal_has_identifier();
}
inline void AutofillProfile::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillProfile::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillProfile.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillProfile::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillProfile.identifier)
}
inline std::string* AutofillProfile::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillProfile.identifier)
  return _s;
}
inline const std::string& AutofillProfile::_internal_identifier() const {
  return identifier_.Get();
}
inline void AutofillProfile::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillProfile::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillProfile::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillProfile.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillProfile::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillProfile.identifier)
}

// -------------------------------------------------------------------

// ValueExpression_RegexpReplacement

// optional .autofill_assistant.TextFilter text_filter = 1;
inline bool ValueExpression_RegexpReplacement::_internal_has_text_filter() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || text_filter_ != nullptr);
  return value;
}
inline bool ValueExpression_RegexpReplacement::has_text_filter() const {
  return _internal_has_text_filter();
}
inline void ValueExpression_RegexpReplacement::clear_text_filter() {
  if (text_filter_ != nullptr) text_filter_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::TextFilter& ValueExpression_RegexpReplacement::_internal_text_filter() const {
  const ::autofill_assistant::TextFilter* p = text_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TextFilter&>(
      ::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& ValueExpression_RegexpReplacement::text_filter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.RegexpReplacement.text_filter)
  return _internal_text_filter();
}
inline void ValueExpression_RegexpReplacement::unsafe_arena_set_allocated_text_filter(
    ::autofill_assistant::TextFilter* text_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_filter_);
  }
  text_filter_ = text_filter;
  if (text_filter) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueExpression.RegexpReplacement.text_filter)
}
inline ::autofill_assistant::TextFilter* ValueExpression_RegexpReplacement::release_text_filter() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextFilter* temp = text_filter_;
  text_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TextFilter* ValueExpression_RegexpReplacement::unsafe_arena_release_text_filter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueExpression.RegexpReplacement.text_filter)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextFilter* temp = text_filter_;
  text_filter_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TextFilter* ValueExpression_RegexpReplacement::_internal_mutable_text_filter() {
  _has_bits_[0] |= 0x00000002u;
  if (text_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TextFilter>(GetArenaForAllocation());
    text_filter_ = p;
  }
  return text_filter_;
}
inline ::autofill_assistant::TextFilter* ValueExpression_RegexpReplacement::mutable_text_filter() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_text_filter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpression.RegexpReplacement.text_filter)
  return _msg;
}
inline void ValueExpression_RegexpReplacement::set_allocated_text_filter(::autofill_assistant::TextFilter* text_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_filter_;
  }
  if (text_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_filter);
    if (message_arena != submessage_arena) {
      text_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_filter_ = text_filter;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueExpression.RegexpReplacement.text_filter)
}

// optional string replacement = 2;
inline bool ValueExpression_RegexpReplacement::_internal_has_replacement() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ValueExpression_RegexpReplacement::has_replacement() const {
  return _internal_has_replacement();
}
inline void ValueExpression_RegexpReplacement::clear_replacement() {
  replacement_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ValueExpression_RegexpReplacement::replacement() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.RegexpReplacement.replacement)
  return _internal_replacement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValueExpression_RegexpReplacement::set_replacement(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 replacement_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueExpression.RegexpReplacement.replacement)
}
inline std::string* ValueExpression_RegexpReplacement::mutable_replacement() {
  std::string* _s = _internal_mutable_replacement();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpression.RegexpReplacement.replacement)
  return _s;
}
inline const std::string& ValueExpression_RegexpReplacement::_internal_replacement() const {
  return replacement_.Get();
}
inline void ValueExpression_RegexpReplacement::_internal_set_replacement(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  replacement_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueExpression_RegexpReplacement::_internal_mutable_replacement() {
  _has_bits_[0] |= 0x00000001u;
  return replacement_.Mutable(GetArenaForAllocation());
}
inline std::string* ValueExpression_RegexpReplacement::release_replacement() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueExpression.RegexpReplacement.replacement)
  if (!_internal_has_replacement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = replacement_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (replacement_.IsDefault()) {
    replacement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ValueExpression_RegexpReplacement::set_allocated_replacement(std::string* replacement) {
  if (replacement != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  replacement_.SetAllocated(replacement, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (replacement_.IsDefault()) {
    replacement_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueExpression.RegexpReplacement.replacement)
}

// optional bool global = 3;
inline bool ValueExpression_RegexpReplacement::_internal_has_global() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ValueExpression_RegexpReplacement::has_global() const {
  return _internal_has_global();
}
inline void ValueExpression_RegexpReplacement::clear_global() {
  global_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ValueExpression_RegexpReplacement::_internal_global() const {
  return global_;
}
inline bool ValueExpression_RegexpReplacement::global() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.RegexpReplacement.global)
  return _internal_global();
}
inline void ValueExpression_RegexpReplacement::_internal_set_global(bool value) {
  _has_bits_[0] |= 0x00000004u;
  global_ = value;
}
inline void ValueExpression_RegexpReplacement::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueExpression.RegexpReplacement.global)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ValueExpression_Chunk

// int32 key = 1;
inline bool ValueExpression_Chunk::_internal_has_key() const {
  return chunk_case() == kKey;
}
inline bool ValueExpression_Chunk::has_key() const {
  return _internal_has_key();
}
inline void ValueExpression_Chunk::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void ValueExpression_Chunk::clear_key() {
  if (_internal_has_key()) {
    chunk_.key_ = 0;
    clear_has_chunk();
  }
}
inline int32_t ValueExpression_Chunk::_internal_key() const {
  if (_internal_has_key()) {
    return chunk_.key_;
  }
  return 0;
}
inline void ValueExpression_Chunk::_internal_set_key(int32_t value) {
  if (!_internal_has_key()) {
    clear_chunk();
    set_has_key();
  }
  chunk_.key_ = value;
}
inline int32_t ValueExpression_Chunk::key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.Chunk.key)
  return _internal_key();
}
inline void ValueExpression_Chunk::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueExpression.Chunk.key)
}

// string text = 2;
inline bool ValueExpression_Chunk::_internal_has_text() const {
  return chunk_case() == kText;
}
inline bool ValueExpression_Chunk::has_text() const {
  return _internal_has_text();
}
inline void ValueExpression_Chunk::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void ValueExpression_Chunk::clear_text() {
  if (_internal_has_text()) {
    chunk_.text_.Destroy();
    clear_has_chunk();
  }
}
inline const std::string& ValueExpression_Chunk::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.Chunk.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void ValueExpression_Chunk::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_chunk();
    set_has_text();
    chunk_.text_.InitDefault();
  }
  chunk_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueExpression.Chunk.text)
}
inline std::string* ValueExpression_Chunk::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpression.Chunk.text)
  return _s;
}
inline const std::string& ValueExpression_Chunk::_internal_text() const {
  if (_internal_has_text()) {
    return chunk_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValueExpression_Chunk::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_chunk();
    set_has_text();
    chunk_.text_.InitDefault();
  }
  chunk_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueExpression_Chunk::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_chunk();
    set_has_text();
    chunk_.text_.InitDefault();
  }
  return chunk_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* ValueExpression_Chunk::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueExpression.Chunk.text)
  if (_internal_has_text()) {
    clear_has_chunk();
    return chunk_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void ValueExpression_Chunk::set_allocated_text(std::string* text) {
  if (has_chunk()) {
    clear_chunk();
  }
  if (text != nullptr) {
    set_has_text();
    chunk_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueExpression.Chunk.text)
}

// string memory_key = 4;
inline bool ValueExpression_Chunk::_internal_has_memory_key() const {
  return chunk_case() == kMemoryKey;
}
inline bool ValueExpression_Chunk::has_memory_key() const {
  return _internal_has_memory_key();
}
inline void ValueExpression_Chunk::set_has_memory_key() {
  _oneof_case_[0] = kMemoryKey;
}
inline void ValueExpression_Chunk::clear_memory_key() {
  if (_internal_has_memory_key()) {
    chunk_.memory_key_.Destroy();
    clear_has_chunk();
  }
}
inline const std::string& ValueExpression_Chunk::memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.Chunk.memory_key)
  return _internal_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline void ValueExpression_Chunk::set_memory_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_memory_key()) {
    clear_chunk();
    set_has_memory_key();
    chunk_.memory_key_.InitDefault();
  }
  chunk_.memory_key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueExpression.Chunk.memory_key)
}
inline std::string* ValueExpression_Chunk::mutable_memory_key() {
  std::string* _s = _internal_mutable_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpression.Chunk.memory_key)
  return _s;
}
inline const std::string& ValueExpression_Chunk::_internal_memory_key() const {
  if (_internal_has_memory_key()) {
    return chunk_.memory_key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValueExpression_Chunk::_internal_set_memory_key(const std::string& value) {
  if (!_internal_has_memory_key()) {
    clear_chunk();
    set_has_memory_key();
    chunk_.memory_key_.InitDefault();
  }
  chunk_.memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ValueExpression_Chunk::_internal_mutable_memory_key() {
  if (!_internal_has_memory_key()) {
    clear_chunk();
    set_has_memory_key();
    chunk_.memory_key_.InitDefault();
  }
  return chunk_.memory_key_.Mutable(      GetArenaForAllocation());
}
inline std::string* ValueExpression_Chunk::release_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueExpression.Chunk.memory_key)
  if (_internal_has_memory_key()) {
    clear_has_chunk();
    return chunk_.memory_key_.Release();
  } else {
    return nullptr;
  }
}
inline void ValueExpression_Chunk::set_allocated_memory_key(std::string* memory_key) {
  if (has_chunk()) {
    clear_chunk();
  }
  if (memory_key != nullptr) {
    set_has_memory_key();
    chunk_.memory_key_.InitAllocated(memory_key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueExpression.Chunk.memory_key)
}

// map<string, string> replacements = 3;
inline int ValueExpression_Chunk::_internal_replacements_size() const {
  return replacements_.size();
}
inline int ValueExpression_Chunk::replacements_size() const {
  return _internal_replacements_size();
}
inline void ValueExpression_Chunk::clear_replacements() {
  replacements_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValueExpression_Chunk::_internal_replacements() const {
  return replacements_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValueExpression_Chunk::replacements() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.ValueExpression.Chunk.replacements)
  return _internal_replacements();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValueExpression_Chunk::_internal_mutable_replacements() {
  return replacements_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValueExpression_Chunk::mutable_replacements() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.ValueExpression.Chunk.replacements)
  return _internal_mutable_replacements();
}

// repeated .autofill_assistant.ValueExpression.RegexpReplacement regexp_replacements = 5;
inline int ValueExpression_Chunk::_internal_regexp_replacements_size() const {
  return regexp_replacements_.size();
}
inline int ValueExpression_Chunk::regexp_replacements_size() const {
  return _internal_regexp_replacements_size();
}
inline void ValueExpression_Chunk::clear_regexp_replacements() {
  regexp_replacements_.Clear();
}
inline ::autofill_assistant::ValueExpression_RegexpReplacement* ValueExpression_Chunk::mutable_regexp_replacements(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpression.Chunk.regexp_replacements)
  return regexp_replacements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_RegexpReplacement >*
ValueExpression_Chunk::mutable_regexp_replacements() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ValueExpression.Chunk.regexp_replacements)
  return &regexp_replacements_;
}
inline const ::autofill_assistant::ValueExpression_RegexpReplacement& ValueExpression_Chunk::_internal_regexp_replacements(int index) const {
  return regexp_replacements_.Get(index);
}
inline const ::autofill_assistant::ValueExpression_RegexpReplacement& ValueExpression_Chunk::regexp_replacements(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.Chunk.regexp_replacements)
  return _internal_regexp_replacements(index);
}
inline ::autofill_assistant::ValueExpression_RegexpReplacement* ValueExpression_Chunk::_internal_add_regexp_replacements() {
  return regexp_replacements_.Add();
}
inline ::autofill_assistant::ValueExpression_RegexpReplacement* ValueExpression_Chunk::add_regexp_replacements() {
  ::autofill_assistant::ValueExpression_RegexpReplacement* _add = _internal_add_regexp_replacements();
  // @@protoc_insertion_point(field_add:autofill_assistant.ValueExpression.Chunk.regexp_replacements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_RegexpReplacement >&
ValueExpression_Chunk::regexp_replacements() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ValueExpression.Chunk.regexp_replacements)
  return regexp_replacements_;
}

inline bool ValueExpression_Chunk::has_chunk() const {
  return chunk_case() != CHUNK_NOT_SET;
}
inline void ValueExpression_Chunk::clear_has_chunk() {
  _oneof_case_[0] = CHUNK_NOT_SET;
}
inline ValueExpression_Chunk::ChunkCase ValueExpression_Chunk::chunk_case() const {
  return ValueExpression_Chunk::ChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValueExpression

// repeated .autofill_assistant.ValueExpression.Chunk chunk = 1;
inline int ValueExpression::_internal_chunk_size() const {
  return chunk_.size();
}
inline int ValueExpression::chunk_size() const {
  return _internal_chunk_size();
}
inline void ValueExpression::clear_chunk() {
  chunk_.Clear();
}
inline ::autofill_assistant::ValueExpression_Chunk* ValueExpression::mutable_chunk(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpression.chunk)
  return chunk_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_Chunk >*
ValueExpression::mutable_chunk() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ValueExpression.chunk)
  return &chunk_;
}
inline const ::autofill_assistant::ValueExpression_Chunk& ValueExpression::_internal_chunk(int index) const {
  return chunk_.Get(index);
}
inline const ::autofill_assistant::ValueExpression_Chunk& ValueExpression::chunk(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpression.chunk)
  return _internal_chunk(index);
}
inline ::autofill_assistant::ValueExpression_Chunk* ValueExpression::_internal_add_chunk() {
  return chunk_.Add();
}
inline ::autofill_assistant::ValueExpression_Chunk* ValueExpression::add_chunk() {
  ::autofill_assistant::ValueExpression_Chunk* _add = _internal_add_chunk();
  // @@protoc_insertion_point(field_add:autofill_assistant.ValueExpression.chunk)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ValueExpression_Chunk >&
ValueExpression::chunk() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ValueExpression.chunk)
  return chunk_;
}

// -------------------------------------------------------------------

// ValueExpressionRegexp

// optional .autofill_assistant.ValueExpression value_expression = 1;
inline bool ValueExpressionRegexp::_internal_has_value_expression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_expression_ != nullptr);
  return value;
}
inline bool ValueExpressionRegexp::has_value_expression() const {
  return _internal_has_value_expression();
}
inline void ValueExpressionRegexp::clear_value_expression() {
  if (value_expression_ != nullptr) value_expression_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ValueExpression& ValueExpressionRegexp::_internal_value_expression() const {
  const ::autofill_assistant::ValueExpression* p = value_expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueExpression&>(
      ::autofill_assistant::_ValueExpression_default_instance_);
}
inline const ::autofill_assistant::ValueExpression& ValueExpressionRegexp::value_expression() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpressionRegexp.value_expression)
  return _internal_value_expression();
}
inline void ValueExpressionRegexp::unsafe_arena_set_allocated_value_expression(
    ::autofill_assistant::ValueExpression* value_expression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_);
  }
  value_expression_ = value_expression;
  if (value_expression) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ValueExpressionRegexp.value_expression)
}
inline ::autofill_assistant::ValueExpression* ValueExpressionRegexp::release_value_expression() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueExpression* ValueExpressionRegexp::unsafe_arena_release_value_expression() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ValueExpressionRegexp.value_expression)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueExpression* ValueExpressionRegexp::_internal_mutable_value_expression() {
  _has_bits_[0] |= 0x00000001u;
  if (value_expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueExpression>(GetArenaForAllocation());
    value_expression_ = p;
  }
  return value_expression_;
}
inline ::autofill_assistant::ValueExpression* ValueExpressionRegexp::mutable_value_expression() {
  ::autofill_assistant::ValueExpression* _msg = _internal_mutable_value_expression();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ValueExpressionRegexp.value_expression)
  return _msg;
}
inline void ValueExpressionRegexp::set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_expression_;
  }
  if (value_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value_expression);
    if (message_arena != submessage_arena) {
      value_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_expression, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_expression_ = value_expression;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueExpressionRegexp.value_expression)
}

// optional bool case_sensitive = 4;
inline bool ValueExpressionRegexp::_internal_has_case_sensitive() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ValueExpressionRegexp::has_case_sensitive() const {
  return _internal_has_case_sensitive();
}
inline void ValueExpressionRegexp::clear_case_sensitive() {
  case_sensitive_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ValueExpressionRegexp::_internal_case_sensitive() const {
  return case_sensitive_;
}
inline bool ValueExpressionRegexp::case_sensitive() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ValueExpressionRegexp.case_sensitive)
  return _internal_case_sensitive();
}
inline void ValueExpressionRegexp::_internal_set_case_sensitive(bool value) {
  _has_bits_[0] |= 0x00000002u;
  case_sensitive_ = value;
}
inline void ValueExpressionRegexp::set_case_sensitive(bool value) {
  _internal_set_case_sensitive(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ValueExpressionRegexp.case_sensitive)
}

// -------------------------------------------------------------------

// AutofillValue

// optional .autofill_assistant.AutofillProfile profile = 1;
inline bool AutofillValue::_internal_has_profile() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || profile_ != nullptr);
  return value;
}
inline bool AutofillValue::has_profile() const {
  return _internal_has_profile();
}
inline void AutofillValue::clear_profile() {
  if (profile_ != nullptr) profile_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::AutofillProfile& AutofillValue::_internal_profile() const {
  const ::autofill_assistant::AutofillProfile* p = profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::AutofillProfile&>(
      ::autofill_assistant::_AutofillProfile_default_instance_);
}
inline const ::autofill_assistant::AutofillProfile& AutofillValue::profile() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillValue.profile)
  return _internal_profile();
}
inline void AutofillValue::unsafe_arena_set_allocated_profile(
    ::autofill_assistant::AutofillProfile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profile_);
  }
  profile_ = profile;
  if (profile) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillValue.profile)
}
inline ::autofill_assistant::AutofillProfile* AutofillValue::release_profile() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillProfile* temp = profile_;
  profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::AutofillProfile* AutofillValue::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillValue.profile)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillProfile* temp = profile_;
  profile_ = nullptr;
  return temp;
}
inline ::autofill_assistant::AutofillProfile* AutofillValue::_internal_mutable_profile() {
  _has_bits_[0] |= 0x00000002u;
  if (profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::AutofillProfile>(GetArenaForAllocation());
    profile_ = p;
  }
  return profile_;
}
inline ::autofill_assistant::AutofillProfile* AutofillValue::mutable_profile() {
  ::autofill_assistant::AutofillProfile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillValue.profile)
  return _msg;
}
inline void AutofillValue::set_allocated_profile(::autofill_assistant::AutofillProfile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profile);
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillValue.profile)
}

// optional .autofill_assistant.ValueExpression value_expression = 5;
inline bool AutofillValue::_internal_has_value_expression() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || value_expression_ != nullptr);
  return value;
}
inline bool AutofillValue::has_value_expression() const {
  return _internal_has_value_expression();
}
inline void AutofillValue::clear_value_expression() {
  if (value_expression_ != nullptr) value_expression_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ValueExpression& AutofillValue::_internal_value_expression() const {
  const ::autofill_assistant::ValueExpression* p = value_expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueExpression&>(
      ::autofill_assistant::_ValueExpression_default_instance_);
}
inline const ::autofill_assistant::ValueExpression& AutofillValue::value_expression() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillValue.value_expression)
  return _internal_value_expression();
}
inline void AutofillValue::unsafe_arena_set_allocated_value_expression(
    ::autofill_assistant::ValueExpression* value_expression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_);
  }
  value_expression_ = value_expression;
  if (value_expression) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillValue.value_expression)
}
inline ::autofill_assistant::ValueExpression* AutofillValue::release_value_expression() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueExpression* AutofillValue::unsafe_arena_release_value_expression() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillValue.value_expression)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueExpression* AutofillValue::_internal_mutable_value_expression() {
  _has_bits_[0] |= 0x00000004u;
  if (value_expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueExpression>(GetArenaForAllocation());
    value_expression_ = p;
  }
  return value_expression_;
}
inline ::autofill_assistant::ValueExpression* AutofillValue::mutable_value_expression() {
  ::autofill_assistant::ValueExpression* _msg = _internal_mutable_value_expression();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillValue.value_expression)
  return _msg;
}
inline void AutofillValue::set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_expression_;
  }
  if (value_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value_expression);
    if (message_arena != submessage_arena) {
      value_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_expression, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  value_expression_ = value_expression;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillValue.value_expression)
}

// optional string locale = 6;
inline bool AutofillValue::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillValue::has_locale() const {
  return _internal_has_locale();
}
inline void AutofillValue::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillValue::locale() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillValue.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillValue::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillValue.locale)
}
inline std::string* AutofillValue::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillValue.locale)
  return _s;
}
inline const std::string& AutofillValue::_internal_locale() const {
  return locale_.Get();
}
inline void AutofillValue::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillValue::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillValue::release_locale() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillValue.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillValue::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillValue.locale)
}

// -------------------------------------------------------------------

// AutofillValueRegexp

// optional .autofill_assistant.AutofillProfile profile = 1;
inline bool AutofillValueRegexp::_internal_has_profile() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || profile_ != nullptr);
  return value;
}
inline bool AutofillValueRegexp::has_profile() const {
  return _internal_has_profile();
}
inline void AutofillValueRegexp::clear_profile() {
  if (profile_ != nullptr) profile_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::AutofillProfile& AutofillValueRegexp::_internal_profile() const {
  const ::autofill_assistant::AutofillProfile* p = profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::AutofillProfile&>(
      ::autofill_assistant::_AutofillProfile_default_instance_);
}
inline const ::autofill_assistant::AutofillProfile& AutofillValueRegexp::profile() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillValueRegexp.profile)
  return _internal_profile();
}
inline void AutofillValueRegexp::unsafe_arena_set_allocated_profile(
    ::autofill_assistant::AutofillProfile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profile_);
  }
  profile_ = profile;
  if (profile) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillValueRegexp.profile)
}
inline ::autofill_assistant::AutofillProfile* AutofillValueRegexp::release_profile() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillProfile* temp = profile_;
  profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::AutofillProfile* AutofillValueRegexp::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillValueRegexp.profile)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillProfile* temp = profile_;
  profile_ = nullptr;
  return temp;
}
inline ::autofill_assistant::AutofillProfile* AutofillValueRegexp::_internal_mutable_profile() {
  _has_bits_[0] |= 0x00000002u;
  if (profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::AutofillProfile>(GetArenaForAllocation());
    profile_ = p;
  }
  return profile_;
}
inline ::autofill_assistant::AutofillProfile* AutofillValueRegexp::mutable_profile() {
  ::autofill_assistant::AutofillProfile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillValueRegexp.profile)
  return _msg;
}
inline void AutofillValueRegexp::set_allocated_profile(::autofill_assistant::AutofillProfile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profile);
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillValueRegexp.profile)
}

// optional .autofill_assistant.ValueExpressionRegexp value_expression_re2 = 3;
inline bool AutofillValueRegexp::_internal_has_value_expression_re2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || value_expression_re2_ != nullptr);
  return value;
}
inline bool AutofillValueRegexp::has_value_expression_re2() const {
  return _internal_has_value_expression_re2();
}
inline void AutofillValueRegexp::clear_value_expression_re2() {
  if (value_expression_re2_ != nullptr) value_expression_re2_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ValueExpressionRegexp& AutofillValueRegexp::_internal_value_expression_re2() const {
  const ::autofill_assistant::ValueExpressionRegexp* p = value_expression_re2_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueExpressionRegexp&>(
      ::autofill_assistant::_ValueExpressionRegexp_default_instance_);
}
inline const ::autofill_assistant::ValueExpressionRegexp& AutofillValueRegexp::value_expression_re2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillValueRegexp.value_expression_re2)
  return _internal_value_expression_re2();
}
inline void AutofillValueRegexp::unsafe_arena_set_allocated_value_expression_re2(
    ::autofill_assistant::ValueExpressionRegexp* value_expression_re2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_re2_);
  }
  value_expression_re2_ = value_expression_re2;
  if (value_expression_re2) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillValueRegexp.value_expression_re2)
}
inline ::autofill_assistant::ValueExpressionRegexp* AutofillValueRegexp::release_value_expression_re2() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueExpressionRegexp* temp = value_expression_re2_;
  value_expression_re2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueExpressionRegexp* AutofillValueRegexp::unsafe_arena_release_value_expression_re2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillValueRegexp.value_expression_re2)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueExpressionRegexp* temp = value_expression_re2_;
  value_expression_re2_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueExpressionRegexp* AutofillValueRegexp::_internal_mutable_value_expression_re2() {
  _has_bits_[0] |= 0x00000004u;
  if (value_expression_re2_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueExpressionRegexp>(GetArenaForAllocation());
    value_expression_re2_ = p;
  }
  return value_expression_re2_;
}
inline ::autofill_assistant::ValueExpressionRegexp* AutofillValueRegexp::mutable_value_expression_re2() {
  ::autofill_assistant::ValueExpressionRegexp* _msg = _internal_mutable_value_expression_re2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillValueRegexp.value_expression_re2)
  return _msg;
}
inline void AutofillValueRegexp::set_allocated_value_expression_re2(::autofill_assistant::ValueExpressionRegexp* value_expression_re2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_expression_re2_;
  }
  if (value_expression_re2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value_expression_re2);
    if (message_arena != submessage_arena) {
      value_expression_re2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_expression_re2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  value_expression_re2_ = value_expression_re2;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillValueRegexp.value_expression_re2)
}

// optional string locale = 4;
inline bool AutofillValueRegexp::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillValueRegexp::has_locale() const {
  return _internal_has_locale();
}
inline void AutofillValueRegexp::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillValueRegexp::locale() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillValueRegexp.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillValueRegexp::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillValueRegexp.locale)
}
inline std::string* AutofillValueRegexp::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillValueRegexp.locale)
  return _s;
}
inline const std::string& AutofillValueRegexp::_internal_locale() const {
  return locale_.Get();
}
inline void AutofillValueRegexp::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillValueRegexp::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillValueRegexp::release_locale() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillValueRegexp.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillValueRegexp::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillValueRegexp.locale)
}

// -------------------------------------------------------------------

// TextFilter

// optional string re2 = 1;
inline bool TextFilter::_internal_has_re2() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextFilter::has_re2() const {
  return _internal_has_re2();
}
inline void TextFilter::clear_re2() {
  re2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextFilter::re2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextFilter.re2)
  return _internal_re2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextFilter::set_re2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 re2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextFilter.re2)
}
inline std::string* TextFilter::mutable_re2() {
  std::string* _s = _internal_mutable_re2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextFilter.re2)
  return _s;
}
inline const std::string& TextFilter::_internal_re2() const {
  return re2_.Get();
}
inline void TextFilter::_internal_set_re2(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  re2_.Set(value, GetArenaForAllocation());
}
inline std::string* TextFilter::_internal_mutable_re2() {
  _has_bits_[0] |= 0x00000001u;
  return re2_.Mutable(GetArenaForAllocation());
}
inline std::string* TextFilter::release_re2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextFilter.re2)
  if (!_internal_has_re2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = re2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (re2_.IsDefault()) {
    re2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextFilter::set_allocated_re2(std::string* re2) {
  if (re2 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  re2_.SetAllocated(re2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (re2_.IsDefault()) {
    re2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextFilter.re2)
}

// optional bool case_sensitive = 2;
inline bool TextFilter::_internal_has_case_sensitive() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TextFilter::has_case_sensitive() const {
  return _internal_has_case_sensitive();
}
inline void TextFilter::clear_case_sensitive() {
  case_sensitive_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TextFilter::_internal_case_sensitive() const {
  return case_sensitive_;
}
inline bool TextFilter::case_sensitive() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextFilter.case_sensitive)
  return _internal_case_sensitive();
}
inline void TextFilter::_internal_set_case_sensitive(bool value) {
  _has_bits_[0] |= 0x00000002u;
  case_sensitive_ = value;
}
inline void TextFilter::set_case_sensitive(bool value) {
  _internal_set_case_sensitive(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TextFilter.case_sensitive)
}

// -------------------------------------------------------------------

// PasswordManagerValue

// optional .autofill_assistant.PasswordManagerValue.CredentialType credential_type = 1;
inline bool PasswordManagerValue::_internal_has_credential_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PasswordManagerValue::has_credential_type() const {
  return _internal_has_credential_type();
}
inline void PasswordManagerValue::clear_credential_type() {
  credential_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::PasswordManagerValue_CredentialType PasswordManagerValue::_internal_credential_type() const {
  return static_cast< ::autofill_assistant::PasswordManagerValue_CredentialType >(credential_type_);
}
inline ::autofill_assistant::PasswordManagerValue_CredentialType PasswordManagerValue::credential_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PasswordManagerValue.credential_type)
  return _internal_credential_type();
}
inline void PasswordManagerValue::_internal_set_credential_type(::autofill_assistant::PasswordManagerValue_CredentialType value) {
  assert(::autofill_assistant::PasswordManagerValue_CredentialType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  credential_type_ = value;
}
inline void PasswordManagerValue::set_credential_type(::autofill_assistant::PasswordManagerValue_CredentialType value) {
  _internal_set_credential_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PasswordManagerValue.credential_type)
}

// -------------------------------------------------------------------

// TextValue

// string text = 1;
inline bool TextValue::_internal_has_text() const {
  return value_case() == kText;
}
inline bool TextValue::has_text() const {
  return _internal_has_text();
}
inline void TextValue::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void TextValue::clear_text() {
  if (_internal_has_text()) {
    value_.text_.Destroy();
    clear_has_value();
  }
}
inline const std::string& TextValue::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextValue.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void TextValue::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_value();
    set_has_text();
    value_.text_.InitDefault();
  }
  value_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextValue.text)
}
inline std::string* TextValue::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextValue.text)
  return _s;
}
inline const std::string& TextValue::_internal_text() const {
  if (_internal_has_text()) {
    return value_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TextValue::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_value();
    set_has_text();
    value_.text_.InitDefault();
  }
  value_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextValue::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_value();
    set_has_text();
    value_.text_.InitDefault();
  }
  return value_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* TextValue::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextValue.text)
  if (_internal_has_text()) {
    clear_has_value();
    return value_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void TextValue::set_allocated_text(std::string* text) {
  if (has_value()) {
    clear_value();
  }
  if (text != nullptr) {
    set_has_text();
    value_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextValue.text)
}

// .autofill_assistant.AutofillValue autofill_value = 2;
inline bool TextValue::_internal_has_autofill_value() const {
  return value_case() == kAutofillValue;
}
inline bool TextValue::has_autofill_value() const {
  return _internal_has_autofill_value();
}
inline void TextValue::set_has_autofill_value() {
  _oneof_case_[0] = kAutofillValue;
}
inline void TextValue::clear_autofill_value() {
  if (_internal_has_autofill_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.autofill_value_;
    }
    clear_has_value();
  }
}
inline ::autofill_assistant::AutofillValue* TextValue::release_autofill_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextValue.autofill_value)
  if (_internal_has_autofill_value()) {
    clear_has_value();
    ::autofill_assistant::AutofillValue* temp = value_.autofill_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.autofill_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::AutofillValue& TextValue::_internal_autofill_value() const {
  return _internal_has_autofill_value()
      ? *value_.autofill_value_
      : reinterpret_cast< ::autofill_assistant::AutofillValue&>(::autofill_assistant::_AutofillValue_default_instance_);
}
inline const ::autofill_assistant::AutofillValue& TextValue::autofill_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextValue.autofill_value)
  return _internal_autofill_value();
}
inline ::autofill_assistant::AutofillValue* TextValue::unsafe_arena_release_autofill_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TextValue.autofill_value)
  if (_internal_has_autofill_value()) {
    clear_has_value();
    ::autofill_assistant::AutofillValue* temp = value_.autofill_value_;
    value_.autofill_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TextValue::unsafe_arena_set_allocated_autofill_value(::autofill_assistant::AutofillValue* autofill_value) {
  clear_value();
  if (autofill_value) {
    set_has_autofill_value();
    value_.autofill_value_ = autofill_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TextValue.autofill_value)
}
inline ::autofill_assistant::AutofillValue* TextValue::_internal_mutable_autofill_value() {
  if (!_internal_has_autofill_value()) {
    clear_value();
    set_has_autofill_value();
    value_.autofill_value_ = CreateMaybeMessage< ::autofill_assistant::AutofillValue >(GetArenaForAllocation());
  }
  return value_.autofill_value_;
}
inline ::autofill_assistant::AutofillValue* TextValue::mutable_autofill_value() {
  ::autofill_assistant::AutofillValue* _msg = _internal_mutable_autofill_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextValue.autofill_value)
  return _msg;
}

// .autofill_assistant.PasswordManagerValue password_manager_value = 3;
inline bool TextValue::_internal_has_password_manager_value() const {
  return value_case() == kPasswordManagerValue;
}
inline bool TextValue::has_password_manager_value() const {
  return _internal_has_password_manager_value();
}
inline void TextValue::set_has_password_manager_value() {
  _oneof_case_[0] = kPasswordManagerValue;
}
inline void TextValue::clear_password_manager_value() {
  if (_internal_has_password_manager_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.password_manager_value_;
    }
    clear_has_value();
  }
}
inline ::autofill_assistant::PasswordManagerValue* TextValue::release_password_manager_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextValue.password_manager_value)
  if (_internal_has_password_manager_value()) {
    clear_has_value();
    ::autofill_assistant::PasswordManagerValue* temp = value_.password_manager_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.password_manager_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PasswordManagerValue& TextValue::_internal_password_manager_value() const {
  return _internal_has_password_manager_value()
      ? *value_.password_manager_value_
      : reinterpret_cast< ::autofill_assistant::PasswordManagerValue&>(::autofill_assistant::_PasswordManagerValue_default_instance_);
}
inline const ::autofill_assistant::PasswordManagerValue& TextValue::password_manager_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextValue.password_manager_value)
  return _internal_password_manager_value();
}
inline ::autofill_assistant::PasswordManagerValue* TextValue::unsafe_arena_release_password_manager_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TextValue.password_manager_value)
  if (_internal_has_password_manager_value()) {
    clear_has_value();
    ::autofill_assistant::PasswordManagerValue* temp = value_.password_manager_value_;
    value_.password_manager_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TextValue::unsafe_arena_set_allocated_password_manager_value(::autofill_assistant::PasswordManagerValue* password_manager_value) {
  clear_value();
  if (password_manager_value) {
    set_has_password_manager_value();
    value_.password_manager_value_ = password_manager_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TextValue.password_manager_value)
}
inline ::autofill_assistant::PasswordManagerValue* TextValue::_internal_mutable_password_manager_value() {
  if (!_internal_has_password_manager_value()) {
    clear_value();
    set_has_password_manager_value();
    value_.password_manager_value_ = CreateMaybeMessage< ::autofill_assistant::PasswordManagerValue >(GetArenaForAllocation());
  }
  return value_.password_manager_value_;
}
inline ::autofill_assistant::PasswordManagerValue* TextValue::mutable_password_manager_value() {
  ::autofill_assistant::PasswordManagerValue* _msg = _internal_mutable_password_manager_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextValue.password_manager_value)
  return _msg;
}

// string client_memory_key = 4;
inline bool TextValue::_internal_has_client_memory_key() const {
  return value_case() == kClientMemoryKey;
}
inline bool TextValue::has_client_memory_key() const {
  return _internal_has_client_memory_key();
}
inline void TextValue::set_has_client_memory_key() {
  _oneof_case_[0] = kClientMemoryKey;
}
inline void TextValue::clear_client_memory_key() {
  if (_internal_has_client_memory_key()) {
    value_.client_memory_key_.Destroy();
    clear_has_value();
  }
}
inline const std::string& TextValue::client_memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextValue.client_memory_key)
  return _internal_client_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline void TextValue::set_client_memory_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_client_memory_key()) {
    clear_value();
    set_has_client_memory_key();
    value_.client_memory_key_.InitDefault();
  }
  value_.client_memory_key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextValue.client_memory_key)
}
inline std::string* TextValue::mutable_client_memory_key() {
  std::string* _s = _internal_mutable_client_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextValue.client_memory_key)
  return _s;
}
inline const std::string& TextValue::_internal_client_memory_key() const {
  if (_internal_has_client_memory_key()) {
    return value_.client_memory_key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TextValue::_internal_set_client_memory_key(const std::string& value) {
  if (!_internal_has_client_memory_key()) {
    clear_value();
    set_has_client_memory_key();
    value_.client_memory_key_.InitDefault();
  }
  value_.client_memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* TextValue::_internal_mutable_client_memory_key() {
  if (!_internal_has_client_memory_key()) {
    clear_value();
    set_has_client_memory_key();
    value_.client_memory_key_.InitDefault();
  }
  return value_.client_memory_key_.Mutable(      GetArenaForAllocation());
}
inline std::string* TextValue::release_client_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextValue.client_memory_key)
  if (_internal_has_client_memory_key()) {
    clear_has_value();
    return value_.client_memory_key_.Release();
  } else {
    return nullptr;
  }
}
inline void TextValue::set_allocated_client_memory_key(std::string* client_memory_key) {
  if (has_value()) {
    clear_value();
  }
  if (client_memory_key != nullptr) {
    set_has_client_memory_key();
    value_.client_memory_key_.InitAllocated(client_memory_key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextValue.client_memory_key)
}

inline bool TextValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TextValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline TextValue::ValueCase TextValue::value_case() const {
  return TextValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeyEvent

// optional string code = 2;
inline bool KeyEvent::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyEvent::has_code() const {
  return _internal_has_code();
}
inline void KeyEvent::clear_code() {
  code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyEvent::code() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.KeyEvent.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyEvent::set_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.KeyEvent.code)
}
inline std::string* KeyEvent::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.KeyEvent.code)
  return _s;
}
inline const std::string& KeyEvent::_internal_code() const {
  return code_.Get();
}
inline void KeyEvent::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  code_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyEvent::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000001u;
  return code_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyEvent::release_code() {
  // @@protoc_insertion_point(field_release:autofill_assistant.KeyEvent.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault()) {
    code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyEvent::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault()) {
    code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.KeyEvent.code)
}

// optional string text = 3;
inline bool KeyEvent::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyEvent::has_text() const {
  return _internal_has_text();
}
inline void KeyEvent::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyEvent::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.KeyEvent.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyEvent::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.KeyEvent.text)
}
inline std::string* KeyEvent::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.KeyEvent.text)
  return _s;
}
inline const std::string& KeyEvent::_internal_text() const {
  return text_.Get();
}
inline void KeyEvent::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyEvent::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyEvent::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.KeyEvent.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.KeyEvent.text)
}

// optional string key = 4;
inline bool KeyEvent::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeyEvent::has_key() const {
  return _internal_has_key();
}
inline void KeyEvent::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& KeyEvent::key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.KeyEvent.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyEvent::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.KeyEvent.key)
}
inline std::string* KeyEvent::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.KeyEvent.key)
  return _s;
}
inline const std::string& KeyEvent::_internal_key() const {
  return key_.Get();
}
inline void KeyEvent::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyEvent::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000004u;
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyEvent::release_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.KeyEvent.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyEvent::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.KeyEvent.key)
}

// repeated string command = 5;
inline int KeyEvent::_internal_command_size() const {
  return command_.size();
}
inline int KeyEvent::command_size() const {
  return _internal_command_size();
}
inline void KeyEvent::clear_command() {
  command_.Clear();
}
inline std::string* KeyEvent::add_command() {
  std::string* _s = _internal_add_command();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.KeyEvent.command)
  return _s;
}
inline const std::string& KeyEvent::_internal_command(int index) const {
  return command_.Get(index);
}
inline const std::string& KeyEvent::command(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.KeyEvent.command)
  return _internal_command(index);
}
inline std::string* KeyEvent::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.KeyEvent.command)
  return command_.Mutable(index);
}
inline void KeyEvent::set_command(int index, const std::string& value) {
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.KeyEvent.command)
}
inline void KeyEvent::set_command(int index, std::string&& value) {
  command_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.KeyEvent.command)
}
inline void KeyEvent::set_command(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.KeyEvent.command)
}
inline void KeyEvent::set_command(int index, const char* value, size_t size) {
  command_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.KeyEvent.command)
}
inline std::string* KeyEvent::_internal_add_command() {
  return command_.Add();
}
inline void KeyEvent::add_command(const std::string& value) {
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.KeyEvent.command)
}
inline void KeyEvent::add_command(std::string&& value) {
  command_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.KeyEvent.command)
}
inline void KeyEvent::add_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  command_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.KeyEvent.command)
}
inline void KeyEvent::add_command(const char* value, size_t size) {
  command_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.KeyEvent.command)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
KeyEvent::command() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.KeyEvent.command)
  return command_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
KeyEvent::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.KeyEvent.command)
  return &command_;
}

// optional int32 key_code = 6;
inline bool KeyEvent::_internal_has_key_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KeyEvent::has_key_code() const {
  return _internal_has_key_code();
}
inline void KeyEvent::clear_key_code() {
  key_code_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t KeyEvent::_internal_key_code() const {
  return key_code_;
}
inline int32_t KeyEvent::key_code() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.KeyEvent.key_code)
  return _internal_key_code();
}
inline void KeyEvent::_internal_set_key_code(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  key_code_ = value;
}
inline void KeyEvent::set_key_code(int32_t value) {
  _internal_set_key_code(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.KeyEvent.key_code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill_assistant

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill_assistant::PasswordManagerValue_CredentialType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2faction_5fvalue_2eproto
