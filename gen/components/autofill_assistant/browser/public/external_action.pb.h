// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/public/external_action.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include "components/autofill_assistant/browser/public/fast_checkout/proto/actions.pb.h"
#include "components/autofill_assistant/browser/public/password_change/proto/actions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
namespace external {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionInfo;
struct ActionInfoDefaultTypeInternal;
extern ActionInfoDefaultTypeInternal _ActionInfo_default_instance_;
class CreditCardProto;
struct CreditCardProtoDefaultTypeInternal;
extern CreditCardProtoDefaultTypeInternal _CreditCardProto_default_instance_;
class CreditCardProto_ValuesEntry_DoNotUse;
struct CreditCardProto_ValuesEntry_DoNotUseDefaultTypeInternal;
extern CreditCardProto_ValuesEntry_DoNotUseDefaultTypeInternal _CreditCardProto_ValuesEntry_DoNotUse_default_instance_;
class ElementConditionsUpdate;
struct ElementConditionsUpdateDefaultTypeInternal;
extern ElementConditionsUpdateDefaultTypeInternal _ElementConditionsUpdate_default_instance_;
class ElementConditionsUpdate_ConditionResult;
struct ElementConditionsUpdate_ConditionResultDefaultTypeInternal;
extern ElementConditionsUpdate_ConditionResultDefaultTypeInternal _ElementConditionsUpdate_ConditionResult_default_instance_;
class ProfileProto;
struct ProfileProtoDefaultTypeInternal;
extern ProfileProtoDefaultTypeInternal _ProfileProto_default_instance_;
class ProfileProto_ValuesEntry_DoNotUse;
struct ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal;
extern ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal _ProfileProto_ValuesEntry_DoNotUse_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class ResultInfo;
struct ResultInfoDefaultTypeInternal;
extern ResultInfoDefaultTypeInternal _ResultInfo_default_instance_;
class Result_SelectedProfilesEntry_DoNotUse;
struct Result_SelectedProfilesEntry_DoNotUseDefaultTypeInternal;
extern Result_SelectedProfilesEntry_DoNotUseDefaultTypeInternal _Result_SelectedProfilesEntry_DoNotUse_default_instance_;
}  // namespace external
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::external::Action* Arena::CreateMaybeMessage<::autofill_assistant::external::Action>(Arena*);
template<> ::autofill_assistant::external::ActionInfo* Arena::CreateMaybeMessage<::autofill_assistant::external::ActionInfo>(Arena*);
template<> ::autofill_assistant::external::CreditCardProto* Arena::CreateMaybeMessage<::autofill_assistant::external::CreditCardProto>(Arena*);
template<> ::autofill_assistant::external::CreditCardProto_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::external::CreditCardProto_ValuesEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::external::ElementConditionsUpdate* Arena::CreateMaybeMessage<::autofill_assistant::external::ElementConditionsUpdate>(Arena*);
template<> ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* Arena::CreateMaybeMessage<::autofill_assistant::external::ElementConditionsUpdate_ConditionResult>(Arena*);
template<> ::autofill_assistant::external::ProfileProto* Arena::CreateMaybeMessage<::autofill_assistant::external::ProfileProto>(Arena*);
template<> ::autofill_assistant::external::ProfileProto_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::external::ProfileProto_ValuesEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::external::Result* Arena::CreateMaybeMessage<::autofill_assistant::external::Result>(Arena*);
template<> ::autofill_assistant::external::ResultInfo* Arena::CreateMaybeMessage<::autofill_assistant::external::ResultInfo>(Arena*);
template<> ::autofill_assistant::external::Result_SelectedProfilesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::external::Result_SelectedProfilesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {
namespace external {

// ===================================================================

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // optional .autofill_assistant.external.ActionInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::autofill_assistant::external::ActionInfo& info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::external::ActionInfo* release_info();
  ::autofill_assistant::external::ActionInfo* mutable_info();
  void set_allocated_info(::autofill_assistant::external::ActionInfo* info);
  private:
  const ::autofill_assistant::external::ActionInfo& _internal_info() const;
  ::autofill_assistant::external::ActionInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::autofill_assistant::external::ActionInfo* info);
  ::autofill_assistant::external::ActionInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:autofill_assistant.external.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::external::ActionInfo* info_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class ActionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.ActionInfo) */ {
 public:
  inline ActionInfo() : ActionInfo(nullptr) {}
  ~ActionInfo() override;
  explicit PROTOBUF_CONSTEXPR ActionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionInfo(const ActionInfo& from);
  ActionInfo(ActionInfo&& from) noexcept
    : ActionInfo() {
    *this = ::std::move(from);
  }

  inline ActionInfo& operator=(const ActionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionInfo& operator=(ActionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActionInfo& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kGenericPasswordChangeSpecification = 1,
    kFastCheckoutAction = 2,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionInfo* internal_default_instance() {
    return reinterpret_cast<const ActionInfo*>(
               &_ActionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ActionInfo& a, ActionInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ActionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActionInfo& from);
  void MergeFrom(const ActionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.ActionInfo";
  }
  protected:
  explicit ActionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGenericPasswordChangeSpecificationFieldNumber = 1,
    kFastCheckoutActionFieldNumber = 2,
  };
  // .autofill_assistant.password_change.GenericPasswordChangeSpecification generic_password_change_specification = 1;
  bool has_generic_password_change_specification() const;
  private:
  bool _internal_has_generic_password_change_specification() const;
  public:
  void clear_generic_password_change_specification();
  const ::autofill_assistant::password_change::GenericPasswordChangeSpecification& generic_password_change_specification() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::GenericPasswordChangeSpecification* release_generic_password_change_specification();
  ::autofill_assistant::password_change::GenericPasswordChangeSpecification* mutable_generic_password_change_specification();
  void set_allocated_generic_password_change_specification(::autofill_assistant::password_change::GenericPasswordChangeSpecification* generic_password_change_specification);
  private:
  const ::autofill_assistant::password_change::GenericPasswordChangeSpecification& _internal_generic_password_change_specification() const;
  ::autofill_assistant::password_change::GenericPasswordChangeSpecification* _internal_mutable_generic_password_change_specification();
  public:
  void unsafe_arena_set_allocated_generic_password_change_specification(
      ::autofill_assistant::password_change::GenericPasswordChangeSpecification* generic_password_change_specification);
  ::autofill_assistant::password_change::GenericPasswordChangeSpecification* unsafe_arena_release_generic_password_change_specification();

  // .autofill_assistant.fast_checkout.FastCheckoutAction fast_checkout_action = 2;
  bool has_fast_checkout_action() const;
  private:
  bool _internal_has_fast_checkout_action() const;
  public:
  void clear_fast_checkout_action();
  const ::autofill_assistant::fast_checkout::FastCheckoutAction& fast_checkout_action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::fast_checkout::FastCheckoutAction* release_fast_checkout_action();
  ::autofill_assistant::fast_checkout::FastCheckoutAction* mutable_fast_checkout_action();
  void set_allocated_fast_checkout_action(::autofill_assistant::fast_checkout::FastCheckoutAction* fast_checkout_action);
  private:
  const ::autofill_assistant::fast_checkout::FastCheckoutAction& _internal_fast_checkout_action() const;
  ::autofill_assistant::fast_checkout::FastCheckoutAction* _internal_mutable_fast_checkout_action();
  public:
  void unsafe_arena_set_allocated_fast_checkout_action(
      ::autofill_assistant::fast_checkout::FastCheckoutAction* fast_checkout_action);
  ::autofill_assistant::fast_checkout::FastCheckoutAction* unsafe_arena_release_fast_checkout_action();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ActionInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_extensions_);
  }

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.external.ActionInfo)
 private:
  class _Internal;
  void set_has_generic_password_change_specification();
  void set_has_fast_checkout_action();

  inline bool has_action() const;
  inline void clear_has_action();

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ActionUnion {
    constexpr ActionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::password_change::GenericPasswordChangeSpecification* generic_password_change_specification_;
    ::autofill_assistant::fast_checkout::FastCheckoutAction* fast_checkout_action_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class ProfileProto_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileProto_ValuesEntry_DoNotUse, 
    int32_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileProto_ValuesEntry_DoNotUse, 
    int32_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ProfileProto_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProfileProto_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProfileProto_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProfileProto_ValuesEntry_DoNotUse& other);
  static const ProfileProto_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProfileProto_ValuesEntry_DoNotUse*>(&_ProfileProto_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};

// -------------------------------------------------------------------

class ProfileProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.ProfileProto) */ {
 public:
  inline ProfileProto() : ProfileProto(nullptr) {}
  ~ProfileProto() override;
  explicit PROTOBUF_CONSTEXPR ProfileProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileProto(const ProfileProto& from);
  ProfileProto(ProfileProto&& from) noexcept
    : ProfileProto() {
    *this = ::std::move(from);
  }

  inline ProfileProto& operator=(const ProfileProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileProto& operator=(ProfileProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProfileProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileProto* internal_default_instance() {
    return reinterpret_cast<const ProfileProto*>(
               &_ProfileProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProfileProto& a, ProfileProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ProfileProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProfileProto& from);
  void MergeFrom(const ProfileProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.ProfileProto";
  }
  protected:
  explicit ProfileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // map<int32, string> values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:autofill_assistant.external.ProfileProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ProfileProto_ValuesEntry_DoNotUse,
      int32_t, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class CreditCardProto_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<CreditCardProto_ValuesEntry_DoNotUse, 
    int32_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<CreditCardProto_ValuesEntry_DoNotUse, 
    int32_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreditCardProto_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreditCardProto_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreditCardProto_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreditCardProto_ValuesEntry_DoNotUse& other);
  static const CreditCardProto_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreditCardProto_ValuesEntry_DoNotUse*>(&_CreditCardProto_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};

// -------------------------------------------------------------------

class CreditCardProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.CreditCardProto) */ {
 public:
  inline CreditCardProto() : CreditCardProto(nullptr) {}
  ~CreditCardProto() override;
  explicit PROTOBUF_CONSTEXPR CreditCardProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreditCardProto(const CreditCardProto& from);
  CreditCardProto(CreditCardProto&& from) noexcept
    : CreditCardProto() {
    *this = ::std::move(from);
  }

  inline CreditCardProto& operator=(const CreditCardProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreditCardProto& operator=(CreditCardProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CreditCardProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreditCardProto* internal_default_instance() {
    return reinterpret_cast<const CreditCardProto*>(
               &_CreditCardProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreditCardProto& a, CreditCardProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CreditCardProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreditCardProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreditCardProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreditCardProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CreditCardProto& from);
  void MergeFrom(const CreditCardProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreditCardProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.CreditCardProto";
  }
  protected:
  explicit CreditCardProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kNetworkFieldNumber = 4,
    kServerIdFieldNumber = 5,
    kRecordTypeFieldNumber = 2,
    kInstrumentIdFieldNumber = 3,
  };
  // map<int32, string> values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
      mutable_values();

  // optional string network = 4;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // optional string server_id = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_server_id() const;
  private:
  bool _internal_has_server_id() const;
  public:
  PROTOBUF_DEPRECATED void clear_server_id();
  PROTOBUF_DEPRECATED const std::string& server_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_server_id(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_server_id();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_server_id();
  PROTOBUF_DEPRECATED void set_allocated_server_id(std::string* server_id);
  private:
  const std::string& _internal_server_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(const std::string& value);
  std::string* _internal_mutable_server_id();
  public:

  // optional int64 record_type = 2;
  bool has_record_type() const;
  private:
  bool _internal_has_record_type() const;
  public:
  void clear_record_type();
  int64_t record_type() const;
  void set_record_type(int64_t value);
  private:
  int64_t _internal_record_type() const;
  void _internal_set_record_type(int64_t value);
  public:

  // optional int64 instrument_id = 3;
  bool has_instrument_id() const;
  private:
  bool _internal_has_instrument_id() const;
  public:
  void clear_instrument_id();
  int64_t instrument_id() const;
  void set_instrument_id(int64_t value);
  private:
  int64_t _internal_instrument_id() const;
  void _internal_set_instrument_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.external.CreditCardProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      CreditCardProto_ValuesEntry_DoNotUse,
      int32_t, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
  int64_t record_type_;
  int64_t instrument_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class Result_SelectedProfilesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Result_SelectedProfilesEntry_DoNotUse, 
    std::string, ::autofill_assistant::external::ProfileProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<Result_SelectedProfilesEntry_DoNotUse, 
    std::string, ::autofill_assistant::external::ProfileProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Result_SelectedProfilesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Result_SelectedProfilesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Result_SelectedProfilesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Result_SelectedProfilesEntry_DoNotUse& other);
  static const Result_SelectedProfilesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Result_SelectedProfilesEntry_DoNotUse*>(&_Result_SelectedProfilesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};

// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSelectedProfilesFieldNumber = 3,
    kResultInfoFieldNumber = 1,
    kSelectedCreditCardFieldNumber = 4,
    kSuccessFieldNumber = 2,
  };
  // map<string, .autofill_assistant.external.ProfileProto> selected_profiles = 3;
  int selected_profiles_size() const;
  private:
  int _internal_selected_profiles_size() const;
  public:
  void clear_selected_profiles();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >&
      _internal_selected_profiles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >*
      _internal_mutable_selected_profiles();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >&
      selected_profiles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >*
      mutable_selected_profiles();

  // optional .autofill_assistant.external.ResultInfo result_info = 1;
  bool has_result_info() const;
  private:
  bool _internal_has_result_info() const;
  public:
  void clear_result_info();
  const ::autofill_assistant::external::ResultInfo& result_info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::external::ResultInfo* release_result_info();
  ::autofill_assistant::external::ResultInfo* mutable_result_info();
  void set_allocated_result_info(::autofill_assistant::external::ResultInfo* result_info);
  private:
  const ::autofill_assistant::external::ResultInfo& _internal_result_info() const;
  ::autofill_assistant::external::ResultInfo* _internal_mutable_result_info();
  public:
  void unsafe_arena_set_allocated_result_info(
      ::autofill_assistant::external::ResultInfo* result_info);
  ::autofill_assistant::external::ResultInfo* unsafe_arena_release_result_info();

  // optional .autofill_assistant.external.CreditCardProto selected_credit_card = 4;
  bool has_selected_credit_card() const;
  private:
  bool _internal_has_selected_credit_card() const;
  public:
  void clear_selected_credit_card();
  const ::autofill_assistant::external::CreditCardProto& selected_credit_card() const;
  PROTOBUF_NODISCARD ::autofill_assistant::external::CreditCardProto* release_selected_credit_card();
  ::autofill_assistant::external::CreditCardProto* mutable_selected_credit_card();
  void set_allocated_selected_credit_card(::autofill_assistant::external::CreditCardProto* selected_credit_card);
  private:
  const ::autofill_assistant::external::CreditCardProto& _internal_selected_credit_card() const;
  ::autofill_assistant::external::CreditCardProto* _internal_mutable_selected_credit_card();
  public:
  void unsafe_arena_set_allocated_selected_credit_card(
      ::autofill_assistant::external::CreditCardProto* selected_credit_card);
  ::autofill_assistant::external::CreditCardProto* unsafe_arena_release_selected_credit_card();

  // optional bool success = 2;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.external.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      Result_SelectedProfilesEntry_DoNotUse,
      std::string, ::autofill_assistant::external::ProfileProto,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> selected_profiles_;
  ::autofill_assistant::external::ResultInfo* result_info_;
  ::autofill_assistant::external::CreditCardProto* selected_credit_card_;
  bool success_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class ResultInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.ResultInfo) */ {
 public:
  inline ResultInfo() : ResultInfo(nullptr) {}
  ~ResultInfo() override;
  explicit PROTOBUF_CONSTEXPR ResultInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultInfo(const ResultInfo& from);
  ResultInfo(ResultInfo&& from) noexcept
    : ResultInfo() {
    *this = ::std::move(from);
  }

  inline ResultInfo& operator=(const ResultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultInfo& operator=(ResultInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ResultInfo& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kGenericPasswordChangeSpecificationResult = 1,
    RESULT_NOT_SET = 0,
  };

  static inline const ResultInfo* internal_default_instance() {
    return reinterpret_cast<const ResultInfo*>(
               &_ResultInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResultInfo& a, ResultInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ResultInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResultInfo& from);
  void MergeFrom(const ResultInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.ResultInfo";
  }
  protected:
  explicit ResultInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGenericPasswordChangeSpecificationResultFieldNumber = 1,
  };
  // .autofill_assistant.password_change.GenericPasswordChangeSpecificationResult generic_password_change_specification_result = 1;
  bool has_generic_password_change_specification_result() const;
  private:
  bool _internal_has_generic_password_change_specification_result() const;
  public:
  void clear_generic_password_change_specification_result();
  const ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult& generic_password_change_specification_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* release_generic_password_change_specification_result();
  ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* mutable_generic_password_change_specification_result();
  void set_allocated_generic_password_change_specification_result(::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* generic_password_change_specification_result);
  private:
  const ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult& _internal_generic_password_change_specification_result() const;
  ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* _internal_mutable_generic_password_change_specification_result();
  public:
  void unsafe_arena_set_allocated_generic_password_change_specification_result(
      ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* generic_password_change_specification_result);
  ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* unsafe_arena_release_generic_password_change_specification_result();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ResultInfo, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_extensions_);
  }

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.external.ResultInfo)
 private:
  class _Internal;
  void set_has_generic_password_change_specification_result();

  inline bool has_result() const;
  inline void clear_has_result();

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResultUnion {
    constexpr ResultUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* generic_password_change_specification_result_;
  } result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class ElementConditionsUpdate_ConditionResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.ElementConditionsUpdate.ConditionResult) */ {
 public:
  inline ElementConditionsUpdate_ConditionResult() : ElementConditionsUpdate_ConditionResult(nullptr) {}
  ~ElementConditionsUpdate_ConditionResult() override;
  explicit PROTOBUF_CONSTEXPR ElementConditionsUpdate_ConditionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementConditionsUpdate_ConditionResult(const ElementConditionsUpdate_ConditionResult& from);
  ElementConditionsUpdate_ConditionResult(ElementConditionsUpdate_ConditionResult&& from) noexcept
    : ElementConditionsUpdate_ConditionResult() {
    *this = ::std::move(from);
  }

  inline ElementConditionsUpdate_ConditionResult& operator=(const ElementConditionsUpdate_ConditionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementConditionsUpdate_ConditionResult& operator=(ElementConditionsUpdate_ConditionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementConditionsUpdate_ConditionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementConditionsUpdate_ConditionResult* internal_default_instance() {
    return reinterpret_cast<const ElementConditionsUpdate_ConditionResult*>(
               &_ElementConditionsUpdate_ConditionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ElementConditionsUpdate_ConditionResult& a, ElementConditionsUpdate_ConditionResult& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementConditionsUpdate_ConditionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementConditionsUpdate_ConditionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementConditionsUpdate_ConditionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementConditionsUpdate_ConditionResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementConditionsUpdate_ConditionResult& from);
  void MergeFrom(const ElementConditionsUpdate_ConditionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementConditionsUpdate_ConditionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.ElementConditionsUpdate.ConditionResult";
  }
  protected:
  explicit ElementConditionsUpdate_ConditionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSatisfiedFieldNumber = 2,
  };
  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional bool satisfied = 2;
  bool has_satisfied() const;
  private:
  bool _internal_has_satisfied() const;
  public:
  void clear_satisfied();
  bool satisfied() const;
  void set_satisfied(bool value);
  private:
  bool _internal_satisfied() const;
  void _internal_set_satisfied(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.external.ElementConditionsUpdate.ConditionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t id_;
  bool satisfied_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// -------------------------------------------------------------------

class ElementConditionsUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.external.ElementConditionsUpdate) */ {
 public:
  inline ElementConditionsUpdate() : ElementConditionsUpdate(nullptr) {}
  ~ElementConditionsUpdate() override;
  explicit PROTOBUF_CONSTEXPR ElementConditionsUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementConditionsUpdate(const ElementConditionsUpdate& from);
  ElementConditionsUpdate(ElementConditionsUpdate&& from) noexcept
    : ElementConditionsUpdate() {
    *this = ::std::move(from);
  }

  inline ElementConditionsUpdate& operator=(const ElementConditionsUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementConditionsUpdate& operator=(ElementConditionsUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementConditionsUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementConditionsUpdate* internal_default_instance() {
    return reinterpret_cast<const ElementConditionsUpdate*>(
               &_ElementConditionsUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ElementConditionsUpdate& a, ElementConditionsUpdate& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementConditionsUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementConditionsUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementConditionsUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementConditionsUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementConditionsUpdate& from);
  void MergeFrom(const ElementConditionsUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementConditionsUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.external.ElementConditionsUpdate";
  }
  protected:
  explicit ElementConditionsUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ElementConditionsUpdate_ConditionResult ConditionResult;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .autofill_assistant.external.ElementConditionsUpdate.ConditionResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult >*
      mutable_results();
  private:
  const ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult& _internal_results(int index) const;
  ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* _internal_add_results();
  public:
  const ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult& results(int index) const;
  ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.external.ElementConditionsUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Action

// optional .autofill_assistant.external.ActionInfo info = 1;
inline bool Action::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool Action::has_info() const {
  return _internal_has_info();
}
inline void Action::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::external::ActionInfo& Action::_internal_info() const {
  const ::autofill_assistant::external::ActionInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::external::ActionInfo&>(
      ::autofill_assistant::external::_ActionInfo_default_instance_);
}
inline const ::autofill_assistant::external::ActionInfo& Action::info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.Action.info)
  return _internal_info();
}
inline void Action::unsafe_arena_set_allocated_info(
    ::autofill_assistant::external::ActionInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.external.Action.info)
}
inline ::autofill_assistant::external::ActionInfo* Action::release_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ActionInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::external::ActionInfo* Action::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.Action.info)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ActionInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::external::ActionInfo* Action::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::external::ActionInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::autofill_assistant::external::ActionInfo* Action::mutable_info() {
  ::autofill_assistant::external::ActionInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.Action.info)
  return _msg;
}
inline void Action::set_allocated_info(::autofill_assistant::external::ActionInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.external.Action.info)
}

// -------------------------------------------------------------------

// ActionInfo

// .autofill_assistant.password_change.GenericPasswordChangeSpecification generic_password_change_specification = 1;
inline bool ActionInfo::_internal_has_generic_password_change_specification() const {
  return action_case() == kGenericPasswordChangeSpecification;
}
inline bool ActionInfo::has_generic_password_change_specification() const {
  return _internal_has_generic_password_change_specification();
}
inline void ActionInfo::set_has_generic_password_change_specification() {
  _oneof_case_[0] = kGenericPasswordChangeSpecification;
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecification* ActionInfo::release_generic_password_change_specification() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.ActionInfo.generic_password_change_specification)
  if (_internal_has_generic_password_change_specification()) {
    clear_has_action();
    ::autofill_assistant::password_change::GenericPasswordChangeSpecification* temp = action_.generic_password_change_specification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.generic_password_change_specification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::GenericPasswordChangeSpecification& ActionInfo::_internal_generic_password_change_specification() const {
  return _internal_has_generic_password_change_specification()
      ? *action_.generic_password_change_specification_
      : reinterpret_cast< ::autofill_assistant::password_change::GenericPasswordChangeSpecification&>(::autofill_assistant::password_change::_GenericPasswordChangeSpecification_default_instance_);
}
inline const ::autofill_assistant::password_change::GenericPasswordChangeSpecification& ActionInfo::generic_password_change_specification() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.ActionInfo.generic_password_change_specification)
  return _internal_generic_password_change_specification();
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecification* ActionInfo::unsafe_arena_release_generic_password_change_specification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.external.ActionInfo.generic_password_change_specification)
  if (_internal_has_generic_password_change_specification()) {
    clear_has_action();
    ::autofill_assistant::password_change::GenericPasswordChangeSpecification* temp = action_.generic_password_change_specification_;
    action_.generic_password_change_specification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionInfo::unsafe_arena_set_allocated_generic_password_change_specification(::autofill_assistant::password_change::GenericPasswordChangeSpecification* generic_password_change_specification) {
  clear_action();
  if (generic_password_change_specification) {
    set_has_generic_password_change_specification();
    action_.generic_password_change_specification_ = generic_password_change_specification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.external.ActionInfo.generic_password_change_specification)
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecification* ActionInfo::_internal_mutable_generic_password_change_specification() {
  if (!_internal_has_generic_password_change_specification()) {
    clear_action();
    set_has_generic_password_change_specification();
    action_.generic_password_change_specification_ = CreateMaybeMessage< ::autofill_assistant::password_change::GenericPasswordChangeSpecification >(GetArenaForAllocation());
  }
  return action_.generic_password_change_specification_;
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecification* ActionInfo::mutable_generic_password_change_specification() {
  ::autofill_assistant::password_change::GenericPasswordChangeSpecification* _msg = _internal_mutable_generic_password_change_specification();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.ActionInfo.generic_password_change_specification)
  return _msg;
}

// .autofill_assistant.fast_checkout.FastCheckoutAction fast_checkout_action = 2;
inline bool ActionInfo::_internal_has_fast_checkout_action() const {
  return action_case() == kFastCheckoutAction;
}
inline bool ActionInfo::has_fast_checkout_action() const {
  return _internal_has_fast_checkout_action();
}
inline void ActionInfo::set_has_fast_checkout_action() {
  _oneof_case_[0] = kFastCheckoutAction;
}
inline ::autofill_assistant::fast_checkout::FastCheckoutAction* ActionInfo::release_fast_checkout_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.ActionInfo.fast_checkout_action)
  if (_internal_has_fast_checkout_action()) {
    clear_has_action();
    ::autofill_assistant::fast_checkout::FastCheckoutAction* temp = action_.fast_checkout_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.fast_checkout_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::fast_checkout::FastCheckoutAction& ActionInfo::_internal_fast_checkout_action() const {
  return _internal_has_fast_checkout_action()
      ? *action_.fast_checkout_action_
      : reinterpret_cast< ::autofill_assistant::fast_checkout::FastCheckoutAction&>(::autofill_assistant::fast_checkout::_FastCheckoutAction_default_instance_);
}
inline const ::autofill_assistant::fast_checkout::FastCheckoutAction& ActionInfo::fast_checkout_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.ActionInfo.fast_checkout_action)
  return _internal_fast_checkout_action();
}
inline ::autofill_assistant::fast_checkout::FastCheckoutAction* ActionInfo::unsafe_arena_release_fast_checkout_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.external.ActionInfo.fast_checkout_action)
  if (_internal_has_fast_checkout_action()) {
    clear_has_action();
    ::autofill_assistant::fast_checkout::FastCheckoutAction* temp = action_.fast_checkout_action_;
    action_.fast_checkout_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionInfo::unsafe_arena_set_allocated_fast_checkout_action(::autofill_assistant::fast_checkout::FastCheckoutAction* fast_checkout_action) {
  clear_action();
  if (fast_checkout_action) {
    set_has_fast_checkout_action();
    action_.fast_checkout_action_ = fast_checkout_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.external.ActionInfo.fast_checkout_action)
}
inline ::autofill_assistant::fast_checkout::FastCheckoutAction* ActionInfo::_internal_mutable_fast_checkout_action() {
  if (!_internal_has_fast_checkout_action()) {
    clear_action();
    set_has_fast_checkout_action();
    action_.fast_checkout_action_ = CreateMaybeMessage< ::autofill_assistant::fast_checkout::FastCheckoutAction >(GetArenaForAllocation());
  }
  return action_.fast_checkout_action_;
}
inline ::autofill_assistant::fast_checkout::FastCheckoutAction* ActionInfo::mutable_fast_checkout_action() {
  ::autofill_assistant::fast_checkout::FastCheckoutAction* _msg = _internal_mutable_fast_checkout_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.ActionInfo.fast_checkout_action)
  return _msg;
}

inline bool ActionInfo::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionInfo::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionInfo::ActionCase ActionInfo::action_case() const {
  return ActionInfo::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProfileProto

// map<int32, string> values = 1;
inline int ProfileProto::_internal_values_size() const {
  return values_.size();
}
inline int ProfileProto::values_size() const {
  return _internal_values_size();
}
inline void ProfileProto::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
ProfileProto::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
ProfileProto::values() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.external.ProfileProto.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
ProfileProto::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
ProfileProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.external.ProfileProto.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreditCardProto

// map<int32, string> values = 1;
inline int CreditCardProto::_internal_values_size() const {
  return values_.size();
}
inline int CreditCardProto::values_size() const {
  return _internal_values_size();
}
inline void CreditCardProto::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
CreditCardProto::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >&
CreditCardProto::values() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.external.CreditCardProto.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
CreditCardProto::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, std::string >*
CreditCardProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.external.CreditCardProto.values)
  return _internal_mutable_values();
}

// optional int64 record_type = 2;
inline bool CreditCardProto::_internal_has_record_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CreditCardProto::has_record_type() const {
  return _internal_has_record_type();
}
inline void CreditCardProto::clear_record_type() {
  record_type_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t CreditCardProto::_internal_record_type() const {
  return record_type_;
}
inline int64_t CreditCardProto::record_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.CreditCardProto.record_type)
  return _internal_record_type();
}
inline void CreditCardProto::_internal_set_record_type(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  record_type_ = value;
}
inline void CreditCardProto::set_record_type(int64_t value) {
  _internal_set_record_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.external.CreditCardProto.record_type)
}

// optional int64 instrument_id = 3;
inline bool CreditCardProto::_internal_has_instrument_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CreditCardProto::has_instrument_id() const {
  return _internal_has_instrument_id();
}
inline void CreditCardProto::clear_instrument_id() {
  instrument_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t CreditCardProto::_internal_instrument_id() const {
  return instrument_id_;
}
inline int64_t CreditCardProto::instrument_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.CreditCardProto.instrument_id)
  return _internal_instrument_id();
}
inline void CreditCardProto::_internal_set_instrument_id(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  instrument_id_ = value;
}
inline void CreditCardProto::set_instrument_id(int64_t value) {
  _internal_set_instrument_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.external.CreditCardProto.instrument_id)
}

// optional string network = 4;
inline bool CreditCardProto::_internal_has_network() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreditCardProto::has_network() const {
  return _internal_has_network();
}
inline void CreditCardProto::clear_network() {
  network_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreditCardProto::network() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.CreditCardProto.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreditCardProto::set_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.external.CreditCardProto.network)
}
inline std::string* CreditCardProto::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.CreditCardProto.network)
  return _s;
}
inline const std::string& CreditCardProto::_internal_network() const {
  return network_.Get();
}
inline void CreditCardProto::_internal_set_network(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  network_.Set(value, GetArenaForAllocation());
}
inline std::string* CreditCardProto::_internal_mutable_network() {
  _has_bits_[0] |= 0x00000001u;
  return network_.Mutable(GetArenaForAllocation());
}
inline std::string* CreditCardProto::release_network() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.CreditCardProto.network)
  if (!_internal_has_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = network_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault()) {
    network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreditCardProto::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault()) {
    network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.external.CreditCardProto.network)
}

// optional string server_id = 5 [deprecated = true];
inline bool CreditCardProto::_internal_has_server_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreditCardProto::has_server_id() const {
  return _internal_has_server_id();
}
inline void CreditCardProto::clear_server_id() {
  server_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreditCardProto::server_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.CreditCardProto.server_id)
  return _internal_server_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreditCardProto::set_server_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 server_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.external.CreditCardProto.server_id)
}
inline std::string* CreditCardProto::mutable_server_id() {
  std::string* _s = _internal_mutable_server_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.CreditCardProto.server_id)
  return _s;
}
inline const std::string& CreditCardProto::_internal_server_id() const {
  return server_id_.Get();
}
inline void CreditCardProto::_internal_set_server_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  server_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreditCardProto::_internal_mutable_server_id() {
  _has_bits_[0] |= 0x00000002u;
  return server_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreditCardProto::release_server_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.CreditCardProto.server_id)
  if (!_internal_has_server_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = server_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault()) {
    server_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreditCardProto::set_allocated_server_id(std::string* server_id) {
  if (server_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  server_id_.SetAllocated(server_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_id_.IsDefault()) {
    server_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.external.CreditCardProto.server_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Result

// optional .autofill_assistant.external.ResultInfo result_info = 1;
inline bool Result::_internal_has_result_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_info_ != nullptr);
  return value;
}
inline bool Result::has_result_info() const {
  return _internal_has_result_info();
}
inline void Result::clear_result_info() {
  if (result_info_ != nullptr) result_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::external::ResultInfo& Result::_internal_result_info() const {
  const ::autofill_assistant::external::ResultInfo* p = result_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::external::ResultInfo&>(
      ::autofill_assistant::external::_ResultInfo_default_instance_);
}
inline const ::autofill_assistant::external::ResultInfo& Result::result_info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.Result.result_info)
  return _internal_result_info();
}
inline void Result::unsafe_arena_set_allocated_result_info(
    ::autofill_assistant::external::ResultInfo* result_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_info_);
  }
  result_info_ = result_info;
  if (result_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.external.Result.result_info)
}
inline ::autofill_assistant::external::ResultInfo* Result::release_result_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ResultInfo* temp = result_info_;
  result_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::external::ResultInfo* Result::unsafe_arena_release_result_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.Result.result_info)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ResultInfo* temp = result_info_;
  result_info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::external::ResultInfo* Result::_internal_mutable_result_info() {
  _has_bits_[0] |= 0x00000001u;
  if (result_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::external::ResultInfo>(GetArenaForAllocation());
    result_info_ = p;
  }
  return result_info_;
}
inline ::autofill_assistant::external::ResultInfo* Result::mutable_result_info() {
  ::autofill_assistant::external::ResultInfo* _msg = _internal_mutable_result_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.Result.result_info)
  return _msg;
}
inline void Result::set_allocated_result_info(::autofill_assistant::external::ResultInfo* result_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_info_;
  }
  if (result_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_info);
    if (message_arena != submessage_arena) {
      result_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_info_ = result_info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.external.Result.result_info)
}

// optional bool success = 2;
inline bool Result::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Result::has_success() const {
  return _internal_has_success();
}
inline void Result::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Result::_internal_success() const {
  return success_;
}
inline bool Result::success() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.Result.success)
  return _internal_success();
}
inline void Result::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000004u;
  success_ = value;
}
inline void Result::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.external.Result.success)
}

// map<string, .autofill_assistant.external.ProfileProto> selected_profiles = 3;
inline int Result::_internal_selected_profiles_size() const {
  return selected_profiles_.size();
}
inline int Result::selected_profiles_size() const {
  return _internal_selected_profiles_size();
}
inline void Result::clear_selected_profiles() {
  selected_profiles_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >&
Result::_internal_selected_profiles() const {
  return selected_profiles_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >&
Result::selected_profiles() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.external.Result.selected_profiles)
  return _internal_selected_profiles();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >*
Result::_internal_mutable_selected_profiles() {
  return selected_profiles_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill_assistant::external::ProfileProto >*
Result::mutable_selected_profiles() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.external.Result.selected_profiles)
  return _internal_mutable_selected_profiles();
}

// optional .autofill_assistant.external.CreditCardProto selected_credit_card = 4;
inline bool Result::_internal_has_selected_credit_card() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || selected_credit_card_ != nullptr);
  return value;
}
inline bool Result::has_selected_credit_card() const {
  return _internal_has_selected_credit_card();
}
inline void Result::clear_selected_credit_card() {
  if (selected_credit_card_ != nullptr) selected_credit_card_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::external::CreditCardProto& Result::_internal_selected_credit_card() const {
  const ::autofill_assistant::external::CreditCardProto* p = selected_credit_card_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::external::CreditCardProto&>(
      ::autofill_assistant::external::_CreditCardProto_default_instance_);
}
inline const ::autofill_assistant::external::CreditCardProto& Result::selected_credit_card() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.Result.selected_credit_card)
  return _internal_selected_credit_card();
}
inline void Result::unsafe_arena_set_allocated_selected_credit_card(
    ::autofill_assistant::external::CreditCardProto* selected_credit_card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(selected_credit_card_);
  }
  selected_credit_card_ = selected_credit_card;
  if (selected_credit_card) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.external.Result.selected_credit_card)
}
inline ::autofill_assistant::external::CreditCardProto* Result::release_selected_credit_card() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::external::CreditCardProto* temp = selected_credit_card_;
  selected_credit_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::external::CreditCardProto* Result::unsafe_arena_release_selected_credit_card() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.Result.selected_credit_card)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::external::CreditCardProto* temp = selected_credit_card_;
  selected_credit_card_ = nullptr;
  return temp;
}
inline ::autofill_assistant::external::CreditCardProto* Result::_internal_mutable_selected_credit_card() {
  _has_bits_[0] |= 0x00000002u;
  if (selected_credit_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::external::CreditCardProto>(GetArenaForAllocation());
    selected_credit_card_ = p;
  }
  return selected_credit_card_;
}
inline ::autofill_assistant::external::CreditCardProto* Result::mutable_selected_credit_card() {
  ::autofill_assistant::external::CreditCardProto* _msg = _internal_mutable_selected_credit_card();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.Result.selected_credit_card)
  return _msg;
}
inline void Result::set_allocated_selected_credit_card(::autofill_assistant::external::CreditCardProto* selected_credit_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete selected_credit_card_;
  }
  if (selected_credit_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selected_credit_card);
    if (message_arena != submessage_arena) {
      selected_credit_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected_credit_card, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  selected_credit_card_ = selected_credit_card;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.external.Result.selected_credit_card)
}

// -------------------------------------------------------------------

// ResultInfo

// .autofill_assistant.password_change.GenericPasswordChangeSpecificationResult generic_password_change_specification_result = 1;
inline bool ResultInfo::_internal_has_generic_password_change_specification_result() const {
  return result_case() == kGenericPasswordChangeSpecificationResult;
}
inline bool ResultInfo::has_generic_password_change_specification_result() const {
  return _internal_has_generic_password_change_specification_result();
}
inline void ResultInfo::set_has_generic_password_change_specification_result() {
  _oneof_case_[0] = kGenericPasswordChangeSpecificationResult;
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* ResultInfo::release_generic_password_change_specification_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.external.ResultInfo.generic_password_change_specification_result)
  if (_internal_has_generic_password_change_specification_result()) {
    clear_has_result();
    ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* temp = result_.generic_password_change_specification_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_.generic_password_change_specification_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult& ResultInfo::_internal_generic_password_change_specification_result() const {
  return _internal_has_generic_password_change_specification_result()
      ? *result_.generic_password_change_specification_result_
      : reinterpret_cast< ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult&>(::autofill_assistant::password_change::_GenericPasswordChangeSpecificationResult_default_instance_);
}
inline const ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult& ResultInfo::generic_password_change_specification_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.ResultInfo.generic_password_change_specification_result)
  return _internal_generic_password_change_specification_result();
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* ResultInfo::unsafe_arena_release_generic_password_change_specification_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.external.ResultInfo.generic_password_change_specification_result)
  if (_internal_has_generic_password_change_specification_result()) {
    clear_has_result();
    ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* temp = result_.generic_password_change_specification_result_;
    result_.generic_password_change_specification_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResultInfo::unsafe_arena_set_allocated_generic_password_change_specification_result(::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* generic_password_change_specification_result) {
  clear_result();
  if (generic_password_change_specification_result) {
    set_has_generic_password_change_specification_result();
    result_.generic_password_change_specification_result_ = generic_password_change_specification_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.external.ResultInfo.generic_password_change_specification_result)
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* ResultInfo::_internal_mutable_generic_password_change_specification_result() {
  if (!_internal_has_generic_password_change_specification_result()) {
    clear_result();
    set_has_generic_password_change_specification_result();
    result_.generic_password_change_specification_result_ = CreateMaybeMessage< ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult >(GetArenaForAllocation());
  }
  return result_.generic_password_change_specification_result_;
}
inline ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* ResultInfo::mutable_generic_password_change_specification_result() {
  ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* _msg = _internal_mutable_generic_password_change_specification_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.ResultInfo.generic_password_change_specification_result)
  return _msg;
}

inline bool ResultInfo::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void ResultInfo::clear_has_result() {
  _oneof_case_[0] = RESULT_NOT_SET;
}
inline ResultInfo::ResultCase ResultInfo::result_case() const {
  return ResultInfo::ResultCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ElementConditionsUpdate_ConditionResult

// optional int32 id = 1;
inline bool ElementConditionsUpdate_ConditionResult::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElementConditionsUpdate_ConditionResult::has_id() const {
  return _internal_has_id();
}
inline void ElementConditionsUpdate_ConditionResult::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ElementConditionsUpdate_ConditionResult::_internal_id() const {
  return id_;
}
inline int32_t ElementConditionsUpdate_ConditionResult::id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.ElementConditionsUpdate.ConditionResult.id)
  return _internal_id();
}
inline void ElementConditionsUpdate_ConditionResult::_internal_set_id(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void ElementConditionsUpdate_ConditionResult::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.external.ElementConditionsUpdate.ConditionResult.id)
}

// optional bool satisfied = 2;
inline bool ElementConditionsUpdate_ConditionResult::_internal_has_satisfied() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ElementConditionsUpdate_ConditionResult::has_satisfied() const {
  return _internal_has_satisfied();
}
inline void ElementConditionsUpdate_ConditionResult::clear_satisfied() {
  satisfied_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ElementConditionsUpdate_ConditionResult::_internal_satisfied() const {
  return satisfied_;
}
inline bool ElementConditionsUpdate_ConditionResult::satisfied() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.ElementConditionsUpdate.ConditionResult.satisfied)
  return _internal_satisfied();
}
inline void ElementConditionsUpdate_ConditionResult::_internal_set_satisfied(bool value) {
  _has_bits_[0] |= 0x00000002u;
  satisfied_ = value;
}
inline void ElementConditionsUpdate_ConditionResult::set_satisfied(bool value) {
  _internal_set_satisfied(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.external.ElementConditionsUpdate.ConditionResult.satisfied)
}

// -------------------------------------------------------------------

// ElementConditionsUpdate

// repeated .autofill_assistant.external.ElementConditionsUpdate.ConditionResult results = 1;
inline int ElementConditionsUpdate::_internal_results_size() const {
  return results_.size();
}
inline int ElementConditionsUpdate::results_size() const {
  return _internal_results_size();
}
inline void ElementConditionsUpdate::clear_results() {
  results_.Clear();
}
inline ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* ElementConditionsUpdate::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.external.ElementConditionsUpdate.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult >*
ElementConditionsUpdate::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.external.ElementConditionsUpdate.results)
  return &results_;
}
inline const ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult& ElementConditionsUpdate::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult& ElementConditionsUpdate::results(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.external.ElementConditionsUpdate.results)
  return _internal_results(index);
}
inline ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* ElementConditionsUpdate::_internal_add_results() {
  return results_.Add();
}
inline ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* ElementConditionsUpdate::add_results() {
  ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:autofill_assistant.external.ElementConditionsUpdate.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::external::ElementConditionsUpdate_ConditionResult >&
ElementConditionsUpdate::results() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.external.ElementConditionsUpdate.results)
  return results_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace external
}  // namespace autofill_assistant

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fexternal_5faction_2eproto
