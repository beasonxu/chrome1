// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "components/autofill_assistant/browser/action_strategy.pb.h"
#include "components/autofill_assistant/browser/action_value.pb.h"
#include "components/autofill_assistant/browser/cud_condition.pb.h"
#include "components/autofill_assistant/browser/dom_action.pb.h"
#include "components/autofill_assistant/browser/generic_ui.pb.h"
#include "components/autofill_assistant/browser/model.pb.h"
#include "components/autofill_assistant/browser/view_layout.pb.h"
#include "components/autofill_assistant/content/common/proto/semantic_feature_overrides.pb.h"
#include "components/autofill_assistant/browser/public/external_action.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
class ActionProto;
struct ActionProtoDefaultTypeInternal;
extern ActionProtoDefaultTypeInternal _ActionProto_default_instance_;
class ActionTimingStats;
struct ActionTimingStatsDefaultTypeInternal;
extern ActionTimingStatsDefaultTypeInternal _ActionTimingStats_default_instance_;
class ActionsResponseProto;
struct ActionsResponseProtoDefaultTypeInternal;
extern ActionsResponseProtoDefaultTypeInternal _ActionsResponseProto_default_instance_;
class ActionsResponseProto_UpdateScriptListProto;
struct ActionsResponseProto_UpdateScriptListProtoDefaultTypeInternal;
extern ActionsResponseProto_UpdateScriptListProtoDefaultTypeInternal _ActionsResponseProto_UpdateScriptListProto_default_instance_;
class AutofillEntryProto;
struct AutofillEntryProtoDefaultTypeInternal;
extern AutofillEntryProtoDefaultTypeInternal _AutofillEntryProto_default_instance_;
class AutofillErrorInfoProto;
struct AutofillErrorInfoProtoDefaultTypeInternal;
extern AutofillErrorInfoProtoDefaultTypeInternal _AutofillErrorInfoProto_default_instance_;
class AutofillErrorInfoProto_AutofillFieldError;
struct AutofillErrorInfoProto_AutofillFieldErrorDefaultTypeInternal;
extern AutofillErrorInfoProto_AutofillFieldErrorDefaultTypeInternal _AutofillErrorInfoProto_AutofillFieldError_default_instance_;
class CUPRequestData;
struct CUPRequestDataDefaultTypeInternal;
extern CUPRequestDataDefaultTypeInternal _CUPRequestData_default_instance_;
class CUPResponseData;
struct CUPResponseDataDefaultTypeInternal;
extern CUPResponseDataDefaultTypeInternal _CUPResponseData_default_instance_;
class ClearPersistentUiProto;
struct ClearPersistentUiProtoDefaultTypeInternal;
extern ClearPersistentUiProtoDefaultTypeInternal _ClearPersistentUiProto_default_instance_;
class ClientContextProto;
struct ClientContextProtoDefaultTypeInternal;
extern ClientContextProtoDefaultTypeInternal _ClientContextProto_default_instance_;
class ClientContextProto_AnnotateDomModelContextProto;
struct ClientContextProto_AnnotateDomModelContextProtoDefaultTypeInternal;
extern ClientContextProto_AnnotateDomModelContextProtoDefaultTypeInternal _ClientContextProto_AnnotateDomModelContextProto_default_instance_;
class ClientContextProto_Chrome;
struct ClientContextProto_ChromeDefaultTypeInternal;
extern ClientContextProto_ChromeDefaultTypeInternal _ClientContextProto_Chrome_default_instance_;
class ClientContextProto_DeviceContextProto;
struct ClientContextProto_DeviceContextProtoDefaultTypeInternal;
extern ClientContextProto_DeviceContextProtoDefaultTypeInternal _ClientContextProto_DeviceContextProto_default_instance_;
class ClientContextProto_DeviceContextProto_VersionProto;
struct ClientContextProto_DeviceContextProto_VersionProtoDefaultTypeInternal;
extern ClientContextProto_DeviceContextProto_VersionProtoDefaultTypeInternal _ClientContextProto_DeviceContextProto_VersionProto_default_instance_;
class ClientContextProto_WindowSize;
struct ClientContextProto_WindowSizeDefaultTypeInternal;
extern ClientContextProto_WindowSizeDefaultTypeInternal _ClientContextProto_WindowSize_default_instance_;
class ClientSettingsProto;
struct ClientSettingsProtoDefaultTypeInternal;
extern ClientSettingsProtoDefaultTypeInternal _ClientSettingsProto_default_instance_;
class ClientSettingsProto_BackButtonSettings;
struct ClientSettingsProto_BackButtonSettingsDefaultTypeInternal;
extern ClientSettingsProto_BackButtonSettingsDefaultTypeInternal _ClientSettingsProto_BackButtonSettings_default_instance_;
class ClientSettingsProto_DisplayString;
struct ClientSettingsProto_DisplayStringDefaultTypeInternal;
extern ClientSettingsProto_DisplayStringDefaultTypeInternal _ClientSettingsProto_DisplayString_default_instance_;
class ClientSettingsProto_IntegrationTestSettings;
struct ClientSettingsProto_IntegrationTestSettingsDefaultTypeInternal;
extern ClientSettingsProto_IntegrationTestSettingsDefaultTypeInternal _ClientSettingsProto_IntegrationTestSettings_default_instance_;
class ClientSettingsProto_SlowWarningSettings;
struct ClientSettingsProto_SlowWarningSettingsDefaultTypeInternal;
extern ClientSettingsProto_SlowWarningSettingsDefaultTypeInternal _ClientSettingsProto_SlowWarningSettings_default_instance_;
class CollectUserDataProto;
struct CollectUserDataProtoDefaultTypeInternal;
extern CollectUserDataProtoDefaultTypeInternal _CollectUserDataProto_default_instance_;
class CollectUserDataProto_DataSource;
struct CollectUserDataProto_DataSourceDefaultTypeInternal;
extern CollectUserDataProto_DataSourceDefaultTypeInternal _CollectUserDataProto_DataSource_default_instance_;
class CollectUserDataResultProto;
struct CollectUserDataResultProtoDefaultTypeInternal;
extern CollectUserDataResultProtoDefaultTypeInternal _CollectUserDataResultProto_default_instance_;
class ConfigureBottomSheetProto;
struct ConfigureBottomSheetProtoDefaultTypeInternal;
extern ConfigureBottomSheetProtoDefaultTypeInternal _ConfigureBottomSheetProto_default_instance_;
class ConfigureUiStateProto;
struct ConfigureUiStateProtoDefaultTypeInternal;
extern ConfigureUiStateProtoDefaultTypeInternal _ConfigureUiStateProto_default_instance_;
class ContactDetailsProto;
struct ContactDetailsProtoDefaultTypeInternal;
extern ContactDetailsProtoDefaultTypeInternal _ContactDetailsProto_default_instance_;
class CounterInputProto;
struct CounterInputProtoDefaultTypeInternal;
extern CounterInputProtoDefaultTypeInternal _CounterInputProto_default_instance_;
class CounterInputProto_Counter;
struct CounterInputProto_CounterDefaultTypeInternal;
extern CounterInputProto_CounterDefaultTypeInternal _CounterInputProto_Counter_default_instance_;
class CounterInputProto_Result;
struct CounterInputProto_ResultDefaultTypeInternal;
extern CounterInputProto_ResultDefaultTypeInternal _CounterInputProto_Result_default_instance_;
class CounterInputProto_ValidationRule;
struct CounterInputProto_ValidationRuleDefaultTypeInternal;
extern CounterInputProto_ValidationRuleDefaultTypeInternal _CounterInputProto_ValidationRule_default_instance_;
class CounterInputProto_ValidationRule_BooleanRule;
struct CounterInputProto_ValidationRule_BooleanRuleDefaultTypeInternal;
extern CounterInputProto_ValidationRule_BooleanRuleDefaultTypeInternal _CounterInputProto_ValidationRule_BooleanRule_default_instance_;
class CounterInputProto_ValidationRule_CounterRule;
struct CounterInputProto_ValidationRule_CounterRuleDefaultTypeInternal;
extern CounterInputProto_ValidationRule_CounterRuleDefaultTypeInternal _CounterInputProto_ValidationRule_CounterRule_default_instance_;
class CounterInputProto_ValidationRule_CountersSumRule;
struct CounterInputProto_ValidationRule_CountersSumRuleDefaultTypeInternal;
extern CounterInputProto_ValidationRule_CountersSumRuleDefaultTypeInternal _CounterInputProto_ValidationRule_CountersSumRule_default_instance_;
class DataOriginNoticeProto;
struct DataOriginNoticeProtoDefaultTypeInternal;
extern DataOriginNoticeProtoDefaultTypeInternal _DataOriginNoticeProto_default_instance_;
class DeleteSelectedPasswordProto;
struct DeleteSelectedPasswordProtoDefaultTypeInternal;
extern DeleteSelectedPasswordProtoDefaultTypeInternal _DeleteSelectedPasswordProto_default_instance_;
class DetailsChangesProto;
struct DetailsChangesProtoDefaultTypeInternal;
extern DetailsChangesProtoDefaultTypeInternal _DetailsChangesProto_default_instance_;
class DetailsProto;
struct DetailsProtoDefaultTypeInternal;
extern DetailsProtoDefaultTypeInternal _DetailsProto_default_instance_;
class DetailsProto_ImageClickthroughData;
struct DetailsProto_ImageClickthroughDataDefaultTypeInternal;
extern DetailsProto_ImageClickthroughDataDefaultTypeInternal _DetailsProto_ImageClickthroughData_default_instance_;
class DetailsProto_PlaceholdersConfiguration;
struct DetailsProto_PlaceholdersConfigurationDefaultTypeInternal;
extern DetailsProto_PlaceholdersConfigurationDefaultTypeInternal _DetailsProto_PlaceholdersConfiguration_default_instance_;
class DispatchJsEventProto;
struct DispatchJsEventProtoDefaultTypeInternal;
extern DispatchJsEventProtoDefaultTypeInternal _DispatchJsEventProto_default_instance_;
class EditSelectedPasswordProto;
struct EditSelectedPasswordProtoDefaultTypeInternal;
extern EditSelectedPasswordProtoDefaultTypeInternal _EditSelectedPasswordProto_default_instance_;
class ElementAreaProto;
struct ElementAreaProtoDefaultTypeInternal;
extern ElementAreaProtoDefaultTypeInternal _ElementAreaProto_default_instance_;
class ElementAreaProto_Rectangle;
struct ElementAreaProto_RectangleDefaultTypeInternal;
extern ElementAreaProto_RectangleDefaultTypeInternal _ElementAreaProto_Rectangle_default_instance_;
class ElementConditionProto;
struct ElementConditionProtoDefaultTypeInternal;
extern ElementConditionProtoDefaultTypeInternal _ElementConditionProto_default_instance_;
class ElementConditionsProto;
struct ElementConditionsProtoDefaultTypeInternal;
extern ElementConditionsProtoDefaultTypeInternal _ElementConditionsProto_default_instance_;
class ElementFinderInfoProto;
struct ElementFinderInfoProtoDefaultTypeInternal;
extern ElementFinderInfoProtoDefaultTypeInternal _ElementFinderInfoProto_default_instance_;
class ElementFinderInfoProto_PredictedElement;
struct ElementFinderInfoProto_PredictedElementDefaultTypeInternal;
extern ElementFinderInfoProto_PredictedElementDefaultTypeInternal _ElementFinderInfoProto_PredictedElement_default_instance_;
class ElementFinderInfoProto_SemanticInferenceResult;
struct ElementFinderInfoProto_SemanticInferenceResultDefaultTypeInternal;
extern ElementFinderInfoProto_SemanticInferenceResultDefaultTypeInternal _ElementFinderInfoProto_SemanticInferenceResult_default_instance_;
class ExpectNavigationProto;
struct ExpectNavigationProtoDefaultTypeInternal;
extern ExpectNavigationProtoDefaultTypeInternal _ExpectNavigationProto_default_instance_;
class ExternalActionProto;
struct ExternalActionProtoDefaultTypeInternal;
extern ExternalActionProtoDefaultTypeInternal _ExternalActionProto_default_instance_;
class ExternalActionProto_ExternalCondition;
struct ExternalActionProto_ExternalConditionDefaultTypeInternal;
extern ExternalActionProto_ExternalConditionDefaultTypeInternal _ExternalActionProto_ExternalCondition_default_instance_;
class ExternalActionProto_Result;
struct ExternalActionProto_ResultDefaultTypeInternal;
extern ExternalActionProto_ResultDefaultTypeInternal _ExternalActionProto_Result_default_instance_;
class FieldTrialProto;
struct FieldTrialProtoDefaultTypeInternal;
extern FieldTrialProtoDefaultTypeInternal _FieldTrialProto_default_instance_;
class FormInputProto;
struct FormInputProtoDefaultTypeInternal;
extern FormInputProtoDefaultTypeInternal _FormInputProto_default_instance_;
class FormInputProto_Result;
struct FormInputProto_ResultDefaultTypeInternal;
extern FormInputProto_ResultDefaultTypeInternal _FormInputProto_Result_default_instance_;
class FormProto;
struct FormProtoDefaultTypeInternal;
extern FormProtoDefaultTypeInternal _FormProto_default_instance_;
class FormProto_Result;
struct FormProto_ResultDefaultTypeInternal;
extern FormProto_ResultDefaultTypeInternal _FormProto_Result_default_instance_;
class GeneratePasswordForFormFieldProto;
struct GeneratePasswordForFormFieldProtoDefaultTypeInternal;
extern GeneratePasswordForFormFieldProtoDefaultTypeInternal _GeneratePasswordForFormFieldProto_default_instance_;
class GetCapabilitiesByHashPrefixRequestProto;
struct GetCapabilitiesByHashPrefixRequestProtoDefaultTypeInternal;
extern GetCapabilitiesByHashPrefixRequestProtoDefaultTypeInternal _GetCapabilitiesByHashPrefixRequestProto_default_instance_;
class GetCapabilitiesByHashPrefixResponseProto;
struct GetCapabilitiesByHashPrefixResponseProtoDefaultTypeInternal;
extern GetCapabilitiesByHashPrefixResponseProtoDefaultTypeInternal _GetCapabilitiesByHashPrefixResponseProto_default_instance_;
class GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto;
struct GetCapabilitiesByHashPrefixResponseProto_MatchInfoProtoDefaultTypeInternal;
extern GetCapabilitiesByHashPrefixResponseProto_MatchInfoProtoDefaultTypeInternal _GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto_default_instance_;
class GetElementStatusProto;
struct GetElementStatusProtoDefaultTypeInternal;
extern GetElementStatusProtoDefaultTypeInternal _GetElementStatusProto_default_instance_;
class GetElementStatusProto_ComparisonReport;
struct GetElementStatusProto_ComparisonReportDefaultTypeInternal;
extern GetElementStatusProto_ComparisonReportDefaultTypeInternal _GetElementStatusProto_ComparisonReport_default_instance_;
class GetElementStatusProto_MatchExpectation;
struct GetElementStatusProto_MatchExpectationDefaultTypeInternal;
extern GetElementStatusProto_MatchExpectationDefaultTypeInternal _GetElementStatusProto_MatchExpectation_default_instance_;
class GetElementStatusProto_MatchOptions;
struct GetElementStatusProto_MatchOptionsDefaultTypeInternal;
extern GetElementStatusProto_MatchOptionsDefaultTypeInternal _GetElementStatusProto_MatchOptions_default_instance_;
class GetElementStatusProto_Result;
struct GetElementStatusProto_ResultDefaultTypeInternal;
extern GetElementStatusProto_ResultDefaultTypeInternal _GetElementStatusProto_Result_default_instance_;
class GetElementStatusProto_TextMatch;
struct GetElementStatusProto_TextMatchDefaultTypeInternal;
extern GetElementStatusProto_TextMatchDefaultTypeInternal _GetElementStatusProto_TextMatch_default_instance_;
class GetElementStatusProto_ValueMatch;
struct GetElementStatusProto_ValueMatchDefaultTypeInternal;
extern GetElementStatusProto_ValueMatchDefaultTypeInternal _GetElementStatusProto_ValueMatch_default_instance_;
class GetTriggerScriptsRequestProto;
struct GetTriggerScriptsRequestProtoDefaultTypeInternal;
extern GetTriggerScriptsRequestProtoDefaultTypeInternal _GetTriggerScriptsRequestProto_default_instance_;
class GetTriggerScriptsResponseProto;
struct GetTriggerScriptsResponseProtoDefaultTypeInternal;
extern GetTriggerScriptsResponseProtoDefaultTypeInternal _GetTriggerScriptsResponseProto_default_instance_;
class GetUserDataRequestProto;
struct GetUserDataRequestProtoDefaultTypeInternal;
extern GetUserDataRequestProtoDefaultTypeInternal _GetUserDataRequestProto_default_instance_;
class GetUserDataRequestProto_AddressRequest;
struct GetUserDataRequestProto_AddressRequestDefaultTypeInternal;
extern GetUserDataRequestProto_AddressRequestDefaultTypeInternal _GetUserDataRequestProto_AddressRequest_default_instance_;
class GetUserDataRequestProto_PaymentMethodRequest;
struct GetUserDataRequestProto_PaymentMethodRequestDefaultTypeInternal;
extern GetUserDataRequestProto_PaymentMethodRequestDefaultTypeInternal _GetUserDataRequestProto_PaymentMethodRequest_default_instance_;
class GetUserDataResponseProto;
struct GetUserDataResponseProtoDefaultTypeInternal;
extern GetUserDataResponseProtoDefaultTypeInternal _GetUserDataResponseProto_default_instance_;
class ImplicitTriggeringDebugParametersProto;
struct ImplicitTriggeringDebugParametersProtoDefaultTypeInternal;
extern ImplicitTriggeringDebugParametersProtoDefaultTypeInternal _ImplicitTriggeringDebugParametersProto_default_instance_;
class InfoBoxProto;
struct InfoBoxProtoDefaultTypeInternal;
extern InfoBoxProtoDefaultTypeInternal _InfoBoxProto_default_instance_;
class InitialScriptActionsRequestProto;
struct InitialScriptActionsRequestProtoDefaultTypeInternal;
extern InitialScriptActionsRequestProtoDefaultTypeInternal _InitialScriptActionsRequestProto_default_instance_;
class InitialScriptActionsRequestProto_QueryProto;
struct InitialScriptActionsRequestProto_QueryProtoDefaultTypeInternal;
extern InitialScriptActionsRequestProto_QueryProtoDefaultTypeInternal _InitialScriptActionsRequestProto_QueryProto_default_instance_;
class JsFlowProto;
struct JsFlowProtoDefaultTypeInternal;
extern JsFlowProtoDefaultTypeInternal _JsFlowProto_default_instance_;
class JsFlowProto_Result;
struct JsFlowProto_ResultDefaultTypeInternal;
extern JsFlowProto_ResultDefaultTypeInternal _JsFlowProto_Result_default_instance_;
class LoginDetailsProto;
struct LoginDetailsProtoDefaultTypeInternal;
extern LoginDetailsProtoDefaultTypeInternal _LoginDetailsProto_default_instance_;
class LoginDetailsProto_LoginOptionCustomProto;
struct LoginDetailsProto_LoginOptionCustomProtoDefaultTypeInternal;
extern LoginDetailsProto_LoginOptionCustomProtoDefaultTypeInternal _LoginDetailsProto_LoginOptionCustomProto_default_instance_;
class LoginDetailsProto_LoginOptionPasswordManagerProto;
struct LoginDetailsProto_LoginOptionPasswordManagerProtoDefaultTypeInternal;
extern LoginDetailsProto_LoginOptionPasswordManagerProtoDefaultTypeInternal _LoginDetailsProto_LoginOptionPasswordManagerProto_default_instance_;
class LoginDetailsProto_LoginOptionProto;
struct LoginDetailsProto_LoginOptionProtoDefaultTypeInternal;
extern LoginDetailsProto_LoginOptionProtoDefaultTypeInternal _LoginDetailsProto_LoginOptionProto_default_instance_;
class NavigateProto;
struct NavigateProtoDefaultTypeInternal;
extern NavigateProtoDefaultTypeInternal _NavigateProto_default_instance_;
class NavigationInfoProto;
struct NavigationInfoProtoDefaultTypeInternal;
extern NavigationInfoProtoDefaultTypeInternal _NavigationInfoProto_default_instance_;
class NextScriptActionsRequestProto;
struct NextScriptActionsRequestProtoDefaultTypeInternal;
extern NextScriptActionsRequestProtoDefaultTypeInternal _NextScriptActionsRequestProto_default_instance_;
class OverlayImageProto;
struct OverlayImageProtoDefaultTypeInternal;
extern OverlayImageProtoDefaultTypeInternal _OverlayImageProto_default_instance_;
class PaymentInstrumentProto;
struct PaymentInstrumentProtoDefaultTypeInternal;
extern PaymentInstrumentProtoDefaultTypeInternal _PaymentInstrumentProto_default_instance_;
class PaymentInstrumentProto_AddressValuesEntry_DoNotUse;
struct PaymentInstrumentProto_AddressValuesEntry_DoNotUseDefaultTypeInternal;
extern PaymentInstrumentProto_AddressValuesEntry_DoNotUseDefaultTypeInternal _PaymentInstrumentProto_AddressValuesEntry_DoNotUse_default_instance_;
class PaymentInstrumentProto_CardValuesEntry_DoNotUse;
struct PaymentInstrumentProto_CardValuesEntry_DoNotUseDefaultTypeInternal;
extern PaymentInstrumentProto_CardValuesEntry_DoNotUseDefaultTypeInternal _PaymentInstrumentProto_CardValuesEntry_DoNotUse_default_instance_;
class PhoneNumberProto;
struct PhoneNumberProtoDefaultTypeInternal;
extern PhoneNumberProtoDefaultTypeInternal _PhoneNumberProto_default_instance_;
class PopupListSectionProto;
struct PopupListSectionProtoDefaultTypeInternal;
extern PopupListSectionProtoDefaultTypeInternal _PopupListSectionProto_default_instance_;
class PopupMessageProto;
struct PopupMessageProtoDefaultTypeInternal;
extern PopupMessageProtoDefaultTypeInternal _PopupMessageProto_default_instance_;
class PresaveGeneratedPasswordProto;
struct PresaveGeneratedPasswordProtoDefaultTypeInternal;
extern PresaveGeneratedPasswordProtoDefaultTypeInternal _PresaveGeneratedPasswordProto_default_instance_;
class ProcessedActionProto;
struct ProcessedActionProtoDefaultTypeInternal;
extern ProcessedActionProtoDefaultTypeInternal _ProcessedActionProto_default_instance_;
class ProcessedActionStatusDetailsProto;
struct ProcessedActionStatusDetailsProtoDefaultTypeInternal;
extern ProcessedActionStatusDetailsProtoDefaultTypeInternal _ProcessedActionStatusDetailsProto_default_instance_;
class ProfileProto;
struct ProfileProtoDefaultTypeInternal;
extern ProfileProtoDefaultTypeInternal _ProfileProto_default_instance_;
class ProfileProto_ValuesEntry_DoNotUse;
struct ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal;
extern ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal _ProfileProto_ValuesEntry_DoNotUse_default_instance_;
class PromptProto;
struct PromptProtoDefaultTypeInternal;
extern PromptProtoDefaultTypeInternal _PromptProto_default_instance_;
class PromptProto_Choice;
struct PromptProto_ChoiceDefaultTypeInternal;
extern PromptProto_ChoiceDefaultTypeInternal _PromptProto_Choice_default_instance_;
class PromptProto_Result;
struct PromptProto_ResultDefaultTypeInternal;
extern PromptProto_ResultDefaultTypeInternal _PromptProto_Result_default_instance_;
class PromptQrCodeScanProto;
struct PromptQrCodeScanProtoDefaultTypeInternal;
extern PromptQrCodeScanProtoDefaultTypeInternal _PromptQrCodeScanProto_default_instance_;
class PromptQrCodeScanProto_CameraScanUiStrings;
struct PromptQrCodeScanProto_CameraScanUiStringsDefaultTypeInternal;
extern PromptQrCodeScanProto_CameraScanUiStringsDefaultTypeInternal _PromptQrCodeScanProto_CameraScanUiStrings_default_instance_;
class PromptQrCodeScanProto_ImagePickerUiStrings;
struct PromptQrCodeScanProto_ImagePickerUiStringsDefaultTypeInternal;
extern PromptQrCodeScanProto_ImagePickerUiStringsDefaultTypeInternal _PromptQrCodeScanProto_ImagePickerUiStrings_default_instance_;
class RegisterPasswordResetRequestProto;
struct RegisterPasswordResetRequestProtoDefaultTypeInternal;
extern RegisterPasswordResetRequestProtoDefaultTypeInternal _RegisterPasswordResetRequestProto_default_instance_;
class ReleaseElementsProto;
struct ReleaseElementsProtoDefaultTypeInternal;
extern ReleaseElementsProtoDefaultTypeInternal _ReleaseElementsProto_default_instance_;
class RequiredFieldProto;
struct RequiredFieldProtoDefaultTypeInternal;
extern RequiredFieldProtoDefaultTypeInternal _RequiredFieldProto_default_instance_;
class ResetPendingCredentialsProto;
struct ResetPendingCredentialsProtoDefaultTypeInternal;
extern ResetPendingCredentialsProtoDefaultTypeInternal _ResetPendingCredentialsProto_default_instance_;
class RoundtripNetworkStats;
struct RoundtripNetworkStatsDefaultTypeInternal;
extern RoundtripNetworkStatsDefaultTypeInternal _RoundtripNetworkStats_default_instance_;
class RoundtripNetworkStats_ActionNetworkStats;
struct RoundtripNetworkStats_ActionNetworkStatsDefaultTypeInternal;
extern RoundtripNetworkStats_ActionNetworkStatsDefaultTypeInternal _RoundtripNetworkStats_ActionNetworkStats_default_instance_;
class RoundtripTimingStats;
struct RoundtripTimingStatsDefaultTypeInternal;
extern RoundtripTimingStatsDefaultTypeInternal _RoundtripTimingStats_default_instance_;
class SaveGeneratedPasswordProto;
struct SaveGeneratedPasswordProtoDefaultTypeInternal;
extern SaveGeneratedPasswordProtoDefaultTypeInternal _SaveGeneratedPasswordProto_default_instance_;
class SaveSubmittedPasswordProto;
struct SaveSubmittedPasswordProtoDefaultTypeInternal;
extern SaveSubmittedPasswordProtoDefaultTypeInternal _SaveSubmittedPasswordProto_default_instance_;
class SaveSubmittedPasswordProto_Result;
struct SaveSubmittedPasswordProto_ResultDefaultTypeInternal;
extern SaveSubmittedPasswordProto_ResultDefaultTypeInternal _SaveSubmittedPasswordProto_Result_default_instance_;
class ScriptActionRequestProto;
struct ScriptActionRequestProtoDefaultTypeInternal;
extern ScriptActionRequestProtoDefaultTypeInternal _ScriptActionRequestProto_default_instance_;
class ScriptParameterMatchProto;
struct ScriptParameterMatchProtoDefaultTypeInternal;
extern ScriptParameterMatchProtoDefaultTypeInternal _ScriptParameterMatchProto_default_instance_;
class ScriptParameterProto;
struct ScriptParameterProtoDefaultTypeInternal;
extern ScriptParameterProtoDefaultTypeInternal _ScriptParameterProto_default_instance_;
class ScriptPreconditionProto;
struct ScriptPreconditionProtoDefaultTypeInternal;
extern ScriptPreconditionProtoDefaultTypeInternal _ScriptPreconditionProto_default_instance_;
class ScriptStoreConfig;
struct ScriptStoreConfigDefaultTypeInternal;
extern ScriptStoreConfigDefaultTypeInternal _ScriptStoreConfig_default_instance_;
class ScriptTimeoutError;
struct ScriptTimeoutErrorDefaultTypeInternal;
extern ScriptTimeoutErrorDefaultTypeInternal _ScriptTimeoutError_default_instance_;
class SelectOptionProto;
struct SelectOptionProtoDefaultTypeInternal;
extern SelectOptionProtoDefaultTypeInternal _SelectOptionProto_default_instance_;
class SelectionInputProto;
struct SelectionInputProtoDefaultTypeInternal;
extern SelectionInputProtoDefaultTypeInternal _SelectionInputProto_default_instance_;
class SelectionInputProto_Choice;
struct SelectionInputProto_ChoiceDefaultTypeInternal;
extern SelectionInputProto_ChoiceDefaultTypeInternal _SelectionInputProto_Choice_default_instance_;
class SelectionInputProto_Result;
struct SelectionInputProto_ResultDefaultTypeInternal;
extern SelectionInputProto_ResultDefaultTypeInternal _SelectionInputProto_Result_default_instance_;
class SelectorProto;
struct SelectorProtoDefaultTypeInternal;
extern SelectorProtoDefaultTypeInternal _SelectorProto_default_instance_;
class SelectorProto_BoundingBoxFilter;
struct SelectorProto_BoundingBoxFilterDefaultTypeInternal;
extern SelectorProto_BoundingBoxFilterDefaultTypeInternal _SelectorProto_BoundingBoxFilter_default_instance_;
class SelectorProto_CssStyleFilter;
struct SelectorProto_CssStyleFilterDefaultTypeInternal;
extern SelectorProto_CssStyleFilterDefaultTypeInternal _SelectorProto_CssStyleFilter_default_instance_;
class SelectorProto_EmptyFilter;
struct SelectorProto_EmptyFilterDefaultTypeInternal;
extern SelectorProto_EmptyFilterDefaultTypeInternal _SelectorProto_EmptyFilter_default_instance_;
class SelectorProto_Filter;
struct SelectorProto_FilterDefaultTypeInternal;
extern SelectorProto_FilterDefaultTypeInternal _SelectorProto_Filter_default_instance_;
class SelectorProto_NthMatchFilter;
struct SelectorProto_NthMatchFilterDefaultTypeInternal;
extern SelectorProto_NthMatchFilterDefaultTypeInternal _SelectorProto_NthMatchFilter_default_instance_;
class SelectorProto_OnTopFilter;
struct SelectorProto_OnTopFilterDefaultTypeInternal;
extern SelectorProto_OnTopFilterDefaultTypeInternal _SelectorProto_OnTopFilter_default_instance_;
class SelectorProto_PropertyFilter;
struct SelectorProto_PropertyFilterDefaultTypeInternal;
extern SelectorProto_PropertyFilterDefaultTypeInternal _SelectorProto_PropertyFilter_default_instance_;
class SelectorProto_PseudoElementContent;
struct SelectorProto_PseudoElementContentDefaultTypeInternal;
extern SelectorProto_PseudoElementContentDefaultTypeInternal _SelectorProto_PseudoElementContent_default_instance_;
class SelectorProto_SemanticFilter;
struct SelectorProto_SemanticFilterDefaultTypeInternal;
extern SelectorProto_SemanticFilterDefaultTypeInternal _SelectorProto_SemanticFilter_default_instance_;
class SetAttributeProto;
struct SetAttributeProtoDefaultTypeInternal;
extern SetAttributeProtoDefaultTypeInternal _SetAttributeProto_default_instance_;
class SetPersistentUiProto;
struct SetPersistentUiProtoDefaultTypeInternal;
extern SetPersistentUiProtoDefaultTypeInternal _SetPersistentUiProto_default_instance_;
class SetTouchableAreaProto;
struct SetTouchableAreaProtoDefaultTypeInternal;
extern SetTouchableAreaProtoDefaultTypeInternal _SetTouchableAreaProto_default_instance_;
class ShowCastProto;
struct ShowCastProtoDefaultTypeInternal;
extern ShowCastProtoDefaultTypeInternal _ShowCastProto_default_instance_;
class ShowCastProto_TopPadding;
struct ShowCastProto_TopPaddingDefaultTypeInternal;
extern ShowCastProto_TopPaddingDefaultTypeInternal _ShowCastProto_TopPadding_default_instance_;
class ShowDetailsProto;
struct ShowDetailsProtoDefaultTypeInternal;
extern ShowDetailsProtoDefaultTypeInternal _ShowDetailsProto_default_instance_;
class ShowFormProto;
struct ShowFormProtoDefaultTypeInternal;
extern ShowFormProtoDefaultTypeInternal _ShowFormProto_default_instance_;
class ShowGenericUiProto;
struct ShowGenericUiProtoDefaultTypeInternal;
extern ShowGenericUiProtoDefaultTypeInternal _ShowGenericUiProto_default_instance_;
class ShowGenericUiProto_PeriodicElementChecks;
struct ShowGenericUiProto_PeriodicElementChecksDefaultTypeInternal;
extern ShowGenericUiProto_PeriodicElementChecksDefaultTypeInternal _ShowGenericUiProto_PeriodicElementChecks_default_instance_;
class ShowGenericUiProto_PeriodicElementChecks_ElementCheck;
struct ShowGenericUiProto_PeriodicElementChecks_ElementCheckDefaultTypeInternal;
extern ShowGenericUiProto_PeriodicElementChecks_ElementCheckDefaultTypeInternal _ShowGenericUiProto_PeriodicElementChecks_ElementCheck_default_instance_;
class ShowGenericUiProto_RequestUserData;
struct ShowGenericUiProto_RequestUserDataDefaultTypeInternal;
extern ShowGenericUiProto_RequestUserDataDefaultTypeInternal _ShowGenericUiProto_RequestUserData_default_instance_;
class ShowGenericUiProto_RequestUserData_AdditionalValue;
struct ShowGenericUiProto_RequestUserData_AdditionalValueDefaultTypeInternal;
extern ShowGenericUiProto_RequestUserData_AdditionalValueDefaultTypeInternal _ShowGenericUiProto_RequestUserData_AdditionalValue_default_instance_;
class ShowGenericUiProto_Result;
struct ShowGenericUiProto_ResultDefaultTypeInternal;
extern ShowGenericUiProto_ResultDefaultTypeInternal _ShowGenericUiProto_Result_default_instance_;
class ShowInfoBoxProto;
struct ShowInfoBoxProtoDefaultTypeInternal;
extern ShowInfoBoxProtoDefaultTypeInternal _ShowInfoBoxProto_default_instance_;
class ShowProgressBarProto;
struct ShowProgressBarProtoDefaultTypeInternal;
extern ShowProgressBarProtoDefaultTypeInternal _ShowProgressBarProto_default_instance_;
class ShowProgressBarProto_StepProgressBarConfiguration;
struct ShowProgressBarProto_StepProgressBarConfigurationDefaultTypeInternal;
extern ShowProgressBarProto_StepProgressBarConfigurationDefaultTypeInternal _ShowProgressBarProto_StepProgressBarConfiguration_default_instance_;
class ShowProgressBarProto_StepProgressBarIcon;
struct ShowProgressBarProto_StepProgressBarIconDefaultTypeInternal;
extern ShowProgressBarProto_StepProgressBarIconDefaultTypeInternal _ShowProgressBarProto_StepProgressBarIcon_default_instance_;
class StaticTextSectionProto;
struct StaticTextSectionProtoDefaultTypeInternal;
extern StaticTextSectionProtoDefaultTypeInternal _StaticTextSectionProto_default_instance_;
class StopProto;
struct StopProtoDefaultTypeInternal;
extern StopProtoDefaultTypeInternal _StopProto_default_instance_;
class SupportedScriptProto;
struct SupportedScriptProtoDefaultTypeInternal;
extern SupportedScriptProtoDefaultTypeInternal _SupportedScriptProto_default_instance_;
class SupportedScriptProto_PresentationProto;
struct SupportedScriptProto_PresentationProtoDefaultTypeInternal;
extern SupportedScriptProto_PresentationProtoDefaultTypeInternal _SupportedScriptProto_PresentationProto_default_instance_;
class SupportsScriptRequestProto;
struct SupportsScriptRequestProtoDefaultTypeInternal;
extern SupportsScriptRequestProtoDefaultTypeInternal _SupportsScriptRequestProto_default_instance_;
class SupportsScriptResponseProto;
struct SupportsScriptResponseProtoDefaultTypeInternal;
extern SupportsScriptResponseProtoDefaultTypeInternal _SupportsScriptResponseProto_default_instance_;
class TellProto;
struct TellProtoDefaultTypeInternal;
extern TellProtoDefaultTypeInternal _TellProto_default_instance_;
class TellProto_TextToSpeech;
struct TellProto_TextToSpeechDefaultTypeInternal;
extern TellProto_TextToSpeechDefaultTypeInternal _TellProto_TextToSpeech_default_instance_;
class TextInputProto;
struct TextInputProtoDefaultTypeInternal;
extern TextInputProtoDefaultTypeInternal _TextInputProto_default_instance_;
class TextInputSectionProto;
struct TextInputSectionProtoDefaultTypeInternal;
extern TextInputSectionProtoDefaultTypeInternal _TextInputSectionProto_default_instance_;
class TriggerScriptConditionProto;
struct TriggerScriptConditionProtoDefaultTypeInternal;
extern TriggerScriptConditionProtoDefaultTypeInternal _TriggerScriptConditionProto_default_instance_;
class TriggerScriptConditionProto_DocumentReadyStateCondition;
struct TriggerScriptConditionProto_DocumentReadyStateConditionDefaultTypeInternal;
extern TriggerScriptConditionProto_DocumentReadyStateConditionDefaultTypeInternal _TriggerScriptConditionProto_DocumentReadyStateCondition_default_instance_;
class TriggerScriptConditionsProto;
struct TriggerScriptConditionsProtoDefaultTypeInternal;
extern TriggerScriptConditionsProtoDefaultTypeInternal _TriggerScriptConditionsProto_default_instance_;
class TriggerScriptProto;
struct TriggerScriptProtoDefaultTypeInternal;
extern TriggerScriptProtoDefaultTypeInternal _TriggerScriptProto_default_instance_;
class TriggerScriptUIProto;
struct TriggerScriptUIProtoDefaultTypeInternal;
extern TriggerScriptUIProtoDefaultTypeInternal _TriggerScriptUIProto_default_instance_;
class TriggerScriptUIProto_Popup;
struct TriggerScriptUIProto_PopupDefaultTypeInternal;
extern TriggerScriptUIProto_PopupDefaultTypeInternal _TriggerScriptUIProto_Popup_default_instance_;
class TriggerScriptUIProto_Popup_Choice;
struct TriggerScriptUIProto_Popup_ChoiceDefaultTypeInternal;
extern TriggerScriptUIProto_Popup_ChoiceDefaultTypeInternal _TriggerScriptUIProto_Popup_Choice_default_instance_;
class TriggerScriptUIProto_ProgressBar;
struct TriggerScriptUIProto_ProgressBarDefaultTypeInternal;
extern TriggerScriptUIProto_ProgressBarDefaultTypeInternal _TriggerScriptUIProto_ProgressBar_default_instance_;
class TriggerScriptUIProto_TriggerChip;
struct TriggerScriptUIProto_TriggerChipDefaultTypeInternal;
extern TriggerScriptUIProto_TriggerChipDefaultTypeInternal _TriggerScriptUIProto_TriggerChip_default_instance_;
class UnexpectedErrorInfoProto;
struct UnexpectedErrorInfoProtoDefaultTypeInternal;
extern UnexpectedErrorInfoProtoDefaultTypeInternal _UnexpectedErrorInfoProto_default_instance_;
class UpdateClientSettingsProto;
struct UpdateClientSettingsProtoDefaultTypeInternal;
extern UpdateClientSettingsProtoDefaultTypeInternal _UpdateClientSettingsProto_default_instance_;
class UploadDomProto;
struct UploadDomProtoDefaultTypeInternal;
extern UploadDomProtoDefaultTypeInternal _UploadDomProto_default_instance_;
class UploadDomProto_Result;
struct UploadDomProto_ResultDefaultTypeInternal;
extern UploadDomProto_ResultDefaultTypeInternal _UploadDomProto_Result_default_instance_;
class UseAddressProto;
struct UseAddressProtoDefaultTypeInternal;
extern UseAddressProtoDefaultTypeInternal _UseAddressProto_default_instance_;
class UseCreditCardProto;
struct UseCreditCardProtoDefaultTypeInternal;
extern UseCreditCardProtoDefaultTypeInternal _UseCreditCardProto_default_instance_;
class UserFormSectionProto;
struct UserFormSectionProtoDefaultTypeInternal;
extern UserFormSectionProtoDefaultTypeInternal _UserFormSectionProto_default_instance_;
class WaitForDocumentProto;
struct WaitForDocumentProtoDefaultTypeInternal;
extern WaitForDocumentProtoDefaultTypeInternal _WaitForDocumentProto_default_instance_;
class WaitForDocumentProto_Result;
struct WaitForDocumentProto_ResultDefaultTypeInternal;
extern WaitForDocumentProto_ResultDefaultTypeInternal _WaitForDocumentProto_Result_default_instance_;
class WaitForDomProto;
struct WaitForDomProtoDefaultTypeInternal;
extern WaitForDomProtoDefaultTypeInternal _WaitForDomProto_default_instance_;
class WaitForDomProto_Result;
struct WaitForDomProto_ResultDefaultTypeInternal;
extern WaitForDomProto_ResultDefaultTypeInternal _WaitForDomProto_Result_default_instance_;
class WaitForNavigationProto;
struct WaitForNavigationProtoDefaultTypeInternal;
extern WaitForNavigationProtoDefaultTypeInternal _WaitForNavigationProto_default_instance_;
class WebControllerErrorInfoProto;
struct WebControllerErrorInfoProtoDefaultTypeInternal;
extern WebControllerErrorInfoProtoDefaultTypeInternal _WebControllerErrorInfoProto_default_instance_;
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::ActionProto* Arena::CreateMaybeMessage<::autofill_assistant::ActionProto>(Arena*);
template<> ::autofill_assistant::ActionTimingStats* Arena::CreateMaybeMessage<::autofill_assistant::ActionTimingStats>(Arena*);
template<> ::autofill_assistant::ActionsResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::ActionsResponseProto>(Arena*);
template<> ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* Arena::CreateMaybeMessage<::autofill_assistant::ActionsResponseProto_UpdateScriptListProto>(Arena*);
template<> ::autofill_assistant::AutofillEntryProto* Arena::CreateMaybeMessage<::autofill_assistant::AutofillEntryProto>(Arena*);
template<> ::autofill_assistant::AutofillErrorInfoProto* Arena::CreateMaybeMessage<::autofill_assistant::AutofillErrorInfoProto>(Arena*);
template<> ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* Arena::CreateMaybeMessage<::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError>(Arena*);
template<> ::autofill_assistant::CUPRequestData* Arena::CreateMaybeMessage<::autofill_assistant::CUPRequestData>(Arena*);
template<> ::autofill_assistant::CUPResponseData* Arena::CreateMaybeMessage<::autofill_assistant::CUPResponseData>(Arena*);
template<> ::autofill_assistant::ClearPersistentUiProto* Arena::CreateMaybeMessage<::autofill_assistant::ClearPersistentUiProto>(Arena*);
template<> ::autofill_assistant::ClientContextProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientContextProto>(Arena*);
template<> ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto>(Arena*);
template<> ::autofill_assistant::ClientContextProto_Chrome* Arena::CreateMaybeMessage<::autofill_assistant::ClientContextProto_Chrome>(Arena*);
template<> ::autofill_assistant::ClientContextProto_DeviceContextProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientContextProto_DeviceContextProto>(Arena*);
template<> ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto>(Arena*);
template<> ::autofill_assistant::ClientContextProto_WindowSize* Arena::CreateMaybeMessage<::autofill_assistant::ClientContextProto_WindowSize>(Arena*);
template<> ::autofill_assistant::ClientSettingsProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientSettingsProto>(Arena*);
template<> ::autofill_assistant::ClientSettingsProto_BackButtonSettings* Arena::CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_BackButtonSettings>(Arena*);
template<> ::autofill_assistant::ClientSettingsProto_DisplayString* Arena::CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_DisplayString>(Arena*);
template<> ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* Arena::CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_IntegrationTestSettings>(Arena*);
template<> ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* Arena::CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_SlowWarningSettings>(Arena*);
template<> ::autofill_assistant::CollectUserDataProto* Arena::CreateMaybeMessage<::autofill_assistant::CollectUserDataProto>(Arena*);
template<> ::autofill_assistant::CollectUserDataProto_DataSource* Arena::CreateMaybeMessage<::autofill_assistant::CollectUserDataProto_DataSource>(Arena*);
template<> ::autofill_assistant::CollectUserDataResultProto* Arena::CreateMaybeMessage<::autofill_assistant::CollectUserDataResultProto>(Arena*);
template<> ::autofill_assistant::ConfigureBottomSheetProto* Arena::CreateMaybeMessage<::autofill_assistant::ConfigureBottomSheetProto>(Arena*);
template<> ::autofill_assistant::ConfigureUiStateProto* Arena::CreateMaybeMessage<::autofill_assistant::ConfigureUiStateProto>(Arena*);
template<> ::autofill_assistant::ContactDetailsProto* Arena::CreateMaybeMessage<::autofill_assistant::ContactDetailsProto>(Arena*);
template<> ::autofill_assistant::CounterInputProto* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto>(Arena*);
template<> ::autofill_assistant::CounterInputProto_Counter* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto_Counter>(Arena*);
template<> ::autofill_assistant::CounterInputProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto_Result>(Arena*);
template<> ::autofill_assistant::CounterInputProto_ValidationRule* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto_ValidationRule>(Arena*);
template<> ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule>(Arena*);
template<> ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto_ValidationRule_CounterRule>(Arena*);
template<> ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* Arena::CreateMaybeMessage<::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule>(Arena*);
template<> ::autofill_assistant::DataOriginNoticeProto* Arena::CreateMaybeMessage<::autofill_assistant::DataOriginNoticeProto>(Arena*);
template<> ::autofill_assistant::DeleteSelectedPasswordProto* Arena::CreateMaybeMessage<::autofill_assistant::DeleteSelectedPasswordProto>(Arena*);
template<> ::autofill_assistant::DetailsChangesProto* Arena::CreateMaybeMessage<::autofill_assistant::DetailsChangesProto>(Arena*);
template<> ::autofill_assistant::DetailsProto* Arena::CreateMaybeMessage<::autofill_assistant::DetailsProto>(Arena*);
template<> ::autofill_assistant::DetailsProto_ImageClickthroughData* Arena::CreateMaybeMessage<::autofill_assistant::DetailsProto_ImageClickthroughData>(Arena*);
template<> ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* Arena::CreateMaybeMessage<::autofill_assistant::DetailsProto_PlaceholdersConfiguration>(Arena*);
template<> ::autofill_assistant::DispatchJsEventProto* Arena::CreateMaybeMessage<::autofill_assistant::DispatchJsEventProto>(Arena*);
template<> ::autofill_assistant::EditSelectedPasswordProto* Arena::CreateMaybeMessage<::autofill_assistant::EditSelectedPasswordProto>(Arena*);
template<> ::autofill_assistant::ElementAreaProto* Arena::CreateMaybeMessage<::autofill_assistant::ElementAreaProto>(Arena*);
template<> ::autofill_assistant::ElementAreaProto_Rectangle* Arena::CreateMaybeMessage<::autofill_assistant::ElementAreaProto_Rectangle>(Arena*);
template<> ::autofill_assistant::ElementConditionProto* Arena::CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(Arena*);
template<> ::autofill_assistant::ElementConditionsProto* Arena::CreateMaybeMessage<::autofill_assistant::ElementConditionsProto>(Arena*);
template<> ::autofill_assistant::ElementFinderInfoProto* Arena::CreateMaybeMessage<::autofill_assistant::ElementFinderInfoProto>(Arena*);
template<> ::autofill_assistant::ElementFinderInfoProto_PredictedElement* Arena::CreateMaybeMessage<::autofill_assistant::ElementFinderInfoProto_PredictedElement>(Arena*);
template<> ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* Arena::CreateMaybeMessage<::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult>(Arena*);
template<> ::autofill_assistant::ExpectNavigationProto* Arena::CreateMaybeMessage<::autofill_assistant::ExpectNavigationProto>(Arena*);
template<> ::autofill_assistant::ExternalActionProto* Arena::CreateMaybeMessage<::autofill_assistant::ExternalActionProto>(Arena*);
template<> ::autofill_assistant::ExternalActionProto_ExternalCondition* Arena::CreateMaybeMessage<::autofill_assistant::ExternalActionProto_ExternalCondition>(Arena*);
template<> ::autofill_assistant::ExternalActionProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::ExternalActionProto_Result>(Arena*);
template<> ::autofill_assistant::FieldTrialProto* Arena::CreateMaybeMessage<::autofill_assistant::FieldTrialProto>(Arena*);
template<> ::autofill_assistant::FormInputProto* Arena::CreateMaybeMessage<::autofill_assistant::FormInputProto>(Arena*);
template<> ::autofill_assistant::FormInputProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::FormInputProto_Result>(Arena*);
template<> ::autofill_assistant::FormProto* Arena::CreateMaybeMessage<::autofill_assistant::FormProto>(Arena*);
template<> ::autofill_assistant::FormProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::FormProto_Result>(Arena*);
template<> ::autofill_assistant::GeneratePasswordForFormFieldProto* Arena::CreateMaybeMessage<::autofill_assistant::GeneratePasswordForFormFieldProto>(Arena*);
template<> ::autofill_assistant::GetCapabilitiesByHashPrefixRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::GetCapabilitiesByHashPrefixRequestProto>(Arena*);
template<> ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto>(Arena*);
template<> ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* Arena::CreateMaybeMessage<::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto_ComparisonReport* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_ComparisonReport>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto_MatchExpectation* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_MatchExpectation>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto_MatchOptions* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_MatchOptions>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_Result>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto_TextMatch* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_TextMatch>(Arena*);
template<> ::autofill_assistant::GetElementStatusProto_ValueMatch* Arena::CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_ValueMatch>(Arena*);
template<> ::autofill_assistant::GetTriggerScriptsRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::GetTriggerScriptsRequestProto>(Arena*);
template<> ::autofill_assistant::GetTriggerScriptsResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::GetTriggerScriptsResponseProto>(Arena*);
template<> ::autofill_assistant::GetUserDataRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::GetUserDataRequestProto>(Arena*);
template<> ::autofill_assistant::GetUserDataRequestProto_AddressRequest* Arena::CreateMaybeMessage<::autofill_assistant::GetUserDataRequestProto_AddressRequest>(Arena*);
template<> ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* Arena::CreateMaybeMessage<::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest>(Arena*);
template<> ::autofill_assistant::GetUserDataResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::GetUserDataResponseProto>(Arena*);
template<> ::autofill_assistant::ImplicitTriggeringDebugParametersProto* Arena::CreateMaybeMessage<::autofill_assistant::ImplicitTriggeringDebugParametersProto>(Arena*);
template<> ::autofill_assistant::InfoBoxProto* Arena::CreateMaybeMessage<::autofill_assistant::InfoBoxProto>(Arena*);
template<> ::autofill_assistant::InitialScriptActionsRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::InitialScriptActionsRequestProto>(Arena*);
template<> ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* Arena::CreateMaybeMessage<::autofill_assistant::InitialScriptActionsRequestProto_QueryProto>(Arena*);
template<> ::autofill_assistant::JsFlowProto* Arena::CreateMaybeMessage<::autofill_assistant::JsFlowProto>(Arena*);
template<> ::autofill_assistant::JsFlowProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::JsFlowProto_Result>(Arena*);
template<> ::autofill_assistant::LoginDetailsProto* Arena::CreateMaybeMessage<::autofill_assistant::LoginDetailsProto>(Arena*);
template<> ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* Arena::CreateMaybeMessage<::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto>(Arena*);
template<> ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* Arena::CreateMaybeMessage<::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto>(Arena*);
template<> ::autofill_assistant::LoginDetailsProto_LoginOptionProto* Arena::CreateMaybeMessage<::autofill_assistant::LoginDetailsProto_LoginOptionProto>(Arena*);
template<> ::autofill_assistant::NavigateProto* Arena::CreateMaybeMessage<::autofill_assistant::NavigateProto>(Arena*);
template<> ::autofill_assistant::NavigationInfoProto* Arena::CreateMaybeMessage<::autofill_assistant::NavigationInfoProto>(Arena*);
template<> ::autofill_assistant::NextScriptActionsRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::NextScriptActionsRequestProto>(Arena*);
template<> ::autofill_assistant::OverlayImageProto* Arena::CreateMaybeMessage<::autofill_assistant::OverlayImageProto>(Arena*);
template<> ::autofill_assistant::PaymentInstrumentProto* Arena::CreateMaybeMessage<::autofill_assistant::PaymentInstrumentProto>(Arena*);
template<> ::autofill_assistant::PaymentInstrumentProto_AddressValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::PaymentInstrumentProto_AddressValuesEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::PaymentInstrumentProto_CardValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::PaymentInstrumentProto_CardValuesEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::PhoneNumberProto* Arena::CreateMaybeMessage<::autofill_assistant::PhoneNumberProto>(Arena*);
template<> ::autofill_assistant::PopupListSectionProto* Arena::CreateMaybeMessage<::autofill_assistant::PopupListSectionProto>(Arena*);
template<> ::autofill_assistant::PopupMessageProto* Arena::CreateMaybeMessage<::autofill_assistant::PopupMessageProto>(Arena*);
template<> ::autofill_assistant::PresaveGeneratedPasswordProto* Arena::CreateMaybeMessage<::autofill_assistant::PresaveGeneratedPasswordProto>(Arena*);
template<> ::autofill_assistant::ProcessedActionProto* Arena::CreateMaybeMessage<::autofill_assistant::ProcessedActionProto>(Arena*);
template<> ::autofill_assistant::ProcessedActionStatusDetailsProto* Arena::CreateMaybeMessage<::autofill_assistant::ProcessedActionStatusDetailsProto>(Arena*);
template<> ::autofill_assistant::ProfileProto* Arena::CreateMaybeMessage<::autofill_assistant::ProfileProto>(Arena*);
template<> ::autofill_assistant::ProfileProto_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::ProfileProto_ValuesEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::PromptProto* Arena::CreateMaybeMessage<::autofill_assistant::PromptProto>(Arena*);
template<> ::autofill_assistant::PromptProto_Choice* Arena::CreateMaybeMessage<::autofill_assistant::PromptProto_Choice>(Arena*);
template<> ::autofill_assistant::PromptProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::PromptProto_Result>(Arena*);
template<> ::autofill_assistant::PromptQrCodeScanProto* Arena::CreateMaybeMessage<::autofill_assistant::PromptQrCodeScanProto>(Arena*);
template<> ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* Arena::CreateMaybeMessage<::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings>(Arena*);
template<> ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* Arena::CreateMaybeMessage<::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings>(Arena*);
template<> ::autofill_assistant::RegisterPasswordResetRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::RegisterPasswordResetRequestProto>(Arena*);
template<> ::autofill_assistant::ReleaseElementsProto* Arena::CreateMaybeMessage<::autofill_assistant::ReleaseElementsProto>(Arena*);
template<> ::autofill_assistant::RequiredFieldProto* Arena::CreateMaybeMessage<::autofill_assistant::RequiredFieldProto>(Arena*);
template<> ::autofill_assistant::ResetPendingCredentialsProto* Arena::CreateMaybeMessage<::autofill_assistant::ResetPendingCredentialsProto>(Arena*);
template<> ::autofill_assistant::RoundtripNetworkStats* Arena::CreateMaybeMessage<::autofill_assistant::RoundtripNetworkStats>(Arena*);
template<> ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* Arena::CreateMaybeMessage<::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats>(Arena*);
template<> ::autofill_assistant::RoundtripTimingStats* Arena::CreateMaybeMessage<::autofill_assistant::RoundtripTimingStats>(Arena*);
template<> ::autofill_assistant::SaveGeneratedPasswordProto* Arena::CreateMaybeMessage<::autofill_assistant::SaveGeneratedPasswordProto>(Arena*);
template<> ::autofill_assistant::SaveSubmittedPasswordProto* Arena::CreateMaybeMessage<::autofill_assistant::SaveSubmittedPasswordProto>(Arena*);
template<> ::autofill_assistant::SaveSubmittedPasswordProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::SaveSubmittedPasswordProto_Result>(Arena*);
template<> ::autofill_assistant::ScriptActionRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::ScriptActionRequestProto>(Arena*);
template<> ::autofill_assistant::ScriptParameterMatchProto* Arena::CreateMaybeMessage<::autofill_assistant::ScriptParameterMatchProto>(Arena*);
template<> ::autofill_assistant::ScriptParameterProto* Arena::CreateMaybeMessage<::autofill_assistant::ScriptParameterProto>(Arena*);
template<> ::autofill_assistant::ScriptPreconditionProto* Arena::CreateMaybeMessage<::autofill_assistant::ScriptPreconditionProto>(Arena*);
template<> ::autofill_assistant::ScriptStoreConfig* Arena::CreateMaybeMessage<::autofill_assistant::ScriptStoreConfig>(Arena*);
template<> ::autofill_assistant::ScriptTimeoutError* Arena::CreateMaybeMessage<::autofill_assistant::ScriptTimeoutError>(Arena*);
template<> ::autofill_assistant::SelectOptionProto* Arena::CreateMaybeMessage<::autofill_assistant::SelectOptionProto>(Arena*);
template<> ::autofill_assistant::SelectionInputProto* Arena::CreateMaybeMessage<::autofill_assistant::SelectionInputProto>(Arena*);
template<> ::autofill_assistant::SelectionInputProto_Choice* Arena::CreateMaybeMessage<::autofill_assistant::SelectionInputProto_Choice>(Arena*);
template<> ::autofill_assistant::SelectionInputProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::SelectionInputProto_Result>(Arena*);
template<> ::autofill_assistant::SelectorProto* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto>(Arena*);
template<> ::autofill_assistant::SelectorProto_BoundingBoxFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_BoundingBoxFilter>(Arena*);
template<> ::autofill_assistant::SelectorProto_CssStyleFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_CssStyleFilter>(Arena*);
template<> ::autofill_assistant::SelectorProto_EmptyFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_EmptyFilter>(Arena*);
template<> ::autofill_assistant::SelectorProto_Filter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_Filter>(Arena*);
template<> ::autofill_assistant::SelectorProto_NthMatchFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_NthMatchFilter>(Arena*);
template<> ::autofill_assistant::SelectorProto_OnTopFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_OnTopFilter>(Arena*);
template<> ::autofill_assistant::SelectorProto_PropertyFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_PropertyFilter>(Arena*);
template<> ::autofill_assistant::SelectorProto_PseudoElementContent* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_PseudoElementContent>(Arena*);
template<> ::autofill_assistant::SelectorProto_SemanticFilter* Arena::CreateMaybeMessage<::autofill_assistant::SelectorProto_SemanticFilter>(Arena*);
template<> ::autofill_assistant::SetAttributeProto* Arena::CreateMaybeMessage<::autofill_assistant::SetAttributeProto>(Arena*);
template<> ::autofill_assistant::SetPersistentUiProto* Arena::CreateMaybeMessage<::autofill_assistant::SetPersistentUiProto>(Arena*);
template<> ::autofill_assistant::SetTouchableAreaProto* Arena::CreateMaybeMessage<::autofill_assistant::SetTouchableAreaProto>(Arena*);
template<> ::autofill_assistant::ShowCastProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowCastProto>(Arena*);
template<> ::autofill_assistant::ShowCastProto_TopPadding* Arena::CreateMaybeMessage<::autofill_assistant::ShowCastProto_TopPadding>(Arena*);
template<> ::autofill_assistant::ShowDetailsProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowDetailsProto>(Arena*);
template<> ::autofill_assistant::ShowFormProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowFormProto>(Arena*);
template<> ::autofill_assistant::ShowGenericUiProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto>(Arena*);
template<> ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks>(Arena*);
template<> ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck>(Arena*);
template<> ::autofill_assistant::ShowGenericUiProto_RequestUserData* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_RequestUserData>(Arena*);
template<> ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue>(Arena*);
template<> ::autofill_assistant::ShowGenericUiProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_Result>(Arena*);
template<> ::autofill_assistant::ShowInfoBoxProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowInfoBoxProto>(Arena*);
template<> ::autofill_assistant::ShowProgressBarProto* Arena::CreateMaybeMessage<::autofill_assistant::ShowProgressBarProto>(Arena*);
template<> ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* Arena::CreateMaybeMessage<::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration>(Arena*);
template<> ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* Arena::CreateMaybeMessage<::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon>(Arena*);
template<> ::autofill_assistant::StaticTextSectionProto* Arena::CreateMaybeMessage<::autofill_assistant::StaticTextSectionProto>(Arena*);
template<> ::autofill_assistant::StopProto* Arena::CreateMaybeMessage<::autofill_assistant::StopProto>(Arena*);
template<> ::autofill_assistant::SupportedScriptProto* Arena::CreateMaybeMessage<::autofill_assistant::SupportedScriptProto>(Arena*);
template<> ::autofill_assistant::SupportedScriptProto_PresentationProto* Arena::CreateMaybeMessage<::autofill_assistant::SupportedScriptProto_PresentationProto>(Arena*);
template<> ::autofill_assistant::SupportsScriptRequestProto* Arena::CreateMaybeMessage<::autofill_assistant::SupportsScriptRequestProto>(Arena*);
template<> ::autofill_assistant::SupportsScriptResponseProto* Arena::CreateMaybeMessage<::autofill_assistant::SupportsScriptResponseProto>(Arena*);
template<> ::autofill_assistant::TellProto* Arena::CreateMaybeMessage<::autofill_assistant::TellProto>(Arena*);
template<> ::autofill_assistant::TellProto_TextToSpeech* Arena::CreateMaybeMessage<::autofill_assistant::TellProto_TextToSpeech>(Arena*);
template<> ::autofill_assistant::TextInputProto* Arena::CreateMaybeMessage<::autofill_assistant::TextInputProto>(Arena*);
template<> ::autofill_assistant::TextInputSectionProto* Arena::CreateMaybeMessage<::autofill_assistant::TextInputSectionProto>(Arena*);
template<> ::autofill_assistant::TriggerScriptConditionProto* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptConditionProto>(Arena*);
template<> ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition>(Arena*);
template<> ::autofill_assistant::TriggerScriptConditionsProto* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptConditionsProto>(Arena*);
template<> ::autofill_assistant::TriggerScriptProto* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptProto>(Arena*);
template<> ::autofill_assistant::TriggerScriptUIProto* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto>(Arena*);
template<> ::autofill_assistant::TriggerScriptUIProto_Popup* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto_Popup>(Arena*);
template<> ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto_Popup_Choice>(Arena*);
template<> ::autofill_assistant::TriggerScriptUIProto_ProgressBar* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto_ProgressBar>(Arena*);
template<> ::autofill_assistant::TriggerScriptUIProto_TriggerChip* Arena::CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto_TriggerChip>(Arena*);
template<> ::autofill_assistant::UnexpectedErrorInfoProto* Arena::CreateMaybeMessage<::autofill_assistant::UnexpectedErrorInfoProto>(Arena*);
template<> ::autofill_assistant::UpdateClientSettingsProto* Arena::CreateMaybeMessage<::autofill_assistant::UpdateClientSettingsProto>(Arena*);
template<> ::autofill_assistant::UploadDomProto* Arena::CreateMaybeMessage<::autofill_assistant::UploadDomProto>(Arena*);
template<> ::autofill_assistant::UploadDomProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::UploadDomProto_Result>(Arena*);
template<> ::autofill_assistant::UseAddressProto* Arena::CreateMaybeMessage<::autofill_assistant::UseAddressProto>(Arena*);
template<> ::autofill_assistant::UseCreditCardProto* Arena::CreateMaybeMessage<::autofill_assistant::UseCreditCardProto>(Arena*);
template<> ::autofill_assistant::UserFormSectionProto* Arena::CreateMaybeMessage<::autofill_assistant::UserFormSectionProto>(Arena*);
template<> ::autofill_assistant::WaitForDocumentProto* Arena::CreateMaybeMessage<::autofill_assistant::WaitForDocumentProto>(Arena*);
template<> ::autofill_assistant::WaitForDocumentProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::WaitForDocumentProto_Result>(Arena*);
template<> ::autofill_assistant::WaitForDomProto* Arena::CreateMaybeMessage<::autofill_assistant::WaitForDomProto>(Arena*);
template<> ::autofill_assistant::WaitForDomProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::WaitForDomProto_Result>(Arena*);
template<> ::autofill_assistant::WaitForNavigationProto* Arena::CreateMaybeMessage<::autofill_assistant::WaitForNavigationProto>(Arena*);
template<> ::autofill_assistant::WebControllerErrorInfoProto* Arena::CreateMaybeMessage<::autofill_assistant::WebControllerErrorInfoProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {

enum ClientContextProto_AccountsMatchingStatus : int {
  ClientContextProto_AccountsMatchingStatus_UNKNOWN = 0,
  ClientContextProto_AccountsMatchingStatus_ACCOUNTS_MATCHING = 1,
  ClientContextProto_AccountsMatchingStatus_ACCOUNTS_NOT_MATCHING = 2
};
bool ClientContextProto_AccountsMatchingStatus_IsValid(int value);
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_MIN = ClientContextProto_AccountsMatchingStatus_UNKNOWN;
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_MAX = ClientContextProto_AccountsMatchingStatus_ACCOUNTS_NOT_MATCHING;
constexpr int ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_ARRAYSIZE = ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_MAX + 1;

const std::string& ClientContextProto_AccountsMatchingStatus_Name(ClientContextProto_AccountsMatchingStatus value);
template<typename T>
inline const std::string& ClientContextProto_AccountsMatchingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientContextProto_AccountsMatchingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientContextProto_AccountsMatchingStatus_Name.");
  return ClientContextProto_AccountsMatchingStatus_Name(static_cast<ClientContextProto_AccountsMatchingStatus>(enum_t_value));
}
bool ClientContextProto_AccountsMatchingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_AccountsMatchingStatus* value);
enum ClientContextProto_SignedIntoChromeStatus : int {
  ClientContextProto_SignedIntoChromeStatus_UNDEFINED = 0,
  ClientContextProto_SignedIntoChromeStatus_NOT_SIGNED_IN = 1,
  ClientContextProto_SignedIntoChromeStatus_SIGNED_IN = 2
};
bool ClientContextProto_SignedIntoChromeStatus_IsValid(int value);
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_MIN = ClientContextProto_SignedIntoChromeStatus_UNDEFINED;
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_MAX = ClientContextProto_SignedIntoChromeStatus_SIGNED_IN;
constexpr int ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_ARRAYSIZE = ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_MAX + 1;

const std::string& ClientContextProto_SignedIntoChromeStatus_Name(ClientContextProto_SignedIntoChromeStatus value);
template<typename T>
inline const std::string& ClientContextProto_SignedIntoChromeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientContextProto_SignedIntoChromeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientContextProto_SignedIntoChromeStatus_Name.");
  return ClientContextProto_SignedIntoChromeStatus_Name(static_cast<ClientContextProto_SignedIntoChromeStatus>(enum_t_value));
}
bool ClientContextProto_SignedIntoChromeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_SignedIntoChromeStatus* value);
enum ClientContextProto_ScreenOrientation : int {
  ClientContextProto_ScreenOrientation_UNDEFINED_ORIENTATION = 0,
  ClientContextProto_ScreenOrientation_PORTRAIT = 1,
  ClientContextProto_ScreenOrientation_LANDSCAPE = 2
};
bool ClientContextProto_ScreenOrientation_IsValid(int value);
constexpr ClientContextProto_ScreenOrientation ClientContextProto_ScreenOrientation_ScreenOrientation_MIN = ClientContextProto_ScreenOrientation_UNDEFINED_ORIENTATION;
constexpr ClientContextProto_ScreenOrientation ClientContextProto_ScreenOrientation_ScreenOrientation_MAX = ClientContextProto_ScreenOrientation_LANDSCAPE;
constexpr int ClientContextProto_ScreenOrientation_ScreenOrientation_ARRAYSIZE = ClientContextProto_ScreenOrientation_ScreenOrientation_MAX + 1;

const std::string& ClientContextProto_ScreenOrientation_Name(ClientContextProto_ScreenOrientation value);
template<typename T>
inline const std::string& ClientContextProto_ScreenOrientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientContextProto_ScreenOrientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientContextProto_ScreenOrientation_Name.");
  return ClientContextProto_ScreenOrientation_Name(static_cast<ClientContextProto_ScreenOrientation>(enum_t_value));
}
bool ClientContextProto_ScreenOrientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_ScreenOrientation* value);
enum ClientContextProto_PlatformType : int {
  ClientContextProto_PlatformType_PLATFORM_TYPE_UNDEFINED = 0,
  ClientContextProto_PlatformType_PLATFORM_TYPE_ANDROID = 1,
  ClientContextProto_PlatformType_PLATFORM_TYPE_IOS = 2,
  ClientContextProto_PlatformType_PLATFORM_TYPE_DESKTOP = 3
};
bool ClientContextProto_PlatformType_IsValid(int value);
constexpr ClientContextProto_PlatformType ClientContextProto_PlatformType_PlatformType_MIN = ClientContextProto_PlatformType_PLATFORM_TYPE_UNDEFINED;
constexpr ClientContextProto_PlatformType ClientContextProto_PlatformType_PlatformType_MAX = ClientContextProto_PlatformType_PLATFORM_TYPE_DESKTOP;
constexpr int ClientContextProto_PlatformType_PlatformType_ARRAYSIZE = ClientContextProto_PlatformType_PlatformType_MAX + 1;

const std::string& ClientContextProto_PlatformType_Name(ClientContextProto_PlatformType value);
template<typename T>
inline const std::string& ClientContextProto_PlatformType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientContextProto_PlatformType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientContextProto_PlatformType_Name.");
  return ClientContextProto_PlatformType_Name(static_cast<ClientContextProto_PlatformType>(enum_t_value));
}
bool ClientContextProto_PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_PlatformType* value);
enum ClientSettingsProto_SlowWarningSettings_MessageMode : int {
  ClientSettingsProto_SlowWarningSettings_MessageMode_UNKNOWN = 0,
  ClientSettingsProto_SlowWarningSettings_MessageMode_CONCATENATE = 1,
  ClientSettingsProto_SlowWarningSettings_MessageMode_REPLACE = 2
};
bool ClientSettingsProto_SlowWarningSettings_MessageMode_IsValid(int value);
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_MIN = ClientSettingsProto_SlowWarningSettings_MessageMode_UNKNOWN;
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_MAX = ClientSettingsProto_SlowWarningSettings_MessageMode_REPLACE;
constexpr int ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_ARRAYSIZE = ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_MAX + 1;

const std::string& ClientSettingsProto_SlowWarningSettings_MessageMode_Name(ClientSettingsProto_SlowWarningSettings_MessageMode value);
template<typename T>
inline const std::string& ClientSettingsProto_SlowWarningSettings_MessageMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientSettingsProto_SlowWarningSettings_MessageMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientSettingsProto_SlowWarningSettings_MessageMode_Name.");
  return ClientSettingsProto_SlowWarningSettings_MessageMode_Name(static_cast<ClientSettingsProto_SlowWarningSettings_MessageMode>(enum_t_value));
}
bool ClientSettingsProto_SlowWarningSettings_MessageMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSettingsProto_SlowWarningSettings_MessageMode* value);
enum ClientSettingsProto_DisplayStringId : int {
  ClientSettingsProto_DisplayStringId_UNSPECIFIED = 0,
  ClientSettingsProto_DisplayStringId_GIVE_UP = 1,
  ClientSettingsProto_DisplayStringId_MAYBE_GIVE_UP = 2,
  ClientSettingsProto_DisplayStringId_DEFAULT_ERROR = 3,
  ClientSettingsProto_DisplayStringId_PAYMENT_INFO_CONFIRM = 4,
  ClientSettingsProto_DisplayStringId_CONTINUE_BUTTON = 5,
  ClientSettingsProto_DisplayStringId_STOPPED = 6,
  ClientSettingsProto_DisplayStringId_SEND_FEEDBACK = 7,
  ClientSettingsProto_DisplayStringId_CLOSE = 8,
  ClientSettingsProto_DisplayStringId_SETTINGS = 9,
  ClientSettingsProto_DisplayStringId_UNDO = 10
};
bool ClientSettingsProto_DisplayStringId_IsValid(int value);
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto_DisplayStringId_DisplayStringId_MIN = ClientSettingsProto_DisplayStringId_UNSPECIFIED;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto_DisplayStringId_DisplayStringId_MAX = ClientSettingsProto_DisplayStringId_UNDO;
constexpr int ClientSettingsProto_DisplayStringId_DisplayStringId_ARRAYSIZE = ClientSettingsProto_DisplayStringId_DisplayStringId_MAX + 1;

const std::string& ClientSettingsProto_DisplayStringId_Name(ClientSettingsProto_DisplayStringId value);
template<typename T>
inline const std::string& ClientSettingsProto_DisplayStringId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientSettingsProto_DisplayStringId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientSettingsProto_DisplayStringId_Name.");
  return ClientSettingsProto_DisplayStringId_Name(static_cast<ClientSettingsProto_DisplayStringId>(enum_t_value));
}
bool ClientSettingsProto_DisplayStringId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSettingsProto_DisplayStringId* value);
enum TriggerScriptProto_TriggerScriptAction : int {
  TriggerScriptProto_TriggerScriptAction_UNDEFINED = 0,
  TriggerScriptProto_TriggerScriptAction_NOT_NOW = 1,
  TriggerScriptProto_TriggerScriptAction_CANCEL_SESSION = 2,
  TriggerScriptProto_TriggerScriptAction_CANCEL_FOREVER = 3,
  TriggerScriptProto_TriggerScriptAction_SHOW_CANCEL_POPUP = 4,
  TriggerScriptProto_TriggerScriptAction_ACCEPT = 5
};
bool TriggerScriptProto_TriggerScriptAction_IsValid(int value);
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_MIN = TriggerScriptProto_TriggerScriptAction_UNDEFINED;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_MAX = TriggerScriptProto_TriggerScriptAction_ACCEPT;
constexpr int TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_ARRAYSIZE = TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_MAX + 1;

const std::string& TriggerScriptProto_TriggerScriptAction_Name(TriggerScriptProto_TriggerScriptAction value);
template<typename T>
inline const std::string& TriggerScriptProto_TriggerScriptAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriggerScriptProto_TriggerScriptAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriggerScriptProto_TriggerScriptAction_Name.");
  return TriggerScriptProto_TriggerScriptAction_Name(static_cast<TriggerScriptProto_TriggerScriptAction>(enum_t_value));
}
bool TriggerScriptProto_TriggerScriptAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerScriptProto_TriggerScriptAction* value);
enum TriggerScriptProto_TriggerUIType : int {
  TriggerScriptProto_TriggerUIType_UNSPECIFIED_TRIGGER_UI_TYPE = 0,
  TriggerScriptProto_TriggerUIType_SHOPPING_CART_FIRST_TIME_USER = 1,
  TriggerScriptProto_TriggerUIType_SHOPPING_CART_RETURNING_USER = 2,
  TriggerScriptProto_TriggerUIType_SHOPPING_CHECKOUT_FIRST_TIME_USER = 3,
  TriggerScriptProto_TriggerUIType_SHOPPING_CHECKOUT_RETURNING_USER = 4,
  TriggerScriptProto_TriggerUIType_FOOD_ORDERING_CART_FIRST_TIME_USER = 9,
  TriggerScriptProto_TriggerUIType_FOOD_ORDERING_CART_RETURNING_USER = 10,
  TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CART_FIRST_TIME_USER = 5,
  TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CART_RETURNING_USER = 6,
  TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER = 7,
  TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER = 8,
  TriggerScriptProto_TriggerUIType_IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER = 11,
  TriggerScriptProto_TriggerUIType_IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER = 12
};
bool TriggerScriptProto_TriggerUIType_IsValid(int value);
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto_TriggerUIType_TriggerUIType_MIN = TriggerScriptProto_TriggerUIType_UNSPECIFIED_TRIGGER_UI_TYPE;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto_TriggerUIType_TriggerUIType_MAX = TriggerScriptProto_TriggerUIType_IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER;
constexpr int TriggerScriptProto_TriggerUIType_TriggerUIType_ARRAYSIZE = TriggerScriptProto_TriggerUIType_TriggerUIType_MAX + 1;

const std::string& TriggerScriptProto_TriggerUIType_Name(TriggerScriptProto_TriggerUIType value);
template<typename T>
inline const std::string& TriggerScriptProto_TriggerUIType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriggerScriptProto_TriggerUIType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriggerScriptProto_TriggerUIType_Name.");
  return TriggerScriptProto_TriggerUIType_Name(static_cast<TriggerScriptProto_TriggerUIType>(enum_t_value));
}
bool TriggerScriptProto_TriggerUIType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerScriptProto_TriggerUIType* value);
enum UnexpectedErrorInfoProto_JsExceptionLocation : int {
  UnexpectedErrorInfoProto_JsExceptionLocation_UNKNOWN = 0,
  UnexpectedErrorInfoProto_JsExceptionLocation_JS_FLOW_LIBRARY = 1,
  UnexpectedErrorInfoProto_JsExceptionLocation_JS_FLOW = 2
};
bool UnexpectedErrorInfoProto_JsExceptionLocation_IsValid(int value);
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_MIN = UnexpectedErrorInfoProto_JsExceptionLocation_UNKNOWN;
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_MAX = UnexpectedErrorInfoProto_JsExceptionLocation_JS_FLOW;
constexpr int UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_ARRAYSIZE = UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_MAX + 1;

const std::string& UnexpectedErrorInfoProto_JsExceptionLocation_Name(UnexpectedErrorInfoProto_JsExceptionLocation value);
template<typename T>
inline const std::string& UnexpectedErrorInfoProto_JsExceptionLocation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnexpectedErrorInfoProto_JsExceptionLocation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnexpectedErrorInfoProto_JsExceptionLocation_Name.");
  return UnexpectedErrorInfoProto_JsExceptionLocation_Name(static_cast<UnexpectedErrorInfoProto_JsExceptionLocation>(enum_t_value));
}
bool UnexpectedErrorInfoProto_JsExceptionLocation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnexpectedErrorInfoProto_JsExceptionLocation* value);
enum AutofillErrorInfoProto_GetFullCardFailureType : int {
  AutofillErrorInfoProto_GetFullCardFailureType_UNKNOWN_FAILURE_TYPE = 0,
  AutofillErrorInfoProto_GetFullCardFailureType_PROMPT_CLOSED = 1,
  AutofillErrorInfoProto_GetFullCardFailureType_VERIFICATION_DECLINED = 2,
  AutofillErrorInfoProto_GetFullCardFailureType_GENERIC_FAILURE = 3
};
bool AutofillErrorInfoProto_GetFullCardFailureType_IsValid(int value);
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_MIN = AutofillErrorInfoProto_GetFullCardFailureType_UNKNOWN_FAILURE_TYPE;
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_MAX = AutofillErrorInfoProto_GetFullCardFailureType_GENERIC_FAILURE;
constexpr int AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_ARRAYSIZE = AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_MAX + 1;

const std::string& AutofillErrorInfoProto_GetFullCardFailureType_Name(AutofillErrorInfoProto_GetFullCardFailureType value);
template<typename T>
inline const std::string& AutofillErrorInfoProto_GetFullCardFailureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillErrorInfoProto_GetFullCardFailureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillErrorInfoProto_GetFullCardFailureType_Name.");
  return AutofillErrorInfoProto_GetFullCardFailureType_Name(static_cast<AutofillErrorInfoProto_GetFullCardFailureType>(enum_t_value));
}
bool AutofillErrorInfoProto_GetFullCardFailureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillErrorInfoProto_GetFullCardFailureType* value);
enum WebControllerErrorInfoProto_WebAction : int {
  WebControllerErrorInfoProto_WebAction_UNSPECIFIED_WEB_ACTION = 0,
  WebControllerErrorInfoProto_WebAction_SCROLL_INTO_VIEW = 1,
  WebControllerErrorInfoProto_WebAction_WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE = 2,
  WebControllerErrorInfoProto_WebAction_CLICK_OR_TAP_ELEMENT = 3,
  WebControllerErrorInfoProto_WebAction_SELECT_OPTION = 4,
  WebControllerErrorInfoProto_WebAction_SCROLL_INTO_VIEW_WITH_PADDING = 6,
  WebControllerErrorInfoProto_WebAction_GET_FIELD_VALUE = 7,
  WebControllerErrorInfoProto_WebAction_GET_STRING_ATTRIBUTE = 8,
  WebControllerErrorInfoProto_WebAction_SELECT_FIELD_VALUE = 9,
  WebControllerErrorInfoProto_WebAction_SET_VALUE_ATTRIBUTE = 10,
  WebControllerErrorInfoProto_WebAction_SET_ATTRIBUTE = 11,
  WebControllerErrorInfoProto_WebAction_SEND_KEYBOARD_INPUT = 12,
  WebControllerErrorInfoProto_WebAction_GET_OUTER_HTML = 13,
  WebControllerErrorInfoProto_WebAction_GET_ELEMENT_TAG = 14,
  WebControllerErrorInfoProto_WebAction_FOCUS_FIELD = 15,
  WebControllerErrorInfoProto_WebAction_WAIT_UNTIL_ELEMENT_IS_STABLE = 16,
  WebControllerErrorInfoProto_WebAction_ON_TOP = 17,
  WebControllerErrorInfoProto_WebAction_WAIT_FOR_DOCUMENT_READY_STATE = 18,
  WebControllerErrorInfoProto_WebAction_SEND_CHANGE_EVENT = 19,
  WebControllerErrorInfoProto_WebAction_DISPATCH_EVENT_ON_DOCUMENT = 20,
  WebControllerErrorInfoProto_WebAction_SEND_KEY_EVENT = 21,
  WebControllerErrorInfoProto_WebAction_SELECT_OPTION_ELEMENT = 22,
  WebControllerErrorInfoProto_WebAction_JS_CLICK_ELEMENT = 23,
  WebControllerErrorInfoProto_WebAction_CHECK_OPTION_ELEMENT = 24,
  WebControllerErrorInfoProto_WebAction_SCROLL_INTO_VIEW_IF_NEEDED = 25,
  WebControllerErrorInfoProto_WebAction_SCROLL_WINDOW = 26,
  WebControllerErrorInfoProto_WebAction_SCROLL_CONTAINER = 27,
  WebControllerErrorInfoProto_WebAction_BLUR_FIELD = 28,
  WebControllerErrorInfoProto_WebAction_EXECUTE_JS = 29
};
bool WebControllerErrorInfoProto_WebAction_IsValid(int value);
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto_WebAction_WebAction_MIN = WebControllerErrorInfoProto_WebAction_UNSPECIFIED_WEB_ACTION;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto_WebAction_WebAction_MAX = WebControllerErrorInfoProto_WebAction_EXECUTE_JS;
constexpr int WebControllerErrorInfoProto_WebAction_WebAction_ARRAYSIZE = WebControllerErrorInfoProto_WebAction_WebAction_MAX + 1;

const std::string& WebControllerErrorInfoProto_WebAction_Name(WebControllerErrorInfoProto_WebAction value);
template<typename T>
inline const std::string& WebControllerErrorInfoProto_WebAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebControllerErrorInfoProto_WebAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebControllerErrorInfoProto_WebAction_Name.");
  return WebControllerErrorInfoProto_WebAction_Name(static_cast<WebControllerErrorInfoProto_WebAction>(enum_t_value));
}
bool WebControllerErrorInfoProto_WebAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebControllerErrorInfoProto_WebAction* value);
enum ElementFinderInfoProto_SemanticInferenceStatus : int {
  ElementFinderInfoProto_SemanticInferenceStatus_UNKNOWN = 0,
  ElementFinderInfoProto_SemanticInferenceStatus_SUCCESS = 1,
  ElementFinderInfoProto_SemanticInferenceStatus_UNEXPECTED_ERROR = 2,
  ElementFinderInfoProto_SemanticInferenceStatus_INITIALIZATION_ERROR = 3,
  ElementFinderInfoProto_SemanticInferenceStatus_MODEL_LOAD_ERROR = 4,
  ElementFinderInfoProto_SemanticInferenceStatus_MODEL_LOAD_TIMEOUT = 5
};
bool ElementFinderInfoProto_SemanticInferenceStatus_IsValid(int value);
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_MIN = ElementFinderInfoProto_SemanticInferenceStatus_UNKNOWN;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_MAX = ElementFinderInfoProto_SemanticInferenceStatus_MODEL_LOAD_TIMEOUT;
constexpr int ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_ARRAYSIZE = ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_MAX + 1;

const std::string& ElementFinderInfoProto_SemanticInferenceStatus_Name(ElementFinderInfoProto_SemanticInferenceStatus value);
template<typename T>
inline const std::string& ElementFinderInfoProto_SemanticInferenceStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ElementFinderInfoProto_SemanticInferenceStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ElementFinderInfoProto_SemanticInferenceStatus_Name.");
  return ElementFinderInfoProto_SemanticInferenceStatus_Name(static_cast<ElementFinderInfoProto_SemanticInferenceStatus>(enum_t_value));
}
bool ElementFinderInfoProto_SemanticInferenceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ElementFinderInfoProto_SemanticInferenceStatus* value);
enum SelectOptionProto_OptionComparisonAttribute : int {
  SelectOptionProto_OptionComparisonAttribute_NOT_SET = 0,
  SelectOptionProto_OptionComparisonAttribute_VALUE = 1,
  SelectOptionProto_OptionComparisonAttribute_LABEL = 2
};
bool SelectOptionProto_OptionComparisonAttribute_IsValid(int value);
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_MIN = SelectOptionProto_OptionComparisonAttribute_NOT_SET;
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_MAX = SelectOptionProto_OptionComparisonAttribute_LABEL;
constexpr int SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_ARRAYSIZE = SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_MAX + 1;

const std::string& SelectOptionProto_OptionComparisonAttribute_Name(SelectOptionProto_OptionComparisonAttribute value);
template<typename T>
inline const std::string& SelectOptionProto_OptionComparisonAttribute_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelectOptionProto_OptionComparisonAttribute>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelectOptionProto_OptionComparisonAttribute_Name.");
  return SelectOptionProto_OptionComparisonAttribute_Name(static_cast<SelectOptionProto_OptionComparisonAttribute>(enum_t_value));
}
bool SelectOptionProto_OptionComparisonAttribute_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SelectOptionProto_OptionComparisonAttribute* value);
enum ContactDetailsProto_AutofillContactField : int {
  ContactDetailsProto_AutofillContactField_NAME_FULL = 7,
  ContactDetailsProto_AutofillContactField_EMAIL_ADDRESS = 9,
  ContactDetailsProto_AutofillContactField_PHONE_HOME_WHOLE_NUMBER = 14
};
bool ContactDetailsProto_AutofillContactField_IsValid(int value);
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto_AutofillContactField_AutofillContactField_MIN = ContactDetailsProto_AutofillContactField_NAME_FULL;
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto_AutofillContactField_AutofillContactField_MAX = ContactDetailsProto_AutofillContactField_PHONE_HOME_WHOLE_NUMBER;
constexpr int ContactDetailsProto_AutofillContactField_AutofillContactField_ARRAYSIZE = ContactDetailsProto_AutofillContactField_AutofillContactField_MAX + 1;

const std::string& ContactDetailsProto_AutofillContactField_Name(ContactDetailsProto_AutofillContactField value);
template<typename T>
inline const std::string& ContactDetailsProto_AutofillContactField_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContactDetailsProto_AutofillContactField>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContactDetailsProto_AutofillContactField_Name.");
  return ContactDetailsProto_AutofillContactField_Name(static_cast<ContactDetailsProto_AutofillContactField>(enum_t_value));
}
bool ContactDetailsProto_AutofillContactField_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContactDetailsProto_AutofillContactField* value);
enum TextInputProto_InputType : int {
  TextInputProto_InputType_UNDEFINED = 0,
  TextInputProto_InputType_INPUT_TEXT = 1,
  TextInputProto_InputType_INPUT_ALPHANUMERIC = 2
};
bool TextInputProto_InputType_IsValid(int value);
constexpr TextInputProto_InputType TextInputProto_InputType_InputType_MIN = TextInputProto_InputType_UNDEFINED;
constexpr TextInputProto_InputType TextInputProto_InputType_InputType_MAX = TextInputProto_InputType_INPUT_ALPHANUMERIC;
constexpr int TextInputProto_InputType_InputType_ARRAYSIZE = TextInputProto_InputType_InputType_MAX + 1;

const std::string& TextInputProto_InputType_Name(TextInputProto_InputType value);
template<typename T>
inline const std::string& TextInputProto_InputType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextInputProto_InputType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextInputProto_InputType_Name.");
  return TextInputProto_InputType_Name(static_cast<TextInputProto_InputType>(enum_t_value));
}
bool TextInputProto_InputType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextInputProto_InputType* value);
enum CollectUserDataProto_TermsAndConditionsState : int {
  CollectUserDataProto_TermsAndConditionsState_NOT_SELECTED = 0,
  CollectUserDataProto_TermsAndConditionsState_ACCEPTED = 1,
  CollectUserDataProto_TermsAndConditionsState_REVIEW_REQUIRED = 2
};
bool CollectUserDataProto_TermsAndConditionsState_IsValid(int value);
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_MIN = CollectUserDataProto_TermsAndConditionsState_NOT_SELECTED;
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_MAX = CollectUserDataProto_TermsAndConditionsState_REVIEW_REQUIRED;
constexpr int CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_ARRAYSIZE = CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_MAX + 1;

const std::string& CollectUserDataProto_TermsAndConditionsState_Name(CollectUserDataProto_TermsAndConditionsState value);
template<typename T>
inline const std::string& CollectUserDataProto_TermsAndConditionsState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectUserDataProto_TermsAndConditionsState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectUserDataProto_TermsAndConditionsState_Name.");
  return CollectUserDataProto_TermsAndConditionsState_Name(static_cast<CollectUserDataProto_TermsAndConditionsState>(enum_t_value));
}
bool CollectUserDataProto_TermsAndConditionsState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectUserDataProto_TermsAndConditionsState* value);
enum ConfigureUiStateProto_OverlayBehavior : int {
  ConfigureUiStateProto_OverlayBehavior_DEFAULT = 0,
  ConfigureUiStateProto_OverlayBehavior_HIDDEN = 1
};
bool ConfigureUiStateProto_OverlayBehavior_IsValid(int value);
constexpr ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_MIN = ConfigureUiStateProto_OverlayBehavior_DEFAULT;
constexpr ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_MAX = ConfigureUiStateProto_OverlayBehavior_HIDDEN;
constexpr int ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_ARRAYSIZE = ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_MAX + 1;

const std::string& ConfigureUiStateProto_OverlayBehavior_Name(ConfigureUiStateProto_OverlayBehavior value);
template<typename T>
inline const std::string& ConfigureUiStateProto_OverlayBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigureUiStateProto_OverlayBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigureUiStateProto_OverlayBehavior_Name.");
  return ConfigureUiStateProto_OverlayBehavior_Name(static_cast<ConfigureUiStateProto_OverlayBehavior>(enum_t_value));
}
bool ConfigureUiStateProto_OverlayBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigureUiStateProto_OverlayBehavior* value);
enum ConfigureBottomSheetProto_ViewportResizing : int {
  ConfigureBottomSheetProto_ViewportResizing_NO_CHANGE = 0,
  ConfigureBottomSheetProto_ViewportResizing_RESIZE_LAYOUT_VIEWPORT = 1,
  ConfigureBottomSheetProto_ViewportResizing_NO_RESIZE = 2,
  ConfigureBottomSheetProto_ViewportResizing_RESIZE_VISUAL_VIEWPORT = 3
};
bool ConfigureBottomSheetProto_ViewportResizing_IsValid(int value);
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_MIN = ConfigureBottomSheetProto_ViewportResizing_NO_CHANGE;
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_MAX = ConfigureBottomSheetProto_ViewportResizing_RESIZE_VISUAL_VIEWPORT;
constexpr int ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_ARRAYSIZE = ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_MAX + 1;

const std::string& ConfigureBottomSheetProto_ViewportResizing_Name(ConfigureBottomSheetProto_ViewportResizing value);
template<typename T>
inline const std::string& ConfigureBottomSheetProto_ViewportResizing_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigureBottomSheetProto_ViewportResizing>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigureBottomSheetProto_ViewportResizing_Name.");
  return ConfigureBottomSheetProto_ViewportResizing_Name(static_cast<ConfigureBottomSheetProto_ViewportResizing>(enum_t_value));
}
bool ConfigureBottomSheetProto_ViewportResizing_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigureBottomSheetProto_ViewportResizing* value);
enum ConfigureBottomSheetProto_PeekMode : int {
  ConfigureBottomSheetProto_PeekMode_UNDEFINED_PEEK_MODE = 0,
  ConfigureBottomSheetProto_PeekMode_HANDLE = 1,
  ConfigureBottomSheetProto_PeekMode_HANDLE_HEADER = 2,
  ConfigureBottomSheetProto_PeekMode_HANDLE_HEADER_CAROUSELS = 3
};
bool ConfigureBottomSheetProto_PeekMode_IsValid(int value);
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto_PeekMode_PeekMode_MIN = ConfigureBottomSheetProto_PeekMode_UNDEFINED_PEEK_MODE;
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto_PeekMode_PeekMode_MAX = ConfigureBottomSheetProto_PeekMode_HANDLE_HEADER_CAROUSELS;
constexpr int ConfigureBottomSheetProto_PeekMode_PeekMode_ARRAYSIZE = ConfigureBottomSheetProto_PeekMode_PeekMode_MAX + 1;

const std::string& ConfigureBottomSheetProto_PeekMode_Name(ConfigureBottomSheetProto_PeekMode value);
template<typename T>
inline const std::string& ConfigureBottomSheetProto_PeekMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfigureBottomSheetProto_PeekMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfigureBottomSheetProto_PeekMode_Name.");
  return ConfigureBottomSheetProto_PeekMode_Name(static_cast<ConfigureBottomSheetProto_PeekMode>(enum_t_value));
}
bool ConfigureBottomSheetProto_PeekMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigureBottomSheetProto_PeekMode* value);
enum GetElementStatusProto_ValueSource : int {
  GetElementStatusProto_ValueSource_NOT_SET = 0,
  GetElementStatusProto_ValueSource_VALUE = 1,
  GetElementStatusProto_ValueSource_INNER_TEXT = 2
};
bool GetElementStatusProto_ValueSource_IsValid(int value);
constexpr GetElementStatusProto_ValueSource GetElementStatusProto_ValueSource_ValueSource_MIN = GetElementStatusProto_ValueSource_NOT_SET;
constexpr GetElementStatusProto_ValueSource GetElementStatusProto_ValueSource_ValueSource_MAX = GetElementStatusProto_ValueSource_INNER_TEXT;
constexpr int GetElementStatusProto_ValueSource_ValueSource_ARRAYSIZE = GetElementStatusProto_ValueSource_ValueSource_MAX + 1;

const std::string& GetElementStatusProto_ValueSource_Name(GetElementStatusProto_ValueSource value);
template<typename T>
inline const std::string& GetElementStatusProto_ValueSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetElementStatusProto_ValueSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetElementStatusProto_ValueSource_Name.");
  return GetElementStatusProto_ValueSource_Name(static_cast<GetElementStatusProto_ValueSource>(enum_t_value));
}
bool GetElementStatusProto_ValueSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetElementStatusProto_ValueSource* value);
enum PolicyType : int {
  UNKNOWN_POLICY = 0,
  SCRIPT = 1
};
bool PolicyType_IsValid(int value);
constexpr PolicyType PolicyType_MIN = UNKNOWN_POLICY;
constexpr PolicyType PolicyType_MAX = SCRIPT;
constexpr int PolicyType_ARRAYSIZE = PolicyType_MAX + 1;

const std::string& PolicyType_Name(PolicyType value);
template<typename T>
inline const std::string& PolicyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolicyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolicyType_Name.");
  return PolicyType_Name(static_cast<PolicyType>(enum_t_value));
}
bool PolicyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyType* value);
enum SlowWarningStatus : int {
  NO_WARNING = 0,
  WARNING_TRIGGERED = 1,
  WARNING_SHOWN = 2
};
bool SlowWarningStatus_IsValid(int value);
constexpr SlowWarningStatus SlowWarningStatus_MIN = NO_WARNING;
constexpr SlowWarningStatus SlowWarningStatus_MAX = WARNING_SHOWN;
constexpr int SlowWarningStatus_ARRAYSIZE = SlowWarningStatus_MAX + 1;

const std::string& SlowWarningStatus_Name(SlowWarningStatus value);
template<typename T>
inline const std::string& SlowWarningStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SlowWarningStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SlowWarningStatus_Name.");
  return SlowWarningStatus_Name(static_cast<SlowWarningStatus>(enum_t_value));
}
bool SlowWarningStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SlowWarningStatus* value);
enum PseudoType : int {
  UNDEFINED = 0,
  FIRST_LINE = 1,
  FIRST_LETTER = 2,
  BEFORE = 3,
  AFTER = 4,
  BACKDROP = 5,
  SELECTION = 6,
  FIRST_LINE_INHERITED = 7,
  SCROLLBAR = 8,
  SCROLLBAR_THUMB = 9,
  SCROLLBAR_BUTTON = 10,
  SCROLLBAR_TRACK = 11,
  SCROLLBAR_TRACK_PIECE = 12,
  SCROLLBAR_CORNER = 13,
  RESIZER = 14,
  INPUT_LIST_BUTTON = 15
};
bool PseudoType_IsValid(int value);
constexpr PseudoType PseudoType_MIN = UNDEFINED;
constexpr PseudoType PseudoType_MAX = INPUT_LIST_BUTTON;
constexpr int PseudoType_ARRAYSIZE = PseudoType_MAX + 1;

const std::string& PseudoType_Name(PseudoType value);
template<typename T>
inline const std::string& PseudoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PseudoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PseudoType_Name.");
  return PseudoType_Name(static_cast<PseudoType>(enum_t_value));
}
bool PseudoType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PseudoType* value);
enum OptionalStep : int {
  STEP_UNSPECIFIED = 0,
  SKIP_STEP = 1,
  REPORT_STEP_RESULT = 2,
  REQUIRE_STEP_SUCCESS = 3
};
bool OptionalStep_IsValid(int value);
constexpr OptionalStep OptionalStep_MIN = STEP_UNSPECIFIED;
constexpr OptionalStep OptionalStep_MAX = REQUIRE_STEP_SUCCESS;
constexpr int OptionalStep_ARRAYSIZE = OptionalStep_MAX + 1;

const std::string& OptionalStep_Name(OptionalStep value);
template<typename T>
inline const std::string& OptionalStep_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OptionalStep>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OptionalStep_Name.");
  return OptionalStep_Name(static_cast<OptionalStep>(enum_t_value));
}
bool OptionalStep_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptionalStep* value);
enum DocumentReadyState : int {
  DOCUMENT_UNKNOWN_READY_STATE = 0,
  DOCUMENT_UNINITIALIZED = 1,
  DOCUMENT_LOADING = 2,
  DOCUMENT_LOADED = 3,
  DOCUMENT_INTERACTIVE = 4,
  DOCUMENT_COMPLETE = 5,
  DOCUMENT_MAX_READY_STATE = 5
};
bool DocumentReadyState_IsValid(int value);
constexpr DocumentReadyState DocumentReadyState_MIN = DOCUMENT_UNKNOWN_READY_STATE;
constexpr DocumentReadyState DocumentReadyState_MAX = DOCUMENT_COMPLETE;
constexpr int DocumentReadyState_ARRAYSIZE = DocumentReadyState_MAX + 1;

const std::string& DocumentReadyState_Name(DocumentReadyState value);
template<typename T>
inline const std::string& DocumentReadyState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DocumentReadyState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DocumentReadyState_Name.");
  return DocumentReadyState_Name(static_cast<DocumentReadyState>(enum_t_value));
}
bool DocumentReadyState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DocumentReadyState* value);
// ===================================================================

class FieldTrialProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FieldTrialProto) */ {
 public:
  inline FieldTrialProto() : FieldTrialProto(nullptr) {}
  ~FieldTrialProto() override;
  explicit PROTOBUF_CONSTEXPR FieldTrialProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldTrialProto(const FieldTrialProto& from);
  FieldTrialProto(FieldTrialProto&& from) noexcept
    : FieldTrialProto() {
    *this = ::std::move(from);
  }

  inline FieldTrialProto& operator=(const FieldTrialProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldTrialProto& operator=(FieldTrialProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FieldTrialProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldTrialProto* internal_default_instance() {
    return reinterpret_cast<const FieldTrialProto*>(
               &_FieldTrialProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FieldTrialProto& a, FieldTrialProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FieldTrialProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldTrialProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldTrialProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldTrialProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FieldTrialProto& from);
  void MergeFrom(const FieldTrialProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FieldTrialProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FieldTrialProto";
  }
  protected:
  explicit FieldTrialProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrialNameFieldNumber = 1,
    kGroupNameFieldNumber = 2,
  };
  // optional string trial_name = 1;
  bool has_trial_name() const;
  private:
  bool _internal_has_trial_name() const;
  public:
  void clear_trial_name();
  const std::string& trial_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trial_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trial_name();
  PROTOBUF_NODISCARD std::string* release_trial_name();
  void set_allocated_trial_name(std::string* trial_name);
  private:
  const std::string& _internal_trial_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trial_name(const std::string& value);
  std::string* _internal_mutable_trial_name();
  public:

  // optional string group_name = 2;
  bool has_group_name() const;
  private:
  bool _internal_has_group_name() const;
  public:
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.FieldTrialProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trial_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientContextProto_Chrome final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientContextProto.Chrome) */ {
 public:
  inline ClientContextProto_Chrome() : ClientContextProto_Chrome(nullptr) {}
  ~ClientContextProto_Chrome() override;
  explicit PROTOBUF_CONSTEXPR ClientContextProto_Chrome(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientContextProto_Chrome(const ClientContextProto_Chrome& from);
  ClientContextProto_Chrome(ClientContextProto_Chrome&& from) noexcept
    : ClientContextProto_Chrome() {
    *this = ::std::move(from);
  }

  inline ClientContextProto_Chrome& operator=(const ClientContextProto_Chrome& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientContextProto_Chrome& operator=(ClientContextProto_Chrome&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientContextProto_Chrome& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientContextProto_Chrome* internal_default_instance() {
    return reinterpret_cast<const ClientContextProto_Chrome*>(
               &_ClientContextProto_Chrome_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClientContextProto_Chrome& a, ClientContextProto_Chrome& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientContextProto_Chrome* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientContextProto_Chrome* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientContextProto_Chrome* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientContextProto_Chrome>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientContextProto_Chrome& from);
  void MergeFrom(const ClientContextProto_Chrome& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientContextProto_Chrome* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientContextProto.Chrome";
  }
  protected:
  explicit ClientContextProto_Chrome(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveFieldTrialsFieldNumber = 2,
    kChromeVersionFieldNumber = 1,
  };
  // repeated .autofill_assistant.FieldTrialProto active_field_trials = 2;
  int active_field_trials_size() const;
  private:
  int _internal_active_field_trials_size() const;
  public:
  void clear_active_field_trials();
  ::autofill_assistant::FieldTrialProto* mutable_active_field_trials(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FieldTrialProto >*
      mutable_active_field_trials();
  private:
  const ::autofill_assistant::FieldTrialProto& _internal_active_field_trials(int index) const;
  ::autofill_assistant::FieldTrialProto* _internal_add_active_field_trials();
  public:
  const ::autofill_assistant::FieldTrialProto& active_field_trials(int index) const;
  ::autofill_assistant::FieldTrialProto* add_active_field_trials();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FieldTrialProto >&
      active_field_trials() const;

  // optional string chrome_version = 1;
  bool has_chrome_version() const;
  private:
  bool _internal_has_chrome_version() const;
  public:
  void clear_chrome_version();
  const std::string& chrome_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chrome_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chrome_version();
  PROTOBUF_NODISCARD std::string* release_chrome_version();
  void set_allocated_chrome_version(std::string* chrome_version);
  private:
  const std::string& _internal_chrome_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_version(const std::string& value);
  std::string* _internal_mutable_chrome_version();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientContextProto.Chrome)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FieldTrialProto > active_field_trials_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_version_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientContextProto_DeviceContextProto_VersionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto) */ {
 public:
  inline ClientContextProto_DeviceContextProto_VersionProto() : ClientContextProto_DeviceContextProto_VersionProto(nullptr) {}
  ~ClientContextProto_DeviceContextProto_VersionProto() override;
  explicit PROTOBUF_CONSTEXPR ClientContextProto_DeviceContextProto_VersionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientContextProto_DeviceContextProto_VersionProto(const ClientContextProto_DeviceContextProto_VersionProto& from);
  ClientContextProto_DeviceContextProto_VersionProto(ClientContextProto_DeviceContextProto_VersionProto&& from) noexcept
    : ClientContextProto_DeviceContextProto_VersionProto() {
    *this = ::std::move(from);
  }

  inline ClientContextProto_DeviceContextProto_VersionProto& operator=(const ClientContextProto_DeviceContextProto_VersionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientContextProto_DeviceContextProto_VersionProto& operator=(ClientContextProto_DeviceContextProto_VersionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientContextProto_DeviceContextProto_VersionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientContextProto_DeviceContextProto_VersionProto* internal_default_instance() {
    return reinterpret_cast<const ClientContextProto_DeviceContextProto_VersionProto*>(
               &_ClientContextProto_DeviceContextProto_VersionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientContextProto_DeviceContextProto_VersionProto& a, ClientContextProto_DeviceContextProto_VersionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientContextProto_DeviceContextProto_VersionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientContextProto_DeviceContextProto_VersionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientContextProto_DeviceContextProto_VersionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientContextProto_DeviceContextProto_VersionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientContextProto_DeviceContextProto_VersionProto& from);
  void MergeFrom(const ClientContextProto_DeviceContextProto_VersionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientContextProto_DeviceContextProto_VersionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto";
  }
  protected:
  explicit ClientContextProto_DeviceContextProto_VersionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdkIntFieldNumber = 1,
  };
  // optional int32 sdk_int = 1;
  bool has_sdk_int() const;
  private:
  bool _internal_has_sdk_int() const;
  public:
  void clear_sdk_int();
  int32_t sdk_int() const;
  void set_sdk_int(int32_t value);
  private:
  int32_t _internal_sdk_int() const;
  void _internal_set_sdk_int(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t sdk_int_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientContextProto_DeviceContextProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientContextProto.DeviceContextProto) */ {
 public:
  inline ClientContextProto_DeviceContextProto() : ClientContextProto_DeviceContextProto(nullptr) {}
  ~ClientContextProto_DeviceContextProto() override;
  explicit PROTOBUF_CONSTEXPR ClientContextProto_DeviceContextProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientContextProto_DeviceContextProto(const ClientContextProto_DeviceContextProto& from);
  ClientContextProto_DeviceContextProto(ClientContextProto_DeviceContextProto&& from) noexcept
    : ClientContextProto_DeviceContextProto() {
    *this = ::std::move(from);
  }

  inline ClientContextProto_DeviceContextProto& operator=(const ClientContextProto_DeviceContextProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientContextProto_DeviceContextProto& operator=(ClientContextProto_DeviceContextProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientContextProto_DeviceContextProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientContextProto_DeviceContextProto* internal_default_instance() {
    return reinterpret_cast<const ClientContextProto_DeviceContextProto*>(
               &_ClientContextProto_DeviceContextProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientContextProto_DeviceContextProto& a, ClientContextProto_DeviceContextProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientContextProto_DeviceContextProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientContextProto_DeviceContextProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientContextProto_DeviceContextProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientContextProto_DeviceContextProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientContextProto_DeviceContextProto& from);
  void MergeFrom(const ClientContextProto_DeviceContextProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientContextProto_DeviceContextProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientContextProto.DeviceContextProto";
  }
  protected:
  explicit ClientContextProto_DeviceContextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientContextProto_DeviceContextProto_VersionProto VersionProto;

  // accessors -------------------------------------------------------

  enum : int {
    kManufacturerFieldNumber = 2,
    kModelFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // optional string manufacturer = 2;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // optional string model = 3;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional .autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto& version() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* release_version();
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* mutable_version();
  void set_allocated_version(::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* version);
  private:
  const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto& _internal_version() const;
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* version);
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* unsafe_arena_release_version();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientContextProto.DeviceContextProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* version_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientContextProto_WindowSize final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientContextProto.WindowSize) */ {
 public:
  inline ClientContextProto_WindowSize() : ClientContextProto_WindowSize(nullptr) {}
  ~ClientContextProto_WindowSize() override;
  explicit PROTOBUF_CONSTEXPR ClientContextProto_WindowSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientContextProto_WindowSize(const ClientContextProto_WindowSize& from);
  ClientContextProto_WindowSize(ClientContextProto_WindowSize&& from) noexcept
    : ClientContextProto_WindowSize() {
    *this = ::std::move(from);
  }

  inline ClientContextProto_WindowSize& operator=(const ClientContextProto_WindowSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientContextProto_WindowSize& operator=(ClientContextProto_WindowSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientContextProto_WindowSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientContextProto_WindowSize* internal_default_instance() {
    return reinterpret_cast<const ClientContextProto_WindowSize*>(
               &_ClientContextProto_WindowSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientContextProto_WindowSize& a, ClientContextProto_WindowSize& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientContextProto_WindowSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientContextProto_WindowSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientContextProto_WindowSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientContextProto_WindowSize>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientContextProto_WindowSize& from);
  void MergeFrom(const ClientContextProto_WindowSize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientContextProto_WindowSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientContextProto.WindowSize";
  }
  protected:
  explicit ClientContextProto_WindowSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightPixelsFieldNumber = 1,
    kWidthPixelsFieldNumber = 2,
  };
  // optional int32 height_pixels = 1;
  bool has_height_pixels() const;
  private:
  bool _internal_has_height_pixels() const;
  public:
  void clear_height_pixels();
  int32_t height_pixels() const;
  void set_height_pixels(int32_t value);
  private:
  int32_t _internal_height_pixels() const;
  void _internal_set_height_pixels(int32_t value);
  public:

  // optional int32 width_pixels = 2;
  bool has_width_pixels() const;
  private:
  bool _internal_has_width_pixels() const;
  public:
  void clear_width_pixels();
  int32_t width_pixels() const;
  void set_width_pixels(int32_t value);
  private:
  int32_t _internal_width_pixels() const;
  void _internal_set_width_pixels(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientContextProto.WindowSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t height_pixels_;
  int32_t width_pixels_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientContextProto_AnnotateDomModelContextProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto) */ {
 public:
  inline ClientContextProto_AnnotateDomModelContextProto() : ClientContextProto_AnnotateDomModelContextProto(nullptr) {}
  ~ClientContextProto_AnnotateDomModelContextProto() override;
  explicit PROTOBUF_CONSTEXPR ClientContextProto_AnnotateDomModelContextProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientContextProto_AnnotateDomModelContextProto(const ClientContextProto_AnnotateDomModelContextProto& from);
  ClientContextProto_AnnotateDomModelContextProto(ClientContextProto_AnnotateDomModelContextProto&& from) noexcept
    : ClientContextProto_AnnotateDomModelContextProto() {
    *this = ::std::move(from);
  }

  inline ClientContextProto_AnnotateDomModelContextProto& operator=(const ClientContextProto_AnnotateDomModelContextProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientContextProto_AnnotateDomModelContextProto& operator=(ClientContextProto_AnnotateDomModelContextProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientContextProto_AnnotateDomModelContextProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientContextProto_AnnotateDomModelContextProto* internal_default_instance() {
    return reinterpret_cast<const ClientContextProto_AnnotateDomModelContextProto*>(
               &_ClientContextProto_AnnotateDomModelContextProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientContextProto_AnnotateDomModelContextProto& a, ClientContextProto_AnnotateDomModelContextProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientContextProto_AnnotateDomModelContextProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientContextProto_AnnotateDomModelContextProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientContextProto_AnnotateDomModelContextProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientContextProto_AnnotateDomModelContextProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientContextProto_AnnotateDomModelContextProto& from);
  void MergeFrom(const ClientContextProto_AnnotateDomModelContextProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientContextProto_AnnotateDomModelContextProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientContextProto.AnnotateDomModelContextProto";
  }
  protected:
  explicit ClientContextProto_AnnotateDomModelContextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelVersionFieldNumber = 1,
    kForceSemanticSelectionFieldNumber = 2,
  };
  // optional int64 model_version = 1;
  bool has_model_version() const;
  private:
  bool _internal_has_model_version() const;
  public:
  void clear_model_version();
  int64_t model_version() const;
  void set_model_version(int64_t value);
  private:
  int64_t _internal_model_version() const;
  void _internal_set_model_version(int64_t value);
  public:

  // optional bool force_semantic_selection = 2;
  bool has_force_semantic_selection() const;
  private:
  bool _internal_has_force_semantic_selection() const;
  public:
  void clear_force_semantic_selection();
  bool force_semantic_selection() const;
  void set_force_semantic_selection(bool value);
  private:
  bool _internal_force_semantic_selection() const;
  void _internal_set_force_semantic_selection(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t model_version_;
  bool force_semantic_selection_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientContextProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientContextProto) */ {
 public:
  inline ClientContextProto() : ClientContextProto(nullptr) {}
  ~ClientContextProto() override;
  explicit PROTOBUF_CONSTEXPR ClientContextProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientContextProto(const ClientContextProto& from);
  ClientContextProto(ClientContextProto&& from) noexcept
    : ClientContextProto() {
    *this = ::std::move(from);
  }

  inline ClientContextProto& operator=(const ClientContextProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientContextProto& operator=(ClientContextProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientContextProto& default_instance() {
    return *internal_default_instance();
  }
  enum ClientCase {
    kChrome = 1,
    CLIENT_NOT_SET = 0,
  };

  static inline const ClientContextProto* internal_default_instance() {
    return reinterpret_cast<const ClientContextProto*>(
               &_ClientContextProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientContextProto& a, ClientContextProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientContextProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientContextProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientContextProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientContextProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientContextProto& from);
  void MergeFrom(const ClientContextProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientContextProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientContextProto";
  }
  protected:
  explicit ClientContextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientContextProto_Chrome Chrome;
  typedef ClientContextProto_DeviceContextProto DeviceContextProto;
  typedef ClientContextProto_WindowSize WindowSize;
  typedef ClientContextProto_AnnotateDomModelContextProto AnnotateDomModelContextProto;

  typedef ClientContextProto_AccountsMatchingStatus AccountsMatchingStatus;
  static constexpr AccountsMatchingStatus UNKNOWN =
    ClientContextProto_AccountsMatchingStatus_UNKNOWN;
  static constexpr AccountsMatchingStatus ACCOUNTS_MATCHING =
    ClientContextProto_AccountsMatchingStatus_ACCOUNTS_MATCHING;
  static constexpr AccountsMatchingStatus ACCOUNTS_NOT_MATCHING =
    ClientContextProto_AccountsMatchingStatus_ACCOUNTS_NOT_MATCHING;
  static inline bool AccountsMatchingStatus_IsValid(int value) {
    return ClientContextProto_AccountsMatchingStatus_IsValid(value);
  }
  static constexpr AccountsMatchingStatus AccountsMatchingStatus_MIN =
    ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_MIN;
  static constexpr AccountsMatchingStatus AccountsMatchingStatus_MAX =
    ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_MAX;
  static constexpr int AccountsMatchingStatus_ARRAYSIZE =
    ClientContextProto_AccountsMatchingStatus_AccountsMatchingStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AccountsMatchingStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AccountsMatchingStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AccountsMatchingStatus_Name.");
    return ClientContextProto_AccountsMatchingStatus_Name(enum_t_value);
  }
  static inline bool AccountsMatchingStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AccountsMatchingStatus* value) {
    return ClientContextProto_AccountsMatchingStatus_Parse(name, value);
  }

  typedef ClientContextProto_SignedIntoChromeStatus SignedIntoChromeStatus;
  static constexpr SignedIntoChromeStatus UNDEFINED =
    ClientContextProto_SignedIntoChromeStatus_UNDEFINED;
  static constexpr SignedIntoChromeStatus NOT_SIGNED_IN =
    ClientContextProto_SignedIntoChromeStatus_NOT_SIGNED_IN;
  static constexpr SignedIntoChromeStatus SIGNED_IN =
    ClientContextProto_SignedIntoChromeStatus_SIGNED_IN;
  static inline bool SignedIntoChromeStatus_IsValid(int value) {
    return ClientContextProto_SignedIntoChromeStatus_IsValid(value);
  }
  static constexpr SignedIntoChromeStatus SignedIntoChromeStatus_MIN =
    ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_MIN;
  static constexpr SignedIntoChromeStatus SignedIntoChromeStatus_MAX =
    ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_MAX;
  static constexpr int SignedIntoChromeStatus_ARRAYSIZE =
    ClientContextProto_SignedIntoChromeStatus_SignedIntoChromeStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SignedIntoChromeStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SignedIntoChromeStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SignedIntoChromeStatus_Name.");
    return ClientContextProto_SignedIntoChromeStatus_Name(enum_t_value);
  }
  static inline bool SignedIntoChromeStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SignedIntoChromeStatus* value) {
    return ClientContextProto_SignedIntoChromeStatus_Parse(name, value);
  }

  typedef ClientContextProto_ScreenOrientation ScreenOrientation;
  static constexpr ScreenOrientation UNDEFINED_ORIENTATION =
    ClientContextProto_ScreenOrientation_UNDEFINED_ORIENTATION;
  static constexpr ScreenOrientation PORTRAIT =
    ClientContextProto_ScreenOrientation_PORTRAIT;
  static constexpr ScreenOrientation LANDSCAPE =
    ClientContextProto_ScreenOrientation_LANDSCAPE;
  static inline bool ScreenOrientation_IsValid(int value) {
    return ClientContextProto_ScreenOrientation_IsValid(value);
  }
  static constexpr ScreenOrientation ScreenOrientation_MIN =
    ClientContextProto_ScreenOrientation_ScreenOrientation_MIN;
  static constexpr ScreenOrientation ScreenOrientation_MAX =
    ClientContextProto_ScreenOrientation_ScreenOrientation_MAX;
  static constexpr int ScreenOrientation_ARRAYSIZE =
    ClientContextProto_ScreenOrientation_ScreenOrientation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ScreenOrientation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScreenOrientation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScreenOrientation_Name.");
    return ClientContextProto_ScreenOrientation_Name(enum_t_value);
  }
  static inline bool ScreenOrientation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScreenOrientation* value) {
    return ClientContextProto_ScreenOrientation_Parse(name, value);
  }

  typedef ClientContextProto_PlatformType PlatformType;
  static constexpr PlatformType PLATFORM_TYPE_UNDEFINED =
    ClientContextProto_PlatformType_PLATFORM_TYPE_UNDEFINED;
  static constexpr PlatformType PLATFORM_TYPE_ANDROID =
    ClientContextProto_PlatformType_PLATFORM_TYPE_ANDROID;
  static constexpr PlatformType PLATFORM_TYPE_IOS =
    ClientContextProto_PlatformType_PLATFORM_TYPE_IOS;
  static constexpr PlatformType PLATFORM_TYPE_DESKTOP =
    ClientContextProto_PlatformType_PLATFORM_TYPE_DESKTOP;
  static inline bool PlatformType_IsValid(int value) {
    return ClientContextProto_PlatformType_IsValid(value);
  }
  static constexpr PlatformType PlatformType_MIN =
    ClientContextProto_PlatformType_PlatformType_MIN;
  static constexpr PlatformType PlatformType_MAX =
    ClientContextProto_PlatformType_PlatformType_MAX;
  static constexpr int PlatformType_ARRAYSIZE =
    ClientContextProto_PlatformType_PlatformType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PlatformType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlatformType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlatformType_Name.");
    return ClientContextProto_PlatformType_Name(enum_t_value);
  }
  static inline bool PlatformType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlatformType* value) {
    return ClientContextProto_PlatformType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 5,
    kCountryFieldNumber = 6,
    kExperimentIdsFieldNumber = 7,
    kDeviceContextFieldNumber = 11,
    kWindowSizeFieldNumber = 15,
    kAnnotateDomModelContextFieldNumber = 22,
    kIsCctFieldNumber = 8,
    kIsOnboardingShownFieldNumber = 10,
    kIsDirectActionFieldNumber = 9,
    kIsInChromeTriggeredFieldNumber = 17,
    kAccountsMatchingStatusFieldNumber = 12,
    kSignedIntoChromeStatusFieldNumber = 14,
    kScreenOrientationFieldNumber = 16,
    kTriggerUiTypeFieldNumber = 18,
    kAccessibilityEnabledFieldNumber = 13,
    kJsFlowLibraryLoadedFieldNumber = 23,
    kPlatformTypeFieldNumber = 20,
    kChromeFieldNumber = 1,
  };
  // optional string locale = 5;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional string country = 6;
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string experiment_ids = 7;
  bool has_experiment_ids() const;
  private:
  bool _internal_has_experiment_ids() const;
  public:
  void clear_experiment_ids();
  const std::string& experiment_ids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_experiment_ids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_experiment_ids();
  PROTOBUF_NODISCARD std::string* release_experiment_ids();
  void set_allocated_experiment_ids(std::string* experiment_ids);
  private:
  const std::string& _internal_experiment_ids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_experiment_ids(const std::string& value);
  std::string* _internal_mutable_experiment_ids();
  public:

  // optional .autofill_assistant.ClientContextProto.DeviceContextProto device_context = 11;
  bool has_device_context() const;
  private:
  bool _internal_has_device_context() const;
  public:
  void clear_device_context();
  const ::autofill_assistant::ClientContextProto_DeviceContextProto& device_context() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto_DeviceContextProto* release_device_context();
  ::autofill_assistant::ClientContextProto_DeviceContextProto* mutable_device_context();
  void set_allocated_device_context(::autofill_assistant::ClientContextProto_DeviceContextProto* device_context);
  private:
  const ::autofill_assistant::ClientContextProto_DeviceContextProto& _internal_device_context() const;
  ::autofill_assistant::ClientContextProto_DeviceContextProto* _internal_mutable_device_context();
  public:
  void unsafe_arena_set_allocated_device_context(
      ::autofill_assistant::ClientContextProto_DeviceContextProto* device_context);
  ::autofill_assistant::ClientContextProto_DeviceContextProto* unsafe_arena_release_device_context();

  // optional .autofill_assistant.ClientContextProto.WindowSize window_size = 15;
  bool has_window_size() const;
  private:
  bool _internal_has_window_size() const;
  public:
  void clear_window_size();
  const ::autofill_assistant::ClientContextProto_WindowSize& window_size() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto_WindowSize* release_window_size();
  ::autofill_assistant::ClientContextProto_WindowSize* mutable_window_size();
  void set_allocated_window_size(::autofill_assistant::ClientContextProto_WindowSize* window_size);
  private:
  const ::autofill_assistant::ClientContextProto_WindowSize& _internal_window_size() const;
  ::autofill_assistant::ClientContextProto_WindowSize* _internal_mutable_window_size();
  public:
  void unsafe_arena_set_allocated_window_size(
      ::autofill_assistant::ClientContextProto_WindowSize* window_size);
  ::autofill_assistant::ClientContextProto_WindowSize* unsafe_arena_release_window_size();

  // optional .autofill_assistant.ClientContextProto.AnnotateDomModelContextProto annotate_dom_model_context = 22;
  bool has_annotate_dom_model_context() const;
  private:
  bool _internal_has_annotate_dom_model_context() const;
  public:
  void clear_annotate_dom_model_context();
  const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto& annotate_dom_model_context() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* release_annotate_dom_model_context();
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* mutable_annotate_dom_model_context();
  void set_allocated_annotate_dom_model_context(::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* annotate_dom_model_context);
  private:
  const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto& _internal_annotate_dom_model_context() const;
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* _internal_mutable_annotate_dom_model_context();
  public:
  void unsafe_arena_set_allocated_annotate_dom_model_context(
      ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* annotate_dom_model_context);
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* unsafe_arena_release_annotate_dom_model_context();

  // optional bool is_cct = 8;
  bool has_is_cct() const;
  private:
  bool _internal_has_is_cct() const;
  public:
  void clear_is_cct();
  bool is_cct() const;
  void set_is_cct(bool value);
  private:
  bool _internal_is_cct() const;
  void _internal_set_is_cct(bool value);
  public:

  // optional bool is_onboarding_shown = 10;
  bool has_is_onboarding_shown() const;
  private:
  bool _internal_has_is_onboarding_shown() const;
  public:
  void clear_is_onboarding_shown();
  bool is_onboarding_shown() const;
  void set_is_onboarding_shown(bool value);
  private:
  bool _internal_is_onboarding_shown() const;
  void _internal_set_is_onboarding_shown(bool value);
  public:

  // optional bool is_direct_action = 9;
  bool has_is_direct_action() const;
  private:
  bool _internal_has_is_direct_action() const;
  public:
  void clear_is_direct_action();
  bool is_direct_action() const;
  void set_is_direct_action(bool value);
  private:
  bool _internal_is_direct_action() const;
  void _internal_set_is_direct_action(bool value);
  public:

  // optional bool is_in_chrome_triggered = 17;
  bool has_is_in_chrome_triggered() const;
  private:
  bool _internal_has_is_in_chrome_triggered() const;
  public:
  void clear_is_in_chrome_triggered();
  bool is_in_chrome_triggered() const;
  void set_is_in_chrome_triggered(bool value);
  private:
  bool _internal_is_in_chrome_triggered() const;
  void _internal_set_is_in_chrome_triggered(bool value);
  public:

  // optional .autofill_assistant.ClientContextProto.AccountsMatchingStatus accounts_matching_status = 12;
  bool has_accounts_matching_status() const;
  private:
  bool _internal_has_accounts_matching_status() const;
  public:
  void clear_accounts_matching_status();
  ::autofill_assistant::ClientContextProto_AccountsMatchingStatus accounts_matching_status() const;
  void set_accounts_matching_status(::autofill_assistant::ClientContextProto_AccountsMatchingStatus value);
  private:
  ::autofill_assistant::ClientContextProto_AccountsMatchingStatus _internal_accounts_matching_status() const;
  void _internal_set_accounts_matching_status(::autofill_assistant::ClientContextProto_AccountsMatchingStatus value);
  public:

  // optional .autofill_assistant.ClientContextProto.SignedIntoChromeStatus signed_into_chrome_status = 14;
  bool has_signed_into_chrome_status() const;
  private:
  bool _internal_has_signed_into_chrome_status() const;
  public:
  void clear_signed_into_chrome_status();
  ::autofill_assistant::ClientContextProto_SignedIntoChromeStatus signed_into_chrome_status() const;
  void set_signed_into_chrome_status(::autofill_assistant::ClientContextProto_SignedIntoChromeStatus value);
  private:
  ::autofill_assistant::ClientContextProto_SignedIntoChromeStatus _internal_signed_into_chrome_status() const;
  void _internal_set_signed_into_chrome_status(::autofill_assistant::ClientContextProto_SignedIntoChromeStatus value);
  public:

  // optional .autofill_assistant.ClientContextProto.ScreenOrientation screen_orientation = 16;
  bool has_screen_orientation() const;
  private:
  bool _internal_has_screen_orientation() const;
  public:
  void clear_screen_orientation();
  ::autofill_assistant::ClientContextProto_ScreenOrientation screen_orientation() const;
  void set_screen_orientation(::autofill_assistant::ClientContextProto_ScreenOrientation value);
  private:
  ::autofill_assistant::ClientContextProto_ScreenOrientation _internal_screen_orientation() const;
  void _internal_set_screen_orientation(::autofill_assistant::ClientContextProto_ScreenOrientation value);
  public:

  // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 18;
  bool has_trigger_ui_type() const;
  private:
  bool _internal_has_trigger_ui_type() const;
  public:
  void clear_trigger_ui_type();
  ::autofill_assistant::TriggerScriptProto_TriggerUIType trigger_ui_type() const;
  void set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value);
  private:
  ::autofill_assistant::TriggerScriptProto_TriggerUIType _internal_trigger_ui_type() const;
  void _internal_set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value);
  public:

  // optional bool accessibility_enabled = 13;
  bool has_accessibility_enabled() const;
  private:
  bool _internal_has_accessibility_enabled() const;
  public:
  void clear_accessibility_enabled();
  bool accessibility_enabled() const;
  void set_accessibility_enabled(bool value);
  private:
  bool _internal_accessibility_enabled() const;
  void _internal_set_accessibility_enabled(bool value);
  public:

  // optional bool js_flow_library_loaded = 23;
  bool has_js_flow_library_loaded() const;
  private:
  bool _internal_has_js_flow_library_loaded() const;
  public:
  void clear_js_flow_library_loaded();
  bool js_flow_library_loaded() const;
  void set_js_flow_library_loaded(bool value);
  private:
  bool _internal_js_flow_library_loaded() const;
  void _internal_set_js_flow_library_loaded(bool value);
  public:

  // optional .autofill_assistant.ClientContextProto.PlatformType platform_type = 20;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::autofill_assistant::ClientContextProto_PlatformType platform_type() const;
  void set_platform_type(::autofill_assistant::ClientContextProto_PlatformType value);
  private:
  ::autofill_assistant::ClientContextProto_PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::autofill_assistant::ClientContextProto_PlatformType value);
  public:

  // .autofill_assistant.ClientContextProto.Chrome chrome = 1;
  bool has_chrome() const;
  private:
  bool _internal_has_chrome() const;
  public:
  void clear_chrome();
  const ::autofill_assistant::ClientContextProto_Chrome& chrome() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto_Chrome* release_chrome();
  ::autofill_assistant::ClientContextProto_Chrome* mutable_chrome();
  void set_allocated_chrome(::autofill_assistant::ClientContextProto_Chrome* chrome);
  private:
  const ::autofill_assistant::ClientContextProto_Chrome& _internal_chrome() const;
  ::autofill_assistant::ClientContextProto_Chrome* _internal_mutable_chrome();
  public:
  void unsafe_arena_set_allocated_chrome(
      ::autofill_assistant::ClientContextProto_Chrome* chrome);
  ::autofill_assistant::ClientContextProto_Chrome* unsafe_arena_release_chrome();

  void clear_client();
  ClientCase client_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientContextProto)
 private:
  class _Internal;
  void set_has_chrome();

  inline bool has_client() const;
  inline void clear_has_client();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr experiment_ids_;
  ::autofill_assistant::ClientContextProto_DeviceContextProto* device_context_;
  ::autofill_assistant::ClientContextProto_WindowSize* window_size_;
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* annotate_dom_model_context_;
  bool is_cct_;
  bool is_onboarding_shown_;
  bool is_direct_action_;
  bool is_in_chrome_triggered_;
  int accounts_matching_status_;
  int signed_into_chrome_status_;
  int screen_orientation_;
  int trigger_ui_type_;
  bool accessibility_enabled_;
  bool js_flow_library_loaded_;
  int platform_type_;
  union ClientUnion {
    constexpr ClientUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::ClientContextProto_Chrome* chrome_;
  } client_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SupportsScriptRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SupportsScriptRequestProto) */ {
 public:
  inline SupportsScriptRequestProto() : SupportsScriptRequestProto(nullptr) {}
  ~SupportsScriptRequestProto() override;
  explicit PROTOBUF_CONSTEXPR SupportsScriptRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupportsScriptRequestProto(const SupportsScriptRequestProto& from);
  SupportsScriptRequestProto(SupportsScriptRequestProto&& from) noexcept
    : SupportsScriptRequestProto() {
    *this = ::std::move(from);
  }

  inline SupportsScriptRequestProto& operator=(const SupportsScriptRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupportsScriptRequestProto& operator=(SupportsScriptRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SupportsScriptRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupportsScriptRequestProto* internal_default_instance() {
    return reinterpret_cast<const SupportsScriptRequestProto*>(
               &_SupportsScriptRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SupportsScriptRequestProto& a, SupportsScriptRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SupportsScriptRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupportsScriptRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupportsScriptRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupportsScriptRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SupportsScriptRequestProto& from);
  void MergeFrom(const SupportsScriptRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SupportsScriptRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SupportsScriptRequestProto";
  }
  protected:
  explicit SupportsScriptRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptParametersFieldNumber = 2,
    kUrlFieldNumber = 1,
    kClientContextFieldNumber = 3,
  };
  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
  int script_parameters_size() const;
  private:
  int _internal_script_parameters_size() const;
  public:
  void clear_script_parameters();
  ::autofill_assistant::ScriptParameterProto* mutable_script_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_script_parameters();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_script_parameters();
  public:
  const ::autofill_assistant::ScriptParameterProto& script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_script_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      script_parameters() const;

  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional .autofill_assistant.ClientContextProto client_context = 3;
  bool has_client_context() const;
  private:
  bool _internal_has_client_context() const;
  public:
  void clear_client_context();
  const ::autofill_assistant::ClientContextProto& client_context() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto* release_client_context();
  ::autofill_assistant::ClientContextProto* mutable_client_context();
  void set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context);
  private:
  const ::autofill_assistant::ClientContextProto& _internal_client_context() const;
  ::autofill_assistant::ClientContextProto* _internal_mutable_client_context();
  public:
  void unsafe_arena_set_allocated_client_context(
      ::autofill_assistant::ClientContextProto* client_context);
  ::autofill_assistant::ClientContextProto* unsafe_arena_release_client_context();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SupportsScriptRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > script_parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::autofill_assistant::ClientContextProto* client_context_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ImplicitTriggeringDebugParametersProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ImplicitTriggeringDebugParametersProto) */ {
 public:
  inline ImplicitTriggeringDebugParametersProto() : ImplicitTriggeringDebugParametersProto(nullptr) {}
  ~ImplicitTriggeringDebugParametersProto() override;
  explicit PROTOBUF_CONSTEXPR ImplicitTriggeringDebugParametersProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImplicitTriggeringDebugParametersProto(const ImplicitTriggeringDebugParametersProto& from);
  ImplicitTriggeringDebugParametersProto(ImplicitTriggeringDebugParametersProto&& from) noexcept
    : ImplicitTriggeringDebugParametersProto() {
    *this = ::std::move(from);
  }

  inline ImplicitTriggeringDebugParametersProto& operator=(const ImplicitTriggeringDebugParametersProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImplicitTriggeringDebugParametersProto& operator=(ImplicitTriggeringDebugParametersProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ImplicitTriggeringDebugParametersProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImplicitTriggeringDebugParametersProto* internal_default_instance() {
    return reinterpret_cast<const ImplicitTriggeringDebugParametersProto*>(
               &_ImplicitTriggeringDebugParametersProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ImplicitTriggeringDebugParametersProto& a, ImplicitTriggeringDebugParametersProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ImplicitTriggeringDebugParametersProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImplicitTriggeringDebugParametersProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImplicitTriggeringDebugParametersProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImplicitTriggeringDebugParametersProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImplicitTriggeringDebugParametersProto& from);
  void MergeFrom(const ImplicitTriggeringDebugParametersProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImplicitTriggeringDebugParametersProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ImplicitTriggeringDebugParametersProto";
  }
  protected:
  explicit ImplicitTriggeringDebugParametersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalScriptParametersFieldNumber = 1,
  };
  // repeated .autofill_assistant.ScriptParameterProto additional_script_parameters = 1;
  int additional_script_parameters_size() const;
  private:
  int _internal_additional_script_parameters_size() const;
  public:
  void clear_additional_script_parameters();
  ::autofill_assistant::ScriptParameterProto* mutable_additional_script_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_additional_script_parameters();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_additional_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_additional_script_parameters();
  public:
  const ::autofill_assistant::ScriptParameterProto& additional_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_additional_script_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      additional_script_parameters() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ImplicitTriggeringDebugParametersProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > additional_script_parameters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ScriptParameterProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScriptParameterProto) */ {
 public:
  inline ScriptParameterProto() : ScriptParameterProto(nullptr) {}
  ~ScriptParameterProto() override;
  explicit PROTOBUF_CONSTEXPR ScriptParameterProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptParameterProto(const ScriptParameterProto& from);
  ScriptParameterProto(ScriptParameterProto&& from) noexcept
    : ScriptParameterProto() {
    *this = ::std::move(from);
  }

  inline ScriptParameterProto& operator=(const ScriptParameterProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptParameterProto& operator=(ScriptParameterProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScriptParameterProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScriptParameterProto* internal_default_instance() {
    return reinterpret_cast<const ScriptParameterProto*>(
               &_ScriptParameterProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ScriptParameterProto& a, ScriptParameterProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScriptParameterProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptParameterProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptParameterProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptParameterProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScriptParameterProto& from);
  void MergeFrom(const ScriptParameterProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScriptParameterProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScriptParameterProto";
  }
  protected:
  explicit ScriptParameterProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScriptParameterProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SupportsScriptResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SupportsScriptResponseProto) */ {
 public:
  inline SupportsScriptResponseProto() : SupportsScriptResponseProto(nullptr) {}
  ~SupportsScriptResponseProto() override;
  explicit PROTOBUF_CONSTEXPR SupportsScriptResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupportsScriptResponseProto(const SupportsScriptResponseProto& from);
  SupportsScriptResponseProto(SupportsScriptResponseProto&& from) noexcept
    : SupportsScriptResponseProto() {
    *this = ::std::move(from);
  }

  inline SupportsScriptResponseProto& operator=(const SupportsScriptResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupportsScriptResponseProto& operator=(SupportsScriptResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SupportsScriptResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupportsScriptResponseProto* internal_default_instance() {
    return reinterpret_cast<const SupportsScriptResponseProto*>(
               &_SupportsScriptResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SupportsScriptResponseProto& a, SupportsScriptResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SupportsScriptResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupportsScriptResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupportsScriptResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupportsScriptResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SupportsScriptResponseProto& from);
  void MergeFrom(const SupportsScriptResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SupportsScriptResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SupportsScriptResponseProto";
  }
  protected:
  explicit SupportsScriptResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptsFieldNumber = 1,
    kScriptTimeoutErrorFieldNumber = 2,
    kClientSettingsFieldNumber = 3,
    kScriptStoreConfigFieldNumber = 6,
    kSemanticSelectorPolicyFieldNumber = 7,
  };
  // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
  int scripts_size() const;
  private:
  int _internal_scripts_size() const;
  public:
  void clear_scripts();
  ::autofill_assistant::SupportedScriptProto* mutable_scripts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >*
      mutable_scripts();
  private:
  const ::autofill_assistant::SupportedScriptProto& _internal_scripts(int index) const;
  ::autofill_assistant::SupportedScriptProto* _internal_add_scripts();
  public:
  const ::autofill_assistant::SupportedScriptProto& scripts(int index) const;
  ::autofill_assistant::SupportedScriptProto* add_scripts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >&
      scripts() const;

  // optional .autofill_assistant.ScriptTimeoutError script_timeout_error = 2;
  bool has_script_timeout_error() const;
  private:
  bool _internal_has_script_timeout_error() const;
  public:
  void clear_script_timeout_error();
  const ::autofill_assistant::ScriptTimeoutError& script_timeout_error() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScriptTimeoutError* release_script_timeout_error();
  ::autofill_assistant::ScriptTimeoutError* mutable_script_timeout_error();
  void set_allocated_script_timeout_error(::autofill_assistant::ScriptTimeoutError* script_timeout_error);
  private:
  const ::autofill_assistant::ScriptTimeoutError& _internal_script_timeout_error() const;
  ::autofill_assistant::ScriptTimeoutError* _internal_mutable_script_timeout_error();
  public:
  void unsafe_arena_set_allocated_script_timeout_error(
      ::autofill_assistant::ScriptTimeoutError* script_timeout_error);
  ::autofill_assistant::ScriptTimeoutError* unsafe_arena_release_script_timeout_error();

  // optional .autofill_assistant.ClientSettingsProto client_settings = 3;
  bool has_client_settings() const;
  private:
  bool _internal_has_client_settings() const;
  public:
  void clear_client_settings();
  const ::autofill_assistant::ClientSettingsProto& client_settings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientSettingsProto* release_client_settings();
  ::autofill_assistant::ClientSettingsProto* mutable_client_settings();
  void set_allocated_client_settings(::autofill_assistant::ClientSettingsProto* client_settings);
  private:
  const ::autofill_assistant::ClientSettingsProto& _internal_client_settings() const;
  ::autofill_assistant::ClientSettingsProto* _internal_mutable_client_settings();
  public:
  void unsafe_arena_set_allocated_client_settings(
      ::autofill_assistant::ClientSettingsProto* client_settings);
  ::autofill_assistant::ClientSettingsProto* unsafe_arena_release_client_settings();

  // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
  bool has_script_store_config() const;
  private:
  bool _internal_has_script_store_config() const;
  public:
  void clear_script_store_config();
  const ::autofill_assistant::ScriptStoreConfig& script_store_config() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScriptStoreConfig* release_script_store_config();
  ::autofill_assistant::ScriptStoreConfig* mutable_script_store_config();
  void set_allocated_script_store_config(::autofill_assistant::ScriptStoreConfig* script_store_config);
  private:
  const ::autofill_assistant::ScriptStoreConfig& _internal_script_store_config() const;
  ::autofill_assistant::ScriptStoreConfig* _internal_mutable_script_store_config();
  public:
  void unsafe_arena_set_allocated_script_store_config(
      ::autofill_assistant::ScriptStoreConfig* script_store_config);
  ::autofill_assistant::ScriptStoreConfig* unsafe_arena_release_script_store_config();

  // optional .autofill_assistant.SemanticSelectorPolicy semantic_selector_policy = 7;
  bool has_semantic_selector_policy() const;
  private:
  bool _internal_has_semantic_selector_policy() const;
  public:
  void clear_semantic_selector_policy();
  const ::autofill_assistant::SemanticSelectorPolicy& semantic_selector_policy() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SemanticSelectorPolicy* release_semantic_selector_policy();
  ::autofill_assistant::SemanticSelectorPolicy* mutable_semantic_selector_policy();
  void set_allocated_semantic_selector_policy(::autofill_assistant::SemanticSelectorPolicy* semantic_selector_policy);
  private:
  const ::autofill_assistant::SemanticSelectorPolicy& _internal_semantic_selector_policy() const;
  ::autofill_assistant::SemanticSelectorPolicy* _internal_mutable_semantic_selector_policy();
  public:
  void unsafe_arena_set_allocated_semantic_selector_policy(
      ::autofill_assistant::SemanticSelectorPolicy* semantic_selector_policy);
  ::autofill_assistant::SemanticSelectorPolicy* unsafe_arena_release_semantic_selector_policy();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SupportsScriptResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto > scripts_;
  ::autofill_assistant::ScriptTimeoutError* script_timeout_error_;
  ::autofill_assistant::ClientSettingsProto* client_settings_;
  ::autofill_assistant::ScriptStoreConfig* script_store_config_;
  ::autofill_assistant::SemanticSelectorPolicy* semantic_selector_policy_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetCapabilitiesByHashPrefixRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto) */ {
 public:
  inline GetCapabilitiesByHashPrefixRequestProto() : GetCapabilitiesByHashPrefixRequestProto(nullptr) {}
  ~GetCapabilitiesByHashPrefixRequestProto() override;
  explicit PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCapabilitiesByHashPrefixRequestProto(const GetCapabilitiesByHashPrefixRequestProto& from);
  GetCapabilitiesByHashPrefixRequestProto(GetCapabilitiesByHashPrefixRequestProto&& from) noexcept
    : GetCapabilitiesByHashPrefixRequestProto() {
    *this = ::std::move(from);
  }

  inline GetCapabilitiesByHashPrefixRequestProto& operator=(const GetCapabilitiesByHashPrefixRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapabilitiesByHashPrefixRequestProto& operator=(GetCapabilitiesByHashPrefixRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetCapabilitiesByHashPrefixRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCapabilitiesByHashPrefixRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetCapabilitiesByHashPrefixRequestProto*>(
               &_GetCapabilitiesByHashPrefixRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetCapabilitiesByHashPrefixRequestProto& a, GetCapabilitiesByHashPrefixRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCapabilitiesByHashPrefixRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapabilitiesByHashPrefixRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCapabilitiesByHashPrefixRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCapabilitiesByHashPrefixRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCapabilitiesByHashPrefixRequestProto& from);
  void MergeFrom(const GetCapabilitiesByHashPrefixRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCapabilitiesByHashPrefixRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetCapabilitiesByHashPrefixRequestProto";
  }
  protected:
  explicit GetCapabilitiesByHashPrefixRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashPrefixFieldNumber = 2,
    kScriptParametersFieldNumber = 4,
    kClientContextFieldNumber = 3,
    kHashPrefixLengthFieldNumber = 1,
  };
  // repeated uint64 hash_prefix = 2 [packed = true];
  int hash_prefix_size() const;
  private:
  int _internal_hash_prefix_size() const;
  public:
  void clear_hash_prefix();
  private:
  uint64_t _internal_hash_prefix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_hash_prefix() const;
  void _internal_add_hash_prefix(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_hash_prefix();
  public:
  uint64_t hash_prefix(int index) const;
  void set_hash_prefix(int index, uint64_t value);
  void add_hash_prefix(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      hash_prefix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_hash_prefix();

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 4;
  int script_parameters_size() const;
  private:
  int _internal_script_parameters_size() const;
  public:
  void clear_script_parameters();
  ::autofill_assistant::ScriptParameterProto* mutable_script_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_script_parameters();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_script_parameters();
  public:
  const ::autofill_assistant::ScriptParameterProto& script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_script_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      script_parameters() const;

  // optional .autofill_assistant.ClientContextProto client_context = 3;
  bool has_client_context() const;
  private:
  bool _internal_has_client_context() const;
  public:
  void clear_client_context();
  const ::autofill_assistant::ClientContextProto& client_context() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto* release_client_context();
  ::autofill_assistant::ClientContextProto* mutable_client_context();
  void set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context);
  private:
  const ::autofill_assistant::ClientContextProto& _internal_client_context() const;
  ::autofill_assistant::ClientContextProto* _internal_mutable_client_context();
  public:
  void unsafe_arena_set_allocated_client_context(
      ::autofill_assistant::ClientContextProto* client_context);
  ::autofill_assistant::ClientContextProto* unsafe_arena_release_client_context();

  // optional uint32 hash_prefix_length = 1;
  bool has_hash_prefix_length() const;
  private:
  bool _internal_has_hash_prefix_length() const;
  public:
  void clear_hash_prefix_length();
  uint32_t hash_prefix_length() const;
  void set_hash_prefix_length(uint32_t value);
  private:
  uint32_t _internal_hash_prefix_length() const;
  void _internal_set_hash_prefix_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > hash_prefix_;
  mutable std::atomic<int> _hash_prefix_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > script_parameters_;
  ::autofill_assistant::ClientContextProto* client_context_;
  uint32_t hash_prefix_length_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto) */ {
 public:
  inline GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto() : GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(nullptr) {}
  ~GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto() override;
  explicit PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from);
  GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto&& from) noexcept
    : GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto() {
    *this = ::std::move(from);
  }

  inline GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& operator=(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& operator=(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* internal_default_instance() {
    return reinterpret_cast<const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto*>(
               &_GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& a, GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from);
  void MergeFrom(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto";
  }
  protected:
  explicit GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptParametersOverrideFieldNumber = 2,
    kUrlMatchFieldNumber = 1,
  };
  // repeated .autofill_assistant.ScriptParameterProto script_parameters_override = 2;
  int script_parameters_override_size() const;
  private:
  int _internal_script_parameters_override_size() const;
  public:
  void clear_script_parameters_override();
  ::autofill_assistant::ScriptParameterProto* mutable_script_parameters_override(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_script_parameters_override();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_script_parameters_override(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_script_parameters_override();
  public:
  const ::autofill_assistant::ScriptParameterProto& script_parameters_override(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_script_parameters_override();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      script_parameters_override() const;

  // optional string url_match = 1;
  bool has_url_match() const;
  private:
  bool _internal_has_url_match() const;
  public:
  void clear_url_match();
  const std::string& url_match() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_match(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_match();
  PROTOBUF_NODISCARD std::string* release_url_match();
  void set_allocated_url_match(std::string* url_match);
  private:
  const std::string& _internal_url_match() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_match(const std::string& value);
  std::string* _internal_mutable_url_match();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > script_parameters_override_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_match_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetCapabilitiesByHashPrefixResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto) */ {
 public:
  inline GetCapabilitiesByHashPrefixResponseProto() : GetCapabilitiesByHashPrefixResponseProto(nullptr) {}
  ~GetCapabilitiesByHashPrefixResponseProto() override;
  explicit PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCapabilitiesByHashPrefixResponseProto(const GetCapabilitiesByHashPrefixResponseProto& from);
  GetCapabilitiesByHashPrefixResponseProto(GetCapabilitiesByHashPrefixResponseProto&& from) noexcept
    : GetCapabilitiesByHashPrefixResponseProto() {
    *this = ::std::move(from);
  }

  inline GetCapabilitiesByHashPrefixResponseProto& operator=(const GetCapabilitiesByHashPrefixResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapabilitiesByHashPrefixResponseProto& operator=(GetCapabilitiesByHashPrefixResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetCapabilitiesByHashPrefixResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCapabilitiesByHashPrefixResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetCapabilitiesByHashPrefixResponseProto*>(
               &_GetCapabilitiesByHashPrefixResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetCapabilitiesByHashPrefixResponseProto& a, GetCapabilitiesByHashPrefixResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCapabilitiesByHashPrefixResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapabilitiesByHashPrefixResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCapabilitiesByHashPrefixResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCapabilitiesByHashPrefixResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCapabilitiesByHashPrefixResponseProto& from);
  void MergeFrom(const GetCapabilitiesByHashPrefixResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCapabilitiesByHashPrefixResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetCapabilitiesByHashPrefixResponseProto";
  }
  protected:
  explicit GetCapabilitiesByHashPrefixResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto MatchInfoProto;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchInfoFieldNumber = 1,
  };
  // repeated .autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto match_info = 1;
  int match_info_size() const;
  private:
  int _internal_match_info_size() const;
  public:
  void clear_match_info();
  ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* mutable_match_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto >*
      mutable_match_info();
  private:
  const ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& _internal_match_info(int index) const;
  ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* _internal_add_match_info();
  public:
  const ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& match_info(int index) const;
  ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* add_match_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto >&
      match_info() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto > match_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataRequestProto_PaymentMethodRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest) */ {
 public:
  inline GetUserDataRequestProto_PaymentMethodRequest() : GetUserDataRequestProto_PaymentMethodRequest(nullptr) {}
  ~GetUserDataRequestProto_PaymentMethodRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataRequestProto_PaymentMethodRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataRequestProto_PaymentMethodRequest(const GetUserDataRequestProto_PaymentMethodRequest& from);
  GetUserDataRequestProto_PaymentMethodRequest(GetUserDataRequestProto_PaymentMethodRequest&& from) noexcept
    : GetUserDataRequestProto_PaymentMethodRequest() {
    *this = ::std::move(from);
  }

  inline GetUserDataRequestProto_PaymentMethodRequest& operator=(const GetUserDataRequestProto_PaymentMethodRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataRequestProto_PaymentMethodRequest& operator=(GetUserDataRequestProto_PaymentMethodRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetUserDataRequestProto_PaymentMethodRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataRequestProto_PaymentMethodRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserDataRequestProto_PaymentMethodRequest*>(
               &_GetUserDataRequestProto_PaymentMethodRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetUserDataRequestProto_PaymentMethodRequest& a, GetUserDataRequestProto_PaymentMethodRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetUserDataRequestProto_PaymentMethodRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataRequestProto_PaymentMethodRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataRequestProto_PaymentMethodRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataRequestProto_PaymentMethodRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetUserDataRequestProto_PaymentMethodRequest& from);
  void MergeFrom(const GetUserDataRequestProto_PaymentMethodRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetUserDataRequestProto_PaymentMethodRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest";
  }
  protected:
  explicit GetUserDataRequestProto_PaymentMethodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedCardNetworksFieldNumber = 2,
    kPreexistingIdsFieldNumber = 3,
    kClientTokenFieldNumber = 1,
  };
  // repeated string supported_card_networks = 2;
  int supported_card_networks_size() const;
  private:
  int _internal_supported_card_networks_size() const;
  public:
  void clear_supported_card_networks();
  const std::string& supported_card_networks(int index) const;
  std::string* mutable_supported_card_networks(int index);
  void set_supported_card_networks(int index, const std::string& value);
  void set_supported_card_networks(int index, std::string&& value);
  void set_supported_card_networks(int index, const char* value);
  void set_supported_card_networks(int index, const char* value, size_t size);
  std::string* add_supported_card_networks();
  void add_supported_card_networks(const std::string& value);
  void add_supported_card_networks(std::string&& value);
  void add_supported_card_networks(const char* value);
  void add_supported_card_networks(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_card_networks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_card_networks();
  private:
  const std::string& _internal_supported_card_networks(int index) const;
  std::string* _internal_add_supported_card_networks();
  public:

  // repeated string preexisting_ids = 3;
  int preexisting_ids_size() const;
  private:
  int _internal_preexisting_ids_size() const;
  public:
  void clear_preexisting_ids();
  const std::string& preexisting_ids(int index) const;
  std::string* mutable_preexisting_ids(int index);
  void set_preexisting_ids(int index, const std::string& value);
  void set_preexisting_ids(int index, std::string&& value);
  void set_preexisting_ids(int index, const char* value);
  void set_preexisting_ids(int index, const char* value, size_t size);
  std::string* add_preexisting_ids();
  void add_preexisting_ids(const std::string& value);
  void add_preexisting_ids(std::string&& value);
  void add_preexisting_ids(const char* value);
  void add_preexisting_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& preexisting_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_preexisting_ids();
  private:
  const std::string& _internal_preexisting_ids(int index) const;
  std::string* _internal_add_preexisting_ids();
  public:

  // optional bytes client_token = 1;
  bool has_client_token() const;
  private:
  bool _internal_has_client_token() const;
  public:
  void clear_client_token();
  const std::string& client_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_token();
  PROTOBUF_NODISCARD std::string* release_client_token();
  void set_allocated_client_token(std::string* client_token);
  private:
  const std::string& _internal_client_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_token(const std::string& value);
  std::string* _internal_mutable_client_token();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_card_networks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> preexisting_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_token_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataRequestProto_AddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetUserDataRequestProto.AddressRequest) */ {
 public:
  inline GetUserDataRequestProto_AddressRequest() : GetUserDataRequestProto_AddressRequest(nullptr) {}
  ~GetUserDataRequestProto_AddressRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataRequestProto_AddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataRequestProto_AddressRequest(const GetUserDataRequestProto_AddressRequest& from);
  GetUserDataRequestProto_AddressRequest(GetUserDataRequestProto_AddressRequest&& from) noexcept
    : GetUserDataRequestProto_AddressRequest() {
    *this = ::std::move(from);
  }

  inline GetUserDataRequestProto_AddressRequest& operator=(const GetUserDataRequestProto_AddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataRequestProto_AddressRequest& operator=(GetUserDataRequestProto_AddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetUserDataRequestProto_AddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataRequestProto_AddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserDataRequestProto_AddressRequest*>(
               &_GetUserDataRequestProto_AddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetUserDataRequestProto_AddressRequest& a, GetUserDataRequestProto_AddressRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetUserDataRequestProto_AddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataRequestProto_AddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataRequestProto_AddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataRequestProto_AddressRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetUserDataRequestProto_AddressRequest& from);
  void MergeFrom(const GetUserDataRequestProto_AddressRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetUserDataRequestProto_AddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetUserDataRequestProto.AddressRequest";
  }
  protected:
  explicit GetUserDataRequestProto_AddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreexistingIdsFieldNumber = 1,
  };
  // repeated string preexisting_ids = 1;
  int preexisting_ids_size() const;
  private:
  int _internal_preexisting_ids_size() const;
  public:
  void clear_preexisting_ids();
  const std::string& preexisting_ids(int index) const;
  std::string* mutable_preexisting_ids(int index);
  void set_preexisting_ids(int index, const std::string& value);
  void set_preexisting_ids(int index, std::string&& value);
  void set_preexisting_ids(int index, const char* value);
  void set_preexisting_ids(int index, const char* value, size_t size);
  std::string* add_preexisting_ids();
  void add_preexisting_ids(const std::string& value);
  void add_preexisting_ids(std::string&& value);
  void add_preexisting_ids(const char* value);
  void add_preexisting_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& preexisting_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_preexisting_ids();
  private:
  const std::string& _internal_preexisting_ids(int index) const;
  std::string* _internal_add_preexisting_ids();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetUserDataRequestProto.AddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> preexisting_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetUserDataRequestProto) */ {
 public:
  inline GetUserDataRequestProto() : GetUserDataRequestProto(nullptr) {}
  ~GetUserDataRequestProto() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataRequestProto(const GetUserDataRequestProto& from);
  GetUserDataRequestProto(GetUserDataRequestProto&& from) noexcept
    : GetUserDataRequestProto() {
    *this = ::std::move(from);
  }

  inline GetUserDataRequestProto& operator=(const GetUserDataRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataRequestProto& operator=(GetUserDataRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetUserDataRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetUserDataRequestProto*>(
               &_GetUserDataRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetUserDataRequestProto& a, GetUserDataRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetUserDataRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetUserDataRequestProto& from);
  void MergeFrom(const GetUserDataRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetUserDataRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetUserDataRequestProto";
  }
  protected:
  explicit GetUserDataRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GetUserDataRequestProto_PaymentMethodRequest PaymentMethodRequest;
  typedef GetUserDataRequestProto_AddressRequest AddressRequest;

  // accessors -------------------------------------------------------

  enum : int {
    kRequestPaymentMethodsFieldNumber = 7,
    kRequestShippingAddressesFieldNumber = 8,
    kRunIdFieldNumber = 1,
    kRequestNameFieldNumber = 2,
    kRequestEmailFieldNumber = 3,
    kRequestPhoneFieldNumber = 4,
  };
  // optional .autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest request_payment_methods = 7;
  bool has_request_payment_methods() const;
  private:
  bool _internal_has_request_payment_methods() const;
  public:
  void clear_request_payment_methods();
  const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest& request_payment_methods() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* release_request_payment_methods();
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* mutable_request_payment_methods();
  void set_allocated_request_payment_methods(::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* request_payment_methods);
  private:
  const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest& _internal_request_payment_methods() const;
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* _internal_mutable_request_payment_methods();
  public:
  void unsafe_arena_set_allocated_request_payment_methods(
      ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* request_payment_methods);
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* unsafe_arena_release_request_payment_methods();

  // optional .autofill_assistant.GetUserDataRequestProto.AddressRequest request_shipping_addresses = 8;
  bool has_request_shipping_addresses() const;
  private:
  bool _internal_has_request_shipping_addresses() const;
  public:
  void clear_request_shipping_addresses();
  const ::autofill_assistant::GetUserDataRequestProto_AddressRequest& request_shipping_addresses() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetUserDataRequestProto_AddressRequest* release_request_shipping_addresses();
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* mutable_request_shipping_addresses();
  void set_allocated_request_shipping_addresses(::autofill_assistant::GetUserDataRequestProto_AddressRequest* request_shipping_addresses);
  private:
  const ::autofill_assistant::GetUserDataRequestProto_AddressRequest& _internal_request_shipping_addresses() const;
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* _internal_mutable_request_shipping_addresses();
  public:
  void unsafe_arena_set_allocated_request_shipping_addresses(
      ::autofill_assistant::GetUserDataRequestProto_AddressRequest* request_shipping_addresses);
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* unsafe_arena_release_request_shipping_addresses();

  // optional uint64 run_id = 1;
  bool has_run_id() const;
  private:
  bool _internal_has_run_id() const;
  public:
  void clear_run_id();
  uint64_t run_id() const;
  void set_run_id(uint64_t value);
  private:
  uint64_t _internal_run_id() const;
  void _internal_set_run_id(uint64_t value);
  public:

  // optional bool request_name = 2;
  bool has_request_name() const;
  private:
  bool _internal_has_request_name() const;
  public:
  void clear_request_name();
  bool request_name() const;
  void set_request_name(bool value);
  private:
  bool _internal_request_name() const;
  void _internal_set_request_name(bool value);
  public:

  // optional bool request_email = 3;
  bool has_request_email() const;
  private:
  bool _internal_has_request_email() const;
  public:
  void clear_request_email();
  bool request_email() const;
  void set_request_email(bool value);
  private:
  bool _internal_request_email() const;
  void _internal_set_request_email(bool value);
  public:

  // optional bool request_phone = 4;
  bool has_request_phone() const;
  private:
  bool _internal_has_request_phone() const;
  public:
  void clear_request_phone();
  bool request_phone() const;
  void set_request_phone(bool value);
  private:
  bool _internal_request_phone() const;
  void _internal_set_request_phone(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetUserDataRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* request_payment_methods_;
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* request_shipping_addresses_;
  uint64_t run_id_;
  bool request_name_;
  bool request_email_;
  bool request_phone_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetUserDataResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetUserDataResponseProto) */ {
 public:
  inline GetUserDataResponseProto() : GetUserDataResponseProto(nullptr) {}
  ~GetUserDataResponseProto() override;
  explicit PROTOBUF_CONSTEXPR GetUserDataResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserDataResponseProto(const GetUserDataResponseProto& from);
  GetUserDataResponseProto(GetUserDataResponseProto&& from) noexcept
    : GetUserDataResponseProto() {
    *this = ::std::move(from);
  }

  inline GetUserDataResponseProto& operator=(const GetUserDataResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserDataResponseProto& operator=(GetUserDataResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetUserDataResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserDataResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetUserDataResponseProto*>(
               &_GetUserDataResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetUserDataResponseProto& a, GetUserDataResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetUserDataResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserDataResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserDataResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserDataResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetUserDataResponseProto& from);
  void MergeFrom(const GetUserDataResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetUserDataResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetUserDataResponseProto";
  }
  protected:
  explicit GetUserDataResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableContactsFieldNumber = 1,
    kAvailablePaymentInstrumentsFieldNumber = 2,
    kAvailableAddressesFieldNumber = 4,
    kAvailablePhoneNumbersFieldNumber = 10,
    kLocaleFieldNumber = 3,
    kSelectedContactIdentifierFieldNumber = 5,
    kSelectedShippingAddressIdentifierFieldNumber = 6,
    kSelectedPaymentInstrumentIdentifierFieldNumber = 7,
    kAddAddressTokenFieldNumber = 8,
    kAddPaymentInstrumentTokenFieldNumber = 9,
    kSelectedPhoneNumberIdentifierFieldNumber = 11,
  };
  // repeated .autofill_assistant.ProfileProto available_contacts = 1;
  int available_contacts_size() const;
  private:
  int _internal_available_contacts_size() const;
  public:
  void clear_available_contacts();
  ::autofill_assistant::ProfileProto* mutable_available_contacts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >*
      mutable_available_contacts();
  private:
  const ::autofill_assistant::ProfileProto& _internal_available_contacts(int index) const;
  ::autofill_assistant::ProfileProto* _internal_add_available_contacts();
  public:
  const ::autofill_assistant::ProfileProto& available_contacts(int index) const;
  ::autofill_assistant::ProfileProto* add_available_contacts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >&
      available_contacts() const;

  // repeated .autofill_assistant.PaymentInstrumentProto available_payment_instruments = 2;
  int available_payment_instruments_size() const;
  private:
  int _internal_available_payment_instruments_size() const;
  public:
  void clear_available_payment_instruments();
  ::autofill_assistant::PaymentInstrumentProto* mutable_available_payment_instruments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PaymentInstrumentProto >*
      mutable_available_payment_instruments();
  private:
  const ::autofill_assistant::PaymentInstrumentProto& _internal_available_payment_instruments(int index) const;
  ::autofill_assistant::PaymentInstrumentProto* _internal_add_available_payment_instruments();
  public:
  const ::autofill_assistant::PaymentInstrumentProto& available_payment_instruments(int index) const;
  ::autofill_assistant::PaymentInstrumentProto* add_available_payment_instruments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PaymentInstrumentProto >&
      available_payment_instruments() const;

  // repeated .autofill_assistant.ProfileProto available_addresses = 4;
  int available_addresses_size() const;
  private:
  int _internal_available_addresses_size() const;
  public:
  void clear_available_addresses();
  ::autofill_assistant::ProfileProto* mutable_available_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >*
      mutable_available_addresses();
  private:
  const ::autofill_assistant::ProfileProto& _internal_available_addresses(int index) const;
  ::autofill_assistant::ProfileProto* _internal_add_available_addresses();
  public:
  const ::autofill_assistant::ProfileProto& available_addresses(int index) const;
  ::autofill_assistant::ProfileProto* add_available_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >&
      available_addresses() const;

  // repeated .autofill_assistant.PhoneNumberProto available_phone_numbers = 10;
  int available_phone_numbers_size() const;
  private:
  int _internal_available_phone_numbers_size() const;
  public:
  void clear_available_phone_numbers();
  ::autofill_assistant::PhoneNumberProto* mutable_available_phone_numbers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PhoneNumberProto >*
      mutable_available_phone_numbers();
  private:
  const ::autofill_assistant::PhoneNumberProto& _internal_available_phone_numbers(int index) const;
  ::autofill_assistant::PhoneNumberProto* _internal_add_available_phone_numbers();
  public:
  const ::autofill_assistant::PhoneNumberProto& available_phone_numbers(int index) const;
  ::autofill_assistant::PhoneNumberProto* add_available_phone_numbers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PhoneNumberProto >&
      available_phone_numbers() const;

  // optional string locale = 3;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional string selected_contact_identifier = 5;
  bool has_selected_contact_identifier() const;
  private:
  bool _internal_has_selected_contact_identifier() const;
  public:
  void clear_selected_contact_identifier();
  const std::string& selected_contact_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_contact_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_contact_identifier();
  PROTOBUF_NODISCARD std::string* release_selected_contact_identifier();
  void set_allocated_selected_contact_identifier(std::string* selected_contact_identifier);
  private:
  const std::string& _internal_selected_contact_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_contact_identifier(const std::string& value);
  std::string* _internal_mutable_selected_contact_identifier();
  public:

  // optional string selected_shipping_address_identifier = 6;
  bool has_selected_shipping_address_identifier() const;
  private:
  bool _internal_has_selected_shipping_address_identifier() const;
  public:
  void clear_selected_shipping_address_identifier();
  const std::string& selected_shipping_address_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_shipping_address_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_shipping_address_identifier();
  PROTOBUF_NODISCARD std::string* release_selected_shipping_address_identifier();
  void set_allocated_selected_shipping_address_identifier(std::string* selected_shipping_address_identifier);
  private:
  const std::string& _internal_selected_shipping_address_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_shipping_address_identifier(const std::string& value);
  std::string* _internal_mutable_selected_shipping_address_identifier();
  public:

  // optional string selected_payment_instrument_identifier = 7;
  bool has_selected_payment_instrument_identifier() const;
  private:
  bool _internal_has_selected_payment_instrument_identifier() const;
  public:
  void clear_selected_payment_instrument_identifier();
  const std::string& selected_payment_instrument_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_payment_instrument_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_payment_instrument_identifier();
  PROTOBUF_NODISCARD std::string* release_selected_payment_instrument_identifier();
  void set_allocated_selected_payment_instrument_identifier(std::string* selected_payment_instrument_identifier);
  private:
  const std::string& _internal_selected_payment_instrument_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_payment_instrument_identifier(const std::string& value);
  std::string* _internal_mutable_selected_payment_instrument_identifier();
  public:

  // optional bytes add_address_token = 8;
  bool has_add_address_token() const;
  private:
  bool _internal_has_add_address_token() const;
  public:
  void clear_add_address_token();
  const std::string& add_address_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_add_address_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_add_address_token();
  PROTOBUF_NODISCARD std::string* release_add_address_token();
  void set_allocated_add_address_token(std::string* add_address_token);
  private:
  const std::string& _internal_add_address_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_add_address_token(const std::string& value);
  std::string* _internal_mutable_add_address_token();
  public:

  // optional bytes add_payment_instrument_token = 9;
  bool has_add_payment_instrument_token() const;
  private:
  bool _internal_has_add_payment_instrument_token() const;
  public:
  void clear_add_payment_instrument_token();
  const std::string& add_payment_instrument_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_add_payment_instrument_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_add_payment_instrument_token();
  PROTOBUF_NODISCARD std::string* release_add_payment_instrument_token();
  void set_allocated_add_payment_instrument_token(std::string* add_payment_instrument_token);
  private:
  const std::string& _internal_add_payment_instrument_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_add_payment_instrument_token(const std::string& value);
  std::string* _internal_mutable_add_payment_instrument_token();
  public:

  // optional string selected_phone_number_identifier = 11;
  bool has_selected_phone_number_identifier() const;
  private:
  bool _internal_has_selected_phone_number_identifier() const;
  public:
  void clear_selected_phone_number_identifier();
  const std::string& selected_phone_number_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_phone_number_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_phone_number_identifier();
  PROTOBUF_NODISCARD std::string* release_selected_phone_number_identifier();
  void set_allocated_selected_phone_number_identifier(std::string* selected_phone_number_identifier);
  private:
  const std::string& _internal_selected_phone_number_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_phone_number_identifier(const std::string& value);
  std::string* _internal_mutable_selected_phone_number_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetUserDataResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto > available_contacts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PaymentInstrumentProto > available_payment_instruments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto > available_addresses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PhoneNumberProto > available_phone_numbers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_contact_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_shipping_address_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_payment_instrument_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr add_address_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr add_payment_instrument_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_phone_number_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class OverlayImageProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.OverlayImageProto) */ {
 public:
  inline OverlayImageProto() : OverlayImageProto(nullptr) {}
  ~OverlayImageProto() override;
  explicit PROTOBUF_CONSTEXPR OverlayImageProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverlayImageProto(const OverlayImageProto& from);
  OverlayImageProto(OverlayImageProto&& from) noexcept
    : OverlayImageProto() {
    *this = ::std::move(from);
  }

  inline OverlayImageProto& operator=(const OverlayImageProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverlayImageProto& operator=(OverlayImageProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OverlayImageProto& default_instance() {
    return *internal_default_instance();
  }
  enum ImageCase {
    kImageUrl = 1,
    kImageDrawable = 8,
    IMAGE_NOT_SET = 0,
  };

  static inline const OverlayImageProto* internal_default_instance() {
    return reinterpret_cast<const OverlayImageProto*>(
               &_OverlayImageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(OverlayImageProto& a, OverlayImageProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OverlayImageProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverlayImageProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverlayImageProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverlayImageProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OverlayImageProto& from);
  void MergeFrom(const OverlayImageProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OverlayImageProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.OverlayImageProto";
  }
  protected:
  explicit OverlayImageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 5,
    kTextColorFieldNumber = 6,
    kImageSizeFieldNumber = 2,
    kImageTopMarginFieldNumber = 3,
    kImageBottomMarginFieldNumber = 4,
    kTextSizeFieldNumber = 7,
    kImageUrlFieldNumber = 1,
    kImageDrawableFieldNumber = 8,
  };
  // optional string text = 5;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string text_color = 6;
  bool has_text_color() const;
  private:
  bool _internal_has_text_color() const;
  public:
  void clear_text_color();
  const std::string& text_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_color();
  PROTOBUF_NODISCARD std::string* release_text_color();
  void set_allocated_text_color(std::string* text_color);
  private:
  const std::string& _internal_text_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_color(const std::string& value);
  std::string* _internal_mutable_text_color();
  public:

  // optional .autofill_assistant.ClientDimensionProto image_size = 2;
  bool has_image_size() const;
  private:
  bool _internal_has_image_size() const;
  public:
  void clear_image_size();
  const ::autofill_assistant::ClientDimensionProto& image_size() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_image_size();
  ::autofill_assistant::ClientDimensionProto* mutable_image_size();
  void set_allocated_image_size(::autofill_assistant::ClientDimensionProto* image_size);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_image_size() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_image_size();
  public:
  void unsafe_arena_set_allocated_image_size(
      ::autofill_assistant::ClientDimensionProto* image_size);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_image_size();

  // optional .autofill_assistant.ClientDimensionProto image_top_margin = 3;
  bool has_image_top_margin() const;
  private:
  bool _internal_has_image_top_margin() const;
  public:
  void clear_image_top_margin();
  const ::autofill_assistant::ClientDimensionProto& image_top_margin() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_image_top_margin();
  ::autofill_assistant::ClientDimensionProto* mutable_image_top_margin();
  void set_allocated_image_top_margin(::autofill_assistant::ClientDimensionProto* image_top_margin);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_image_top_margin() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_image_top_margin();
  public:
  void unsafe_arena_set_allocated_image_top_margin(
      ::autofill_assistant::ClientDimensionProto* image_top_margin);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_image_top_margin();

  // optional .autofill_assistant.ClientDimensionProto image_bottom_margin = 4;
  bool has_image_bottom_margin() const;
  private:
  bool _internal_has_image_bottom_margin() const;
  public:
  void clear_image_bottom_margin();
  const ::autofill_assistant::ClientDimensionProto& image_bottom_margin() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_image_bottom_margin();
  ::autofill_assistant::ClientDimensionProto* mutable_image_bottom_margin();
  void set_allocated_image_bottom_margin(::autofill_assistant::ClientDimensionProto* image_bottom_margin);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_image_bottom_margin() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_image_bottom_margin();
  public:
  void unsafe_arena_set_allocated_image_bottom_margin(
      ::autofill_assistant::ClientDimensionProto* image_bottom_margin);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_image_bottom_margin();

  // optional .autofill_assistant.ClientDimensionProto text_size = 7;
  bool has_text_size() const;
  private:
  bool _internal_has_text_size() const;
  public:
  void clear_text_size();
  const ::autofill_assistant::ClientDimensionProto& text_size() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_text_size();
  ::autofill_assistant::ClientDimensionProto* mutable_text_size();
  void set_allocated_text_size(::autofill_assistant::ClientDimensionProto* text_size);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_text_size() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_text_size();
  public:
  void unsafe_arena_set_allocated_text_size(
      ::autofill_assistant::ClientDimensionProto* text_size);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_text_size();

  // string image_url = 1;
  bool has_image_url() const;
  private:
  bool _internal_has_image_url() const;
  public:
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // .autofill_assistant.DrawableProto image_drawable = 8;
  bool has_image_drawable() const;
  private:
  bool _internal_has_image_drawable() const;
  public:
  void clear_image_drawable();
  const ::autofill_assistant::DrawableProto& image_drawable() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DrawableProto* release_image_drawable();
  ::autofill_assistant::DrawableProto* mutable_image_drawable();
  void set_allocated_image_drawable(::autofill_assistant::DrawableProto* image_drawable);
  private:
  const ::autofill_assistant::DrawableProto& _internal_image_drawable() const;
  ::autofill_assistant::DrawableProto* _internal_mutable_image_drawable();
  public:
  void unsafe_arena_set_allocated_image_drawable(
      ::autofill_assistant::DrawableProto* image_drawable);
  ::autofill_assistant::DrawableProto* unsafe_arena_release_image_drawable();

  void clear_image();
  ImageCase image_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.OverlayImageProto)
 private:
  class _Internal;
  void set_has_image_url();
  void set_has_image_drawable();

  inline bool has_image() const;
  inline void clear_has_image();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_color_;
  ::autofill_assistant::ClientDimensionProto* image_size_;
  ::autofill_assistant::ClientDimensionProto* image_top_margin_;
  ::autofill_assistant::ClientDimensionProto* image_bottom_margin_;
  ::autofill_assistant::ClientDimensionProto* text_size_;
  union ImageUnion {
    constexpr ImageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
    ::autofill_assistant::DrawableProto* image_drawable_;
  } image_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientSettingsProto_IntegrationTestSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientSettingsProto.IntegrationTestSettings) */ {
 public:
  inline ClientSettingsProto_IntegrationTestSettings() : ClientSettingsProto_IntegrationTestSettings(nullptr) {}
  ~ClientSettingsProto_IntegrationTestSettings() override;
  explicit PROTOBUF_CONSTEXPR ClientSettingsProto_IntegrationTestSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientSettingsProto_IntegrationTestSettings(const ClientSettingsProto_IntegrationTestSettings& from);
  ClientSettingsProto_IntegrationTestSettings(ClientSettingsProto_IntegrationTestSettings&& from) noexcept
    : ClientSettingsProto_IntegrationTestSettings() {
    *this = ::std::move(from);
  }

  inline ClientSettingsProto_IntegrationTestSettings& operator=(const ClientSettingsProto_IntegrationTestSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientSettingsProto_IntegrationTestSettings& operator=(ClientSettingsProto_IntegrationTestSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientSettingsProto_IntegrationTestSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientSettingsProto_IntegrationTestSettings* internal_default_instance() {
    return reinterpret_cast<const ClientSettingsProto_IntegrationTestSettings*>(
               &_ClientSettingsProto_IntegrationTestSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ClientSettingsProto_IntegrationTestSettings& a, ClientSettingsProto_IntegrationTestSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientSettingsProto_IntegrationTestSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientSettingsProto_IntegrationTestSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientSettingsProto_IntegrationTestSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientSettingsProto_IntegrationTestSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientSettingsProto_IntegrationTestSettings& from);
  void MergeFrom(const ClientSettingsProto_IntegrationTestSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientSettingsProto_IntegrationTestSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientSettingsProto.IntegrationTestSettings";
  }
  protected:
  explicit ClientSettingsProto_IntegrationTestSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisableHeaderAnimationsFieldNumber = 1,
    kDisableCarouselChangeAnimationsFieldNumber = 2,
  };
  // optional bool disable_header_animations = 1;
  bool has_disable_header_animations() const;
  private:
  bool _internal_has_disable_header_animations() const;
  public:
  void clear_disable_header_animations();
  bool disable_header_animations() const;
  void set_disable_header_animations(bool value);
  private:
  bool _internal_disable_header_animations() const;
  void _internal_set_disable_header_animations(bool value);
  public:

  // optional bool disable_carousel_change_animations = 2;
  bool has_disable_carousel_change_animations() const;
  private:
  bool _internal_has_disable_carousel_change_animations() const;
  public:
  void clear_disable_carousel_change_animations();
  bool disable_carousel_change_animations() const;
  void set_disable_carousel_change_animations(bool value);
  private:
  bool _internal_disable_carousel_change_animations() const;
  void _internal_set_disable_carousel_change_animations(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool disable_header_animations_;
  bool disable_carousel_change_animations_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientSettingsProto_BackButtonSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientSettingsProto.BackButtonSettings) */ {
 public:
  inline ClientSettingsProto_BackButtonSettings() : ClientSettingsProto_BackButtonSettings(nullptr) {}
  ~ClientSettingsProto_BackButtonSettings() override;
  explicit PROTOBUF_CONSTEXPR ClientSettingsProto_BackButtonSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientSettingsProto_BackButtonSettings(const ClientSettingsProto_BackButtonSettings& from);
  ClientSettingsProto_BackButtonSettings(ClientSettingsProto_BackButtonSettings&& from) noexcept
    : ClientSettingsProto_BackButtonSettings() {
    *this = ::std::move(from);
  }

  inline ClientSettingsProto_BackButtonSettings& operator=(const ClientSettingsProto_BackButtonSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientSettingsProto_BackButtonSettings& operator=(ClientSettingsProto_BackButtonSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientSettingsProto_BackButtonSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientSettingsProto_BackButtonSettings* internal_default_instance() {
    return reinterpret_cast<const ClientSettingsProto_BackButtonSettings*>(
               &_ClientSettingsProto_BackButtonSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ClientSettingsProto_BackButtonSettings& a, ClientSettingsProto_BackButtonSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientSettingsProto_BackButtonSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientSettingsProto_BackButtonSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientSettingsProto_BackButtonSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientSettingsProto_BackButtonSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientSettingsProto_BackButtonSettings& from);
  void MergeFrom(const ClientSettingsProto_BackButtonSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientSettingsProto_BackButtonSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientSettingsProto.BackButtonSettings";
  }
  protected:
  explicit ClientSettingsProto_BackButtonSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUndoLabelFieldNumber = 2,
  };
  // optional string undo_label = 2;
  bool has_undo_label() const;
  private:
  bool _internal_has_undo_label() const;
  public:
  void clear_undo_label();
  const std::string& undo_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_undo_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_undo_label();
  PROTOBUF_NODISCARD std::string* release_undo_label();
  void set_allocated_undo_label(std::string* undo_label);
  private:
  const std::string& _internal_undo_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_undo_label(const std::string& value);
  std::string* _internal_mutable_undo_label();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto.BackButtonSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr undo_label_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientSettingsProto_SlowWarningSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientSettingsProto.SlowWarningSettings) */ {
 public:
  inline ClientSettingsProto_SlowWarningSettings() : ClientSettingsProto_SlowWarningSettings(nullptr) {}
  ~ClientSettingsProto_SlowWarningSettings() override;
  explicit PROTOBUF_CONSTEXPR ClientSettingsProto_SlowWarningSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientSettingsProto_SlowWarningSettings(const ClientSettingsProto_SlowWarningSettings& from);
  ClientSettingsProto_SlowWarningSettings(ClientSettingsProto_SlowWarningSettings&& from) noexcept
    : ClientSettingsProto_SlowWarningSettings() {
    *this = ::std::move(from);
  }

  inline ClientSettingsProto_SlowWarningSettings& operator=(const ClientSettingsProto_SlowWarningSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientSettingsProto_SlowWarningSettings& operator=(ClientSettingsProto_SlowWarningSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientSettingsProto_SlowWarningSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientSettingsProto_SlowWarningSettings* internal_default_instance() {
    return reinterpret_cast<const ClientSettingsProto_SlowWarningSettings*>(
               &_ClientSettingsProto_SlowWarningSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ClientSettingsProto_SlowWarningSettings& a, ClientSettingsProto_SlowWarningSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientSettingsProto_SlowWarningSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientSettingsProto_SlowWarningSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientSettingsProto_SlowWarningSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientSettingsProto_SlowWarningSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientSettingsProto_SlowWarningSettings& from);
  void MergeFrom(const ClientSettingsProto_SlowWarningSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientSettingsProto_SlowWarningSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientSettingsProto.SlowWarningSettings";
  }
  protected:
  explicit ClientSettingsProto_SlowWarningSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientSettingsProto_SlowWarningSettings_MessageMode MessageMode;
  static constexpr MessageMode UNKNOWN =
    ClientSettingsProto_SlowWarningSettings_MessageMode_UNKNOWN;
  static constexpr MessageMode CONCATENATE =
    ClientSettingsProto_SlowWarningSettings_MessageMode_CONCATENATE;
  static constexpr MessageMode REPLACE =
    ClientSettingsProto_SlowWarningSettings_MessageMode_REPLACE;
  static inline bool MessageMode_IsValid(int value) {
    return ClientSettingsProto_SlowWarningSettings_MessageMode_IsValid(value);
  }
  static constexpr MessageMode MessageMode_MIN =
    ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_MIN;
  static constexpr MessageMode MessageMode_MAX =
    ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_MAX;
  static constexpr int MessageMode_ARRAYSIZE =
    ClientSettingsProto_SlowWarningSettings_MessageMode_MessageMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MessageMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageMode_Name.");
    return ClientSettingsProto_SlowWarningSettings_MessageMode_Name(enum_t_value);
  }
  static inline bool MessageMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageMode* value) {
    return ClientSettingsProto_SlowWarningSettings_MessageMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSlowConnectionMessageFieldNumber = 9,
    kSlowWebsiteMessageFieldNumber = 10,
    kEnableSlowConnectionWarningsFieldNumber = 1,
    kEnableSlowWebsiteWarningsFieldNumber = 2,
    kOnlyShowWarningOnceFieldNumber = 3,
    kOnlyShowConnectionWarningOnceFieldNumber = 4,
    kOnlyShowWebsiteWarningOnceFieldNumber = 5,
    kWarningDelayMsFieldNumber = 6,
    kSlowRoundtripThresholdMsFieldNumber = 7,
    kMaxConsecutiveSlowRoundtripsFieldNumber = 8,
    kMinimumWarningMessageDurationMsFieldNumber = 11,
    kMessageModeFieldNumber = 12,
  };
  // optional string slow_connection_message = 9;
  bool has_slow_connection_message() const;
  private:
  bool _internal_has_slow_connection_message() const;
  public:
  void clear_slow_connection_message();
  const std::string& slow_connection_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slow_connection_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slow_connection_message();
  PROTOBUF_NODISCARD std::string* release_slow_connection_message();
  void set_allocated_slow_connection_message(std::string* slow_connection_message);
  private:
  const std::string& _internal_slow_connection_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slow_connection_message(const std::string& value);
  std::string* _internal_mutable_slow_connection_message();
  public:

  // optional string slow_website_message = 10;
  bool has_slow_website_message() const;
  private:
  bool _internal_has_slow_website_message() const;
  public:
  void clear_slow_website_message();
  const std::string& slow_website_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slow_website_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slow_website_message();
  PROTOBUF_NODISCARD std::string* release_slow_website_message();
  void set_allocated_slow_website_message(std::string* slow_website_message);
  private:
  const std::string& _internal_slow_website_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slow_website_message(const std::string& value);
  std::string* _internal_mutable_slow_website_message();
  public:

  // optional bool enable_slow_connection_warnings = 1;
  bool has_enable_slow_connection_warnings() const;
  private:
  bool _internal_has_enable_slow_connection_warnings() const;
  public:
  void clear_enable_slow_connection_warnings();
  bool enable_slow_connection_warnings() const;
  void set_enable_slow_connection_warnings(bool value);
  private:
  bool _internal_enable_slow_connection_warnings() const;
  void _internal_set_enable_slow_connection_warnings(bool value);
  public:

  // optional bool enable_slow_website_warnings = 2;
  bool has_enable_slow_website_warnings() const;
  private:
  bool _internal_has_enable_slow_website_warnings() const;
  public:
  void clear_enable_slow_website_warnings();
  bool enable_slow_website_warnings() const;
  void set_enable_slow_website_warnings(bool value);
  private:
  bool _internal_enable_slow_website_warnings() const;
  void _internal_set_enable_slow_website_warnings(bool value);
  public:

  // optional bool only_show_warning_once = 3;
  bool has_only_show_warning_once() const;
  private:
  bool _internal_has_only_show_warning_once() const;
  public:
  void clear_only_show_warning_once();
  bool only_show_warning_once() const;
  void set_only_show_warning_once(bool value);
  private:
  bool _internal_only_show_warning_once() const;
  void _internal_set_only_show_warning_once(bool value);
  public:

  // optional bool only_show_connection_warning_once = 4;
  bool has_only_show_connection_warning_once() const;
  private:
  bool _internal_has_only_show_connection_warning_once() const;
  public:
  void clear_only_show_connection_warning_once();
  bool only_show_connection_warning_once() const;
  void set_only_show_connection_warning_once(bool value);
  private:
  bool _internal_only_show_connection_warning_once() const;
  void _internal_set_only_show_connection_warning_once(bool value);
  public:

  // optional bool only_show_website_warning_once = 5;
  bool has_only_show_website_warning_once() const;
  private:
  bool _internal_has_only_show_website_warning_once() const;
  public:
  void clear_only_show_website_warning_once();
  bool only_show_website_warning_once() const;
  void set_only_show_website_warning_once(bool value);
  private:
  bool _internal_only_show_website_warning_once() const;
  void _internal_set_only_show_website_warning_once(bool value);
  public:

  // optional int32 warning_delay_ms = 6;
  bool has_warning_delay_ms() const;
  private:
  bool _internal_has_warning_delay_ms() const;
  public:
  void clear_warning_delay_ms();
  int32_t warning_delay_ms() const;
  void set_warning_delay_ms(int32_t value);
  private:
  int32_t _internal_warning_delay_ms() const;
  void _internal_set_warning_delay_ms(int32_t value);
  public:

  // optional int32 slow_roundtrip_threshold_ms = 7;
  bool has_slow_roundtrip_threshold_ms() const;
  private:
  bool _internal_has_slow_roundtrip_threshold_ms() const;
  public:
  void clear_slow_roundtrip_threshold_ms();
  int32_t slow_roundtrip_threshold_ms() const;
  void set_slow_roundtrip_threshold_ms(int32_t value);
  private:
  int32_t _internal_slow_roundtrip_threshold_ms() const;
  void _internal_set_slow_roundtrip_threshold_ms(int32_t value);
  public:

  // optional int32 max_consecutive_slow_roundtrips = 8;
  bool has_max_consecutive_slow_roundtrips() const;
  private:
  bool _internal_has_max_consecutive_slow_roundtrips() const;
  public:
  void clear_max_consecutive_slow_roundtrips();
  int32_t max_consecutive_slow_roundtrips() const;
  void set_max_consecutive_slow_roundtrips(int32_t value);
  private:
  int32_t _internal_max_consecutive_slow_roundtrips() const;
  void _internal_set_max_consecutive_slow_roundtrips(int32_t value);
  public:

  // optional int32 minimum_warning_message_duration_ms = 11;
  bool has_minimum_warning_message_duration_ms() const;
  private:
  bool _internal_has_minimum_warning_message_duration_ms() const;
  public:
  void clear_minimum_warning_message_duration_ms();
  int32_t minimum_warning_message_duration_ms() const;
  void set_minimum_warning_message_duration_ms(int32_t value);
  private:
  int32_t _internal_minimum_warning_message_duration_ms() const;
  void _internal_set_minimum_warning_message_duration_ms(int32_t value);
  public:

  // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings.MessageMode message_mode = 12;
  bool has_message_mode() const;
  private:
  bool _internal_has_message_mode() const;
  public:
  void clear_message_mode();
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode message_mode() const;
  void set_message_mode(::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode value);
  private:
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode _internal_message_mode() const;
  void _internal_set_message_mode(::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slow_connection_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slow_website_message_;
  bool enable_slow_connection_warnings_;
  bool enable_slow_website_warnings_;
  bool only_show_warning_once_;
  bool only_show_connection_warning_once_;
  bool only_show_website_warning_once_;
  int32_t warning_delay_ms_;
  int32_t slow_roundtrip_threshold_ms_;
  int32_t max_consecutive_slow_roundtrips_;
  int32_t minimum_warning_message_duration_ms_;
  int message_mode_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientSettingsProto_DisplayString final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientSettingsProto.DisplayString) */ {
 public:
  inline ClientSettingsProto_DisplayString() : ClientSettingsProto_DisplayString(nullptr) {}
  ~ClientSettingsProto_DisplayString() override;
  explicit PROTOBUF_CONSTEXPR ClientSettingsProto_DisplayString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientSettingsProto_DisplayString(const ClientSettingsProto_DisplayString& from);
  ClientSettingsProto_DisplayString(ClientSettingsProto_DisplayString&& from) noexcept
    : ClientSettingsProto_DisplayString() {
    *this = ::std::move(from);
  }

  inline ClientSettingsProto_DisplayString& operator=(const ClientSettingsProto_DisplayString& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientSettingsProto_DisplayString& operator=(ClientSettingsProto_DisplayString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientSettingsProto_DisplayString& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientSettingsProto_DisplayString* internal_default_instance() {
    return reinterpret_cast<const ClientSettingsProto_DisplayString*>(
               &_ClientSettingsProto_DisplayString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ClientSettingsProto_DisplayString& a, ClientSettingsProto_DisplayString& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientSettingsProto_DisplayString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientSettingsProto_DisplayString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientSettingsProto_DisplayString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientSettingsProto_DisplayString>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientSettingsProto_DisplayString& from);
  void MergeFrom(const ClientSettingsProto_DisplayString& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientSettingsProto_DisplayString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientSettingsProto.DisplayString";
  }
  protected:
  explicit ClientSettingsProto_DisplayString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .autofill_assistant.ClientSettingsProto.DisplayStringId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::autofill_assistant::ClientSettingsProto_DisplayStringId id() const;
  void set_id(::autofill_assistant::ClientSettingsProto_DisplayStringId value);
  private:
  ::autofill_assistant::ClientSettingsProto_DisplayStringId _internal_id() const;
  void _internal_set_id(::autofill_assistant::ClientSettingsProto_DisplayStringId value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto.DisplayString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClientSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientSettingsProto) */ {
 public:
  inline ClientSettingsProto() : ClientSettingsProto(nullptr) {}
  ~ClientSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR ClientSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientSettingsProto(const ClientSettingsProto& from);
  ClientSettingsProto(ClientSettingsProto&& from) noexcept
    : ClientSettingsProto() {
    *this = ::std::move(from);
  }

  inline ClientSettingsProto& operator=(const ClientSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientSettingsProto& operator=(ClientSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientSettingsProto* internal_default_instance() {
    return reinterpret_cast<const ClientSettingsProto*>(
               &_ClientSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ClientSettingsProto& a, ClientSettingsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientSettingsProto& from);
  void MergeFrom(const ClientSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientSettingsProto";
  }
  protected:
  explicit ClientSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientSettingsProto_IntegrationTestSettings IntegrationTestSettings;
  typedef ClientSettingsProto_BackButtonSettings BackButtonSettings;
  typedef ClientSettingsProto_SlowWarningSettings SlowWarningSettings;
  typedef ClientSettingsProto_DisplayString DisplayString;

  typedef ClientSettingsProto_DisplayStringId DisplayStringId;
  static constexpr DisplayStringId UNSPECIFIED =
    ClientSettingsProto_DisplayStringId_UNSPECIFIED;
  static constexpr DisplayStringId GIVE_UP =
    ClientSettingsProto_DisplayStringId_GIVE_UP;
  static constexpr DisplayStringId MAYBE_GIVE_UP =
    ClientSettingsProto_DisplayStringId_MAYBE_GIVE_UP;
  static constexpr DisplayStringId DEFAULT_ERROR =
    ClientSettingsProto_DisplayStringId_DEFAULT_ERROR;
  static constexpr DisplayStringId PAYMENT_INFO_CONFIRM =
    ClientSettingsProto_DisplayStringId_PAYMENT_INFO_CONFIRM;
  static constexpr DisplayStringId CONTINUE_BUTTON =
    ClientSettingsProto_DisplayStringId_CONTINUE_BUTTON;
  static constexpr DisplayStringId STOPPED =
    ClientSettingsProto_DisplayStringId_STOPPED;
  static constexpr DisplayStringId SEND_FEEDBACK =
    ClientSettingsProto_DisplayStringId_SEND_FEEDBACK;
  static constexpr DisplayStringId CLOSE =
    ClientSettingsProto_DisplayStringId_CLOSE;
  static constexpr DisplayStringId SETTINGS =
    ClientSettingsProto_DisplayStringId_SETTINGS;
  static constexpr DisplayStringId UNDO =
    ClientSettingsProto_DisplayStringId_UNDO;
  static inline bool DisplayStringId_IsValid(int value) {
    return ClientSettingsProto_DisplayStringId_IsValid(value);
  }
  static constexpr DisplayStringId DisplayStringId_MIN =
    ClientSettingsProto_DisplayStringId_DisplayStringId_MIN;
  static constexpr DisplayStringId DisplayStringId_MAX =
    ClientSettingsProto_DisplayStringId_DisplayStringId_MAX;
  static constexpr int DisplayStringId_ARRAYSIZE =
    ClientSettingsProto_DisplayStringId_DisplayStringId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DisplayStringId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DisplayStringId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DisplayStringId_Name.");
    return ClientSettingsProto_DisplayStringId_Name(enum_t_value);
  }
  static inline bool DisplayStringId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DisplayStringId* value) {
    return ClientSettingsProto_DisplayStringId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayStringsFieldNumber = 22,
    kDisplayStringsLocaleFieldNumber = 23,
    kOverlayImageFieldNumber = 16,
    kIntegrationTestSettingsFieldNumber = 17,
    kBackButtonSettingsFieldNumber = 19,
    kSlowWarningSettingsFieldNumber = 21,
    kPeriodicScriptCheckIntervalMsFieldNumber = 1,
    kPeriodicElementCheckIntervalMsFieldNumber = 2,
    kPeriodicScriptCheckCountFieldNumber = 3,
    kElementPositionUpdateIntervalMsFieldNumber = 4,
    kShortWaitForElementDeadlineMsFieldNumber = 5,
    kBoxModelCheckIntervalMsFieldNumber = 6,
    kBoxModelCheckCountFieldNumber = 7,
    kCancelDelayMsFieldNumber = 12,
    kTapCountFieldNumber = 13,
    kTapTrackingDurationMsFieldNumber = 14,
    kTapShutdownDelayMsFieldNumber = 15,
    kTalkbackSheetSizeFractionFieldNumber = 18,
    kDocumentReadyCheckTimeoutMsFieldNumber = 20,
    kSelectorObserverExtraTimeoutMsFieldNumber = 24,
    kSelectorObserverDebounceIntervalMsFieldNumber = 25,
  };
  // repeated .autofill_assistant.ClientSettingsProto.DisplayString display_strings = 22;
  int display_strings_size() const;
  private:
  int _internal_display_strings_size() const;
  public:
  void clear_display_strings();
  ::autofill_assistant::ClientSettingsProto_DisplayString* mutable_display_strings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientSettingsProto_DisplayString >*
      mutable_display_strings();
  private:
  const ::autofill_assistant::ClientSettingsProto_DisplayString& _internal_display_strings(int index) const;
  ::autofill_assistant::ClientSettingsProto_DisplayString* _internal_add_display_strings();
  public:
  const ::autofill_assistant::ClientSettingsProto_DisplayString& display_strings(int index) const;
  ::autofill_assistant::ClientSettingsProto_DisplayString* add_display_strings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientSettingsProto_DisplayString >&
      display_strings() const;

  // optional string display_strings_locale = 23;
  bool has_display_strings_locale() const;
  private:
  bool _internal_has_display_strings_locale() const;
  public:
  void clear_display_strings_locale();
  const std::string& display_strings_locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_strings_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_strings_locale();
  PROTOBUF_NODISCARD std::string* release_display_strings_locale();
  void set_allocated_display_strings_locale(std::string* display_strings_locale);
  private:
  const std::string& _internal_display_strings_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_strings_locale(const std::string& value);
  std::string* _internal_mutable_display_strings_locale();
  public:

  // optional .autofill_assistant.OverlayImageProto overlay_image = 16;
  bool has_overlay_image() const;
  private:
  bool _internal_has_overlay_image() const;
  public:
  void clear_overlay_image();
  const ::autofill_assistant::OverlayImageProto& overlay_image() const;
  PROTOBUF_NODISCARD ::autofill_assistant::OverlayImageProto* release_overlay_image();
  ::autofill_assistant::OverlayImageProto* mutable_overlay_image();
  void set_allocated_overlay_image(::autofill_assistant::OverlayImageProto* overlay_image);
  private:
  const ::autofill_assistant::OverlayImageProto& _internal_overlay_image() const;
  ::autofill_assistant::OverlayImageProto* _internal_mutable_overlay_image();
  public:
  void unsafe_arena_set_allocated_overlay_image(
      ::autofill_assistant::OverlayImageProto* overlay_image);
  ::autofill_assistant::OverlayImageProto* unsafe_arena_release_overlay_image();

  // optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;
  bool has_integration_test_settings() const;
  private:
  bool _internal_has_integration_test_settings() const;
  public:
  void clear_integration_test_settings();
  const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings& integration_test_settings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* release_integration_test_settings();
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* mutable_integration_test_settings();
  void set_allocated_integration_test_settings(::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* integration_test_settings);
  private:
  const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings& _internal_integration_test_settings() const;
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* _internal_mutable_integration_test_settings();
  public:
  void unsafe_arena_set_allocated_integration_test_settings(
      ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* integration_test_settings);
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* unsafe_arena_release_integration_test_settings();

  // optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;
  bool has_back_button_settings() const;
  private:
  bool _internal_has_back_button_settings() const;
  public:
  void clear_back_button_settings();
  const ::autofill_assistant::ClientSettingsProto_BackButtonSettings& back_button_settings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientSettingsProto_BackButtonSettings* release_back_button_settings();
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* mutable_back_button_settings();
  void set_allocated_back_button_settings(::autofill_assistant::ClientSettingsProto_BackButtonSettings* back_button_settings);
  private:
  const ::autofill_assistant::ClientSettingsProto_BackButtonSettings& _internal_back_button_settings() const;
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* _internal_mutable_back_button_settings();
  public:
  void unsafe_arena_set_allocated_back_button_settings(
      ::autofill_assistant::ClientSettingsProto_BackButtonSettings* back_button_settings);
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* unsafe_arena_release_back_button_settings();

  // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings slow_warning_settings = 21;
  bool has_slow_warning_settings() const;
  private:
  bool _internal_has_slow_warning_settings() const;
  public:
  void clear_slow_warning_settings();
  const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings& slow_warning_settings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* release_slow_warning_settings();
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* mutable_slow_warning_settings();
  void set_allocated_slow_warning_settings(::autofill_assistant::ClientSettingsProto_SlowWarningSettings* slow_warning_settings);
  private:
  const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings& _internal_slow_warning_settings() const;
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* _internal_mutable_slow_warning_settings();
  public:
  void unsafe_arena_set_allocated_slow_warning_settings(
      ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* slow_warning_settings);
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* unsafe_arena_release_slow_warning_settings();

  // optional int32 periodic_script_check_interval_ms = 1;
  bool has_periodic_script_check_interval_ms() const;
  private:
  bool _internal_has_periodic_script_check_interval_ms() const;
  public:
  void clear_periodic_script_check_interval_ms();
  int32_t periodic_script_check_interval_ms() const;
  void set_periodic_script_check_interval_ms(int32_t value);
  private:
  int32_t _internal_periodic_script_check_interval_ms() const;
  void _internal_set_periodic_script_check_interval_ms(int32_t value);
  public:

  // optional int32 periodic_element_check_interval_ms = 2;
  bool has_periodic_element_check_interval_ms() const;
  private:
  bool _internal_has_periodic_element_check_interval_ms() const;
  public:
  void clear_periodic_element_check_interval_ms();
  int32_t periodic_element_check_interval_ms() const;
  void set_periodic_element_check_interval_ms(int32_t value);
  private:
  int32_t _internal_periodic_element_check_interval_ms() const;
  void _internal_set_periodic_element_check_interval_ms(int32_t value);
  public:

  // optional int32 periodic_script_check_count = 3;
  bool has_periodic_script_check_count() const;
  private:
  bool _internal_has_periodic_script_check_count() const;
  public:
  void clear_periodic_script_check_count();
  int32_t periodic_script_check_count() const;
  void set_periodic_script_check_count(int32_t value);
  private:
  int32_t _internal_periodic_script_check_count() const;
  void _internal_set_periodic_script_check_count(int32_t value);
  public:

  // optional int32 element_position_update_interval_ms = 4;
  bool has_element_position_update_interval_ms() const;
  private:
  bool _internal_has_element_position_update_interval_ms() const;
  public:
  void clear_element_position_update_interval_ms();
  int32_t element_position_update_interval_ms() const;
  void set_element_position_update_interval_ms(int32_t value);
  private:
  int32_t _internal_element_position_update_interval_ms() const;
  void _internal_set_element_position_update_interval_ms(int32_t value);
  public:

  // optional int32 short_wait_for_element_deadline_ms = 5;
  bool has_short_wait_for_element_deadline_ms() const;
  private:
  bool _internal_has_short_wait_for_element_deadline_ms() const;
  public:
  void clear_short_wait_for_element_deadline_ms();
  int32_t short_wait_for_element_deadline_ms() const;
  void set_short_wait_for_element_deadline_ms(int32_t value);
  private:
  int32_t _internal_short_wait_for_element_deadline_ms() const;
  void _internal_set_short_wait_for_element_deadline_ms(int32_t value);
  public:

  // optional int32 box_model_check_interval_ms = 6;
  bool has_box_model_check_interval_ms() const;
  private:
  bool _internal_has_box_model_check_interval_ms() const;
  public:
  void clear_box_model_check_interval_ms();
  int32_t box_model_check_interval_ms() const;
  void set_box_model_check_interval_ms(int32_t value);
  private:
  int32_t _internal_box_model_check_interval_ms() const;
  void _internal_set_box_model_check_interval_ms(int32_t value);
  public:

  // optional int32 box_model_check_count = 7;
  bool has_box_model_check_count() const;
  private:
  bool _internal_has_box_model_check_count() const;
  public:
  void clear_box_model_check_count();
  int32_t box_model_check_count() const;
  void set_box_model_check_count(int32_t value);
  private:
  int32_t _internal_box_model_check_count() const;
  void _internal_set_box_model_check_count(int32_t value);
  public:

  // optional int32 cancel_delay_ms = 12;
  bool has_cancel_delay_ms() const;
  private:
  bool _internal_has_cancel_delay_ms() const;
  public:
  void clear_cancel_delay_ms();
  int32_t cancel_delay_ms() const;
  void set_cancel_delay_ms(int32_t value);
  private:
  int32_t _internal_cancel_delay_ms() const;
  void _internal_set_cancel_delay_ms(int32_t value);
  public:

  // optional int32 tap_count = 13;
  bool has_tap_count() const;
  private:
  bool _internal_has_tap_count() const;
  public:
  void clear_tap_count();
  int32_t tap_count() const;
  void set_tap_count(int32_t value);
  private:
  int32_t _internal_tap_count() const;
  void _internal_set_tap_count(int32_t value);
  public:

  // optional int32 tap_tracking_duration_ms = 14;
  bool has_tap_tracking_duration_ms() const;
  private:
  bool _internal_has_tap_tracking_duration_ms() const;
  public:
  void clear_tap_tracking_duration_ms();
  int32_t tap_tracking_duration_ms() const;
  void set_tap_tracking_duration_ms(int32_t value);
  private:
  int32_t _internal_tap_tracking_duration_ms() const;
  void _internal_set_tap_tracking_duration_ms(int32_t value);
  public:

  // optional int32 tap_shutdown_delay_ms = 15;
  bool has_tap_shutdown_delay_ms() const;
  private:
  bool _internal_has_tap_shutdown_delay_ms() const;
  public:
  void clear_tap_shutdown_delay_ms();
  int32_t tap_shutdown_delay_ms() const;
  void set_tap_shutdown_delay_ms(int32_t value);
  private:
  int32_t _internal_tap_shutdown_delay_ms() const;
  void _internal_set_tap_shutdown_delay_ms(int32_t value);
  public:

  // optional float talkback_sheet_size_fraction = 18;
  bool has_talkback_sheet_size_fraction() const;
  private:
  bool _internal_has_talkback_sheet_size_fraction() const;
  public:
  void clear_talkback_sheet_size_fraction();
  float talkback_sheet_size_fraction() const;
  void set_talkback_sheet_size_fraction(float value);
  private:
  float _internal_talkback_sheet_size_fraction() const;
  void _internal_set_talkback_sheet_size_fraction(float value);
  public:

  // optional int32 document_ready_check_timeout_ms = 20;
  bool has_document_ready_check_timeout_ms() const;
  private:
  bool _internal_has_document_ready_check_timeout_ms() const;
  public:
  void clear_document_ready_check_timeout_ms();
  int32_t document_ready_check_timeout_ms() const;
  void set_document_ready_check_timeout_ms(int32_t value);
  private:
  int32_t _internal_document_ready_check_timeout_ms() const;
  void _internal_set_document_ready_check_timeout_ms(int32_t value);
  public:

  // optional int32 selector_observer_extra_timeout_ms = 24;
  bool has_selector_observer_extra_timeout_ms() const;
  private:
  bool _internal_has_selector_observer_extra_timeout_ms() const;
  public:
  void clear_selector_observer_extra_timeout_ms();
  int32_t selector_observer_extra_timeout_ms() const;
  void set_selector_observer_extra_timeout_ms(int32_t value);
  private:
  int32_t _internal_selector_observer_extra_timeout_ms() const;
  void _internal_set_selector_observer_extra_timeout_ms(int32_t value);
  public:

  // optional int32 selector_observer_debounce_interval_ms = 25;
  bool has_selector_observer_debounce_interval_ms() const;
  private:
  bool _internal_has_selector_observer_debounce_interval_ms() const;
  public:
  void clear_selector_observer_debounce_interval_ms();
  int32_t selector_observer_debounce_interval_ms() const;
  void set_selector_observer_debounce_interval_ms(int32_t value);
  private:
  int32_t _internal_selector_observer_debounce_interval_ms() const;
  void _internal_set_selector_observer_debounce_interval_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientSettingsProto_DisplayString > display_strings_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_strings_locale_;
  ::autofill_assistant::OverlayImageProto* overlay_image_;
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* integration_test_settings_;
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* back_button_settings_;
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* slow_warning_settings_;
  int32_t periodic_script_check_interval_ms_;
  int32_t periodic_element_check_interval_ms_;
  int32_t periodic_script_check_count_;
  int32_t element_position_update_interval_ms_;
  int32_t short_wait_for_element_deadline_ms_;
  int32_t box_model_check_interval_ms_;
  int32_t box_model_check_count_;
  int32_t cancel_delay_ms_;
  int32_t tap_count_;
  int32_t tap_tracking_duration_ms_;
  int32_t tap_shutdown_delay_ms_;
  float talkback_sheet_size_fraction_;
  int32_t document_ready_check_timeout_ms_;
  int32_t selector_observer_extra_timeout_ms_;
  int32_t selector_observer_debounce_interval_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ScriptTimeoutError final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScriptTimeoutError) */ {
 public:
  inline ScriptTimeoutError() : ScriptTimeoutError(nullptr) {}
  ~ScriptTimeoutError() override;
  explicit PROTOBUF_CONSTEXPR ScriptTimeoutError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptTimeoutError(const ScriptTimeoutError& from);
  ScriptTimeoutError(ScriptTimeoutError&& from) noexcept
    : ScriptTimeoutError() {
    *this = ::std::move(from);
  }

  inline ScriptTimeoutError& operator=(const ScriptTimeoutError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptTimeoutError& operator=(ScriptTimeoutError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScriptTimeoutError& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScriptTimeoutError* internal_default_instance() {
    return reinterpret_cast<const ScriptTimeoutError*>(
               &_ScriptTimeoutError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ScriptTimeoutError& a, ScriptTimeoutError& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScriptTimeoutError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptTimeoutError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptTimeoutError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptTimeoutError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScriptTimeoutError& from);
  void MergeFrom(const ScriptTimeoutError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScriptTimeoutError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScriptTimeoutError";
  }
  protected:
  explicit ScriptTimeoutError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptPathFieldNumber = 2,
    kTimeoutMsFieldNumber = 1,
  };
  // optional string script_path = 2;
  bool has_script_path() const;
  private:
  bool _internal_has_script_path() const;
  public:
  void clear_script_path();
  const std::string& script_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script_path();
  PROTOBUF_NODISCARD std::string* release_script_path();
  void set_allocated_script_path(std::string* script_path);
  private:
  const std::string& _internal_script_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script_path(const std::string& value);
  std::string* _internal_mutable_script_path();
  public:

  // optional int32 timeout_ms = 1;
  bool has_timeout_ms() const;
  private:
  bool _internal_has_timeout_ms() const;
  public:
  void clear_timeout_ms();
  int32_t timeout_ms() const;
  void set_timeout_ms(int32_t value);
  private:
  int32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScriptTimeoutError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_path_;
  int32_t timeout_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SupportedScriptProto_PresentationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SupportedScriptProto.PresentationProto) */ {
 public:
  inline SupportedScriptProto_PresentationProto() : SupportedScriptProto_PresentationProto(nullptr) {}
  ~SupportedScriptProto_PresentationProto() override;
  explicit PROTOBUF_CONSTEXPR SupportedScriptProto_PresentationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupportedScriptProto_PresentationProto(const SupportedScriptProto_PresentationProto& from);
  SupportedScriptProto_PresentationProto(SupportedScriptProto_PresentationProto&& from) noexcept
    : SupportedScriptProto_PresentationProto() {
    *this = ::std::move(from);
  }

  inline SupportedScriptProto_PresentationProto& operator=(const SupportedScriptProto_PresentationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupportedScriptProto_PresentationProto& operator=(SupportedScriptProto_PresentationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SupportedScriptProto_PresentationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupportedScriptProto_PresentationProto* internal_default_instance() {
    return reinterpret_cast<const SupportedScriptProto_PresentationProto*>(
               &_SupportedScriptProto_PresentationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SupportedScriptProto_PresentationProto& a, SupportedScriptProto_PresentationProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SupportedScriptProto_PresentationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupportedScriptProto_PresentationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupportedScriptProto_PresentationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupportedScriptProto_PresentationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SupportedScriptProto_PresentationProto& from);
  void MergeFrom(const SupportedScriptProto_PresentationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SupportedScriptProto_PresentationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SupportedScriptProto.PresentationProto";
  }
  protected:
  explicit SupportedScriptProto_PresentationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartMessageFieldNumber = 14,
    kPreconditionFieldNumber = 3,
    kDirectActionFieldNumber = 13,
    kPriorityFieldNumber = 5,
    kAutostartFieldNumber = 8,
    kInterruptFieldNumber = 9,
    kNeedsUiFieldNumber = 15,
  };
  // optional string start_message = 14;
  bool has_start_message() const;
  private:
  bool _internal_has_start_message() const;
  public:
  void clear_start_message();
  const std::string& start_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_message();
  PROTOBUF_NODISCARD std::string* release_start_message();
  void set_allocated_start_message(std::string* start_message);
  private:
  const std::string& _internal_start_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_message(const std::string& value);
  std::string* _internal_mutable_start_message();
  public:

  // optional .autofill_assistant.ScriptPreconditionProto precondition = 3;
  bool has_precondition() const;
  private:
  bool _internal_has_precondition() const;
  public:
  void clear_precondition();
  const ::autofill_assistant::ScriptPreconditionProto& precondition() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScriptPreconditionProto* release_precondition();
  ::autofill_assistant::ScriptPreconditionProto* mutable_precondition();
  void set_allocated_precondition(::autofill_assistant::ScriptPreconditionProto* precondition);
  private:
  const ::autofill_assistant::ScriptPreconditionProto& _internal_precondition() const;
  ::autofill_assistant::ScriptPreconditionProto* _internal_mutable_precondition();
  public:
  void unsafe_arena_set_allocated_precondition(
      ::autofill_assistant::ScriptPreconditionProto* precondition);
  ::autofill_assistant::ScriptPreconditionProto* unsafe_arena_release_precondition();

  // optional .autofill_assistant.DirectActionProto direct_action = 13;
  bool has_direct_action() const;
  private:
  bool _internal_has_direct_action() const;
  public:
  void clear_direct_action();
  const ::autofill_assistant::DirectActionProto& direct_action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DirectActionProto* release_direct_action();
  ::autofill_assistant::DirectActionProto* mutable_direct_action();
  void set_allocated_direct_action(::autofill_assistant::DirectActionProto* direct_action);
  private:
  const ::autofill_assistant::DirectActionProto& _internal_direct_action() const;
  ::autofill_assistant::DirectActionProto* _internal_mutable_direct_action();
  public:
  void unsafe_arena_set_allocated_direct_action(
      ::autofill_assistant::DirectActionProto* direct_action);
  ::autofill_assistant::DirectActionProto* unsafe_arena_release_direct_action();

  // optional int32 priority = 5;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // optional bool autostart = 8;
  bool has_autostart() const;
  private:
  bool _internal_has_autostart() const;
  public:
  void clear_autostart();
  bool autostart() const;
  void set_autostart(bool value);
  private:
  bool _internal_autostart() const;
  void _internal_set_autostart(bool value);
  public:

  // optional bool interrupt = 9;
  bool has_interrupt() const;
  private:
  bool _internal_has_interrupt() const;
  public:
  void clear_interrupt();
  bool interrupt() const;
  void set_interrupt(bool value);
  private:
  bool _internal_interrupt() const;
  void _internal_set_interrupt(bool value);
  public:

  // optional bool needs_ui = 15 [default = true];
  bool has_needs_ui() const;
  private:
  bool _internal_has_needs_ui() const;
  public:
  void clear_needs_ui();
  bool needs_ui() const;
  void set_needs_ui(bool value);
  private:
  bool _internal_needs_ui() const;
  void _internal_set_needs_ui(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SupportedScriptProto.PresentationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_message_;
  ::autofill_assistant::ScriptPreconditionProto* precondition_;
  ::autofill_assistant::DirectActionProto* direct_action_;
  int32_t priority_;
  bool autostart_;
  bool interrupt_;
  bool needs_ui_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SupportedScriptProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SupportedScriptProto) */ {
 public:
  inline SupportedScriptProto() : SupportedScriptProto(nullptr) {}
  ~SupportedScriptProto() override;
  explicit PROTOBUF_CONSTEXPR SupportedScriptProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupportedScriptProto(const SupportedScriptProto& from);
  SupportedScriptProto(SupportedScriptProto&& from) noexcept
    : SupportedScriptProto() {
    *this = ::std::move(from);
  }

  inline SupportedScriptProto& operator=(const SupportedScriptProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupportedScriptProto& operator=(SupportedScriptProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SupportedScriptProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupportedScriptProto* internal_default_instance() {
    return reinterpret_cast<const SupportedScriptProto*>(
               &_SupportedScriptProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SupportedScriptProto& a, SupportedScriptProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SupportedScriptProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupportedScriptProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupportedScriptProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupportedScriptProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SupportedScriptProto& from);
  void MergeFrom(const SupportedScriptProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SupportedScriptProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SupportedScriptProto";
  }
  protected:
  explicit SupportedScriptProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SupportedScriptProto_PresentationProto PresentationProto;

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kPresentationFieldNumber = 2,
  };
  // optional string path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional .autofill_assistant.SupportedScriptProto.PresentationProto presentation = 2;
  bool has_presentation() const;
  private:
  bool _internal_has_presentation() const;
  public:
  void clear_presentation();
  const ::autofill_assistant::SupportedScriptProto_PresentationProto& presentation() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SupportedScriptProto_PresentationProto* release_presentation();
  ::autofill_assistant::SupportedScriptProto_PresentationProto* mutable_presentation();
  void set_allocated_presentation(::autofill_assistant::SupportedScriptProto_PresentationProto* presentation);
  private:
  const ::autofill_assistant::SupportedScriptProto_PresentationProto& _internal_presentation() const;
  ::autofill_assistant::SupportedScriptProto_PresentationProto* _internal_mutable_presentation();
  public:
  void unsafe_arena_set_allocated_presentation(
      ::autofill_assistant::SupportedScriptProto_PresentationProto* presentation);
  ::autofill_assistant::SupportedScriptProto_PresentationProto* unsafe_arena_release_presentation();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SupportedScriptProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::autofill_assistant::SupportedScriptProto_PresentationProto* presentation_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ScriptPreconditionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScriptPreconditionProto) */ {
 public:
  inline ScriptPreconditionProto() : ScriptPreconditionProto(nullptr) {}
  ~ScriptPreconditionProto() override;
  explicit PROTOBUF_CONSTEXPR ScriptPreconditionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptPreconditionProto(const ScriptPreconditionProto& from);
  ScriptPreconditionProto(ScriptPreconditionProto&& from) noexcept
    : ScriptPreconditionProto() {
    *this = ::std::move(from);
  }

  inline ScriptPreconditionProto& operator=(const ScriptPreconditionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptPreconditionProto& operator=(ScriptPreconditionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScriptPreconditionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScriptPreconditionProto* internal_default_instance() {
    return reinterpret_cast<const ScriptPreconditionProto*>(
               &_ScriptPreconditionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ScriptPreconditionProto& a, ScriptPreconditionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScriptPreconditionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptPreconditionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptPreconditionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptPreconditionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScriptPreconditionProto& from);
  void MergeFrom(const ScriptPreconditionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScriptPreconditionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScriptPreconditionProto";
  }
  protected:
  explicit ScriptPreconditionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathPatternFieldNumber = 5,
    kDomainFieldNumber = 6,
    kScriptParameterMatchFieldNumber = 7,
    kElementConditionFieldNumber = 10,
  };
  // repeated string path_pattern = 5;
  int path_pattern_size() const;
  private:
  int _internal_path_pattern_size() const;
  public:
  void clear_path_pattern();
  const std::string& path_pattern(int index) const;
  std::string* mutable_path_pattern(int index);
  void set_path_pattern(int index, const std::string& value);
  void set_path_pattern(int index, std::string&& value);
  void set_path_pattern(int index, const char* value);
  void set_path_pattern(int index, const char* value, size_t size);
  std::string* add_path_pattern();
  void add_path_pattern(const std::string& value);
  void add_path_pattern(std::string&& value);
  void add_path_pattern(const char* value);
  void add_path_pattern(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path_pattern() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path_pattern();
  private:
  const std::string& _internal_path_pattern(int index) const;
  std::string* _internal_add_path_pattern();
  public:

  // repeated string domain = 6;
  int domain_size() const;
  private:
  int _internal_domain_size() const;
  public:
  void clear_domain();
  const std::string& domain(int index) const;
  std::string* mutable_domain(int index);
  void set_domain(int index, const std::string& value);
  void set_domain(int index, std::string&& value);
  void set_domain(int index, const char* value);
  void set_domain(int index, const char* value, size_t size);
  std::string* add_domain();
  void add_domain(const std::string& value);
  void add_domain(std::string&& value);
  void add_domain(const char* value);
  void add_domain(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& domain() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_domain();
  private:
  const std::string& _internal_domain(int index) const;
  std::string* _internal_add_domain();
  public:

  // repeated .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 7;
  int script_parameter_match_size() const;
  private:
  int _internal_script_parameter_match_size() const;
  public:
  void clear_script_parameter_match();
  ::autofill_assistant::ScriptParameterMatchProto* mutable_script_parameter_match(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterMatchProto >*
      mutable_script_parameter_match();
  private:
  const ::autofill_assistant::ScriptParameterMatchProto& _internal_script_parameter_match(int index) const;
  ::autofill_assistant::ScriptParameterMatchProto* _internal_add_script_parameter_match();
  public:
  const ::autofill_assistant::ScriptParameterMatchProto& script_parameter_match(int index) const;
  ::autofill_assistant::ScriptParameterMatchProto* add_script_parameter_match();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterMatchProto >&
      script_parameter_match() const;

  // optional .autofill_assistant.ElementConditionProto element_condition = 10;
  bool has_element_condition() const;
  private:
  bool _internal_has_element_condition() const;
  public:
  void clear_element_condition();
  const ::autofill_assistant::ElementConditionProto& element_condition() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionProto* release_element_condition();
  ::autofill_assistant::ElementConditionProto* mutable_element_condition();
  void set_allocated_element_condition(::autofill_assistant::ElementConditionProto* element_condition);
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_element_condition() const;
  ::autofill_assistant::ElementConditionProto* _internal_mutable_element_condition();
  public:
  void unsafe_arena_set_allocated_element_condition(
      ::autofill_assistant::ElementConditionProto* element_condition);
  ::autofill_assistant::ElementConditionProto* unsafe_arena_release_element_condition();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScriptPreconditionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path_pattern_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> domain_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterMatchProto > script_parameter_match_;
  ::autofill_assistant::ElementConditionProto* element_condition_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ScriptParameterMatchProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScriptParameterMatchProto) */ {
 public:
  inline ScriptParameterMatchProto() : ScriptParameterMatchProto(nullptr) {}
  ~ScriptParameterMatchProto() override;
  explicit PROTOBUF_CONSTEXPR ScriptParameterMatchProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptParameterMatchProto(const ScriptParameterMatchProto& from);
  ScriptParameterMatchProto(ScriptParameterMatchProto&& from) noexcept
    : ScriptParameterMatchProto() {
    *this = ::std::move(from);
  }

  inline ScriptParameterMatchProto& operator=(const ScriptParameterMatchProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptParameterMatchProto& operator=(ScriptParameterMatchProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScriptParameterMatchProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScriptParameterMatchProto* internal_default_instance() {
    return reinterpret_cast<const ScriptParameterMatchProto*>(
               &_ScriptParameterMatchProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ScriptParameterMatchProto& a, ScriptParameterMatchProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScriptParameterMatchProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptParameterMatchProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptParameterMatchProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptParameterMatchProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScriptParameterMatchProto& from);
  void MergeFrom(const ScriptParameterMatchProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScriptParameterMatchProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScriptParameterMatchProto";
  }
  protected:
  explicit ScriptParameterMatchProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueEqualsFieldNumber = 3,
    kNameFieldNumber = 4,
    kExistsFieldNumber = 2,
  };
  // optional string value_equals = 3;
  bool has_value_equals() const;
  private:
  bool _internal_has_value_equals() const;
  public:
  void clear_value_equals();
  const std::string& value_equals() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_equals(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_equals();
  PROTOBUF_NODISCARD std::string* release_value_equals();
  void set_allocated_value_equals(std::string* value_equals);
  private:
  const std::string& _internal_value_equals() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_equals(const std::string& value);
  std::string* _internal_mutable_value_equals();
  public:

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool exists = 2 [default = true];
  bool has_exists() const;
  private:
  bool _internal_has_exists() const;
  public:
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);
  private:
  bool _internal_exists() const;
  void _internal_set_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScriptParameterMatchProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_equals_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool exists_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CUPRequestData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CUPRequestData) */ {
 public:
  inline CUPRequestData() : CUPRequestData(nullptr) {}
  ~CUPRequestData() override;
  explicit PROTOBUF_CONSTEXPR CUPRequestData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUPRequestData(const CUPRequestData& from);
  CUPRequestData(CUPRequestData&& from) noexcept
    : CUPRequestData() {
    *this = ::std::move(from);
  }

  inline CUPRequestData& operator=(const CUPRequestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUPRequestData& operator=(CUPRequestData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CUPRequestData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUPRequestData* internal_default_instance() {
    return reinterpret_cast<const CUPRequestData*>(
               &_CUPRequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CUPRequestData& a, CUPRequestData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CUPRequestData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUPRequestData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CUPRequestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CUPRequestData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CUPRequestData& from);
  void MergeFrom(const CUPRequestData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CUPRequestData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CUPRequestData";
  }
  protected:
  explicit CUPRequestData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kQueryCup2KeyFieldNumber = 2,
    kHashHexFieldNumber = 3,
  };
  // optional bytes request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const std::string& request() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request();
  PROTOBUF_NODISCARD std::string* release_request();
  void set_allocated_request(std::string* request);
  private:
  const std::string& _internal_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request(const std::string& value);
  std::string* _internal_mutable_request();
  public:

  // optional bytes query_cup2key = 2;
  bool has_query_cup2key() const;
  private:
  bool _internal_has_query_cup2key() const;
  public:
  void clear_query_cup2key();
  const std::string& query_cup2key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query_cup2key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query_cup2key();
  PROTOBUF_NODISCARD std::string* release_query_cup2key();
  void set_allocated_query_cup2key(std::string* query_cup2key);
  private:
  const std::string& _internal_query_cup2key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_cup2key(const std::string& value);
  std::string* _internal_mutable_query_cup2key();
  public:

  // optional bytes hash_hex = 3;
  bool has_hash_hex() const;
  private:
  bool _internal_has_hash_hex() const;
  public:
  void clear_hash_hex();
  const std::string& hash_hex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash_hex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash_hex();
  PROTOBUF_NODISCARD std::string* release_hash_hex();
  void set_allocated_hash_hex(std::string* hash_hex);
  private:
  const std::string& _internal_hash_hex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_hex(const std::string& value);
  std::string* _internal_mutable_hash_hex();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CUPRequestData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_cup2key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_hex_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ScriptActionRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScriptActionRequestProto) */ {
 public:
  inline ScriptActionRequestProto() : ScriptActionRequestProto(nullptr) {}
  ~ScriptActionRequestProto() override;
  explicit PROTOBUF_CONSTEXPR ScriptActionRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptActionRequestProto(const ScriptActionRequestProto& from);
  ScriptActionRequestProto(ScriptActionRequestProto&& from) noexcept
    : ScriptActionRequestProto() {
    *this = ::std::move(from);
  }

  inline ScriptActionRequestProto& operator=(const ScriptActionRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptActionRequestProto& operator=(ScriptActionRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScriptActionRequestProto& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kInitialRequest = 4,
    kNextRequest = 5,
    REQUEST_NOT_SET = 0,
  };

  static inline const ScriptActionRequestProto* internal_default_instance() {
    return reinterpret_cast<const ScriptActionRequestProto*>(
               &_ScriptActionRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ScriptActionRequestProto& a, ScriptActionRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScriptActionRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptActionRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptActionRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptActionRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScriptActionRequestProto& from);
  void MergeFrom(const ScriptActionRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScriptActionRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScriptActionRequestProto";
  }
  protected:
  explicit ScriptActionRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptPayloadFieldNumber = 2,
    kGlobalPayloadFieldNumber = 8,
    kClientContextFieldNumber = 7,
    kCupDataFieldNumber = 11,
    kInitialRequestFieldNumber = 4,
    kNextRequestFieldNumber = 5,
  };
  // optional bytes script_payload = 2;
  bool has_script_payload() const;
  private:
  bool _internal_has_script_payload() const;
  public:
  void clear_script_payload();
  const std::string& script_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script_payload();
  PROTOBUF_NODISCARD std::string* release_script_payload();
  void set_allocated_script_payload(std::string* script_payload);
  private:
  const std::string& _internal_script_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script_payload(const std::string& value);
  std::string* _internal_mutable_script_payload();
  public:

  // optional bytes global_payload = 8;
  bool has_global_payload() const;
  private:
  bool _internal_has_global_payload() const;
  public:
  void clear_global_payload();
  const std::string& global_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_payload();
  PROTOBUF_NODISCARD std::string* release_global_payload();
  void set_allocated_global_payload(std::string* global_payload);
  private:
  const std::string& _internal_global_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_payload(const std::string& value);
  std::string* _internal_mutable_global_payload();
  public:

  // optional .autofill_assistant.ClientContextProto client_context = 7;
  bool has_client_context() const;
  private:
  bool _internal_has_client_context() const;
  public:
  void clear_client_context();
  const ::autofill_assistant::ClientContextProto& client_context() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto* release_client_context();
  ::autofill_assistant::ClientContextProto* mutable_client_context();
  void set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context);
  private:
  const ::autofill_assistant::ClientContextProto& _internal_client_context() const;
  ::autofill_assistant::ClientContextProto* _internal_mutable_client_context();
  public:
  void unsafe_arena_set_allocated_client_context(
      ::autofill_assistant::ClientContextProto* client_context);
  ::autofill_assistant::ClientContextProto* unsafe_arena_release_client_context();

  // optional .autofill_assistant.CUPRequestData cup_data = 11;
  bool has_cup_data() const;
  private:
  bool _internal_has_cup_data() const;
  public:
  void clear_cup_data();
  const ::autofill_assistant::CUPRequestData& cup_data() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CUPRequestData* release_cup_data();
  ::autofill_assistant::CUPRequestData* mutable_cup_data();
  void set_allocated_cup_data(::autofill_assistant::CUPRequestData* cup_data);
  private:
  const ::autofill_assistant::CUPRequestData& _internal_cup_data() const;
  ::autofill_assistant::CUPRequestData* _internal_mutable_cup_data();
  public:
  void unsafe_arena_set_allocated_cup_data(
      ::autofill_assistant::CUPRequestData* cup_data);
  ::autofill_assistant::CUPRequestData* unsafe_arena_release_cup_data();

  // .autofill_assistant.InitialScriptActionsRequestProto initial_request = 4;
  bool has_initial_request() const;
  private:
  bool _internal_has_initial_request() const;
  public:
  void clear_initial_request();
  const ::autofill_assistant::InitialScriptActionsRequestProto& initial_request() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InitialScriptActionsRequestProto* release_initial_request();
  ::autofill_assistant::InitialScriptActionsRequestProto* mutable_initial_request();
  void set_allocated_initial_request(::autofill_assistant::InitialScriptActionsRequestProto* initial_request);
  private:
  const ::autofill_assistant::InitialScriptActionsRequestProto& _internal_initial_request() const;
  ::autofill_assistant::InitialScriptActionsRequestProto* _internal_mutable_initial_request();
  public:
  void unsafe_arena_set_allocated_initial_request(
      ::autofill_assistant::InitialScriptActionsRequestProto* initial_request);
  ::autofill_assistant::InitialScriptActionsRequestProto* unsafe_arena_release_initial_request();

  // .autofill_assistant.NextScriptActionsRequestProto next_request = 5;
  bool has_next_request() const;
  private:
  bool _internal_has_next_request() const;
  public:
  void clear_next_request();
  const ::autofill_assistant::NextScriptActionsRequestProto& next_request() const;
  PROTOBUF_NODISCARD ::autofill_assistant::NextScriptActionsRequestProto* release_next_request();
  ::autofill_assistant::NextScriptActionsRequestProto* mutable_next_request();
  void set_allocated_next_request(::autofill_assistant::NextScriptActionsRequestProto* next_request);
  private:
  const ::autofill_assistant::NextScriptActionsRequestProto& _internal_next_request() const;
  ::autofill_assistant::NextScriptActionsRequestProto* _internal_mutable_next_request();
  public:
  void unsafe_arena_set_allocated_next_request(
      ::autofill_assistant::NextScriptActionsRequestProto* next_request);
  ::autofill_assistant::NextScriptActionsRequestProto* unsafe_arena_release_next_request();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ScriptActionRequestProto)
 private:
  class _Internal;
  void set_has_initial_request();
  void set_has_next_request();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_payload_;
  ::autofill_assistant::ClientContextProto* client_context_;
  ::autofill_assistant::CUPRequestData* cup_data_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::InitialScriptActionsRequestProto* initial_request_;
    ::autofill_assistant::NextScriptActionsRequestProto* next_request_;
  } request_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ScriptStoreConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScriptStoreConfig) */ {
 public:
  inline ScriptStoreConfig() : ScriptStoreConfig(nullptr) {}
  ~ScriptStoreConfig() override;
  explicit PROTOBUF_CONSTEXPR ScriptStoreConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScriptStoreConfig(const ScriptStoreConfig& from);
  ScriptStoreConfig(ScriptStoreConfig&& from) noexcept
    : ScriptStoreConfig() {
    *this = ::std::move(from);
  }

  inline ScriptStoreConfig& operator=(const ScriptStoreConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScriptStoreConfig& operator=(ScriptStoreConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScriptStoreConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScriptStoreConfig* internal_default_instance() {
    return reinterpret_cast<const ScriptStoreConfig*>(
               &_ScriptStoreConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ScriptStoreConfig& a, ScriptStoreConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScriptStoreConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScriptStoreConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScriptStoreConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScriptStoreConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScriptStoreConfig& from);
  void MergeFrom(const ScriptStoreConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScriptStoreConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScriptStoreConfig";
  }
  protected:
  explicit ScriptStoreConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBundlePathFieldNumber = 2,
    kBundleVersionFieldNumber = 3,
  };
  // optional string bundle_path = 2;
  bool has_bundle_path() const;
  private:
  bool _internal_has_bundle_path() const;
  public:
  void clear_bundle_path();
  const std::string& bundle_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bundle_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bundle_path();
  PROTOBUF_NODISCARD std::string* release_bundle_path();
  void set_allocated_bundle_path(std::string* bundle_path);
  private:
  const std::string& _internal_bundle_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bundle_path(const std::string& value);
  std::string* _internal_mutable_bundle_path();
  public:

  // optional int64 bundle_version = 3;
  bool has_bundle_version() const;
  private:
  bool _internal_has_bundle_version() const;
  public:
  void clear_bundle_version();
  int64_t bundle_version() const;
  void set_bundle_version(int64_t value);
  private:
  int64_t _internal_bundle_version() const;
  void _internal_set_bundle_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScriptStoreConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bundle_path_;
  int64_t bundle_version_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class InitialScriptActionsRequestProto_QueryProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InitialScriptActionsRequestProto.QueryProto) */ {
 public:
  inline InitialScriptActionsRequestProto_QueryProto() : InitialScriptActionsRequestProto_QueryProto(nullptr) {}
  ~InitialScriptActionsRequestProto_QueryProto() override;
  explicit PROTOBUF_CONSTEXPR InitialScriptActionsRequestProto_QueryProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitialScriptActionsRequestProto_QueryProto(const InitialScriptActionsRequestProto_QueryProto& from);
  InitialScriptActionsRequestProto_QueryProto(InitialScriptActionsRequestProto_QueryProto&& from) noexcept
    : InitialScriptActionsRequestProto_QueryProto() {
    *this = ::std::move(from);
  }

  inline InitialScriptActionsRequestProto_QueryProto& operator=(const InitialScriptActionsRequestProto_QueryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialScriptActionsRequestProto_QueryProto& operator=(InitialScriptActionsRequestProto_QueryProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InitialScriptActionsRequestProto_QueryProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitialScriptActionsRequestProto_QueryProto* internal_default_instance() {
    return reinterpret_cast<const InitialScriptActionsRequestProto_QueryProto*>(
               &_InitialScriptActionsRequestProto_QueryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(InitialScriptActionsRequestProto_QueryProto& a, InitialScriptActionsRequestProto_QueryProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InitialScriptActionsRequestProto_QueryProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialScriptActionsRequestProto_QueryProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialScriptActionsRequestProto_QueryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitialScriptActionsRequestProto_QueryProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InitialScriptActionsRequestProto_QueryProto& from);
  void MergeFrom(const InitialScriptActionsRequestProto_QueryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitialScriptActionsRequestProto_QueryProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InitialScriptActionsRequestProto.QueryProto";
  }
  protected:
  explicit InitialScriptActionsRequestProto_QueryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptPathFieldNumber = 1,
    kUrlFieldNumber = 2,
    kPolicyFieldNumber = 3,
  };
  // repeated string script_path = 1;
  int script_path_size() const;
  private:
  int _internal_script_path_size() const;
  public:
  void clear_script_path();
  const std::string& script_path(int index) const;
  std::string* mutable_script_path(int index);
  void set_script_path(int index, const std::string& value);
  void set_script_path(int index, std::string&& value);
  void set_script_path(int index, const char* value);
  void set_script_path(int index, const char* value, size_t size);
  std::string* add_script_path();
  void add_script_path(const std::string& value);
  void add_script_path(std::string&& value);
  void add_script_path(const char* value);
  void add_script_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& script_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_script_path();
  private:
  const std::string& _internal_script_path(int index) const;
  std::string* _internal_add_script_path();
  public:

  // optional string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional .autofill_assistant.PolicyType policy = 3;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  ::autofill_assistant::PolicyType policy() const;
  void set_policy(::autofill_assistant::PolicyType value);
  private:
  ::autofill_assistant::PolicyType _internal_policy() const;
  void _internal_set_policy(::autofill_assistant::PolicyType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> script_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  int policy_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class InitialScriptActionsRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InitialScriptActionsRequestProto) */ {
 public:
  inline InitialScriptActionsRequestProto() : InitialScriptActionsRequestProto(nullptr) {}
  ~InitialScriptActionsRequestProto() override;
  explicit PROTOBUF_CONSTEXPR InitialScriptActionsRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitialScriptActionsRequestProto(const InitialScriptActionsRequestProto& from);
  InitialScriptActionsRequestProto(InitialScriptActionsRequestProto&& from) noexcept
    : InitialScriptActionsRequestProto() {
    *this = ::std::move(from);
  }

  inline InitialScriptActionsRequestProto& operator=(const InitialScriptActionsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialScriptActionsRequestProto& operator=(InitialScriptActionsRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InitialScriptActionsRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitialScriptActionsRequestProto* internal_default_instance() {
    return reinterpret_cast<const InitialScriptActionsRequestProto*>(
               &_InitialScriptActionsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(InitialScriptActionsRequestProto& a, InitialScriptActionsRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InitialScriptActionsRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialScriptActionsRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialScriptActionsRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitialScriptActionsRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InitialScriptActionsRequestProto& from);
  void MergeFrom(const InitialScriptActionsRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitialScriptActionsRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InitialScriptActionsRequestProto";
  }
  protected:
  explicit InitialScriptActionsRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InitialScriptActionsRequestProto_QueryProto QueryProto;

  // accessors -------------------------------------------------------

  enum : int {
    kScriptParametersFieldNumber = 2,
    kQueryFieldNumber = 3,
    kScriptStoreConfigFieldNumber = 6,
  };
  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
  int script_parameters_size() const;
  private:
  int _internal_script_parameters_size() const;
  public:
  void clear_script_parameters();
  ::autofill_assistant::ScriptParameterProto* mutable_script_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_script_parameters();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_script_parameters();
  public:
  const ::autofill_assistant::ScriptParameterProto& script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_script_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      script_parameters() const;

  // optional .autofill_assistant.InitialScriptActionsRequestProto.QueryProto query = 3;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto& query() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* release_query();
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* mutable_query();
  void set_allocated_query(::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* query);
  private:
  const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto& _internal_query() const;
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* query);
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* unsafe_arena_release_query();

  // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
  bool has_script_store_config() const;
  private:
  bool _internal_has_script_store_config() const;
  public:
  void clear_script_store_config();
  const ::autofill_assistant::ScriptStoreConfig& script_store_config() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScriptStoreConfig* release_script_store_config();
  ::autofill_assistant::ScriptStoreConfig* mutable_script_store_config();
  void set_allocated_script_store_config(::autofill_assistant::ScriptStoreConfig* script_store_config);
  private:
  const ::autofill_assistant::ScriptStoreConfig& _internal_script_store_config() const;
  ::autofill_assistant::ScriptStoreConfig* _internal_mutable_script_store_config();
  public:
  void unsafe_arena_set_allocated_script_store_config(
      ::autofill_assistant::ScriptStoreConfig* script_store_config);
  ::autofill_assistant::ScriptStoreConfig* unsafe_arena_release_script_store_config();

  // @@protoc_insertion_point(class_scope:autofill_assistant.InitialScriptActionsRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > script_parameters_;
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* query_;
  ::autofill_assistant::ScriptStoreConfig* script_store_config_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RoundtripTimingStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.RoundtripTimingStats) */ {
 public:
  inline RoundtripTimingStats() : RoundtripTimingStats(nullptr) {}
  ~RoundtripTimingStats() override;
  explicit PROTOBUF_CONSTEXPR RoundtripTimingStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoundtripTimingStats(const RoundtripTimingStats& from);
  RoundtripTimingStats(RoundtripTimingStats&& from) noexcept
    : RoundtripTimingStats() {
    *this = ::std::move(from);
  }

  inline RoundtripTimingStats& operator=(const RoundtripTimingStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundtripTimingStats& operator=(RoundtripTimingStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RoundtripTimingStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoundtripTimingStats* internal_default_instance() {
    return reinterpret_cast<const RoundtripTimingStats*>(
               &_RoundtripTimingStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RoundtripTimingStats& a, RoundtripTimingStats& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RoundtripTimingStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundtripTimingStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundtripTimingStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoundtripTimingStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RoundtripTimingStats& from);
  void MergeFrom(const RoundtripTimingStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoundtripTimingStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.RoundtripTimingStats";
  }
  protected:
  explicit RoundtripTimingStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundtripTimeMsFieldNumber = 1,
    kClientTimeMsFieldNumber = 2,
  };
  // optional int64 roundtrip_time_ms = 1;
  bool has_roundtrip_time_ms() const;
  private:
  bool _internal_has_roundtrip_time_ms() const;
  public:
  void clear_roundtrip_time_ms();
  int64_t roundtrip_time_ms() const;
  void set_roundtrip_time_ms(int64_t value);
  private:
  int64_t _internal_roundtrip_time_ms() const;
  void _internal_set_roundtrip_time_ms(int64_t value);
  public:

  // optional int64 client_time_ms = 2;
  bool has_client_time_ms() const;
  private:
  bool _internal_has_client_time_ms() const;
  public:
  void clear_client_time_ms();
  int64_t client_time_ms() const;
  void set_client_time_ms(int64_t value);
  private:
  int64_t _internal_client_time_ms() const;
  void _internal_set_client_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.RoundtripTimingStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t roundtrip_time_ms_;
  int64_t client_time_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RoundtripNetworkStats_ActionNetworkStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats) */ {
 public:
  inline RoundtripNetworkStats_ActionNetworkStats() : RoundtripNetworkStats_ActionNetworkStats(nullptr) {}
  ~RoundtripNetworkStats_ActionNetworkStats() override;
  explicit PROTOBUF_CONSTEXPR RoundtripNetworkStats_ActionNetworkStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoundtripNetworkStats_ActionNetworkStats(const RoundtripNetworkStats_ActionNetworkStats& from);
  RoundtripNetworkStats_ActionNetworkStats(RoundtripNetworkStats_ActionNetworkStats&& from) noexcept
    : RoundtripNetworkStats_ActionNetworkStats() {
    *this = ::std::move(from);
  }

  inline RoundtripNetworkStats_ActionNetworkStats& operator=(const RoundtripNetworkStats_ActionNetworkStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundtripNetworkStats_ActionNetworkStats& operator=(RoundtripNetworkStats_ActionNetworkStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RoundtripNetworkStats_ActionNetworkStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoundtripNetworkStats_ActionNetworkStats* internal_default_instance() {
    return reinterpret_cast<const RoundtripNetworkStats_ActionNetworkStats*>(
               &_RoundtripNetworkStats_ActionNetworkStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RoundtripNetworkStats_ActionNetworkStats& a, RoundtripNetworkStats_ActionNetworkStats& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RoundtripNetworkStats_ActionNetworkStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundtripNetworkStats_ActionNetworkStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundtripNetworkStats_ActionNetworkStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoundtripNetworkStats_ActionNetworkStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RoundtripNetworkStats_ActionNetworkStats& from);
  void MergeFrom(const RoundtripNetworkStats_ActionNetworkStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoundtripNetworkStats_ActionNetworkStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.RoundtripNetworkStats.ActionNetworkStats";
  }
  protected:
  explicit RoundtripNetworkStats_ActionNetworkStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecodedSizeBytesFieldNumber = 2,
    kActionInfoCaseFieldNumber = 1,
  };
  // optional int64 decoded_size_bytes = 2;
  bool has_decoded_size_bytes() const;
  private:
  bool _internal_has_decoded_size_bytes() const;
  public:
  void clear_decoded_size_bytes();
  int64_t decoded_size_bytes() const;
  void set_decoded_size_bytes(int64_t value);
  private:
  int64_t _internal_decoded_size_bytes() const;
  void _internal_set_decoded_size_bytes(int64_t value);
  public:

  // optional int32 action_info_case = 1;
  bool has_action_info_case() const;
  private:
  bool _internal_has_action_info_case() const;
  public:
  void clear_action_info_case();
  int32_t action_info_case() const;
  void set_action_info_case(int32_t value);
  private:
  int32_t _internal_action_info_case() const;
  void _internal_set_action_info_case(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t decoded_size_bytes_;
  int32_t action_info_case_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RoundtripNetworkStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.RoundtripNetworkStats) */ {
 public:
  inline RoundtripNetworkStats() : RoundtripNetworkStats(nullptr) {}
  ~RoundtripNetworkStats() override;
  explicit PROTOBUF_CONSTEXPR RoundtripNetworkStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoundtripNetworkStats(const RoundtripNetworkStats& from);
  RoundtripNetworkStats(RoundtripNetworkStats&& from) noexcept
    : RoundtripNetworkStats() {
    *this = ::std::move(from);
  }

  inline RoundtripNetworkStats& operator=(const RoundtripNetworkStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundtripNetworkStats& operator=(RoundtripNetworkStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RoundtripNetworkStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoundtripNetworkStats* internal_default_instance() {
    return reinterpret_cast<const RoundtripNetworkStats*>(
               &_RoundtripNetworkStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RoundtripNetworkStats& a, RoundtripNetworkStats& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RoundtripNetworkStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundtripNetworkStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundtripNetworkStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoundtripNetworkStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RoundtripNetworkStats& from);
  void MergeFrom(const RoundtripNetworkStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoundtripNetworkStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.RoundtripNetworkStats";
  }
  protected:
  explicit RoundtripNetworkStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RoundtripNetworkStats_ActionNetworkStats ActionNetworkStats;

  // accessors -------------------------------------------------------

  enum : int {
    kActionStatsFieldNumber = 3,
    kRoundtripEncodedBodySizeBytesFieldNumber = 1,
    kRoundtripDecodedBodySizeBytesFieldNumber = 2,
    kNumRoundtripsFieldNumber = 4,
  };
  // repeated .autofill_assistant.RoundtripNetworkStats.ActionNetworkStats action_stats = 3;
  int action_stats_size() const;
  private:
  int _internal_action_stats_size() const;
  public:
  void clear_action_stats();
  ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* mutable_action_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats >*
      mutable_action_stats();
  private:
  const ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats& _internal_action_stats(int index) const;
  ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* _internal_add_action_stats();
  public:
  const ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats& action_stats(int index) const;
  ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* add_action_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats >&
      action_stats() const;

  // optional int64 roundtrip_encoded_body_size_bytes = 1;
  bool has_roundtrip_encoded_body_size_bytes() const;
  private:
  bool _internal_has_roundtrip_encoded_body_size_bytes() const;
  public:
  void clear_roundtrip_encoded_body_size_bytes();
  int64_t roundtrip_encoded_body_size_bytes() const;
  void set_roundtrip_encoded_body_size_bytes(int64_t value);
  private:
  int64_t _internal_roundtrip_encoded_body_size_bytes() const;
  void _internal_set_roundtrip_encoded_body_size_bytes(int64_t value);
  public:

  // optional int64 roundtrip_decoded_body_size_bytes = 2;
  bool has_roundtrip_decoded_body_size_bytes() const;
  private:
  bool _internal_has_roundtrip_decoded_body_size_bytes() const;
  public:
  void clear_roundtrip_decoded_body_size_bytes();
  int64_t roundtrip_decoded_body_size_bytes() const;
  void set_roundtrip_decoded_body_size_bytes(int64_t value);
  private:
  int64_t _internal_roundtrip_decoded_body_size_bytes() const;
  void _internal_set_roundtrip_decoded_body_size_bytes(int64_t value);
  public:

  // optional int32 num_roundtrips = 4;
  bool has_num_roundtrips() const;
  private:
  bool _internal_has_num_roundtrips() const;
  public:
  void clear_num_roundtrips();
  int32_t num_roundtrips() const;
  void set_num_roundtrips(int32_t value);
  private:
  int32_t _internal_num_roundtrips() const;
  void _internal_set_num_roundtrips(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.RoundtripNetworkStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats > action_stats_;
  int64_t roundtrip_encoded_body_size_bytes_;
  int64_t roundtrip_decoded_body_size_bytes_;
  int32_t num_roundtrips_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class NextScriptActionsRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.NextScriptActionsRequestProto) */ {
 public:
  inline NextScriptActionsRequestProto() : NextScriptActionsRequestProto(nullptr) {}
  ~NextScriptActionsRequestProto() override;
  explicit PROTOBUF_CONSTEXPR NextScriptActionsRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextScriptActionsRequestProto(const NextScriptActionsRequestProto& from);
  NextScriptActionsRequestProto(NextScriptActionsRequestProto&& from) noexcept
    : NextScriptActionsRequestProto() {
    *this = ::std::move(from);
  }

  inline NextScriptActionsRequestProto& operator=(const NextScriptActionsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextScriptActionsRequestProto& operator=(NextScriptActionsRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NextScriptActionsRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextScriptActionsRequestProto* internal_default_instance() {
    return reinterpret_cast<const NextScriptActionsRequestProto*>(
               &_NextScriptActionsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(NextScriptActionsRequestProto& a, NextScriptActionsRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NextScriptActionsRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextScriptActionsRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextScriptActionsRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextScriptActionsRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NextScriptActionsRequestProto& from);
  void MergeFrom(const NextScriptActionsRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NextScriptActionsRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.NextScriptActionsRequestProto";
  }
  protected:
  explicit NextScriptActionsRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessedActionsFieldNumber = 1,
    kTimingStatsFieldNumber = 2,
    kNetworkStatsFieldNumber = 3,
    kSlowConnectionWarningFieldNumber = 34,
  };
  // repeated .autofill_assistant.ProcessedActionProto processed_actions = 1;
  int processed_actions_size() const;
  private:
  int _internal_processed_actions_size() const;
  public:
  void clear_processed_actions();
  ::autofill_assistant::ProcessedActionProto* mutable_processed_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProcessedActionProto >*
      mutable_processed_actions();
  private:
  const ::autofill_assistant::ProcessedActionProto& _internal_processed_actions(int index) const;
  ::autofill_assistant::ProcessedActionProto* _internal_add_processed_actions();
  public:
  const ::autofill_assistant::ProcessedActionProto& processed_actions(int index) const;
  ::autofill_assistant::ProcessedActionProto* add_processed_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProcessedActionProto >&
      processed_actions() const;

  // optional .autofill_assistant.RoundtripTimingStats timing_stats = 2;
  bool has_timing_stats() const;
  private:
  bool _internal_has_timing_stats() const;
  public:
  void clear_timing_stats();
  const ::autofill_assistant::RoundtripTimingStats& timing_stats() const;
  PROTOBUF_NODISCARD ::autofill_assistant::RoundtripTimingStats* release_timing_stats();
  ::autofill_assistant::RoundtripTimingStats* mutable_timing_stats();
  void set_allocated_timing_stats(::autofill_assistant::RoundtripTimingStats* timing_stats);
  private:
  const ::autofill_assistant::RoundtripTimingStats& _internal_timing_stats() const;
  ::autofill_assistant::RoundtripTimingStats* _internal_mutable_timing_stats();
  public:
  void unsafe_arena_set_allocated_timing_stats(
      ::autofill_assistant::RoundtripTimingStats* timing_stats);
  ::autofill_assistant::RoundtripTimingStats* unsafe_arena_release_timing_stats();

  // optional .autofill_assistant.RoundtripNetworkStats network_stats = 3;
  bool has_network_stats() const;
  private:
  bool _internal_has_network_stats() const;
  public:
  void clear_network_stats();
  const ::autofill_assistant::RoundtripNetworkStats& network_stats() const;
  PROTOBUF_NODISCARD ::autofill_assistant::RoundtripNetworkStats* release_network_stats();
  ::autofill_assistant::RoundtripNetworkStats* mutable_network_stats();
  void set_allocated_network_stats(::autofill_assistant::RoundtripNetworkStats* network_stats);
  private:
  const ::autofill_assistant::RoundtripNetworkStats& _internal_network_stats() const;
  ::autofill_assistant::RoundtripNetworkStats* _internal_mutable_network_stats();
  public:
  void unsafe_arena_set_allocated_network_stats(
      ::autofill_assistant::RoundtripNetworkStats* network_stats);
  ::autofill_assistant::RoundtripNetworkStats* unsafe_arena_release_network_stats();

  // optional .autofill_assistant.SlowWarningStatus slow_connection_warning = 34;
  bool has_slow_connection_warning() const;
  private:
  bool _internal_has_slow_connection_warning() const;
  public:
  void clear_slow_connection_warning();
  ::autofill_assistant::SlowWarningStatus slow_connection_warning() const;
  void set_slow_connection_warning(::autofill_assistant::SlowWarningStatus value);
  private:
  ::autofill_assistant::SlowWarningStatus _internal_slow_connection_warning() const;
  void _internal_set_slow_connection_warning(::autofill_assistant::SlowWarningStatus value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.NextScriptActionsRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProcessedActionProto > processed_actions_;
  ::autofill_assistant::RoundtripTimingStats* timing_stats_;
  ::autofill_assistant::RoundtripNetworkStats* network_stats_;
  int slow_connection_warning_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CUPResponseData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CUPResponseData) */ {
 public:
  inline CUPResponseData() : CUPResponseData(nullptr) {}
  ~CUPResponseData() override;
  explicit PROTOBUF_CONSTEXPR CUPResponseData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CUPResponseData(const CUPResponseData& from);
  CUPResponseData(CUPResponseData&& from) noexcept
    : CUPResponseData() {
    *this = ::std::move(from);
  }

  inline CUPResponseData& operator=(const CUPResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CUPResponseData& operator=(CUPResponseData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CUPResponseData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CUPResponseData* internal_default_instance() {
    return reinterpret_cast<const CUPResponseData*>(
               &_CUPResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CUPResponseData& a, CUPResponseData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CUPResponseData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CUPResponseData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CUPResponseData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CUPResponseData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CUPResponseData& from);
  void MergeFrom(const CUPResponseData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CUPResponseData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CUPResponseData";
  }
  protected:
  explicit CUPResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kEcdsaSignatureFieldNumber = 2,
  };
  // optional bytes response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // optional bytes ecdsa_signature = 2;
  bool has_ecdsa_signature() const;
  private:
  bool _internal_has_ecdsa_signature() const;
  public:
  void clear_ecdsa_signature();
  const std::string& ecdsa_signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ecdsa_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ecdsa_signature();
  PROTOBUF_NODISCARD std::string* release_ecdsa_signature();
  void set_allocated_ecdsa_signature(std::string* ecdsa_signature);
  private:
  const std::string& _internal_ecdsa_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ecdsa_signature(const std::string& value);
  std::string* _internal_mutable_ecdsa_signature();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CUPResponseData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ecdsa_signature_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ActionsResponseProto_UpdateScriptListProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ActionsResponseProto.UpdateScriptListProto) */ {
 public:
  inline ActionsResponseProto_UpdateScriptListProto() : ActionsResponseProto_UpdateScriptListProto(nullptr) {}
  ~ActionsResponseProto_UpdateScriptListProto() override;
  explicit PROTOBUF_CONSTEXPR ActionsResponseProto_UpdateScriptListProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionsResponseProto_UpdateScriptListProto(const ActionsResponseProto_UpdateScriptListProto& from);
  ActionsResponseProto_UpdateScriptListProto(ActionsResponseProto_UpdateScriptListProto&& from) noexcept
    : ActionsResponseProto_UpdateScriptListProto() {
    *this = ::std::move(from);
  }

  inline ActionsResponseProto_UpdateScriptListProto& operator=(const ActionsResponseProto_UpdateScriptListProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionsResponseProto_UpdateScriptListProto& operator=(ActionsResponseProto_UpdateScriptListProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActionsResponseProto_UpdateScriptListProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionsResponseProto_UpdateScriptListProto* internal_default_instance() {
    return reinterpret_cast<const ActionsResponseProto_UpdateScriptListProto*>(
               &_ActionsResponseProto_UpdateScriptListProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ActionsResponseProto_UpdateScriptListProto& a, ActionsResponseProto_UpdateScriptListProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ActionsResponseProto_UpdateScriptListProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionsResponseProto_UpdateScriptListProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionsResponseProto_UpdateScriptListProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionsResponseProto_UpdateScriptListProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActionsResponseProto_UpdateScriptListProto& from);
  void MergeFrom(const ActionsResponseProto_UpdateScriptListProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionsResponseProto_UpdateScriptListProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ActionsResponseProto.UpdateScriptListProto";
  }
  protected:
  explicit ActionsResponseProto_UpdateScriptListProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptsFieldNumber = 1,
  };
  // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
  int scripts_size() const;
  private:
  int _internal_scripts_size() const;
  public:
  void clear_scripts();
  ::autofill_assistant::SupportedScriptProto* mutable_scripts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >*
      mutable_scripts();
  private:
  const ::autofill_assistant::SupportedScriptProto& _internal_scripts(int index) const;
  ::autofill_assistant::SupportedScriptProto* _internal_add_scripts();
  public:
  const ::autofill_assistant::SupportedScriptProto& scripts(int index) const;
  ::autofill_assistant::SupportedScriptProto* add_scripts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >&
      scripts() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto > scripts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ActionsResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ActionsResponseProto) */ {
 public:
  inline ActionsResponseProto() : ActionsResponseProto(nullptr) {}
  ~ActionsResponseProto() override;
  explicit PROTOBUF_CONSTEXPR ActionsResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionsResponseProto(const ActionsResponseProto& from);
  ActionsResponseProto(ActionsResponseProto&& from) noexcept
    : ActionsResponseProto() {
    *this = ::std::move(from);
  }

  inline ActionsResponseProto& operator=(const ActionsResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionsResponseProto& operator=(ActionsResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActionsResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionsResponseProto* internal_default_instance() {
    return reinterpret_cast<const ActionsResponseProto*>(
               &_ActionsResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ActionsResponseProto& a, ActionsResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ActionsResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionsResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionsResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionsResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActionsResponseProto& from);
  void MergeFrom(const ActionsResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionsResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ActionsResponseProto";
  }
  protected:
  explicit ActionsResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ActionsResponseProto_UpdateScriptListProto UpdateScriptListProto;

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 3,
    kScriptPayloadFieldNumber = 2,
    kGlobalPayloadFieldNumber = 4,
    kJsFlowLibraryFieldNumber = 13,
    kReportTokenFieldNumber = 14,
    kUpdateScriptListFieldNumber = 5,
    kCupDataFieldNumber = 11,
    kRunIdFieldNumber = 12,
  };
  // repeated .autofill_assistant.ActionProto actions = 3;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::autofill_assistant::ActionProto* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ActionProto >*
      mutable_actions();
  private:
  const ::autofill_assistant::ActionProto& _internal_actions(int index) const;
  ::autofill_assistant::ActionProto* _internal_add_actions();
  public:
  const ::autofill_assistant::ActionProto& actions(int index) const;
  ::autofill_assistant::ActionProto* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ActionProto >&
      actions() const;

  // optional bytes script_payload = 2;
  bool has_script_payload() const;
  private:
  bool _internal_has_script_payload() const;
  public:
  void clear_script_payload();
  const std::string& script_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script_payload();
  PROTOBUF_NODISCARD std::string* release_script_payload();
  void set_allocated_script_payload(std::string* script_payload);
  private:
  const std::string& _internal_script_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script_payload(const std::string& value);
  std::string* _internal_mutable_script_payload();
  public:

  // optional bytes global_payload = 4;
  bool has_global_payload() const;
  private:
  bool _internal_has_global_payload() const;
  public:
  void clear_global_payload();
  const std::string& global_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_global_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_global_payload();
  PROTOBUF_NODISCARD std::string* release_global_payload();
  void set_allocated_global_payload(std::string* global_payload);
  private:
  const std::string& _internal_global_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_payload(const std::string& value);
  std::string* _internal_mutable_global_payload();
  public:

  // optional string js_flow_library = 13;
  bool has_js_flow_library() const;
  private:
  bool _internal_has_js_flow_library() const;
  public:
  void clear_js_flow_library();
  const std::string& js_flow_library() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_js_flow_library(ArgT0&& arg0, ArgT... args);
  std::string* mutable_js_flow_library();
  PROTOBUF_NODISCARD std::string* release_js_flow_library();
  void set_allocated_js_flow_library(std::string* js_flow_library);
  private:
  const std::string& _internal_js_flow_library() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_js_flow_library(const std::string& value);
  std::string* _internal_mutable_js_flow_library();
  public:

  // optional string report_token = 14;
  bool has_report_token() const;
  private:
  bool _internal_has_report_token() const;
  public:
  void clear_report_token();
  const std::string& report_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_report_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_report_token();
  PROTOBUF_NODISCARD std::string* release_report_token();
  void set_allocated_report_token(std::string* report_token);
  private:
  const std::string& _internal_report_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_report_token(const std::string& value);
  std::string* _internal_mutable_report_token();
  public:

  // optional .autofill_assistant.ActionsResponseProto.UpdateScriptListProto update_script_list = 5;
  bool has_update_script_list() const;
  private:
  bool _internal_has_update_script_list() const;
  public:
  void clear_update_script_list();
  const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto& update_script_list() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* release_update_script_list();
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* mutable_update_script_list();
  void set_allocated_update_script_list(::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* update_script_list);
  private:
  const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto& _internal_update_script_list() const;
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* _internal_mutable_update_script_list();
  public:
  void unsafe_arena_set_allocated_update_script_list(
      ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* update_script_list);
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* unsafe_arena_release_update_script_list();

  // optional .autofill_assistant.CUPResponseData cup_data = 11;
  bool has_cup_data() const;
  private:
  bool _internal_has_cup_data() const;
  public:
  void clear_cup_data();
  const ::autofill_assistant::CUPResponseData& cup_data() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CUPResponseData* release_cup_data();
  ::autofill_assistant::CUPResponseData* mutable_cup_data();
  void set_allocated_cup_data(::autofill_assistant::CUPResponseData* cup_data);
  private:
  const ::autofill_assistant::CUPResponseData& _internal_cup_data() const;
  ::autofill_assistant::CUPResponseData* _internal_mutable_cup_data();
  public:
  void unsafe_arena_set_allocated_cup_data(
      ::autofill_assistant::CUPResponseData* cup_data);
  ::autofill_assistant::CUPResponseData* unsafe_arena_release_cup_data();

  // optional uint64 run_id = 12;
  bool has_run_id() const;
  private:
  bool _internal_has_run_id() const;
  public:
  void clear_run_id();
  uint64_t run_id() const;
  void set_run_id(uint64_t value);
  private:
  uint64_t _internal_run_id() const;
  void _internal_set_run_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ActionsResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ActionProto > actions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr js_flow_library_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_token_;
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* update_script_list_;
  ::autofill_assistant::CUPResponseData* cup_data_;
  uint64_t run_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetTriggerScriptsRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetTriggerScriptsRequestProto) */ {
 public:
  inline GetTriggerScriptsRequestProto() : GetTriggerScriptsRequestProto(nullptr) {}
  ~GetTriggerScriptsRequestProto() override;
  explicit PROTOBUF_CONSTEXPR GetTriggerScriptsRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTriggerScriptsRequestProto(const GetTriggerScriptsRequestProto& from);
  GetTriggerScriptsRequestProto(GetTriggerScriptsRequestProto&& from) noexcept
    : GetTriggerScriptsRequestProto() {
    *this = ::std::move(from);
  }

  inline GetTriggerScriptsRequestProto& operator=(const GetTriggerScriptsRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTriggerScriptsRequestProto& operator=(GetTriggerScriptsRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetTriggerScriptsRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTriggerScriptsRequestProto* internal_default_instance() {
    return reinterpret_cast<const GetTriggerScriptsRequestProto*>(
               &_GetTriggerScriptsRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetTriggerScriptsRequestProto& a, GetTriggerScriptsRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetTriggerScriptsRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTriggerScriptsRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTriggerScriptsRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTriggerScriptsRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetTriggerScriptsRequestProto& from);
  void MergeFrom(const GetTriggerScriptsRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTriggerScriptsRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetTriggerScriptsRequestProto";
  }
  protected:
  explicit GetTriggerScriptsRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptParametersFieldNumber = 3,
    kUrlFieldNumber = 1,
    kClientContextFieldNumber = 2,
  };
  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 3;
  int script_parameters_size() const;
  private:
  int _internal_script_parameters_size() const;
  public:
  void clear_script_parameters();
  ::autofill_assistant::ScriptParameterProto* mutable_script_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_script_parameters();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_script_parameters();
  public:
  const ::autofill_assistant::ScriptParameterProto& script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_script_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      script_parameters() const;

  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional .autofill_assistant.ClientContextProto client_context = 2;
  bool has_client_context() const;
  private:
  bool _internal_has_client_context() const;
  public:
  void clear_client_context();
  const ::autofill_assistant::ClientContextProto& client_context() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientContextProto* release_client_context();
  ::autofill_assistant::ClientContextProto* mutable_client_context();
  void set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context);
  private:
  const ::autofill_assistant::ClientContextProto& _internal_client_context() const;
  ::autofill_assistant::ClientContextProto* _internal_mutable_client_context();
  public:
  void unsafe_arena_set_allocated_client_context(
      ::autofill_assistant::ClientContextProto* client_context);
  ::autofill_assistant::ClientContextProto* unsafe_arena_release_client_context();

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetTriggerScriptsRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > script_parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::autofill_assistant::ClientContextProto* client_context_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetTriggerScriptsResponseProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetTriggerScriptsResponseProto) */ {
 public:
  inline GetTriggerScriptsResponseProto() : GetTriggerScriptsResponseProto(nullptr) {}
  ~GetTriggerScriptsResponseProto() override;
  explicit PROTOBUF_CONSTEXPR GetTriggerScriptsResponseProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTriggerScriptsResponseProto(const GetTriggerScriptsResponseProto& from);
  GetTriggerScriptsResponseProto(GetTriggerScriptsResponseProto&& from) noexcept
    : GetTriggerScriptsResponseProto() {
    *this = ::std::move(from);
  }

  inline GetTriggerScriptsResponseProto& operator=(const GetTriggerScriptsResponseProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTriggerScriptsResponseProto& operator=(GetTriggerScriptsResponseProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetTriggerScriptsResponseProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTriggerScriptsResponseProto* internal_default_instance() {
    return reinterpret_cast<const GetTriggerScriptsResponseProto*>(
               &_GetTriggerScriptsResponseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetTriggerScriptsResponseProto& a, GetTriggerScriptsResponseProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetTriggerScriptsResponseProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTriggerScriptsResponseProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTriggerScriptsResponseProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTriggerScriptsResponseProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetTriggerScriptsResponseProto& from);
  void MergeFrom(const GetTriggerScriptsResponseProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTriggerScriptsResponseProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetTriggerScriptsResponseProto";
  }
  protected:
  explicit GetTriggerScriptsResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerScriptsFieldNumber = 1,
    kAdditionalAllowedDomainsFieldNumber = 2,
    kScriptParametersFieldNumber = 5,
    kTriggerConditionTimeoutMsFieldNumber = 3,
    kTriggerConditionCheckIntervalMsFieldNumber = 4,
  };
  // repeated .autofill_assistant.TriggerScriptProto trigger_scripts = 1;
  int trigger_scripts_size() const;
  private:
  int _internal_trigger_scripts_size() const;
  public:
  void clear_trigger_scripts();
  ::autofill_assistant::TriggerScriptProto* mutable_trigger_scripts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptProto >*
      mutable_trigger_scripts();
  private:
  const ::autofill_assistant::TriggerScriptProto& _internal_trigger_scripts(int index) const;
  ::autofill_assistant::TriggerScriptProto* _internal_add_trigger_scripts();
  public:
  const ::autofill_assistant::TriggerScriptProto& trigger_scripts(int index) const;
  ::autofill_assistant::TriggerScriptProto* add_trigger_scripts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptProto >&
      trigger_scripts() const;

  // repeated string additional_allowed_domains = 2;
  int additional_allowed_domains_size() const;
  private:
  int _internal_additional_allowed_domains_size() const;
  public:
  void clear_additional_allowed_domains();
  const std::string& additional_allowed_domains(int index) const;
  std::string* mutable_additional_allowed_domains(int index);
  void set_additional_allowed_domains(int index, const std::string& value);
  void set_additional_allowed_domains(int index, std::string&& value);
  void set_additional_allowed_domains(int index, const char* value);
  void set_additional_allowed_domains(int index, const char* value, size_t size);
  std::string* add_additional_allowed_domains();
  void add_additional_allowed_domains(const std::string& value);
  void add_additional_allowed_domains(std::string&& value);
  void add_additional_allowed_domains(const char* value);
  void add_additional_allowed_domains(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_allowed_domains() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_allowed_domains();
  private:
  const std::string& _internal_additional_allowed_domains(int index) const;
  std::string* _internal_add_additional_allowed_domains();
  public:

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 5;
  int script_parameters_size() const;
  private:
  int _internal_script_parameters_size() const;
  public:
  void clear_script_parameters();
  ::autofill_assistant::ScriptParameterProto* mutable_script_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
      mutable_script_parameters();
  private:
  const ::autofill_assistant::ScriptParameterProto& _internal_script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* _internal_add_script_parameters();
  public:
  const ::autofill_assistant::ScriptParameterProto& script_parameters(int index) const;
  ::autofill_assistant::ScriptParameterProto* add_script_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
      script_parameters() const;

  // optional int32 trigger_condition_timeout_ms = 3;
  bool has_trigger_condition_timeout_ms() const;
  private:
  bool _internal_has_trigger_condition_timeout_ms() const;
  public:
  void clear_trigger_condition_timeout_ms();
  int32_t trigger_condition_timeout_ms() const;
  void set_trigger_condition_timeout_ms(int32_t value);
  private:
  int32_t _internal_trigger_condition_timeout_ms() const;
  void _internal_set_trigger_condition_timeout_ms(int32_t value);
  public:

  // optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];
  bool has_trigger_condition_check_interval_ms() const;
  private:
  bool _internal_has_trigger_condition_check_interval_ms() const;
  public:
  void clear_trigger_condition_check_interval_ms();
  int32_t trigger_condition_check_interval_ms() const;
  void set_trigger_condition_check_interval_ms(int32_t value);
  private:
  int32_t _internal_trigger_condition_check_interval_ms() const;
  void _internal_set_trigger_condition_check_interval_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetTriggerScriptsResponseProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptProto > trigger_scripts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_allowed_domains_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto > script_parameters_;
  int32_t trigger_condition_timeout_ms_;
  int32_t trigger_condition_check_interval_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptProto) */ {
 public:
  inline TriggerScriptProto() : TriggerScriptProto(nullptr) {}
  ~TriggerScriptProto() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptProto(const TriggerScriptProto& from);
  TriggerScriptProto(TriggerScriptProto&& from) noexcept
    : TriggerScriptProto() {
    *this = ::std::move(from);
  }

  inline TriggerScriptProto& operator=(const TriggerScriptProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptProto& operator=(TriggerScriptProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptProto* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptProto*>(
               &_TriggerScriptProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(TriggerScriptProto& a, TriggerScriptProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptProto& from);
  void MergeFrom(const TriggerScriptProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptProto";
  }
  protected:
  explicit TriggerScriptProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TriggerScriptProto_TriggerScriptAction TriggerScriptAction;
  static constexpr TriggerScriptAction UNDEFINED =
    TriggerScriptProto_TriggerScriptAction_UNDEFINED;
  static constexpr TriggerScriptAction NOT_NOW =
    TriggerScriptProto_TriggerScriptAction_NOT_NOW;
  static constexpr TriggerScriptAction CANCEL_SESSION =
    TriggerScriptProto_TriggerScriptAction_CANCEL_SESSION;
  static constexpr TriggerScriptAction CANCEL_FOREVER =
    TriggerScriptProto_TriggerScriptAction_CANCEL_FOREVER;
  static constexpr TriggerScriptAction SHOW_CANCEL_POPUP =
    TriggerScriptProto_TriggerScriptAction_SHOW_CANCEL_POPUP;
  static constexpr TriggerScriptAction ACCEPT =
    TriggerScriptProto_TriggerScriptAction_ACCEPT;
  static inline bool TriggerScriptAction_IsValid(int value) {
    return TriggerScriptProto_TriggerScriptAction_IsValid(value);
  }
  static constexpr TriggerScriptAction TriggerScriptAction_MIN =
    TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_MIN;
  static constexpr TriggerScriptAction TriggerScriptAction_MAX =
    TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_MAX;
  static constexpr int TriggerScriptAction_ARRAYSIZE =
    TriggerScriptProto_TriggerScriptAction_TriggerScriptAction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TriggerScriptAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerScriptAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerScriptAction_Name.");
    return TriggerScriptProto_TriggerScriptAction_Name(enum_t_value);
  }
  static inline bool TriggerScriptAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TriggerScriptAction* value) {
    return TriggerScriptProto_TriggerScriptAction_Parse(name, value);
  }

  typedef TriggerScriptProto_TriggerUIType TriggerUIType;
  static constexpr TriggerUIType UNSPECIFIED_TRIGGER_UI_TYPE =
    TriggerScriptProto_TriggerUIType_UNSPECIFIED_TRIGGER_UI_TYPE;
  static constexpr TriggerUIType SHOPPING_CART_FIRST_TIME_USER =
    TriggerScriptProto_TriggerUIType_SHOPPING_CART_FIRST_TIME_USER;
  static constexpr TriggerUIType SHOPPING_CART_RETURNING_USER =
    TriggerScriptProto_TriggerUIType_SHOPPING_CART_RETURNING_USER;
  static constexpr TriggerUIType SHOPPING_CHECKOUT_FIRST_TIME_USER =
    TriggerScriptProto_TriggerUIType_SHOPPING_CHECKOUT_FIRST_TIME_USER;
  static constexpr TriggerUIType SHOPPING_CHECKOUT_RETURNING_USER =
    TriggerScriptProto_TriggerUIType_SHOPPING_CHECKOUT_RETURNING_USER;
  static constexpr TriggerUIType FOOD_ORDERING_CART_FIRST_TIME_USER =
    TriggerScriptProto_TriggerUIType_FOOD_ORDERING_CART_FIRST_TIME_USER;
  static constexpr TriggerUIType FOOD_ORDERING_CART_RETURNING_USER =
    TriggerScriptProto_TriggerUIType_FOOD_ORDERING_CART_RETURNING_USER;
  static constexpr TriggerUIType IN_CHROME_SHOPPING_CART_FIRST_TIME_USER =
    TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CART_FIRST_TIME_USER;
  static constexpr TriggerUIType IN_CHROME_SHOPPING_CART_RETURNING_USER =
    TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CART_RETURNING_USER;
  static constexpr TriggerUIType IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER =
    TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER;
  static constexpr TriggerUIType IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER =
    TriggerScriptProto_TriggerUIType_IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER;
  static constexpr TriggerUIType IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER =
    TriggerScriptProto_TriggerUIType_IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER;
  static constexpr TriggerUIType IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER =
    TriggerScriptProto_TriggerUIType_IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER;
  static inline bool TriggerUIType_IsValid(int value) {
    return TriggerScriptProto_TriggerUIType_IsValid(value);
  }
  static constexpr TriggerUIType TriggerUIType_MIN =
    TriggerScriptProto_TriggerUIType_TriggerUIType_MIN;
  static constexpr TriggerUIType TriggerUIType_MAX =
    TriggerScriptProto_TriggerUIType_TriggerUIType_MAX;
  static constexpr int TriggerUIType_ARRAYSIZE =
    TriggerScriptProto_TriggerUIType_TriggerUIType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TriggerUIType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerUIType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerUIType_Name.");
    return TriggerScriptProto_TriggerUIType_Name(enum_t_value);
  }
  static inline bool TriggerUIType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TriggerUIType* value) {
    return TriggerScriptProto_TriggerUIType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerConditionFieldNumber = 1,
    kUserInterfaceFieldNumber = 3,
    kTriggerUiTypeFieldNumber = 7,
    kOnSwipeToDismissFieldNumber = 4,
  };
  // optional .autofill_assistant.TriggerScriptConditionProto trigger_condition = 1;
  bool has_trigger_condition() const;
  private:
  bool _internal_has_trigger_condition() const;
  public:
  void clear_trigger_condition();
  const ::autofill_assistant::TriggerScriptConditionProto& trigger_condition() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptConditionProto* release_trigger_condition();
  ::autofill_assistant::TriggerScriptConditionProto* mutable_trigger_condition();
  void set_allocated_trigger_condition(::autofill_assistant::TriggerScriptConditionProto* trigger_condition);
  private:
  const ::autofill_assistant::TriggerScriptConditionProto& _internal_trigger_condition() const;
  ::autofill_assistant::TriggerScriptConditionProto* _internal_mutable_trigger_condition();
  public:
  void unsafe_arena_set_allocated_trigger_condition(
      ::autofill_assistant::TriggerScriptConditionProto* trigger_condition);
  ::autofill_assistant::TriggerScriptConditionProto* unsafe_arena_release_trigger_condition();

  // optional .autofill_assistant.TriggerScriptUIProto user_interface = 3;
  bool has_user_interface() const;
  private:
  bool _internal_has_user_interface() const;
  public:
  void clear_user_interface();
  const ::autofill_assistant::TriggerScriptUIProto& user_interface() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptUIProto* release_user_interface();
  ::autofill_assistant::TriggerScriptUIProto* mutable_user_interface();
  void set_allocated_user_interface(::autofill_assistant::TriggerScriptUIProto* user_interface);
  private:
  const ::autofill_assistant::TriggerScriptUIProto& _internal_user_interface() const;
  ::autofill_assistant::TriggerScriptUIProto* _internal_mutable_user_interface();
  public:
  void unsafe_arena_set_allocated_user_interface(
      ::autofill_assistant::TriggerScriptUIProto* user_interface);
  ::autofill_assistant::TriggerScriptUIProto* unsafe_arena_release_user_interface();

  // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 7;
  bool has_trigger_ui_type() const;
  private:
  bool _internal_has_trigger_ui_type() const;
  public:
  void clear_trigger_ui_type();
  ::autofill_assistant::TriggerScriptProto_TriggerUIType trigger_ui_type() const;
  void set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value);
  private:
  ::autofill_assistant::TriggerScriptProto_TriggerUIType _internal_trigger_ui_type() const;
  void _internal_set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value);
  public:

  // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction on_swipe_to_dismiss = 4 [default = CANCEL_SESSION];
  bool has_on_swipe_to_dismiss() const;
  private:
  bool _internal_has_on_swipe_to_dismiss() const;
  public:
  void clear_on_swipe_to_dismiss();
  ::autofill_assistant::TriggerScriptProto_TriggerScriptAction on_swipe_to_dismiss() const;
  void set_on_swipe_to_dismiss(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value);
  private:
  ::autofill_assistant::TriggerScriptProto_TriggerScriptAction _internal_on_swipe_to_dismiss() const;
  void _internal_set_on_swipe_to_dismiss(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::TriggerScriptConditionProto* trigger_condition_;
  ::autofill_assistant::TriggerScriptUIProto* user_interface_;
  int trigger_ui_type_;
  int on_swipe_to_dismiss_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptConditionProto_DocumentReadyStateCondition final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition) */ {
 public:
  inline TriggerScriptConditionProto_DocumentReadyStateCondition() : TriggerScriptConditionProto_DocumentReadyStateCondition(nullptr) {}
  ~TriggerScriptConditionProto_DocumentReadyStateCondition() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptConditionProto_DocumentReadyStateCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptConditionProto_DocumentReadyStateCondition(const TriggerScriptConditionProto_DocumentReadyStateCondition& from);
  TriggerScriptConditionProto_DocumentReadyStateCondition(TriggerScriptConditionProto_DocumentReadyStateCondition&& from) noexcept
    : TriggerScriptConditionProto_DocumentReadyStateCondition() {
    *this = ::std::move(from);
  }

  inline TriggerScriptConditionProto_DocumentReadyStateCondition& operator=(const TriggerScriptConditionProto_DocumentReadyStateCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptConditionProto_DocumentReadyStateCondition& operator=(TriggerScriptConditionProto_DocumentReadyStateCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptConditionProto_DocumentReadyStateCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptConditionProto_DocumentReadyStateCondition* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptConditionProto_DocumentReadyStateCondition*>(
               &_TriggerScriptConditionProto_DocumentReadyStateCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(TriggerScriptConditionProto_DocumentReadyStateCondition& a, TriggerScriptConditionProto_DocumentReadyStateCondition& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptConditionProto_DocumentReadyStateCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptConditionProto_DocumentReadyStateCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptConditionProto_DocumentReadyStateCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptConditionProto_DocumentReadyStateCondition>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptConditionProto_DocumentReadyStateCondition& from);
  void MergeFrom(const TriggerScriptConditionProto_DocumentReadyStateCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptConditionProto_DocumentReadyStateCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition";
  }
  protected:
  explicit TriggerScriptConditionProto_DocumentReadyStateCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 2,
    kMinDocumentReadyStateFieldNumber = 1,
  };
  // optional .autofill_assistant.SelectorProto frame = 2;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::autofill_assistant::SelectorProto& frame() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_frame();
  ::autofill_assistant::SelectorProto* mutable_frame();
  void set_allocated_frame(::autofill_assistant::SelectorProto* frame);
  private:
  const ::autofill_assistant::SelectorProto& _internal_frame() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::autofill_assistant::SelectorProto* frame);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_frame();

  // optional .autofill_assistant.DocumentReadyState min_document_ready_state = 1;
  bool has_min_document_ready_state() const;
  private:
  bool _internal_has_min_document_ready_state() const;
  public:
  void clear_min_document_ready_state();
  ::autofill_assistant::DocumentReadyState min_document_ready_state() const;
  void set_min_document_ready_state(::autofill_assistant::DocumentReadyState value);
  private:
  ::autofill_assistant::DocumentReadyState _internal_min_document_ready_state() const;
  void _internal_set_min_document_ready_state(::autofill_assistant::DocumentReadyState value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto* frame_;
  int min_document_ready_state_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptConditionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptConditionProto) */ {
 public:
  inline TriggerScriptConditionProto() : TriggerScriptConditionProto(nullptr) {}
  ~TriggerScriptConditionProto() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptConditionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptConditionProto(const TriggerScriptConditionProto& from);
  TriggerScriptConditionProto(TriggerScriptConditionProto&& from) noexcept
    : TriggerScriptConditionProto() {
    *this = ::std::move(from);
  }

  inline TriggerScriptConditionProto& operator=(const TriggerScriptConditionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptConditionProto& operator=(TriggerScriptConditionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptConditionProto& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kAllOf = 1,
    kAnyOf = 2,
    kNoneOf = 3,
    kSelector = 8,
    kStoredLoginCredentials = 5,
    kIsFirstTimeUser = 6,
    kExperimentId = 7,
    kKeyboardHidden = 9,
    kScriptParameterMatch = 10,
    kPathPattern = 11,
    kDomainWithScheme = 12,
    kDocumentReadyState = 13,
    TYPE_NOT_SET = 0,
  };

  static inline const TriggerScriptConditionProto* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptConditionProto*>(
               &_TriggerScriptConditionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(TriggerScriptConditionProto& a, TriggerScriptConditionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptConditionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptConditionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptConditionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptConditionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptConditionProto& from);
  void MergeFrom(const TriggerScriptConditionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptConditionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptConditionProto";
  }
  protected:
  explicit TriggerScriptConditionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TriggerScriptConditionProto_DocumentReadyStateCondition DocumentReadyStateCondition;

  // accessors -------------------------------------------------------

  enum : int {
    kAllOfFieldNumber = 1,
    kAnyOfFieldNumber = 2,
    kNoneOfFieldNumber = 3,
    kSelectorFieldNumber = 8,
    kStoredLoginCredentialsFieldNumber = 5,
    kIsFirstTimeUserFieldNumber = 6,
    kExperimentIdFieldNumber = 7,
    kKeyboardHiddenFieldNumber = 9,
    kScriptParameterMatchFieldNumber = 10,
    kPathPatternFieldNumber = 11,
    kDomainWithSchemeFieldNumber = 12,
    kDocumentReadyStateFieldNumber = 13,
  };
  // .autofill_assistant.TriggerScriptConditionsProto all_of = 1;
  bool has_all_of() const;
  private:
  bool _internal_has_all_of() const;
  public:
  void clear_all_of();
  const ::autofill_assistant::TriggerScriptConditionsProto& all_of() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptConditionsProto* release_all_of();
  ::autofill_assistant::TriggerScriptConditionsProto* mutable_all_of();
  void set_allocated_all_of(::autofill_assistant::TriggerScriptConditionsProto* all_of);
  private:
  const ::autofill_assistant::TriggerScriptConditionsProto& _internal_all_of() const;
  ::autofill_assistant::TriggerScriptConditionsProto* _internal_mutable_all_of();
  public:
  void unsafe_arena_set_allocated_all_of(
      ::autofill_assistant::TriggerScriptConditionsProto* all_of);
  ::autofill_assistant::TriggerScriptConditionsProto* unsafe_arena_release_all_of();

  // .autofill_assistant.TriggerScriptConditionsProto any_of = 2;
  bool has_any_of() const;
  private:
  bool _internal_has_any_of() const;
  public:
  void clear_any_of();
  const ::autofill_assistant::TriggerScriptConditionsProto& any_of() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptConditionsProto* release_any_of();
  ::autofill_assistant::TriggerScriptConditionsProto* mutable_any_of();
  void set_allocated_any_of(::autofill_assistant::TriggerScriptConditionsProto* any_of);
  private:
  const ::autofill_assistant::TriggerScriptConditionsProto& _internal_any_of() const;
  ::autofill_assistant::TriggerScriptConditionsProto* _internal_mutable_any_of();
  public:
  void unsafe_arena_set_allocated_any_of(
      ::autofill_assistant::TriggerScriptConditionsProto* any_of);
  ::autofill_assistant::TriggerScriptConditionsProto* unsafe_arena_release_any_of();

  // .autofill_assistant.TriggerScriptConditionsProto none_of = 3;
  bool has_none_of() const;
  private:
  bool _internal_has_none_of() const;
  public:
  void clear_none_of();
  const ::autofill_assistant::TriggerScriptConditionsProto& none_of() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptConditionsProto* release_none_of();
  ::autofill_assistant::TriggerScriptConditionsProto* mutable_none_of();
  void set_allocated_none_of(::autofill_assistant::TriggerScriptConditionsProto* none_of);
  private:
  const ::autofill_assistant::TriggerScriptConditionsProto& _internal_none_of() const;
  ::autofill_assistant::TriggerScriptConditionsProto* _internal_mutable_none_of();
  public:
  void unsafe_arena_set_allocated_none_of(
      ::autofill_assistant::TriggerScriptConditionsProto* none_of);
  ::autofill_assistant::TriggerScriptConditionsProto* unsafe_arena_release_none_of();

  // .autofill_assistant.SelectorProto selector = 8;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::autofill_assistant::SelectorProto& selector() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_selector();
  ::autofill_assistant::SelectorProto* mutable_selector();
  void set_allocated_selector(::autofill_assistant::SelectorProto* selector);
  private:
  const ::autofill_assistant::SelectorProto& _internal_selector() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::autofill_assistant::SelectorProto* selector);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_selector();

  // .autofill_assistant.Empty stored_login_credentials = 5;
  bool has_stored_login_credentials() const;
  private:
  bool _internal_has_stored_login_credentials() const;
  public:
  void clear_stored_login_credentials();
  const ::autofill_assistant::Empty& stored_login_credentials() const;
  PROTOBUF_NODISCARD ::autofill_assistant::Empty* release_stored_login_credentials();
  ::autofill_assistant::Empty* mutable_stored_login_credentials();
  void set_allocated_stored_login_credentials(::autofill_assistant::Empty* stored_login_credentials);
  private:
  const ::autofill_assistant::Empty& _internal_stored_login_credentials() const;
  ::autofill_assistant::Empty* _internal_mutable_stored_login_credentials();
  public:
  void unsafe_arena_set_allocated_stored_login_credentials(
      ::autofill_assistant::Empty* stored_login_credentials);
  ::autofill_assistant::Empty* unsafe_arena_release_stored_login_credentials();

  // .autofill_assistant.Empty is_first_time_user = 6;
  bool has_is_first_time_user() const;
  private:
  bool _internal_has_is_first_time_user() const;
  public:
  void clear_is_first_time_user();
  const ::autofill_assistant::Empty& is_first_time_user() const;
  PROTOBUF_NODISCARD ::autofill_assistant::Empty* release_is_first_time_user();
  ::autofill_assistant::Empty* mutable_is_first_time_user();
  void set_allocated_is_first_time_user(::autofill_assistant::Empty* is_first_time_user);
  private:
  const ::autofill_assistant::Empty& _internal_is_first_time_user() const;
  ::autofill_assistant::Empty* _internal_mutable_is_first_time_user();
  public:
  void unsafe_arena_set_allocated_is_first_time_user(
      ::autofill_assistant::Empty* is_first_time_user);
  ::autofill_assistant::Empty* unsafe_arena_release_is_first_time_user();

  // int32 experiment_id = 7;
  bool has_experiment_id() const;
  private:
  bool _internal_has_experiment_id() const;
  public:
  void clear_experiment_id();
  int32_t experiment_id() const;
  void set_experiment_id(int32_t value);
  private:
  int32_t _internal_experiment_id() const;
  void _internal_set_experiment_id(int32_t value);
  public:

  // .autofill_assistant.Empty keyboard_hidden = 9;
  bool has_keyboard_hidden() const;
  private:
  bool _internal_has_keyboard_hidden() const;
  public:
  void clear_keyboard_hidden();
  const ::autofill_assistant::Empty& keyboard_hidden() const;
  PROTOBUF_NODISCARD ::autofill_assistant::Empty* release_keyboard_hidden();
  ::autofill_assistant::Empty* mutable_keyboard_hidden();
  void set_allocated_keyboard_hidden(::autofill_assistant::Empty* keyboard_hidden);
  private:
  const ::autofill_assistant::Empty& _internal_keyboard_hidden() const;
  ::autofill_assistant::Empty* _internal_mutable_keyboard_hidden();
  public:
  void unsafe_arena_set_allocated_keyboard_hidden(
      ::autofill_assistant::Empty* keyboard_hidden);
  ::autofill_assistant::Empty* unsafe_arena_release_keyboard_hidden();

  // .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 10;
  bool has_script_parameter_match() const;
  private:
  bool _internal_has_script_parameter_match() const;
  public:
  void clear_script_parameter_match();
  const ::autofill_assistant::ScriptParameterMatchProto& script_parameter_match() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScriptParameterMatchProto* release_script_parameter_match();
  ::autofill_assistant::ScriptParameterMatchProto* mutable_script_parameter_match();
  void set_allocated_script_parameter_match(::autofill_assistant::ScriptParameterMatchProto* script_parameter_match);
  private:
  const ::autofill_assistant::ScriptParameterMatchProto& _internal_script_parameter_match() const;
  ::autofill_assistant::ScriptParameterMatchProto* _internal_mutable_script_parameter_match();
  public:
  void unsafe_arena_set_allocated_script_parameter_match(
      ::autofill_assistant::ScriptParameterMatchProto* script_parameter_match);
  ::autofill_assistant::ScriptParameterMatchProto* unsafe_arena_release_script_parameter_match();

  // string path_pattern = 11;
  bool has_path_pattern() const;
  private:
  bool _internal_has_path_pattern() const;
  public:
  void clear_path_pattern();
  const std::string& path_pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path_pattern();
  PROTOBUF_NODISCARD std::string* release_path_pattern();
  void set_allocated_path_pattern(std::string* path_pattern);
  private:
  const std::string& _internal_path_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_pattern(const std::string& value);
  std::string* _internal_mutable_path_pattern();
  public:

  // string domain_with_scheme = 12;
  bool has_domain_with_scheme() const;
  private:
  bool _internal_has_domain_with_scheme() const;
  public:
  void clear_domain_with_scheme();
  const std::string& domain_with_scheme() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain_with_scheme(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain_with_scheme();
  PROTOBUF_NODISCARD std::string* release_domain_with_scheme();
  void set_allocated_domain_with_scheme(std::string* domain_with_scheme);
  private:
  const std::string& _internal_domain_with_scheme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain_with_scheme(const std::string& value);
  std::string* _internal_mutable_domain_with_scheme();
  public:

  // .autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition document_ready_state = 13;
  bool has_document_ready_state() const;
  private:
  bool _internal_has_document_ready_state() const;
  public:
  void clear_document_ready_state();
  const ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition& document_ready_state() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* release_document_ready_state();
  ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* mutable_document_ready_state();
  void set_allocated_document_ready_state(::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* document_ready_state);
  private:
  const ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition& _internal_document_ready_state() const;
  ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* _internal_mutable_document_ready_state();
  public:
  void unsafe_arena_set_allocated_document_ready_state(
      ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* document_ready_state);
  ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* unsafe_arena_release_document_ready_state();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptConditionProto)
 private:
  class _Internal;
  void set_has_all_of();
  void set_has_any_of();
  void set_has_none_of();
  void set_has_selector();
  void set_has_stored_login_credentials();
  void set_has_is_first_time_user();
  void set_has_experiment_id();
  void set_has_keyboard_hidden();
  void set_has_script_parameter_match();
  void set_has_path_pattern();
  void set_has_domain_with_scheme();
  void set_has_document_ready_state();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::TriggerScriptConditionsProto* all_of_;
    ::autofill_assistant::TriggerScriptConditionsProto* any_of_;
    ::autofill_assistant::TriggerScriptConditionsProto* none_of_;
    ::autofill_assistant::SelectorProto* selector_;
    ::autofill_assistant::Empty* stored_login_credentials_;
    ::autofill_assistant::Empty* is_first_time_user_;
    int32_t experiment_id_;
    ::autofill_assistant::Empty* keyboard_hidden_;
    ::autofill_assistant::ScriptParameterMatchProto* script_parameter_match_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_pattern_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_with_scheme_;
    ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* document_ready_state_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptConditionsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptConditionsProto) */ {
 public:
  inline TriggerScriptConditionsProto() : TriggerScriptConditionsProto(nullptr) {}
  ~TriggerScriptConditionsProto() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptConditionsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptConditionsProto(const TriggerScriptConditionsProto& from);
  TriggerScriptConditionsProto(TriggerScriptConditionsProto&& from) noexcept
    : TriggerScriptConditionsProto() {
    *this = ::std::move(from);
  }

  inline TriggerScriptConditionsProto& operator=(const TriggerScriptConditionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptConditionsProto& operator=(TriggerScriptConditionsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptConditionsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptConditionsProto* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptConditionsProto*>(
               &_TriggerScriptConditionsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(TriggerScriptConditionsProto& a, TriggerScriptConditionsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptConditionsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptConditionsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptConditionsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptConditionsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptConditionsProto& from);
  void MergeFrom(const TriggerScriptConditionsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptConditionsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptConditionsProto";
  }
  protected:
  explicit TriggerScriptConditionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
  };
  // repeated .autofill_assistant.TriggerScriptConditionProto conditions = 1;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::autofill_assistant::TriggerScriptConditionProto* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptConditionProto >*
      mutable_conditions();
  private:
  const ::autofill_assistant::TriggerScriptConditionProto& _internal_conditions(int index) const;
  ::autofill_assistant::TriggerScriptConditionProto* _internal_add_conditions();
  public:
  const ::autofill_assistant::TriggerScriptConditionProto& conditions(int index) const;
  ::autofill_assistant::TriggerScriptConditionProto* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptConditionProto >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptConditionsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptConditionProto > conditions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptUIProto_ProgressBar final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptUIProto.ProgressBar) */ {
 public:
  inline TriggerScriptUIProto_ProgressBar() : TriggerScriptUIProto_ProgressBar(nullptr) {}
  ~TriggerScriptUIProto_ProgressBar() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptUIProto_ProgressBar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptUIProto_ProgressBar(const TriggerScriptUIProto_ProgressBar& from);
  TriggerScriptUIProto_ProgressBar(TriggerScriptUIProto_ProgressBar&& from) noexcept
    : TriggerScriptUIProto_ProgressBar() {
    *this = ::std::move(from);
  }

  inline TriggerScriptUIProto_ProgressBar& operator=(const TriggerScriptUIProto_ProgressBar& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptUIProto_ProgressBar& operator=(TriggerScriptUIProto_ProgressBar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptUIProto_ProgressBar& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptUIProto_ProgressBar* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptUIProto_ProgressBar*>(
               &_TriggerScriptUIProto_ProgressBar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(TriggerScriptUIProto_ProgressBar& a, TriggerScriptUIProto_ProgressBar& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptUIProto_ProgressBar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptUIProto_ProgressBar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptUIProto_ProgressBar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptUIProto_ProgressBar>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptUIProto_ProgressBar& from);
  void MergeFrom(const TriggerScriptUIProto_ProgressBar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptUIProto_ProgressBar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptUIProto.ProgressBar";
  }
  protected:
  explicit TriggerScriptUIProto_ProgressBar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepIconsFieldNumber = 1,
    kActiveStepFieldNumber = 2,
  };
  // repeated .autofill_assistant.DrawableProto step_icons = 1;
  int step_icons_size() const;
  private:
  int _internal_step_icons_size() const;
  public:
  void clear_step_icons();
  ::autofill_assistant::DrawableProto* mutable_step_icons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DrawableProto >*
      mutable_step_icons();
  private:
  const ::autofill_assistant::DrawableProto& _internal_step_icons(int index) const;
  ::autofill_assistant::DrawableProto* _internal_add_step_icons();
  public:
  const ::autofill_assistant::DrawableProto& step_icons(int index) const;
  ::autofill_assistant::DrawableProto* add_step_icons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DrawableProto >&
      step_icons() const;

  // optional int32 active_step = 2;
  bool has_active_step() const;
  private:
  bool _internal_has_active_step() const;
  public:
  void clear_active_step();
  int32_t active_step() const;
  void set_active_step(int32_t value);
  private:
  int32_t _internal_active_step() const;
  void _internal_set_active_step(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptUIProto.ProgressBar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DrawableProto > step_icons_;
  int32_t active_step_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptUIProto_TriggerChip final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptUIProto.TriggerChip) */ {
 public:
  inline TriggerScriptUIProto_TriggerChip() : TriggerScriptUIProto_TriggerChip(nullptr) {}
  ~TriggerScriptUIProto_TriggerChip() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptUIProto_TriggerChip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptUIProto_TriggerChip(const TriggerScriptUIProto_TriggerChip& from);
  TriggerScriptUIProto_TriggerChip(TriggerScriptUIProto_TriggerChip&& from) noexcept
    : TriggerScriptUIProto_TriggerChip() {
    *this = ::std::move(from);
  }

  inline TriggerScriptUIProto_TriggerChip& operator=(const TriggerScriptUIProto_TriggerChip& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptUIProto_TriggerChip& operator=(TriggerScriptUIProto_TriggerChip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptUIProto_TriggerChip& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptUIProto_TriggerChip* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptUIProto_TriggerChip*>(
               &_TriggerScriptUIProto_TriggerChip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(TriggerScriptUIProto_TriggerChip& a, TriggerScriptUIProto_TriggerChip& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptUIProto_TriggerChip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptUIProto_TriggerChip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptUIProto_TriggerChip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptUIProto_TriggerChip>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptUIProto_TriggerChip& from);
  void MergeFrom(const TriggerScriptUIProto_TriggerChip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptUIProto_TriggerChip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptUIProto.TriggerChip";
  }
  protected:
  explicit TriggerScriptUIProto_TriggerChip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChipFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // optional .autofill_assistant.ChipProto chip = 1;
  bool has_chip() const;
  private:
  bool _internal_has_chip() const;
  public:
  void clear_chip();
  const ::autofill_assistant::ChipProto& chip() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ChipProto* release_chip();
  ::autofill_assistant::ChipProto* mutable_chip();
  void set_allocated_chip(::autofill_assistant::ChipProto* chip);
  private:
  const ::autofill_assistant::ChipProto& _internal_chip() const;
  ::autofill_assistant::ChipProto* _internal_mutable_chip();
  public:
  void unsafe_arena_set_allocated_chip(
      ::autofill_assistant::ChipProto* chip);
  ::autofill_assistant::ChipProto* unsafe_arena_release_chip();

  // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::autofill_assistant::TriggerScriptProto_TriggerScriptAction action() const;
  void set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value);
  private:
  ::autofill_assistant::TriggerScriptProto_TriggerScriptAction _internal_action() const;
  void _internal_set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptUIProto.TriggerChip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ChipProto* chip_;
  int action_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptUIProto_Popup_Choice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptUIProto.Popup.Choice) */ {
 public:
  inline TriggerScriptUIProto_Popup_Choice() : TriggerScriptUIProto_Popup_Choice(nullptr) {}
  ~TriggerScriptUIProto_Popup_Choice() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptUIProto_Popup_Choice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptUIProto_Popup_Choice(const TriggerScriptUIProto_Popup_Choice& from);
  TriggerScriptUIProto_Popup_Choice(TriggerScriptUIProto_Popup_Choice&& from) noexcept
    : TriggerScriptUIProto_Popup_Choice() {
    *this = ::std::move(from);
  }

  inline TriggerScriptUIProto_Popup_Choice& operator=(const TriggerScriptUIProto_Popup_Choice& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptUIProto_Popup_Choice& operator=(TriggerScriptUIProto_Popup_Choice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptUIProto_Popup_Choice& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptUIProto_Popup_Choice* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptUIProto_Popup_Choice*>(
               &_TriggerScriptUIProto_Popup_Choice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TriggerScriptUIProto_Popup_Choice& a, TriggerScriptUIProto_Popup_Choice& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptUIProto_Popup_Choice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptUIProto_Popup_Choice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptUIProto_Popup_Choice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptUIProto_Popup_Choice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptUIProto_Popup_Choice& from);
  void MergeFrom(const TriggerScriptUIProto_Popup_Choice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptUIProto_Popup_Choice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptUIProto.Popup.Choice";
  }
  protected:
  explicit TriggerScriptUIProto_Popup_Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::autofill_assistant::TriggerScriptProto_TriggerScriptAction action() const;
  void set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value);
  private:
  ::autofill_assistant::TriggerScriptProto_TriggerScriptAction _internal_action() const;
  void _internal_set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int action_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptUIProto_Popup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptUIProto.Popup) */ {
 public:
  inline TriggerScriptUIProto_Popup() : TriggerScriptUIProto_Popup(nullptr) {}
  ~TriggerScriptUIProto_Popup() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptUIProto_Popup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptUIProto_Popup(const TriggerScriptUIProto_Popup& from);
  TriggerScriptUIProto_Popup(TriggerScriptUIProto_Popup&& from) noexcept
    : TriggerScriptUIProto_Popup() {
    *this = ::std::move(from);
  }

  inline TriggerScriptUIProto_Popup& operator=(const TriggerScriptUIProto_Popup& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptUIProto_Popup& operator=(TriggerScriptUIProto_Popup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptUIProto_Popup& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptUIProto_Popup* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptUIProto_Popup*>(
               &_TriggerScriptUIProto_Popup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(TriggerScriptUIProto_Popup& a, TriggerScriptUIProto_Popup& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptUIProto_Popup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptUIProto_Popup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptUIProto_Popup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptUIProto_Popup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptUIProto_Popup& from);
  void MergeFrom(const TriggerScriptUIProto_Popup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptUIProto_Popup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptUIProto.Popup";
  }
  protected:
  explicit TriggerScriptUIProto_Popup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TriggerScriptUIProto_Popup_Choice Choice;

  // accessors -------------------------------------------------------

  enum : int {
    kChoicesFieldNumber = 1,
  };
  // repeated .autofill_assistant.TriggerScriptUIProto.Popup.Choice choices = 1;
  int choices_size() const;
  private:
  int _internal_choices_size() const;
  public:
  void clear_choices();
  ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* mutable_choices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice >*
      mutable_choices();
  private:
  const ::autofill_assistant::TriggerScriptUIProto_Popup_Choice& _internal_choices(int index) const;
  ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* _internal_add_choices();
  public:
  const ::autofill_assistant::TriggerScriptUIProto_Popup_Choice& choices(int index) const;
  ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* add_choices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice >&
      choices() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptUIProto.Popup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice > choices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TriggerScriptUIProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TriggerScriptUIProto) */ {
 public:
  inline TriggerScriptUIProto() : TriggerScriptUIProto(nullptr) {}
  ~TriggerScriptUIProto() override;
  explicit PROTOBUF_CONSTEXPR TriggerScriptUIProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriggerScriptUIProto(const TriggerScriptUIProto& from);
  TriggerScriptUIProto(TriggerScriptUIProto&& from) noexcept
    : TriggerScriptUIProto() {
    *this = ::std::move(from);
  }

  inline TriggerScriptUIProto& operator=(const TriggerScriptUIProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriggerScriptUIProto& operator=(TriggerScriptUIProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TriggerScriptUIProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriggerScriptUIProto* internal_default_instance() {
    return reinterpret_cast<const TriggerScriptUIProto*>(
               &_TriggerScriptUIProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(TriggerScriptUIProto& a, TriggerScriptUIProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TriggerScriptUIProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriggerScriptUIProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriggerScriptUIProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriggerScriptUIProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TriggerScriptUIProto& from);
  void MergeFrom(const TriggerScriptUIProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TriggerScriptUIProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TriggerScriptUIProto";
  }
  protected:
  explicit TriggerScriptUIProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TriggerScriptUIProto_ProgressBar ProgressBar;
  typedef TriggerScriptUIProto_TriggerChip TriggerChip;
  typedef TriggerScriptUIProto_Popup Popup;

  // accessors -------------------------------------------------------

  enum : int {
    kLeftAlignedChipsFieldNumber = 5,
    kRightAlignedChipsFieldNumber = 6,
    kStatusMessageFieldNumber = 1,
    kCalloutMessageFieldNumber = 2,
    kRegularScriptLoadingStatusMessageFieldNumber = 7,
    kProgressBarFieldNumber = 3,
    kCancelPopupFieldNumber = 4,
    kResizeVisualViewportFieldNumber = 8,
    kScrollToHideFieldNumber = 9,
    kUiTimeoutMsFieldNumber = 10,
  };
  // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip left_aligned_chips = 5;
  int left_aligned_chips_size() const;
  private:
  int _internal_left_aligned_chips_size() const;
  public:
  void clear_left_aligned_chips();
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* mutable_left_aligned_chips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >*
      mutable_left_aligned_chips();
  private:
  const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& _internal_left_aligned_chips(int index) const;
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* _internal_add_left_aligned_chips();
  public:
  const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& left_aligned_chips(int index) const;
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* add_left_aligned_chips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >&
      left_aligned_chips() const;

  // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip right_aligned_chips = 6;
  int right_aligned_chips_size() const;
  private:
  int _internal_right_aligned_chips_size() const;
  public:
  void clear_right_aligned_chips();
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* mutable_right_aligned_chips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >*
      mutable_right_aligned_chips();
  private:
  const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& _internal_right_aligned_chips(int index) const;
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* _internal_add_right_aligned_chips();
  public:
  const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& right_aligned_chips(int index) const;
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* add_right_aligned_chips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >&
      right_aligned_chips() const;

  // optional string status_message = 1;
  bool has_status_message() const;
  private:
  bool _internal_has_status_message() const;
  public:
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // optional string callout_message = 2;
  bool has_callout_message() const;
  private:
  bool _internal_has_callout_message() const;
  public:
  void clear_callout_message();
  const std::string& callout_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callout_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callout_message();
  PROTOBUF_NODISCARD std::string* release_callout_message();
  void set_allocated_callout_message(std::string* callout_message);
  private:
  const std::string& _internal_callout_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callout_message(const std::string& value);
  std::string* _internal_mutable_callout_message();
  public:

  // optional string regular_script_loading_status_message = 7;
  bool has_regular_script_loading_status_message() const;
  private:
  bool _internal_has_regular_script_loading_status_message() const;
  public:
  void clear_regular_script_loading_status_message();
  const std::string& regular_script_loading_status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regular_script_loading_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regular_script_loading_status_message();
  PROTOBUF_NODISCARD std::string* release_regular_script_loading_status_message();
  void set_allocated_regular_script_loading_status_message(std::string* regular_script_loading_status_message);
  private:
  const std::string& _internal_regular_script_loading_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regular_script_loading_status_message(const std::string& value);
  std::string* _internal_mutable_regular_script_loading_status_message();
  public:

  // optional .autofill_assistant.TriggerScriptUIProto.ProgressBar progress_bar = 3;
  bool has_progress_bar() const;
  private:
  bool _internal_has_progress_bar() const;
  public:
  void clear_progress_bar();
  const ::autofill_assistant::TriggerScriptUIProto_ProgressBar& progress_bar() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptUIProto_ProgressBar* release_progress_bar();
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* mutable_progress_bar();
  void set_allocated_progress_bar(::autofill_assistant::TriggerScriptUIProto_ProgressBar* progress_bar);
  private:
  const ::autofill_assistant::TriggerScriptUIProto_ProgressBar& _internal_progress_bar() const;
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* _internal_mutable_progress_bar();
  public:
  void unsafe_arena_set_allocated_progress_bar(
      ::autofill_assistant::TriggerScriptUIProto_ProgressBar* progress_bar);
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* unsafe_arena_release_progress_bar();

  // optional .autofill_assistant.TriggerScriptUIProto.Popup cancel_popup = 4;
  bool has_cancel_popup() const;
  private:
  bool _internal_has_cancel_popup() const;
  public:
  void clear_cancel_popup();
  const ::autofill_assistant::TriggerScriptUIProto_Popup& cancel_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TriggerScriptUIProto_Popup* release_cancel_popup();
  ::autofill_assistant::TriggerScriptUIProto_Popup* mutable_cancel_popup();
  void set_allocated_cancel_popup(::autofill_assistant::TriggerScriptUIProto_Popup* cancel_popup);
  private:
  const ::autofill_assistant::TriggerScriptUIProto_Popup& _internal_cancel_popup() const;
  ::autofill_assistant::TriggerScriptUIProto_Popup* _internal_mutable_cancel_popup();
  public:
  void unsafe_arena_set_allocated_cancel_popup(
      ::autofill_assistant::TriggerScriptUIProto_Popup* cancel_popup);
  ::autofill_assistant::TriggerScriptUIProto_Popup* unsafe_arena_release_cancel_popup();

  // optional bool resize_visual_viewport = 8;
  bool has_resize_visual_viewport() const;
  private:
  bool _internal_has_resize_visual_viewport() const;
  public:
  void clear_resize_visual_viewport();
  bool resize_visual_viewport() const;
  void set_resize_visual_viewport(bool value);
  private:
  bool _internal_resize_visual_viewport() const;
  void _internal_set_resize_visual_viewport(bool value);
  public:

  // optional bool scroll_to_hide = 9;
  bool has_scroll_to_hide() const;
  private:
  bool _internal_has_scroll_to_hide() const;
  public:
  void clear_scroll_to_hide();
  bool scroll_to_hide() const;
  void set_scroll_to_hide(bool value);
  private:
  bool _internal_scroll_to_hide() const;
  void _internal_set_scroll_to_hide(bool value);
  public:

  // optional int32 ui_timeout_ms = 10;
  bool has_ui_timeout_ms() const;
  private:
  bool _internal_has_ui_timeout_ms() const;
  public:
  void clear_ui_timeout_ms();
  int32_t ui_timeout_ms() const;
  void set_ui_timeout_ms(int32_t value);
  private:
  int32_t _internal_ui_timeout_ms() const;
  void _internal_set_ui_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TriggerScriptUIProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip > left_aligned_chips_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip > right_aligned_chips_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callout_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regular_script_loading_status_message_;
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* progress_bar_;
  ::autofill_assistant::TriggerScriptUIProto_Popup* cancel_popup_;
  bool resize_visual_viewport_;
  bool scroll_to_hide_;
  int32_t ui_timeout_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ActionProto) */ {
 public:
  inline ActionProto() : ActionProto(nullptr) {}
  ~ActionProto() override;
  explicit PROTOBUF_CONSTEXPR ActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionProto(const ActionProto& from);
  ActionProto(ActionProto&& from) noexcept
    : ActionProto() {
    *this = ::std::move(from);
  }

  inline ActionProto& operator=(const ActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionProto& operator=(ActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActionProto& default_instance() {
    return *internal_default_instance();
  }
  enum ActionInfoCase {
    kSelectOption = 7,
    kNavigate = 9,
    kPrompt = 10,
    kTell = 11,
    kShowCast = 12,
    kWaitForDom = 19,
    kUseCard = 28,
    kUseAddress = 29,
    kUploadDom = 18,
    kShowProgressBar = 24,
    kShowDetails = 32,
    kStop = 35,
    kCollectUserData = 36,
    kSetAttribute = 37,
    kShowInfoBox = 39,
    kExpectNavigation = 40,
    kWaitForNavigation = 41,
    kConfigureBottomSheet = 42,
    kShowForm = 43,
    kPopupMessage = 44,
    kWaitForDocument = 45,
    kShowGenericUi = 49,
    kGeneratePasswordForFormField = 52,
    kSaveGeneratedPassword = 53,
    kConfigureUiState = 54,
    kPresaveGeneratedPassword = 55,
    kGetElementStatus = 56,
    kScrollIntoView = 57,
    kWaitForDocumentToBecomeInteractive = 58,
    kWaitForDocumentToBecomeComplete = 59,
    kSendClickEvent = 60,
    kSendTapEvent = 61,
    kJsClick = 62,
    kSendKeystrokeEvents = 63,
    kSendChangeEvent = 64,
    kSetElementAttribute = 65,
    kSelectFieldValue = 66,
    kFocusField = 67,
    kWaitForElementToBecomeStable = 68,
    kCheckElementIsOnTop = 69,
    kReleaseElements = 70,
    kDispatchJsEvent = 72,
    kSendKeyEvent = 73,
    kSelectOptionElement = 74,
    kCheckElementTag = 75,
    kCheckOptionElement = 76,
    kSetPersistentUi = 77,
    kClearPersistentUi = 78,
    kScrollIntoViewIfNeeded = 79,
    kScrollWindow = 80,
    kScrollContainer = 81,
    kSetTouchableArea = 82,
    kDeletePassword = 83,
    kEditPassword = 84,
    kBlurField = 85,
    kResetPendingCredentials = 86,
    kSaveSubmittedPassword = 87,
    kUpdateClientSettings = 89,
    kJsFlow = 92,
    kExecuteJs = 93,
    kRegisterPasswordResetRequest = 94,
    kExternalAction = 95,
    kSetNativeValue = 96,
    kSetNativeChecked = 97,
    kPromptQrCodeScan = 98,
    ACTION_INFO_NOT_SET = 0,
  };

  static inline const ActionProto* internal_default_instance() {
    return reinterpret_cast<const ActionProto*>(
               &_ActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ActionProto& a, ActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActionProto& from);
  void MergeFrom(const ActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ActionProto";
  }
  protected:
  explicit ActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerPayloadFieldNumber = 4,
    kActionDelayMsFieldNumber = 3,
    kCleanContextualUiFieldNumber = 33,
    kSelectOptionFieldNumber = 7,
    kNavigateFieldNumber = 9,
    kPromptFieldNumber = 10,
    kTellFieldNumber = 11,
    kShowCastFieldNumber = 12,
    kWaitForDomFieldNumber = 19,
    kUseCardFieldNumber = 28,
    kUseAddressFieldNumber = 29,
    kUploadDomFieldNumber = 18,
    kShowProgressBarFieldNumber = 24,
    kShowDetailsFieldNumber = 32,
    kStopFieldNumber = 35,
    kCollectUserDataFieldNumber = 36,
    kSetAttributeFieldNumber = 37,
    kShowInfoBoxFieldNumber = 39,
    kExpectNavigationFieldNumber = 40,
    kWaitForNavigationFieldNumber = 41,
    kConfigureBottomSheetFieldNumber = 42,
    kShowFormFieldNumber = 43,
    kPopupMessageFieldNumber = 44,
    kWaitForDocumentFieldNumber = 45,
    kShowGenericUiFieldNumber = 49,
    kGeneratePasswordForFormFieldFieldNumber = 52,
    kSaveGeneratedPasswordFieldNumber = 53,
    kConfigureUiStateFieldNumber = 54,
    kPresaveGeneratedPasswordFieldNumber = 55,
    kGetElementStatusFieldNumber = 56,
    kScrollIntoViewFieldNumber = 57,
    kWaitForDocumentToBecomeInteractiveFieldNumber = 58,
    kWaitForDocumentToBecomeCompleteFieldNumber = 59,
    kSendClickEventFieldNumber = 60,
    kSendTapEventFieldNumber = 61,
    kJsClickFieldNumber = 62,
    kSendKeystrokeEventsFieldNumber = 63,
    kSendChangeEventFieldNumber = 64,
    kSetElementAttributeFieldNumber = 65,
    kSelectFieldValueFieldNumber = 66,
    kFocusFieldFieldNumber = 67,
    kWaitForElementToBecomeStableFieldNumber = 68,
    kCheckElementIsOnTopFieldNumber = 69,
    kReleaseElementsFieldNumber = 70,
    kDispatchJsEventFieldNumber = 72,
    kSendKeyEventFieldNumber = 73,
    kSelectOptionElementFieldNumber = 74,
    kCheckElementTagFieldNumber = 75,
    kCheckOptionElementFieldNumber = 76,
    kSetPersistentUiFieldNumber = 77,
    kClearPersistentUiFieldNumber = 78,
    kScrollIntoViewIfNeededFieldNumber = 79,
    kScrollWindowFieldNumber = 80,
    kScrollContainerFieldNumber = 81,
    kSetTouchableAreaFieldNumber = 82,
    kDeletePasswordFieldNumber = 83,
    kEditPasswordFieldNumber = 84,
    kBlurFieldFieldNumber = 85,
    kResetPendingCredentialsFieldNumber = 86,
    kSaveSubmittedPasswordFieldNumber = 87,
    kUpdateClientSettingsFieldNumber = 89,
    kJsFlowFieldNumber = 92,
    kExecuteJsFieldNumber = 93,
    kRegisterPasswordResetRequestFieldNumber = 94,
    kExternalActionFieldNumber = 95,
    kSetNativeValueFieldNumber = 96,
    kSetNativeCheckedFieldNumber = 97,
    kPromptQrCodeScanFieldNumber = 98,
  };
  // optional bytes server_payload = 4;
  bool has_server_payload() const;
  private:
  bool _internal_has_server_payload() const;
  public:
  void clear_server_payload();
  const std::string& server_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_payload();
  PROTOBUF_NODISCARD std::string* release_server_payload();
  void set_allocated_server_payload(std::string* server_payload);
  private:
  const std::string& _internal_server_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_payload(const std::string& value);
  std::string* _internal_mutable_server_payload();
  public:

  // optional int32 action_delay_ms = 3;
  bool has_action_delay_ms() const;
  private:
  bool _internal_has_action_delay_ms() const;
  public:
  void clear_action_delay_ms();
  int32_t action_delay_ms() const;
  void set_action_delay_ms(int32_t value);
  private:
  int32_t _internal_action_delay_ms() const;
  void _internal_set_action_delay_ms(int32_t value);
  public:

  // optional bool clean_contextual_ui = 33;
  bool has_clean_contextual_ui() const;
  private:
  bool _internal_has_clean_contextual_ui() const;
  public:
  void clear_clean_contextual_ui();
  bool clean_contextual_ui() const;
  void set_clean_contextual_ui(bool value);
  private:
  bool _internal_clean_contextual_ui() const;
  void _internal_set_clean_contextual_ui(bool value);
  public:

  // .autofill_assistant.SelectOptionProto select_option = 7;
  bool has_select_option() const;
  private:
  bool _internal_has_select_option() const;
  public:
  void clear_select_option();
  const ::autofill_assistant::SelectOptionProto& select_option() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectOptionProto* release_select_option();
  ::autofill_assistant::SelectOptionProto* mutable_select_option();
  void set_allocated_select_option(::autofill_assistant::SelectOptionProto* select_option);
  private:
  const ::autofill_assistant::SelectOptionProto& _internal_select_option() const;
  ::autofill_assistant::SelectOptionProto* _internal_mutable_select_option();
  public:
  void unsafe_arena_set_allocated_select_option(
      ::autofill_assistant::SelectOptionProto* select_option);
  ::autofill_assistant::SelectOptionProto* unsafe_arena_release_select_option();

  // .autofill_assistant.NavigateProto navigate = 9;
  bool has_navigate() const;
  private:
  bool _internal_has_navigate() const;
  public:
  void clear_navigate();
  const ::autofill_assistant::NavigateProto& navigate() const;
  PROTOBUF_NODISCARD ::autofill_assistant::NavigateProto* release_navigate();
  ::autofill_assistant::NavigateProto* mutable_navigate();
  void set_allocated_navigate(::autofill_assistant::NavigateProto* navigate);
  private:
  const ::autofill_assistant::NavigateProto& _internal_navigate() const;
  ::autofill_assistant::NavigateProto* _internal_mutable_navigate();
  public:
  void unsafe_arena_set_allocated_navigate(
      ::autofill_assistant::NavigateProto* navigate);
  ::autofill_assistant::NavigateProto* unsafe_arena_release_navigate();

  // .autofill_assistant.PromptProto prompt = 10;
  bool has_prompt() const;
  private:
  bool _internal_has_prompt() const;
  public:
  void clear_prompt();
  const ::autofill_assistant::PromptProto& prompt() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PromptProto* release_prompt();
  ::autofill_assistant::PromptProto* mutable_prompt();
  void set_allocated_prompt(::autofill_assistant::PromptProto* prompt);
  private:
  const ::autofill_assistant::PromptProto& _internal_prompt() const;
  ::autofill_assistant::PromptProto* _internal_mutable_prompt();
  public:
  void unsafe_arena_set_allocated_prompt(
      ::autofill_assistant::PromptProto* prompt);
  ::autofill_assistant::PromptProto* unsafe_arena_release_prompt();

  // .autofill_assistant.TellProto tell = 11;
  bool has_tell() const;
  private:
  bool _internal_has_tell() const;
  public:
  void clear_tell();
  const ::autofill_assistant::TellProto& tell() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TellProto* release_tell();
  ::autofill_assistant::TellProto* mutable_tell();
  void set_allocated_tell(::autofill_assistant::TellProto* tell);
  private:
  const ::autofill_assistant::TellProto& _internal_tell() const;
  ::autofill_assistant::TellProto* _internal_mutable_tell();
  public:
  void unsafe_arena_set_allocated_tell(
      ::autofill_assistant::TellProto* tell);
  ::autofill_assistant::TellProto* unsafe_arena_release_tell();

  // .autofill_assistant.ShowCastProto show_cast = 12;
  bool has_show_cast() const;
  private:
  bool _internal_has_show_cast() const;
  public:
  void clear_show_cast();
  const ::autofill_assistant::ShowCastProto& show_cast() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowCastProto* release_show_cast();
  ::autofill_assistant::ShowCastProto* mutable_show_cast();
  void set_allocated_show_cast(::autofill_assistant::ShowCastProto* show_cast);
  private:
  const ::autofill_assistant::ShowCastProto& _internal_show_cast() const;
  ::autofill_assistant::ShowCastProto* _internal_mutable_show_cast();
  public:
  void unsafe_arena_set_allocated_show_cast(
      ::autofill_assistant::ShowCastProto* show_cast);
  ::autofill_assistant::ShowCastProto* unsafe_arena_release_show_cast();

  // .autofill_assistant.WaitForDomProto wait_for_dom = 19;
  bool has_wait_for_dom() const;
  private:
  bool _internal_has_wait_for_dom() const;
  public:
  void clear_wait_for_dom();
  const ::autofill_assistant::WaitForDomProto& wait_for_dom() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForDomProto* release_wait_for_dom();
  ::autofill_assistant::WaitForDomProto* mutable_wait_for_dom();
  void set_allocated_wait_for_dom(::autofill_assistant::WaitForDomProto* wait_for_dom);
  private:
  const ::autofill_assistant::WaitForDomProto& _internal_wait_for_dom() const;
  ::autofill_assistant::WaitForDomProto* _internal_mutable_wait_for_dom();
  public:
  void unsafe_arena_set_allocated_wait_for_dom(
      ::autofill_assistant::WaitForDomProto* wait_for_dom);
  ::autofill_assistant::WaitForDomProto* unsafe_arena_release_wait_for_dom();

  // .autofill_assistant.UseCreditCardProto use_card = 28;
  bool has_use_card() const;
  private:
  bool _internal_has_use_card() const;
  public:
  void clear_use_card();
  const ::autofill_assistant::UseCreditCardProto& use_card() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UseCreditCardProto* release_use_card();
  ::autofill_assistant::UseCreditCardProto* mutable_use_card();
  void set_allocated_use_card(::autofill_assistant::UseCreditCardProto* use_card);
  private:
  const ::autofill_assistant::UseCreditCardProto& _internal_use_card() const;
  ::autofill_assistant::UseCreditCardProto* _internal_mutable_use_card();
  public:
  void unsafe_arena_set_allocated_use_card(
      ::autofill_assistant::UseCreditCardProto* use_card);
  ::autofill_assistant::UseCreditCardProto* unsafe_arena_release_use_card();

  // .autofill_assistant.UseAddressProto use_address = 29;
  bool has_use_address() const;
  private:
  bool _internal_has_use_address() const;
  public:
  void clear_use_address();
  const ::autofill_assistant::UseAddressProto& use_address() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UseAddressProto* release_use_address();
  ::autofill_assistant::UseAddressProto* mutable_use_address();
  void set_allocated_use_address(::autofill_assistant::UseAddressProto* use_address);
  private:
  const ::autofill_assistant::UseAddressProto& _internal_use_address() const;
  ::autofill_assistant::UseAddressProto* _internal_mutable_use_address();
  public:
  void unsafe_arena_set_allocated_use_address(
      ::autofill_assistant::UseAddressProto* use_address);
  ::autofill_assistant::UseAddressProto* unsafe_arena_release_use_address();

  // .autofill_assistant.UploadDomProto upload_dom = 18;
  bool has_upload_dom() const;
  private:
  bool _internal_has_upload_dom() const;
  public:
  void clear_upload_dom();
  const ::autofill_assistant::UploadDomProto& upload_dom() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UploadDomProto* release_upload_dom();
  ::autofill_assistant::UploadDomProto* mutable_upload_dom();
  void set_allocated_upload_dom(::autofill_assistant::UploadDomProto* upload_dom);
  private:
  const ::autofill_assistant::UploadDomProto& _internal_upload_dom() const;
  ::autofill_assistant::UploadDomProto* _internal_mutable_upload_dom();
  public:
  void unsafe_arena_set_allocated_upload_dom(
      ::autofill_assistant::UploadDomProto* upload_dom);
  ::autofill_assistant::UploadDomProto* unsafe_arena_release_upload_dom();

  // .autofill_assistant.ShowProgressBarProto show_progress_bar = 24;
  bool has_show_progress_bar() const;
  private:
  bool _internal_has_show_progress_bar() const;
  public:
  void clear_show_progress_bar();
  const ::autofill_assistant::ShowProgressBarProto& show_progress_bar() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowProgressBarProto* release_show_progress_bar();
  ::autofill_assistant::ShowProgressBarProto* mutable_show_progress_bar();
  void set_allocated_show_progress_bar(::autofill_assistant::ShowProgressBarProto* show_progress_bar);
  private:
  const ::autofill_assistant::ShowProgressBarProto& _internal_show_progress_bar() const;
  ::autofill_assistant::ShowProgressBarProto* _internal_mutable_show_progress_bar();
  public:
  void unsafe_arena_set_allocated_show_progress_bar(
      ::autofill_assistant::ShowProgressBarProto* show_progress_bar);
  ::autofill_assistant::ShowProgressBarProto* unsafe_arena_release_show_progress_bar();

  // .autofill_assistant.ShowDetailsProto show_details = 32;
  bool has_show_details() const;
  private:
  bool _internal_has_show_details() const;
  public:
  void clear_show_details();
  const ::autofill_assistant::ShowDetailsProto& show_details() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowDetailsProto* release_show_details();
  ::autofill_assistant::ShowDetailsProto* mutable_show_details();
  void set_allocated_show_details(::autofill_assistant::ShowDetailsProto* show_details);
  private:
  const ::autofill_assistant::ShowDetailsProto& _internal_show_details() const;
  ::autofill_assistant::ShowDetailsProto* _internal_mutable_show_details();
  public:
  void unsafe_arena_set_allocated_show_details(
      ::autofill_assistant::ShowDetailsProto* show_details);
  ::autofill_assistant::ShowDetailsProto* unsafe_arena_release_show_details();

  // .autofill_assistant.StopProto stop = 35;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const ::autofill_assistant::StopProto& stop() const;
  PROTOBUF_NODISCARD ::autofill_assistant::StopProto* release_stop();
  ::autofill_assistant::StopProto* mutable_stop();
  void set_allocated_stop(::autofill_assistant::StopProto* stop);
  private:
  const ::autofill_assistant::StopProto& _internal_stop() const;
  ::autofill_assistant::StopProto* _internal_mutable_stop();
  public:
  void unsafe_arena_set_allocated_stop(
      ::autofill_assistant::StopProto* stop);
  ::autofill_assistant::StopProto* unsafe_arena_release_stop();

  // .autofill_assistant.CollectUserDataProto collect_user_data = 36;
  bool has_collect_user_data() const;
  private:
  bool _internal_has_collect_user_data() const;
  public:
  void clear_collect_user_data();
  const ::autofill_assistant::CollectUserDataProto& collect_user_data() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CollectUserDataProto* release_collect_user_data();
  ::autofill_assistant::CollectUserDataProto* mutable_collect_user_data();
  void set_allocated_collect_user_data(::autofill_assistant::CollectUserDataProto* collect_user_data);
  private:
  const ::autofill_assistant::CollectUserDataProto& _internal_collect_user_data() const;
  ::autofill_assistant::CollectUserDataProto* _internal_mutable_collect_user_data();
  public:
  void unsafe_arena_set_allocated_collect_user_data(
      ::autofill_assistant::CollectUserDataProto* collect_user_data);
  ::autofill_assistant::CollectUserDataProto* unsafe_arena_release_collect_user_data();

  // .autofill_assistant.SetAttributeProto set_attribute = 37;
  bool has_set_attribute() const;
  private:
  bool _internal_has_set_attribute() const;
  public:
  void clear_set_attribute();
  const ::autofill_assistant::SetAttributeProto& set_attribute() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetAttributeProto* release_set_attribute();
  ::autofill_assistant::SetAttributeProto* mutable_set_attribute();
  void set_allocated_set_attribute(::autofill_assistant::SetAttributeProto* set_attribute);
  private:
  const ::autofill_assistant::SetAttributeProto& _internal_set_attribute() const;
  ::autofill_assistant::SetAttributeProto* _internal_mutable_set_attribute();
  public:
  void unsafe_arena_set_allocated_set_attribute(
      ::autofill_assistant::SetAttributeProto* set_attribute);
  ::autofill_assistant::SetAttributeProto* unsafe_arena_release_set_attribute();

  // .autofill_assistant.ShowInfoBoxProto show_info_box = 39;
  bool has_show_info_box() const;
  private:
  bool _internal_has_show_info_box() const;
  public:
  void clear_show_info_box();
  const ::autofill_assistant::ShowInfoBoxProto& show_info_box() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowInfoBoxProto* release_show_info_box();
  ::autofill_assistant::ShowInfoBoxProto* mutable_show_info_box();
  void set_allocated_show_info_box(::autofill_assistant::ShowInfoBoxProto* show_info_box);
  private:
  const ::autofill_assistant::ShowInfoBoxProto& _internal_show_info_box() const;
  ::autofill_assistant::ShowInfoBoxProto* _internal_mutable_show_info_box();
  public:
  void unsafe_arena_set_allocated_show_info_box(
      ::autofill_assistant::ShowInfoBoxProto* show_info_box);
  ::autofill_assistant::ShowInfoBoxProto* unsafe_arena_release_show_info_box();

  // .autofill_assistant.ExpectNavigationProto expect_navigation = 40;
  bool has_expect_navigation() const;
  private:
  bool _internal_has_expect_navigation() const;
  public:
  void clear_expect_navigation();
  const ::autofill_assistant::ExpectNavigationProto& expect_navigation() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ExpectNavigationProto* release_expect_navigation();
  ::autofill_assistant::ExpectNavigationProto* mutable_expect_navigation();
  void set_allocated_expect_navigation(::autofill_assistant::ExpectNavigationProto* expect_navigation);
  private:
  const ::autofill_assistant::ExpectNavigationProto& _internal_expect_navigation() const;
  ::autofill_assistant::ExpectNavigationProto* _internal_mutable_expect_navigation();
  public:
  void unsafe_arena_set_allocated_expect_navigation(
      ::autofill_assistant::ExpectNavigationProto* expect_navigation);
  ::autofill_assistant::ExpectNavigationProto* unsafe_arena_release_expect_navigation();

  // .autofill_assistant.WaitForNavigationProto wait_for_navigation = 41;
  bool has_wait_for_navigation() const;
  private:
  bool _internal_has_wait_for_navigation() const;
  public:
  void clear_wait_for_navigation();
  const ::autofill_assistant::WaitForNavigationProto& wait_for_navigation() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForNavigationProto* release_wait_for_navigation();
  ::autofill_assistant::WaitForNavigationProto* mutable_wait_for_navigation();
  void set_allocated_wait_for_navigation(::autofill_assistant::WaitForNavigationProto* wait_for_navigation);
  private:
  const ::autofill_assistant::WaitForNavigationProto& _internal_wait_for_navigation() const;
  ::autofill_assistant::WaitForNavigationProto* _internal_mutable_wait_for_navigation();
  public:
  void unsafe_arena_set_allocated_wait_for_navigation(
      ::autofill_assistant::WaitForNavigationProto* wait_for_navigation);
  ::autofill_assistant::WaitForNavigationProto* unsafe_arena_release_wait_for_navigation();

  // .autofill_assistant.ConfigureBottomSheetProto configure_bottom_sheet = 42;
  bool has_configure_bottom_sheet() const;
  private:
  bool _internal_has_configure_bottom_sheet() const;
  public:
  void clear_configure_bottom_sheet();
  const ::autofill_assistant::ConfigureBottomSheetProto& configure_bottom_sheet() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ConfigureBottomSheetProto* release_configure_bottom_sheet();
  ::autofill_assistant::ConfigureBottomSheetProto* mutable_configure_bottom_sheet();
  void set_allocated_configure_bottom_sheet(::autofill_assistant::ConfigureBottomSheetProto* configure_bottom_sheet);
  private:
  const ::autofill_assistant::ConfigureBottomSheetProto& _internal_configure_bottom_sheet() const;
  ::autofill_assistant::ConfigureBottomSheetProto* _internal_mutable_configure_bottom_sheet();
  public:
  void unsafe_arena_set_allocated_configure_bottom_sheet(
      ::autofill_assistant::ConfigureBottomSheetProto* configure_bottom_sheet);
  ::autofill_assistant::ConfigureBottomSheetProto* unsafe_arena_release_configure_bottom_sheet();

  // .autofill_assistant.ShowFormProto show_form = 43;
  bool has_show_form() const;
  private:
  bool _internal_has_show_form() const;
  public:
  void clear_show_form();
  const ::autofill_assistant::ShowFormProto& show_form() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowFormProto* release_show_form();
  ::autofill_assistant::ShowFormProto* mutable_show_form();
  void set_allocated_show_form(::autofill_assistant::ShowFormProto* show_form);
  private:
  const ::autofill_assistant::ShowFormProto& _internal_show_form() const;
  ::autofill_assistant::ShowFormProto* _internal_mutable_show_form();
  public:
  void unsafe_arena_set_allocated_show_form(
      ::autofill_assistant::ShowFormProto* show_form);
  ::autofill_assistant::ShowFormProto* unsafe_arena_release_show_form();

  // .autofill_assistant.PopupMessageProto popup_message = 44;
  bool has_popup_message() const;
  private:
  bool _internal_has_popup_message() const;
  public:
  void clear_popup_message();
  const ::autofill_assistant::PopupMessageProto& popup_message() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PopupMessageProto* release_popup_message();
  ::autofill_assistant::PopupMessageProto* mutable_popup_message();
  void set_allocated_popup_message(::autofill_assistant::PopupMessageProto* popup_message);
  private:
  const ::autofill_assistant::PopupMessageProto& _internal_popup_message() const;
  ::autofill_assistant::PopupMessageProto* _internal_mutable_popup_message();
  public:
  void unsafe_arena_set_allocated_popup_message(
      ::autofill_assistant::PopupMessageProto* popup_message);
  ::autofill_assistant::PopupMessageProto* unsafe_arena_release_popup_message();

  // .autofill_assistant.WaitForDocumentProto wait_for_document = 45;
  bool has_wait_for_document() const;
  private:
  bool _internal_has_wait_for_document() const;
  public:
  void clear_wait_for_document();
  const ::autofill_assistant::WaitForDocumentProto& wait_for_document() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForDocumentProto* release_wait_for_document();
  ::autofill_assistant::WaitForDocumentProto* mutable_wait_for_document();
  void set_allocated_wait_for_document(::autofill_assistant::WaitForDocumentProto* wait_for_document);
  private:
  const ::autofill_assistant::WaitForDocumentProto& _internal_wait_for_document() const;
  ::autofill_assistant::WaitForDocumentProto* _internal_mutable_wait_for_document();
  public:
  void unsafe_arena_set_allocated_wait_for_document(
      ::autofill_assistant::WaitForDocumentProto* wait_for_document);
  ::autofill_assistant::WaitForDocumentProto* unsafe_arena_release_wait_for_document();

  // .autofill_assistant.ShowGenericUiProto show_generic_ui = 49;
  bool has_show_generic_ui() const;
  private:
  bool _internal_has_show_generic_ui() const;
  public:
  void clear_show_generic_ui();
  const ::autofill_assistant::ShowGenericUiProto& show_generic_ui() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowGenericUiProto* release_show_generic_ui();
  ::autofill_assistant::ShowGenericUiProto* mutable_show_generic_ui();
  void set_allocated_show_generic_ui(::autofill_assistant::ShowGenericUiProto* show_generic_ui);
  private:
  const ::autofill_assistant::ShowGenericUiProto& _internal_show_generic_ui() const;
  ::autofill_assistant::ShowGenericUiProto* _internal_mutable_show_generic_ui();
  public:
  void unsafe_arena_set_allocated_show_generic_ui(
      ::autofill_assistant::ShowGenericUiProto* show_generic_ui);
  ::autofill_assistant::ShowGenericUiProto* unsafe_arena_release_show_generic_ui();

  // .autofill_assistant.GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
  bool has_generate_password_for_form_field() const;
  private:
  bool _internal_has_generate_password_for_form_field() const;
  public:
  void clear_generate_password_for_form_field();
  const ::autofill_assistant::GeneratePasswordForFormFieldProto& generate_password_for_form_field() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GeneratePasswordForFormFieldProto* release_generate_password_for_form_field();
  ::autofill_assistant::GeneratePasswordForFormFieldProto* mutable_generate_password_for_form_field();
  void set_allocated_generate_password_for_form_field(::autofill_assistant::GeneratePasswordForFormFieldProto* generate_password_for_form_field);
  private:
  const ::autofill_assistant::GeneratePasswordForFormFieldProto& _internal_generate_password_for_form_field() const;
  ::autofill_assistant::GeneratePasswordForFormFieldProto* _internal_mutable_generate_password_for_form_field();
  public:
  void unsafe_arena_set_allocated_generate_password_for_form_field(
      ::autofill_assistant::GeneratePasswordForFormFieldProto* generate_password_for_form_field);
  ::autofill_assistant::GeneratePasswordForFormFieldProto* unsafe_arena_release_generate_password_for_form_field();

  // .autofill_assistant.SaveGeneratedPasswordProto save_generated_password = 53;
  bool has_save_generated_password() const;
  private:
  bool _internal_has_save_generated_password() const;
  public:
  void clear_save_generated_password();
  const ::autofill_assistant::SaveGeneratedPasswordProto& save_generated_password() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SaveGeneratedPasswordProto* release_save_generated_password();
  ::autofill_assistant::SaveGeneratedPasswordProto* mutable_save_generated_password();
  void set_allocated_save_generated_password(::autofill_assistant::SaveGeneratedPasswordProto* save_generated_password);
  private:
  const ::autofill_assistant::SaveGeneratedPasswordProto& _internal_save_generated_password() const;
  ::autofill_assistant::SaveGeneratedPasswordProto* _internal_mutable_save_generated_password();
  public:
  void unsafe_arena_set_allocated_save_generated_password(
      ::autofill_assistant::SaveGeneratedPasswordProto* save_generated_password);
  ::autofill_assistant::SaveGeneratedPasswordProto* unsafe_arena_release_save_generated_password();

  // .autofill_assistant.ConfigureUiStateProto configure_ui_state = 54;
  bool has_configure_ui_state() const;
  private:
  bool _internal_has_configure_ui_state() const;
  public:
  void clear_configure_ui_state();
  const ::autofill_assistant::ConfigureUiStateProto& configure_ui_state() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ConfigureUiStateProto* release_configure_ui_state();
  ::autofill_assistant::ConfigureUiStateProto* mutable_configure_ui_state();
  void set_allocated_configure_ui_state(::autofill_assistant::ConfigureUiStateProto* configure_ui_state);
  private:
  const ::autofill_assistant::ConfigureUiStateProto& _internal_configure_ui_state() const;
  ::autofill_assistant::ConfigureUiStateProto* _internal_mutable_configure_ui_state();
  public:
  void unsafe_arena_set_allocated_configure_ui_state(
      ::autofill_assistant::ConfigureUiStateProto* configure_ui_state);
  ::autofill_assistant::ConfigureUiStateProto* unsafe_arena_release_configure_ui_state();

  // .autofill_assistant.PresaveGeneratedPasswordProto presave_generated_password = 55;
  bool has_presave_generated_password() const;
  private:
  bool _internal_has_presave_generated_password() const;
  public:
  void clear_presave_generated_password();
  const ::autofill_assistant::PresaveGeneratedPasswordProto& presave_generated_password() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PresaveGeneratedPasswordProto* release_presave_generated_password();
  ::autofill_assistant::PresaveGeneratedPasswordProto* mutable_presave_generated_password();
  void set_allocated_presave_generated_password(::autofill_assistant::PresaveGeneratedPasswordProto* presave_generated_password);
  private:
  const ::autofill_assistant::PresaveGeneratedPasswordProto& _internal_presave_generated_password() const;
  ::autofill_assistant::PresaveGeneratedPasswordProto* _internal_mutable_presave_generated_password();
  public:
  void unsafe_arena_set_allocated_presave_generated_password(
      ::autofill_assistant::PresaveGeneratedPasswordProto* presave_generated_password);
  ::autofill_assistant::PresaveGeneratedPasswordProto* unsafe_arena_release_presave_generated_password();

  // .autofill_assistant.GetElementStatusProto get_element_status = 56;
  bool has_get_element_status() const;
  private:
  bool _internal_has_get_element_status() const;
  public:
  void clear_get_element_status();
  const ::autofill_assistant::GetElementStatusProto& get_element_status() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto* release_get_element_status();
  ::autofill_assistant::GetElementStatusProto* mutable_get_element_status();
  void set_allocated_get_element_status(::autofill_assistant::GetElementStatusProto* get_element_status);
  private:
  const ::autofill_assistant::GetElementStatusProto& _internal_get_element_status() const;
  ::autofill_assistant::GetElementStatusProto* _internal_mutable_get_element_status();
  public:
  void unsafe_arena_set_allocated_get_element_status(
      ::autofill_assistant::GetElementStatusProto* get_element_status);
  ::autofill_assistant::GetElementStatusProto* unsafe_arena_release_get_element_status();

  // .autofill_assistant.ScrollIntoViewProto scroll_into_view = 57;
  bool has_scroll_into_view() const;
  private:
  bool _internal_has_scroll_into_view() const;
  public:
  void clear_scroll_into_view();
  const ::autofill_assistant::ScrollIntoViewProto& scroll_into_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScrollIntoViewProto* release_scroll_into_view();
  ::autofill_assistant::ScrollIntoViewProto* mutable_scroll_into_view();
  void set_allocated_scroll_into_view(::autofill_assistant::ScrollIntoViewProto* scroll_into_view);
  private:
  const ::autofill_assistant::ScrollIntoViewProto& _internal_scroll_into_view() const;
  ::autofill_assistant::ScrollIntoViewProto* _internal_mutable_scroll_into_view();
  public:
  void unsafe_arena_set_allocated_scroll_into_view(
      ::autofill_assistant::ScrollIntoViewProto* scroll_into_view);
  ::autofill_assistant::ScrollIntoViewProto* unsafe_arena_release_scroll_into_view();

  // .autofill_assistant.WaitForDocumentToBecomeInteractiveProto wait_for_document_to_become_interactive = 58;
  bool has_wait_for_document_to_become_interactive() const;
  private:
  bool _internal_has_wait_for_document_to_become_interactive() const;
  public:
  void clear_wait_for_document_to_become_interactive();
  const ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto& wait_for_document_to_become_interactive() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* release_wait_for_document_to_become_interactive();
  ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* mutable_wait_for_document_to_become_interactive();
  void set_allocated_wait_for_document_to_become_interactive(::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* wait_for_document_to_become_interactive);
  private:
  const ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto& _internal_wait_for_document_to_become_interactive() const;
  ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* _internal_mutable_wait_for_document_to_become_interactive();
  public:
  void unsafe_arena_set_allocated_wait_for_document_to_become_interactive(
      ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* wait_for_document_to_become_interactive);
  ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* unsafe_arena_release_wait_for_document_to_become_interactive();

  // .autofill_assistant.WaitForDocumentToBecomeCompleteProto wait_for_document_to_become_complete = 59;
  bool has_wait_for_document_to_become_complete() const;
  private:
  bool _internal_has_wait_for_document_to_become_complete() const;
  public:
  void clear_wait_for_document_to_become_complete();
  const ::autofill_assistant::WaitForDocumentToBecomeCompleteProto& wait_for_document_to_become_complete() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* release_wait_for_document_to_become_complete();
  ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* mutable_wait_for_document_to_become_complete();
  void set_allocated_wait_for_document_to_become_complete(::autofill_assistant::WaitForDocumentToBecomeCompleteProto* wait_for_document_to_become_complete);
  private:
  const ::autofill_assistant::WaitForDocumentToBecomeCompleteProto& _internal_wait_for_document_to_become_complete() const;
  ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* _internal_mutable_wait_for_document_to_become_complete();
  public:
  void unsafe_arena_set_allocated_wait_for_document_to_become_complete(
      ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* wait_for_document_to_become_complete);
  ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* unsafe_arena_release_wait_for_document_to_become_complete();

  // .autofill_assistant.SendClickEventProto send_click_event = 60;
  bool has_send_click_event() const;
  private:
  bool _internal_has_send_click_event() const;
  public:
  void clear_send_click_event();
  const ::autofill_assistant::SendClickEventProto& send_click_event() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SendClickEventProto* release_send_click_event();
  ::autofill_assistant::SendClickEventProto* mutable_send_click_event();
  void set_allocated_send_click_event(::autofill_assistant::SendClickEventProto* send_click_event);
  private:
  const ::autofill_assistant::SendClickEventProto& _internal_send_click_event() const;
  ::autofill_assistant::SendClickEventProto* _internal_mutable_send_click_event();
  public:
  void unsafe_arena_set_allocated_send_click_event(
      ::autofill_assistant::SendClickEventProto* send_click_event);
  ::autofill_assistant::SendClickEventProto* unsafe_arena_release_send_click_event();

  // .autofill_assistant.SendTapEventProto send_tap_event = 61;
  bool has_send_tap_event() const;
  private:
  bool _internal_has_send_tap_event() const;
  public:
  void clear_send_tap_event();
  const ::autofill_assistant::SendTapEventProto& send_tap_event() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SendTapEventProto* release_send_tap_event();
  ::autofill_assistant::SendTapEventProto* mutable_send_tap_event();
  void set_allocated_send_tap_event(::autofill_assistant::SendTapEventProto* send_tap_event);
  private:
  const ::autofill_assistant::SendTapEventProto& _internal_send_tap_event() const;
  ::autofill_assistant::SendTapEventProto* _internal_mutable_send_tap_event();
  public:
  void unsafe_arena_set_allocated_send_tap_event(
      ::autofill_assistant::SendTapEventProto* send_tap_event);
  ::autofill_assistant::SendTapEventProto* unsafe_arena_release_send_tap_event();

  // .autofill_assistant.JsClickProto js_click = 62;
  bool has_js_click() const;
  private:
  bool _internal_has_js_click() const;
  public:
  void clear_js_click();
  const ::autofill_assistant::JsClickProto& js_click() const;
  PROTOBUF_NODISCARD ::autofill_assistant::JsClickProto* release_js_click();
  ::autofill_assistant::JsClickProto* mutable_js_click();
  void set_allocated_js_click(::autofill_assistant::JsClickProto* js_click);
  private:
  const ::autofill_assistant::JsClickProto& _internal_js_click() const;
  ::autofill_assistant::JsClickProto* _internal_mutable_js_click();
  public:
  void unsafe_arena_set_allocated_js_click(
      ::autofill_assistant::JsClickProto* js_click);
  ::autofill_assistant::JsClickProto* unsafe_arena_release_js_click();

  // .autofill_assistant.SendKeystrokeEventsProto send_keystroke_events = 63;
  bool has_send_keystroke_events() const;
  private:
  bool _internal_has_send_keystroke_events() const;
  public:
  void clear_send_keystroke_events();
  const ::autofill_assistant::SendKeystrokeEventsProto& send_keystroke_events() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SendKeystrokeEventsProto* release_send_keystroke_events();
  ::autofill_assistant::SendKeystrokeEventsProto* mutable_send_keystroke_events();
  void set_allocated_send_keystroke_events(::autofill_assistant::SendKeystrokeEventsProto* send_keystroke_events);
  private:
  const ::autofill_assistant::SendKeystrokeEventsProto& _internal_send_keystroke_events() const;
  ::autofill_assistant::SendKeystrokeEventsProto* _internal_mutable_send_keystroke_events();
  public:
  void unsafe_arena_set_allocated_send_keystroke_events(
      ::autofill_assistant::SendKeystrokeEventsProto* send_keystroke_events);
  ::autofill_assistant::SendKeystrokeEventsProto* unsafe_arena_release_send_keystroke_events();

  // .autofill_assistant.SendChangeEventProto send_change_event = 64;
  bool has_send_change_event() const;
  private:
  bool _internal_has_send_change_event() const;
  public:
  void clear_send_change_event();
  const ::autofill_assistant::SendChangeEventProto& send_change_event() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SendChangeEventProto* release_send_change_event();
  ::autofill_assistant::SendChangeEventProto* mutable_send_change_event();
  void set_allocated_send_change_event(::autofill_assistant::SendChangeEventProto* send_change_event);
  private:
  const ::autofill_assistant::SendChangeEventProto& _internal_send_change_event() const;
  ::autofill_assistant::SendChangeEventProto* _internal_mutable_send_change_event();
  public:
  void unsafe_arena_set_allocated_send_change_event(
      ::autofill_assistant::SendChangeEventProto* send_change_event);
  ::autofill_assistant::SendChangeEventProto* unsafe_arena_release_send_change_event();

  // .autofill_assistant.SetElementAttributeProto set_element_attribute = 65;
  bool has_set_element_attribute() const;
  private:
  bool _internal_has_set_element_attribute() const;
  public:
  void clear_set_element_attribute();
  const ::autofill_assistant::SetElementAttributeProto& set_element_attribute() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetElementAttributeProto* release_set_element_attribute();
  ::autofill_assistant::SetElementAttributeProto* mutable_set_element_attribute();
  void set_allocated_set_element_attribute(::autofill_assistant::SetElementAttributeProto* set_element_attribute);
  private:
  const ::autofill_assistant::SetElementAttributeProto& _internal_set_element_attribute() const;
  ::autofill_assistant::SetElementAttributeProto* _internal_mutable_set_element_attribute();
  public:
  void unsafe_arena_set_allocated_set_element_attribute(
      ::autofill_assistant::SetElementAttributeProto* set_element_attribute);
  ::autofill_assistant::SetElementAttributeProto* unsafe_arena_release_set_element_attribute();

  // .autofill_assistant.SelectFieldValueProto select_field_value = 66;
  bool has_select_field_value() const;
  private:
  bool _internal_has_select_field_value() const;
  public:
  void clear_select_field_value();
  const ::autofill_assistant::SelectFieldValueProto& select_field_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectFieldValueProto* release_select_field_value();
  ::autofill_assistant::SelectFieldValueProto* mutable_select_field_value();
  void set_allocated_select_field_value(::autofill_assistant::SelectFieldValueProto* select_field_value);
  private:
  const ::autofill_assistant::SelectFieldValueProto& _internal_select_field_value() const;
  ::autofill_assistant::SelectFieldValueProto* _internal_mutable_select_field_value();
  public:
  void unsafe_arena_set_allocated_select_field_value(
      ::autofill_assistant::SelectFieldValueProto* select_field_value);
  ::autofill_assistant::SelectFieldValueProto* unsafe_arena_release_select_field_value();

  // .autofill_assistant.FocusFieldProto focus_field = 67;
  bool has_focus_field() const;
  private:
  bool _internal_has_focus_field() const;
  public:
  void clear_focus_field();
  const ::autofill_assistant::FocusFieldProto& focus_field() const;
  PROTOBUF_NODISCARD ::autofill_assistant::FocusFieldProto* release_focus_field();
  ::autofill_assistant::FocusFieldProto* mutable_focus_field();
  void set_allocated_focus_field(::autofill_assistant::FocusFieldProto* focus_field);
  private:
  const ::autofill_assistant::FocusFieldProto& _internal_focus_field() const;
  ::autofill_assistant::FocusFieldProto* _internal_mutable_focus_field();
  public:
  void unsafe_arena_set_allocated_focus_field(
      ::autofill_assistant::FocusFieldProto* focus_field);
  ::autofill_assistant::FocusFieldProto* unsafe_arena_release_focus_field();

  // .autofill_assistant.WaitForElementToBecomeStableProto wait_for_element_to_become_stable = 68;
  bool has_wait_for_element_to_become_stable() const;
  private:
  bool _internal_has_wait_for_element_to_become_stable() const;
  public:
  void clear_wait_for_element_to_become_stable();
  const ::autofill_assistant::WaitForElementToBecomeStableProto& wait_for_element_to_become_stable() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForElementToBecomeStableProto* release_wait_for_element_to_become_stable();
  ::autofill_assistant::WaitForElementToBecomeStableProto* mutable_wait_for_element_to_become_stable();
  void set_allocated_wait_for_element_to_become_stable(::autofill_assistant::WaitForElementToBecomeStableProto* wait_for_element_to_become_stable);
  private:
  const ::autofill_assistant::WaitForElementToBecomeStableProto& _internal_wait_for_element_to_become_stable() const;
  ::autofill_assistant::WaitForElementToBecomeStableProto* _internal_mutable_wait_for_element_to_become_stable();
  public:
  void unsafe_arena_set_allocated_wait_for_element_to_become_stable(
      ::autofill_assistant::WaitForElementToBecomeStableProto* wait_for_element_to_become_stable);
  ::autofill_assistant::WaitForElementToBecomeStableProto* unsafe_arena_release_wait_for_element_to_become_stable();

  // .autofill_assistant.CheckElementIsOnTopProto check_element_is_on_top = 69;
  bool has_check_element_is_on_top() const;
  private:
  bool _internal_has_check_element_is_on_top() const;
  public:
  void clear_check_element_is_on_top();
  const ::autofill_assistant::CheckElementIsOnTopProto& check_element_is_on_top() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CheckElementIsOnTopProto* release_check_element_is_on_top();
  ::autofill_assistant::CheckElementIsOnTopProto* mutable_check_element_is_on_top();
  void set_allocated_check_element_is_on_top(::autofill_assistant::CheckElementIsOnTopProto* check_element_is_on_top);
  private:
  const ::autofill_assistant::CheckElementIsOnTopProto& _internal_check_element_is_on_top() const;
  ::autofill_assistant::CheckElementIsOnTopProto* _internal_mutable_check_element_is_on_top();
  public:
  void unsafe_arena_set_allocated_check_element_is_on_top(
      ::autofill_assistant::CheckElementIsOnTopProto* check_element_is_on_top);
  ::autofill_assistant::CheckElementIsOnTopProto* unsafe_arena_release_check_element_is_on_top();

  // .autofill_assistant.ReleaseElementsProto release_elements = 70;
  bool has_release_elements() const;
  private:
  bool _internal_has_release_elements() const;
  public:
  void clear_release_elements();
  const ::autofill_assistant::ReleaseElementsProto& release_elements() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ReleaseElementsProto* release_release_elements();
  ::autofill_assistant::ReleaseElementsProto* mutable_release_elements();
  void set_allocated_release_elements(::autofill_assistant::ReleaseElementsProto* release_elements);
  private:
  const ::autofill_assistant::ReleaseElementsProto& _internal_release_elements() const;
  ::autofill_assistant::ReleaseElementsProto* _internal_mutable_release_elements();
  public:
  void unsafe_arena_set_allocated_release_elements(
      ::autofill_assistant::ReleaseElementsProto* release_elements);
  ::autofill_assistant::ReleaseElementsProto* unsafe_arena_release_release_elements();

  // .autofill_assistant.DispatchJsEventProto dispatch_js_event = 72;
  bool has_dispatch_js_event() const;
  private:
  bool _internal_has_dispatch_js_event() const;
  public:
  void clear_dispatch_js_event();
  const ::autofill_assistant::DispatchJsEventProto& dispatch_js_event() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DispatchJsEventProto* release_dispatch_js_event();
  ::autofill_assistant::DispatchJsEventProto* mutable_dispatch_js_event();
  void set_allocated_dispatch_js_event(::autofill_assistant::DispatchJsEventProto* dispatch_js_event);
  private:
  const ::autofill_assistant::DispatchJsEventProto& _internal_dispatch_js_event() const;
  ::autofill_assistant::DispatchJsEventProto* _internal_mutable_dispatch_js_event();
  public:
  void unsafe_arena_set_allocated_dispatch_js_event(
      ::autofill_assistant::DispatchJsEventProto* dispatch_js_event);
  ::autofill_assistant::DispatchJsEventProto* unsafe_arena_release_dispatch_js_event();

  // .autofill_assistant.SendKeyEventProto send_key_event = 73;
  bool has_send_key_event() const;
  private:
  bool _internal_has_send_key_event() const;
  public:
  void clear_send_key_event();
  const ::autofill_assistant::SendKeyEventProto& send_key_event() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SendKeyEventProto* release_send_key_event();
  ::autofill_assistant::SendKeyEventProto* mutable_send_key_event();
  void set_allocated_send_key_event(::autofill_assistant::SendKeyEventProto* send_key_event);
  private:
  const ::autofill_assistant::SendKeyEventProto& _internal_send_key_event() const;
  ::autofill_assistant::SendKeyEventProto* _internal_mutable_send_key_event();
  public:
  void unsafe_arena_set_allocated_send_key_event(
      ::autofill_assistant::SendKeyEventProto* send_key_event);
  ::autofill_assistant::SendKeyEventProto* unsafe_arena_release_send_key_event();

  // .autofill_assistant.SelectOptionElementProto select_option_element = 74;
  bool has_select_option_element() const;
  private:
  bool _internal_has_select_option_element() const;
  public:
  void clear_select_option_element();
  const ::autofill_assistant::SelectOptionElementProto& select_option_element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectOptionElementProto* release_select_option_element();
  ::autofill_assistant::SelectOptionElementProto* mutable_select_option_element();
  void set_allocated_select_option_element(::autofill_assistant::SelectOptionElementProto* select_option_element);
  private:
  const ::autofill_assistant::SelectOptionElementProto& _internal_select_option_element() const;
  ::autofill_assistant::SelectOptionElementProto* _internal_mutable_select_option_element();
  public:
  void unsafe_arena_set_allocated_select_option_element(
      ::autofill_assistant::SelectOptionElementProto* select_option_element);
  ::autofill_assistant::SelectOptionElementProto* unsafe_arena_release_select_option_element();

  // .autofill_assistant.CheckElementTagProto check_element_tag = 75;
  bool has_check_element_tag() const;
  private:
  bool _internal_has_check_element_tag() const;
  public:
  void clear_check_element_tag();
  const ::autofill_assistant::CheckElementTagProto& check_element_tag() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CheckElementTagProto* release_check_element_tag();
  ::autofill_assistant::CheckElementTagProto* mutable_check_element_tag();
  void set_allocated_check_element_tag(::autofill_assistant::CheckElementTagProto* check_element_tag);
  private:
  const ::autofill_assistant::CheckElementTagProto& _internal_check_element_tag() const;
  ::autofill_assistant::CheckElementTagProto* _internal_mutable_check_element_tag();
  public:
  void unsafe_arena_set_allocated_check_element_tag(
      ::autofill_assistant::CheckElementTagProto* check_element_tag);
  ::autofill_assistant::CheckElementTagProto* unsafe_arena_release_check_element_tag();

  // .autofill_assistant.CheckOptionElementProto check_option_element = 76;
  bool has_check_option_element() const;
  private:
  bool _internal_has_check_option_element() const;
  public:
  void clear_check_option_element();
  const ::autofill_assistant::CheckOptionElementProto& check_option_element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CheckOptionElementProto* release_check_option_element();
  ::autofill_assistant::CheckOptionElementProto* mutable_check_option_element();
  void set_allocated_check_option_element(::autofill_assistant::CheckOptionElementProto* check_option_element);
  private:
  const ::autofill_assistant::CheckOptionElementProto& _internal_check_option_element() const;
  ::autofill_assistant::CheckOptionElementProto* _internal_mutable_check_option_element();
  public:
  void unsafe_arena_set_allocated_check_option_element(
      ::autofill_assistant::CheckOptionElementProto* check_option_element);
  ::autofill_assistant::CheckOptionElementProto* unsafe_arena_release_check_option_element();

  // .autofill_assistant.SetPersistentUiProto set_persistent_ui = 77;
  bool has_set_persistent_ui() const;
  private:
  bool _internal_has_set_persistent_ui() const;
  public:
  void clear_set_persistent_ui();
  const ::autofill_assistant::SetPersistentUiProto& set_persistent_ui() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetPersistentUiProto* release_set_persistent_ui();
  ::autofill_assistant::SetPersistentUiProto* mutable_set_persistent_ui();
  void set_allocated_set_persistent_ui(::autofill_assistant::SetPersistentUiProto* set_persistent_ui);
  private:
  const ::autofill_assistant::SetPersistentUiProto& _internal_set_persistent_ui() const;
  ::autofill_assistant::SetPersistentUiProto* _internal_mutable_set_persistent_ui();
  public:
  void unsafe_arena_set_allocated_set_persistent_ui(
      ::autofill_assistant::SetPersistentUiProto* set_persistent_ui);
  ::autofill_assistant::SetPersistentUiProto* unsafe_arena_release_set_persistent_ui();

  // .autofill_assistant.ClearPersistentUiProto clear_persistent_ui = 78;
  bool has_clear_persistent_ui() const;
  private:
  bool _internal_has_clear_persistent_ui() const;
  public:
  void clear_clear_persistent_ui();
  const ::autofill_assistant::ClearPersistentUiProto& clear_persistent_ui() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClearPersistentUiProto* release_clear_persistent_ui();
  ::autofill_assistant::ClearPersistentUiProto* mutable_clear_persistent_ui();
  void set_allocated_clear_persistent_ui(::autofill_assistant::ClearPersistentUiProto* clear_persistent_ui);
  private:
  const ::autofill_assistant::ClearPersistentUiProto& _internal_clear_persistent_ui() const;
  ::autofill_assistant::ClearPersistentUiProto* _internal_mutable_clear_persistent_ui();
  public:
  void unsafe_arena_set_allocated_clear_persistent_ui(
      ::autofill_assistant::ClearPersistentUiProto* clear_persistent_ui);
  ::autofill_assistant::ClearPersistentUiProto* unsafe_arena_release_clear_persistent_ui();

  // .autofill_assistant.ScrollIntoViewIfNeededProto scroll_into_view_if_needed = 79;
  bool has_scroll_into_view_if_needed() const;
  private:
  bool _internal_has_scroll_into_view_if_needed() const;
  public:
  void clear_scroll_into_view_if_needed();
  const ::autofill_assistant::ScrollIntoViewIfNeededProto& scroll_into_view_if_needed() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScrollIntoViewIfNeededProto* release_scroll_into_view_if_needed();
  ::autofill_assistant::ScrollIntoViewIfNeededProto* mutable_scroll_into_view_if_needed();
  void set_allocated_scroll_into_view_if_needed(::autofill_assistant::ScrollIntoViewIfNeededProto* scroll_into_view_if_needed);
  private:
  const ::autofill_assistant::ScrollIntoViewIfNeededProto& _internal_scroll_into_view_if_needed() const;
  ::autofill_assistant::ScrollIntoViewIfNeededProto* _internal_mutable_scroll_into_view_if_needed();
  public:
  void unsafe_arena_set_allocated_scroll_into_view_if_needed(
      ::autofill_assistant::ScrollIntoViewIfNeededProto* scroll_into_view_if_needed);
  ::autofill_assistant::ScrollIntoViewIfNeededProto* unsafe_arena_release_scroll_into_view_if_needed();

  // .autofill_assistant.ScrollWindowProto scroll_window = 80;
  bool has_scroll_window() const;
  private:
  bool _internal_has_scroll_window() const;
  public:
  void clear_scroll_window();
  const ::autofill_assistant::ScrollWindowProto& scroll_window() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScrollWindowProto* release_scroll_window();
  ::autofill_assistant::ScrollWindowProto* mutable_scroll_window();
  void set_allocated_scroll_window(::autofill_assistant::ScrollWindowProto* scroll_window);
  private:
  const ::autofill_assistant::ScrollWindowProto& _internal_scroll_window() const;
  ::autofill_assistant::ScrollWindowProto* _internal_mutable_scroll_window();
  public:
  void unsafe_arena_set_allocated_scroll_window(
      ::autofill_assistant::ScrollWindowProto* scroll_window);
  ::autofill_assistant::ScrollWindowProto* unsafe_arena_release_scroll_window();

  // .autofill_assistant.ScrollContainerProto scroll_container = 81;
  bool has_scroll_container() const;
  private:
  bool _internal_has_scroll_container() const;
  public:
  void clear_scroll_container();
  const ::autofill_assistant::ScrollContainerProto& scroll_container() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScrollContainerProto* release_scroll_container();
  ::autofill_assistant::ScrollContainerProto* mutable_scroll_container();
  void set_allocated_scroll_container(::autofill_assistant::ScrollContainerProto* scroll_container);
  private:
  const ::autofill_assistant::ScrollContainerProto& _internal_scroll_container() const;
  ::autofill_assistant::ScrollContainerProto* _internal_mutable_scroll_container();
  public:
  void unsafe_arena_set_allocated_scroll_container(
      ::autofill_assistant::ScrollContainerProto* scroll_container);
  ::autofill_assistant::ScrollContainerProto* unsafe_arena_release_scroll_container();

  // .autofill_assistant.SetTouchableAreaProto set_touchable_area = 82;
  bool has_set_touchable_area() const;
  private:
  bool _internal_has_set_touchable_area() const;
  public:
  void clear_set_touchable_area();
  const ::autofill_assistant::SetTouchableAreaProto& set_touchable_area() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetTouchableAreaProto* release_set_touchable_area();
  ::autofill_assistant::SetTouchableAreaProto* mutable_set_touchable_area();
  void set_allocated_set_touchable_area(::autofill_assistant::SetTouchableAreaProto* set_touchable_area);
  private:
  const ::autofill_assistant::SetTouchableAreaProto& _internal_set_touchable_area() const;
  ::autofill_assistant::SetTouchableAreaProto* _internal_mutable_set_touchable_area();
  public:
  void unsafe_arena_set_allocated_set_touchable_area(
      ::autofill_assistant::SetTouchableAreaProto* set_touchable_area);
  ::autofill_assistant::SetTouchableAreaProto* unsafe_arena_release_set_touchable_area();

  // .autofill_assistant.DeleteSelectedPasswordProto delete_password = 83;
  bool has_delete_password() const;
  private:
  bool _internal_has_delete_password() const;
  public:
  void clear_delete_password();
  const ::autofill_assistant::DeleteSelectedPasswordProto& delete_password() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DeleteSelectedPasswordProto* release_delete_password();
  ::autofill_assistant::DeleteSelectedPasswordProto* mutable_delete_password();
  void set_allocated_delete_password(::autofill_assistant::DeleteSelectedPasswordProto* delete_password);
  private:
  const ::autofill_assistant::DeleteSelectedPasswordProto& _internal_delete_password() const;
  ::autofill_assistant::DeleteSelectedPasswordProto* _internal_mutable_delete_password();
  public:
  void unsafe_arena_set_allocated_delete_password(
      ::autofill_assistant::DeleteSelectedPasswordProto* delete_password);
  ::autofill_assistant::DeleteSelectedPasswordProto* unsafe_arena_release_delete_password();

  // .autofill_assistant.EditSelectedPasswordProto edit_password = 84;
  bool has_edit_password() const;
  private:
  bool _internal_has_edit_password() const;
  public:
  void clear_edit_password();
  const ::autofill_assistant::EditSelectedPasswordProto& edit_password() const;
  PROTOBUF_NODISCARD ::autofill_assistant::EditSelectedPasswordProto* release_edit_password();
  ::autofill_assistant::EditSelectedPasswordProto* mutable_edit_password();
  void set_allocated_edit_password(::autofill_assistant::EditSelectedPasswordProto* edit_password);
  private:
  const ::autofill_assistant::EditSelectedPasswordProto& _internal_edit_password() const;
  ::autofill_assistant::EditSelectedPasswordProto* _internal_mutable_edit_password();
  public:
  void unsafe_arena_set_allocated_edit_password(
      ::autofill_assistant::EditSelectedPasswordProto* edit_password);
  ::autofill_assistant::EditSelectedPasswordProto* unsafe_arena_release_edit_password();

  // .autofill_assistant.BlurFieldProto blur_field = 85;
  bool has_blur_field() const;
  private:
  bool _internal_has_blur_field() const;
  public:
  void clear_blur_field();
  const ::autofill_assistant::BlurFieldProto& blur_field() const;
  PROTOBUF_NODISCARD ::autofill_assistant::BlurFieldProto* release_blur_field();
  ::autofill_assistant::BlurFieldProto* mutable_blur_field();
  void set_allocated_blur_field(::autofill_assistant::BlurFieldProto* blur_field);
  private:
  const ::autofill_assistant::BlurFieldProto& _internal_blur_field() const;
  ::autofill_assistant::BlurFieldProto* _internal_mutable_blur_field();
  public:
  void unsafe_arena_set_allocated_blur_field(
      ::autofill_assistant::BlurFieldProto* blur_field);
  ::autofill_assistant::BlurFieldProto* unsafe_arena_release_blur_field();

  // .autofill_assistant.ResetPendingCredentialsProto reset_pending_credentials = 86;
  bool has_reset_pending_credentials() const;
  private:
  bool _internal_has_reset_pending_credentials() const;
  public:
  void clear_reset_pending_credentials();
  const ::autofill_assistant::ResetPendingCredentialsProto& reset_pending_credentials() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ResetPendingCredentialsProto* release_reset_pending_credentials();
  ::autofill_assistant::ResetPendingCredentialsProto* mutable_reset_pending_credentials();
  void set_allocated_reset_pending_credentials(::autofill_assistant::ResetPendingCredentialsProto* reset_pending_credentials);
  private:
  const ::autofill_assistant::ResetPendingCredentialsProto& _internal_reset_pending_credentials() const;
  ::autofill_assistant::ResetPendingCredentialsProto* _internal_mutable_reset_pending_credentials();
  public:
  void unsafe_arena_set_allocated_reset_pending_credentials(
      ::autofill_assistant::ResetPendingCredentialsProto* reset_pending_credentials);
  ::autofill_assistant::ResetPendingCredentialsProto* unsafe_arena_release_reset_pending_credentials();

  // .autofill_assistant.SaveSubmittedPasswordProto save_submitted_password = 87;
  bool has_save_submitted_password() const;
  private:
  bool _internal_has_save_submitted_password() const;
  public:
  void clear_save_submitted_password();
  const ::autofill_assistant::SaveSubmittedPasswordProto& save_submitted_password() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SaveSubmittedPasswordProto* release_save_submitted_password();
  ::autofill_assistant::SaveSubmittedPasswordProto* mutable_save_submitted_password();
  void set_allocated_save_submitted_password(::autofill_assistant::SaveSubmittedPasswordProto* save_submitted_password);
  private:
  const ::autofill_assistant::SaveSubmittedPasswordProto& _internal_save_submitted_password() const;
  ::autofill_assistant::SaveSubmittedPasswordProto* _internal_mutable_save_submitted_password();
  public:
  void unsafe_arena_set_allocated_save_submitted_password(
      ::autofill_assistant::SaveSubmittedPasswordProto* save_submitted_password);
  ::autofill_assistant::SaveSubmittedPasswordProto* unsafe_arena_release_save_submitted_password();

  // .autofill_assistant.UpdateClientSettingsProto update_client_settings = 89;
  bool has_update_client_settings() const;
  private:
  bool _internal_has_update_client_settings() const;
  public:
  void clear_update_client_settings();
  const ::autofill_assistant::UpdateClientSettingsProto& update_client_settings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UpdateClientSettingsProto* release_update_client_settings();
  ::autofill_assistant::UpdateClientSettingsProto* mutable_update_client_settings();
  void set_allocated_update_client_settings(::autofill_assistant::UpdateClientSettingsProto* update_client_settings);
  private:
  const ::autofill_assistant::UpdateClientSettingsProto& _internal_update_client_settings() const;
  ::autofill_assistant::UpdateClientSettingsProto* _internal_mutable_update_client_settings();
  public:
  void unsafe_arena_set_allocated_update_client_settings(
      ::autofill_assistant::UpdateClientSettingsProto* update_client_settings);
  ::autofill_assistant::UpdateClientSettingsProto* unsafe_arena_release_update_client_settings();

  // .autofill_assistant.JsFlowProto js_flow = 92;
  bool has_js_flow() const;
  private:
  bool _internal_has_js_flow() const;
  public:
  void clear_js_flow();
  const ::autofill_assistant::JsFlowProto& js_flow() const;
  PROTOBUF_NODISCARD ::autofill_assistant::JsFlowProto* release_js_flow();
  ::autofill_assistant::JsFlowProto* mutable_js_flow();
  void set_allocated_js_flow(::autofill_assistant::JsFlowProto* js_flow);
  private:
  const ::autofill_assistant::JsFlowProto& _internal_js_flow() const;
  ::autofill_assistant::JsFlowProto* _internal_mutable_js_flow();
  public:
  void unsafe_arena_set_allocated_js_flow(
      ::autofill_assistant::JsFlowProto* js_flow);
  ::autofill_assistant::JsFlowProto* unsafe_arena_release_js_flow();

  // .autofill_assistant.ExecuteJsProto execute_js = 93;
  bool has_execute_js() const;
  private:
  bool _internal_has_execute_js() const;
  public:
  void clear_execute_js();
  const ::autofill_assistant::ExecuteJsProto& execute_js() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ExecuteJsProto* release_execute_js();
  ::autofill_assistant::ExecuteJsProto* mutable_execute_js();
  void set_allocated_execute_js(::autofill_assistant::ExecuteJsProto* execute_js);
  private:
  const ::autofill_assistant::ExecuteJsProto& _internal_execute_js() const;
  ::autofill_assistant::ExecuteJsProto* _internal_mutable_execute_js();
  public:
  void unsafe_arena_set_allocated_execute_js(
      ::autofill_assistant::ExecuteJsProto* execute_js);
  ::autofill_assistant::ExecuteJsProto* unsafe_arena_release_execute_js();

  // .autofill_assistant.RegisterPasswordResetRequestProto register_password_reset_request = 94;
  bool has_register_password_reset_request() const;
  private:
  bool _internal_has_register_password_reset_request() const;
  public:
  void clear_register_password_reset_request();
  const ::autofill_assistant::RegisterPasswordResetRequestProto& register_password_reset_request() const;
  PROTOBUF_NODISCARD ::autofill_assistant::RegisterPasswordResetRequestProto* release_register_password_reset_request();
  ::autofill_assistant::RegisterPasswordResetRequestProto* mutable_register_password_reset_request();
  void set_allocated_register_password_reset_request(::autofill_assistant::RegisterPasswordResetRequestProto* register_password_reset_request);
  private:
  const ::autofill_assistant::RegisterPasswordResetRequestProto& _internal_register_password_reset_request() const;
  ::autofill_assistant::RegisterPasswordResetRequestProto* _internal_mutable_register_password_reset_request();
  public:
  void unsafe_arena_set_allocated_register_password_reset_request(
      ::autofill_assistant::RegisterPasswordResetRequestProto* register_password_reset_request);
  ::autofill_assistant::RegisterPasswordResetRequestProto* unsafe_arena_release_register_password_reset_request();

  // .autofill_assistant.ExternalActionProto external_action = 95;
  bool has_external_action() const;
  private:
  bool _internal_has_external_action() const;
  public:
  void clear_external_action();
  const ::autofill_assistant::ExternalActionProto& external_action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ExternalActionProto* release_external_action();
  ::autofill_assistant::ExternalActionProto* mutable_external_action();
  void set_allocated_external_action(::autofill_assistant::ExternalActionProto* external_action);
  private:
  const ::autofill_assistant::ExternalActionProto& _internal_external_action() const;
  ::autofill_assistant::ExternalActionProto* _internal_mutable_external_action();
  public:
  void unsafe_arena_set_allocated_external_action(
      ::autofill_assistant::ExternalActionProto* external_action);
  ::autofill_assistant::ExternalActionProto* unsafe_arena_release_external_action();

  // .autofill_assistant.SetNativeValueProto set_native_value = 96;
  bool has_set_native_value() const;
  private:
  bool _internal_has_set_native_value() const;
  public:
  void clear_set_native_value();
  const ::autofill_assistant::SetNativeValueProto& set_native_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetNativeValueProto* release_set_native_value();
  ::autofill_assistant::SetNativeValueProto* mutable_set_native_value();
  void set_allocated_set_native_value(::autofill_assistant::SetNativeValueProto* set_native_value);
  private:
  const ::autofill_assistant::SetNativeValueProto& _internal_set_native_value() const;
  ::autofill_assistant::SetNativeValueProto* _internal_mutable_set_native_value();
  public:
  void unsafe_arena_set_allocated_set_native_value(
      ::autofill_assistant::SetNativeValueProto* set_native_value);
  ::autofill_assistant::SetNativeValueProto* unsafe_arena_release_set_native_value();

  // .autofill_assistant.SetNativeCheckedProto set_native_checked = 97;
  bool has_set_native_checked() const;
  private:
  bool _internal_has_set_native_checked() const;
  public:
  void clear_set_native_checked();
  const ::autofill_assistant::SetNativeCheckedProto& set_native_checked() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SetNativeCheckedProto* release_set_native_checked();
  ::autofill_assistant::SetNativeCheckedProto* mutable_set_native_checked();
  void set_allocated_set_native_checked(::autofill_assistant::SetNativeCheckedProto* set_native_checked);
  private:
  const ::autofill_assistant::SetNativeCheckedProto& _internal_set_native_checked() const;
  ::autofill_assistant::SetNativeCheckedProto* _internal_mutable_set_native_checked();
  public:
  void unsafe_arena_set_allocated_set_native_checked(
      ::autofill_assistant::SetNativeCheckedProto* set_native_checked);
  ::autofill_assistant::SetNativeCheckedProto* unsafe_arena_release_set_native_checked();

  // .autofill_assistant.PromptQrCodeScanProto prompt_qr_code_scan = 98;
  bool has_prompt_qr_code_scan() const;
  private:
  bool _internal_has_prompt_qr_code_scan() const;
  public:
  void clear_prompt_qr_code_scan();
  const ::autofill_assistant::PromptQrCodeScanProto& prompt_qr_code_scan() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PromptQrCodeScanProto* release_prompt_qr_code_scan();
  ::autofill_assistant::PromptQrCodeScanProto* mutable_prompt_qr_code_scan();
  void set_allocated_prompt_qr_code_scan(::autofill_assistant::PromptQrCodeScanProto* prompt_qr_code_scan);
  private:
  const ::autofill_assistant::PromptQrCodeScanProto& _internal_prompt_qr_code_scan() const;
  ::autofill_assistant::PromptQrCodeScanProto* _internal_mutable_prompt_qr_code_scan();
  public:
  void unsafe_arena_set_allocated_prompt_qr_code_scan(
      ::autofill_assistant::PromptQrCodeScanProto* prompt_qr_code_scan);
  ::autofill_assistant::PromptQrCodeScanProto* unsafe_arena_release_prompt_qr_code_scan();

  void clear_action_info();
  ActionInfoCase action_info_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ActionProto)
 private:
  class _Internal;
  void set_has_select_option();
  void set_has_navigate();
  void set_has_prompt();
  void set_has_tell();
  void set_has_show_cast();
  void set_has_wait_for_dom();
  void set_has_use_card();
  void set_has_use_address();
  void set_has_upload_dom();
  void set_has_show_progress_bar();
  void set_has_show_details();
  void set_has_stop();
  void set_has_collect_user_data();
  void set_has_set_attribute();
  void set_has_show_info_box();
  void set_has_expect_navigation();
  void set_has_wait_for_navigation();
  void set_has_configure_bottom_sheet();
  void set_has_show_form();
  void set_has_popup_message();
  void set_has_wait_for_document();
  void set_has_show_generic_ui();
  void set_has_generate_password_for_form_field();
  void set_has_save_generated_password();
  void set_has_configure_ui_state();
  void set_has_presave_generated_password();
  void set_has_get_element_status();
  void set_has_scroll_into_view();
  void set_has_wait_for_document_to_become_interactive();
  void set_has_wait_for_document_to_become_complete();
  void set_has_send_click_event();
  void set_has_send_tap_event();
  void set_has_js_click();
  void set_has_send_keystroke_events();
  void set_has_send_change_event();
  void set_has_set_element_attribute();
  void set_has_select_field_value();
  void set_has_focus_field();
  void set_has_wait_for_element_to_become_stable();
  void set_has_check_element_is_on_top();
  void set_has_release_elements();
  void set_has_dispatch_js_event();
  void set_has_send_key_event();
  void set_has_select_option_element();
  void set_has_check_element_tag();
  void set_has_check_option_element();
  void set_has_set_persistent_ui();
  void set_has_clear_persistent_ui();
  void set_has_scroll_into_view_if_needed();
  void set_has_scroll_window();
  void set_has_scroll_container();
  void set_has_set_touchable_area();
  void set_has_delete_password();
  void set_has_edit_password();
  void set_has_blur_field();
  void set_has_reset_pending_credentials();
  void set_has_save_submitted_password();
  void set_has_update_client_settings();
  void set_has_js_flow();
  void set_has_execute_js();
  void set_has_register_password_reset_request();
  void set_has_external_action();
  void set_has_set_native_value();
  void set_has_set_native_checked();
  void set_has_prompt_qr_code_scan();

  inline bool has_action_info() const;
  inline void clear_has_action_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_payload_;
  int32_t action_delay_ms_;
  bool clean_contextual_ui_;
  union ActionInfoUnion {
    constexpr ActionInfoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::SelectOptionProto* select_option_;
    ::autofill_assistant::NavigateProto* navigate_;
    ::autofill_assistant::PromptProto* prompt_;
    ::autofill_assistant::TellProto* tell_;
    ::autofill_assistant::ShowCastProto* show_cast_;
    ::autofill_assistant::WaitForDomProto* wait_for_dom_;
    ::autofill_assistant::UseCreditCardProto* use_card_;
    ::autofill_assistant::UseAddressProto* use_address_;
    ::autofill_assistant::UploadDomProto* upload_dom_;
    ::autofill_assistant::ShowProgressBarProto* show_progress_bar_;
    ::autofill_assistant::ShowDetailsProto* show_details_;
    ::autofill_assistant::StopProto* stop_;
    ::autofill_assistant::CollectUserDataProto* collect_user_data_;
    ::autofill_assistant::SetAttributeProto* set_attribute_;
    ::autofill_assistant::ShowInfoBoxProto* show_info_box_;
    ::autofill_assistant::ExpectNavigationProto* expect_navigation_;
    ::autofill_assistant::WaitForNavigationProto* wait_for_navigation_;
    ::autofill_assistant::ConfigureBottomSheetProto* configure_bottom_sheet_;
    ::autofill_assistant::ShowFormProto* show_form_;
    ::autofill_assistant::PopupMessageProto* popup_message_;
    ::autofill_assistant::WaitForDocumentProto* wait_for_document_;
    ::autofill_assistant::ShowGenericUiProto* show_generic_ui_;
    ::autofill_assistant::GeneratePasswordForFormFieldProto* generate_password_for_form_field_;
    ::autofill_assistant::SaveGeneratedPasswordProto* save_generated_password_;
    ::autofill_assistant::ConfigureUiStateProto* configure_ui_state_;
    ::autofill_assistant::PresaveGeneratedPasswordProto* presave_generated_password_;
    ::autofill_assistant::GetElementStatusProto* get_element_status_;
    ::autofill_assistant::ScrollIntoViewProto* scroll_into_view_;
    ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* wait_for_document_to_become_interactive_;
    ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* wait_for_document_to_become_complete_;
    ::autofill_assistant::SendClickEventProto* send_click_event_;
    ::autofill_assistant::SendTapEventProto* send_tap_event_;
    ::autofill_assistant::JsClickProto* js_click_;
    ::autofill_assistant::SendKeystrokeEventsProto* send_keystroke_events_;
    ::autofill_assistant::SendChangeEventProto* send_change_event_;
    ::autofill_assistant::SetElementAttributeProto* set_element_attribute_;
    ::autofill_assistant::SelectFieldValueProto* select_field_value_;
    ::autofill_assistant::FocusFieldProto* focus_field_;
    ::autofill_assistant::WaitForElementToBecomeStableProto* wait_for_element_to_become_stable_;
    ::autofill_assistant::CheckElementIsOnTopProto* check_element_is_on_top_;
    ::autofill_assistant::ReleaseElementsProto* release_elements_;
    ::autofill_assistant::DispatchJsEventProto* dispatch_js_event_;
    ::autofill_assistant::SendKeyEventProto* send_key_event_;
    ::autofill_assistant::SelectOptionElementProto* select_option_element_;
    ::autofill_assistant::CheckElementTagProto* check_element_tag_;
    ::autofill_assistant::CheckOptionElementProto* check_option_element_;
    ::autofill_assistant::SetPersistentUiProto* set_persistent_ui_;
    ::autofill_assistant::ClearPersistentUiProto* clear_persistent_ui_;
    ::autofill_assistant::ScrollIntoViewIfNeededProto* scroll_into_view_if_needed_;
    ::autofill_assistant::ScrollWindowProto* scroll_window_;
    ::autofill_assistant::ScrollContainerProto* scroll_container_;
    ::autofill_assistant::SetTouchableAreaProto* set_touchable_area_;
    ::autofill_assistant::DeleteSelectedPasswordProto* delete_password_;
    ::autofill_assistant::EditSelectedPasswordProto* edit_password_;
    ::autofill_assistant::BlurFieldProto* blur_field_;
    ::autofill_assistant::ResetPendingCredentialsProto* reset_pending_credentials_;
    ::autofill_assistant::SaveSubmittedPasswordProto* save_submitted_password_;
    ::autofill_assistant::UpdateClientSettingsProto* update_client_settings_;
    ::autofill_assistant::JsFlowProto* js_flow_;
    ::autofill_assistant::ExecuteJsProto* execute_js_;
    ::autofill_assistant::RegisterPasswordResetRequestProto* register_password_reset_request_;
    ::autofill_assistant::ExternalActionProto* external_action_;
    ::autofill_assistant::SetNativeValueProto* set_native_value_;
    ::autofill_assistant::SetNativeCheckedProto* set_native_checked_;
    ::autofill_assistant::PromptQrCodeScanProto* prompt_qr_code_scan_;
  } action_info_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CollectUserDataResultProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CollectUserDataResultProto) */ {
 public:
  inline CollectUserDataResultProto() : CollectUserDataResultProto(nullptr) {}
  ~CollectUserDataResultProto() override;
  explicit PROTOBUF_CONSTEXPR CollectUserDataResultProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectUserDataResultProto(const CollectUserDataResultProto& from);
  CollectUserDataResultProto(CollectUserDataResultProto&& from) noexcept
    : CollectUserDataResultProto() {
    *this = ::std::move(from);
  }

  inline CollectUserDataResultProto& operator=(const CollectUserDataResultProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectUserDataResultProto& operator=(CollectUserDataResultProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CollectUserDataResultProto& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadOrTagCase {
    kLoginPayload = 6,
    kLoginTag = 21,
    PAYLOAD_OR_TAG_NOT_SET = 0,
  };

  static inline const CollectUserDataResultProto* internal_default_instance() {
    return reinterpret_cast<const CollectUserDataResultProto*>(
               &_CollectUserDataResultProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CollectUserDataResultProto& a, CollectUserDataResultProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CollectUserDataResultProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectUserDataResultProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectUserDataResultProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectUserDataResultProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CollectUserDataResultProto& from);
  void MergeFrom(const CollectUserDataResultProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectUserDataResultProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CollectUserDataResultProto";
  }
  protected:
  explicit CollectUserDataResultProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetTextInputMemoryKeysFieldNumber = 10,
    kAdditionalSectionsValuesFieldNumber = 15,
    kCardIssuerNetworkFieldNumber = 1,
    kPayerEmailFieldNumber = 3,
    kModelFieldNumber = 9,
    kAdditionalActionIndexFieldNumber = 4,
    kTermsLinkFieldNumber = 5,
    kIsTermsAndConditionsAcceptedFieldNumber = 2,
    kShownToUserFieldNumber = 16,
    kLoginMissingUsernameFieldNumber = 17,
    kLoginPayloadFieldNumber = 6,
    kLoginTagFieldNumber = 21,
  };
  // repeated string set_text_input_memory_keys = 10;
  int set_text_input_memory_keys_size() const;
  private:
  int _internal_set_text_input_memory_keys_size() const;
  public:
  void clear_set_text_input_memory_keys();
  const std::string& set_text_input_memory_keys(int index) const;
  std::string* mutable_set_text_input_memory_keys(int index);
  void set_set_text_input_memory_keys(int index, const std::string& value);
  void set_set_text_input_memory_keys(int index, std::string&& value);
  void set_set_text_input_memory_keys(int index, const char* value);
  void set_set_text_input_memory_keys(int index, const char* value, size_t size);
  std::string* add_set_text_input_memory_keys();
  void add_set_text_input_memory_keys(const std::string& value);
  void add_set_text_input_memory_keys(std::string&& value);
  void add_set_text_input_memory_keys(const char* value);
  void add_set_text_input_memory_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& set_text_input_memory_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_set_text_input_memory_keys();
  private:
  const std::string& _internal_set_text_input_memory_keys(int index) const;
  std::string* _internal_add_set_text_input_memory_keys();
  public:

  // repeated .autofill_assistant.ModelProto.ModelValue additional_sections_values = 15;
  int additional_sections_values_size() const;
  private:
  int _internal_additional_sections_values_size() const;
  public:
  void clear_additional_sections_values();
  ::autofill_assistant::ModelProto_ModelValue* mutable_additional_sections_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >*
      mutable_additional_sections_values();
  private:
  const ::autofill_assistant::ModelProto_ModelValue& _internal_additional_sections_values(int index) const;
  ::autofill_assistant::ModelProto_ModelValue* _internal_add_additional_sections_values();
  public:
  const ::autofill_assistant::ModelProto_ModelValue& additional_sections_values(int index) const;
  ::autofill_assistant::ModelProto_ModelValue* add_additional_sections_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >&
      additional_sections_values() const;

  // optional string card_issuer_network = 1;
  bool has_card_issuer_network() const;
  private:
  bool _internal_has_card_issuer_network() const;
  public:
  void clear_card_issuer_network();
  const std::string& card_issuer_network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_card_issuer_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_card_issuer_network();
  PROTOBUF_NODISCARD std::string* release_card_issuer_network();
  void set_allocated_card_issuer_network(std::string* card_issuer_network);
  private:
  const std::string& _internal_card_issuer_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_card_issuer_network(const std::string& value);
  std::string* _internal_mutable_card_issuer_network();
  public:

  // optional string payer_email = 3;
  bool has_payer_email() const;
  private:
  bool _internal_has_payer_email() const;
  public:
  void clear_payer_email();
  const std::string& payer_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payer_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payer_email();
  PROTOBUF_NODISCARD std::string* release_payer_email();
  void set_allocated_payer_email(std::string* payer_email);
  private:
  const std::string& _internal_payer_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payer_email(const std::string& value);
  std::string* _internal_mutable_payer_email();
  public:

  // optional .autofill_assistant.ModelProto model = 9;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::autofill_assistant::ModelProto& model() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ModelProto* release_model();
  ::autofill_assistant::ModelProto* mutable_model();
  void set_allocated_model(::autofill_assistant::ModelProto* model);
  private:
  const ::autofill_assistant::ModelProto& _internal_model() const;
  ::autofill_assistant::ModelProto* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::autofill_assistant::ModelProto* model);
  ::autofill_assistant::ModelProto* unsafe_arena_release_model();

  // optional int32 additional_action_index = 4;
  bool has_additional_action_index() const;
  private:
  bool _internal_has_additional_action_index() const;
  public:
  void clear_additional_action_index();
  int32_t additional_action_index() const;
  void set_additional_action_index(int32_t value);
  private:
  int32_t _internal_additional_action_index() const;
  void _internal_set_additional_action_index(int32_t value);
  public:

  // optional int32 terms_link = 5;
  bool has_terms_link() const;
  private:
  bool _internal_has_terms_link() const;
  public:
  void clear_terms_link();
  int32_t terms_link() const;
  void set_terms_link(int32_t value);
  private:
  int32_t _internal_terms_link() const;
  void _internal_set_terms_link(int32_t value);
  public:

  // optional bool is_terms_and_conditions_accepted = 2;
  bool has_is_terms_and_conditions_accepted() const;
  private:
  bool _internal_has_is_terms_and_conditions_accepted() const;
  public:
  void clear_is_terms_and_conditions_accepted();
  bool is_terms_and_conditions_accepted() const;
  void set_is_terms_and_conditions_accepted(bool value);
  private:
  bool _internal_is_terms_and_conditions_accepted() const;
  void _internal_set_is_terms_and_conditions_accepted(bool value);
  public:

  // optional bool shown_to_user = 16;
  bool has_shown_to_user() const;
  private:
  bool _internal_has_shown_to_user() const;
  public:
  void clear_shown_to_user();
  bool shown_to_user() const;
  void set_shown_to_user(bool value);
  private:
  bool _internal_shown_to_user() const;
  void _internal_set_shown_to_user(bool value);
  public:

  // optional bool login_missing_username = 17;
  bool has_login_missing_username() const;
  private:
  bool _internal_has_login_missing_username() const;
  public:
  void clear_login_missing_username();
  bool login_missing_username() const;
  void set_login_missing_username(bool value);
  private:
  bool _internal_login_missing_username() const;
  void _internal_set_login_missing_username(bool value);
  public:

  // bytes login_payload = 6;
  bool has_login_payload() const;
  private:
  bool _internal_has_login_payload() const;
  public:
  void clear_login_payload();
  const std::string& login_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_payload();
  PROTOBUF_NODISCARD std::string* release_login_payload();
  void set_allocated_login_payload(std::string* login_payload);
  private:
  const std::string& _internal_login_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_payload(const std::string& value);
  std::string* _internal_mutable_login_payload();
  public:

  // string login_tag = 21;
  bool has_login_tag() const;
  private:
  bool _internal_has_login_tag() const;
  public:
  void clear_login_tag();
  const std::string& login_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_tag();
  PROTOBUF_NODISCARD std::string* release_login_tag();
  void set_allocated_login_tag(std::string* login_tag);
  private:
  const std::string& _internal_login_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_tag(const std::string& value);
  std::string* _internal_mutable_login_tag();
  public:

  void clear_payload_or_tag();
  PayloadOrTagCase payload_or_tag_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.CollectUserDataResultProto)
 private:
  class _Internal;
  void set_has_login_payload();
  void set_has_login_tag();

  inline bool has_payload_or_tag() const;
  inline void clear_has_payload_or_tag();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> set_text_input_memory_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue > additional_sections_values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr card_issuer_network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payer_email_;
  ::autofill_assistant::ModelProto* model_;
  int32_t additional_action_index_;
  int32_t terms_link_;
  bool is_terms_and_conditions_accepted_;
  bool shown_to_user_;
  bool login_missing_username_;
  union PayloadOrTagUnion {
    constexpr PayloadOrTagUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_tag_;
  } payload_or_tag_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ActionTimingStats final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ActionTimingStats) */ {
 public:
  inline ActionTimingStats() : ActionTimingStats(nullptr) {}
  ~ActionTimingStats() override;
  explicit PROTOBUF_CONSTEXPR ActionTimingStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionTimingStats(const ActionTimingStats& from);
  ActionTimingStats(ActionTimingStats&& from) noexcept
    : ActionTimingStats() {
    *this = ::std::move(from);
  }

  inline ActionTimingStats& operator=(const ActionTimingStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionTimingStats& operator=(ActionTimingStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ActionTimingStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionTimingStats* internal_default_instance() {
    return reinterpret_cast<const ActionTimingStats*>(
               &_ActionTimingStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ActionTimingStats& a, ActionTimingStats& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ActionTimingStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionTimingStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionTimingStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionTimingStats>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ActionTimingStats& from);
  void MergeFrom(const ActionTimingStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionTimingStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ActionTimingStats";
  }
  protected:
  explicit ActionTimingStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelayMsFieldNumber = 1,
    kActiveTimeMsFieldNumber = 2,
    kWaitTimeMsFieldNumber = 3,
  };
  // optional int64 delay_ms = 1;
  bool has_delay_ms() const;
  private:
  bool _internal_has_delay_ms() const;
  public:
  void clear_delay_ms();
  int64_t delay_ms() const;
  void set_delay_ms(int64_t value);
  private:
  int64_t _internal_delay_ms() const;
  void _internal_set_delay_ms(int64_t value);
  public:

  // optional int64 active_time_ms = 2;
  bool has_active_time_ms() const;
  private:
  bool _internal_has_active_time_ms() const;
  public:
  void clear_active_time_ms();
  int64_t active_time_ms() const;
  void set_active_time_ms(int64_t value);
  private:
  int64_t _internal_active_time_ms() const;
  void _internal_set_active_time_ms(int64_t value);
  public:

  // optional int64 wait_time_ms = 3;
  bool has_wait_time_ms() const;
  private:
  bool _internal_has_wait_time_ms() const;
  public:
  void clear_wait_time_ms();
  int64_t wait_time_ms() const;
  void set_wait_time_ms(int64_t value);
  private:
  int64_t _internal_wait_time_ms() const;
  void _internal_set_wait_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ActionTimingStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t delay_ms_;
  int64_t active_time_ms_;
  int64_t wait_time_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ProcessedActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ProcessedActionProto) */ {
 public:
  inline ProcessedActionProto() : ProcessedActionProto(nullptr) {}
  ~ProcessedActionProto() override;
  explicit PROTOBUF_CONSTEXPR ProcessedActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessedActionProto(const ProcessedActionProto& from);
  ProcessedActionProto(ProcessedActionProto&& from) noexcept
    : ProcessedActionProto() {
    *this = ::std::move(from);
  }

  inline ProcessedActionProto& operator=(const ProcessedActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessedActionProto& operator=(ProcessedActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProcessedActionProto& default_instance() {
    return *internal_default_instance();
  }
  enum ResultDataCase {
    kPromptChoice = 5,
    kCollectUserDataResult = 15,
    kWaitForDomResult = 22,
    kFormResult = 21,
    kWaitForDocumentResult = 25,
    kShowGenericUiResult = 28,
    kGetElementStatusResult = 31,
    kUploadDomResult = 33,
    kCheckOptionElementResult = 35,
    kSendKeyStrokeEventsResult = 36,
    kJsFlowResult = 37,
    kSaveSubmittedPasswordResult = 38,
    kExternalActionResult = 39,
    RESULT_DATA_NOT_SET = 0,
  };

  static inline const ProcessedActionProto* internal_default_instance() {
    return reinterpret_cast<const ProcessedActionProto*>(
               &_ProcessedActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ProcessedActionProto& a, ProcessedActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ProcessedActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessedActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessedActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessedActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProcessedActionProto& from);
  void MergeFrom(const ProcessedActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessedActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ProcessedActionProto";
  }
  protected:
  explicit ProcessedActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kStatusDetailsFieldNumber = 19,
    kNavigationInfoFieldNumber = 20,
    kTimingStatsFieldNumber = 32,
    kStatusFieldNumber = 2,
    kSlowWarningStatusFieldNumber = 34,
    kRunTimeMsFieldNumber = 23,
    kPromptChoiceFieldNumber = 5,
    kCollectUserDataResultFieldNumber = 15,
    kWaitForDomResultFieldNumber = 22,
    kFormResultFieldNumber = 21,
    kWaitForDocumentResultFieldNumber = 25,
    kShowGenericUiResultFieldNumber = 28,
    kGetElementStatusResultFieldNumber = 31,
    kUploadDomResultFieldNumber = 33,
    kCheckOptionElementResultFieldNumber = 35,
    kSendKeyStrokeEventsResultFieldNumber = 36,
    kJsFlowResultFieldNumber = 37,
    kSaveSubmittedPasswordResultFieldNumber = 38,
    kExternalActionResultFieldNumber = 39,
  };
  // optional .autofill_assistant.ActionProto action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::autofill_assistant::ActionProto& action() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ActionProto* release_action();
  ::autofill_assistant::ActionProto* mutable_action();
  void set_allocated_action(::autofill_assistant::ActionProto* action);
  private:
  const ::autofill_assistant::ActionProto& _internal_action() const;
  ::autofill_assistant::ActionProto* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::autofill_assistant::ActionProto* action);
  ::autofill_assistant::ActionProto* unsafe_arena_release_action();

  // optional .autofill_assistant.ProcessedActionStatusDetailsProto status_details = 19;
  bool has_status_details() const;
  private:
  bool _internal_has_status_details() const;
  public:
  void clear_status_details();
  const ::autofill_assistant::ProcessedActionStatusDetailsProto& status_details() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ProcessedActionStatusDetailsProto* release_status_details();
  ::autofill_assistant::ProcessedActionStatusDetailsProto* mutable_status_details();
  void set_allocated_status_details(::autofill_assistant::ProcessedActionStatusDetailsProto* status_details);
  private:
  const ::autofill_assistant::ProcessedActionStatusDetailsProto& _internal_status_details() const;
  ::autofill_assistant::ProcessedActionStatusDetailsProto* _internal_mutable_status_details();
  public:
  void unsafe_arena_set_allocated_status_details(
      ::autofill_assistant::ProcessedActionStatusDetailsProto* status_details);
  ::autofill_assistant::ProcessedActionStatusDetailsProto* unsafe_arena_release_status_details();

  // optional .autofill_assistant.NavigationInfoProto navigation_info = 20;
  bool has_navigation_info() const;
  private:
  bool _internal_has_navigation_info() const;
  public:
  void clear_navigation_info();
  const ::autofill_assistant::NavigationInfoProto& navigation_info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::NavigationInfoProto* release_navigation_info();
  ::autofill_assistant::NavigationInfoProto* mutable_navigation_info();
  void set_allocated_navigation_info(::autofill_assistant::NavigationInfoProto* navigation_info);
  private:
  const ::autofill_assistant::NavigationInfoProto& _internal_navigation_info() const;
  ::autofill_assistant::NavigationInfoProto* _internal_mutable_navigation_info();
  public:
  void unsafe_arena_set_allocated_navigation_info(
      ::autofill_assistant::NavigationInfoProto* navigation_info);
  ::autofill_assistant::NavigationInfoProto* unsafe_arena_release_navigation_info();

  // optional .autofill_assistant.ActionTimingStats timing_stats = 32;
  bool has_timing_stats() const;
  private:
  bool _internal_has_timing_stats() const;
  public:
  void clear_timing_stats();
  const ::autofill_assistant::ActionTimingStats& timing_stats() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ActionTimingStats* release_timing_stats();
  ::autofill_assistant::ActionTimingStats* mutable_timing_stats();
  void set_allocated_timing_stats(::autofill_assistant::ActionTimingStats* timing_stats);
  private:
  const ::autofill_assistant::ActionTimingStats& _internal_timing_stats() const;
  ::autofill_assistant::ActionTimingStats* _internal_mutable_timing_stats();
  public:
  void unsafe_arena_set_allocated_timing_stats(
      ::autofill_assistant::ActionTimingStats* timing_stats);
  ::autofill_assistant::ActionTimingStats* unsafe_arena_release_timing_stats();

  // optional .autofill_assistant.ProcessedActionStatusProto status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::autofill_assistant::ProcessedActionStatusProto status() const;
  void set_status(::autofill_assistant::ProcessedActionStatusProto value);
  private:
  ::autofill_assistant::ProcessedActionStatusProto _internal_status() const;
  void _internal_set_status(::autofill_assistant::ProcessedActionStatusProto value);
  public:

  // optional .autofill_assistant.SlowWarningStatus slow_warning_status = 34;
  bool has_slow_warning_status() const;
  private:
  bool _internal_has_slow_warning_status() const;
  public:
  void clear_slow_warning_status();
  ::autofill_assistant::SlowWarningStatus slow_warning_status() const;
  void set_slow_warning_status(::autofill_assistant::SlowWarningStatus value);
  private:
  ::autofill_assistant::SlowWarningStatus _internal_slow_warning_status() const;
  void _internal_set_slow_warning_status(::autofill_assistant::SlowWarningStatus value);
  public:

  // optional int64 run_time_ms = 23;
  bool has_run_time_ms() const;
  private:
  bool _internal_has_run_time_ms() const;
  public:
  void clear_run_time_ms();
  int64_t run_time_ms() const;
  void set_run_time_ms(int64_t value);
  private:
  int64_t _internal_run_time_ms() const;
  void _internal_set_run_time_ms(int64_t value);
  public:

  // .autofill_assistant.PromptProto.Result prompt_choice = 5;
  bool has_prompt_choice() const;
  private:
  bool _internal_has_prompt_choice() const;
  public:
  void clear_prompt_choice();
  const ::autofill_assistant::PromptProto_Result& prompt_choice() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PromptProto_Result* release_prompt_choice();
  ::autofill_assistant::PromptProto_Result* mutable_prompt_choice();
  void set_allocated_prompt_choice(::autofill_assistant::PromptProto_Result* prompt_choice);
  private:
  const ::autofill_assistant::PromptProto_Result& _internal_prompt_choice() const;
  ::autofill_assistant::PromptProto_Result* _internal_mutable_prompt_choice();
  public:
  void unsafe_arena_set_allocated_prompt_choice(
      ::autofill_assistant::PromptProto_Result* prompt_choice);
  ::autofill_assistant::PromptProto_Result* unsafe_arena_release_prompt_choice();

  // .autofill_assistant.CollectUserDataResultProto collect_user_data_result = 15;
  bool has_collect_user_data_result() const;
  private:
  bool _internal_has_collect_user_data_result() const;
  public:
  void clear_collect_user_data_result();
  const ::autofill_assistant::CollectUserDataResultProto& collect_user_data_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CollectUserDataResultProto* release_collect_user_data_result();
  ::autofill_assistant::CollectUserDataResultProto* mutable_collect_user_data_result();
  void set_allocated_collect_user_data_result(::autofill_assistant::CollectUserDataResultProto* collect_user_data_result);
  private:
  const ::autofill_assistant::CollectUserDataResultProto& _internal_collect_user_data_result() const;
  ::autofill_assistant::CollectUserDataResultProto* _internal_mutable_collect_user_data_result();
  public:
  void unsafe_arena_set_allocated_collect_user_data_result(
      ::autofill_assistant::CollectUserDataResultProto* collect_user_data_result);
  ::autofill_assistant::CollectUserDataResultProto* unsafe_arena_release_collect_user_data_result();

  // .autofill_assistant.WaitForDomProto.Result wait_for_dom_result = 22;
  bool has_wait_for_dom_result() const;
  private:
  bool _internal_has_wait_for_dom_result() const;
  public:
  void clear_wait_for_dom_result();
  const ::autofill_assistant::WaitForDomProto_Result& wait_for_dom_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForDomProto_Result* release_wait_for_dom_result();
  ::autofill_assistant::WaitForDomProto_Result* mutable_wait_for_dom_result();
  void set_allocated_wait_for_dom_result(::autofill_assistant::WaitForDomProto_Result* wait_for_dom_result);
  private:
  const ::autofill_assistant::WaitForDomProto_Result& _internal_wait_for_dom_result() const;
  ::autofill_assistant::WaitForDomProto_Result* _internal_mutable_wait_for_dom_result();
  public:
  void unsafe_arena_set_allocated_wait_for_dom_result(
      ::autofill_assistant::WaitForDomProto_Result* wait_for_dom_result);
  ::autofill_assistant::WaitForDomProto_Result* unsafe_arena_release_wait_for_dom_result();

  // .autofill_assistant.FormProto.Result form_result = 21;
  bool has_form_result() const;
  private:
  bool _internal_has_form_result() const;
  public:
  void clear_form_result();
  const ::autofill_assistant::FormProto_Result& form_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::FormProto_Result* release_form_result();
  ::autofill_assistant::FormProto_Result* mutable_form_result();
  void set_allocated_form_result(::autofill_assistant::FormProto_Result* form_result);
  private:
  const ::autofill_assistant::FormProto_Result& _internal_form_result() const;
  ::autofill_assistant::FormProto_Result* _internal_mutable_form_result();
  public:
  void unsafe_arena_set_allocated_form_result(
      ::autofill_assistant::FormProto_Result* form_result);
  ::autofill_assistant::FormProto_Result* unsafe_arena_release_form_result();

  // .autofill_assistant.WaitForDocumentProto.Result wait_for_document_result = 25;
  bool has_wait_for_document_result() const;
  private:
  bool _internal_has_wait_for_document_result() const;
  public:
  void clear_wait_for_document_result();
  const ::autofill_assistant::WaitForDocumentProto_Result& wait_for_document_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WaitForDocumentProto_Result* release_wait_for_document_result();
  ::autofill_assistant::WaitForDocumentProto_Result* mutable_wait_for_document_result();
  void set_allocated_wait_for_document_result(::autofill_assistant::WaitForDocumentProto_Result* wait_for_document_result);
  private:
  const ::autofill_assistant::WaitForDocumentProto_Result& _internal_wait_for_document_result() const;
  ::autofill_assistant::WaitForDocumentProto_Result* _internal_mutable_wait_for_document_result();
  public:
  void unsafe_arena_set_allocated_wait_for_document_result(
      ::autofill_assistant::WaitForDocumentProto_Result* wait_for_document_result);
  ::autofill_assistant::WaitForDocumentProto_Result* unsafe_arena_release_wait_for_document_result();

  // .autofill_assistant.ShowGenericUiProto.Result show_generic_ui_result = 28;
  bool has_show_generic_ui_result() const;
  private:
  bool _internal_has_show_generic_ui_result() const;
  public:
  void clear_show_generic_ui_result();
  const ::autofill_assistant::ShowGenericUiProto_Result& show_generic_ui_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowGenericUiProto_Result* release_show_generic_ui_result();
  ::autofill_assistant::ShowGenericUiProto_Result* mutable_show_generic_ui_result();
  void set_allocated_show_generic_ui_result(::autofill_assistant::ShowGenericUiProto_Result* show_generic_ui_result);
  private:
  const ::autofill_assistant::ShowGenericUiProto_Result& _internal_show_generic_ui_result() const;
  ::autofill_assistant::ShowGenericUiProto_Result* _internal_mutable_show_generic_ui_result();
  public:
  void unsafe_arena_set_allocated_show_generic_ui_result(
      ::autofill_assistant::ShowGenericUiProto_Result* show_generic_ui_result);
  ::autofill_assistant::ShowGenericUiProto_Result* unsafe_arena_release_show_generic_ui_result();

  // .autofill_assistant.GetElementStatusProto.Result get_element_status_result = 31;
  bool has_get_element_status_result() const;
  private:
  bool _internal_has_get_element_status_result() const;
  public:
  void clear_get_element_status_result();
  const ::autofill_assistant::GetElementStatusProto_Result& get_element_status_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto_Result* release_get_element_status_result();
  ::autofill_assistant::GetElementStatusProto_Result* mutable_get_element_status_result();
  void set_allocated_get_element_status_result(::autofill_assistant::GetElementStatusProto_Result* get_element_status_result);
  private:
  const ::autofill_assistant::GetElementStatusProto_Result& _internal_get_element_status_result() const;
  ::autofill_assistant::GetElementStatusProto_Result* _internal_mutable_get_element_status_result();
  public:
  void unsafe_arena_set_allocated_get_element_status_result(
      ::autofill_assistant::GetElementStatusProto_Result* get_element_status_result);
  ::autofill_assistant::GetElementStatusProto_Result* unsafe_arena_release_get_element_status_result();

  // .autofill_assistant.UploadDomProto.Result upload_dom_result = 33;
  bool has_upload_dom_result() const;
  private:
  bool _internal_has_upload_dom_result() const;
  public:
  void clear_upload_dom_result();
  const ::autofill_assistant::UploadDomProto_Result& upload_dom_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UploadDomProto_Result* release_upload_dom_result();
  ::autofill_assistant::UploadDomProto_Result* mutable_upload_dom_result();
  void set_allocated_upload_dom_result(::autofill_assistant::UploadDomProto_Result* upload_dom_result);
  private:
  const ::autofill_assistant::UploadDomProto_Result& _internal_upload_dom_result() const;
  ::autofill_assistant::UploadDomProto_Result* _internal_mutable_upload_dom_result();
  public:
  void unsafe_arena_set_allocated_upload_dom_result(
      ::autofill_assistant::UploadDomProto_Result* upload_dom_result);
  ::autofill_assistant::UploadDomProto_Result* unsafe_arena_release_upload_dom_result();

  // .autofill_assistant.CheckOptionElementProto.Result check_option_element_result = 35;
  bool has_check_option_element_result() const;
  private:
  bool _internal_has_check_option_element_result() const;
  public:
  void clear_check_option_element_result();
  const ::autofill_assistant::CheckOptionElementProto_Result& check_option_element_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CheckOptionElementProto_Result* release_check_option_element_result();
  ::autofill_assistant::CheckOptionElementProto_Result* mutable_check_option_element_result();
  void set_allocated_check_option_element_result(::autofill_assistant::CheckOptionElementProto_Result* check_option_element_result);
  private:
  const ::autofill_assistant::CheckOptionElementProto_Result& _internal_check_option_element_result() const;
  ::autofill_assistant::CheckOptionElementProto_Result* _internal_mutable_check_option_element_result();
  public:
  void unsafe_arena_set_allocated_check_option_element_result(
      ::autofill_assistant::CheckOptionElementProto_Result* check_option_element_result);
  ::autofill_assistant::CheckOptionElementProto_Result* unsafe_arena_release_check_option_element_result();

  // .autofill_assistant.SendKeystrokeEventsProto.Result send_key_stroke_events_result = 36;
  bool has_send_key_stroke_events_result() const;
  private:
  bool _internal_has_send_key_stroke_events_result() const;
  public:
  void clear_send_key_stroke_events_result();
  const ::autofill_assistant::SendKeystrokeEventsProto_Result& send_key_stroke_events_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SendKeystrokeEventsProto_Result* release_send_key_stroke_events_result();
  ::autofill_assistant::SendKeystrokeEventsProto_Result* mutable_send_key_stroke_events_result();
  void set_allocated_send_key_stroke_events_result(::autofill_assistant::SendKeystrokeEventsProto_Result* send_key_stroke_events_result);
  private:
  const ::autofill_assistant::SendKeystrokeEventsProto_Result& _internal_send_key_stroke_events_result() const;
  ::autofill_assistant::SendKeystrokeEventsProto_Result* _internal_mutable_send_key_stroke_events_result();
  public:
  void unsafe_arena_set_allocated_send_key_stroke_events_result(
      ::autofill_assistant::SendKeystrokeEventsProto_Result* send_key_stroke_events_result);
  ::autofill_assistant::SendKeystrokeEventsProto_Result* unsafe_arena_release_send_key_stroke_events_result();

  // .autofill_assistant.JsFlowProto.Result js_flow_result = 37;
  bool has_js_flow_result() const;
  private:
  bool _internal_has_js_flow_result() const;
  public:
  void clear_js_flow_result();
  const ::autofill_assistant::JsFlowProto_Result& js_flow_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::JsFlowProto_Result* release_js_flow_result();
  ::autofill_assistant::JsFlowProto_Result* mutable_js_flow_result();
  void set_allocated_js_flow_result(::autofill_assistant::JsFlowProto_Result* js_flow_result);
  private:
  const ::autofill_assistant::JsFlowProto_Result& _internal_js_flow_result() const;
  ::autofill_assistant::JsFlowProto_Result* _internal_mutable_js_flow_result();
  public:
  void unsafe_arena_set_allocated_js_flow_result(
      ::autofill_assistant::JsFlowProto_Result* js_flow_result);
  ::autofill_assistant::JsFlowProto_Result* unsafe_arena_release_js_flow_result();

  // .autofill_assistant.SaveSubmittedPasswordProto.Result save_submitted_password_result = 38;
  bool has_save_submitted_password_result() const;
  private:
  bool _internal_has_save_submitted_password_result() const;
  public:
  void clear_save_submitted_password_result();
  const ::autofill_assistant::SaveSubmittedPasswordProto_Result& save_submitted_password_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SaveSubmittedPasswordProto_Result* release_save_submitted_password_result();
  ::autofill_assistant::SaveSubmittedPasswordProto_Result* mutable_save_submitted_password_result();
  void set_allocated_save_submitted_password_result(::autofill_assistant::SaveSubmittedPasswordProto_Result* save_submitted_password_result);
  private:
  const ::autofill_assistant::SaveSubmittedPasswordProto_Result& _internal_save_submitted_password_result() const;
  ::autofill_assistant::SaveSubmittedPasswordProto_Result* _internal_mutable_save_submitted_password_result();
  public:
  void unsafe_arena_set_allocated_save_submitted_password_result(
      ::autofill_assistant::SaveSubmittedPasswordProto_Result* save_submitted_password_result);
  ::autofill_assistant::SaveSubmittedPasswordProto_Result* unsafe_arena_release_save_submitted_password_result();

  // .autofill_assistant.ExternalActionProto.Result external_action_result = 39;
  bool has_external_action_result() const;
  private:
  bool _internal_has_external_action_result() const;
  public:
  void clear_external_action_result();
  const ::autofill_assistant::ExternalActionProto_Result& external_action_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ExternalActionProto_Result* release_external_action_result();
  ::autofill_assistant::ExternalActionProto_Result* mutable_external_action_result();
  void set_allocated_external_action_result(::autofill_assistant::ExternalActionProto_Result* external_action_result);
  private:
  const ::autofill_assistant::ExternalActionProto_Result& _internal_external_action_result() const;
  ::autofill_assistant::ExternalActionProto_Result* _internal_mutable_external_action_result();
  public:
  void unsafe_arena_set_allocated_external_action_result(
      ::autofill_assistant::ExternalActionProto_Result* external_action_result);
  ::autofill_assistant::ExternalActionProto_Result* unsafe_arena_release_external_action_result();

  void clear_result_data();
  ResultDataCase result_data_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ProcessedActionProto)
 private:
  class _Internal;
  void set_has_prompt_choice();
  void set_has_collect_user_data_result();
  void set_has_wait_for_dom_result();
  void set_has_form_result();
  void set_has_wait_for_document_result();
  void set_has_show_generic_ui_result();
  void set_has_get_element_status_result();
  void set_has_upload_dom_result();
  void set_has_check_option_element_result();
  void set_has_send_key_stroke_events_result();
  void set_has_js_flow_result();
  void set_has_save_submitted_password_result();
  void set_has_external_action_result();

  inline bool has_result_data() const;
  inline void clear_has_result_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ActionProto* action_;
  ::autofill_assistant::ProcessedActionStatusDetailsProto* status_details_;
  ::autofill_assistant::NavigationInfoProto* navigation_info_;
  ::autofill_assistant::ActionTimingStats* timing_stats_;
  int status_;
  int slow_warning_status_;
  int64_t run_time_ms_;
  union ResultDataUnion {
    constexpr ResultDataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::PromptProto_Result* prompt_choice_;
    ::autofill_assistant::CollectUserDataResultProto* collect_user_data_result_;
    ::autofill_assistant::WaitForDomProto_Result* wait_for_dom_result_;
    ::autofill_assistant::FormProto_Result* form_result_;
    ::autofill_assistant::WaitForDocumentProto_Result* wait_for_document_result_;
    ::autofill_assistant::ShowGenericUiProto_Result* show_generic_ui_result_;
    ::autofill_assistant::GetElementStatusProto_Result* get_element_status_result_;
    ::autofill_assistant::UploadDomProto_Result* upload_dom_result_;
    ::autofill_assistant::CheckOptionElementProto_Result* check_option_element_result_;
    ::autofill_assistant::SendKeystrokeEventsProto_Result* send_key_stroke_events_result_;
    ::autofill_assistant::JsFlowProto_Result* js_flow_result_;
    ::autofill_assistant::SaveSubmittedPasswordProto_Result* save_submitted_password_result_;
    ::autofill_assistant::ExternalActionProto_Result* external_action_result_;
  } result_data_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ProcessedActionStatusDetailsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ProcessedActionStatusDetailsProto) */ {
 public:
  inline ProcessedActionStatusDetailsProto() : ProcessedActionStatusDetailsProto(nullptr) {}
  ~ProcessedActionStatusDetailsProto() override;
  explicit PROTOBUF_CONSTEXPR ProcessedActionStatusDetailsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessedActionStatusDetailsProto(const ProcessedActionStatusDetailsProto& from);
  ProcessedActionStatusDetailsProto(ProcessedActionStatusDetailsProto&& from) noexcept
    : ProcessedActionStatusDetailsProto() {
    *this = ::std::move(from);
  }

  inline ProcessedActionStatusDetailsProto& operator=(const ProcessedActionStatusDetailsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessedActionStatusDetailsProto& operator=(ProcessedActionStatusDetailsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProcessedActionStatusDetailsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessedActionStatusDetailsProto* internal_default_instance() {
    return reinterpret_cast<const ProcessedActionStatusDetailsProto*>(
               &_ProcessedActionStatusDetailsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ProcessedActionStatusDetailsProto& a, ProcessedActionStatusDetailsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ProcessedActionStatusDetailsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessedActionStatusDetailsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessedActionStatusDetailsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessedActionStatusDetailsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProcessedActionStatusDetailsProto& from);
  void MergeFrom(const ProcessedActionStatusDetailsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessedActionStatusDetailsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ProcessedActionStatusDetailsProto";
  }
  protected:
  explicit ProcessedActionStatusDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFinderInfoFieldNumber = 6,
    kUnexpectedErrorInfoFieldNumber = 1,
    kAutofillErrorInfoFieldNumber = 3,
    kWebControllerErrorInfoFieldNumber = 5,
    kOriginalStatusFieldNumber = 2,
  };
  // repeated .autofill_assistant.ElementFinderInfoProto element_finder_info = 6;
  int element_finder_info_size() const;
  private:
  int _internal_element_finder_info_size() const;
  public:
  void clear_element_finder_info();
  ::autofill_assistant::ElementFinderInfoProto* mutable_element_finder_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto >*
      mutable_element_finder_info();
  private:
  const ::autofill_assistant::ElementFinderInfoProto& _internal_element_finder_info(int index) const;
  ::autofill_assistant::ElementFinderInfoProto* _internal_add_element_finder_info();
  public:
  const ::autofill_assistant::ElementFinderInfoProto& element_finder_info(int index) const;
  ::autofill_assistant::ElementFinderInfoProto* add_element_finder_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto >&
      element_finder_info() const;

  // optional .autofill_assistant.UnexpectedErrorInfoProto unexpected_error_info = 1;
  bool has_unexpected_error_info() const;
  private:
  bool _internal_has_unexpected_error_info() const;
  public:
  void clear_unexpected_error_info();
  const ::autofill_assistant::UnexpectedErrorInfoProto& unexpected_error_info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::UnexpectedErrorInfoProto* release_unexpected_error_info();
  ::autofill_assistant::UnexpectedErrorInfoProto* mutable_unexpected_error_info();
  void set_allocated_unexpected_error_info(::autofill_assistant::UnexpectedErrorInfoProto* unexpected_error_info);
  private:
  const ::autofill_assistant::UnexpectedErrorInfoProto& _internal_unexpected_error_info() const;
  ::autofill_assistant::UnexpectedErrorInfoProto* _internal_mutable_unexpected_error_info();
  public:
  void unsafe_arena_set_allocated_unexpected_error_info(
      ::autofill_assistant::UnexpectedErrorInfoProto* unexpected_error_info);
  ::autofill_assistant::UnexpectedErrorInfoProto* unsafe_arena_release_unexpected_error_info();

  // optional .autofill_assistant.AutofillErrorInfoProto autofill_error_info = 3;
  bool has_autofill_error_info() const;
  private:
  bool _internal_has_autofill_error_info() const;
  public:
  void clear_autofill_error_info();
  const ::autofill_assistant::AutofillErrorInfoProto& autofill_error_info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillErrorInfoProto* release_autofill_error_info();
  ::autofill_assistant::AutofillErrorInfoProto* mutable_autofill_error_info();
  void set_allocated_autofill_error_info(::autofill_assistant::AutofillErrorInfoProto* autofill_error_info);
  private:
  const ::autofill_assistant::AutofillErrorInfoProto& _internal_autofill_error_info() const;
  ::autofill_assistant::AutofillErrorInfoProto* _internal_mutable_autofill_error_info();
  public:
  void unsafe_arena_set_allocated_autofill_error_info(
      ::autofill_assistant::AutofillErrorInfoProto* autofill_error_info);
  ::autofill_assistant::AutofillErrorInfoProto* unsafe_arena_release_autofill_error_info();

  // optional .autofill_assistant.WebControllerErrorInfoProto web_controller_error_info = 5;
  bool has_web_controller_error_info() const;
  private:
  bool _internal_has_web_controller_error_info() const;
  public:
  void clear_web_controller_error_info();
  const ::autofill_assistant::WebControllerErrorInfoProto& web_controller_error_info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::WebControllerErrorInfoProto* release_web_controller_error_info();
  ::autofill_assistant::WebControllerErrorInfoProto* mutable_web_controller_error_info();
  void set_allocated_web_controller_error_info(::autofill_assistant::WebControllerErrorInfoProto* web_controller_error_info);
  private:
  const ::autofill_assistant::WebControllerErrorInfoProto& _internal_web_controller_error_info() const;
  ::autofill_assistant::WebControllerErrorInfoProto* _internal_mutable_web_controller_error_info();
  public:
  void unsafe_arena_set_allocated_web_controller_error_info(
      ::autofill_assistant::WebControllerErrorInfoProto* web_controller_error_info);
  ::autofill_assistant::WebControllerErrorInfoProto* unsafe_arena_release_web_controller_error_info();

  // optional .autofill_assistant.ProcessedActionStatusProto original_status = 2;
  bool has_original_status() const;
  private:
  bool _internal_has_original_status() const;
  public:
  void clear_original_status();
  ::autofill_assistant::ProcessedActionStatusProto original_status() const;
  void set_original_status(::autofill_assistant::ProcessedActionStatusProto value);
  private:
  ::autofill_assistant::ProcessedActionStatusProto _internal_original_status() const;
  void _internal_set_original_status(::autofill_assistant::ProcessedActionStatusProto value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ProcessedActionStatusDetailsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto > element_finder_info_;
  ::autofill_assistant::UnexpectedErrorInfoProto* unexpected_error_info_;
  ::autofill_assistant::AutofillErrorInfoProto* autofill_error_info_;
  ::autofill_assistant::WebControllerErrorInfoProto* web_controller_error_info_;
  int original_status_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class NavigationInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.NavigationInfoProto) */ {
 public:
  inline NavigationInfoProto() : NavigationInfoProto(nullptr) {}
  ~NavigationInfoProto() override;
  explicit PROTOBUF_CONSTEXPR NavigationInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationInfoProto(const NavigationInfoProto& from);
  NavigationInfoProto(NavigationInfoProto&& from) noexcept
    : NavigationInfoProto() {
    *this = ::std::move(from);
  }

  inline NavigationInfoProto& operator=(const NavigationInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationInfoProto& operator=(NavigationInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NavigationInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationInfoProto* internal_default_instance() {
    return reinterpret_cast<const NavigationInfoProto*>(
               &_NavigationInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(NavigationInfoProto& a, NavigationInfoProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NavigationInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NavigationInfoProto& from);
  void MergeFrom(const NavigationInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NavigationInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.NavigationInfoProto";
  }
  protected:
  explicit NavigationInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartedFieldNumber = 1,
    kEndedFieldNumber = 2,
    kHasErrorFieldNumber = 3,
    kUnexpectedFieldNumber = 4,
  };
  // optional bool started = 1;
  bool has_started() const;
  private:
  bool _internal_has_started() const;
  public:
  void clear_started();
  bool started() const;
  void set_started(bool value);
  private:
  bool _internal_started() const;
  void _internal_set_started(bool value);
  public:

  // optional bool ended = 2;
  bool has_ended() const;
  private:
  bool _internal_has_ended() const;
  public:
  void clear_ended();
  bool ended() const;
  void set_ended(bool value);
  private:
  bool _internal_ended() const;
  void _internal_set_ended(bool value);
  public:

  // optional bool has_error = 3;
  bool has_has_error() const;
  private:
  bool _internal_has_has_error() const;
  public:
  void clear_has_error();
  bool has_error() const;
  void set_has_error(bool value);
  private:
  bool _internal_has_error() const;
  void _internal_set_has_error(bool value);
  public:

  // optional bool unexpected = 4;
  bool has_unexpected() const;
  private:
  bool _internal_has_unexpected() const;
  public:
  void clear_unexpected();
  bool unexpected() const;
  void set_unexpected(bool value);
  private:
  bool _internal_unexpected() const;
  void _internal_set_unexpected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.NavigationInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool started_;
  bool ended_;
  bool has_error_;
  bool unexpected_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UnexpectedErrorInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UnexpectedErrorInfoProto) */ {
 public:
  inline UnexpectedErrorInfoProto() : UnexpectedErrorInfoProto(nullptr) {}
  ~UnexpectedErrorInfoProto() override;
  explicit PROTOBUF_CONSTEXPR UnexpectedErrorInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnexpectedErrorInfoProto(const UnexpectedErrorInfoProto& from);
  UnexpectedErrorInfoProto(UnexpectedErrorInfoProto&& from) noexcept
    : UnexpectedErrorInfoProto() {
    *this = ::std::move(from);
  }

  inline UnexpectedErrorInfoProto& operator=(const UnexpectedErrorInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnexpectedErrorInfoProto& operator=(UnexpectedErrorInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UnexpectedErrorInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnexpectedErrorInfoProto* internal_default_instance() {
    return reinterpret_cast<const UnexpectedErrorInfoProto*>(
               &_UnexpectedErrorInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(UnexpectedErrorInfoProto& a, UnexpectedErrorInfoProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UnexpectedErrorInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnexpectedErrorInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnexpectedErrorInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnexpectedErrorInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UnexpectedErrorInfoProto& from);
  void MergeFrom(const UnexpectedErrorInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnexpectedErrorInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UnexpectedErrorInfoProto";
  }
  protected:
  explicit UnexpectedErrorInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UnexpectedErrorInfoProto_JsExceptionLocation JsExceptionLocation;
  static constexpr JsExceptionLocation UNKNOWN =
    UnexpectedErrorInfoProto_JsExceptionLocation_UNKNOWN;
  static constexpr JsExceptionLocation JS_FLOW_LIBRARY =
    UnexpectedErrorInfoProto_JsExceptionLocation_JS_FLOW_LIBRARY;
  static constexpr JsExceptionLocation JS_FLOW =
    UnexpectedErrorInfoProto_JsExceptionLocation_JS_FLOW;
  static inline bool JsExceptionLocation_IsValid(int value) {
    return UnexpectedErrorInfoProto_JsExceptionLocation_IsValid(value);
  }
  static constexpr JsExceptionLocation JsExceptionLocation_MIN =
    UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_MIN;
  static constexpr JsExceptionLocation JsExceptionLocation_MAX =
    UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_MAX;
  static constexpr int JsExceptionLocation_ARRAYSIZE =
    UnexpectedErrorInfoProto_JsExceptionLocation_JsExceptionLocation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& JsExceptionLocation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, JsExceptionLocation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function JsExceptionLocation_Name.");
    return UnexpectedErrorInfoProto_JsExceptionLocation_Name(enum_t_value);
  }
  static inline bool JsExceptionLocation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      JsExceptionLocation* value) {
    return UnexpectedErrorInfoProto_JsExceptionLocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJsExceptionLineNumbersFieldNumber = 4,
    kJsExceptionColumnNumbersFieldNumber = 5,
    kJsExceptionLocationsFieldNumber = 8,
    kSourceFileFieldNumber = 1,
    kJsExceptionClassnameFieldNumber = 3,
    kDevtoolsErrorMessageFieldNumber = 7,
    kSourceLineNumberFieldNumber = 2,
    kDevtoolsErrorCodeFieldNumber = 6,
  };
  // repeated int32 js_exception_line_numbers = 4;
  int js_exception_line_numbers_size() const;
  private:
  int _internal_js_exception_line_numbers_size() const;
  public:
  void clear_js_exception_line_numbers();
  private:
  int32_t _internal_js_exception_line_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_js_exception_line_numbers() const;
  void _internal_add_js_exception_line_numbers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_js_exception_line_numbers();
  public:
  int32_t js_exception_line_numbers(int index) const;
  void set_js_exception_line_numbers(int index, int32_t value);
  void add_js_exception_line_numbers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      js_exception_line_numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_js_exception_line_numbers();

  // repeated int32 js_exception_column_numbers = 5;
  int js_exception_column_numbers_size() const;
  private:
  int _internal_js_exception_column_numbers_size() const;
  public:
  void clear_js_exception_column_numbers();
  private:
  int32_t _internal_js_exception_column_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_js_exception_column_numbers() const;
  void _internal_add_js_exception_column_numbers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_js_exception_column_numbers();
  public:
  int32_t js_exception_column_numbers(int index) const;
  void set_js_exception_column_numbers(int index, int32_t value);
  void add_js_exception_column_numbers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      js_exception_column_numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_js_exception_column_numbers();

  // repeated .autofill_assistant.UnexpectedErrorInfoProto.JsExceptionLocation js_exception_locations = 8 [packed = true];
  int js_exception_locations_size() const;
  private:
  int _internal_js_exception_locations_size() const;
  public:
  void clear_js_exception_locations();
  private:
  ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation _internal_js_exception_locations(int index) const;
  void _internal_add_js_exception_locations(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_js_exception_locations();
  public:
  ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation js_exception_locations(int index) const;
  void set_js_exception_locations(int index, ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation value);
  void add_js_exception_locations(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& js_exception_locations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_js_exception_locations();

  // optional string source_file = 1;
  bool has_source_file() const;
  private:
  bool _internal_has_source_file() const;
  public:
  void clear_source_file();
  const std::string& source_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_file();
  PROTOBUF_NODISCARD std::string* release_source_file();
  void set_allocated_source_file(std::string* source_file);
  private:
  const std::string& _internal_source_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_file(const std::string& value);
  std::string* _internal_mutable_source_file();
  public:

  // optional string js_exception_classname = 3;
  bool has_js_exception_classname() const;
  private:
  bool _internal_has_js_exception_classname() const;
  public:
  void clear_js_exception_classname();
  const std::string& js_exception_classname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_js_exception_classname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_js_exception_classname();
  PROTOBUF_NODISCARD std::string* release_js_exception_classname();
  void set_allocated_js_exception_classname(std::string* js_exception_classname);
  private:
  const std::string& _internal_js_exception_classname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_js_exception_classname(const std::string& value);
  std::string* _internal_mutable_js_exception_classname();
  public:

  // optional string devtools_error_message = 7;
  bool has_devtools_error_message() const;
  private:
  bool _internal_has_devtools_error_message() const;
  public:
  void clear_devtools_error_message();
  const std::string& devtools_error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devtools_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devtools_error_message();
  PROTOBUF_NODISCARD std::string* release_devtools_error_message();
  void set_allocated_devtools_error_message(std::string* devtools_error_message);
  private:
  const std::string& _internal_devtools_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devtools_error_message(const std::string& value);
  std::string* _internal_mutable_devtools_error_message();
  public:

  // optional int32 source_line_number = 2;
  bool has_source_line_number() const;
  private:
  bool _internal_has_source_line_number() const;
  public:
  void clear_source_line_number();
  int32_t source_line_number() const;
  void set_source_line_number(int32_t value);
  private:
  int32_t _internal_source_line_number() const;
  void _internal_set_source_line_number(int32_t value);
  public:

  // optional int32 devtools_error_code = 6;
  bool has_devtools_error_code() const;
  private:
  bool _internal_has_devtools_error_code() const;
  public:
  void clear_devtools_error_code();
  int32_t devtools_error_code() const;
  void set_devtools_error_code(int32_t value);
  private:
  int32_t _internal_devtools_error_code() const;
  void _internal_set_devtools_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.UnexpectedErrorInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > js_exception_line_numbers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > js_exception_column_numbers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> js_exception_locations_;
  mutable std::atomic<int> _js_exception_locations_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr js_exception_classname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devtools_error_message_;
  int32_t source_line_number_;
  int32_t devtools_error_code_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AutofillErrorInfoProto_AutofillFieldError final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError) */ {
 public:
  inline AutofillErrorInfoProto_AutofillFieldError() : AutofillErrorInfoProto_AutofillFieldError(nullptr) {}
  ~AutofillErrorInfoProto_AutofillFieldError() override;
  explicit PROTOBUF_CONSTEXPR AutofillErrorInfoProto_AutofillFieldError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillErrorInfoProto_AutofillFieldError(const AutofillErrorInfoProto_AutofillFieldError& from);
  AutofillErrorInfoProto_AutofillFieldError(AutofillErrorInfoProto_AutofillFieldError&& from) noexcept
    : AutofillErrorInfoProto_AutofillFieldError() {
    *this = ::std::move(from);
  }

  inline AutofillErrorInfoProto_AutofillFieldError& operator=(const AutofillErrorInfoProto_AutofillFieldError& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillErrorInfoProto_AutofillFieldError& operator=(AutofillErrorInfoProto_AutofillFieldError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillErrorInfoProto_AutofillFieldError& default_instance() {
    return *internal_default_instance();
  }
  enum ErrorTypeCase {
    kNoFallbackValue = 3,
    kStatus = 4,
    kEmptyAfterFallback = 6,
    kFilledAfterClear = 7,
    ERROR_TYPE_NOT_SET = 0,
  };

  static inline const AutofillErrorInfoProto_AutofillFieldError* internal_default_instance() {
    return reinterpret_cast<const AutofillErrorInfoProto_AutofillFieldError*>(
               &_AutofillErrorInfoProto_AutofillFieldError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(AutofillErrorInfoProto_AutofillFieldError& a, AutofillErrorInfoProto_AutofillFieldError& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillErrorInfoProto_AutofillFieldError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillErrorInfoProto_AutofillFieldError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillErrorInfoProto_AutofillFieldError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillErrorInfoProto_AutofillFieldError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillErrorInfoProto_AutofillFieldError& from);
  void MergeFrom(const AutofillErrorInfoProto_AutofillFieldError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillErrorInfoProto_AutofillFieldError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillErrorInfoProto.AutofillFieldError";
  }
  protected:
  explicit AutofillErrorInfoProto_AutofillFieldError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueExpressionFieldNumber = 5,
    kFieldFieldNumber = 1,
    kNoFallbackValueFieldNumber = 3,
    kStatusFieldNumber = 4,
    kEmptyAfterFallbackFieldNumber = 6,
    kFilledAfterClearFieldNumber = 7,
  };
  // optional string value_expression = 5;
  bool has_value_expression() const;
  private:
  bool _internal_has_value_expression() const;
  public:
  void clear_value_expression();
  const std::string& value_expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_expression();
  PROTOBUF_NODISCARD std::string* release_value_expression();
  void set_allocated_value_expression(std::string* value_expression);
  private:
  const std::string& _internal_value_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_expression(const std::string& value);
  std::string* _internal_mutable_value_expression();
  public:

  // optional .autofill_assistant.SelectorProto field = 1;
  bool has_field() const;
  private:
  bool _internal_has_field() const;
  public:
  void clear_field();
  const ::autofill_assistant::SelectorProto& field() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_field();
  ::autofill_assistant::SelectorProto* mutable_field();
  void set_allocated_field(::autofill_assistant::SelectorProto* field);
  private:
  const ::autofill_assistant::SelectorProto& _internal_field() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_field();
  public:
  void unsafe_arena_set_allocated_field(
      ::autofill_assistant::SelectorProto* field);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_field();

  // bool no_fallback_value = 3;
  bool has_no_fallback_value() const;
  private:
  bool _internal_has_no_fallback_value() const;
  public:
  void clear_no_fallback_value();
  bool no_fallback_value() const;
  void set_no_fallback_value(bool value);
  private:
  bool _internal_no_fallback_value() const;
  void _internal_set_no_fallback_value(bool value);
  public:

  // .autofill_assistant.ProcessedActionStatusProto status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::autofill_assistant::ProcessedActionStatusProto status() const;
  void set_status(::autofill_assistant::ProcessedActionStatusProto value);
  private:
  ::autofill_assistant::ProcessedActionStatusProto _internal_status() const;
  void _internal_set_status(::autofill_assistant::ProcessedActionStatusProto value);
  public:

  // bool empty_after_fallback = 6;
  bool has_empty_after_fallback() const;
  private:
  bool _internal_has_empty_after_fallback() const;
  public:
  void clear_empty_after_fallback();
  bool empty_after_fallback() const;
  void set_empty_after_fallback(bool value);
  private:
  bool _internal_empty_after_fallback() const;
  void _internal_set_empty_after_fallback(bool value);
  public:

  // bool filled_after_clear = 7;
  bool has_filled_after_clear() const;
  private:
  bool _internal_has_filled_after_clear() const;
  public:
  void clear_filled_after_clear();
  bool filled_after_clear() const;
  void set_filled_after_clear(bool value);
  private:
  bool _internal_filled_after_clear() const;
  void _internal_set_filled_after_clear(bool value);
  public:

  void clear_error_type();
  ErrorTypeCase error_type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
 private:
  class _Internal;
  void set_has_no_fallback_value();
  void set_has_status();
  void set_has_empty_after_fallback();
  void set_has_filled_after_clear();

  inline bool has_error_type() const;
  inline void clear_has_error_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_expression_;
  ::autofill_assistant::SelectorProto* field_;
  union ErrorTypeUnion {
    constexpr ErrorTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool no_fallback_value_;
    int status_;
    bool empty_after_fallback_;
    bool filled_after_clear_;
  } error_type_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AutofillErrorInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillErrorInfoProto) */ {
 public:
  inline AutofillErrorInfoProto() : AutofillErrorInfoProto(nullptr) {}
  ~AutofillErrorInfoProto() override;
  explicit PROTOBUF_CONSTEXPR AutofillErrorInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillErrorInfoProto(const AutofillErrorInfoProto& from);
  AutofillErrorInfoProto(AutofillErrorInfoProto&& from) noexcept
    : AutofillErrorInfoProto() {
    *this = ::std::move(from);
  }

  inline AutofillErrorInfoProto& operator=(const AutofillErrorInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillErrorInfoProto& operator=(AutofillErrorInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillErrorInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillErrorInfoProto* internal_default_instance() {
    return reinterpret_cast<const AutofillErrorInfoProto*>(
               &_AutofillErrorInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(AutofillErrorInfoProto& a, AutofillErrorInfoProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillErrorInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillErrorInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillErrorInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillErrorInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillErrorInfoProto& from);
  void MergeFrom(const AutofillErrorInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillErrorInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillErrorInfoProto";
  }
  protected:
  explicit AutofillErrorInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillErrorInfoProto_AutofillFieldError AutofillFieldError;

  typedef AutofillErrorInfoProto_GetFullCardFailureType GetFullCardFailureType;
  static constexpr GetFullCardFailureType UNKNOWN_FAILURE_TYPE =
    AutofillErrorInfoProto_GetFullCardFailureType_UNKNOWN_FAILURE_TYPE;
  static constexpr GetFullCardFailureType PROMPT_CLOSED =
    AutofillErrorInfoProto_GetFullCardFailureType_PROMPT_CLOSED;
  static constexpr GetFullCardFailureType VERIFICATION_DECLINED =
    AutofillErrorInfoProto_GetFullCardFailureType_VERIFICATION_DECLINED;
  static constexpr GetFullCardFailureType GENERIC_FAILURE =
    AutofillErrorInfoProto_GetFullCardFailureType_GENERIC_FAILURE;
  static inline bool GetFullCardFailureType_IsValid(int value) {
    return AutofillErrorInfoProto_GetFullCardFailureType_IsValid(value);
  }
  static constexpr GetFullCardFailureType GetFullCardFailureType_MIN =
    AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_MIN;
  static constexpr GetFullCardFailureType GetFullCardFailureType_MAX =
    AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_MAX;
  static constexpr int GetFullCardFailureType_ARRAYSIZE =
    AutofillErrorInfoProto_GetFullCardFailureType_GetFullCardFailureType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& GetFullCardFailureType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GetFullCardFailureType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GetFullCardFailureType_Name.");
    return AutofillErrorInfoProto_GetFullCardFailureType_Name(enum_t_value);
  }
  static inline bool GetFullCardFailureType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GetFullCardFailureType* value) {
    return AutofillErrorInfoProto_GetFullCardFailureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAutofillFieldErrorFieldNumber = 5,
    kClientMemoryAddressKeyNamesFieldNumber = 1,
    kAddressKeyRequestedFieldNumber = 2,
    kAddressPointeeWasNullFieldNumber = 3,
    kAutofillErrorStatusFieldNumber = 4,
    kGetFullCardFailureTypeFieldNumber = 6,
  };
  // repeated .autofill_assistant.AutofillErrorInfoProto.AutofillFieldError autofill_field_error = 5;
  int autofill_field_error_size() const;
  private:
  int _internal_autofill_field_error_size() const;
  public:
  void clear_autofill_field_error();
  ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* mutable_autofill_field_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError >*
      mutable_autofill_field_error();
  private:
  const ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError& _internal_autofill_field_error(int index) const;
  ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* _internal_add_autofill_field_error();
  public:
  const ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError& autofill_field_error(int index) const;
  ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* add_autofill_field_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError >&
      autofill_field_error() const;

  // optional string client_memory_address_key_names = 1;
  bool has_client_memory_address_key_names() const;
  private:
  bool _internal_has_client_memory_address_key_names() const;
  public:
  void clear_client_memory_address_key_names();
  const std::string& client_memory_address_key_names() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_memory_address_key_names(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_memory_address_key_names();
  PROTOBUF_NODISCARD std::string* release_client_memory_address_key_names();
  void set_allocated_client_memory_address_key_names(std::string* client_memory_address_key_names);
  private:
  const std::string& _internal_client_memory_address_key_names() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_memory_address_key_names(const std::string& value);
  std::string* _internal_mutable_client_memory_address_key_names();
  public:

  // optional string address_key_requested = 2;
  bool has_address_key_requested() const;
  private:
  bool _internal_has_address_key_requested() const;
  public:
  void clear_address_key_requested();
  const std::string& address_key_requested() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address_key_requested(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address_key_requested();
  PROTOBUF_NODISCARD std::string* release_address_key_requested();
  void set_allocated_address_key_requested(std::string* address_key_requested);
  private:
  const std::string& _internal_address_key_requested() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address_key_requested(const std::string& value);
  std::string* _internal_mutable_address_key_requested();
  public:

  // optional bool address_pointee_was_null = 3;
  bool has_address_pointee_was_null() const;
  private:
  bool _internal_has_address_pointee_was_null() const;
  public:
  void clear_address_pointee_was_null();
  bool address_pointee_was_null() const;
  void set_address_pointee_was_null(bool value);
  private:
  bool _internal_address_pointee_was_null() const;
  void _internal_set_address_pointee_was_null(bool value);
  public:

  // optional .autofill_assistant.ProcessedActionStatusProto autofill_error_status = 4;
  bool has_autofill_error_status() const;
  private:
  bool _internal_has_autofill_error_status() const;
  public:
  void clear_autofill_error_status();
  ::autofill_assistant::ProcessedActionStatusProto autofill_error_status() const;
  void set_autofill_error_status(::autofill_assistant::ProcessedActionStatusProto value);
  private:
  ::autofill_assistant::ProcessedActionStatusProto _internal_autofill_error_status() const;
  void _internal_set_autofill_error_status(::autofill_assistant::ProcessedActionStatusProto value);
  public:

  // optional .autofill_assistant.AutofillErrorInfoProto.GetFullCardFailureType get_full_card_failure_type = 6;
  bool has_get_full_card_failure_type() const;
  private:
  bool _internal_has_get_full_card_failure_type() const;
  public:
  void clear_get_full_card_failure_type();
  ::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType get_full_card_failure_type() const;
  void set_get_full_card_failure_type(::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType value);
  private:
  ::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType _internal_get_full_card_failure_type() const;
  void _internal_set_get_full_card_failure_type(::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillErrorInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError > autofill_field_error_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_memory_address_key_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_key_requested_;
  bool address_pointee_was_null_;
  int autofill_error_status_;
  int get_full_card_failure_type_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WebControllerErrorInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WebControllerErrorInfoProto) */ {
 public:
  inline WebControllerErrorInfoProto() : WebControllerErrorInfoProto(nullptr) {}
  ~WebControllerErrorInfoProto() override;
  explicit PROTOBUF_CONSTEXPR WebControllerErrorInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebControllerErrorInfoProto(const WebControllerErrorInfoProto& from);
  WebControllerErrorInfoProto(WebControllerErrorInfoProto&& from) noexcept
    : WebControllerErrorInfoProto() {
    *this = ::std::move(from);
  }

  inline WebControllerErrorInfoProto& operator=(const WebControllerErrorInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebControllerErrorInfoProto& operator=(WebControllerErrorInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WebControllerErrorInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebControllerErrorInfoProto* internal_default_instance() {
    return reinterpret_cast<const WebControllerErrorInfoProto*>(
               &_WebControllerErrorInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(WebControllerErrorInfoProto& a, WebControllerErrorInfoProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WebControllerErrorInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebControllerErrorInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebControllerErrorInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebControllerErrorInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WebControllerErrorInfoProto& from);
  void MergeFrom(const WebControllerErrorInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WebControllerErrorInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WebControllerErrorInfoProto";
  }
  protected:
  explicit WebControllerErrorInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WebControllerErrorInfoProto_WebAction WebAction;
  static constexpr WebAction UNSPECIFIED_WEB_ACTION =
    WebControllerErrorInfoProto_WebAction_UNSPECIFIED_WEB_ACTION;
  static constexpr WebAction SCROLL_INTO_VIEW =
    WebControllerErrorInfoProto_WebAction_SCROLL_INTO_VIEW;
  static constexpr WebAction WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE =
    WebControllerErrorInfoProto_WebAction_WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE;
  static constexpr WebAction CLICK_OR_TAP_ELEMENT =
    WebControllerErrorInfoProto_WebAction_CLICK_OR_TAP_ELEMENT;
  static constexpr WebAction SELECT_OPTION =
    WebControllerErrorInfoProto_WebAction_SELECT_OPTION;
  static constexpr WebAction SCROLL_INTO_VIEW_WITH_PADDING =
    WebControllerErrorInfoProto_WebAction_SCROLL_INTO_VIEW_WITH_PADDING;
  static constexpr WebAction GET_FIELD_VALUE =
    WebControllerErrorInfoProto_WebAction_GET_FIELD_VALUE;
  static constexpr WebAction GET_STRING_ATTRIBUTE =
    WebControllerErrorInfoProto_WebAction_GET_STRING_ATTRIBUTE;
  static constexpr WebAction SELECT_FIELD_VALUE =
    WebControllerErrorInfoProto_WebAction_SELECT_FIELD_VALUE;
  static constexpr WebAction SET_VALUE_ATTRIBUTE =
    WebControllerErrorInfoProto_WebAction_SET_VALUE_ATTRIBUTE;
  static constexpr WebAction SET_ATTRIBUTE =
    WebControllerErrorInfoProto_WebAction_SET_ATTRIBUTE;
  static constexpr WebAction SEND_KEYBOARD_INPUT =
    WebControllerErrorInfoProto_WebAction_SEND_KEYBOARD_INPUT;
  static constexpr WebAction GET_OUTER_HTML =
    WebControllerErrorInfoProto_WebAction_GET_OUTER_HTML;
  static constexpr WebAction GET_ELEMENT_TAG =
    WebControllerErrorInfoProto_WebAction_GET_ELEMENT_TAG;
  static constexpr WebAction FOCUS_FIELD =
    WebControllerErrorInfoProto_WebAction_FOCUS_FIELD;
  static constexpr WebAction WAIT_UNTIL_ELEMENT_IS_STABLE =
    WebControllerErrorInfoProto_WebAction_WAIT_UNTIL_ELEMENT_IS_STABLE;
  static constexpr WebAction ON_TOP =
    WebControllerErrorInfoProto_WebAction_ON_TOP;
  static constexpr WebAction WAIT_FOR_DOCUMENT_READY_STATE =
    WebControllerErrorInfoProto_WebAction_WAIT_FOR_DOCUMENT_READY_STATE;
  static constexpr WebAction SEND_CHANGE_EVENT =
    WebControllerErrorInfoProto_WebAction_SEND_CHANGE_EVENT;
  static constexpr WebAction DISPATCH_EVENT_ON_DOCUMENT =
    WebControllerErrorInfoProto_WebAction_DISPATCH_EVENT_ON_DOCUMENT;
  static constexpr WebAction SEND_KEY_EVENT =
    WebControllerErrorInfoProto_WebAction_SEND_KEY_EVENT;
  static constexpr WebAction SELECT_OPTION_ELEMENT =
    WebControllerErrorInfoProto_WebAction_SELECT_OPTION_ELEMENT;
  static constexpr WebAction JS_CLICK_ELEMENT =
    WebControllerErrorInfoProto_WebAction_JS_CLICK_ELEMENT;
  static constexpr WebAction CHECK_OPTION_ELEMENT =
    WebControllerErrorInfoProto_WebAction_CHECK_OPTION_ELEMENT;
  static constexpr WebAction SCROLL_INTO_VIEW_IF_NEEDED =
    WebControllerErrorInfoProto_WebAction_SCROLL_INTO_VIEW_IF_NEEDED;
  static constexpr WebAction SCROLL_WINDOW =
    WebControllerErrorInfoProto_WebAction_SCROLL_WINDOW;
  static constexpr WebAction SCROLL_CONTAINER =
    WebControllerErrorInfoProto_WebAction_SCROLL_CONTAINER;
  static constexpr WebAction BLUR_FIELD =
    WebControllerErrorInfoProto_WebAction_BLUR_FIELD;
  static constexpr WebAction EXECUTE_JS =
    WebControllerErrorInfoProto_WebAction_EXECUTE_JS;
  static inline bool WebAction_IsValid(int value) {
    return WebControllerErrorInfoProto_WebAction_IsValid(value);
  }
  static constexpr WebAction WebAction_MIN =
    WebControllerErrorInfoProto_WebAction_WebAction_MIN;
  static constexpr WebAction WebAction_MAX =
    WebControllerErrorInfoProto_WebAction_WebAction_MAX;
  static constexpr int WebAction_ARRAYSIZE =
    WebControllerErrorInfoProto_WebAction_WebAction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& WebAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WebAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WebAction_Name.");
    return WebControllerErrorInfoProto_WebAction_Name(enum_t_value);
  }
  static inline bool WebAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WebAction* value) {
    return WebControllerErrorInfoProto_WebAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFailedWebActionFieldNumber = 1,
  };
  // optional .autofill_assistant.WebControllerErrorInfoProto.WebAction failed_web_action = 1;
  bool has_failed_web_action() const;
  private:
  bool _internal_has_failed_web_action() const;
  public:
  void clear_failed_web_action();
  ::autofill_assistant::WebControllerErrorInfoProto_WebAction failed_web_action() const;
  void set_failed_web_action(::autofill_assistant::WebControllerErrorInfoProto_WebAction value);
  private:
  ::autofill_assistant::WebControllerErrorInfoProto_WebAction _internal_failed_web_action() const;
  void _internal_set_failed_web_action(::autofill_assistant::WebControllerErrorInfoProto_WebAction value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WebControllerErrorInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int failed_web_action_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementFinderInfoProto_PredictedElement final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementFinderInfoProto.PredictedElement) */ {
 public:
  inline ElementFinderInfoProto_PredictedElement() : ElementFinderInfoProto_PredictedElement(nullptr) {}
  ~ElementFinderInfoProto_PredictedElement() override;
  explicit PROTOBUF_CONSTEXPR ElementFinderInfoProto_PredictedElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementFinderInfoProto_PredictedElement(const ElementFinderInfoProto_PredictedElement& from);
  ElementFinderInfoProto_PredictedElement(ElementFinderInfoProto_PredictedElement&& from) noexcept
    : ElementFinderInfoProto_PredictedElement() {
    *this = ::std::move(from);
  }

  inline ElementFinderInfoProto_PredictedElement& operator=(const ElementFinderInfoProto_PredictedElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementFinderInfoProto_PredictedElement& operator=(ElementFinderInfoProto_PredictedElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementFinderInfoProto_PredictedElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementFinderInfoProto_PredictedElement* internal_default_instance() {
    return reinterpret_cast<const ElementFinderInfoProto_PredictedElement*>(
               &_ElementFinderInfoProto_PredictedElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(ElementFinderInfoProto_PredictedElement& a, ElementFinderInfoProto_PredictedElement& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementFinderInfoProto_PredictedElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementFinderInfoProto_PredictedElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementFinderInfoProto_PredictedElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementFinderInfoProto_PredictedElement>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementFinderInfoProto_PredictedElement& from);
  void MergeFrom(const ElementFinderInfoProto_PredictedElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementFinderInfoProto_PredictedElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementFinderInfoProto.PredictedElement";
  }
  protected:
  explicit ElementFinderInfoProto_PredictedElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSemanticFilterFieldNumber = 4,
    kBackendNodeIdFieldNumber = 3,
  };
  // optional .autofill_assistant.SelectorProto.SemanticFilter semantic_filter = 4;
  bool has_semantic_filter() const;
  private:
  bool _internal_has_semantic_filter() const;
  public:
  void clear_semantic_filter();
  const ::autofill_assistant::SelectorProto_SemanticFilter& semantic_filter() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_SemanticFilter* release_semantic_filter();
  ::autofill_assistant::SelectorProto_SemanticFilter* mutable_semantic_filter();
  void set_allocated_semantic_filter(::autofill_assistant::SelectorProto_SemanticFilter* semantic_filter);
  private:
  const ::autofill_assistant::SelectorProto_SemanticFilter& _internal_semantic_filter() const;
  ::autofill_assistant::SelectorProto_SemanticFilter* _internal_mutable_semantic_filter();
  public:
  void unsafe_arena_set_allocated_semantic_filter(
      ::autofill_assistant::SelectorProto_SemanticFilter* semantic_filter);
  ::autofill_assistant::SelectorProto_SemanticFilter* unsafe_arena_release_semantic_filter();

  // optional int32 backend_node_id = 3;
  bool has_backend_node_id() const;
  private:
  bool _internal_has_backend_node_id() const;
  public:
  void clear_backend_node_id();
  int32_t backend_node_id() const;
  void set_backend_node_id(int32_t value);
  private:
  int32_t _internal_backend_node_id() const;
  void _internal_set_backend_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementFinderInfoProto.PredictedElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto_SemanticFilter* semantic_filter_;
  int32_t backend_node_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementFinderInfoProto_SemanticInferenceResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult) */ {
 public:
  inline ElementFinderInfoProto_SemanticInferenceResult() : ElementFinderInfoProto_SemanticInferenceResult(nullptr) {}
  ~ElementFinderInfoProto_SemanticInferenceResult() override;
  explicit PROTOBUF_CONSTEXPR ElementFinderInfoProto_SemanticInferenceResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementFinderInfoProto_SemanticInferenceResult(const ElementFinderInfoProto_SemanticInferenceResult& from);
  ElementFinderInfoProto_SemanticInferenceResult(ElementFinderInfoProto_SemanticInferenceResult&& from) noexcept
    : ElementFinderInfoProto_SemanticInferenceResult() {
    *this = ::std::move(from);
  }

  inline ElementFinderInfoProto_SemanticInferenceResult& operator=(const ElementFinderInfoProto_SemanticInferenceResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementFinderInfoProto_SemanticInferenceResult& operator=(ElementFinderInfoProto_SemanticInferenceResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementFinderInfoProto_SemanticInferenceResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementFinderInfoProto_SemanticInferenceResult* internal_default_instance() {
    return reinterpret_cast<const ElementFinderInfoProto_SemanticInferenceResult*>(
               &_ElementFinderInfoProto_SemanticInferenceResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ElementFinderInfoProto_SemanticInferenceResult& a, ElementFinderInfoProto_SemanticInferenceResult& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementFinderInfoProto_SemanticInferenceResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementFinderInfoProto_SemanticInferenceResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementFinderInfoProto_SemanticInferenceResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementFinderInfoProto_SemanticInferenceResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementFinderInfoProto_SemanticInferenceResult& from);
  void MergeFrom(const ElementFinderInfoProto_SemanticInferenceResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementFinderInfoProto_SemanticInferenceResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult";
  }
  protected:
  explicit ElementFinderInfoProto_SemanticInferenceResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredictedElementsFieldNumber = 1,
    kStatusPerFrameFieldNumber = 2,
  };
  // repeated .autofill_assistant.ElementFinderInfoProto.PredictedElement predicted_elements = 1;
  int predicted_elements_size() const;
  private:
  int _internal_predicted_elements_size() const;
  public:
  void clear_predicted_elements();
  ::autofill_assistant::ElementFinderInfoProto_PredictedElement* mutable_predicted_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto_PredictedElement >*
      mutable_predicted_elements();
  private:
  const ::autofill_assistant::ElementFinderInfoProto_PredictedElement& _internal_predicted_elements(int index) const;
  ::autofill_assistant::ElementFinderInfoProto_PredictedElement* _internal_add_predicted_elements();
  public:
  const ::autofill_assistant::ElementFinderInfoProto_PredictedElement& predicted_elements(int index) const;
  ::autofill_assistant::ElementFinderInfoProto_PredictedElement* add_predicted_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto_PredictedElement >&
      predicted_elements() const;

  // repeated .autofill_assistant.ElementFinderInfoProto.SemanticInferenceStatus status_per_frame = 2;
  int status_per_frame_size() const;
  private:
  int _internal_status_per_frame_size() const;
  public:
  void clear_status_per_frame();
  private:
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus _internal_status_per_frame(int index) const;
  void _internal_add_status_per_frame(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_status_per_frame();
  public:
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus status_per_frame(int index) const;
  void set_status_per_frame(int index, ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus value);
  void add_status_per_frame(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& status_per_frame() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_status_per_frame();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto_PredictedElement > predicted_elements_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> status_per_frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementFinderInfoProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementFinderInfoProto) */ {
 public:
  inline ElementFinderInfoProto() : ElementFinderInfoProto(nullptr) {}
  ~ElementFinderInfoProto() override;
  explicit PROTOBUF_CONSTEXPR ElementFinderInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementFinderInfoProto(const ElementFinderInfoProto& from);
  ElementFinderInfoProto(ElementFinderInfoProto&& from) noexcept
    : ElementFinderInfoProto() {
    *this = ::std::move(from);
  }

  inline ElementFinderInfoProto& operator=(const ElementFinderInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementFinderInfoProto& operator=(ElementFinderInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementFinderInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementFinderInfoProto* internal_default_instance() {
    return reinterpret_cast<const ElementFinderInfoProto*>(
               &_ElementFinderInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(ElementFinderInfoProto& a, ElementFinderInfoProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementFinderInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementFinderInfoProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementFinderInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementFinderInfoProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementFinderInfoProto& from);
  void MergeFrom(const ElementFinderInfoProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementFinderInfoProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementFinderInfoProto";
  }
  protected:
  explicit ElementFinderInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ElementFinderInfoProto_PredictedElement PredictedElement;
  typedef ElementFinderInfoProto_SemanticInferenceResult SemanticInferenceResult;

  typedef ElementFinderInfoProto_SemanticInferenceStatus SemanticInferenceStatus;
  static constexpr SemanticInferenceStatus UNKNOWN =
    ElementFinderInfoProto_SemanticInferenceStatus_UNKNOWN;
  static constexpr SemanticInferenceStatus SUCCESS =
    ElementFinderInfoProto_SemanticInferenceStatus_SUCCESS;
  static constexpr SemanticInferenceStatus UNEXPECTED_ERROR =
    ElementFinderInfoProto_SemanticInferenceStatus_UNEXPECTED_ERROR;
  static constexpr SemanticInferenceStatus INITIALIZATION_ERROR =
    ElementFinderInfoProto_SemanticInferenceStatus_INITIALIZATION_ERROR;
  static constexpr SemanticInferenceStatus MODEL_LOAD_ERROR =
    ElementFinderInfoProto_SemanticInferenceStatus_MODEL_LOAD_ERROR;
  static constexpr SemanticInferenceStatus MODEL_LOAD_TIMEOUT =
    ElementFinderInfoProto_SemanticInferenceStatus_MODEL_LOAD_TIMEOUT;
  static inline bool SemanticInferenceStatus_IsValid(int value) {
    return ElementFinderInfoProto_SemanticInferenceStatus_IsValid(value);
  }
  static constexpr SemanticInferenceStatus SemanticInferenceStatus_MIN =
    ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_MIN;
  static constexpr SemanticInferenceStatus SemanticInferenceStatus_MAX =
    ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_MAX;
  static constexpr int SemanticInferenceStatus_ARRAYSIZE =
    ElementFinderInfoProto_SemanticInferenceStatus_SemanticInferenceStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SemanticInferenceStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SemanticInferenceStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SemanticInferenceStatus_Name.");
    return ElementFinderInfoProto_SemanticInferenceStatus_Name(enum_t_value);
  }
  static inline bool SemanticInferenceStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SemanticInferenceStatus* value) {
    return ElementFinderInfoProto_SemanticInferenceStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSemanticInferenceResultFieldNumber = 6,
    kTrackingIdFieldNumber = 1,
    kFailedFilterIndexRangeStartFieldNumber = 2,
    kFailedFilterIndexRangeEndFieldNumber = 3,
    kStatusFieldNumber = 4,
    kGetDocumentFailedFieldNumber = 5,
  };
  // optional .autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult semantic_inference_result = 6;
  bool has_semantic_inference_result() const;
  private:
  bool _internal_has_semantic_inference_result() const;
  public:
  void clear_semantic_inference_result();
  const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult& semantic_inference_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* release_semantic_inference_result();
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* mutable_semantic_inference_result();
  void set_allocated_semantic_inference_result(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* semantic_inference_result);
  private:
  const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult& _internal_semantic_inference_result() const;
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* _internal_mutable_semantic_inference_result();
  public:
  void unsafe_arena_set_allocated_semantic_inference_result(
      ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* semantic_inference_result);
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* unsafe_arena_release_semantic_inference_result();

  // optional int64 tracking_id = 1;
  bool has_tracking_id() const;
  private:
  bool _internal_has_tracking_id() const;
  public:
  void clear_tracking_id();
  int64_t tracking_id() const;
  void set_tracking_id(int64_t value);
  private:
  int64_t _internal_tracking_id() const;
  void _internal_set_tracking_id(int64_t value);
  public:

  // optional int32 failed_filter_index_range_start = 2;
  bool has_failed_filter_index_range_start() const;
  private:
  bool _internal_has_failed_filter_index_range_start() const;
  public:
  void clear_failed_filter_index_range_start();
  int32_t failed_filter_index_range_start() const;
  void set_failed_filter_index_range_start(int32_t value);
  private:
  int32_t _internal_failed_filter_index_range_start() const;
  void _internal_set_failed_filter_index_range_start(int32_t value);
  public:

  // optional int32 failed_filter_index_range_end = 3;
  bool has_failed_filter_index_range_end() const;
  private:
  bool _internal_has_failed_filter_index_range_end() const;
  public:
  void clear_failed_filter_index_range_end();
  int32_t failed_filter_index_range_end() const;
  void set_failed_filter_index_range_end(int32_t value);
  private:
  int32_t _internal_failed_filter_index_range_end() const;
  void _internal_set_failed_filter_index_range_end(int32_t value);
  public:

  // optional .autofill_assistant.ProcessedActionStatusProto status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::autofill_assistant::ProcessedActionStatusProto status() const;
  void set_status(::autofill_assistant::ProcessedActionStatusProto value);
  private:
  ::autofill_assistant::ProcessedActionStatusProto _internal_status() const;
  void _internal_set_status(::autofill_assistant::ProcessedActionStatusProto value);
  public:

  // optional bool get_document_failed = 5;
  bool has_get_document_failed() const;
  private:
  bool _internal_has_get_document_failed() const;
  public:
  void clear_get_document_failed();
  bool get_document_failed() const;
  void set_get_document_failed(bool value);
  private:
  bool _internal_get_document_failed() const;
  void _internal_set_get_document_failed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementFinderInfoProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* semantic_inference_result_;
  int64_t tracking_id_;
  int32_t failed_filter_index_range_start_;
  int32_t failed_filter_index_range_end_;
  int status_;
  bool get_document_failed_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_Filter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.Filter) */ {
 public:
  inline SelectorProto_Filter() : SelectorProto_Filter(nullptr) {}
  ~SelectorProto_Filter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_Filter(const SelectorProto_Filter& from);
  SelectorProto_Filter(SelectorProto_Filter&& from) noexcept
    : SelectorProto_Filter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_Filter& operator=(const SelectorProto_Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_Filter& operator=(SelectorProto_Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_Filter& default_instance() {
    return *internal_default_instance();
  }
  enum FilterCase {
    kEnterFrame = 1,
    kCssSelector = 2,
    kInnerText = 3,
    kValue = 4,
    kPseudoType = 5,
    kBoundingBox = 6,
    kNthMatch = 7,
    kPseudoElementContent = 8,
    kLabelled = 9,
    kMatchCssSelector = 11,
    kCssStyle = 12,
    kOnTop = 13,
    kProperty = 14,
    kParent = 15,
    kSemantic = 16,
    FILTER_NOT_SET = 0,
  };

  static inline const SelectorProto_Filter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_Filter*>(
               &_SelectorProto_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(SelectorProto_Filter& a, SelectorProto_Filter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_Filter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_Filter& from);
  void MergeFrom(const SelectorProto_Filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.Filter";
  }
  protected:
  explicit SelectorProto_Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnterFrameFieldNumber = 1,
    kCssSelectorFieldNumber = 2,
    kInnerTextFieldNumber = 3,
    kValueFieldNumber = 4,
    kPseudoTypeFieldNumber = 5,
    kBoundingBoxFieldNumber = 6,
    kNthMatchFieldNumber = 7,
    kPseudoElementContentFieldNumber = 8,
    kLabelledFieldNumber = 9,
    kMatchCssSelectorFieldNumber = 11,
    kCssStyleFieldNumber = 12,
    kOnTopFieldNumber = 13,
    kPropertyFieldNumber = 14,
    kParentFieldNumber = 15,
    kSemanticFieldNumber = 16,
  };
  // .autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;
  bool has_enter_frame() const;
  private:
  bool _internal_has_enter_frame() const;
  public:
  void clear_enter_frame();
  const ::autofill_assistant::SelectorProto_EmptyFilter& enter_frame() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_EmptyFilter* release_enter_frame();
  ::autofill_assistant::SelectorProto_EmptyFilter* mutable_enter_frame();
  void set_allocated_enter_frame(::autofill_assistant::SelectorProto_EmptyFilter* enter_frame);
  private:
  const ::autofill_assistant::SelectorProto_EmptyFilter& _internal_enter_frame() const;
  ::autofill_assistant::SelectorProto_EmptyFilter* _internal_mutable_enter_frame();
  public:
  void unsafe_arena_set_allocated_enter_frame(
      ::autofill_assistant::SelectorProto_EmptyFilter* enter_frame);
  ::autofill_assistant::SelectorProto_EmptyFilter* unsafe_arena_release_enter_frame();

  // string css_selector = 2;
  bool has_css_selector() const;
  private:
  bool _internal_has_css_selector() const;
  public:
  void clear_css_selector();
  const std::string& css_selector() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_css_selector(ArgT0&& arg0, ArgT... args);
  std::string* mutable_css_selector();
  PROTOBUF_NODISCARD std::string* release_css_selector();
  void set_allocated_css_selector(std::string* css_selector);
  private:
  const std::string& _internal_css_selector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_css_selector(const std::string& value);
  std::string* _internal_mutable_css_selector();
  public:

  // .autofill_assistant.TextFilter inner_text = 3;
  bool has_inner_text() const;
  private:
  bool _internal_has_inner_text() const;
  public:
  void clear_inner_text();
  const ::autofill_assistant::TextFilter& inner_text() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_inner_text();
  ::autofill_assistant::TextFilter* mutable_inner_text();
  void set_allocated_inner_text(::autofill_assistant::TextFilter* inner_text);
  private:
  const ::autofill_assistant::TextFilter& _internal_inner_text() const;
  ::autofill_assistant::TextFilter* _internal_mutable_inner_text();
  public:
  void unsafe_arena_set_allocated_inner_text(
      ::autofill_assistant::TextFilter* inner_text);
  ::autofill_assistant::TextFilter* unsafe_arena_release_inner_text();

  // .autofill_assistant.TextFilter value = 4;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::TextFilter& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_value();
  ::autofill_assistant::TextFilter* mutable_value();
  void set_allocated_value(::autofill_assistant::TextFilter* value);
  private:
  const ::autofill_assistant::TextFilter& _internal_value() const;
  ::autofill_assistant::TextFilter* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::TextFilter* value);
  ::autofill_assistant::TextFilter* unsafe_arena_release_value();

  // .autofill_assistant.PseudoType pseudo_type = 5;
  bool has_pseudo_type() const;
  private:
  bool _internal_has_pseudo_type() const;
  public:
  void clear_pseudo_type();
  ::autofill_assistant::PseudoType pseudo_type() const;
  void set_pseudo_type(::autofill_assistant::PseudoType value);
  private:
  ::autofill_assistant::PseudoType _internal_pseudo_type() const;
  void _internal_set_pseudo_type(::autofill_assistant::PseudoType value);
  public:

  // .autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;
  bool has_bounding_box() const;
  private:
  bool _internal_has_bounding_box() const;
  public:
  void clear_bounding_box();
  const ::autofill_assistant::SelectorProto_BoundingBoxFilter& bounding_box() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_BoundingBoxFilter* release_bounding_box();
  ::autofill_assistant::SelectorProto_BoundingBoxFilter* mutable_bounding_box();
  void set_allocated_bounding_box(::autofill_assistant::SelectorProto_BoundingBoxFilter* bounding_box);
  private:
  const ::autofill_assistant::SelectorProto_BoundingBoxFilter& _internal_bounding_box() const;
  ::autofill_assistant::SelectorProto_BoundingBoxFilter* _internal_mutable_bounding_box();
  public:
  void unsafe_arena_set_allocated_bounding_box(
      ::autofill_assistant::SelectorProto_BoundingBoxFilter* bounding_box);
  ::autofill_assistant::SelectorProto_BoundingBoxFilter* unsafe_arena_release_bounding_box();

  // .autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;
  bool has_nth_match() const;
  private:
  bool _internal_has_nth_match() const;
  public:
  void clear_nth_match();
  const ::autofill_assistant::SelectorProto_NthMatchFilter& nth_match() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_NthMatchFilter* release_nth_match();
  ::autofill_assistant::SelectorProto_NthMatchFilter* mutable_nth_match();
  void set_allocated_nth_match(::autofill_assistant::SelectorProto_NthMatchFilter* nth_match);
  private:
  const ::autofill_assistant::SelectorProto_NthMatchFilter& _internal_nth_match() const;
  ::autofill_assistant::SelectorProto_NthMatchFilter* _internal_mutable_nth_match();
  public:
  void unsafe_arena_set_allocated_nth_match(
      ::autofill_assistant::SelectorProto_NthMatchFilter* nth_match);
  ::autofill_assistant::SelectorProto_NthMatchFilter* unsafe_arena_release_nth_match();

  // .autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;
  bool has_pseudo_element_content() const;
  private:
  bool _internal_has_pseudo_element_content() const;
  public:
  void clear_pseudo_element_content();
  const ::autofill_assistant::SelectorProto_PseudoElementContent& pseudo_element_content() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_PseudoElementContent* release_pseudo_element_content();
  ::autofill_assistant::SelectorProto_PseudoElementContent* mutable_pseudo_element_content();
  void set_allocated_pseudo_element_content(::autofill_assistant::SelectorProto_PseudoElementContent* pseudo_element_content);
  private:
  const ::autofill_assistant::SelectorProto_PseudoElementContent& _internal_pseudo_element_content() const;
  ::autofill_assistant::SelectorProto_PseudoElementContent* _internal_mutable_pseudo_element_content();
  public:
  void unsafe_arena_set_allocated_pseudo_element_content(
      ::autofill_assistant::SelectorProto_PseudoElementContent* pseudo_element_content);
  ::autofill_assistant::SelectorProto_PseudoElementContent* unsafe_arena_release_pseudo_element_content();

  // .autofill_assistant.SelectorProto.EmptyFilter labelled = 9;
  bool has_labelled() const;
  private:
  bool _internal_has_labelled() const;
  public:
  void clear_labelled();
  const ::autofill_assistant::SelectorProto_EmptyFilter& labelled() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_EmptyFilter* release_labelled();
  ::autofill_assistant::SelectorProto_EmptyFilter* mutable_labelled();
  void set_allocated_labelled(::autofill_assistant::SelectorProto_EmptyFilter* labelled);
  private:
  const ::autofill_assistant::SelectorProto_EmptyFilter& _internal_labelled() const;
  ::autofill_assistant::SelectorProto_EmptyFilter* _internal_mutable_labelled();
  public:
  void unsafe_arena_set_allocated_labelled(
      ::autofill_assistant::SelectorProto_EmptyFilter* labelled);
  ::autofill_assistant::SelectorProto_EmptyFilter* unsafe_arena_release_labelled();

  // string match_css_selector = 11;
  bool has_match_css_selector() const;
  private:
  bool _internal_has_match_css_selector() const;
  public:
  void clear_match_css_selector();
  const std::string& match_css_selector() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_css_selector(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_css_selector();
  PROTOBUF_NODISCARD std::string* release_match_css_selector();
  void set_allocated_match_css_selector(std::string* match_css_selector);
  private:
  const std::string& _internal_match_css_selector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_css_selector(const std::string& value);
  std::string* _internal_mutable_match_css_selector();
  public:

  // .autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;
  bool has_css_style() const;
  private:
  bool _internal_has_css_style() const;
  public:
  void clear_css_style();
  const ::autofill_assistant::SelectorProto_CssStyleFilter& css_style() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_CssStyleFilter* release_css_style();
  ::autofill_assistant::SelectorProto_CssStyleFilter* mutable_css_style();
  void set_allocated_css_style(::autofill_assistant::SelectorProto_CssStyleFilter* css_style);
  private:
  const ::autofill_assistant::SelectorProto_CssStyleFilter& _internal_css_style() const;
  ::autofill_assistant::SelectorProto_CssStyleFilter* _internal_mutable_css_style();
  public:
  void unsafe_arena_set_allocated_css_style(
      ::autofill_assistant::SelectorProto_CssStyleFilter* css_style);
  ::autofill_assistant::SelectorProto_CssStyleFilter* unsafe_arena_release_css_style();

  // .autofill_assistant.SelectorProto.OnTopFilter on_top = 13;
  bool has_on_top() const;
  private:
  bool _internal_has_on_top() const;
  public:
  void clear_on_top();
  const ::autofill_assistant::SelectorProto_OnTopFilter& on_top() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_OnTopFilter* release_on_top();
  ::autofill_assistant::SelectorProto_OnTopFilter* mutable_on_top();
  void set_allocated_on_top(::autofill_assistant::SelectorProto_OnTopFilter* on_top);
  private:
  const ::autofill_assistant::SelectorProto_OnTopFilter& _internal_on_top() const;
  ::autofill_assistant::SelectorProto_OnTopFilter* _internal_mutable_on_top();
  public:
  void unsafe_arena_set_allocated_on_top(
      ::autofill_assistant::SelectorProto_OnTopFilter* on_top);
  ::autofill_assistant::SelectorProto_OnTopFilter* unsafe_arena_release_on_top();

  // .autofill_assistant.SelectorProto.PropertyFilter property = 14;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const ::autofill_assistant::SelectorProto_PropertyFilter& property() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_PropertyFilter* release_property();
  ::autofill_assistant::SelectorProto_PropertyFilter* mutable_property();
  void set_allocated_property(::autofill_assistant::SelectorProto_PropertyFilter* property);
  private:
  const ::autofill_assistant::SelectorProto_PropertyFilter& _internal_property() const;
  ::autofill_assistant::SelectorProto_PropertyFilter* _internal_mutable_property();
  public:
  void unsafe_arena_set_allocated_property(
      ::autofill_assistant::SelectorProto_PropertyFilter* property);
  ::autofill_assistant::SelectorProto_PropertyFilter* unsafe_arena_release_property();

  // .autofill_assistant.SelectorProto.EmptyFilter parent = 15;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::autofill_assistant::SelectorProto_EmptyFilter& parent() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_EmptyFilter* release_parent();
  ::autofill_assistant::SelectorProto_EmptyFilter* mutable_parent();
  void set_allocated_parent(::autofill_assistant::SelectorProto_EmptyFilter* parent);
  private:
  const ::autofill_assistant::SelectorProto_EmptyFilter& _internal_parent() const;
  ::autofill_assistant::SelectorProto_EmptyFilter* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::autofill_assistant::SelectorProto_EmptyFilter* parent);
  ::autofill_assistant::SelectorProto_EmptyFilter* unsafe_arena_release_parent();

  // .autofill_assistant.SelectorProto.SemanticFilter semantic = 16;
  bool has_semantic() const;
  private:
  bool _internal_has_semantic() const;
  public:
  void clear_semantic();
  const ::autofill_assistant::SelectorProto_SemanticFilter& semantic() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto_SemanticFilter* release_semantic();
  ::autofill_assistant::SelectorProto_SemanticFilter* mutable_semantic();
  void set_allocated_semantic(::autofill_assistant::SelectorProto_SemanticFilter* semantic);
  private:
  const ::autofill_assistant::SelectorProto_SemanticFilter& _internal_semantic() const;
  ::autofill_assistant::SelectorProto_SemanticFilter* _internal_mutable_semantic();
  public:
  void unsafe_arena_set_allocated_semantic(
      ::autofill_assistant::SelectorProto_SemanticFilter* semantic);
  ::autofill_assistant::SelectorProto_SemanticFilter* unsafe_arena_release_semantic();

  void clear_filter();
  FilterCase filter_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.Filter)
 private:
  class _Internal;
  void set_has_enter_frame();
  void set_has_css_selector();
  void set_has_inner_text();
  void set_has_value();
  void set_has_pseudo_type();
  void set_has_bounding_box();
  void set_has_nth_match();
  void set_has_pseudo_element_content();
  void set_has_labelled();
  void set_has_match_css_selector();
  void set_has_css_style();
  void set_has_on_top();
  void set_has_property();
  void set_has_parent();
  void set_has_semantic();

  inline bool has_filter() const;
  inline void clear_has_filter();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FilterUnion {
    constexpr FilterUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::SelectorProto_EmptyFilter* enter_frame_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr css_selector_;
    ::autofill_assistant::TextFilter* inner_text_;
    ::autofill_assistant::TextFilter* value_;
    int pseudo_type_;
    ::autofill_assistant::SelectorProto_BoundingBoxFilter* bounding_box_;
    ::autofill_assistant::SelectorProto_NthMatchFilter* nth_match_;
    ::autofill_assistant::SelectorProto_PseudoElementContent* pseudo_element_content_;
    ::autofill_assistant::SelectorProto_EmptyFilter* labelled_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_css_selector_;
    ::autofill_assistant::SelectorProto_CssStyleFilter* css_style_;
    ::autofill_assistant::SelectorProto_OnTopFilter* on_top_;
    ::autofill_assistant::SelectorProto_PropertyFilter* property_;
    ::autofill_assistant::SelectorProto_EmptyFilter* parent_;
    ::autofill_assistant::SelectorProto_SemanticFilter* semantic_;
  } filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_PropertyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.PropertyFilter) */ {
 public:
  inline SelectorProto_PropertyFilter() : SelectorProto_PropertyFilter(nullptr) {}
  ~SelectorProto_PropertyFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_PropertyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_PropertyFilter(const SelectorProto_PropertyFilter& from);
  SelectorProto_PropertyFilter(SelectorProto_PropertyFilter&& from) noexcept
    : SelectorProto_PropertyFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_PropertyFilter& operator=(const SelectorProto_PropertyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_PropertyFilter& operator=(SelectorProto_PropertyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_PropertyFilter& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kTextFilter = 2,
    kAutofillValueRegexp = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const SelectorProto_PropertyFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_PropertyFilter*>(
               &_SelectorProto_PropertyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(SelectorProto_PropertyFilter& a, SelectorProto_PropertyFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_PropertyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_PropertyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_PropertyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_PropertyFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_PropertyFilter& from);
  void MergeFrom(const SelectorProto_PropertyFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_PropertyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.PropertyFilter";
  }
  protected:
  explicit SelectorProto_PropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyFieldNumber = 1,
    kTextFilterFieldNumber = 2,
    kAutofillValueRegexpFieldNumber = 3,
  };
  // optional string property = 1;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const std::string& property() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_property(ArgT0&& arg0, ArgT... args);
  std::string* mutable_property();
  PROTOBUF_NODISCARD std::string* release_property();
  void set_allocated_property(std::string* property);
  private:
  const std::string& _internal_property() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_property(const std::string& value);
  std::string* _internal_mutable_property();
  public:

  // .autofill_assistant.TextFilter text_filter = 2;
  bool has_text_filter() const;
  private:
  bool _internal_has_text_filter() const;
  public:
  void clear_text_filter();
  const ::autofill_assistant::TextFilter& text_filter() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_text_filter();
  ::autofill_assistant::TextFilter* mutable_text_filter();
  void set_allocated_text_filter(::autofill_assistant::TextFilter* text_filter);
  private:
  const ::autofill_assistant::TextFilter& _internal_text_filter() const;
  ::autofill_assistant::TextFilter* _internal_mutable_text_filter();
  public:
  void unsafe_arena_set_allocated_text_filter(
      ::autofill_assistant::TextFilter* text_filter);
  ::autofill_assistant::TextFilter* unsafe_arena_release_text_filter();

  // .autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;
  bool has_autofill_value_regexp() const;
  private:
  bool _internal_has_autofill_value_regexp() const;
  public:
  void clear_autofill_value_regexp();
  const ::autofill_assistant::AutofillValueRegexp& autofill_value_regexp() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillValueRegexp* release_autofill_value_regexp();
  ::autofill_assistant::AutofillValueRegexp* mutable_autofill_value_regexp();
  void set_allocated_autofill_value_regexp(::autofill_assistant::AutofillValueRegexp* autofill_value_regexp);
  private:
  const ::autofill_assistant::AutofillValueRegexp& _internal_autofill_value_regexp() const;
  ::autofill_assistant::AutofillValueRegexp* _internal_mutable_autofill_value_regexp();
  public:
  void unsafe_arena_set_allocated_autofill_value_regexp(
      ::autofill_assistant::AutofillValueRegexp* autofill_value_regexp);
  ::autofill_assistant::AutofillValueRegexp* unsafe_arena_release_autofill_value_regexp();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.PropertyFilter)
 private:
  class _Internal;
  void set_has_text_filter();
  void set_has_autofill_value_regexp();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::TextFilter* text_filter_;
    ::autofill_assistant::AutofillValueRegexp* autofill_value_regexp_;
  } value_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_PseudoElementContent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.PseudoElementContent) */ {
 public:
  inline SelectorProto_PseudoElementContent() : SelectorProto_PseudoElementContent(nullptr) {}
  ~SelectorProto_PseudoElementContent() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_PseudoElementContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_PseudoElementContent(const SelectorProto_PseudoElementContent& from);
  SelectorProto_PseudoElementContent(SelectorProto_PseudoElementContent&& from) noexcept
    : SelectorProto_PseudoElementContent() {
    *this = ::std::move(from);
  }

  inline SelectorProto_PseudoElementContent& operator=(const SelectorProto_PseudoElementContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_PseudoElementContent& operator=(SelectorProto_PseudoElementContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_PseudoElementContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_PseudoElementContent* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_PseudoElementContent*>(
               &_SelectorProto_PseudoElementContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(SelectorProto_PseudoElementContent& a, SelectorProto_PseudoElementContent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_PseudoElementContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_PseudoElementContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_PseudoElementContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_PseudoElementContent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_PseudoElementContent& from);
  void MergeFrom(const SelectorProto_PseudoElementContent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_PseudoElementContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.PseudoElementContent";
  }
  protected:
  explicit SelectorProto_PseudoElementContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kPseudoTypeFieldNumber = 1,
  };
  // optional .autofill_assistant.TextFilter content = 2;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::autofill_assistant::TextFilter& content() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_content();
  ::autofill_assistant::TextFilter* mutable_content();
  void set_allocated_content(::autofill_assistant::TextFilter* content);
  private:
  const ::autofill_assistant::TextFilter& _internal_content() const;
  ::autofill_assistant::TextFilter* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::autofill_assistant::TextFilter* content);
  ::autofill_assistant::TextFilter* unsafe_arena_release_content();

  // optional .autofill_assistant.PseudoType pseudo_type = 1;
  bool has_pseudo_type() const;
  private:
  bool _internal_has_pseudo_type() const;
  public:
  void clear_pseudo_type();
  ::autofill_assistant::PseudoType pseudo_type() const;
  void set_pseudo_type(::autofill_assistant::PseudoType value);
  private:
  ::autofill_assistant::PseudoType _internal_pseudo_type() const;
  void _internal_set_pseudo_type(::autofill_assistant::PseudoType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.PseudoElementContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::TextFilter* content_;
  int pseudo_type_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_CssStyleFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.CssStyleFilter) */ {
 public:
  inline SelectorProto_CssStyleFilter() : SelectorProto_CssStyleFilter(nullptr) {}
  ~SelectorProto_CssStyleFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_CssStyleFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_CssStyleFilter(const SelectorProto_CssStyleFilter& from);
  SelectorProto_CssStyleFilter(SelectorProto_CssStyleFilter&& from) noexcept
    : SelectorProto_CssStyleFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_CssStyleFilter& operator=(const SelectorProto_CssStyleFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_CssStyleFilter& operator=(SelectorProto_CssStyleFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_CssStyleFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_CssStyleFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_CssStyleFilter*>(
               &_SelectorProto_CssStyleFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(SelectorProto_CssStyleFilter& a, SelectorProto_CssStyleFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_CssStyleFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_CssStyleFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_CssStyleFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_CssStyleFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_CssStyleFilter& from);
  void MergeFrom(const SelectorProto_CssStyleFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_CssStyleFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.CssStyleFilter";
  }
  protected:
  explicit SelectorProto_CssStyleFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyFieldNumber = 3,
    kPseudoElementFieldNumber = 4,
    kValueFieldNumber = 6,
    kShouldMatchFieldNumber = 5,
  };
  // optional string property = 3;
  bool has_property() const;
  private:
  bool _internal_has_property() const;
  public:
  void clear_property();
  const std::string& property() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_property(ArgT0&& arg0, ArgT... args);
  std::string* mutable_property();
  PROTOBUF_NODISCARD std::string* release_property();
  void set_allocated_property(std::string* property);
  private:
  const std::string& _internal_property() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_property(const std::string& value);
  std::string* _internal_mutable_property();
  public:

  // optional string pseudo_element = 4;
  bool has_pseudo_element() const;
  private:
  bool _internal_has_pseudo_element() const;
  public:
  void clear_pseudo_element();
  const std::string& pseudo_element() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pseudo_element(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pseudo_element();
  PROTOBUF_NODISCARD std::string* release_pseudo_element();
  void set_allocated_pseudo_element(std::string* pseudo_element);
  private:
  const std::string& _internal_pseudo_element() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pseudo_element(const std::string& value);
  std::string* _internal_mutable_pseudo_element();
  public:

  // optional .autofill_assistant.TextFilter value = 6;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::TextFilter& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_value();
  ::autofill_assistant::TextFilter* mutable_value();
  void set_allocated_value(::autofill_assistant::TextFilter* value);
  private:
  const ::autofill_assistant::TextFilter& _internal_value() const;
  ::autofill_assistant::TextFilter* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::TextFilter* value);
  ::autofill_assistant::TextFilter* unsafe_arena_release_value();

  // optional bool should_match = 5 [default = true];
  bool has_should_match() const;
  private:
  bool _internal_has_should_match() const;
  public:
  void clear_should_match();
  bool should_match() const;
  void set_should_match(bool value);
  private:
  bool _internal_should_match() const;
  void _internal_set_should_match(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.CssStyleFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pseudo_element_;
  ::autofill_assistant::TextFilter* value_;
  bool should_match_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_BoundingBoxFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.BoundingBoxFilter) */ {
 public:
  inline SelectorProto_BoundingBoxFilter() : SelectorProto_BoundingBoxFilter(nullptr) {}
  ~SelectorProto_BoundingBoxFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_BoundingBoxFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_BoundingBoxFilter(const SelectorProto_BoundingBoxFilter& from);
  SelectorProto_BoundingBoxFilter(SelectorProto_BoundingBoxFilter&& from) noexcept
    : SelectorProto_BoundingBoxFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_BoundingBoxFilter& operator=(const SelectorProto_BoundingBoxFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_BoundingBoxFilter& operator=(SelectorProto_BoundingBoxFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_BoundingBoxFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_BoundingBoxFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_BoundingBoxFilter*>(
               &_SelectorProto_BoundingBoxFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(SelectorProto_BoundingBoxFilter& a, SelectorProto_BoundingBoxFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_BoundingBoxFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_BoundingBoxFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_BoundingBoxFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_BoundingBoxFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_BoundingBoxFilter& from);
  void MergeFrom(const SelectorProto_BoundingBoxFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_BoundingBoxFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.BoundingBoxFilter";
  }
  protected:
  explicit SelectorProto_BoundingBoxFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequireNonemptyFieldNumber = 1,
  };
  // optional bool require_nonempty = 1;
  bool has_require_nonempty() const;
  private:
  bool _internal_has_require_nonempty() const;
  public:
  void clear_require_nonempty();
  bool require_nonempty() const;
  void set_require_nonempty(bool value);
  private:
  bool _internal_require_nonempty() const;
  void _internal_set_require_nonempty(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.BoundingBoxFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool require_nonempty_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_OnTopFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.OnTopFilter) */ {
 public:
  inline SelectorProto_OnTopFilter() : SelectorProto_OnTopFilter(nullptr) {}
  ~SelectorProto_OnTopFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_OnTopFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_OnTopFilter(const SelectorProto_OnTopFilter& from);
  SelectorProto_OnTopFilter(SelectorProto_OnTopFilter&& from) noexcept
    : SelectorProto_OnTopFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_OnTopFilter& operator=(const SelectorProto_OnTopFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_OnTopFilter& operator=(SelectorProto_OnTopFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_OnTopFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_OnTopFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_OnTopFilter*>(
               &_SelectorProto_OnTopFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(SelectorProto_OnTopFilter& a, SelectorProto_OnTopFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_OnTopFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_OnTopFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_OnTopFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_OnTopFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_OnTopFilter& from);
  void MergeFrom(const SelectorProto_OnTopFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_OnTopFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.OnTopFilter";
  }
  protected:
  explicit SelectorProto_OnTopFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceptElementIfNotInViewFieldNumber = 2,
    kScrollIntoViewIfNeededFieldNumber = 1,
  };
  // optional bool accept_element_if_not_in_view = 2;
  bool has_accept_element_if_not_in_view() const;
  private:
  bool _internal_has_accept_element_if_not_in_view() const;
  public:
  void clear_accept_element_if_not_in_view();
  bool accept_element_if_not_in_view() const;
  void set_accept_element_if_not_in_view(bool value);
  private:
  bool _internal_accept_element_if_not_in_view() const;
  void _internal_set_accept_element_if_not_in_view(bool value);
  public:

  // optional bool scroll_into_view_if_needed = 1 [default = true];
  bool has_scroll_into_view_if_needed() const;
  private:
  bool _internal_has_scroll_into_view_if_needed() const;
  public:
  void clear_scroll_into_view_if_needed();
  bool scroll_into_view_if_needed() const;
  void set_scroll_into_view_if_needed(bool value);
  private:
  bool _internal_scroll_into_view_if_needed() const;
  void _internal_set_scroll_into_view_if_needed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.OnTopFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool accept_element_if_not_in_view_;
  bool scroll_into_view_if_needed_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_EmptyFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.EmptyFilter) */ {
 public:
  inline SelectorProto_EmptyFilter() : SelectorProto_EmptyFilter(nullptr) {}
  ~SelectorProto_EmptyFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_EmptyFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_EmptyFilter(const SelectorProto_EmptyFilter& from);
  SelectorProto_EmptyFilter(SelectorProto_EmptyFilter&& from) noexcept
    : SelectorProto_EmptyFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_EmptyFilter& operator=(const SelectorProto_EmptyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_EmptyFilter& operator=(SelectorProto_EmptyFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_EmptyFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_EmptyFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_EmptyFilter*>(
               &_SelectorProto_EmptyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(SelectorProto_EmptyFilter& a, SelectorProto_EmptyFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_EmptyFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_EmptyFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_EmptyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_EmptyFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_EmptyFilter& from);
  void MergeFrom(const SelectorProto_EmptyFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_EmptyFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.EmptyFilter";
  }
  protected:
  explicit SelectorProto_EmptyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.EmptyFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_NthMatchFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.NthMatchFilter) */ {
 public:
  inline SelectorProto_NthMatchFilter() : SelectorProto_NthMatchFilter(nullptr) {}
  ~SelectorProto_NthMatchFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_NthMatchFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_NthMatchFilter(const SelectorProto_NthMatchFilter& from);
  SelectorProto_NthMatchFilter(SelectorProto_NthMatchFilter&& from) noexcept
    : SelectorProto_NthMatchFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_NthMatchFilter& operator=(const SelectorProto_NthMatchFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_NthMatchFilter& operator=(SelectorProto_NthMatchFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_NthMatchFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_NthMatchFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_NthMatchFilter*>(
               &_SelectorProto_NthMatchFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(SelectorProto_NthMatchFilter& a, SelectorProto_NthMatchFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_NthMatchFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_NthMatchFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_NthMatchFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_NthMatchFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_NthMatchFilter& from);
  void MergeFrom(const SelectorProto_NthMatchFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_NthMatchFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.NthMatchFilter";
  }
  protected:
  explicit SelectorProto_NthMatchFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // optional int32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.NthMatchFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t index_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto_SemanticFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto.SemanticFilter) */ {
 public:
  inline SelectorProto_SemanticFilter() : SelectorProto_SemanticFilter(nullptr) {}
  ~SelectorProto_SemanticFilter() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto_SemanticFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto_SemanticFilter(const SelectorProto_SemanticFilter& from);
  SelectorProto_SemanticFilter(SelectorProto_SemanticFilter&& from) noexcept
    : SelectorProto_SemanticFilter() {
    *this = ::std::move(from);
  }

  inline SelectorProto_SemanticFilter& operator=(const SelectorProto_SemanticFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto_SemanticFilter& operator=(SelectorProto_SemanticFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto_SemanticFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto_SemanticFilter* internal_default_instance() {
    return reinterpret_cast<const SelectorProto_SemanticFilter*>(
               &_SelectorProto_SemanticFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(SelectorProto_SemanticFilter& a, SelectorProto_SemanticFilter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto_SemanticFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto_SemanticFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto_SemanticFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto_SemanticFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto_SemanticFilter& from);
  void MergeFrom(const SelectorProto_SemanticFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto_SemanticFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto.SemanticFilter";
  }
  protected:
  explicit SelectorProto_SemanticFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectiveFieldNumber = 1,
    kRoleFieldNumber = 2,
    kIgnoreObjectiveFieldNumber = 4,
    kModelTimeoutMsFieldNumber = 3,
  };
  // optional int32 objective = 1;
  bool has_objective() const;
  private:
  bool _internal_has_objective() const;
  public:
  void clear_objective();
  int32_t objective() const;
  void set_objective(int32_t value);
  private:
  int32_t _internal_objective() const;
  void _internal_set_objective(int32_t value);
  public:

  // optional int32 role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  int32_t role() const;
  void set_role(int32_t value);
  private:
  int32_t _internal_role() const;
  void _internal_set_role(int32_t value);
  public:

  // optional bool ignore_objective = 4;
  bool has_ignore_objective() const;
  private:
  bool _internal_has_ignore_objective() const;
  public:
  void clear_ignore_objective();
  bool ignore_objective() const;
  void set_ignore_objective(bool value);
  private:
  bool _internal_ignore_objective() const;
  void _internal_set_ignore_objective(bool value);
  public:

  // optional int32 model_timeout_ms = 3 [default = 5000];
  bool has_model_timeout_ms() const;
  private:
  bool _internal_has_model_timeout_ms() const;
  public:
  void clear_model_timeout_ms();
  int32_t model_timeout_ms() const;
  void set_model_timeout_ms(int32_t value);
  private:
  int32_t _internal_model_timeout_ms() const;
  void _internal_set_model_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto.SemanticFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t objective_;
  int32_t role_;
  bool ignore_objective_;
  int32_t model_timeout_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectorProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectorProto) */ {
 public:
  inline SelectorProto() : SelectorProto(nullptr) {}
  ~SelectorProto() override;
  explicit PROTOBUF_CONSTEXPR SelectorProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectorProto(const SelectorProto& from);
  SelectorProto(SelectorProto&& from) noexcept
    : SelectorProto() {
    *this = ::std::move(from);
  }

  inline SelectorProto& operator=(const SelectorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectorProto& operator=(SelectorProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectorProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectorProto* internal_default_instance() {
    return reinterpret_cast<const SelectorProto*>(
               &_SelectorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(SelectorProto& a, SelectorProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectorProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectorProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectorProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectorProto& from);
  void MergeFrom(const SelectorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectorProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectorProto";
  }
  protected:
  explicit SelectorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SelectorProto_Filter Filter;
  typedef SelectorProto_PropertyFilter PropertyFilter;
  typedef SelectorProto_PseudoElementContent PseudoElementContent;
  typedef SelectorProto_CssStyleFilter CssStyleFilter;
  typedef SelectorProto_BoundingBoxFilter BoundingBoxFilter;
  typedef SelectorProto_OnTopFilter OnTopFilter;
  typedef SelectorProto_EmptyFilter EmptyFilter;
  typedef SelectorProto_NthMatchFilter NthMatchFilter;
  typedef SelectorProto_SemanticFilter SemanticFilter;

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 9,
    kTrackingIdFieldNumber = 10,
  };
  // repeated .autofill_assistant.SelectorProto.Filter filters = 9;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::autofill_assistant::SelectorProto_Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto_Filter >*
      mutable_filters();
  private:
  const ::autofill_assistant::SelectorProto_Filter& _internal_filters(int index) const;
  ::autofill_assistant::SelectorProto_Filter* _internal_add_filters();
  public:
  const ::autofill_assistant::SelectorProto_Filter& filters(int index) const;
  ::autofill_assistant::SelectorProto_Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto_Filter >&
      filters() const;

  // optional int64 tracking_id = 10;
  bool has_tracking_id() const;
  private:
  bool _internal_has_tracking_id() const;
  public:
  void clear_tracking_id();
  int64_t tracking_id() const;
  void set_tracking_id(int64_t value);
  private:
  int64_t _internal_tracking_id() const;
  void _internal_set_tracking_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectorProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto_Filter > filters_;
  int64_t tracking_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectOptionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectOptionProto) */ {
 public:
  inline SelectOptionProto() : SelectOptionProto(nullptr) {}
  ~SelectOptionProto() override;
  explicit PROTOBUF_CONSTEXPR SelectOptionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectOptionProto(const SelectOptionProto& from);
  SelectOptionProto(SelectOptionProto&& from) noexcept
    : SelectOptionProto() {
    *this = ::std::move(from);
  }

  inline SelectOptionProto& operator=(const SelectOptionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectOptionProto& operator=(SelectOptionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectOptionProto& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kTextFilterValue = 7,
    kAutofillRegexpValue = 8,
    VALUE_NOT_SET = 0,
  };

  static inline const SelectOptionProto* internal_default_instance() {
    return reinterpret_cast<const SelectOptionProto*>(
               &_SelectOptionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(SelectOptionProto& a, SelectOptionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectOptionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectOptionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectOptionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectOptionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectOptionProto& from);
  void MergeFrom(const SelectOptionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectOptionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectOptionProto";
  }
  protected:
  explicit SelectOptionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SelectOptionProto_OptionComparisonAttribute OptionComparisonAttribute;
  static constexpr OptionComparisonAttribute NOT_SET =
    SelectOptionProto_OptionComparisonAttribute_NOT_SET;
  static constexpr OptionComparisonAttribute VALUE =
    SelectOptionProto_OptionComparisonAttribute_VALUE;
  static constexpr OptionComparisonAttribute LABEL =
    SelectOptionProto_OptionComparisonAttribute_LABEL;
  static inline bool OptionComparisonAttribute_IsValid(int value) {
    return SelectOptionProto_OptionComparisonAttribute_IsValid(value);
  }
  static constexpr OptionComparisonAttribute OptionComparisonAttribute_MIN =
    SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_MIN;
  static constexpr OptionComparisonAttribute OptionComparisonAttribute_MAX =
    SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_MAX;
  static constexpr int OptionComparisonAttribute_ARRAYSIZE =
    SelectOptionProto_OptionComparisonAttribute_OptionComparisonAttribute_ARRAYSIZE;
  template<typename T>
  static inline const std::string& OptionComparisonAttribute_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OptionComparisonAttribute>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OptionComparisonAttribute_Name.");
    return SelectOptionProto_OptionComparisonAttribute_Name(enum_t_value);
  }
  static inline bool OptionComparisonAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OptionComparisonAttribute* value) {
    return SelectOptionProto_OptionComparisonAttribute_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 2,
    kOptionComparisonAttributeFieldNumber = 6,
    kStrictFieldNumber = 9,
    kTextFilterValueFieldNumber = 7,
    kAutofillRegexpValueFieldNumber = 8,
  };
  // optional .autofill_assistant.SelectorProto element = 2;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::autofill_assistant::SelectorProto& element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_element();
  ::autofill_assistant::SelectorProto* mutable_element();
  void set_allocated_element(::autofill_assistant::SelectorProto* element);
  private:
  const ::autofill_assistant::SelectorProto& _internal_element() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::autofill_assistant::SelectorProto* element);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_element();

  // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 6;
  bool has_option_comparison_attribute() const;
  private:
  bool _internal_has_option_comparison_attribute() const;
  public:
  void clear_option_comparison_attribute();
  ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute option_comparison_attribute() const;
  void set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value);
  private:
  ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute _internal_option_comparison_attribute() const;
  void _internal_set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value);
  public:

  // optional bool strict = 9;
  bool has_strict() const;
  private:
  bool _internal_has_strict() const;
  public:
  void clear_strict();
  bool strict() const;
  void set_strict(bool value);
  private:
  bool _internal_strict() const;
  void _internal_set_strict(bool value);
  public:

  // .autofill_assistant.TextFilter text_filter_value = 7;
  bool has_text_filter_value() const;
  private:
  bool _internal_has_text_filter_value() const;
  public:
  void clear_text_filter_value();
  const ::autofill_assistant::TextFilter& text_filter_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextFilter* release_text_filter_value();
  ::autofill_assistant::TextFilter* mutable_text_filter_value();
  void set_allocated_text_filter_value(::autofill_assistant::TextFilter* text_filter_value);
  private:
  const ::autofill_assistant::TextFilter& _internal_text_filter_value() const;
  ::autofill_assistant::TextFilter* _internal_mutable_text_filter_value();
  public:
  void unsafe_arena_set_allocated_text_filter_value(
      ::autofill_assistant::TextFilter* text_filter_value);
  ::autofill_assistant::TextFilter* unsafe_arena_release_text_filter_value();

  // .autofill_assistant.AutofillValueRegexp autofill_regexp_value = 8;
  bool has_autofill_regexp_value() const;
  private:
  bool _internal_has_autofill_regexp_value() const;
  public:
  void clear_autofill_regexp_value();
  const ::autofill_assistant::AutofillValueRegexp& autofill_regexp_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillValueRegexp* release_autofill_regexp_value();
  ::autofill_assistant::AutofillValueRegexp* mutable_autofill_regexp_value();
  void set_allocated_autofill_regexp_value(::autofill_assistant::AutofillValueRegexp* autofill_regexp_value);
  private:
  const ::autofill_assistant::AutofillValueRegexp& _internal_autofill_regexp_value() const;
  ::autofill_assistant::AutofillValueRegexp* _internal_mutable_autofill_regexp_value();
  public:
  void unsafe_arena_set_allocated_autofill_regexp_value(
      ::autofill_assistant::AutofillValueRegexp* autofill_regexp_value);
  ::autofill_assistant::AutofillValueRegexp* unsafe_arena_release_autofill_regexp_value();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectOptionProto)
 private:
  class _Internal;
  void set_has_text_filter_value();
  void set_has_autofill_regexp_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto* element_;
  int option_comparison_attribute_;
  bool strict_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::TextFilter* text_filter_value_;
    ::autofill_assistant::AutofillValueRegexp* autofill_regexp_value_;
  } value_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateClientSettingsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UpdateClientSettingsProto) */ {
 public:
  inline UpdateClientSettingsProto() : UpdateClientSettingsProto(nullptr) {}
  ~UpdateClientSettingsProto() override;
  explicit PROTOBUF_CONSTEXPR UpdateClientSettingsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateClientSettingsProto(const UpdateClientSettingsProto& from);
  UpdateClientSettingsProto(UpdateClientSettingsProto&& from) noexcept
    : UpdateClientSettingsProto() {
    *this = ::std::move(from);
  }

  inline UpdateClientSettingsProto& operator=(const UpdateClientSettingsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateClientSettingsProto& operator=(UpdateClientSettingsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UpdateClientSettingsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateClientSettingsProto* internal_default_instance() {
    return reinterpret_cast<const UpdateClientSettingsProto*>(
               &_UpdateClientSettingsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(UpdateClientSettingsProto& a, UpdateClientSettingsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UpdateClientSettingsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateClientSettingsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateClientSettingsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateClientSettingsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UpdateClientSettingsProto& from);
  void MergeFrom(const UpdateClientSettingsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateClientSettingsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UpdateClientSettingsProto";
  }
  protected:
  explicit UpdateClientSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientSettingsFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientSettingsProto client_settings = 1;
  bool has_client_settings() const;
  private:
  bool _internal_has_client_settings() const;
  public:
  void clear_client_settings();
  const ::autofill_assistant::ClientSettingsProto& client_settings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientSettingsProto* release_client_settings();
  ::autofill_assistant::ClientSettingsProto* mutable_client_settings();
  void set_allocated_client_settings(::autofill_assistant::ClientSettingsProto* client_settings);
  private:
  const ::autofill_assistant::ClientSettingsProto& _internal_client_settings() const;
  ::autofill_assistant::ClientSettingsProto* _internal_mutable_client_settings();
  public:
  void unsafe_arena_set_allocated_client_settings(
      ::autofill_assistant::ClientSettingsProto* client_settings);
  ::autofill_assistant::ClientSettingsProto* unsafe_arena_release_client_settings();

  // @@protoc_insertion_point(class_scope:autofill_assistant.UpdateClientSettingsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientSettingsProto* client_settings_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PromptQrCodeScanProto_CameraScanUiStrings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings) */ {
 public:
  inline PromptQrCodeScanProto_CameraScanUiStrings() : PromptQrCodeScanProto_CameraScanUiStrings(nullptr) {}
  ~PromptQrCodeScanProto_CameraScanUiStrings() override;
  explicit PROTOBUF_CONSTEXPR PromptQrCodeScanProto_CameraScanUiStrings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptQrCodeScanProto_CameraScanUiStrings(const PromptQrCodeScanProto_CameraScanUiStrings& from);
  PromptQrCodeScanProto_CameraScanUiStrings(PromptQrCodeScanProto_CameraScanUiStrings&& from) noexcept
    : PromptQrCodeScanProto_CameraScanUiStrings() {
    *this = ::std::move(from);
  }

  inline PromptQrCodeScanProto_CameraScanUiStrings& operator=(const PromptQrCodeScanProto_CameraScanUiStrings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptQrCodeScanProto_CameraScanUiStrings& operator=(PromptQrCodeScanProto_CameraScanUiStrings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PromptQrCodeScanProto_CameraScanUiStrings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptQrCodeScanProto_CameraScanUiStrings* internal_default_instance() {
    return reinterpret_cast<const PromptQrCodeScanProto_CameraScanUiStrings*>(
               &_PromptQrCodeScanProto_CameraScanUiStrings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(PromptQrCodeScanProto_CameraScanUiStrings& a, PromptQrCodeScanProto_CameraScanUiStrings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PromptQrCodeScanProto_CameraScanUiStrings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptQrCodeScanProto_CameraScanUiStrings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptQrCodeScanProto_CameraScanUiStrings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptQrCodeScanProto_CameraScanUiStrings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PromptQrCodeScanProto_CameraScanUiStrings& from);
  void MergeFrom(const PromptQrCodeScanProto_CameraScanUiStrings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PromptQrCodeScanProto_CameraScanUiStrings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings";
  }
  protected:
  explicit PromptQrCodeScanProto_CameraScanUiStrings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleTextFieldNumber = 1,
    kPermissionTextFieldNumber = 2,
    kPermissionButtonTextFieldNumber = 3,
    kOpenSettingsTextFieldNumber = 4,
    kOpenSettingsButtonTextFieldNumber = 5,
    kCameraPreviewInstructionTextFieldNumber = 6,
    kCameraPreviewSecurityTextFieldNumber = 7,
  };
  // optional string title_text = 1;
  bool has_title_text() const;
  private:
  bool _internal_has_title_text() const;
  public:
  void clear_title_text();
  const std::string& title_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title_text();
  PROTOBUF_NODISCARD std::string* release_title_text();
  void set_allocated_title_text(std::string* title_text);
  private:
  const std::string& _internal_title_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title_text(const std::string& value);
  std::string* _internal_mutable_title_text();
  public:

  // optional string permission_text = 2;
  bool has_permission_text() const;
  private:
  bool _internal_has_permission_text() const;
  public:
  void clear_permission_text();
  const std::string& permission_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_text();
  PROTOBUF_NODISCARD std::string* release_permission_text();
  void set_allocated_permission_text(std::string* permission_text);
  private:
  const std::string& _internal_permission_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_text(const std::string& value);
  std::string* _internal_mutable_permission_text();
  public:

  // optional string permission_button_text = 3;
  bool has_permission_button_text() const;
  private:
  bool _internal_has_permission_button_text() const;
  public:
  void clear_permission_button_text();
  const std::string& permission_button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_button_text();
  PROTOBUF_NODISCARD std::string* release_permission_button_text();
  void set_allocated_permission_button_text(std::string* permission_button_text);
  private:
  const std::string& _internal_permission_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_button_text(const std::string& value);
  std::string* _internal_mutable_permission_button_text();
  public:

  // optional string open_settings_text = 4;
  bool has_open_settings_text() const;
  private:
  bool _internal_has_open_settings_text() const;
  public:
  void clear_open_settings_text();
  const std::string& open_settings_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open_settings_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open_settings_text();
  PROTOBUF_NODISCARD std::string* release_open_settings_text();
  void set_allocated_open_settings_text(std::string* open_settings_text);
  private:
  const std::string& _internal_open_settings_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open_settings_text(const std::string& value);
  std::string* _internal_mutable_open_settings_text();
  public:

  // optional string open_settings_button_text = 5;
  bool has_open_settings_button_text() const;
  private:
  bool _internal_has_open_settings_button_text() const;
  public:
  void clear_open_settings_button_text();
  const std::string& open_settings_button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open_settings_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open_settings_button_text();
  PROTOBUF_NODISCARD std::string* release_open_settings_button_text();
  void set_allocated_open_settings_button_text(std::string* open_settings_button_text);
  private:
  const std::string& _internal_open_settings_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open_settings_button_text(const std::string& value);
  std::string* _internal_mutable_open_settings_button_text();
  public:

  // optional string camera_preview_instruction_text = 6;
  bool has_camera_preview_instruction_text() const;
  private:
  bool _internal_has_camera_preview_instruction_text() const;
  public:
  void clear_camera_preview_instruction_text();
  const std::string& camera_preview_instruction_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_preview_instruction_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_preview_instruction_text();
  PROTOBUF_NODISCARD std::string* release_camera_preview_instruction_text();
  void set_allocated_camera_preview_instruction_text(std::string* camera_preview_instruction_text);
  private:
  const std::string& _internal_camera_preview_instruction_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_preview_instruction_text(const std::string& value);
  std::string* _internal_mutable_camera_preview_instruction_text();
  public:

  // optional string camera_preview_security_text = 7;
  bool has_camera_preview_security_text() const;
  private:
  bool _internal_has_camera_preview_security_text() const;
  public:
  void clear_camera_preview_security_text();
  const std::string& camera_preview_security_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_preview_security_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_preview_security_text();
  PROTOBUF_NODISCARD std::string* release_camera_preview_security_text();
  void set_allocated_camera_preview_security_text(std::string* camera_preview_security_text);
  private:
  const std::string& _internal_camera_preview_security_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_preview_security_text(const std::string& value);
  std::string* _internal_mutable_camera_preview_security_text();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_button_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_settings_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_settings_button_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_preview_instruction_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_preview_security_text_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PromptQrCodeScanProto_ImagePickerUiStrings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings) */ {
 public:
  inline PromptQrCodeScanProto_ImagePickerUiStrings() : PromptQrCodeScanProto_ImagePickerUiStrings(nullptr) {}
  ~PromptQrCodeScanProto_ImagePickerUiStrings() override;
  explicit PROTOBUF_CONSTEXPR PromptQrCodeScanProto_ImagePickerUiStrings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptQrCodeScanProto_ImagePickerUiStrings(const PromptQrCodeScanProto_ImagePickerUiStrings& from);
  PromptQrCodeScanProto_ImagePickerUiStrings(PromptQrCodeScanProto_ImagePickerUiStrings&& from) noexcept
    : PromptQrCodeScanProto_ImagePickerUiStrings() {
    *this = ::std::move(from);
  }

  inline PromptQrCodeScanProto_ImagePickerUiStrings& operator=(const PromptQrCodeScanProto_ImagePickerUiStrings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptQrCodeScanProto_ImagePickerUiStrings& operator=(PromptQrCodeScanProto_ImagePickerUiStrings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PromptQrCodeScanProto_ImagePickerUiStrings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptQrCodeScanProto_ImagePickerUiStrings* internal_default_instance() {
    return reinterpret_cast<const PromptQrCodeScanProto_ImagePickerUiStrings*>(
               &_PromptQrCodeScanProto_ImagePickerUiStrings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(PromptQrCodeScanProto_ImagePickerUiStrings& a, PromptQrCodeScanProto_ImagePickerUiStrings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PromptQrCodeScanProto_ImagePickerUiStrings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptQrCodeScanProto_ImagePickerUiStrings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptQrCodeScanProto_ImagePickerUiStrings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptQrCodeScanProto_ImagePickerUiStrings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PromptQrCodeScanProto_ImagePickerUiStrings& from);
  void MergeFrom(const PromptQrCodeScanProto_ImagePickerUiStrings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PromptQrCodeScanProto_ImagePickerUiStrings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings";
  }
  protected:
  explicit PromptQrCodeScanProto_ImagePickerUiStrings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleTextFieldNumber = 1,
    kPermissionTextFieldNumber = 2,
    kPermissionButtonTextFieldNumber = 3,
    kOpenSettingsTextFieldNumber = 4,
    kOpenSettingsButtonTextFieldNumber = 5,
  };
  // optional string title_text = 1;
  bool has_title_text() const;
  private:
  bool _internal_has_title_text() const;
  public:
  void clear_title_text();
  const std::string& title_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title_text();
  PROTOBUF_NODISCARD std::string* release_title_text();
  void set_allocated_title_text(std::string* title_text);
  private:
  const std::string& _internal_title_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title_text(const std::string& value);
  std::string* _internal_mutable_title_text();
  public:

  // optional string permission_text = 2;
  bool has_permission_text() const;
  private:
  bool _internal_has_permission_text() const;
  public:
  void clear_permission_text();
  const std::string& permission_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_text();
  PROTOBUF_NODISCARD std::string* release_permission_text();
  void set_allocated_permission_text(std::string* permission_text);
  private:
  const std::string& _internal_permission_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_text(const std::string& value);
  std::string* _internal_mutable_permission_text();
  public:

  // optional string permission_button_text = 3;
  bool has_permission_button_text() const;
  private:
  bool _internal_has_permission_button_text() const;
  public:
  void clear_permission_button_text();
  const std::string& permission_button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_permission_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_permission_button_text();
  PROTOBUF_NODISCARD std::string* release_permission_button_text();
  void set_allocated_permission_button_text(std::string* permission_button_text);
  private:
  const std::string& _internal_permission_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission_button_text(const std::string& value);
  std::string* _internal_mutable_permission_button_text();
  public:

  // optional string open_settings_text = 4;
  bool has_open_settings_text() const;
  private:
  bool _internal_has_open_settings_text() const;
  public:
  void clear_open_settings_text();
  const std::string& open_settings_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open_settings_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open_settings_text();
  PROTOBUF_NODISCARD std::string* release_open_settings_text();
  void set_allocated_open_settings_text(std::string* open_settings_text);
  private:
  const std::string& _internal_open_settings_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open_settings_text(const std::string& value);
  std::string* _internal_mutable_open_settings_text();
  public:

  // optional string open_settings_button_text = 5;
  bool has_open_settings_button_text() const;
  private:
  bool _internal_has_open_settings_button_text() const;
  public:
  void clear_open_settings_button_text();
  const std::string& open_settings_button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open_settings_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open_settings_button_text();
  PROTOBUF_NODISCARD std::string* release_open_settings_button_text();
  void set_allocated_open_settings_button_text(std::string* open_settings_button_text);
  private:
  const std::string& _internal_open_settings_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open_settings_button_text(const std::string& value);
  std::string* _internal_mutable_open_settings_button_text();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr permission_button_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_settings_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_settings_button_text_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PromptQrCodeScanProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PromptQrCodeScanProto) */ {
 public:
  inline PromptQrCodeScanProto() : PromptQrCodeScanProto(nullptr) {}
  ~PromptQrCodeScanProto() override;
  explicit PROTOBUF_CONSTEXPR PromptQrCodeScanProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptQrCodeScanProto(const PromptQrCodeScanProto& from);
  PromptQrCodeScanProto(PromptQrCodeScanProto&& from) noexcept
    : PromptQrCodeScanProto() {
    *this = ::std::move(from);
  }

  inline PromptQrCodeScanProto& operator=(const PromptQrCodeScanProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptQrCodeScanProto& operator=(PromptQrCodeScanProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PromptQrCodeScanProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptQrCodeScanProto* internal_default_instance() {
    return reinterpret_cast<const PromptQrCodeScanProto*>(
               &_PromptQrCodeScanProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(PromptQrCodeScanProto& a, PromptQrCodeScanProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PromptQrCodeScanProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptQrCodeScanProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptQrCodeScanProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptQrCodeScanProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PromptQrCodeScanProto& from);
  void MergeFrom(const PromptQrCodeScanProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PromptQrCodeScanProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PromptQrCodeScanProto";
  }
  protected:
  explicit PromptQrCodeScanProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PromptQrCodeScanProto_CameraScanUiStrings CameraScanUiStrings;
  typedef PromptQrCodeScanProto_ImagePickerUiStrings ImagePickerUiStrings;

  // accessors -------------------------------------------------------

  enum : int {
    kOutputClientMemoryKeyFieldNumber = 2,
    kCameraScanUiStringsFieldNumber = 3,
    kImagePickerUiStringsFieldNumber = 4,
    kUseGalleryFieldNumber = 1,
  };
  // optional string output_client_memory_key = 2;
  bool has_output_client_memory_key() const;
  private:
  bool _internal_has_output_client_memory_key() const;
  public:
  void clear_output_client_memory_key();
  const std::string& output_client_memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_client_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_client_memory_key();
  PROTOBUF_NODISCARD std::string* release_output_client_memory_key();
  void set_allocated_output_client_memory_key(std::string* output_client_memory_key);
  private:
  const std::string& _internal_output_client_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_client_memory_key(const std::string& value);
  std::string* _internal_mutable_output_client_memory_key();
  public:

  // optional .autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings camera_scan_ui_strings = 3;
  bool has_camera_scan_ui_strings() const;
  private:
  bool _internal_has_camera_scan_ui_strings() const;
  public:
  void clear_camera_scan_ui_strings();
  const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings& camera_scan_ui_strings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* release_camera_scan_ui_strings();
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* mutable_camera_scan_ui_strings();
  void set_allocated_camera_scan_ui_strings(::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* camera_scan_ui_strings);
  private:
  const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings& _internal_camera_scan_ui_strings() const;
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* _internal_mutable_camera_scan_ui_strings();
  public:
  void unsafe_arena_set_allocated_camera_scan_ui_strings(
      ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* camera_scan_ui_strings);
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* unsafe_arena_release_camera_scan_ui_strings();

  // optional .autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings image_picker_ui_strings = 4;
  bool has_image_picker_ui_strings() const;
  private:
  bool _internal_has_image_picker_ui_strings() const;
  public:
  void clear_image_picker_ui_strings();
  const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings& image_picker_ui_strings() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* release_image_picker_ui_strings();
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* mutable_image_picker_ui_strings();
  void set_allocated_image_picker_ui_strings(::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* image_picker_ui_strings);
  private:
  const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings& _internal_image_picker_ui_strings() const;
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* _internal_mutable_image_picker_ui_strings();
  public:
  void unsafe_arena_set_allocated_image_picker_ui_strings(
      ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* image_picker_ui_strings);
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* unsafe_arena_release_image_picker_ui_strings();

  // optional bool use_gallery = 1;
  bool has_use_gallery() const;
  private:
  bool _internal_has_use_gallery() const;
  public:
  void clear_use_gallery();
  bool use_gallery() const;
  void set_use_gallery(bool value);
  private:
  bool _internal_use_gallery() const;
  void _internal_set_use_gallery(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PromptQrCodeScanProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_client_memory_key_;
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* camera_scan_ui_strings_;
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* image_picker_ui_strings_;
  bool use_gallery_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TellProto_TextToSpeech final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TellProto.TextToSpeech) */ {
 public:
  inline TellProto_TextToSpeech() : TellProto_TextToSpeech(nullptr) {}
  ~TellProto_TextToSpeech() override;
  explicit PROTOBUF_CONSTEXPR TellProto_TextToSpeech(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TellProto_TextToSpeech(const TellProto_TextToSpeech& from);
  TellProto_TextToSpeech(TellProto_TextToSpeech&& from) noexcept
    : TellProto_TextToSpeech() {
    *this = ::std::move(from);
  }

  inline TellProto_TextToSpeech& operator=(const TellProto_TextToSpeech& from) {
    CopyFrom(from);
    return *this;
  }
  inline TellProto_TextToSpeech& operator=(TellProto_TextToSpeech&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TellProto_TextToSpeech& default_instance() {
    return *internal_default_instance();
  }
  static inline const TellProto_TextToSpeech* internal_default_instance() {
    return reinterpret_cast<const TellProto_TextToSpeech*>(
               &_TellProto_TextToSpeech_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(TellProto_TextToSpeech& a, TellProto_TextToSpeech& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TellProto_TextToSpeech* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TellProto_TextToSpeech* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TellProto_TextToSpeech* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TellProto_TextToSpeech>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TellProto_TextToSpeech& from);
  void MergeFrom(const TellProto_TextToSpeech& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TellProto_TextToSpeech* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TellProto.TextToSpeech";
  }
  protected:
  explicit TellProto_TextToSpeech(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTtsMessageFieldNumber = 1,
    kPlayNowFieldNumber = 2,
  };
  // optional string tts_message = 1;
  bool has_tts_message() const;
  private:
  bool _internal_has_tts_message() const;
  public:
  void clear_tts_message();
  const std::string& tts_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tts_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tts_message();
  PROTOBUF_NODISCARD std::string* release_tts_message();
  void set_allocated_tts_message(std::string* tts_message);
  private:
  const std::string& _internal_tts_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tts_message(const std::string& value);
  std::string* _internal_mutable_tts_message();
  public:

  // optional bool play_now = 2;
  bool has_play_now() const;
  private:
  bool _internal_has_play_now() const;
  public:
  void clear_play_now();
  bool play_now() const;
  void set_play_now(bool value);
  private:
  bool _internal_play_now() const;
  void _internal_set_play_now(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TellProto.TextToSpeech)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tts_message_;
  bool play_now_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TellProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TellProto) */ {
 public:
  inline TellProto() : TellProto(nullptr) {}
  ~TellProto() override;
  explicit PROTOBUF_CONSTEXPR TellProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TellProto(const TellProto& from);
  TellProto(TellProto&& from) noexcept
    : TellProto() {
    *this = ::std::move(from);
  }

  inline TellProto& operator=(const TellProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TellProto& operator=(TellProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TellProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TellProto* internal_default_instance() {
    return reinterpret_cast<const TellProto*>(
               &_TellProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(TellProto& a, TellProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TellProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TellProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TellProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TellProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TellProto& from);
  void MergeFrom(const TellProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TellProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TellProto";
  }
  protected:
  explicit TellProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TellProto_TextToSpeech TextToSpeech;

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTextToSpeechFieldNumber = 3,
    kNeedsUiFieldNumber = 2,
  };
  // optional string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional .autofill_assistant.TellProto.TextToSpeech text_to_speech = 3;
  bool has_text_to_speech() const;
  private:
  bool _internal_has_text_to_speech() const;
  public:
  void clear_text_to_speech();
  const ::autofill_assistant::TellProto_TextToSpeech& text_to_speech() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TellProto_TextToSpeech* release_text_to_speech();
  ::autofill_assistant::TellProto_TextToSpeech* mutable_text_to_speech();
  void set_allocated_text_to_speech(::autofill_assistant::TellProto_TextToSpeech* text_to_speech);
  private:
  const ::autofill_assistant::TellProto_TextToSpeech& _internal_text_to_speech() const;
  ::autofill_assistant::TellProto_TextToSpeech* _internal_mutable_text_to_speech();
  public:
  void unsafe_arena_set_allocated_text_to_speech(
      ::autofill_assistant::TellProto_TextToSpeech* text_to_speech);
  ::autofill_assistant::TellProto_TextToSpeech* unsafe_arena_release_text_to_speech();

  // optional bool needs_ui = 2 [default = true];
  bool has_needs_ui() const;
  private:
  bool _internal_has_needs_ui() const;
  public:
  void clear_needs_ui();
  bool needs_ui() const;
  void set_needs_ui(bool value);
  private:
  bool _internal_needs_ui() const;
  void _internal_set_needs_ui(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TellProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::autofill_assistant::TellProto_TextToSpeech* text_to_speech_;
  bool needs_ui_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowCastProto_TopPadding final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowCastProto.TopPadding) */ {
 public:
  inline ShowCastProto_TopPadding() : ShowCastProto_TopPadding(nullptr) {}
  ~ShowCastProto_TopPadding() override;
  explicit PROTOBUF_CONSTEXPR ShowCastProto_TopPadding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowCastProto_TopPadding(const ShowCastProto_TopPadding& from);
  ShowCastProto_TopPadding(ShowCastProto_TopPadding&& from) noexcept
    : ShowCastProto_TopPadding() {
    *this = ::std::move(from);
  }

  inline ShowCastProto_TopPadding& operator=(const ShowCastProto_TopPadding& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowCastProto_TopPadding& operator=(ShowCastProto_TopPadding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowCastProto_TopPadding& default_instance() {
    return *internal_default_instance();
  }
  enum TopPaddingCase {
    kPixels = 1,
    kRatio = 2,
    TOP_PADDING_NOT_SET = 0,
  };

  static inline const ShowCastProto_TopPadding* internal_default_instance() {
    return reinterpret_cast<const ShowCastProto_TopPadding*>(
               &_ShowCastProto_TopPadding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(ShowCastProto_TopPadding& a, ShowCastProto_TopPadding& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowCastProto_TopPadding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowCastProto_TopPadding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowCastProto_TopPadding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowCastProto_TopPadding>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowCastProto_TopPadding& from);
  void MergeFrom(const ShowCastProto_TopPadding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowCastProto_TopPadding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowCastProto.TopPadding";
  }
  protected:
  explicit ShowCastProto_TopPadding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelsFieldNumber = 1,
    kRatioFieldNumber = 2,
  };
  // int32 pixels = 1;
  bool has_pixels() const;
  private:
  bool _internal_has_pixels() const;
  public:
  void clear_pixels();
  int32_t pixels() const;
  void set_pixels(int32_t value);
  private:
  int32_t _internal_pixels() const;
  void _internal_set_pixels(int32_t value);
  public:

  // float ratio = 2;
  bool has_ratio() const;
  private:
  bool _internal_has_ratio() const;
  public:
  void clear_ratio();
  float ratio() const;
  void set_ratio(float value);
  private:
  float _internal_ratio() const;
  void _internal_set_ratio(float value);
  public:

  void clear_top_padding();
  TopPaddingCase top_padding_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowCastProto.TopPadding)
 private:
  class _Internal;
  void set_has_pixels();
  void set_has_ratio();

  inline bool has_top_padding() const;
  inline void clear_has_top_padding();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TopPaddingUnion {
    constexpr TopPaddingUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t pixels_;
    float ratio_;
  } top_padding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowCastProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowCastProto) */ {
 public:
  inline ShowCastProto() : ShowCastProto(nullptr) {}
  ~ShowCastProto() override;
  explicit PROTOBUF_CONSTEXPR ShowCastProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowCastProto(const ShowCastProto& from);
  ShowCastProto(ShowCastProto&& from) noexcept
    : ShowCastProto() {
    *this = ::std::move(from);
  }

  inline ShowCastProto& operator=(const ShowCastProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowCastProto& operator=(ShowCastProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowCastProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowCastProto* internal_default_instance() {
    return reinterpret_cast<const ShowCastProto*>(
               &_ShowCastProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(ShowCastProto& a, ShowCastProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowCastProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowCastProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowCastProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowCastProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowCastProto& from);
  void MergeFrom(const ShowCastProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowCastProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowCastProto";
  }
  protected:
  explicit ShowCastProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShowCastProto_TopPadding TopPadding;

  // accessors -------------------------------------------------------

  enum : int {
    kElementToPresentFieldNumber = 1,
    kTouchableElementAreaFieldNumber = 6,
    kTopPaddingFieldNumber = 7,
    kContainerFieldNumber = 12,
    kWaitForStableElementFieldNumber = 9,
    kStableCheckMaxRoundsFieldNumber = 10,
    kStableCheckIntervalMsFieldNumber = 11,
  };
  // optional .autofill_assistant.SelectorProto element_to_present = 1;
  bool has_element_to_present() const;
  private:
  bool _internal_has_element_to_present() const;
  public:
  void clear_element_to_present();
  const ::autofill_assistant::SelectorProto& element_to_present() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_element_to_present();
  ::autofill_assistant::SelectorProto* mutable_element_to_present();
  void set_allocated_element_to_present(::autofill_assistant::SelectorProto* element_to_present);
  private:
  const ::autofill_assistant::SelectorProto& _internal_element_to_present() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_element_to_present();
  public:
  void unsafe_arena_set_allocated_element_to_present(
      ::autofill_assistant::SelectorProto* element_to_present);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_element_to_present();

  // optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;
  bool has_touchable_element_area() const;
  private:
  bool _internal_has_touchable_element_area() const;
  public:
  void clear_touchable_element_area();
  const ::autofill_assistant::ElementAreaProto& touchable_element_area() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementAreaProto* release_touchable_element_area();
  ::autofill_assistant::ElementAreaProto* mutable_touchable_element_area();
  void set_allocated_touchable_element_area(::autofill_assistant::ElementAreaProto* touchable_element_area);
  private:
  const ::autofill_assistant::ElementAreaProto& _internal_touchable_element_area() const;
  ::autofill_assistant::ElementAreaProto* _internal_mutable_touchable_element_area();
  public:
  void unsafe_arena_set_allocated_touchable_element_area(
      ::autofill_assistant::ElementAreaProto* touchable_element_area);
  ::autofill_assistant::ElementAreaProto* unsafe_arena_release_touchable_element_area();

  // optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;
  bool has_top_padding() const;
  private:
  bool _internal_has_top_padding() const;
  public:
  void clear_top_padding();
  const ::autofill_assistant::ShowCastProto_TopPadding& top_padding() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowCastProto_TopPadding* release_top_padding();
  ::autofill_assistant::ShowCastProto_TopPadding* mutable_top_padding();
  void set_allocated_top_padding(::autofill_assistant::ShowCastProto_TopPadding* top_padding);
  private:
  const ::autofill_assistant::ShowCastProto_TopPadding& _internal_top_padding() const;
  ::autofill_assistant::ShowCastProto_TopPadding* _internal_mutable_top_padding();
  public:
  void unsafe_arena_set_allocated_top_padding(
      ::autofill_assistant::ShowCastProto_TopPadding* top_padding);
  ::autofill_assistant::ShowCastProto_TopPadding* unsafe_arena_release_top_padding();

  // optional .autofill_assistant.SelectorProto container = 12;
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::autofill_assistant::SelectorProto& container() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_container();
  ::autofill_assistant::SelectorProto* mutable_container();
  void set_allocated_container(::autofill_assistant::SelectorProto* container);
  private:
  const ::autofill_assistant::SelectorProto& _internal_container() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::autofill_assistant::SelectorProto* container);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_container();

  // optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;
  bool has_wait_for_stable_element() const;
  private:
  bool _internal_has_wait_for_stable_element() const;
  public:
  void clear_wait_for_stable_element();
  ::autofill_assistant::OptionalStep wait_for_stable_element() const;
  void set_wait_for_stable_element(::autofill_assistant::OptionalStep value);
  private:
  ::autofill_assistant::OptionalStep _internal_wait_for_stable_element() const;
  void _internal_set_wait_for_stable_element(::autofill_assistant::OptionalStep value);
  public:

  // optional int32 stable_check_max_rounds = 10 [default = 50];
  bool has_stable_check_max_rounds() const;
  private:
  bool _internal_has_stable_check_max_rounds() const;
  public:
  void clear_stable_check_max_rounds();
  int32_t stable_check_max_rounds() const;
  void set_stable_check_max_rounds(int32_t value);
  private:
  int32_t _internal_stable_check_max_rounds() const;
  void _internal_set_stable_check_max_rounds(int32_t value);
  public:

  // optional int32 stable_check_interval_ms = 11 [default = 200];
  bool has_stable_check_interval_ms() const;
  private:
  bool _internal_has_stable_check_interval_ms() const;
  public:
  void clear_stable_check_interval_ms();
  int32_t stable_check_interval_ms() const;
  void set_stable_check_interval_ms(int32_t value);
  private:
  int32_t _internal_stable_check_interval_ms() const;
  void _internal_set_stable_check_interval_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowCastProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto* element_to_present_;
  ::autofill_assistant::ElementAreaProto* touchable_element_area_;
  ::autofill_assistant::ShowCastProto_TopPadding* top_padding_;
  ::autofill_assistant::SelectorProto* container_;
  int wait_for_stable_element_;
  int32_t stable_check_max_rounds_;
  int32_t stable_check_interval_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SetTouchableAreaProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetTouchableAreaProto) */ {
 public:
  inline SetTouchableAreaProto() : SetTouchableAreaProto(nullptr) {}
  ~SetTouchableAreaProto() override;
  explicit PROTOBUF_CONSTEXPR SetTouchableAreaProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTouchableAreaProto(const SetTouchableAreaProto& from);
  SetTouchableAreaProto(SetTouchableAreaProto&& from) noexcept
    : SetTouchableAreaProto() {
    *this = ::std::move(from);
  }

  inline SetTouchableAreaProto& operator=(const SetTouchableAreaProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTouchableAreaProto& operator=(SetTouchableAreaProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetTouchableAreaProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTouchableAreaProto* internal_default_instance() {
    return reinterpret_cast<const SetTouchableAreaProto*>(
               &_SetTouchableAreaProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(SetTouchableAreaProto& a, SetTouchableAreaProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetTouchableAreaProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTouchableAreaProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTouchableAreaProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTouchableAreaProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetTouchableAreaProto& from);
  void MergeFrom(const SetTouchableAreaProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetTouchableAreaProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetTouchableAreaProto";
  }
  protected:
  explicit SetTouchableAreaProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementAreaFieldNumber = 1,
  };
  // optional .autofill_assistant.ElementAreaProto element_area = 1;
  bool has_element_area() const;
  private:
  bool _internal_has_element_area() const;
  public:
  void clear_element_area();
  const ::autofill_assistant::ElementAreaProto& element_area() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementAreaProto* release_element_area();
  ::autofill_assistant::ElementAreaProto* mutable_element_area();
  void set_allocated_element_area(::autofill_assistant::ElementAreaProto* element_area);
  private:
  const ::autofill_assistant::ElementAreaProto& _internal_element_area() const;
  ::autofill_assistant::ElementAreaProto* _internal_mutable_element_area();
  public:
  void unsafe_arena_set_allocated_element_area(
      ::autofill_assistant::ElementAreaProto* element_area);
  ::autofill_assistant::ElementAreaProto* unsafe_arena_release_element_area();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetTouchableAreaProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ElementAreaProto* element_area_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementAreaProto_Rectangle final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementAreaProto.Rectangle) */ {
 public:
  inline ElementAreaProto_Rectangle() : ElementAreaProto_Rectangle(nullptr) {}
  ~ElementAreaProto_Rectangle() override;
  explicit PROTOBUF_CONSTEXPR ElementAreaProto_Rectangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementAreaProto_Rectangle(const ElementAreaProto_Rectangle& from);
  ElementAreaProto_Rectangle(ElementAreaProto_Rectangle&& from) noexcept
    : ElementAreaProto_Rectangle() {
    *this = ::std::move(from);
  }

  inline ElementAreaProto_Rectangle& operator=(const ElementAreaProto_Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementAreaProto_Rectangle& operator=(ElementAreaProto_Rectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementAreaProto_Rectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementAreaProto_Rectangle* internal_default_instance() {
    return reinterpret_cast<const ElementAreaProto_Rectangle*>(
               &_ElementAreaProto_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(ElementAreaProto_Rectangle& a, ElementAreaProto_Rectangle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementAreaProto_Rectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementAreaProto_Rectangle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementAreaProto_Rectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementAreaProto_Rectangle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementAreaProto_Rectangle& from);
  void MergeFrom(const ElementAreaProto_Rectangle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementAreaProto_Rectangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementAreaProto.Rectangle";
  }
  protected:
  explicit ElementAreaProto_Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
    kFullWidthFieldNumber = 2,
  };
  // repeated .autofill_assistant.SelectorProto elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::autofill_assistant::SelectorProto* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto >*
      mutable_elements();
  private:
  const ::autofill_assistant::SelectorProto& _internal_elements(int index) const;
  ::autofill_assistant::SelectorProto* _internal_add_elements();
  public:
  const ::autofill_assistant::SelectorProto& elements(int index) const;
  ::autofill_assistant::SelectorProto* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto >&
      elements() const;

  // optional bool full_width = 2;
  bool has_full_width() const;
  private:
  bool _internal_has_full_width() const;
  public:
  void clear_full_width();
  bool full_width() const;
  void set_full_width(bool value);
  private:
  bool _internal_full_width() const;
  void _internal_set_full_width(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementAreaProto.Rectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto > elements_;
  bool full_width_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementAreaProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementAreaProto) */ {
 public:
  inline ElementAreaProto() : ElementAreaProto(nullptr) {}
  ~ElementAreaProto() override;
  explicit PROTOBUF_CONSTEXPR ElementAreaProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementAreaProto(const ElementAreaProto& from);
  ElementAreaProto(ElementAreaProto&& from) noexcept
    : ElementAreaProto() {
    *this = ::std::move(from);
  }

  inline ElementAreaProto& operator=(const ElementAreaProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementAreaProto& operator=(ElementAreaProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementAreaProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementAreaProto* internal_default_instance() {
    return reinterpret_cast<const ElementAreaProto*>(
               &_ElementAreaProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(ElementAreaProto& a, ElementAreaProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementAreaProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementAreaProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementAreaProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementAreaProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementAreaProto& from);
  void MergeFrom(const ElementAreaProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementAreaProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementAreaProto";
  }
  protected:
  explicit ElementAreaProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ElementAreaProto_Rectangle Rectangle;

  // accessors -------------------------------------------------------

  enum : int {
    kTouchableFieldNumber = 1,
    kRestrictedFieldNumber = 2,
  };
  // repeated .autofill_assistant.ElementAreaProto.Rectangle touchable = 1;
  int touchable_size() const;
  private:
  int _internal_touchable_size() const;
  public:
  void clear_touchable();
  ::autofill_assistant::ElementAreaProto_Rectangle* mutable_touchable(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >*
      mutable_touchable();
  private:
  const ::autofill_assistant::ElementAreaProto_Rectangle& _internal_touchable(int index) const;
  ::autofill_assistant::ElementAreaProto_Rectangle* _internal_add_touchable();
  public:
  const ::autofill_assistant::ElementAreaProto_Rectangle& touchable(int index) const;
  ::autofill_assistant::ElementAreaProto_Rectangle* add_touchable();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >&
      touchable() const;

  // repeated .autofill_assistant.ElementAreaProto.Rectangle restricted = 2;
  int restricted_size() const;
  private:
  int _internal_restricted_size() const;
  public:
  void clear_restricted();
  ::autofill_assistant::ElementAreaProto_Rectangle* mutable_restricted(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >*
      mutable_restricted();
  private:
  const ::autofill_assistant::ElementAreaProto_Rectangle& _internal_restricted(int index) const;
  ::autofill_assistant::ElementAreaProto_Rectangle* _internal_add_restricted();
  public:
  const ::autofill_assistant::ElementAreaProto_Rectangle& restricted(int index) const;
  ::autofill_assistant::ElementAreaProto_Rectangle* add_restricted();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >&
      restricted() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementAreaProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle > touchable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle > restricted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RequiredFieldProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.RequiredFieldProto) */ {
 public:
  inline RequiredFieldProto() : RequiredFieldProto(nullptr) {}
  ~RequiredFieldProto() override;
  explicit PROTOBUF_CONSTEXPR RequiredFieldProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequiredFieldProto(const RequiredFieldProto& from);
  RequiredFieldProto(RequiredFieldProto&& from) noexcept
    : RequiredFieldProto() {
    *this = ::std::move(from);
  }

  inline RequiredFieldProto& operator=(const RequiredFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequiredFieldProto& operator=(RequiredFieldProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RequiredFieldProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequiredFieldProto* internal_default_instance() {
    return reinterpret_cast<const RequiredFieldProto*>(
               &_RequiredFieldProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(RequiredFieldProto& a, RequiredFieldProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RequiredFieldProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequiredFieldProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequiredFieldProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequiredFieldProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RequiredFieldProto& from);
  void MergeFrom(const RequiredFieldProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequiredFieldProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.RequiredFieldProto";
  }
  protected:
  explicit RequiredFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementFieldNumber = 2,
    kOptionElementToClickFieldNumber = 9,
    kValueExpressionFieldNumber = 12,
    kOptionComparisonValueExpressionRe2FieldNumber = 14,
    kFillStrategyFieldNumber = 7,
    kSelectStrategyFieldNumber = 8,
    kForcedFieldNumber = 5,
    kIsOptionalFieldNumber = 11,
    kClickTypeFieldNumber = 10,
    kOptionComparisonAttributeFieldNumber = 13,
    kDelayInMillisecondFieldNumber = 4,
  };
  // optional .autofill_assistant.SelectorProto element = 2;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::autofill_assistant::SelectorProto& element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_element();
  ::autofill_assistant::SelectorProto* mutable_element();
  void set_allocated_element(::autofill_assistant::SelectorProto* element);
  private:
  const ::autofill_assistant::SelectorProto& _internal_element() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::autofill_assistant::SelectorProto* element);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_element();

  // optional .autofill_assistant.SelectorProto option_element_to_click = 9;
  bool has_option_element_to_click() const;
  private:
  bool _internal_has_option_element_to_click() const;
  public:
  void clear_option_element_to_click();
  const ::autofill_assistant::SelectorProto& option_element_to_click() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_option_element_to_click();
  ::autofill_assistant::SelectorProto* mutable_option_element_to_click();
  void set_allocated_option_element_to_click(::autofill_assistant::SelectorProto* option_element_to_click);
  private:
  const ::autofill_assistant::SelectorProto& _internal_option_element_to_click() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_option_element_to_click();
  public:
  void unsafe_arena_set_allocated_option_element_to_click(
      ::autofill_assistant::SelectorProto* option_element_to_click);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_option_element_to_click();

  // optional .autofill_assistant.ValueExpression value_expression = 12;
  bool has_value_expression() const;
  private:
  bool _internal_has_value_expression() const;
  public:
  void clear_value_expression();
  const ::autofill_assistant::ValueExpression& value_expression() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueExpression* release_value_expression();
  ::autofill_assistant::ValueExpression* mutable_value_expression();
  void set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression);
  private:
  const ::autofill_assistant::ValueExpression& _internal_value_expression() const;
  ::autofill_assistant::ValueExpression* _internal_mutable_value_expression();
  public:
  void unsafe_arena_set_allocated_value_expression(
      ::autofill_assistant::ValueExpression* value_expression);
  ::autofill_assistant::ValueExpression* unsafe_arena_release_value_expression();

  // optional .autofill_assistant.ValueExpressionRegexp option_comparison_value_expression_re2 = 14;
  bool has_option_comparison_value_expression_re2() const;
  private:
  bool _internal_has_option_comparison_value_expression_re2() const;
  public:
  void clear_option_comparison_value_expression_re2();
  const ::autofill_assistant::ValueExpressionRegexp& option_comparison_value_expression_re2() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ValueExpressionRegexp* release_option_comparison_value_expression_re2();
  ::autofill_assistant::ValueExpressionRegexp* mutable_option_comparison_value_expression_re2();
  void set_allocated_option_comparison_value_expression_re2(::autofill_assistant::ValueExpressionRegexp* option_comparison_value_expression_re2);
  private:
  const ::autofill_assistant::ValueExpressionRegexp& _internal_option_comparison_value_expression_re2() const;
  ::autofill_assistant::ValueExpressionRegexp* _internal_mutable_option_comparison_value_expression_re2();
  public:
  void unsafe_arena_set_allocated_option_comparison_value_expression_re2(
      ::autofill_assistant::ValueExpressionRegexp* option_comparison_value_expression_re2);
  ::autofill_assistant::ValueExpressionRegexp* unsafe_arena_release_option_comparison_value_expression_re2();

  // optional .autofill_assistant.KeyboardValueFillStrategy fill_strategy = 7;
  bool has_fill_strategy() const;
  private:
  bool _internal_has_fill_strategy() const;
  public:
  void clear_fill_strategy();
  ::autofill_assistant::KeyboardValueFillStrategy fill_strategy() const;
  void set_fill_strategy(::autofill_assistant::KeyboardValueFillStrategy value);
  private:
  ::autofill_assistant::KeyboardValueFillStrategy _internal_fill_strategy() const;
  void _internal_set_fill_strategy(::autofill_assistant::KeyboardValueFillStrategy value);
  public:

  // optional .autofill_assistant.DropdownSelectStrategy select_strategy = 8;
  bool has_select_strategy() const;
  private:
  bool _internal_has_select_strategy() const;
  public:
  void clear_select_strategy();
  ::autofill_assistant::DropdownSelectStrategy select_strategy() const;
  void set_select_strategy(::autofill_assistant::DropdownSelectStrategy value);
  private:
  ::autofill_assistant::DropdownSelectStrategy _internal_select_strategy() const;
  void _internal_set_select_strategy(::autofill_assistant::DropdownSelectStrategy value);
  public:

  // optional bool forced = 5;
  bool has_forced() const;
  private:
  bool _internal_has_forced() const;
  public:
  void clear_forced();
  bool forced() const;
  void set_forced(bool value);
  private:
  bool _internal_forced() const;
  void _internal_set_forced(bool value);
  public:

  // optional bool is_optional = 11;
  bool has_is_optional() const;
  private:
  bool _internal_has_is_optional() const;
  public:
  void clear_is_optional();
  bool is_optional() const;
  void set_is_optional(bool value);
  private:
  bool _internal_is_optional() const;
  void _internal_set_is_optional(bool value);
  public:

  // optional .autofill_assistant.ClickType click_type = 10;
  bool has_click_type() const;
  private:
  bool _internal_has_click_type() const;
  public:
  void clear_click_type();
  ::autofill_assistant::ClickType click_type() const;
  void set_click_type(::autofill_assistant::ClickType value);
  private:
  ::autofill_assistant::ClickType _internal_click_type() const;
  void _internal_set_click_type(::autofill_assistant::ClickType value);
  public:

  // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 13;
  bool has_option_comparison_attribute() const;
  private:
  bool _internal_has_option_comparison_attribute() const;
  public:
  void clear_option_comparison_attribute();
  ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute option_comparison_attribute() const;
  void set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value);
  private:
  ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute _internal_option_comparison_attribute() const;
  void _internal_set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value);
  public:

  // optional int32 delay_in_millisecond = 4 [default = 20];
  bool has_delay_in_millisecond() const;
  private:
  bool _internal_has_delay_in_millisecond() const;
  public:
  void clear_delay_in_millisecond();
  int32_t delay_in_millisecond() const;
  void set_delay_in_millisecond(int32_t value);
  private:
  int32_t _internal_delay_in_millisecond() const;
  void _internal_set_delay_in_millisecond(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.RequiredFieldProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto* element_;
  ::autofill_assistant::SelectorProto* option_element_to_click_;
  ::autofill_assistant::ValueExpression* value_expression_;
  ::autofill_assistant::ValueExpressionRegexp* option_comparison_value_expression_re2_;
  int fill_strategy_;
  int select_strategy_;
  bool forced_;
  bool is_optional_;
  int click_type_;
  int option_comparison_attribute_;
  int32_t delay_in_millisecond_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UseAddressProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UseAddressProto) */ {
 public:
  inline UseAddressProto() : UseAddressProto(nullptr) {}
  ~UseAddressProto() override;
  explicit PROTOBUF_CONSTEXPR UseAddressProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseAddressProto(const UseAddressProto& from);
  UseAddressProto(UseAddressProto&& from) noexcept
    : UseAddressProto() {
    *this = ::std::move(from);
  }

  inline UseAddressProto& operator=(const UseAddressProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseAddressProto& operator=(UseAddressProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UseAddressProto& default_instance() {
    return *internal_default_instance();
  }
  enum AddressSourceCase {
    kName = 1,
    kModelIdentifier = 9,
    ADDRESS_SOURCE_NOT_SET = 0,
  };

  static inline const UseAddressProto* internal_default_instance() {
    return reinterpret_cast<const UseAddressProto*>(
               &_UseAddressProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(UseAddressProto& a, UseAddressProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UseAddressProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseAddressProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseAddressProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseAddressProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UseAddressProto& from);
  void MergeFrom(const UseAddressProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UseAddressProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UseAddressProto";
  }
  protected:
  explicit UseAddressProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredFieldsFieldNumber = 6,
    kFormFieldElementFieldNumber = 4,
    kSkipAutofillFieldNumber = 10,
    kNameFieldNumber = 1,
    kModelIdentifierFieldNumber = 9,
  };
  // repeated .autofill_assistant.RequiredFieldProto required_fields = 6;
  int required_fields_size() const;
  private:
  int _internal_required_fields_size() const;
  public:
  void clear_required_fields();
  ::autofill_assistant::RequiredFieldProto* mutable_required_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >*
      mutable_required_fields();
  private:
  const ::autofill_assistant::RequiredFieldProto& _internal_required_fields(int index) const;
  ::autofill_assistant::RequiredFieldProto* _internal_add_required_fields();
  public:
  const ::autofill_assistant::RequiredFieldProto& required_fields(int index) const;
  ::autofill_assistant::RequiredFieldProto* add_required_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >&
      required_fields() const;

  // optional .autofill_assistant.SelectorProto form_field_element = 4;
  bool has_form_field_element() const;
  private:
  bool _internal_has_form_field_element() const;
  public:
  void clear_form_field_element();
  const ::autofill_assistant::SelectorProto& form_field_element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_form_field_element();
  ::autofill_assistant::SelectorProto* mutable_form_field_element();
  void set_allocated_form_field_element(::autofill_assistant::SelectorProto* form_field_element);
  private:
  const ::autofill_assistant::SelectorProto& _internal_form_field_element() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_form_field_element();
  public:
  void unsafe_arena_set_allocated_form_field_element(
      ::autofill_assistant::SelectorProto* form_field_element);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_form_field_element();

  // optional bool skip_autofill = 10;
  bool has_skip_autofill() const;
  private:
  bool _internal_has_skip_autofill() const;
  public:
  void clear_skip_autofill();
  bool skip_autofill() const;
  void set_skip_autofill(bool value);
  private:
  bool _internal_skip_autofill() const;
  void _internal_set_skip_autofill(bool value);
  public:

  // string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string model_identifier = 9;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  void clear_address_source();
  AddressSourceCase address_source_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.UseAddressProto)
 private:
  class _Internal;
  void set_has_name();
  void set_has_model_identifier();

  inline bool has_address_source() const;
  inline void clear_has_address_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto > required_fields_;
  ::autofill_assistant::SelectorProto* form_field_element_;
  bool skip_autofill_;
  union AddressSourceUnion {
    constexpr AddressSourceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  } address_source_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UseCreditCardProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UseCreditCardProto) */ {
 public:
  inline UseCreditCardProto() : UseCreditCardProto(nullptr) {}
  ~UseCreditCardProto() override;
  explicit PROTOBUF_CONSTEXPR UseCreditCardProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseCreditCardProto(const UseCreditCardProto& from);
  UseCreditCardProto(UseCreditCardProto&& from) noexcept
    : UseCreditCardProto() {
    *this = ::std::move(from);
  }

  inline UseCreditCardProto& operator=(const UseCreditCardProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseCreditCardProto& operator=(UseCreditCardProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UseCreditCardProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseCreditCardProto* internal_default_instance() {
    return reinterpret_cast<const UseCreditCardProto*>(
               &_UseCreditCardProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(UseCreditCardProto& a, UseCreditCardProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UseCreditCardProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseCreditCardProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseCreditCardProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseCreditCardProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UseCreditCardProto& from);
  void MergeFrom(const UseCreditCardProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UseCreditCardProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UseCreditCardProto";
  }
  protected:
  explicit UseCreditCardProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredFieldsFieldNumber = 7,
    kModelIdentifierFieldNumber = 4,
    kFormFieldElementFieldNumber = 3,
    kSkipAutofillFieldNumber = 8,
    kSkipResolveFieldNumber = 9,
  };
  // repeated .autofill_assistant.RequiredFieldProto required_fields = 7;
  int required_fields_size() const;
  private:
  int _internal_required_fields_size() const;
  public:
  void clear_required_fields();
  ::autofill_assistant::RequiredFieldProto* mutable_required_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >*
      mutable_required_fields();
  private:
  const ::autofill_assistant::RequiredFieldProto& _internal_required_fields(int index) const;
  ::autofill_assistant::RequiredFieldProto* _internal_add_required_fields();
  public:
  const ::autofill_assistant::RequiredFieldProto& required_fields(int index) const;
  ::autofill_assistant::RequiredFieldProto* add_required_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >&
      required_fields() const;

  // optional string model_identifier = 4;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // optional .autofill_assistant.SelectorProto form_field_element = 3;
  bool has_form_field_element() const;
  private:
  bool _internal_has_form_field_element() const;
  public:
  void clear_form_field_element();
  const ::autofill_assistant::SelectorProto& form_field_element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_form_field_element();
  ::autofill_assistant::SelectorProto* mutable_form_field_element();
  void set_allocated_form_field_element(::autofill_assistant::SelectorProto* form_field_element);
  private:
  const ::autofill_assistant::SelectorProto& _internal_form_field_element() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_form_field_element();
  public:
  void unsafe_arena_set_allocated_form_field_element(
      ::autofill_assistant::SelectorProto* form_field_element);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_form_field_element();

  // optional bool skip_autofill = 8;
  bool has_skip_autofill() const;
  private:
  bool _internal_has_skip_autofill() const;
  public:
  void clear_skip_autofill();
  bool skip_autofill() const;
  void set_skip_autofill(bool value);
  private:
  bool _internal_skip_autofill() const;
  void _internal_set_skip_autofill(bool value);
  public:

  // optional bool skip_resolve = 9;
  bool has_skip_resolve() const;
  private:
  bool _internal_has_skip_resolve() const;
  public:
  void clear_skip_resolve();
  bool skip_resolve() const;
  void set_skip_resolve(bool value);
  private:
  bool _internal_skip_resolve() const;
  void _internal_set_skip_resolve(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.UseCreditCardProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto > required_fields_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  ::autofill_assistant::SelectorProto* form_field_element_;
  bool skip_autofill_;
  bool skip_resolve_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForDomProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForDomProto.Result) */ {
 public:
  inline WaitForDomProto_Result() : WaitForDomProto_Result(nullptr) {}
  ~WaitForDomProto_Result() override;
  explicit PROTOBUF_CONSTEXPR WaitForDomProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForDomProto_Result(const WaitForDomProto_Result& from);
  WaitForDomProto_Result(WaitForDomProto_Result&& from) noexcept
    : WaitForDomProto_Result() {
    *this = ::std::move(from);
  }

  inline WaitForDomProto_Result& operator=(const WaitForDomProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForDomProto_Result& operator=(WaitForDomProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForDomProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForDomProto_Result* internal_default_instance() {
    return reinterpret_cast<const WaitForDomProto_Result*>(
               &_WaitForDomProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(WaitForDomProto_Result& a, WaitForDomProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForDomProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForDomProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForDomProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForDomProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForDomProto_Result& from);
  void MergeFrom(const WaitForDomProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForDomProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForDomProto.Result";
  }
  protected:
  explicit WaitForDomProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchingConditionPayloadsFieldNumber = 1,
    kMatchingConditionTagsFieldNumber = 2,
  };
  // repeated bytes matching_condition_payloads = 1;
  int matching_condition_payloads_size() const;
  private:
  int _internal_matching_condition_payloads_size() const;
  public:
  void clear_matching_condition_payloads();
  const std::string& matching_condition_payloads(int index) const;
  std::string* mutable_matching_condition_payloads(int index);
  void set_matching_condition_payloads(int index, const std::string& value);
  void set_matching_condition_payloads(int index, std::string&& value);
  void set_matching_condition_payloads(int index, const char* value);
  void set_matching_condition_payloads(int index, const void* value, size_t size);
  std::string* add_matching_condition_payloads();
  void add_matching_condition_payloads(const std::string& value);
  void add_matching_condition_payloads(std::string&& value);
  void add_matching_condition_payloads(const char* value);
  void add_matching_condition_payloads(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& matching_condition_payloads() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_matching_condition_payloads();
  private:
  const std::string& _internal_matching_condition_payloads(int index) const;
  std::string* _internal_add_matching_condition_payloads();
  public:

  // repeated string matching_condition_tags = 2;
  int matching_condition_tags_size() const;
  private:
  int _internal_matching_condition_tags_size() const;
  public:
  void clear_matching_condition_tags();
  const std::string& matching_condition_tags(int index) const;
  std::string* mutable_matching_condition_tags(int index);
  void set_matching_condition_tags(int index, const std::string& value);
  void set_matching_condition_tags(int index, std::string&& value);
  void set_matching_condition_tags(int index, const char* value);
  void set_matching_condition_tags(int index, const char* value, size_t size);
  std::string* add_matching_condition_tags();
  void add_matching_condition_tags(const std::string& value);
  void add_matching_condition_tags(std::string&& value);
  void add_matching_condition_tags(const char* value);
  void add_matching_condition_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& matching_condition_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_matching_condition_tags();
  private:
  const std::string& _internal_matching_condition_tags(int index) const;
  std::string* _internal_add_matching_condition_tags();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForDomProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> matching_condition_payloads_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> matching_condition_tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForDomProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForDomProto) */ {
 public:
  inline WaitForDomProto() : WaitForDomProto(nullptr) {}
  ~WaitForDomProto() override;
  explicit PROTOBUF_CONSTEXPR WaitForDomProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForDomProto(const WaitForDomProto& from);
  WaitForDomProto(WaitForDomProto&& from) noexcept
    : WaitForDomProto() {
    *this = ::std::move(from);
  }

  inline WaitForDomProto& operator=(const WaitForDomProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForDomProto& operator=(WaitForDomProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForDomProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForDomProto* internal_default_instance() {
    return reinterpret_cast<const WaitForDomProto*>(
               &_WaitForDomProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(WaitForDomProto& a, WaitForDomProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForDomProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForDomProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForDomProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForDomProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForDomProto& from);
  void MergeFrom(const WaitForDomProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForDomProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForDomProto";
  }
  protected:
  explicit WaitForDomProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WaitForDomProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kWaitConditionFieldNumber = 9,
    kTimeoutMsFieldNumber = 1,
    kAllowInterruptFieldNumber = 3,
  };
  // optional .autofill_assistant.ElementConditionProto wait_condition = 9;
  bool has_wait_condition() const;
  private:
  bool _internal_has_wait_condition() const;
  public:
  void clear_wait_condition();
  const ::autofill_assistant::ElementConditionProto& wait_condition() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionProto* release_wait_condition();
  ::autofill_assistant::ElementConditionProto* mutable_wait_condition();
  void set_allocated_wait_condition(::autofill_assistant::ElementConditionProto* wait_condition);
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_wait_condition() const;
  ::autofill_assistant::ElementConditionProto* _internal_mutable_wait_condition();
  public:
  void unsafe_arena_set_allocated_wait_condition(
      ::autofill_assistant::ElementConditionProto* wait_condition);
  ::autofill_assistant::ElementConditionProto* unsafe_arena_release_wait_condition();

  // optional int32 timeout_ms = 1;
  bool has_timeout_ms() const;
  private:
  bool _internal_has_timeout_ms() const;
  public:
  void clear_timeout_ms();
  int32_t timeout_ms() const;
  void set_timeout_ms(int32_t value);
  private:
  int32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(int32_t value);
  public:

  // optional bool allow_interrupt = 3;
  bool has_allow_interrupt() const;
  private:
  bool _internal_has_allow_interrupt() const;
  public:
  void clear_allow_interrupt();
  bool allow_interrupt() const;
  void set_allow_interrupt(bool value);
  private:
  bool _internal_allow_interrupt() const;
  void _internal_set_allow_interrupt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForDomProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ElementConditionProto* wait_condition_;
  int32_t timeout_ms_;
  bool allow_interrupt_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementConditionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementConditionProto) */ {
 public:
  inline ElementConditionProto() : ElementConditionProto(nullptr) {}
  ~ElementConditionProto() override;
  explicit PROTOBUF_CONSTEXPR ElementConditionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementConditionProto(const ElementConditionProto& from);
  ElementConditionProto(ElementConditionProto&& from) noexcept
    : ElementConditionProto() {
    *this = ::std::move(from);
  }

  inline ElementConditionProto& operator=(const ElementConditionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementConditionProto& operator=(ElementConditionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementConditionProto& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kAllOf = 1,
    kAnyOf = 2,
    kNoneOf = 3,
    kMatch = 4,
    TYPE_NOT_SET = 0,
  };

  static inline const ElementConditionProto* internal_default_instance() {
    return reinterpret_cast<const ElementConditionProto*>(
               &_ElementConditionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(ElementConditionProto& a, ElementConditionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementConditionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementConditionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementConditionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementConditionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementConditionProto& from);
  void MergeFrom(const ElementConditionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementConditionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementConditionProto";
  }
  protected:
  explicit ElementConditionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 5,
    kTagFieldNumber = 8,
    kClientIdFieldNumber = 6,
    kRequireUniqueElementFieldNumber = 7,
    kAllOfFieldNumber = 1,
    kAnyOfFieldNumber = 2,
    kNoneOfFieldNumber = 3,
    kMatchFieldNumber = 4,
  };
  // optional bytes payload = 5;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string tag = 8;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .autofill_assistant.ClientIdProto client_id = 6;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional bool require_unique_element = 7;
  bool has_require_unique_element() const;
  private:
  bool _internal_has_require_unique_element() const;
  public:
  void clear_require_unique_element();
  bool require_unique_element() const;
  void set_require_unique_element(bool value);
  private:
  bool _internal_require_unique_element() const;
  void _internal_set_require_unique_element(bool value);
  public:

  // .autofill_assistant.ElementConditionsProto all_of = 1;
  bool has_all_of() const;
  private:
  bool _internal_has_all_of() const;
  public:
  void clear_all_of();
  const ::autofill_assistant::ElementConditionsProto& all_of() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionsProto* release_all_of();
  ::autofill_assistant::ElementConditionsProto* mutable_all_of();
  void set_allocated_all_of(::autofill_assistant::ElementConditionsProto* all_of);
  private:
  const ::autofill_assistant::ElementConditionsProto& _internal_all_of() const;
  ::autofill_assistant::ElementConditionsProto* _internal_mutable_all_of();
  public:
  void unsafe_arena_set_allocated_all_of(
      ::autofill_assistant::ElementConditionsProto* all_of);
  ::autofill_assistant::ElementConditionsProto* unsafe_arena_release_all_of();

  // .autofill_assistant.ElementConditionsProto any_of = 2;
  bool has_any_of() const;
  private:
  bool _internal_has_any_of() const;
  public:
  void clear_any_of();
  const ::autofill_assistant::ElementConditionsProto& any_of() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionsProto* release_any_of();
  ::autofill_assistant::ElementConditionsProto* mutable_any_of();
  void set_allocated_any_of(::autofill_assistant::ElementConditionsProto* any_of);
  private:
  const ::autofill_assistant::ElementConditionsProto& _internal_any_of() const;
  ::autofill_assistant::ElementConditionsProto* _internal_mutable_any_of();
  public:
  void unsafe_arena_set_allocated_any_of(
      ::autofill_assistant::ElementConditionsProto* any_of);
  ::autofill_assistant::ElementConditionsProto* unsafe_arena_release_any_of();

  // .autofill_assistant.ElementConditionsProto none_of = 3;
  bool has_none_of() const;
  private:
  bool _internal_has_none_of() const;
  public:
  void clear_none_of();
  const ::autofill_assistant::ElementConditionsProto& none_of() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionsProto* release_none_of();
  ::autofill_assistant::ElementConditionsProto* mutable_none_of();
  void set_allocated_none_of(::autofill_assistant::ElementConditionsProto* none_of);
  private:
  const ::autofill_assistant::ElementConditionsProto& _internal_none_of() const;
  ::autofill_assistant::ElementConditionsProto* _internal_mutable_none_of();
  public:
  void unsafe_arena_set_allocated_none_of(
      ::autofill_assistant::ElementConditionsProto* none_of);
  ::autofill_assistant::ElementConditionsProto* unsafe_arena_release_none_of();

  // .autofill_assistant.SelectorProto match = 4;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::autofill_assistant::SelectorProto& match() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_match();
  ::autofill_assistant::SelectorProto* mutable_match();
  void set_allocated_match(::autofill_assistant::SelectorProto* match);
  private:
  const ::autofill_assistant::SelectorProto& _internal_match() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::autofill_assistant::SelectorProto* match);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_match();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementConditionProto)
 private:
  class _Internal;
  void set_has_all_of();
  void set_has_any_of();
  void set_has_none_of();
  void set_has_match();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::autofill_assistant::ClientIdProto* client_id_;
  bool require_unique_element_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::ElementConditionsProto* all_of_;
    ::autofill_assistant::ElementConditionsProto* any_of_;
    ::autofill_assistant::ElementConditionsProto* none_of_;
    ::autofill_assistant::SelectorProto* match_;
  } type_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementConditionsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ElementConditionsProto) */ {
 public:
  inline ElementConditionsProto() : ElementConditionsProto(nullptr) {}
  ~ElementConditionsProto() override;
  explicit PROTOBUF_CONSTEXPR ElementConditionsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementConditionsProto(const ElementConditionsProto& from);
  ElementConditionsProto(ElementConditionsProto&& from) noexcept
    : ElementConditionsProto() {
    *this = ::std::move(from);
  }

  inline ElementConditionsProto& operator=(const ElementConditionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementConditionsProto& operator=(ElementConditionsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ElementConditionsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementConditionsProto* internal_default_instance() {
    return reinterpret_cast<const ElementConditionsProto*>(
               &_ElementConditionsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(ElementConditionsProto& a, ElementConditionsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ElementConditionsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementConditionsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementConditionsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementConditionsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ElementConditionsProto& from);
  void MergeFrom(const ElementConditionsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ElementConditionsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ElementConditionsProto";
  }
  protected:
  explicit ElementConditionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
  };
  // repeated .autofill_assistant.ElementConditionProto conditions = 1;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::autofill_assistant::ElementConditionProto* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementConditionProto >*
      mutable_conditions();
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_conditions(int index) const;
  ::autofill_assistant::ElementConditionProto* _internal_add_conditions();
  public:
  const ::autofill_assistant::ElementConditionProto& conditions(int index) const;
  ::autofill_assistant::ElementConditionProto* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementConditionProto >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ElementConditionsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementConditionProto > conditions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UploadDomProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UploadDomProto.Result) */ {
 public:
  inline UploadDomProto_Result() : UploadDomProto_Result(nullptr) {}
  ~UploadDomProto_Result() override;
  explicit PROTOBUF_CONSTEXPR UploadDomProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadDomProto_Result(const UploadDomProto_Result& from);
  UploadDomProto_Result(UploadDomProto_Result&& from) noexcept
    : UploadDomProto_Result() {
    *this = ::std::move(from);
  }

  inline UploadDomProto_Result& operator=(const UploadDomProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadDomProto_Result& operator=(UploadDomProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UploadDomProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadDomProto_Result* internal_default_instance() {
    return reinterpret_cast<const UploadDomProto_Result*>(
               &_UploadDomProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(UploadDomProto_Result& a, UploadDomProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UploadDomProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadDomProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadDomProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadDomProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadDomProto_Result& from);
  void MergeFrom(const UploadDomProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadDomProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UploadDomProto.Result";
  }
  protected:
  explicit UploadDomProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOuterHtmlsFieldNumber = 1,
  };
  // repeated string outer_htmls = 1;
  int outer_htmls_size() const;
  private:
  int _internal_outer_htmls_size() const;
  public:
  void clear_outer_htmls();
  const std::string& outer_htmls(int index) const;
  std::string* mutable_outer_htmls(int index);
  void set_outer_htmls(int index, const std::string& value);
  void set_outer_htmls(int index, std::string&& value);
  void set_outer_htmls(int index, const char* value);
  void set_outer_htmls(int index, const char* value, size_t size);
  std::string* add_outer_htmls();
  void add_outer_htmls(const std::string& value);
  void add_outer_htmls(std::string&& value);
  void add_outer_htmls(const char* value);
  void add_outer_htmls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& outer_htmls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_outer_htmls();
  private:
  const std::string& _internal_outer_htmls(int index) const;
  std::string* _internal_add_outer_htmls();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.UploadDomProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> outer_htmls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UploadDomProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UploadDomProto) */ {
 public:
  inline UploadDomProto() : UploadDomProto(nullptr) {}
  ~UploadDomProto() override;
  explicit PROTOBUF_CONSTEXPR UploadDomProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadDomProto(const UploadDomProto& from);
  UploadDomProto(UploadDomProto&& from) noexcept
    : UploadDomProto() {
    *this = ::std::move(from);
  }

  inline UploadDomProto& operator=(const UploadDomProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadDomProto& operator=(UploadDomProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UploadDomProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadDomProto* internal_default_instance() {
    return reinterpret_cast<const UploadDomProto*>(
               &_UploadDomProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(UploadDomProto& a, UploadDomProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UploadDomProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadDomProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadDomProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadDomProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadDomProto& from);
  void MergeFrom(const UploadDomProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadDomProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UploadDomProto";
  }
  protected:
  explicit UploadDomProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UploadDomProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kTreeRootFieldNumber = 1,
    kCanMatchMultipleElementsFieldNumber = 2,
    kIncludeAllInnerTextFieldNumber = 3,
  };
  // optional .autofill_assistant.SelectorProto tree_root = 1;
  bool has_tree_root() const;
  private:
  bool _internal_has_tree_root() const;
  public:
  void clear_tree_root();
  const ::autofill_assistant::SelectorProto& tree_root() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_tree_root();
  ::autofill_assistant::SelectorProto* mutable_tree_root();
  void set_allocated_tree_root(::autofill_assistant::SelectorProto* tree_root);
  private:
  const ::autofill_assistant::SelectorProto& _internal_tree_root() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_tree_root();
  public:
  void unsafe_arena_set_allocated_tree_root(
      ::autofill_assistant::SelectorProto* tree_root);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_tree_root();

  // optional bool can_match_multiple_elements = 2;
  bool has_can_match_multiple_elements() const;
  private:
  bool _internal_has_can_match_multiple_elements() const;
  public:
  void clear_can_match_multiple_elements();
  bool can_match_multiple_elements() const;
  void set_can_match_multiple_elements(bool value);
  private:
  bool _internal_can_match_multiple_elements() const;
  void _internal_set_can_match_multiple_elements(bool value);
  public:

  // optional bool include_all_inner_text = 3;
  bool has_include_all_inner_text() const;
  private:
  bool _internal_has_include_all_inner_text() const;
  public:
  void clear_include_all_inner_text();
  bool include_all_inner_text() const;
  void set_include_all_inner_text(bool value);
  private:
  bool _internal_include_all_inner_text() const;
  void _internal_set_include_all_inner_text(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.UploadDomProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto* tree_root_;
  bool can_match_multiple_elements_;
  bool include_all_inner_text_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowProgressBarProto_StepProgressBarIcon final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon) */ {
 public:
  inline ShowProgressBarProto_StepProgressBarIcon() : ShowProgressBarProto_StepProgressBarIcon(nullptr) {}
  ~ShowProgressBarProto_StepProgressBarIcon() override;
  explicit PROTOBUF_CONSTEXPR ShowProgressBarProto_StepProgressBarIcon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowProgressBarProto_StepProgressBarIcon(const ShowProgressBarProto_StepProgressBarIcon& from);
  ShowProgressBarProto_StepProgressBarIcon(ShowProgressBarProto_StepProgressBarIcon&& from) noexcept
    : ShowProgressBarProto_StepProgressBarIcon() {
    *this = ::std::move(from);
  }

  inline ShowProgressBarProto_StepProgressBarIcon& operator=(const ShowProgressBarProto_StepProgressBarIcon& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowProgressBarProto_StepProgressBarIcon& operator=(ShowProgressBarProto_StepProgressBarIcon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowProgressBarProto_StepProgressBarIcon& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowProgressBarProto_StepProgressBarIcon* internal_default_instance() {
    return reinterpret_cast<const ShowProgressBarProto_StepProgressBarIcon*>(
               &_ShowProgressBarProto_StepProgressBarIcon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(ShowProgressBarProto_StepProgressBarIcon& a, ShowProgressBarProto_StepProgressBarIcon& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowProgressBarProto_StepProgressBarIcon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowProgressBarProto_StepProgressBarIcon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowProgressBarProto_StepProgressBarIcon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowProgressBarProto_StepProgressBarIcon>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowProgressBarProto_StepProgressBarIcon& from);
  void MergeFrom(const ShowProgressBarProto_StepProgressBarIcon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowProgressBarProto_StepProgressBarIcon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowProgressBarProto.StepProgressBarIcon";
  }
  protected:
  explicit ShowProgressBarProto_StepProgressBarIcon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 2,
    kIconFieldNumber = 1,
  };
  // optional string identifier = 2;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .autofill_assistant.DrawableProto icon = 1;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const ::autofill_assistant::DrawableProto& icon() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DrawableProto* release_icon();
  ::autofill_assistant::DrawableProto* mutable_icon();
  void set_allocated_icon(::autofill_assistant::DrawableProto* icon);
  private:
  const ::autofill_assistant::DrawableProto& _internal_icon() const;
  ::autofill_assistant::DrawableProto* _internal_mutable_icon();
  public:
  void unsafe_arena_set_allocated_icon(
      ::autofill_assistant::DrawableProto* icon);
  ::autofill_assistant::DrawableProto* unsafe_arena_release_icon();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::autofill_assistant::DrawableProto* icon_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowProgressBarProto_StepProgressBarConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration) */ {
 public:
  inline ShowProgressBarProto_StepProgressBarConfiguration() : ShowProgressBarProto_StepProgressBarConfiguration(nullptr) {}
  ~ShowProgressBarProto_StepProgressBarConfiguration() override;
  explicit PROTOBUF_CONSTEXPR ShowProgressBarProto_StepProgressBarConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowProgressBarProto_StepProgressBarConfiguration(const ShowProgressBarProto_StepProgressBarConfiguration& from);
  ShowProgressBarProto_StepProgressBarConfiguration(ShowProgressBarProto_StepProgressBarConfiguration&& from) noexcept
    : ShowProgressBarProto_StepProgressBarConfiguration() {
    *this = ::std::move(from);
  }

  inline ShowProgressBarProto_StepProgressBarConfiguration& operator=(const ShowProgressBarProto_StepProgressBarConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowProgressBarProto_StepProgressBarConfiguration& operator=(ShowProgressBarProto_StepProgressBarConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowProgressBarProto_StepProgressBarConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowProgressBarProto_StepProgressBarConfiguration* internal_default_instance() {
    return reinterpret_cast<const ShowProgressBarProto_StepProgressBarConfiguration*>(
               &_ShowProgressBarProto_StepProgressBarConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(ShowProgressBarProto_StepProgressBarConfiguration& a, ShowProgressBarProto_StepProgressBarConfiguration& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowProgressBarProto_StepProgressBarConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowProgressBarProto_StepProgressBarConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowProgressBarProto_StepProgressBarConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowProgressBarProto_StepProgressBarConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowProgressBarProto_StepProgressBarConfiguration& from);
  void MergeFrom(const ShowProgressBarProto_StepProgressBarConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowProgressBarProto_StepProgressBarConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration";
  }
  protected:
  explicit ShowProgressBarProto_StepProgressBarConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotatedStepIconsFieldNumber = 3,
  };
  // repeated .autofill_assistant.ShowProgressBarProto.StepProgressBarIcon annotated_step_icons = 3;
  int annotated_step_icons_size() const;
  private:
  int _internal_annotated_step_icons_size() const;
  public:
  void clear_annotated_step_icons();
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* mutable_annotated_step_icons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon >*
      mutable_annotated_step_icons();
  private:
  const ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon& _internal_annotated_step_icons(int index) const;
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* _internal_add_annotated_step_icons();
  public:
  const ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon& annotated_step_icons(int index) const;
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* add_annotated_step_icons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon >&
      annotated_step_icons() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon > annotated_step_icons_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowProgressBarProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowProgressBarProto) */ {
 public:
  inline ShowProgressBarProto() : ShowProgressBarProto(nullptr) {}
  ~ShowProgressBarProto() override;
  explicit PROTOBUF_CONSTEXPR ShowProgressBarProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowProgressBarProto(const ShowProgressBarProto& from);
  ShowProgressBarProto(ShowProgressBarProto&& from) noexcept
    : ShowProgressBarProto() {
    *this = ::std::move(from);
  }

  inline ShowProgressBarProto& operator=(const ShowProgressBarProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowProgressBarProto& operator=(ShowProgressBarProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowProgressBarProto& default_instance() {
    return *internal_default_instance();
  }
  enum ProgressIndicatorCase {
    kActiveStep = 8,
    kActiveStepIdentifier = 11,
    kCompleteProgress = 12,
    PROGRESS_INDICATOR_NOT_SET = 0,
  };

  static inline const ShowProgressBarProto* internal_default_instance() {
    return reinterpret_cast<const ShowProgressBarProto*>(
               &_ShowProgressBarProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(ShowProgressBarProto& a, ShowProgressBarProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowProgressBarProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowProgressBarProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowProgressBarProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowProgressBarProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowProgressBarProto& from);
  void MergeFrom(const ShowProgressBarProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowProgressBarProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowProgressBarProto";
  }
  protected:
  explicit ShowProgressBarProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShowProgressBarProto_StepProgressBarIcon StepProgressBarIcon;
  typedef ShowProgressBarProto_StepProgressBarConfiguration StepProgressBarConfiguration;

  // accessors -------------------------------------------------------

  enum : int {
    kStepProgressBarConfigurationFieldNumber = 9,
    kErrorStateFieldNumber = 10,
    kHideFieldNumber = 7,
    kActiveStepFieldNumber = 8,
    kActiveStepIdentifierFieldNumber = 11,
    kCompleteProgressFieldNumber = 12,
  };
  // optional .autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration step_progress_bar_configuration = 9;
  bool has_step_progress_bar_configuration() const;
  private:
  bool _internal_has_step_progress_bar_configuration() const;
  public:
  void clear_step_progress_bar_configuration();
  const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration& step_progress_bar_configuration() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* release_step_progress_bar_configuration();
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* mutable_step_progress_bar_configuration();
  void set_allocated_step_progress_bar_configuration(::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* step_progress_bar_configuration);
  private:
  const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration& _internal_step_progress_bar_configuration() const;
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* _internal_mutable_step_progress_bar_configuration();
  public:
  void unsafe_arena_set_allocated_step_progress_bar_configuration(
      ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* step_progress_bar_configuration);
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* unsafe_arena_release_step_progress_bar_configuration();

  // optional bool error_state = 10;
  bool has_error_state() const;
  private:
  bool _internal_has_error_state() const;
  public:
  void clear_error_state();
  bool error_state() const;
  void set_error_state(bool value);
  private:
  bool _internal_error_state() const;
  void _internal_set_error_state(bool value);
  public:

  // optional bool hide = 7;
  bool has_hide() const;
  private:
  bool _internal_has_hide() const;
  public:
  void clear_hide();
  bool hide() const;
  void set_hide(bool value);
  private:
  bool _internal_hide() const;
  void _internal_set_hide(bool value);
  public:

  // int32 active_step = 8;
  bool has_active_step() const;
  private:
  bool _internal_has_active_step() const;
  public:
  void clear_active_step();
  int32_t active_step() const;
  void set_active_step(int32_t value);
  private:
  int32_t _internal_active_step() const;
  void _internal_set_active_step(int32_t value);
  public:

  // string active_step_identifier = 11;
  bool has_active_step_identifier() const;
  private:
  bool _internal_has_active_step_identifier() const;
  public:
  void clear_active_step_identifier();
  const std::string& active_step_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_active_step_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_active_step_identifier();
  PROTOBUF_NODISCARD std::string* release_active_step_identifier();
  void set_allocated_active_step_identifier(std::string* active_step_identifier);
  private:
  const std::string& _internal_active_step_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_active_step_identifier(const std::string& value);
  std::string* _internal_mutable_active_step_identifier();
  public:

  // bool complete_progress = 12;
  bool has_complete_progress() const;
  private:
  bool _internal_has_complete_progress() const;
  public:
  void clear_complete_progress();
  bool complete_progress() const;
  void set_complete_progress(bool value);
  private:
  bool _internal_complete_progress() const;
  void _internal_set_complete_progress(bool value);
  public:

  void clear_progress_indicator();
  ProgressIndicatorCase progress_indicator_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowProgressBarProto)
 private:
  class _Internal;
  void set_has_active_step();
  void set_has_active_step_identifier();
  void set_has_complete_progress();

  inline bool has_progress_indicator() const;
  inline void clear_has_progress_indicator();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* step_progress_bar_configuration_;
  bool error_state_;
  bool hide_;
  union ProgressIndicatorUnion {
    constexpr ProgressIndicatorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t active_step_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr active_step_identifier_;
    bool complete_progress_;
  } progress_indicator_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class NavigateProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.NavigateProto) */ {
 public:
  inline NavigateProto() : NavigateProto(nullptr) {}
  ~NavigateProto() override;
  explicit PROTOBUF_CONSTEXPR NavigateProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigateProto(const NavigateProto& from);
  NavigateProto(NavigateProto&& from) noexcept
    : NavigateProto() {
    *this = ::std::move(from);
  }

  inline NavigateProto& operator=(const NavigateProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigateProto& operator=(NavigateProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NavigateProto& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUrl = 1,
    kGoBackward = 2,
    kGoForward = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const NavigateProto* internal_default_instance() {
    return reinterpret_cast<const NavigateProto*>(
               &_NavigateProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(NavigateProto& a, NavigateProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NavigateProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigateProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigateProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigateProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NavigateProto& from);
  void MergeFrom(const NavigateProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NavigateProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.NavigateProto";
  }
  protected:
  explicit NavigateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kGoBackwardFieldNumber = 2,
    kGoForwardFieldNumber = 3,
  };
  // string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bool go_backward = 2;
  bool has_go_backward() const;
  private:
  bool _internal_has_go_backward() const;
  public:
  void clear_go_backward();
  bool go_backward() const;
  void set_go_backward(bool value);
  private:
  bool _internal_go_backward() const;
  void _internal_set_go_backward(bool value);
  public:

  // bool go_forward = 3;
  bool has_go_forward() const;
  private:
  bool _internal_has_go_forward() const;
  public:
  void clear_go_forward();
  bool go_forward() const;
  void set_go_forward(bool value);
  private:
  bool _internal_go_forward() const;
  void _internal_set_go_forward(bool value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.NavigateProto)
 private:
  class _Internal;
  void set_has_url();
  void set_has_go_backward();
  void set_has_go_forward();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    bool go_backward_;
    bool go_forward_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ExpectNavigationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ExpectNavigationProto) */ {
 public:
  inline ExpectNavigationProto() : ExpectNavigationProto(nullptr) {}
  ~ExpectNavigationProto() override;
  explicit PROTOBUF_CONSTEXPR ExpectNavigationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpectNavigationProto(const ExpectNavigationProto& from);
  ExpectNavigationProto(ExpectNavigationProto&& from) noexcept
    : ExpectNavigationProto() {
    *this = ::std::move(from);
  }

  inline ExpectNavigationProto& operator=(const ExpectNavigationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpectNavigationProto& operator=(ExpectNavigationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExpectNavigationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpectNavigationProto* internal_default_instance() {
    return reinterpret_cast<const ExpectNavigationProto*>(
               &_ExpectNavigationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(ExpectNavigationProto& a, ExpectNavigationProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExpectNavigationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpectNavigationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpectNavigationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpectNavigationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExpectNavigationProto& from);
  void MergeFrom(const ExpectNavigationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExpectNavigationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ExpectNavigationProto";
  }
  protected:
  explicit ExpectNavigationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.ExpectNavigationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForNavigationProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForNavigationProto) */ {
 public:
  inline WaitForNavigationProto() : WaitForNavigationProto(nullptr) {}
  ~WaitForNavigationProto() override;
  explicit PROTOBUF_CONSTEXPR WaitForNavigationProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForNavigationProto(const WaitForNavigationProto& from);
  WaitForNavigationProto(WaitForNavigationProto&& from) noexcept
    : WaitForNavigationProto() {
    *this = ::std::move(from);
  }

  inline WaitForNavigationProto& operator=(const WaitForNavigationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForNavigationProto& operator=(WaitForNavigationProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForNavigationProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForNavigationProto* internal_default_instance() {
    return reinterpret_cast<const WaitForNavigationProto*>(
               &_WaitForNavigationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(WaitForNavigationProto& a, WaitForNavigationProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForNavigationProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForNavigationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForNavigationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForNavigationProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForNavigationProto& from);
  void MergeFrom(const WaitForNavigationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForNavigationProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForNavigationProto";
  }
  protected:
  explicit WaitForNavigationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutMsFieldNumber = 1,
  };
  // optional int32 timeout_ms = 1;
  bool has_timeout_ms() const;
  private:
  bool _internal_has_timeout_ms() const;
  public:
  void clear_timeout_ms();
  int32_t timeout_ms() const;
  void set_timeout_ms(int32_t value);
  private:
  int32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForNavigationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t timeout_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForDocumentProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForDocumentProto.Result) */ {
 public:
  inline WaitForDocumentProto_Result() : WaitForDocumentProto_Result(nullptr) {}
  ~WaitForDocumentProto_Result() override;
  explicit PROTOBUF_CONSTEXPR WaitForDocumentProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForDocumentProto_Result(const WaitForDocumentProto_Result& from);
  WaitForDocumentProto_Result(WaitForDocumentProto_Result&& from) noexcept
    : WaitForDocumentProto_Result() {
    *this = ::std::move(from);
  }

  inline WaitForDocumentProto_Result& operator=(const WaitForDocumentProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForDocumentProto_Result& operator=(WaitForDocumentProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForDocumentProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForDocumentProto_Result* internal_default_instance() {
    return reinterpret_cast<const WaitForDocumentProto_Result*>(
               &_WaitForDocumentProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(WaitForDocumentProto_Result& a, WaitForDocumentProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForDocumentProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForDocumentProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForDocumentProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForDocumentProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForDocumentProto_Result& from);
  void MergeFrom(const WaitForDocumentProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForDocumentProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForDocumentProto.Result";
  }
  protected:
  explicit WaitForDocumentProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartReadyStateFieldNumber = 1,
    kEndReadyStateFieldNumber = 2,
  };
  // optional .autofill_assistant.DocumentReadyState start_ready_state = 1;
  bool has_start_ready_state() const;
  private:
  bool _internal_has_start_ready_state() const;
  public:
  void clear_start_ready_state();
  ::autofill_assistant::DocumentReadyState start_ready_state() const;
  void set_start_ready_state(::autofill_assistant::DocumentReadyState value);
  private:
  ::autofill_assistant::DocumentReadyState _internal_start_ready_state() const;
  void _internal_set_start_ready_state(::autofill_assistant::DocumentReadyState value);
  public:

  // optional .autofill_assistant.DocumentReadyState end_ready_state = 2;
  bool has_end_ready_state() const;
  private:
  bool _internal_has_end_ready_state() const;
  public:
  void clear_end_ready_state();
  ::autofill_assistant::DocumentReadyState end_ready_state() const;
  void set_end_ready_state(::autofill_assistant::DocumentReadyState value);
  private:
  ::autofill_assistant::DocumentReadyState _internal_end_ready_state() const;
  void _internal_set_end_ready_state(::autofill_assistant::DocumentReadyState value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForDocumentProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int start_ready_state_;
  int end_ready_state_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class WaitForDocumentProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForDocumentProto) */ {
 public:
  inline WaitForDocumentProto() : WaitForDocumentProto(nullptr) {}
  ~WaitForDocumentProto() override;
  explicit PROTOBUF_CONSTEXPR WaitForDocumentProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForDocumentProto(const WaitForDocumentProto& from);
  WaitForDocumentProto(WaitForDocumentProto&& from) noexcept
    : WaitForDocumentProto() {
    *this = ::std::move(from);
  }

  inline WaitForDocumentProto& operator=(const WaitForDocumentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForDocumentProto& operator=(WaitForDocumentProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForDocumentProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForDocumentProto* internal_default_instance() {
    return reinterpret_cast<const WaitForDocumentProto*>(
               &_WaitForDocumentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(WaitForDocumentProto& a, WaitForDocumentProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForDocumentProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForDocumentProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForDocumentProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForDocumentProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForDocumentProto& from);
  void MergeFrom(const WaitForDocumentProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForDocumentProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForDocumentProto";
  }
  protected:
  explicit WaitForDocumentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WaitForDocumentProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 2,
    kTimeoutMsFieldNumber = 1,
    kMinReadyStateFieldNumber = 3,
  };
  // optional .autofill_assistant.SelectorProto frame = 2;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::autofill_assistant::SelectorProto& frame() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_frame();
  ::autofill_assistant::SelectorProto* mutable_frame();
  void set_allocated_frame(::autofill_assistant::SelectorProto* frame);
  private:
  const ::autofill_assistant::SelectorProto& _internal_frame() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::autofill_assistant::SelectorProto* frame);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_frame();

  // optional int32 timeout_ms = 1 [default = 5000];
  bool has_timeout_ms() const;
  private:
  bool _internal_has_timeout_ms() const;
  public:
  void clear_timeout_ms();
  int32_t timeout_ms() const;
  void set_timeout_ms(int32_t value);
  private:
  int32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(int32_t value);
  public:

  // optional .autofill_assistant.DocumentReadyState min_ready_state = 3 [default = DOCUMENT_INTERACTIVE];
  bool has_min_ready_state() const;
  private:
  bool _internal_has_min_ready_state() const;
  public:
  void clear_min_ready_state();
  ::autofill_assistant::DocumentReadyState min_ready_state() const;
  void set_min_ready_state(::autofill_assistant::DocumentReadyState value);
  private:
  ::autofill_assistant::DocumentReadyState _internal_min_ready_state() const;
  void _internal_set_min_ready_state(::autofill_assistant::DocumentReadyState value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForDocumentProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::SelectorProto* frame_;
  int32_t timeout_ms_;
  int min_ready_state_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiProto_RequestUserData_AdditionalValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue) */ {
 public:
  inline ShowGenericUiProto_RequestUserData_AdditionalValue() : ShowGenericUiProto_RequestUserData_AdditionalValue(nullptr) {}
  ~ShowGenericUiProto_RequestUserData_AdditionalValue() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiProto_RequestUserData_AdditionalValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiProto_RequestUserData_AdditionalValue(const ShowGenericUiProto_RequestUserData_AdditionalValue& from);
  ShowGenericUiProto_RequestUserData_AdditionalValue(ShowGenericUiProto_RequestUserData_AdditionalValue&& from) noexcept
    : ShowGenericUiProto_RequestUserData_AdditionalValue() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiProto_RequestUserData_AdditionalValue& operator=(const ShowGenericUiProto_RequestUserData_AdditionalValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiProto_RequestUserData_AdditionalValue& operator=(ShowGenericUiProto_RequestUserData_AdditionalValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiProto_RequestUserData_AdditionalValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiProto_RequestUserData_AdditionalValue* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiProto_RequestUserData_AdditionalValue*>(
               &_ShowGenericUiProto_RequestUserData_AdditionalValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(ShowGenericUiProto_RequestUserData_AdditionalValue& a, ShowGenericUiProto_RequestUserData_AdditionalValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiProto_RequestUserData_AdditionalValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiProto_RequestUserData_AdditionalValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiProto_RequestUserData_AdditionalValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiProto_RequestUserData_AdditionalValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiProto_RequestUserData_AdditionalValue& from);
  void MergeFrom(const ShowGenericUiProto_RequestUserData_AdditionalValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiProto_RequestUserData_AdditionalValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue";
  }
  protected:
  explicit ShowGenericUiProto_RequestUserData_AdditionalValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdentifierFieldNumber = 1,
    kModelIdentifierFieldNumber = 2,
  };
  // optional string source_identifier = 1;
  bool has_source_identifier() const;
  private:
  bool _internal_has_source_identifier() const;
  public:
  void clear_source_identifier();
  const std::string& source_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_identifier();
  PROTOBUF_NODISCARD std::string* release_source_identifier();
  void set_allocated_source_identifier(std::string* source_identifier);
  private:
  const std::string& _internal_source_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_identifier(const std::string& value);
  std::string* _internal_mutable_source_identifier();
  public:

  // optional string model_identifier = 2;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiProto_RequestUserData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiProto.RequestUserData) */ {
 public:
  inline ShowGenericUiProto_RequestUserData() : ShowGenericUiProto_RequestUserData(nullptr) {}
  ~ShowGenericUiProto_RequestUserData() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiProto_RequestUserData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiProto_RequestUserData(const ShowGenericUiProto_RequestUserData& from);
  ShowGenericUiProto_RequestUserData(ShowGenericUiProto_RequestUserData&& from) noexcept
    : ShowGenericUiProto_RequestUserData() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiProto_RequestUserData& operator=(const ShowGenericUiProto_RequestUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiProto_RequestUserData& operator=(ShowGenericUiProto_RequestUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiProto_RequestUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiProto_RequestUserData* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiProto_RequestUserData*>(
               &_ShowGenericUiProto_RequestUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(ShowGenericUiProto_RequestUserData& a, ShowGenericUiProto_RequestUserData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiProto_RequestUserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiProto_RequestUserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiProto_RequestUserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiProto_RequestUserData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiProto_RequestUserData& from);
  void MergeFrom(const ShowGenericUiProto_RequestUserData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiProto_RequestUserData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiProto.RequestUserData";
  }
  protected:
  explicit ShowGenericUiProto_RequestUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShowGenericUiProto_RequestUserData_AdditionalValue AdditionalValue;

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalValuesFieldNumber = 1,
  };
  // repeated .autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue additional_values = 1;
  int additional_values_size() const;
  private:
  int _internal_additional_values_size() const;
  public:
  void clear_additional_values();
  ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* mutable_additional_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue >*
      mutable_additional_values();
  private:
  const ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue& _internal_additional_values(int index) const;
  ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* _internal_add_additional_values();
  public:
  const ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue& additional_values(int index) const;
  ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* add_additional_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue >&
      additional_values() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiProto.RequestUserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue > additional_values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiProto.Result) */ {
 public:
  inline ShowGenericUiProto_Result() : ShowGenericUiProto_Result(nullptr) {}
  ~ShowGenericUiProto_Result() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiProto_Result(const ShowGenericUiProto_Result& from);
  ShowGenericUiProto_Result(ShowGenericUiProto_Result&& from) noexcept
    : ShowGenericUiProto_Result() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiProto_Result& operator=(const ShowGenericUiProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiProto_Result& operator=(ShowGenericUiProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiProto_Result* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiProto_Result*>(
               &_ShowGenericUiProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(ShowGenericUiProto_Result& a, ShowGenericUiProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiProto_Result& from);
  void MergeFrom(const ShowGenericUiProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiProto.Result";
  }
  protected:
  explicit ShowGenericUiProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kNavigationEndedFieldNumber = 2,
  };
  // optional .autofill_assistant.ModelProto model = 1;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::autofill_assistant::ModelProto& model() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ModelProto* release_model();
  ::autofill_assistant::ModelProto* mutable_model();
  void set_allocated_model(::autofill_assistant::ModelProto* model);
  private:
  const ::autofill_assistant::ModelProto& _internal_model() const;
  ::autofill_assistant::ModelProto* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::autofill_assistant::ModelProto* model);
  ::autofill_assistant::ModelProto* unsafe_arena_release_model();

  // optional bool navigation_ended = 2;
  bool has_navigation_ended() const;
  private:
  bool _internal_has_navigation_ended() const;
  public:
  void clear_navigation_ended();
  bool navigation_ended() const;
  void set_navigation_ended(bool value);
  private:
  bool _internal_navigation_ended() const;
  void _internal_set_navigation_ended(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ModelProto* model_;
  bool navigation_ended_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiProto_PeriodicElementChecks_ElementCheck final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck) */ {
 public:
  inline ShowGenericUiProto_PeriodicElementChecks_ElementCheck() : ShowGenericUiProto_PeriodicElementChecks_ElementCheck(nullptr) {}
  ~ShowGenericUiProto_PeriodicElementChecks_ElementCheck() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiProto_PeriodicElementChecks_ElementCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiProto_PeriodicElementChecks_ElementCheck(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from);
  ShowGenericUiProto_PeriodicElementChecks_ElementCheck(ShowGenericUiProto_PeriodicElementChecks_ElementCheck&& from) noexcept
    : ShowGenericUiProto_PeriodicElementChecks_ElementCheck() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiProto_PeriodicElementChecks_ElementCheck& operator=(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiProto_PeriodicElementChecks_ElementCheck& operator=(ShowGenericUiProto_PeriodicElementChecks_ElementCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiProto_PeriodicElementChecks_ElementCheck* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiProto_PeriodicElementChecks_ElementCheck*>(
               &_ShowGenericUiProto_PeriodicElementChecks_ElementCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(ShowGenericUiProto_PeriodicElementChecks_ElementCheck& a, ShowGenericUiProto_PeriodicElementChecks_ElementCheck& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiProto_PeriodicElementChecks_ElementCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiProto_PeriodicElementChecks_ElementCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiProto_PeriodicElementChecks_ElementCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiProto_PeriodicElementChecks_ElementCheck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from);
  void MergeFrom(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiProto_PeriodicElementChecks_ElementCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck";
  }
  protected:
  explicit ShowGenericUiProto_PeriodicElementChecks_ElementCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdentifierFieldNumber = 2,
    kElementConditionFieldNumber = 1,
  };
  // optional string model_identifier = 2;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // optional .autofill_assistant.ElementConditionProto element_condition = 1;
  bool has_element_condition() const;
  private:
  bool _internal_has_element_condition() const;
  public:
  void clear_element_condition();
  const ::autofill_assistant::ElementConditionProto& element_condition() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionProto* release_element_condition();
  ::autofill_assistant::ElementConditionProto* mutable_element_condition();
  void set_allocated_element_condition(::autofill_assistant::ElementConditionProto* element_condition);
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_element_condition() const;
  ::autofill_assistant::ElementConditionProto* _internal_mutable_element_condition();
  public:
  void unsafe_arena_set_allocated_element_condition(
      ::autofill_assistant::ElementConditionProto* element_condition);
  ::autofill_assistant::ElementConditionProto* unsafe_arena_release_element_condition();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  ::autofill_assistant::ElementConditionProto* element_condition_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiProto_PeriodicElementChecks final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks) */ {
 public:
  inline ShowGenericUiProto_PeriodicElementChecks() : ShowGenericUiProto_PeriodicElementChecks(nullptr) {}
  ~ShowGenericUiProto_PeriodicElementChecks() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiProto_PeriodicElementChecks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiProto_PeriodicElementChecks(const ShowGenericUiProto_PeriodicElementChecks& from);
  ShowGenericUiProto_PeriodicElementChecks(ShowGenericUiProto_PeriodicElementChecks&& from) noexcept
    : ShowGenericUiProto_PeriodicElementChecks() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiProto_PeriodicElementChecks& operator=(const ShowGenericUiProto_PeriodicElementChecks& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiProto_PeriodicElementChecks& operator=(ShowGenericUiProto_PeriodicElementChecks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiProto_PeriodicElementChecks& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiProto_PeriodicElementChecks* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiProto_PeriodicElementChecks*>(
               &_ShowGenericUiProto_PeriodicElementChecks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(ShowGenericUiProto_PeriodicElementChecks& a, ShowGenericUiProto_PeriodicElementChecks& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiProto_PeriodicElementChecks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiProto_PeriodicElementChecks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiProto_PeriodicElementChecks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiProto_PeriodicElementChecks>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiProto_PeriodicElementChecks& from);
  void MergeFrom(const ShowGenericUiProto_PeriodicElementChecks& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiProto_PeriodicElementChecks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiProto.PeriodicElementChecks";
  }
  protected:
  explicit ShowGenericUiProto_PeriodicElementChecks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShowGenericUiProto_PeriodicElementChecks_ElementCheck ElementCheck;

  // accessors -------------------------------------------------------

  enum : int {
    kElementChecksFieldNumber = 1,
  };
  // repeated .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck element_checks = 1;
  int element_checks_size() const;
  private:
  int _internal_element_checks_size() const;
  public:
  void clear_element_checks();
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* mutable_element_checks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck >*
      mutable_element_checks();
  private:
  const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck& _internal_element_checks(int index) const;
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* _internal_add_element_checks();
  public:
  const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck& element_checks(int index) const;
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* add_element_checks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck >&
      element_checks() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck > element_checks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowGenericUiProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowGenericUiProto) */ {
 public:
  inline ShowGenericUiProto() : ShowGenericUiProto(nullptr) {}
  ~ShowGenericUiProto() override;
  explicit PROTOBUF_CONSTEXPR ShowGenericUiProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowGenericUiProto(const ShowGenericUiProto& from);
  ShowGenericUiProto(ShowGenericUiProto&& from) noexcept
    : ShowGenericUiProto() {
    *this = ::std::move(from);
  }

  inline ShowGenericUiProto& operator=(const ShowGenericUiProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowGenericUiProto& operator=(ShowGenericUiProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowGenericUiProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowGenericUiProto* internal_default_instance() {
    return reinterpret_cast<const ShowGenericUiProto*>(
               &_ShowGenericUiProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ShowGenericUiProto& a, ShowGenericUiProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowGenericUiProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowGenericUiProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowGenericUiProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowGenericUiProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowGenericUiProto& from);
  void MergeFrom(const ShowGenericUiProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowGenericUiProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowGenericUiProto";
  }
  protected:
  explicit ShowGenericUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShowGenericUiProto_RequestUserData RequestUserData;
  typedef ShowGenericUiProto_Result Result;
  typedef ShowGenericUiProto_PeriodicElementChecks PeriodicElementChecks;

  // accessors -------------------------------------------------------

  enum : int {
    kOutputModelIdentifiersFieldNumber = 2,
    kGenericUserInterfaceFieldNumber = 1,
    kPeriodicElementChecksFieldNumber = 6,
    kRequestUserDataFieldNumber = 9,
    kEndOnNavigationFieldNumber = 7,
    kAllowInterruptFieldNumber = 8,
  };
  // repeated string output_model_identifiers = 2;
  int output_model_identifiers_size() const;
  private:
  int _internal_output_model_identifiers_size() const;
  public:
  void clear_output_model_identifiers();
  const std::string& output_model_identifiers(int index) const;
  std::string* mutable_output_model_identifiers(int index);
  void set_output_model_identifiers(int index, const std::string& value);
  void set_output_model_identifiers(int index, std::string&& value);
  void set_output_model_identifiers(int index, const char* value);
  void set_output_model_identifiers(int index, const char* value, size_t size);
  std::string* add_output_model_identifiers();
  void add_output_model_identifiers(const std::string& value);
  void add_output_model_identifiers(std::string&& value);
  void add_output_model_identifiers(const char* value);
  void add_output_model_identifiers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output_model_identifiers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output_model_identifiers();
  private:
  const std::string& _internal_output_model_identifiers(int index) const;
  std::string* _internal_add_output_model_identifiers();
  public:

  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
  bool has_generic_user_interface() const;
  private:
  bool _internal_has_generic_user_interface() const;
  public:
  void clear_generic_user_interface();
  const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GenericUserInterfaceProto* release_generic_user_interface();
  ::autofill_assistant::GenericUserInterfaceProto* mutable_generic_user_interface();
  void set_allocated_generic_user_interface(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface);
  private:
  const ::autofill_assistant::GenericUserInterfaceProto& _internal_generic_user_interface() const;
  ::autofill_assistant::GenericUserInterfaceProto* _internal_mutable_generic_user_interface();
  public:
  void unsafe_arena_set_allocated_generic_user_interface(
      ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface);
  ::autofill_assistant::GenericUserInterfaceProto* unsafe_arena_release_generic_user_interface();

  // optional .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks periodic_element_checks = 6;
  bool has_periodic_element_checks() const;
  private:
  bool _internal_has_periodic_element_checks() const;
  public:
  void clear_periodic_element_checks();
  const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks& periodic_element_checks() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* release_periodic_element_checks();
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* mutable_periodic_element_checks();
  void set_allocated_periodic_element_checks(::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* periodic_element_checks);
  private:
  const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks& _internal_periodic_element_checks() const;
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* _internal_mutable_periodic_element_checks();
  public:
  void unsafe_arena_set_allocated_periodic_element_checks(
      ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* periodic_element_checks);
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* unsafe_arena_release_periodic_element_checks();

  // optional .autofill_assistant.ShowGenericUiProto.RequestUserData request_user_data = 9;
  bool has_request_user_data() const;
  private:
  bool _internal_has_request_user_data() const;
  public:
  void clear_request_user_data();
  const ::autofill_assistant::ShowGenericUiProto_RequestUserData& request_user_data() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShowGenericUiProto_RequestUserData* release_request_user_data();
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* mutable_request_user_data();
  void set_allocated_request_user_data(::autofill_assistant::ShowGenericUiProto_RequestUserData* request_user_data);
  private:
  const ::autofill_assistant::ShowGenericUiProto_RequestUserData& _internal_request_user_data() const;
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* _internal_mutable_request_user_data();
  public:
  void unsafe_arena_set_allocated_request_user_data(
      ::autofill_assistant::ShowGenericUiProto_RequestUserData* request_user_data);
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* unsafe_arena_release_request_user_data();

  // optional bool end_on_navigation = 7;
  bool has_end_on_navigation() const;
  private:
  bool _internal_has_end_on_navigation() const;
  public:
  void clear_end_on_navigation();
  bool end_on_navigation() const;
  void set_end_on_navigation(bool value);
  private:
  bool _internal_end_on_navigation() const;
  void _internal_set_end_on_navigation(bool value);
  public:

  // optional bool allow_interrupt = 8;
  bool has_allow_interrupt() const;
  private:
  bool _internal_has_allow_interrupt() const;
  public:
  void clear_allow_interrupt();
  bool allow_interrupt() const;
  void set_allow_interrupt(bool value);
  private:
  bool _internal_allow_interrupt() const;
  void _internal_set_allow_interrupt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowGenericUiProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_model_identifiers_;
  ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_;
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* periodic_element_checks_;
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* request_user_data_;
  bool end_on_navigation_;
  bool allow_interrupt_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SetPersistentUiProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetPersistentUiProto) */ {
 public:
  inline SetPersistentUiProto() : SetPersistentUiProto(nullptr) {}
  ~SetPersistentUiProto() override;
  explicit PROTOBUF_CONSTEXPR SetPersistentUiProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPersistentUiProto(const SetPersistentUiProto& from);
  SetPersistentUiProto(SetPersistentUiProto&& from) noexcept
    : SetPersistentUiProto() {
    *this = ::std::move(from);
  }

  inline SetPersistentUiProto& operator=(const SetPersistentUiProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPersistentUiProto& operator=(SetPersistentUiProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetPersistentUiProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPersistentUiProto* internal_default_instance() {
    return reinterpret_cast<const SetPersistentUiProto*>(
               &_SetPersistentUiProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(SetPersistentUiProto& a, SetPersistentUiProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetPersistentUiProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPersistentUiProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPersistentUiProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPersistentUiProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetPersistentUiProto& from);
  void MergeFrom(const SetPersistentUiProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetPersistentUiProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetPersistentUiProto";
  }
  protected:
  explicit SetPersistentUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGenericUserInterfaceFieldNumber = 1,
  };
  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
  bool has_generic_user_interface() const;
  private:
  bool _internal_has_generic_user_interface() const;
  public:
  void clear_generic_user_interface();
  const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GenericUserInterfaceProto* release_generic_user_interface();
  ::autofill_assistant::GenericUserInterfaceProto* mutable_generic_user_interface();
  void set_allocated_generic_user_interface(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface);
  private:
  const ::autofill_assistant::GenericUserInterfaceProto& _internal_generic_user_interface() const;
  ::autofill_assistant::GenericUserInterfaceProto* _internal_mutable_generic_user_interface();
  public:
  void unsafe_arena_set_allocated_generic_user_interface(
      ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface);
  ::autofill_assistant::GenericUserInterfaceProto* unsafe_arena_release_generic_user_interface();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetPersistentUiProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ClearPersistentUiProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClearPersistentUiProto) */ {
 public:
  inline ClearPersistentUiProto() : ClearPersistentUiProto(nullptr) {}
  ~ClearPersistentUiProto() override;
  explicit PROTOBUF_CONSTEXPR ClearPersistentUiProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearPersistentUiProto(const ClearPersistentUiProto& from);
  ClearPersistentUiProto(ClearPersistentUiProto&& from) noexcept
    : ClearPersistentUiProto() {
    *this = ::std::move(from);
  }

  inline ClearPersistentUiProto& operator=(const ClearPersistentUiProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearPersistentUiProto& operator=(ClearPersistentUiProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClearPersistentUiProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearPersistentUiProto* internal_default_instance() {
    return reinterpret_cast<const ClearPersistentUiProto*>(
               &_ClearPersistentUiProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(ClearPersistentUiProto& a, ClearPersistentUiProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClearPersistentUiProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearPersistentUiProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearPersistentUiProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearPersistentUiProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClearPersistentUiProto& from);
  void MergeFrom(const ClearPersistentUiProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearPersistentUiProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClearPersistentUiProto";
  }
  protected:
  explicit ClearPersistentUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClearPersistentUiProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PromptProto_Choice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PromptProto.Choice) */ {
 public:
  inline PromptProto_Choice() : PromptProto_Choice(nullptr) {}
  ~PromptProto_Choice() override;
  explicit PROTOBUF_CONSTEXPR PromptProto_Choice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptProto_Choice(const PromptProto_Choice& from);
  PromptProto_Choice(PromptProto_Choice&& from) noexcept
    : PromptProto_Choice() {
    *this = ::std::move(from);
  }

  inline PromptProto_Choice& operator=(const PromptProto_Choice& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptProto_Choice& operator=(PromptProto_Choice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PromptProto_Choice& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptProto_Choice* internal_default_instance() {
    return reinterpret_cast<const PromptProto_Choice*>(
               &_PromptProto_Choice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(PromptProto_Choice& a, PromptProto_Choice& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PromptProto_Choice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptProto_Choice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptProto_Choice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptProto_Choice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PromptProto_Choice& from);
  void MergeFrom(const PromptProto_Choice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PromptProto_Choice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PromptProto.Choice";
  }
  protected:
  explicit PromptProto_Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerPayloadFieldNumber = 5,
    kTagFieldNumber = 18,
    kChipFieldNumber = 11,
    kAutoSelectWhenFieldNumber = 15,
    kShowOnlyWhenFieldNumber = 16,
    kAllowDisablingFieldNumber = 9,
  };
  // optional bytes server_payload = 5;
  bool has_server_payload() const;
  private:
  bool _internal_has_server_payload() const;
  public:
  void clear_server_payload();
  const std::string& server_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_payload();
  PROTOBUF_NODISCARD std::string* release_server_payload();
  void set_allocated_server_payload(std::string* server_payload);
  private:
  const std::string& _internal_server_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_payload(const std::string& value);
  std::string* _internal_mutable_server_payload();
  public:

  // optional string tag = 18;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .autofill_assistant.ChipProto chip = 11;
  bool has_chip() const;
  private:
  bool _internal_has_chip() const;
  public:
  void clear_chip();
  const ::autofill_assistant::ChipProto& chip() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ChipProto* release_chip();
  ::autofill_assistant::ChipProto* mutable_chip();
  void set_allocated_chip(::autofill_assistant::ChipProto* chip);
  private:
  const ::autofill_assistant::ChipProto& _internal_chip() const;
  ::autofill_assistant::ChipProto* _internal_mutable_chip();
  public:
  void unsafe_arena_set_allocated_chip(
      ::autofill_assistant::ChipProto* chip);
  ::autofill_assistant::ChipProto* unsafe_arena_release_chip();

  // optional .autofill_assistant.ElementConditionProto auto_select_when = 15;
  bool has_auto_select_when() const;
  private:
  bool _internal_has_auto_select_when() const;
  public:
  void clear_auto_select_when();
  const ::autofill_assistant::ElementConditionProto& auto_select_when() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionProto* release_auto_select_when();
  ::autofill_assistant::ElementConditionProto* mutable_auto_select_when();
  void set_allocated_auto_select_when(::autofill_assistant::ElementConditionProto* auto_select_when);
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_auto_select_when() const;
  ::autofill_assistant::ElementConditionProto* _internal_mutable_auto_select_when();
  public:
  void unsafe_arena_set_allocated_auto_select_when(
      ::autofill_assistant::ElementConditionProto* auto_select_when);
  ::autofill_assistant::ElementConditionProto* unsafe_arena_release_auto_select_when();

  // optional .autofill_assistant.ElementConditionProto show_only_when = 16;
  bool has_show_only_when() const;
  private:
  bool _internal_has_show_only_when() const;
  public:
  void clear_show_only_when();
  const ::autofill_assistant::ElementConditionProto& show_only_when() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionProto* release_show_only_when();
  ::autofill_assistant::ElementConditionProto* mutable_show_only_when();
  void set_allocated_show_only_when(::autofill_assistant::ElementConditionProto* show_only_when);
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_show_only_when() const;
  ::autofill_assistant::ElementConditionProto* _internal_mutable_show_only_when();
  public:
  void unsafe_arena_set_allocated_show_only_when(
      ::autofill_assistant::ElementConditionProto* show_only_when);
  ::autofill_assistant::ElementConditionProto* unsafe_arena_release_show_only_when();

  // optional bool allow_disabling = 9;
  bool has_allow_disabling() const;
  private:
  bool _internal_has_allow_disabling() const;
  public:
  void clear_allow_disabling();
  bool allow_disabling() const;
  void set_allow_disabling(bool value);
  private:
  bool _internal_allow_disabling() const;
  void _internal_set_allow_disabling(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PromptProto.Choice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::autofill_assistant::ChipProto* chip_;
  ::autofill_assistant::ElementConditionProto* auto_select_when_;
  ::autofill_assistant::ElementConditionProto* show_only_when_;
  bool allow_disabling_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PromptProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PromptProto.Result) */ {
 public:
  inline PromptProto_Result() : PromptProto_Result(nullptr) {}
  ~PromptProto_Result() override;
  explicit PROTOBUF_CONSTEXPR PromptProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptProto_Result(const PromptProto_Result& from);
  PromptProto_Result(PromptProto_Result&& from) noexcept
    : PromptProto_Result() {
    *this = ::std::move(from);
  }

  inline PromptProto_Result& operator=(const PromptProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptProto_Result& operator=(PromptProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PromptProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptProto_Result* internal_default_instance() {
    return reinterpret_cast<const PromptProto_Result*>(
               &_PromptProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(PromptProto_Result& a, PromptProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PromptProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PromptProto_Result& from);
  void MergeFrom(const PromptProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PromptProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PromptProto.Result";
  }
  protected:
  explicit PromptProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerPayloadFieldNumber = 5,
    kChoiceTagFieldNumber = 6,
    kNavigationEndedFieldNumber = 2,
  };
  // optional bytes server_payload = 5;
  bool has_server_payload() const;
  private:
  bool _internal_has_server_payload() const;
  public:
  void clear_server_payload();
  const std::string& server_payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_payload();
  PROTOBUF_NODISCARD std::string* release_server_payload();
  void set_allocated_server_payload(std::string* server_payload);
  private:
  const std::string& _internal_server_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_payload(const std::string& value);
  std::string* _internal_mutable_server_payload();
  public:

  // optional string choice_tag = 6;
  bool has_choice_tag() const;
  private:
  bool _internal_has_choice_tag() const;
  public:
  void clear_choice_tag();
  const std::string& choice_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_choice_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_choice_tag();
  PROTOBUF_NODISCARD std::string* release_choice_tag();
  void set_allocated_choice_tag(std::string* choice_tag);
  private:
  const std::string& _internal_choice_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_choice_tag(const std::string& value);
  std::string* _internal_mutable_choice_tag();
  public:

  // optional bool navigation_ended = 2;
  bool has_navigation_ended() const;
  private:
  bool _internal_has_navigation_ended() const;
  public:
  void clear_navigation_ended();
  bool navigation_ended() const;
  void set_navigation_ended(bool value);
  private:
  bool _internal_navigation_ended() const;
  void _internal_set_navigation_ended(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PromptProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr choice_tag_;
  bool navigation_ended_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PromptProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PromptProto) */ {
 public:
  inline PromptProto() : PromptProto(nullptr) {}
  ~PromptProto() override;
  explicit PROTOBUF_CONSTEXPR PromptProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromptProto(const PromptProto& from);
  PromptProto(PromptProto&& from) noexcept
    : PromptProto() {
    *this = ::std::move(from);
  }

  inline PromptProto& operator=(const PromptProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromptProto& operator=(PromptProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PromptProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromptProto* internal_default_instance() {
    return reinterpret_cast<const PromptProto*>(
               &_PromptProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(PromptProto& a, PromptProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PromptProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromptProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromptProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromptProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PromptProto& from);
  void MergeFrom(const PromptProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PromptProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PromptProto";
  }
  protected:
  explicit PromptProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PromptProto_Choice Choice;
  typedef PromptProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kChoicesFieldNumber = 4,
    kBrowseDomainsAllowlistFieldNumber = 9,
    kMessageFieldNumber = 1,
    kAllowInterruptFieldNumber = 5,
    kDisableForceExpandSheetFieldNumber = 6,
    kBrowseModeFieldNumber = 7,
    kBrowseModeInvisibleFieldNumber = 10,
    kEndOnNavigationFieldNumber = 8,
  };
  // repeated .autofill_assistant.PromptProto.Choice choices = 4;
  int choices_size() const;
  private:
  int _internal_choices_size() const;
  public:
  void clear_choices();
  ::autofill_assistant::PromptProto_Choice* mutable_choices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PromptProto_Choice >*
      mutable_choices();
  private:
  const ::autofill_assistant::PromptProto_Choice& _internal_choices(int index) const;
  ::autofill_assistant::PromptProto_Choice* _internal_add_choices();
  public:
  const ::autofill_assistant::PromptProto_Choice& choices(int index) const;
  ::autofill_assistant::PromptProto_Choice* add_choices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PromptProto_Choice >&
      choices() const;

  // repeated string browse_domains_allowlist = 9;
  int browse_domains_allowlist_size() const;
  private:
  int _internal_browse_domains_allowlist_size() const;
  public:
  void clear_browse_domains_allowlist();
  const std::string& browse_domains_allowlist(int index) const;
  std::string* mutable_browse_domains_allowlist(int index);
  void set_browse_domains_allowlist(int index, const std::string& value);
  void set_browse_domains_allowlist(int index, std::string&& value);
  void set_browse_domains_allowlist(int index, const char* value);
  void set_browse_domains_allowlist(int index, const char* value, size_t size);
  std::string* add_browse_domains_allowlist();
  void add_browse_domains_allowlist(const std::string& value);
  void add_browse_domains_allowlist(std::string&& value);
  void add_browse_domains_allowlist(const char* value);
  void add_browse_domains_allowlist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& browse_domains_allowlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_browse_domains_allowlist();
  private:
  const std::string& _internal_browse_domains_allowlist(int index) const;
  std::string* _internal_add_browse_domains_allowlist();
  public:

  // optional string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional bool allow_interrupt = 5;
  bool has_allow_interrupt() const;
  private:
  bool _internal_has_allow_interrupt() const;
  public:
  void clear_allow_interrupt();
  bool allow_interrupt() const;
  void set_allow_interrupt(bool value);
  private:
  bool _internal_allow_interrupt() const;
  void _internal_set_allow_interrupt(bool value);
  public:

  // optional bool disable_force_expand_sheet = 6;
  bool has_disable_force_expand_sheet() const;
  private:
  bool _internal_has_disable_force_expand_sheet() const;
  public:
  void clear_disable_force_expand_sheet();
  bool disable_force_expand_sheet() const;
  void set_disable_force_expand_sheet(bool value);
  private:
  bool _internal_disable_force_expand_sheet() const;
  void _internal_set_disable_force_expand_sheet(bool value);
  public:

  // optional bool browse_mode = 7;
  bool has_browse_mode() const;
  private:
  bool _internal_has_browse_mode() const;
  public:
  void clear_browse_mode();
  bool browse_mode() const;
  void set_browse_mode(bool value);
  private:
  bool _internal_browse_mode() const;
  void _internal_set_browse_mode(bool value);
  public:

  // optional bool browse_mode_invisible = 10;
  bool has_browse_mode_invisible() const;
  private:
  bool _internal_has_browse_mode_invisible() const;
  public:
  void clear_browse_mode_invisible();
  bool browse_mode_invisible() const;
  void set_browse_mode_invisible(bool value);
  private:
  bool _internal_browse_mode_invisible() const;
  void _internal_set_browse_mode_invisible(bool value);
  public:

  // optional bool end_on_navigation = 8;
  bool has_end_on_navigation() const;
  private:
  bool _internal_has_end_on_navigation() const;
  public:
  void clear_end_on_navigation();
  bool end_on_navigation() const;
  void set_end_on_navigation(bool value);
  private:
  bool _internal_end_on_navigation() const;
  void _internal_set_end_on_navigation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PromptProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PromptProto_Choice > choices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> browse_domains_allowlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool allow_interrupt_;
  bool disable_force_expand_sheet_;
  bool browse_mode_;
  bool browse_mode_invisible_;
  bool end_on_navigation_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ContactDetailsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ContactDetailsProto) */ {
 public:
  inline ContactDetailsProto() : ContactDetailsProto(nullptr) {}
  ~ContactDetailsProto() override;
  explicit PROTOBUF_CONSTEXPR ContactDetailsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactDetailsProto(const ContactDetailsProto& from);
  ContactDetailsProto(ContactDetailsProto&& from) noexcept
    : ContactDetailsProto() {
    *this = ::std::move(from);
  }

  inline ContactDetailsProto& operator=(const ContactDetailsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactDetailsProto& operator=(ContactDetailsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ContactDetailsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactDetailsProto* internal_default_instance() {
    return reinterpret_cast<const ContactDetailsProto*>(
               &_ContactDetailsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(ContactDetailsProto& a, ContactDetailsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ContactDetailsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactDetailsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContactDetailsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContactDetailsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContactDetailsProto& from);
  void MergeFrom(const ContactDetailsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContactDetailsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ContactDetailsProto";
  }
  protected:
  explicit ContactDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ContactDetailsProto_AutofillContactField AutofillContactField;
  static constexpr AutofillContactField NAME_FULL =
    ContactDetailsProto_AutofillContactField_NAME_FULL;
  static constexpr AutofillContactField EMAIL_ADDRESS =
    ContactDetailsProto_AutofillContactField_EMAIL_ADDRESS;
  static constexpr AutofillContactField PHONE_HOME_WHOLE_NUMBER =
    ContactDetailsProto_AutofillContactField_PHONE_HOME_WHOLE_NUMBER;
  static inline bool AutofillContactField_IsValid(int value) {
    return ContactDetailsProto_AutofillContactField_IsValid(value);
  }
  static constexpr AutofillContactField AutofillContactField_MIN =
    ContactDetailsProto_AutofillContactField_AutofillContactField_MIN;
  static constexpr AutofillContactField AutofillContactField_MAX =
    ContactDetailsProto_AutofillContactField_AutofillContactField_MAX;
  static constexpr int AutofillContactField_ARRAYSIZE =
    ContactDetailsProto_AutofillContactField_AutofillContactField_ARRAYSIZE;
  template<typename T>
  static inline const std::string& AutofillContactField_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AutofillContactField>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AutofillContactField_Name.");
    return ContactDetailsProto_AutofillContactField_Name(enum_t_value);
  }
  static inline bool AutofillContactField_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AutofillContactField* value) {
    return ContactDetailsProto_AutofillContactField_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSummaryFieldsFieldNumber = 5,
    kFullFieldsFieldNumber = 7,
    kRequiredDataPieceFieldNumber = 10,
    kPhoneNumberRequiredDataPieceFieldNumber = 13,
    kContactDetailsNameFieldNumber = 1,
    kContactDetailsSectionTitleFieldNumber = 9,
    kPhoneNumberSectionTitleFieldNumber = 12,
    kRequestPayerNameFieldNumber = 2,
    kRequestPayerEmailFieldNumber = 3,
    kRequestPayerPhoneFieldNumber = 4,
    kSeparatePhoneNumberSectionFieldNumber = 11,
    kMaxNumberSummaryLinesFieldNumber = 6,
    kMaxNumberFullLinesFieldNumber = 8,
  };
  // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField summary_fields = 5;
  int summary_fields_size() const;
  private:
  int _internal_summary_fields_size() const;
  public:
  void clear_summary_fields();
  private:
  ::autofill_assistant::ContactDetailsProto_AutofillContactField _internal_summary_fields(int index) const;
  void _internal_add_summary_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_summary_fields();
  public:
  ::autofill_assistant::ContactDetailsProto_AutofillContactField summary_fields(int index) const;
  void set_summary_fields(int index, ::autofill_assistant::ContactDetailsProto_AutofillContactField value);
  void add_summary_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& summary_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_summary_fields();

  // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField full_fields = 7;
  int full_fields_size() const;
  private:
  int _internal_full_fields_size() const;
  public:
  void clear_full_fields();
  private:
  ::autofill_assistant::ContactDetailsProto_AutofillContactField _internal_full_fields(int index) const;
  void _internal_add_full_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_full_fields();
  public:
  ::autofill_assistant::ContactDetailsProto_AutofillContactField full_fields(int index) const;
  void set_full_fields(int index, ::autofill_assistant::ContactDetailsProto_AutofillContactField value);
  void add_full_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& full_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_full_fields();

  // repeated .autofill_assistant.RequiredDataPiece required_data_piece = 10;
  int required_data_piece_size() const;
  private:
  int _internal_required_data_piece_size() const;
  public:
  void clear_required_data_piece();
  ::autofill_assistant::RequiredDataPiece* mutable_required_data_piece(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
      mutable_required_data_piece();
  private:
  const ::autofill_assistant::RequiredDataPiece& _internal_required_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* _internal_add_required_data_piece();
  public:
  const ::autofill_assistant::RequiredDataPiece& required_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* add_required_data_piece();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
      required_data_piece() const;

  // repeated .autofill_assistant.RequiredDataPiece phone_number_required_data_piece = 13;
  int phone_number_required_data_piece_size() const;
  private:
  int _internal_phone_number_required_data_piece_size() const;
  public:
  void clear_phone_number_required_data_piece();
  ::autofill_assistant::RequiredDataPiece* mutable_phone_number_required_data_piece(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
      mutable_phone_number_required_data_piece();
  private:
  const ::autofill_assistant::RequiredDataPiece& _internal_phone_number_required_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* _internal_add_phone_number_required_data_piece();
  public:
  const ::autofill_assistant::RequiredDataPiece& phone_number_required_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* add_phone_number_required_data_piece();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
      phone_number_required_data_piece() const;

  // optional string contact_details_name = 1;
  bool has_contact_details_name() const;
  private:
  bool _internal_has_contact_details_name() const;
  public:
  void clear_contact_details_name();
  const std::string& contact_details_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_details_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_details_name();
  PROTOBUF_NODISCARD std::string* release_contact_details_name();
  void set_allocated_contact_details_name(std::string* contact_details_name);
  private:
  const std::string& _internal_contact_details_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_details_name(const std::string& value);
  std::string* _internal_mutable_contact_details_name();
  public:

  // optional string contact_details_section_title = 9;
  bool has_contact_details_section_title() const;
  private:
  bool _internal_has_contact_details_section_title() const;
  public:
  void clear_contact_details_section_title();
  const std::string& contact_details_section_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_details_section_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_details_section_title();
  PROTOBUF_NODISCARD std::string* release_contact_details_section_title();
  void set_allocated_contact_details_section_title(std::string* contact_details_section_title);
  private:
  const std::string& _internal_contact_details_section_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_details_section_title(const std::string& value);
  std::string* _internal_mutable_contact_details_section_title();
  public:

  // optional string phone_number_section_title = 12;
  bool has_phone_number_section_title() const;
  private:
  bool _internal_has_phone_number_section_title() const;
  public:
  void clear_phone_number_section_title();
  const std::string& phone_number_section_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone_number_section_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone_number_section_title();
  PROTOBUF_NODISCARD std::string* release_phone_number_section_title();
  void set_allocated_phone_number_section_title(std::string* phone_number_section_title);
  private:
  const std::string& _internal_phone_number_section_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number_section_title(const std::string& value);
  std::string* _internal_mutable_phone_number_section_title();
  public:

  // optional bool request_payer_name = 2;
  bool has_request_payer_name() const;
  private:
  bool _internal_has_request_payer_name() const;
  public:
  void clear_request_payer_name();
  bool request_payer_name() const;
  void set_request_payer_name(bool value);
  private:
  bool _internal_request_payer_name() const;
  void _internal_set_request_payer_name(bool value);
  public:

  // optional bool request_payer_email = 3;
  bool has_request_payer_email() const;
  private:
  bool _internal_has_request_payer_email() const;
  public:
  void clear_request_payer_email();
  bool request_payer_email() const;
  void set_request_payer_email(bool value);
  private:
  bool _internal_request_payer_email() const;
  void _internal_set_request_payer_email(bool value);
  public:

  // optional bool request_payer_phone = 4;
  bool has_request_payer_phone() const;
  private:
  bool _internal_has_request_payer_phone() const;
  public:
  void clear_request_payer_phone();
  bool request_payer_phone() const;
  void set_request_payer_phone(bool value);
  private:
  bool _internal_request_payer_phone() const;
  void _internal_set_request_payer_phone(bool value);
  public:

  // optional bool separate_phone_number_section = 11;
  bool has_separate_phone_number_section() const;
  private:
  bool _internal_has_separate_phone_number_section() const;
  public:
  void clear_separate_phone_number_section();
  bool separate_phone_number_section() const;
  void set_separate_phone_number_section(bool value);
  private:
  bool _internal_separate_phone_number_section() const;
  void _internal_set_separate_phone_number_section(bool value);
  public:

  // optional int32 max_number_summary_lines = 6;
  bool has_max_number_summary_lines() const;
  private:
  bool _internal_has_max_number_summary_lines() const;
  public:
  void clear_max_number_summary_lines();
  int32_t max_number_summary_lines() const;
  void set_max_number_summary_lines(int32_t value);
  private:
  int32_t _internal_max_number_summary_lines() const;
  void _internal_set_max_number_summary_lines(int32_t value);
  public:

  // optional int32 max_number_full_lines = 8;
  bool has_max_number_full_lines() const;
  private:
  bool _internal_has_max_number_full_lines() const;
  public:
  void clear_max_number_full_lines();
  int32_t max_number_full_lines() const;
  void set_max_number_full_lines(int32_t value);
  private:
  int32_t _internal_max_number_full_lines() const;
  void _internal_set_max_number_full_lines(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ContactDetailsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> summary_fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> full_fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece > required_data_piece_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece > phone_number_required_data_piece_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_details_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_details_section_title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_number_section_title_;
  bool request_payer_name_;
  bool request_payer_email_;
  bool request_payer_phone_;
  bool separate_phone_number_section_;
  int32_t max_number_summary_lines_;
  int32_t max_number_full_lines_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginDetailsProto_LoginOptionCustomProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto) */ {
 public:
  inline LoginDetailsProto_LoginOptionCustomProto() : LoginDetailsProto_LoginOptionCustomProto(nullptr) {}
  ~LoginDetailsProto_LoginOptionCustomProto() override;
  explicit PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionCustomProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginDetailsProto_LoginOptionCustomProto(const LoginDetailsProto_LoginOptionCustomProto& from);
  LoginDetailsProto_LoginOptionCustomProto(LoginDetailsProto_LoginOptionCustomProto&& from) noexcept
    : LoginDetailsProto_LoginOptionCustomProto() {
    *this = ::std::move(from);
  }

  inline LoginDetailsProto_LoginOptionCustomProto& operator=(const LoginDetailsProto_LoginOptionCustomProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginDetailsProto_LoginOptionCustomProto& operator=(LoginDetailsProto_LoginOptionCustomProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginDetailsProto_LoginOptionCustomProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginDetailsProto_LoginOptionCustomProto* internal_default_instance() {
    return reinterpret_cast<const LoginDetailsProto_LoginOptionCustomProto*>(
               &_LoginDetailsProto_LoginOptionCustomProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(LoginDetailsProto_LoginOptionCustomProto& a, LoginDetailsProto_LoginOptionCustomProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LoginDetailsProto_LoginOptionCustomProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginDetailsProto_LoginOptionCustomProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginDetailsProto_LoginOptionCustomProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginDetailsProto_LoginOptionCustomProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginDetailsProto_LoginOptionCustomProto& from);
  void MergeFrom(const LoginDetailsProto_LoginOptionCustomProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginDetailsProto_LoginOptionCustomProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LoginDetailsProto.LoginOptionCustomProto";
  }
  protected:
  explicit LoginDetailsProto_LoginOptionCustomProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
  };
  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginDetailsProto_LoginOptionPasswordManagerProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto) */ {
 public:
  inline LoginDetailsProto_LoginOptionPasswordManagerProto() : LoginDetailsProto_LoginOptionPasswordManagerProto(nullptr) {}
  ~LoginDetailsProto_LoginOptionPasswordManagerProto() override;
  explicit PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionPasswordManagerProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginDetailsProto_LoginOptionPasswordManagerProto(const LoginDetailsProto_LoginOptionPasswordManagerProto& from);
  LoginDetailsProto_LoginOptionPasswordManagerProto(LoginDetailsProto_LoginOptionPasswordManagerProto&& from) noexcept
    : LoginDetailsProto_LoginOptionPasswordManagerProto() {
    *this = ::std::move(from);
  }

  inline LoginDetailsProto_LoginOptionPasswordManagerProto& operator=(const LoginDetailsProto_LoginOptionPasswordManagerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginDetailsProto_LoginOptionPasswordManagerProto& operator=(LoginDetailsProto_LoginOptionPasswordManagerProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginDetailsProto_LoginOptionPasswordManagerProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginDetailsProto_LoginOptionPasswordManagerProto* internal_default_instance() {
    return reinterpret_cast<const LoginDetailsProto_LoginOptionPasswordManagerProto*>(
               &_LoginDetailsProto_LoginOptionPasswordManagerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(LoginDetailsProto_LoginOptionPasswordManagerProto& a, LoginDetailsProto_LoginOptionPasswordManagerProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LoginDetailsProto_LoginOptionPasswordManagerProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginDetailsProto_LoginOptionPasswordManagerProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginDetailsProto_LoginOptionPasswordManagerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginDetailsProto_LoginOptionPasswordManagerProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginDetailsProto_LoginOptionPasswordManagerProto& from);
  void MergeFrom(const LoginDetailsProto_LoginOptionPasswordManagerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginDetailsProto_LoginOptionPasswordManagerProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto";
  }
  protected:
  explicit LoginDetailsProto_LoginOptionPasswordManagerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginDetailsProto_LoginOptionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LoginDetailsProto.LoginOptionProto) */ {
 public:
  inline LoginDetailsProto_LoginOptionProto() : LoginDetailsProto_LoginOptionProto(nullptr) {}
  ~LoginDetailsProto_LoginOptionProto() override;
  explicit PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginDetailsProto_LoginOptionProto(const LoginDetailsProto_LoginOptionProto& from);
  LoginDetailsProto_LoginOptionProto(LoginDetailsProto_LoginOptionProto&& from) noexcept
    : LoginDetailsProto_LoginOptionProto() {
    *this = ::std::move(from);
  }

  inline LoginDetailsProto_LoginOptionProto& operator=(const LoginDetailsProto_LoginOptionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginDetailsProto_LoginOptionProto& operator=(LoginDetailsProto_LoginOptionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginDetailsProto_LoginOptionProto& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadOrTagCase {
    kPayload = 1,
    kTag = 21,
    PAYLOAD_OR_TAG_NOT_SET = 0,
  };

  enum TypeCase {
    kCustom = 4,
    kPasswordManager = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const LoginDetailsProto_LoginOptionProto* internal_default_instance() {
    return reinterpret_cast<const LoginDetailsProto_LoginOptionProto*>(
               &_LoginDetailsProto_LoginOptionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(LoginDetailsProto_LoginOptionProto& a, LoginDetailsProto_LoginOptionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LoginDetailsProto_LoginOptionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginDetailsProto_LoginOptionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginDetailsProto_LoginOptionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginDetailsProto_LoginOptionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginDetailsProto_LoginOptionProto& from);
  void MergeFrom(const LoginDetailsProto_LoginOptionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginDetailsProto_LoginOptionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LoginDetailsProto.LoginOptionProto";
  }
  protected:
  explicit LoginDetailsProto_LoginOptionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSublabelFieldNumber = 7,
    kSublabelAccessibilityHintFieldNumber = 8,
    kEditButtonContentDescriptionFieldNumber = 10,
    kInfoPopupFieldNumber = 6,
    kChooseAutomaticallyIfNoStoredLoginFieldNumber = 2,
    kPreselectionPriorityFieldNumber = 3,
    kPayloadFieldNumber = 1,
    kTagFieldNumber = 21,
    kCustomFieldNumber = 4,
    kPasswordManagerFieldNumber = 5,
  };
  // optional string sublabel = 7;
  bool has_sublabel() const;
  private:
  bool _internal_has_sublabel() const;
  public:
  void clear_sublabel();
  const std::string& sublabel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sublabel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sublabel();
  PROTOBUF_NODISCARD std::string* release_sublabel();
  void set_allocated_sublabel(std::string* sublabel);
  private:
  const std::string& _internal_sublabel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sublabel(const std::string& value);
  std::string* _internal_mutable_sublabel();
  public:

  // optional string sublabel_accessibility_hint = 8;
  bool has_sublabel_accessibility_hint() const;
  private:
  bool _internal_has_sublabel_accessibility_hint() const;
  public:
  void clear_sublabel_accessibility_hint();
  const std::string& sublabel_accessibility_hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sublabel_accessibility_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sublabel_accessibility_hint();
  PROTOBUF_NODISCARD std::string* release_sublabel_accessibility_hint();
  void set_allocated_sublabel_accessibility_hint(std::string* sublabel_accessibility_hint);
  private:
  const std::string& _internal_sublabel_accessibility_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sublabel_accessibility_hint(const std::string& value);
  std::string* _internal_mutable_sublabel_accessibility_hint();
  public:

  // optional string edit_button_content_description = 10;
  bool has_edit_button_content_description() const;
  private:
  bool _internal_has_edit_button_content_description() const;
  public:
  void clear_edit_button_content_description();
  const std::string& edit_button_content_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_button_content_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_button_content_description();
  PROTOBUF_NODISCARD std::string* release_edit_button_content_description();
  void set_allocated_edit_button_content_description(std::string* edit_button_content_description);
  private:
  const std::string& _internal_edit_button_content_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_button_content_description(const std::string& value);
  std::string* _internal_mutable_edit_button_content_description();
  public:

  // optional .autofill_assistant.InfoPopupProto info_popup = 6;
  bool has_info_popup() const;
  private:
  bool _internal_has_info_popup() const;
  public:
  void clear_info_popup();
  const ::autofill_assistant::InfoPopupProto& info_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto* release_info_popup();
  ::autofill_assistant::InfoPopupProto* mutable_info_popup();
  void set_allocated_info_popup(::autofill_assistant::InfoPopupProto* info_popup);
  private:
  const ::autofill_assistant::InfoPopupProto& _internal_info_popup() const;
  ::autofill_assistant::InfoPopupProto* _internal_mutable_info_popup();
  public:
  void unsafe_arena_set_allocated_info_popup(
      ::autofill_assistant::InfoPopupProto* info_popup);
  ::autofill_assistant::InfoPopupProto* unsafe_arena_release_info_popup();

  // optional bool choose_automatically_if_no_stored_login = 2;
  bool has_choose_automatically_if_no_stored_login() const;
  private:
  bool _internal_has_choose_automatically_if_no_stored_login() const;
  public:
  void clear_choose_automatically_if_no_stored_login();
  bool choose_automatically_if_no_stored_login() const;
  void set_choose_automatically_if_no_stored_login(bool value);
  private:
  bool _internal_choose_automatically_if_no_stored_login() const;
  void _internal_set_choose_automatically_if_no_stored_login(bool value);
  public:

  // optional int32 preselection_priority = 3;
  bool has_preselection_priority() const;
  private:
  bool _internal_has_preselection_priority() const;
  public:
  void clear_preselection_priority();
  int32_t preselection_priority() const;
  void set_preselection_priority(int32_t value);
  private:
  int32_t _internal_preselection_priority() const;
  void _internal_set_preselection_priority(int32_t value);
  public:

  // bytes payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // string tag = 21;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .autofill_assistant.LoginDetailsProto.LoginOptionCustomProto custom = 4;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto& custom() const;
  PROTOBUF_NODISCARD ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* release_custom();
  ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* mutable_custom();
  void set_allocated_custom(::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* custom);
  private:
  const ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto& _internal_custom() const;
  ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* custom);
  ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* unsafe_arena_release_custom();

  // .autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto password_manager = 5;
  bool has_password_manager() const;
  private:
  bool _internal_has_password_manager() const;
  public:
  void clear_password_manager();
  const ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto& password_manager() const;
  PROTOBUF_NODISCARD ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* release_password_manager();
  ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* mutable_password_manager();
  void set_allocated_password_manager(::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* password_manager);
  private:
  const ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto& _internal_password_manager() const;
  ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* _internal_mutable_password_manager();
  public:
  void unsafe_arena_set_allocated_password_manager(
      ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* password_manager);
  ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* unsafe_arena_release_password_manager();

  void clear_payload_or_tag();
  PayloadOrTagCase payload_or_tag_case() const;
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.LoginDetailsProto.LoginOptionProto)
 private:
  class _Internal;
  void set_has_payload();
  void set_has_tag();
  void set_has_custom();
  void set_has_password_manager();

  inline bool has_payload_or_tag() const;
  inline void clear_has_payload_or_tag();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sublabel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sublabel_accessibility_hint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_button_content_description_;
  ::autofill_assistant::InfoPopupProto* info_popup_;
  bool choose_automatically_if_no_stored_login_;
  int32_t preselection_priority_;
  union PayloadOrTagUnion {
    constexpr PayloadOrTagUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  } payload_or_tag_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* custom_;
    ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* password_manager_;
  } type_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginDetailsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LoginDetailsProto) */ {
 public:
  inline LoginDetailsProto() : LoginDetailsProto(nullptr) {}
  ~LoginDetailsProto() override;
  explicit PROTOBUF_CONSTEXPR LoginDetailsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginDetailsProto(const LoginDetailsProto& from);
  LoginDetailsProto(LoginDetailsProto&& from) noexcept
    : LoginDetailsProto() {
    *this = ::std::move(from);
  }

  inline LoginDetailsProto& operator=(const LoginDetailsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginDetailsProto& operator=(LoginDetailsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LoginDetailsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginDetailsProto* internal_default_instance() {
    return reinterpret_cast<const LoginDetailsProto*>(
               &_LoginDetailsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(LoginDetailsProto& a, LoginDetailsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LoginDetailsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginDetailsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginDetailsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginDetailsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginDetailsProto& from);
  void MergeFrom(const LoginDetailsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginDetailsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LoginDetailsProto";
  }
  protected:
  explicit LoginDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoginDetailsProto_LoginOptionCustomProto LoginOptionCustomProto;
  typedef LoginDetailsProto_LoginOptionPasswordManagerProto LoginOptionPasswordManagerProto;
  typedef LoginDetailsProto_LoginOptionProto LoginOptionProto;

  // accessors -------------------------------------------------------

  enum : int {
    kLoginOptionsFieldNumber = 2,
    kSectionTitleFieldNumber = 1,
  };
  // repeated .autofill_assistant.LoginDetailsProto.LoginOptionProto login_options = 2;
  int login_options_size() const;
  private:
  int _internal_login_options_size() const;
  public:
  void clear_login_options();
  ::autofill_assistant::LoginDetailsProto_LoginOptionProto* mutable_login_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginDetailsProto_LoginOptionProto >*
      mutable_login_options();
  private:
  const ::autofill_assistant::LoginDetailsProto_LoginOptionProto& _internal_login_options(int index) const;
  ::autofill_assistant::LoginDetailsProto_LoginOptionProto* _internal_add_login_options();
  public:
  const ::autofill_assistant::LoginDetailsProto_LoginOptionProto& login_options(int index) const;
  ::autofill_assistant::LoginDetailsProto_LoginOptionProto* add_login_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginDetailsProto_LoginOptionProto >&
      login_options() const;

  // optional string section_title = 1;
  bool has_section_title() const;
  private:
  bool _internal_has_section_title() const;
  public:
  void clear_section_title();
  const std::string& section_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_section_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_section_title();
  PROTOBUF_NODISCARD std::string* release_section_title();
  void set_allocated_section_title(std::string* section_title);
  private:
  const std::string& _internal_section_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_section_title(const std::string& value);
  std::string* _internal_mutable_section_title();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.LoginDetailsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginDetailsProto_LoginOptionProto > login_options_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr section_title_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class StaticTextSectionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.StaticTextSectionProto) */ {
 public:
  inline StaticTextSectionProto() : StaticTextSectionProto(nullptr) {}
  ~StaticTextSectionProto() override;
  explicit PROTOBUF_CONSTEXPR StaticTextSectionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StaticTextSectionProto(const StaticTextSectionProto& from);
  StaticTextSectionProto(StaticTextSectionProto&& from) noexcept
    : StaticTextSectionProto() {
    *this = ::std::move(from);
  }

  inline StaticTextSectionProto& operator=(const StaticTextSectionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticTextSectionProto& operator=(StaticTextSectionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StaticTextSectionProto& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kText = 1,
    kClientMemoryKey = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const StaticTextSectionProto* internal_default_instance() {
    return reinterpret_cast<const StaticTextSectionProto*>(
               &_StaticTextSectionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(StaticTextSectionProto& a, StaticTextSectionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StaticTextSectionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticTextSectionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StaticTextSectionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StaticTextSectionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StaticTextSectionProto& from);
  void MergeFrom(const StaticTextSectionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StaticTextSectionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.StaticTextSectionProto";
  }
  protected:
  explicit StaticTextSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kClientMemoryKeyFieldNumber = 2,
  };
  // string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string client_memory_key = 2;
  bool has_client_memory_key() const;
  private:
  bool _internal_has_client_memory_key() const;
  public:
  void clear_client_memory_key();
  const std::string& client_memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_memory_key();
  PROTOBUF_NODISCARD std::string* release_client_memory_key();
  void set_allocated_client_memory_key(std::string* client_memory_key);
  private:
  const std::string& _internal_client_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_memory_key(const std::string& value);
  std::string* _internal_mutable_client_memory_key();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.StaticTextSectionProto)
 private:
  class _Internal;
  void set_has_text();
  void set_has_client_memory_key();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_memory_key_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TextInputProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TextInputProto) */ {
 public:
  inline TextInputProto() : TextInputProto(nullptr) {}
  ~TextInputProto() override;
  explicit PROTOBUF_CONSTEXPR TextInputProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextInputProto(const TextInputProto& from);
  TextInputProto(TextInputProto&& from) noexcept
    : TextInputProto() {
    *this = ::std::move(from);
  }

  inline TextInputProto& operator=(const TextInputProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextInputProto& operator=(TextInputProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextInputProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextInputProto* internal_default_instance() {
    return reinterpret_cast<const TextInputProto*>(
               &_TextInputProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(TextInputProto& a, TextInputProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TextInputProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextInputProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextInputProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextInputProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextInputProto& from);
  void MergeFrom(const TextInputProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextInputProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TextInputProto";
  }
  protected:
  explicit TextInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TextInputProto_InputType InputType;
  static constexpr InputType UNDEFINED =
    TextInputProto_InputType_UNDEFINED;
  static constexpr InputType INPUT_TEXT =
    TextInputProto_InputType_INPUT_TEXT;
  static constexpr InputType INPUT_ALPHANUMERIC =
    TextInputProto_InputType_INPUT_ALPHANUMERIC;
  static inline bool InputType_IsValid(int value) {
    return TextInputProto_InputType_IsValid(value);
  }
  static constexpr InputType InputType_MIN =
    TextInputProto_InputType_InputType_MIN;
  static constexpr InputType InputType_MAX =
    TextInputProto_InputType_InputType_MAX;
  static constexpr int InputType_ARRAYSIZE =
    TextInputProto_InputType_InputType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InputType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InputType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InputType_Name.");
    return TextInputProto_InputType_Name(enum_t_value);
  }
  static inline bool InputType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InputType* value) {
    return TextInputProto_InputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHintFieldNumber = 1,
    kClientMemoryKeyFieldNumber = 3,
    kValueFieldNumber = 4,
    kInputTypeFieldNumber = 2,
  };
  // optional string hint = 1;
  bool has_hint() const;
  private:
  bool _internal_has_hint() const;
  public:
  void clear_hint();
  const std::string& hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hint();
  PROTOBUF_NODISCARD std::string* release_hint();
  void set_allocated_hint(std::string* hint);
  private:
  const std::string& _internal_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hint(const std::string& value);
  std::string* _internal_mutable_hint();
  public:

  // optional string client_memory_key = 3;
  bool has_client_memory_key() const;
  private:
  bool _internal_has_client_memory_key() const;
  public:
  void clear_client_memory_key();
  const std::string& client_memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_memory_key();
  PROTOBUF_NODISCARD std::string* release_client_memory_key();
  void set_allocated_client_memory_key(std::string* client_memory_key);
  private:
  const std::string& _internal_client_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_memory_key(const std::string& value);
  std::string* _internal_mutable_client_memory_key();
  public:

  // optional string value = 4;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .autofill_assistant.TextInputProto.InputType input_type = 2;
  bool has_input_type() const;
  private:
  bool _internal_has_input_type() const;
  public:
  void clear_input_type();
  ::autofill_assistant::TextInputProto_InputType input_type() const;
  void set_input_type(::autofill_assistant::TextInputProto_InputType value);
  private:
  ::autofill_assistant::TextInputProto_InputType _internal_input_type() const;
  void _internal_set_input_type(::autofill_assistant::TextInputProto_InputType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TextInputProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_memory_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int input_type_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class TextInputSectionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TextInputSectionProto) */ {
 public:
  inline TextInputSectionProto() : TextInputSectionProto(nullptr) {}
  ~TextInputSectionProto() override;
  explicit PROTOBUF_CONSTEXPR TextInputSectionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextInputSectionProto(const TextInputSectionProto& from);
  TextInputSectionProto(TextInputSectionProto&& from) noexcept
    : TextInputSectionProto() {
    *this = ::std::move(from);
  }

  inline TextInputSectionProto& operator=(const TextInputSectionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextInputSectionProto& operator=(TextInputSectionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextInputSectionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextInputSectionProto* internal_default_instance() {
    return reinterpret_cast<const TextInputSectionProto*>(
               &_TextInputSectionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(TextInputSectionProto& a, TextInputSectionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TextInputSectionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextInputSectionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextInputSectionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextInputSectionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextInputSectionProto& from);
  void MergeFrom(const TextInputSectionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextInputSectionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TextInputSectionProto";
  }
  protected:
  explicit TextInputSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldsFieldNumber = 1,
  };
  // repeated .autofill_assistant.TextInputProto input_fields = 1;
  int input_fields_size() const;
  private:
  int _internal_input_fields_size() const;
  public:
  void clear_input_fields();
  ::autofill_assistant::TextInputProto* mutable_input_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TextInputProto >*
      mutable_input_fields();
  private:
  const ::autofill_assistant::TextInputProto& _internal_input_fields(int index) const;
  ::autofill_assistant::TextInputProto* _internal_add_input_fields();
  public:
  const ::autofill_assistant::TextInputProto& input_fields(int index) const;
  ::autofill_assistant::TextInputProto* add_input_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TextInputProto >&
      input_fields() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.TextInputSectionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TextInputProto > input_fields_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UserFormSectionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.UserFormSectionProto) */ {
 public:
  inline UserFormSectionProto() : UserFormSectionProto(nullptr) {}
  ~UserFormSectionProto() override;
  explicit PROTOBUF_CONSTEXPR UserFormSectionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserFormSectionProto(const UserFormSectionProto& from);
  UserFormSectionProto(UserFormSectionProto&& from) noexcept
    : UserFormSectionProto() {
    *this = ::std::move(from);
  }

  inline UserFormSectionProto& operator=(const UserFormSectionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserFormSectionProto& operator=(UserFormSectionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserFormSectionProto& default_instance() {
    return *internal_default_instance();
  }
  enum SectionCase {
    kStaticTextSection = 2,
    kTextInputSection = 3,
    kPopupListSection = 4,
    SECTION_NOT_SET = 0,
  };

  static inline const UserFormSectionProto* internal_default_instance() {
    return reinterpret_cast<const UserFormSectionProto*>(
               &_UserFormSectionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(UserFormSectionProto& a, UserFormSectionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UserFormSectionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserFormSectionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserFormSectionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserFormSectionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserFormSectionProto& from);
  void MergeFrom(const UserFormSectionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserFormSectionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.UserFormSectionProto";
  }
  protected:
  explicit UserFormSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kSendResultToBackendFieldNumber = 5,
    kStaticTextSectionFieldNumber = 2,
    kTextInputSectionFieldNumber = 3,
    kPopupListSectionFieldNumber = 4,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional bool send_result_to_backend = 5;
  bool has_send_result_to_backend() const;
  private:
  bool _internal_has_send_result_to_backend() const;
  public:
  void clear_send_result_to_backend();
  bool send_result_to_backend() const;
  void set_send_result_to_backend(bool value);
  private:
  bool _internal_send_result_to_backend() const;
  void _internal_set_send_result_to_backend(bool value);
  public:

  // .autofill_assistant.StaticTextSectionProto static_text_section = 2;
  bool has_static_text_section() const;
  private:
  bool _internal_has_static_text_section() const;
  public:
  void clear_static_text_section();
  const ::autofill_assistant::StaticTextSectionProto& static_text_section() const;
  PROTOBUF_NODISCARD ::autofill_assistant::StaticTextSectionProto* release_static_text_section();
  ::autofill_assistant::StaticTextSectionProto* mutable_static_text_section();
  void set_allocated_static_text_section(::autofill_assistant::StaticTextSectionProto* static_text_section);
  private:
  const ::autofill_assistant::StaticTextSectionProto& _internal_static_text_section() const;
  ::autofill_assistant::StaticTextSectionProto* _internal_mutable_static_text_section();
  public:
  void unsafe_arena_set_allocated_static_text_section(
      ::autofill_assistant::StaticTextSectionProto* static_text_section);
  ::autofill_assistant::StaticTextSectionProto* unsafe_arena_release_static_text_section();

  // .autofill_assistant.TextInputSectionProto text_input_section = 3;
  bool has_text_input_section() const;
  private:
  bool _internal_has_text_input_section() const;
  public:
  void clear_text_input_section();
  const ::autofill_assistant::TextInputSectionProto& text_input_section() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextInputSectionProto* release_text_input_section();
  ::autofill_assistant::TextInputSectionProto* mutable_text_input_section();
  void set_allocated_text_input_section(::autofill_assistant::TextInputSectionProto* text_input_section);
  private:
  const ::autofill_assistant::TextInputSectionProto& _internal_text_input_section() const;
  ::autofill_assistant::TextInputSectionProto* _internal_mutable_text_input_section();
  public:
  void unsafe_arena_set_allocated_text_input_section(
      ::autofill_assistant::TextInputSectionProto* text_input_section);
  ::autofill_assistant::TextInputSectionProto* unsafe_arena_release_text_input_section();

  // .autofill_assistant.PopupListSectionProto popup_list_section = 4;
  bool has_popup_list_section() const;
  private:
  bool _internal_has_popup_list_section() const;
  public:
  void clear_popup_list_section();
  const ::autofill_assistant::PopupListSectionProto& popup_list_section() const;
  PROTOBUF_NODISCARD ::autofill_assistant::PopupListSectionProto* release_popup_list_section();
  ::autofill_assistant::PopupListSectionProto* mutable_popup_list_section();
  void set_allocated_popup_list_section(::autofill_assistant::PopupListSectionProto* popup_list_section);
  private:
  const ::autofill_assistant::PopupListSectionProto& _internal_popup_list_section() const;
  ::autofill_assistant::PopupListSectionProto* _internal_mutable_popup_list_section();
  public:
  void unsafe_arena_set_allocated_popup_list_section(
      ::autofill_assistant::PopupListSectionProto* popup_list_section);
  ::autofill_assistant::PopupListSectionProto* unsafe_arena_release_popup_list_section();

  void clear_section();
  SectionCase section_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.UserFormSectionProto)
 private:
  class _Internal;
  void set_has_static_text_section();
  void set_has_text_input_section();
  void set_has_popup_list_section();

  inline bool has_section() const;
  inline void clear_has_section();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  bool send_result_to_backend_;
  union SectionUnion {
    constexpr SectionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::StaticTextSectionProto* static_text_section_;
    ::autofill_assistant::TextInputSectionProto* text_input_section_;
    ::autofill_assistant::PopupListSectionProto* popup_list_section_;
  } section_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PopupListSectionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PopupListSectionProto) */ {
 public:
  inline PopupListSectionProto() : PopupListSectionProto(nullptr) {}
  ~PopupListSectionProto() override;
  explicit PROTOBUF_CONSTEXPR PopupListSectionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PopupListSectionProto(const PopupListSectionProto& from);
  PopupListSectionProto(PopupListSectionProto&& from) noexcept
    : PopupListSectionProto() {
    *this = ::std::move(from);
  }

  inline PopupListSectionProto& operator=(const PopupListSectionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PopupListSectionProto& operator=(PopupListSectionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PopupListSectionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PopupListSectionProto* internal_default_instance() {
    return reinterpret_cast<const PopupListSectionProto*>(
               &_PopupListSectionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    124;

  friend void swap(PopupListSectionProto& a, PopupListSectionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PopupListSectionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PopupListSectionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PopupListSectionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PopupListSectionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PopupListSectionProto& from);
  void MergeFrom(const PopupListSectionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PopupListSectionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PopupListSectionProto";
  }
  protected:
  explicit PopupListSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemNamesFieldNumber = 2,
    kInitialSelectionFieldNumber = 3,
    kAdditionalValueKeyFieldNumber = 1,
    kNoSelectionErrorMessageFieldNumber = 6,
    kAllowMultiselectFieldNumber = 4,
    kSelectionMandatoryFieldNumber = 5,
  };
  // repeated string item_names = 2;
  int item_names_size() const;
  private:
  int _internal_item_names_size() const;
  public:
  void clear_item_names();
  const std::string& item_names(int index) const;
  std::string* mutable_item_names(int index);
  void set_item_names(int index, const std::string& value);
  void set_item_names(int index, std::string&& value);
  void set_item_names(int index, const char* value);
  void set_item_names(int index, const char* value, size_t size);
  std::string* add_item_names();
  void add_item_names(const std::string& value);
  void add_item_names(std::string&& value);
  void add_item_names(const char* value);
  void add_item_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& item_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_item_names();
  private:
  const std::string& _internal_item_names(int index) const;
  std::string* _internal_add_item_names();
  public:

  // repeated int32 initial_selection = 3;
  int initial_selection_size() const;
  private:
  int _internal_initial_selection_size() const;
  public:
  void clear_initial_selection();
  private:
  int32_t _internal_initial_selection(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_initial_selection() const;
  void _internal_add_initial_selection(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_initial_selection();
  public:
  int32_t initial_selection(int index) const;
  void set_initial_selection(int index, int32_t value);
  void add_initial_selection(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      initial_selection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_initial_selection();

  // optional string additional_value_key = 1;
  bool has_additional_value_key() const;
  private:
  bool _internal_has_additional_value_key() const;
  public:
  void clear_additional_value_key();
  const std::string& additional_value_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_additional_value_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_additional_value_key();
  PROTOBUF_NODISCARD std::string* release_additional_value_key();
  void set_allocated_additional_value_key(std::string* additional_value_key);
  private:
  const std::string& _internal_additional_value_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_additional_value_key(const std::string& value);
  std::string* _internal_mutable_additional_value_key();
  public:

  // optional string no_selection_error_message = 6;
  bool has_no_selection_error_message() const;
  private:
  bool _internal_has_no_selection_error_message() const;
  public:
  void clear_no_selection_error_message();
  const std::string& no_selection_error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_no_selection_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_no_selection_error_message();
  PROTOBUF_NODISCARD std::string* release_no_selection_error_message();
  void set_allocated_no_selection_error_message(std::string* no_selection_error_message);
  private:
  const std::string& _internal_no_selection_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_no_selection_error_message(const std::string& value);
  std::string* _internal_mutable_no_selection_error_message();
  public:

  // optional bool allow_multiselect = 4;
  bool has_allow_multiselect() const;
  private:
  bool _internal_has_allow_multiselect() const;
  public:
  void clear_allow_multiselect();
  bool allow_multiselect() const;
  void set_allow_multiselect(bool value);
  private:
  bool _internal_allow_multiselect() const;
  void _internal_set_allow_multiselect(bool value);
  public:

  // optional bool selection_mandatory = 5 [default = true];
  bool has_selection_mandatory() const;
  private:
  bool _internal_has_selection_mandatory() const;
  public:
  void clear_selection_mandatory();
  bool selection_mandatory() const;
  void set_selection_mandatory(bool value);
  private:
  bool _internal_selection_mandatory() const;
  void _internal_set_selection_mandatory(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PopupListSectionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> item_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > initial_selection_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr additional_value_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr no_selection_error_message_;
  bool allow_multiselect_;
  bool selection_mandatory_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AutofillEntryProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.AutofillEntryProto) */ {
 public:
  inline AutofillEntryProto() : AutofillEntryProto(nullptr) {}
  ~AutofillEntryProto() override;
  explicit PROTOBUF_CONSTEXPR AutofillEntryProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillEntryProto(const AutofillEntryProto& from);
  AutofillEntryProto(AutofillEntryProto&& from) noexcept
    : AutofillEntryProto() {
    *this = ::std::move(from);
  }

  inline AutofillEntryProto& operator=(const AutofillEntryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillEntryProto& operator=(AutofillEntryProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillEntryProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillEntryProto* internal_default_instance() {
    return reinterpret_cast<const AutofillEntryProto*>(
               &_AutofillEntryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    125;

  friend void swap(AutofillEntryProto& a, AutofillEntryProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillEntryProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillEntryProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillEntryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillEntryProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillEntryProto& from);
  void MergeFrom(const AutofillEntryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillEntryProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.AutofillEntryProto";
  }
  protected:
  explicit AutofillEntryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kRawFieldNumber = 2,
  };
  // optional string value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional bool raw = 2;
  bool has_raw() const;
  private:
  bool _internal_has_raw() const;
  public:
  void clear_raw();
  bool raw() const;
  void set_raw(bool value);
  private:
  bool _internal_raw() const;
  void _internal_set_raw(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.AutofillEntryProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  bool raw_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ProfileProto_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileProto_ValuesEntry_DoNotUse, 
    int32_t, ::autofill_assistant::AutofillEntryProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileProto_ValuesEntry_DoNotUse, 
    int32_t, ::autofill_assistant::AutofillEntryProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ProfileProto_ValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProfileProto_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProfileProto_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProfileProto_ValuesEntry_DoNotUse& other);
  static const ProfileProto_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProfileProto_ValuesEntry_DoNotUse*>(&_ProfileProto_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};

// -------------------------------------------------------------------

class ProfileProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ProfileProto) */ {
 public:
  inline ProfileProto() : ProfileProto(nullptr) {}
  ~ProfileProto() override;
  explicit PROTOBUF_CONSTEXPR ProfileProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileProto(const ProfileProto& from);
  ProfileProto(ProfileProto&& from) noexcept
    : ProfileProto() {
    *this = ::std::move(from);
  }

  inline ProfileProto& operator=(const ProfileProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileProto& operator=(ProfileProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProfileProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileProto* internal_default_instance() {
    return reinterpret_cast<const ProfileProto*>(
               &_ProfileProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    127;

  friend void swap(ProfileProto& a, ProfileProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ProfileProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProfileProto& from);
  void MergeFrom(const ProfileProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ProfileProto";
  }
  protected:
  explicit ProfileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kIdentifierFieldNumber = 3,
    kEditTokenFieldNumber = 4,
  };
  // map<int32, .autofill_assistant.AutofillEntryProto> values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
      mutable_values();

  // optional string identifier = 3;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional bytes edit_token = 4;
  bool has_edit_token() const;
  private:
  bool _internal_has_edit_token() const;
  public:
  void clear_edit_token();
  const std::string& edit_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_token();
  PROTOBUF_NODISCARD std::string* release_edit_token();
  void set_allocated_edit_token(std::string* edit_token);
  private:
  const std::string& _internal_edit_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_token(const std::string& value);
  std::string* _internal_mutable_edit_token();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ProfileProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ProfileProto_ValuesEntry_DoNotUse,
      int32_t, ::autofill_assistant::AutofillEntryProto,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_token_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PhoneNumberProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PhoneNumberProto) */ {
 public:
  inline PhoneNumberProto() : PhoneNumberProto(nullptr) {}
  ~PhoneNumberProto() override;
  explicit PROTOBUF_CONSTEXPR PhoneNumberProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhoneNumberProto(const PhoneNumberProto& from);
  PhoneNumberProto(PhoneNumberProto&& from) noexcept
    : PhoneNumberProto() {
    *this = ::std::move(from);
  }

  inline PhoneNumberProto& operator=(const PhoneNumberProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneNumberProto& operator=(PhoneNumberProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PhoneNumberProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhoneNumberProto* internal_default_instance() {
    return reinterpret_cast<const PhoneNumberProto*>(
               &_PhoneNumberProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    128;

  friend void swap(PhoneNumberProto& a, PhoneNumberProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PhoneNumberProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneNumberProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhoneNumberProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhoneNumberProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PhoneNumberProto& from);
  void MergeFrom(const PhoneNumberProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PhoneNumberProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PhoneNumberProto";
  }
  protected:
  explicit PhoneNumberProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .autofill_assistant.AutofillEntryProto value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::AutofillEntryProto& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::AutofillEntryProto* release_value();
  ::autofill_assistant::AutofillEntryProto* mutable_value();
  void set_allocated_value(::autofill_assistant::AutofillEntryProto* value);
  private:
  const ::autofill_assistant::AutofillEntryProto& _internal_value() const;
  ::autofill_assistant::AutofillEntryProto* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::AutofillEntryProto* value);
  ::autofill_assistant::AutofillEntryProto* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.PhoneNumberProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::autofill_assistant::AutofillEntryProto* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PaymentInstrumentProto_CardValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<PaymentInstrumentProto_CardValuesEntry_DoNotUse, 
    int32_t, ::autofill_assistant::AutofillEntryProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<PaymentInstrumentProto_CardValuesEntry_DoNotUse, 
    int32_t, ::autofill_assistant::AutofillEntryProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PaymentInstrumentProto_CardValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PaymentInstrumentProto_CardValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PaymentInstrumentProto_CardValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PaymentInstrumentProto_CardValuesEntry_DoNotUse& other);
  static const PaymentInstrumentProto_CardValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PaymentInstrumentProto_CardValuesEntry_DoNotUse*>(&_PaymentInstrumentProto_CardValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};

// -------------------------------------------------------------------

class PaymentInstrumentProto_AddressValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<PaymentInstrumentProto_AddressValuesEntry_DoNotUse, 
    int32_t, ::autofill_assistant::AutofillEntryProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<PaymentInstrumentProto_AddressValuesEntry_DoNotUse, 
    int32_t, ::autofill_assistant::AutofillEntryProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PaymentInstrumentProto_AddressValuesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PaymentInstrumentProto_AddressValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PaymentInstrumentProto_AddressValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PaymentInstrumentProto_AddressValuesEntry_DoNotUse& other);
  static const PaymentInstrumentProto_AddressValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PaymentInstrumentProto_AddressValuesEntry_DoNotUse*>(&_PaymentInstrumentProto_AddressValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};

// -------------------------------------------------------------------

class PaymentInstrumentProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PaymentInstrumentProto) */ {
 public:
  inline PaymentInstrumentProto() : PaymentInstrumentProto(nullptr) {}
  ~PaymentInstrumentProto() override;
  explicit PROTOBUF_CONSTEXPR PaymentInstrumentProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentInstrumentProto(const PaymentInstrumentProto& from);
  PaymentInstrumentProto(PaymentInstrumentProto&& from) noexcept
    : PaymentInstrumentProto() {
    *this = ::std::move(from);
  }

  inline PaymentInstrumentProto& operator=(const PaymentInstrumentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentInstrumentProto& operator=(PaymentInstrumentProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PaymentInstrumentProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentInstrumentProto* internal_default_instance() {
    return reinterpret_cast<const PaymentInstrumentProto*>(
               &_PaymentInstrumentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    131;

  friend void swap(PaymentInstrumentProto& a, PaymentInstrumentProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PaymentInstrumentProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentInstrumentProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentInstrumentProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentInstrumentProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PaymentInstrumentProto& from);
  void MergeFrom(const PaymentInstrumentProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaymentInstrumentProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PaymentInstrumentProto";
  }
  protected:
  explicit PaymentInstrumentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCardValuesFieldNumber = 2,
    kAddressValuesFieldNumber = 3,
    kIdentifierFieldNumber = 4,
    kNetworkFieldNumber = 5,
    kLastFourDigitsFieldNumber = 6,
    kEditTokenFieldNumber = 8,
    kInstrumentIdFieldNumber = 7,
  };
  // map<int32, .autofill_assistant.AutofillEntryProto> card_values = 2;
  int card_values_size() const;
  private:
  int _internal_card_values_size() const;
  public:
  void clear_card_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
      _internal_card_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
      _internal_mutable_card_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
      card_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
      mutable_card_values();

  // map<int32, .autofill_assistant.AutofillEntryProto> address_values = 3;
  int address_values_size() const;
  private:
  int _internal_address_values_size() const;
  public:
  void clear_address_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
      _internal_address_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
      _internal_mutable_address_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
      address_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
      mutable_address_values();

  // optional string identifier = 4;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional string network = 5;
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // optional string last_four_digits = 6;
  bool has_last_four_digits() const;
  private:
  bool _internal_has_last_four_digits() const;
  public:
  void clear_last_four_digits();
  const std::string& last_four_digits() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_four_digits(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_four_digits();
  PROTOBUF_NODISCARD std::string* release_last_four_digits();
  void set_allocated_last_four_digits(std::string* last_four_digits);
  private:
  const std::string& _internal_last_four_digits() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_four_digits(const std::string& value);
  std::string* _internal_mutable_last_four_digits();
  public:

  // optional bytes edit_token = 8;
  bool has_edit_token() const;
  private:
  bool _internal_has_edit_token() const;
  public:
  void clear_edit_token();
  const std::string& edit_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_token();
  PROTOBUF_NODISCARD std::string* release_edit_token();
  void set_allocated_edit_token(std::string* edit_token);
  private:
  const std::string& _internal_edit_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_token(const std::string& value);
  std::string* _internal_mutable_edit_token();
  public:

  // optional int64 instrument_id = 7;
  bool has_instrument_id() const;
  private:
  bool _internal_has_instrument_id() const;
  public:
  void clear_instrument_id();
  int64_t instrument_id() const;
  void set_instrument_id(int64_t value);
  private:
  int64_t _internal_instrument_id() const;
  void _internal_set_instrument_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PaymentInstrumentProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      PaymentInstrumentProto_CardValuesEntry_DoNotUse,
      int32_t, ::autofill_assistant::AutofillEntryProto,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> card_values_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      PaymentInstrumentProto_AddressValuesEntry_DoNotUse,
      int32_t, ::autofill_assistant::AutofillEntryProto,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> address_values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_four_digits_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_token_;
  int64_t instrument_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DataOriginNoticeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DataOriginNoticeProto) */ {
 public:
  inline DataOriginNoticeProto() : DataOriginNoticeProto(nullptr) {}
  ~DataOriginNoticeProto() override;
  explicit PROTOBUF_CONSTEXPR DataOriginNoticeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataOriginNoticeProto(const DataOriginNoticeProto& from);
  DataOriginNoticeProto(DataOriginNoticeProto&& from) noexcept
    : DataOriginNoticeProto() {
    *this = ::std::move(from);
  }

  inline DataOriginNoticeProto& operator=(const DataOriginNoticeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataOriginNoticeProto& operator=(DataOriginNoticeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DataOriginNoticeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataOriginNoticeProto* internal_default_instance() {
    return reinterpret_cast<const DataOriginNoticeProto*>(
               &_DataOriginNoticeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    132;

  friend void swap(DataOriginNoticeProto& a, DataOriginNoticeProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataOriginNoticeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataOriginNoticeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataOriginNoticeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataOriginNoticeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataOriginNoticeProto& from);
  void MergeFrom(const DataOriginNoticeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataOriginNoticeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DataOriginNoticeProto";
  }
  protected:
  explicit DataOriginNoticeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkTextFieldNumber = 1,
    kDialogTitleFieldNumber = 2,
    kDialogTextFieldNumber = 3,
    kDialogButtonTextFieldNumber = 4,
  };
  // optional string link_text = 1;
  bool has_link_text() const;
  private:
  bool _internal_has_link_text() const;
  public:
  void clear_link_text();
  const std::string& link_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_text();
  PROTOBUF_NODISCARD std::string* release_link_text();
  void set_allocated_link_text(std::string* link_text);
  private:
  const std::string& _internal_link_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_text(const std::string& value);
  std::string* _internal_mutable_link_text();
  public:

  // optional string dialog_title = 2;
  bool has_dialog_title() const;
  private:
  bool _internal_has_dialog_title() const;
  public:
  void clear_dialog_title();
  const std::string& dialog_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialog_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialog_title();
  PROTOBUF_NODISCARD std::string* release_dialog_title();
  void set_allocated_dialog_title(std::string* dialog_title);
  private:
  const std::string& _internal_dialog_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialog_title(const std::string& value);
  std::string* _internal_mutable_dialog_title();
  public:

  // optional string dialog_text = 3;
  bool has_dialog_text() const;
  private:
  bool _internal_has_dialog_text() const;
  public:
  void clear_dialog_text();
  const std::string& dialog_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialog_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialog_text();
  PROTOBUF_NODISCARD std::string* release_dialog_text();
  void set_allocated_dialog_text(std::string* dialog_text);
  private:
  const std::string& _internal_dialog_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialog_text(const std::string& value);
  std::string* _internal_mutable_dialog_text();
  public:

  // optional string dialog_button_text = 4;
  bool has_dialog_button_text() const;
  private:
  bool _internal_has_dialog_button_text() const;
  public:
  void clear_dialog_button_text();
  const std::string& dialog_button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialog_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialog_button_text();
  PROTOBUF_NODISCARD std::string* release_dialog_button_text();
  void set_allocated_dialog_button_text(std::string* dialog_button_text);
  private:
  const std::string& _internal_dialog_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialog_button_text(const std::string& value);
  std::string* _internal_mutable_dialog_button_text();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DataOriginNoticeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialog_title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialog_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialog_button_text_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CollectUserDataProto_DataSource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CollectUserDataProto.DataSource) */ {
 public:
  inline CollectUserDataProto_DataSource() : CollectUserDataProto_DataSource(nullptr) {}
  ~CollectUserDataProto_DataSource() override;
  explicit PROTOBUF_CONSTEXPR CollectUserDataProto_DataSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectUserDataProto_DataSource(const CollectUserDataProto_DataSource& from);
  CollectUserDataProto_DataSource(CollectUserDataProto_DataSource&& from) noexcept
    : CollectUserDataProto_DataSource() {
    *this = ::std::move(from);
  }

  inline CollectUserDataProto_DataSource& operator=(const CollectUserDataProto_DataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectUserDataProto_DataSource& operator=(CollectUserDataProto_DataSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CollectUserDataProto_DataSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectUserDataProto_DataSource* internal_default_instance() {
    return reinterpret_cast<const CollectUserDataProto_DataSource*>(
               &_CollectUserDataProto_DataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    133;

  friend void swap(CollectUserDataProto_DataSource& a, CollectUserDataProto_DataSource& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CollectUserDataProto_DataSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectUserDataProto_DataSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectUserDataProto_DataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectUserDataProto_DataSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CollectUserDataProto_DataSource& from);
  void MergeFrom(const CollectUserDataProto_DataSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectUserDataProto_DataSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CollectUserDataProto.DataSource";
  }
  protected:
  explicit CollectUserDataProto_DataSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowFallbackFieldNumber = 1,
  };
  // optional bool allow_fallback = 1 [default = true];
  bool has_allow_fallback() const;
  private:
  bool _internal_has_allow_fallback() const;
  public:
  void clear_allow_fallback();
  bool allow_fallback() const;
  void set_allow_fallback(bool value);
  private:
  bool _internal_allow_fallback() const;
  void _internal_set_allow_fallback(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CollectUserDataProto.DataSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool allow_fallback_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CollectUserDataProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CollectUserDataProto) */ {
 public:
  inline CollectUserDataProto() : CollectUserDataProto(nullptr) {}
  ~CollectUserDataProto() override;
  explicit PROTOBUF_CONSTEXPR CollectUserDataProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectUserDataProto(const CollectUserDataProto& from);
  CollectUserDataProto(CollectUserDataProto&& from) noexcept
    : CollectUserDataProto() {
    *this = ::std::move(from);
  }

  inline CollectUserDataProto& operator=(const CollectUserDataProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectUserDataProto& operator=(CollectUserDataProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CollectUserDataProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectUserDataProto* internal_default_instance() {
    return reinterpret_cast<const CollectUserDataProto*>(
               &_CollectUserDataProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    134;

  friend void swap(CollectUserDataProto& a, CollectUserDataProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CollectUserDataProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectUserDataProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectUserDataProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectUserDataProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CollectUserDataProto& from);
  void MergeFrom(const CollectUserDataProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollectUserDataProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CollectUserDataProto";
  }
  protected:
  explicit CollectUserDataProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CollectUserDataProto_DataSource DataSource;

  typedef CollectUserDataProto_TermsAndConditionsState TermsAndConditionsState;
  static constexpr TermsAndConditionsState NOT_SELECTED =
    CollectUserDataProto_TermsAndConditionsState_NOT_SELECTED;
  static constexpr TermsAndConditionsState ACCEPTED =
    CollectUserDataProto_TermsAndConditionsState_ACCEPTED;
  static constexpr TermsAndConditionsState REVIEW_REQUIRED =
    CollectUserDataProto_TermsAndConditionsState_REVIEW_REQUIRED;
  static inline bool TermsAndConditionsState_IsValid(int value) {
    return CollectUserDataProto_TermsAndConditionsState_IsValid(value);
  }
  static constexpr TermsAndConditionsState TermsAndConditionsState_MIN =
    CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_MIN;
  static constexpr TermsAndConditionsState TermsAndConditionsState_MAX =
    CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_MAX;
  static constexpr int TermsAndConditionsState_ARRAYSIZE =
    CollectUserDataProto_TermsAndConditionsState_TermsAndConditionsState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TermsAndConditionsState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TermsAndConditionsState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TermsAndConditionsState_Name.");
    return CollectUserDataProto_TermsAndConditionsState_Name(enum_t_value);
  }
  static inline bool TermsAndConditionsState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TermsAndConditionsState* value) {
    return CollectUserDataProto_TermsAndConditionsState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedBasicCardNetworksFieldNumber = 6,
    kAdditionalActionsFieldNumber = 11,
    kAdditionalPrependedSectionsFieldNumber = 18,
    kAdditionalAppendedSectionsFieldNumber = 19,
    kClearPreviousProfileSelectionFieldNumber = 30,
    kRequiredShippingAddressDataPieceFieldNumber = 34,
    kRequiredCreditCardDataPieceFieldNumber = 35,
    kRequiredBillingAddressDataPieceFieldNumber = 36,
    kPromptFieldNumber = 1,
    kBillingAddressNameFieldNumber = 2,
    kShippingAddressNameFieldNumber = 3,
    kAcceptTermsAndConditionsTextFieldNumber = 13,
    kTermsRequireReviewTextFieldNumber = 20,
    kPrivacyNoticeTextFieldNumber = 21,
    kCreditCardExpiredTextFieldNumber = 23,
    kInfoSectionTextFieldNumber = 24,
    kAdditionalModelIdentifierToCheckFieldNumber = 27,
    kShippingAddressSectionTitleFieldNumber = 32,
    kContactDetailsFieldNumber = 5,
    kLoginDetailsFieldNumber = 16,
    kGenericUserInterfacePrependedFieldNumber = 22,
    kGenericUserInterfaceAppendedFieldNumber = 25,
    kConfirmChipFieldNumber = 33,
    kDataSourceFieldNumber = 38,
    kDataOriginNoticeFieldNumber = 39,
    kTermsAndConditionsStateFieldNumber = 8,
    kRequestPaymentMethodFieldNumber = 4,
    kShowTermsAsCheckboxFieldNumber = 12,
    kInfoSectionTextCenterFieldNumber = 31,
    kClearPreviousCreditCardSelectionFieldNumber = 28,
    kClearPreviousLoginSelectionFieldNumber = 29,
    kRequestTermsAndConditionsFieldNumber = 9,
  };
  // repeated string supported_basic_card_networks = 6;
  int supported_basic_card_networks_size() const;
  private:
  int _internal_supported_basic_card_networks_size() const;
  public:
  void clear_supported_basic_card_networks();
  const std::string& supported_basic_card_networks(int index) const;
  std::string* mutable_supported_basic_card_networks(int index);
  void set_supported_basic_card_networks(int index, const std::string& value);
  void set_supported_basic_card_networks(int index, std::string&& value);
  void set_supported_basic_card_networks(int index, const char* value);
  void set_supported_basic_card_networks(int index, const char* value, size_t size);
  std::string* add_supported_basic_card_networks();
  void add_supported_basic_card_networks(const std::string& value);
  void add_supported_basic_card_networks(std::string&& value);
  void add_supported_basic_card_networks(const char* value);
  void add_supported_basic_card_networks(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_basic_card_networks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_basic_card_networks();
  private:
  const std::string& _internal_supported_basic_card_networks(int index) const;
  std::string* _internal_add_supported_basic_card_networks();
  public:

  // repeated .autofill_assistant.UserActionProto additional_actions = 11;
  int additional_actions_size() const;
  private:
  int _internal_additional_actions_size() const;
  public:
  void clear_additional_actions();
  ::autofill_assistant::UserActionProto* mutable_additional_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >*
      mutable_additional_actions();
  private:
  const ::autofill_assistant::UserActionProto& _internal_additional_actions(int index) const;
  ::autofill_assistant::UserActionProto* _internal_add_additional_actions();
  public:
  const ::autofill_assistant::UserActionProto& additional_actions(int index) const;
  ::autofill_assistant::UserActionProto* add_additional_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >&
      additional_actions() const;

  // repeated .autofill_assistant.UserFormSectionProto additional_prepended_sections = 18;
  int additional_prepended_sections_size() const;
  private:
  int _internal_additional_prepended_sections_size() const;
  public:
  void clear_additional_prepended_sections();
  ::autofill_assistant::UserFormSectionProto* mutable_additional_prepended_sections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >*
      mutable_additional_prepended_sections();
  private:
  const ::autofill_assistant::UserFormSectionProto& _internal_additional_prepended_sections(int index) const;
  ::autofill_assistant::UserFormSectionProto* _internal_add_additional_prepended_sections();
  public:
  const ::autofill_assistant::UserFormSectionProto& additional_prepended_sections(int index) const;
  ::autofill_assistant::UserFormSectionProto* add_additional_prepended_sections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >&
      additional_prepended_sections() const;

  // repeated .autofill_assistant.UserFormSectionProto additional_appended_sections = 19;
  int additional_appended_sections_size() const;
  private:
  int _internal_additional_appended_sections_size() const;
  public:
  void clear_additional_appended_sections();
  ::autofill_assistant::UserFormSectionProto* mutable_additional_appended_sections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >*
      mutable_additional_appended_sections();
  private:
  const ::autofill_assistant::UserFormSectionProto& _internal_additional_appended_sections(int index) const;
  ::autofill_assistant::UserFormSectionProto* _internal_add_additional_appended_sections();
  public:
  const ::autofill_assistant::UserFormSectionProto& additional_appended_sections(int index) const;
  ::autofill_assistant::UserFormSectionProto* add_additional_appended_sections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >&
      additional_appended_sections() const;

  // repeated string clear_previous_profile_selection = 30;
  int clear_previous_profile_selection_size() const;
  private:
  int _internal_clear_previous_profile_selection_size() const;
  public:
  void clear_clear_previous_profile_selection();
  const std::string& clear_previous_profile_selection(int index) const;
  std::string* mutable_clear_previous_profile_selection(int index);
  void set_clear_previous_profile_selection(int index, const std::string& value);
  void set_clear_previous_profile_selection(int index, std::string&& value);
  void set_clear_previous_profile_selection(int index, const char* value);
  void set_clear_previous_profile_selection(int index, const char* value, size_t size);
  std::string* add_clear_previous_profile_selection();
  void add_clear_previous_profile_selection(const std::string& value);
  void add_clear_previous_profile_selection(std::string&& value);
  void add_clear_previous_profile_selection(const char* value);
  void add_clear_previous_profile_selection(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& clear_previous_profile_selection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_clear_previous_profile_selection();
  private:
  const std::string& _internal_clear_previous_profile_selection(int index) const;
  std::string* _internal_add_clear_previous_profile_selection();
  public:

  // repeated .autofill_assistant.RequiredDataPiece required_shipping_address_data_piece = 34;
  int required_shipping_address_data_piece_size() const;
  private:
  int _internal_required_shipping_address_data_piece_size() const;
  public:
  void clear_required_shipping_address_data_piece();
  ::autofill_assistant::RequiredDataPiece* mutable_required_shipping_address_data_piece(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
      mutable_required_shipping_address_data_piece();
  private:
  const ::autofill_assistant::RequiredDataPiece& _internal_required_shipping_address_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* _internal_add_required_shipping_address_data_piece();
  public:
  const ::autofill_assistant::RequiredDataPiece& required_shipping_address_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* add_required_shipping_address_data_piece();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
      required_shipping_address_data_piece() const;

  // repeated .autofill_assistant.RequiredDataPiece required_credit_card_data_piece = 35;
  int required_credit_card_data_piece_size() const;
  private:
  int _internal_required_credit_card_data_piece_size() const;
  public:
  void clear_required_credit_card_data_piece();
  ::autofill_assistant::RequiredDataPiece* mutable_required_credit_card_data_piece(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
      mutable_required_credit_card_data_piece();
  private:
  const ::autofill_assistant::RequiredDataPiece& _internal_required_credit_card_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* _internal_add_required_credit_card_data_piece();
  public:
  const ::autofill_assistant::RequiredDataPiece& required_credit_card_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* add_required_credit_card_data_piece();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
      required_credit_card_data_piece() const;

  // repeated .autofill_assistant.RequiredDataPiece required_billing_address_data_piece = 36;
  int required_billing_address_data_piece_size() const;
  private:
  int _internal_required_billing_address_data_piece_size() const;
  public:
  void clear_required_billing_address_data_piece();
  ::autofill_assistant::RequiredDataPiece* mutable_required_billing_address_data_piece(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
      mutable_required_billing_address_data_piece();
  private:
  const ::autofill_assistant::RequiredDataPiece& _internal_required_billing_address_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* _internal_add_required_billing_address_data_piece();
  public:
  const ::autofill_assistant::RequiredDataPiece& required_billing_address_data_piece(int index) const;
  ::autofill_assistant::RequiredDataPiece* add_required_billing_address_data_piece();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
      required_billing_address_data_piece() const;

  // optional string prompt = 1;
  bool has_prompt() const;
  private:
  bool _internal_has_prompt() const;
  public:
  void clear_prompt();
  const std::string& prompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prompt();
  PROTOBUF_NODISCARD std::string* release_prompt();
  void set_allocated_prompt(std::string* prompt);
  private:
  const std::string& _internal_prompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prompt(const std::string& value);
  std::string* _internal_mutable_prompt();
  public:

  // optional string billing_address_name = 2;
  bool has_billing_address_name() const;
  private:
  bool _internal_has_billing_address_name() const;
  public:
  void clear_billing_address_name();
  const std::string& billing_address_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_billing_address_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_billing_address_name();
  PROTOBUF_NODISCARD std::string* release_billing_address_name();
  void set_allocated_billing_address_name(std::string* billing_address_name);
  private:
  const std::string& _internal_billing_address_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_billing_address_name(const std::string& value);
  std::string* _internal_mutable_billing_address_name();
  public:

  // optional string shipping_address_name = 3;
  bool has_shipping_address_name() const;
  private:
  bool _internal_has_shipping_address_name() const;
  public:
  void clear_shipping_address_name();
  const std::string& shipping_address_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shipping_address_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shipping_address_name();
  PROTOBUF_NODISCARD std::string* release_shipping_address_name();
  void set_allocated_shipping_address_name(std::string* shipping_address_name);
  private:
  const std::string& _internal_shipping_address_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shipping_address_name(const std::string& value);
  std::string* _internal_mutable_shipping_address_name();
  public:

  // optional string accept_terms_and_conditions_text = 13;
  bool has_accept_terms_and_conditions_text() const;
  private:
  bool _internal_has_accept_terms_and_conditions_text() const;
  public:
  void clear_accept_terms_and_conditions_text();
  const std::string& accept_terms_and_conditions_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accept_terms_and_conditions_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accept_terms_and_conditions_text();
  PROTOBUF_NODISCARD std::string* release_accept_terms_and_conditions_text();
  void set_allocated_accept_terms_and_conditions_text(std::string* accept_terms_and_conditions_text);
  private:
  const std::string& _internal_accept_terms_and_conditions_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accept_terms_and_conditions_text(const std::string& value);
  std::string* _internal_mutable_accept_terms_and_conditions_text();
  public:

  // optional string terms_require_review_text = 20;
  bool has_terms_require_review_text() const;
  private:
  bool _internal_has_terms_require_review_text() const;
  public:
  void clear_terms_require_review_text();
  const std::string& terms_require_review_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_terms_require_review_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_terms_require_review_text();
  PROTOBUF_NODISCARD std::string* release_terms_require_review_text();
  void set_allocated_terms_require_review_text(std::string* terms_require_review_text);
  private:
  const std::string& _internal_terms_require_review_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terms_require_review_text(const std::string& value);
  std::string* _internal_mutable_terms_require_review_text();
  public:

  // optional string privacy_notice_text = 21;
  bool has_privacy_notice_text() const;
  private:
  bool _internal_has_privacy_notice_text() const;
  public:
  void clear_privacy_notice_text();
  const std::string& privacy_notice_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privacy_notice_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privacy_notice_text();
  PROTOBUF_NODISCARD std::string* release_privacy_notice_text();
  void set_allocated_privacy_notice_text(std::string* privacy_notice_text);
  private:
  const std::string& _internal_privacy_notice_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privacy_notice_text(const std::string& value);
  std::string* _internal_mutable_privacy_notice_text();
  public:

  // optional string credit_card_expired_text = 23;
  bool has_credit_card_expired_text() const;
  private:
  bool _internal_has_credit_card_expired_text() const;
  public:
  void clear_credit_card_expired_text();
  const std::string& credit_card_expired_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credit_card_expired_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credit_card_expired_text();
  PROTOBUF_NODISCARD std::string* release_credit_card_expired_text();
  void set_allocated_credit_card_expired_text(std::string* credit_card_expired_text);
  private:
  const std::string& _internal_credit_card_expired_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credit_card_expired_text(const std::string& value);
  std::string* _internal_mutable_credit_card_expired_text();
  public:

  // optional string info_section_text = 24;
  bool has_info_section_text() const;
  private:
  bool _internal_has_info_section_text() const;
  public:
  void clear_info_section_text();
  const std::string& info_section_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info_section_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info_section_text();
  PROTOBUF_NODISCARD std::string* release_info_section_text();
  void set_allocated_info_section_text(std::string* info_section_text);
  private:
  const std::string& _internal_info_section_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info_section_text(const std::string& value);
  std::string* _internal_mutable_info_section_text();
  public:

  // optional string additional_model_identifier_to_check = 27;
  bool has_additional_model_identifier_to_check() const;
  private:
  bool _internal_has_additional_model_identifier_to_check() const;
  public:
  void clear_additional_model_identifier_to_check();
  const std::string& additional_model_identifier_to_check() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_additional_model_identifier_to_check(ArgT0&& arg0, ArgT... args);
  std::string* mutable_additional_model_identifier_to_check();
  PROTOBUF_NODISCARD std::string* release_additional_model_identifier_to_check();
  void set_allocated_additional_model_identifier_to_check(std::string* additional_model_identifier_to_check);
  private:
  const std::string& _internal_additional_model_identifier_to_check() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_additional_model_identifier_to_check(const std::string& value);
  std::string* _internal_mutable_additional_model_identifier_to_check();
  public:

  // optional string shipping_address_section_title = 32;
  bool has_shipping_address_section_title() const;
  private:
  bool _internal_has_shipping_address_section_title() const;
  public:
  void clear_shipping_address_section_title();
  const std::string& shipping_address_section_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shipping_address_section_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shipping_address_section_title();
  PROTOBUF_NODISCARD std::string* release_shipping_address_section_title();
  void set_allocated_shipping_address_section_title(std::string* shipping_address_section_title);
  private:
  const std::string& _internal_shipping_address_section_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shipping_address_section_title(const std::string& value);
  std::string* _internal_mutable_shipping_address_section_title();
  public:

  // optional .autofill_assistant.ContactDetailsProto contact_details = 5;
  bool has_contact_details() const;
  private:
  bool _internal_has_contact_details() const;
  public:
  void clear_contact_details();
  const ::autofill_assistant::ContactDetailsProto& contact_details() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ContactDetailsProto* release_contact_details();
  ::autofill_assistant::ContactDetailsProto* mutable_contact_details();
  void set_allocated_contact_details(::autofill_assistant::ContactDetailsProto* contact_details);
  private:
  const ::autofill_assistant::ContactDetailsProto& _internal_contact_details() const;
  ::autofill_assistant::ContactDetailsProto* _internal_mutable_contact_details();
  public:
  void unsafe_arena_set_allocated_contact_details(
      ::autofill_assistant::ContactDetailsProto* contact_details);
  ::autofill_assistant::ContactDetailsProto* unsafe_arena_release_contact_details();

  // optional .autofill_assistant.LoginDetailsProto login_details = 16;
  bool has_login_details() const;
  private:
  bool _internal_has_login_details() const;
  public:
  void clear_login_details();
  const ::autofill_assistant::LoginDetailsProto& login_details() const;
  PROTOBUF_NODISCARD ::autofill_assistant::LoginDetailsProto* release_login_details();
  ::autofill_assistant::LoginDetailsProto* mutable_login_details();
  void set_allocated_login_details(::autofill_assistant::LoginDetailsProto* login_details);
  private:
  const ::autofill_assistant::LoginDetailsProto& _internal_login_details() const;
  ::autofill_assistant::LoginDetailsProto* _internal_mutable_login_details();
  public:
  void unsafe_arena_set_allocated_login_details(
      ::autofill_assistant::LoginDetailsProto* login_details);
  ::autofill_assistant::LoginDetailsProto* unsafe_arena_release_login_details();

  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_prepended = 22;
  bool has_generic_user_interface_prepended() const;
  private:
  bool _internal_has_generic_user_interface_prepended() const;
  public:
  void clear_generic_user_interface_prepended();
  const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface_prepended() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GenericUserInterfaceProto* release_generic_user_interface_prepended();
  ::autofill_assistant::GenericUserInterfaceProto* mutable_generic_user_interface_prepended();
  void set_allocated_generic_user_interface_prepended(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_prepended);
  private:
  const ::autofill_assistant::GenericUserInterfaceProto& _internal_generic_user_interface_prepended() const;
  ::autofill_assistant::GenericUserInterfaceProto* _internal_mutable_generic_user_interface_prepended();
  public:
  void unsafe_arena_set_allocated_generic_user_interface_prepended(
      ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_prepended);
  ::autofill_assistant::GenericUserInterfaceProto* unsafe_arena_release_generic_user_interface_prepended();

  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_appended = 25;
  bool has_generic_user_interface_appended() const;
  private:
  bool _internal_has_generic_user_interface_appended() const;
  public:
  void clear_generic_user_interface_appended();
  const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface_appended() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GenericUserInterfaceProto* release_generic_user_interface_appended();
  ::autofill_assistant::GenericUserInterfaceProto* mutable_generic_user_interface_appended();
  void set_allocated_generic_user_interface_appended(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_appended);
  private:
  const ::autofill_assistant::GenericUserInterfaceProto& _internal_generic_user_interface_appended() const;
  ::autofill_assistant::GenericUserInterfaceProto* _internal_mutable_generic_user_interface_appended();
  public:
  void unsafe_arena_set_allocated_generic_user_interface_appended(
      ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_appended);
  ::autofill_assistant::GenericUserInterfaceProto* unsafe_arena_release_generic_user_interface_appended();

  // optional .autofill_assistant.ChipProto confirm_chip = 33;
  bool has_confirm_chip() const;
  private:
  bool _internal_has_confirm_chip() const;
  public:
  void clear_confirm_chip();
  const ::autofill_assistant::ChipProto& confirm_chip() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ChipProto* release_confirm_chip();
  ::autofill_assistant::ChipProto* mutable_confirm_chip();
  void set_allocated_confirm_chip(::autofill_assistant::ChipProto* confirm_chip);
  private:
  const ::autofill_assistant::ChipProto& _internal_confirm_chip() const;
  ::autofill_assistant::ChipProto* _internal_mutable_confirm_chip();
  public:
  void unsafe_arena_set_allocated_confirm_chip(
      ::autofill_assistant::ChipProto* confirm_chip);
  ::autofill_assistant::ChipProto* unsafe_arena_release_confirm_chip();

  // optional .autofill_assistant.CollectUserDataProto.DataSource data_source = 38;
  bool has_data_source() const;
  private:
  bool _internal_has_data_source() const;
  public:
  void clear_data_source();
  const ::autofill_assistant::CollectUserDataProto_DataSource& data_source() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CollectUserDataProto_DataSource* release_data_source();
  ::autofill_assistant::CollectUserDataProto_DataSource* mutable_data_source();
  void set_allocated_data_source(::autofill_assistant::CollectUserDataProto_DataSource* data_source);
  private:
  const ::autofill_assistant::CollectUserDataProto_DataSource& _internal_data_source() const;
  ::autofill_assistant::CollectUserDataProto_DataSource* _internal_mutable_data_source();
  public:
  void unsafe_arena_set_allocated_data_source(
      ::autofill_assistant::CollectUserDataProto_DataSource* data_source);
  ::autofill_assistant::CollectUserDataProto_DataSource* unsafe_arena_release_data_source();

  // optional .autofill_assistant.DataOriginNoticeProto data_origin_notice = 39;
  bool has_data_origin_notice() const;
  private:
  bool _internal_has_data_origin_notice() const;
  public:
  void clear_data_origin_notice();
  const ::autofill_assistant::DataOriginNoticeProto& data_origin_notice() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DataOriginNoticeProto* release_data_origin_notice();
  ::autofill_assistant::DataOriginNoticeProto* mutable_data_origin_notice();
  void set_allocated_data_origin_notice(::autofill_assistant::DataOriginNoticeProto* data_origin_notice);
  private:
  const ::autofill_assistant::DataOriginNoticeProto& _internal_data_origin_notice() const;
  ::autofill_assistant::DataOriginNoticeProto* _internal_mutable_data_origin_notice();
  public:
  void unsafe_arena_set_allocated_data_origin_notice(
      ::autofill_assistant::DataOriginNoticeProto* data_origin_notice);
  ::autofill_assistant::DataOriginNoticeProto* unsafe_arena_release_data_origin_notice();

  // optional .autofill_assistant.CollectUserDataProto.TermsAndConditionsState terms_and_conditions_state = 8;
  bool has_terms_and_conditions_state() const;
  private:
  bool _internal_has_terms_and_conditions_state() const;
  public:
  void clear_terms_and_conditions_state();
  ::autofill_assistant::CollectUserDataProto_TermsAndConditionsState terms_and_conditions_state() const;
  void set_terms_and_conditions_state(::autofill_assistant::CollectUserDataProto_TermsAndConditionsState value);
  private:
  ::autofill_assistant::CollectUserDataProto_TermsAndConditionsState _internal_terms_and_conditions_state() const;
  void _internal_set_terms_and_conditions_state(::autofill_assistant::CollectUserDataProto_TermsAndConditionsState value);
  public:

  // optional bool request_payment_method = 4;
  bool has_request_payment_method() const;
  private:
  bool _internal_has_request_payment_method() const;
  public:
  void clear_request_payment_method();
  bool request_payment_method() const;
  void set_request_payment_method(bool value);
  private:
  bool _internal_request_payment_method() const;
  void _internal_set_request_payment_method(bool value);
  public:

  // optional bool show_terms_as_checkbox = 12;
  bool has_show_terms_as_checkbox() const;
  private:
  bool _internal_has_show_terms_as_checkbox() const;
  public:
  void clear_show_terms_as_checkbox();
  bool show_terms_as_checkbox() const;
  void set_show_terms_as_checkbox(bool value);
  private:
  bool _internal_show_terms_as_checkbox() const;
  void _internal_set_show_terms_as_checkbox(bool value);
  public:

  // optional bool info_section_text_center = 31;
  bool has_info_section_text_center() const;
  private:
  bool _internal_has_info_section_text_center() const;
  public:
  void clear_info_section_text_center();
  bool info_section_text_center() const;
  void set_info_section_text_center(bool value);
  private:
  bool _internal_info_section_text_center() const;
  void _internal_set_info_section_text_center(bool value);
  public:

  // optional bool clear_previous_credit_card_selection = 28;
  bool has_clear_previous_credit_card_selection() const;
  private:
  bool _internal_has_clear_previous_credit_card_selection() const;
  public:
  void clear_clear_previous_credit_card_selection();
  bool clear_previous_credit_card_selection() const;
  void set_clear_previous_credit_card_selection(bool value);
  private:
  bool _internal_clear_previous_credit_card_selection() const;
  void _internal_set_clear_previous_credit_card_selection(bool value);
  public:

  // optional bool clear_previous_login_selection = 29;
  bool has_clear_previous_login_selection() const;
  private:
  bool _internal_has_clear_previous_login_selection() const;
  public:
  void clear_clear_previous_login_selection();
  bool clear_previous_login_selection() const;
  void set_clear_previous_login_selection(bool value);
  private:
  bool _internal_clear_previous_login_selection() const;
  void _internal_set_clear_previous_login_selection(bool value);
  public:

  // optional bool request_terms_and_conditions = 9 [default = true];
  bool has_request_terms_and_conditions() const;
  private:
  bool _internal_has_request_terms_and_conditions() const;
  public:
  void clear_request_terms_and_conditions();
  bool request_terms_and_conditions() const;
  void set_request_terms_and_conditions(bool value);
  private:
  bool _internal_request_terms_and_conditions() const;
  void _internal_set_request_terms_and_conditions(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CollectUserDataProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_basic_card_networks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto > additional_actions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto > additional_prepended_sections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto > additional_appended_sections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> clear_previous_profile_selection_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece > required_shipping_address_data_piece_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece > required_credit_card_data_piece_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece > required_billing_address_data_piece_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prompt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr billing_address_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shipping_address_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accept_terms_and_conditions_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terms_require_review_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privacy_notice_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credit_card_expired_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_section_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr additional_model_identifier_to_check_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shipping_address_section_title_;
  ::autofill_assistant::ContactDetailsProto* contact_details_;
  ::autofill_assistant::LoginDetailsProto* login_details_;
  ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_prepended_;
  ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_appended_;
  ::autofill_assistant::ChipProto* confirm_chip_;
  ::autofill_assistant::CollectUserDataProto_DataSource* data_source_;
  ::autofill_assistant::DataOriginNoticeProto* data_origin_notice_;
  int terms_and_conditions_state_;
  bool request_payment_method_;
  bool show_terms_as_checkbox_;
  bool info_section_text_center_;
  bool clear_previous_credit_card_selection_;
  bool clear_previous_login_selection_;
  bool request_terms_and_conditions_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class StopProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.StopProto) */ {
 public:
  inline StopProto() : StopProto(nullptr) {}
  ~StopProto() override;
  explicit PROTOBUF_CONSTEXPR StopProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopProto(const StopProto& from);
  StopProto(StopProto&& from) noexcept
    : StopProto() {
    *this = ::std::move(from);
  }

  inline StopProto& operator=(const StopProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopProto& operator=(StopProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StopProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopProto* internal_default_instance() {
    return reinterpret_cast<const StopProto*>(
               &_StopProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    135;

  friend void swap(StopProto& a, StopProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StopProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StopProto& from);
  void MergeFrom(const StopProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.StopProto";
  }
  protected:
  explicit StopProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCloseCctFieldNumber = 2,
    kShowFeedbackChipFieldNumber = 3,
  };
  // optional bool close_cct = 2;
  bool has_close_cct() const;
  private:
  bool _internal_has_close_cct() const;
  public:
  void clear_close_cct();
  bool close_cct() const;
  void set_close_cct(bool value);
  private:
  bool _internal_close_cct() const;
  void _internal_set_close_cct(bool value);
  public:

  // optional bool show_feedback_chip = 3;
  bool has_show_feedback_chip() const;
  private:
  bool _internal_has_show_feedback_chip() const;
  public:
  void clear_show_feedback_chip();
  bool show_feedback_chip() const;
  void set_show_feedback_chip(bool value);
  private:
  bool _internal_show_feedback_chip() const;
  void _internal_set_show_feedback_chip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.StopProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool close_cct_;
  bool show_feedback_chip_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DetailsChangesProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DetailsChangesProto) */ {
 public:
  inline DetailsChangesProto() : DetailsChangesProto(nullptr) {}
  ~DetailsChangesProto() override;
  explicit PROTOBUF_CONSTEXPR DetailsChangesProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailsChangesProto(const DetailsChangesProto& from);
  DetailsChangesProto(DetailsChangesProto&& from) noexcept
    : DetailsChangesProto() {
    *this = ::std::move(from);
  }

  inline DetailsChangesProto& operator=(const DetailsChangesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailsChangesProto& operator=(DetailsChangesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DetailsChangesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailsChangesProto* internal_default_instance() {
    return reinterpret_cast<const DetailsChangesProto*>(
               &_DetailsChangesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    136;

  friend void swap(DetailsChangesProto& a, DetailsChangesProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DetailsChangesProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailsChangesProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailsChangesProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailsChangesProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DetailsChangesProto& from);
  void MergeFrom(const DetailsChangesProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetailsChangesProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DetailsChangesProto";
  }
  protected:
  explicit DetailsChangesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserApprovalRequiredFieldNumber = 1,
    kHighlightTitleFieldNumber = 2,
    kHighlightLine1FieldNumber = 3,
    kHighlightLine2FieldNumber = 4,
    kHighlightLine3FieldNumber = 5,
  };
  // optional bool user_approval_required = 1;
  bool has_user_approval_required() const;
  private:
  bool _internal_has_user_approval_required() const;
  public:
  void clear_user_approval_required();
  bool user_approval_required() const;
  void set_user_approval_required(bool value);
  private:
  bool _internal_user_approval_required() const;
  void _internal_set_user_approval_required(bool value);
  public:

  // optional bool highlight_title = 2;
  bool has_highlight_title() const;
  private:
  bool _internal_has_highlight_title() const;
  public:
  void clear_highlight_title();
  bool highlight_title() const;
  void set_highlight_title(bool value);
  private:
  bool _internal_highlight_title() const;
  void _internal_set_highlight_title(bool value);
  public:

  // optional bool highlight_line1 = 3;
  bool has_highlight_line1() const;
  private:
  bool _internal_has_highlight_line1() const;
  public:
  void clear_highlight_line1();
  bool highlight_line1() const;
  void set_highlight_line1(bool value);
  private:
  bool _internal_highlight_line1() const;
  void _internal_set_highlight_line1(bool value);
  public:

  // optional bool highlight_line2 = 4;
  bool has_highlight_line2() const;
  private:
  bool _internal_has_highlight_line2() const;
  public:
  void clear_highlight_line2();
  bool highlight_line2() const;
  void set_highlight_line2(bool value);
  private:
  bool _internal_highlight_line2() const;
  void _internal_set_highlight_line2(bool value);
  public:

  // optional bool highlight_line3 = 5;
  bool has_highlight_line3() const;
  private:
  bool _internal_has_highlight_line3() const;
  public:
  void clear_highlight_line3();
  bool highlight_line3() const;
  void set_highlight_line3(bool value);
  private:
  bool _internal_highlight_line3() const;
  void _internal_set_highlight_line3(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DetailsChangesProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool user_approval_required_;
  bool highlight_title_;
  bool highlight_line1_;
  bool highlight_line2_;
  bool highlight_line3_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DetailsProto_ImageClickthroughData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DetailsProto.ImageClickthroughData) */ {
 public:
  inline DetailsProto_ImageClickthroughData() : DetailsProto_ImageClickthroughData(nullptr) {}
  ~DetailsProto_ImageClickthroughData() override;
  explicit PROTOBUF_CONSTEXPR DetailsProto_ImageClickthroughData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailsProto_ImageClickthroughData(const DetailsProto_ImageClickthroughData& from);
  DetailsProto_ImageClickthroughData(DetailsProto_ImageClickthroughData&& from) noexcept
    : DetailsProto_ImageClickthroughData() {
    *this = ::std::move(from);
  }

  inline DetailsProto_ImageClickthroughData& operator=(const DetailsProto_ImageClickthroughData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailsProto_ImageClickthroughData& operator=(DetailsProto_ImageClickthroughData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DetailsProto_ImageClickthroughData& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailsProto_ImageClickthroughData* internal_default_instance() {
    return reinterpret_cast<const DetailsProto_ImageClickthroughData*>(
               &_DetailsProto_ImageClickthroughData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    137;

  friend void swap(DetailsProto_ImageClickthroughData& a, DetailsProto_ImageClickthroughData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DetailsProto_ImageClickthroughData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailsProto_ImageClickthroughData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailsProto_ImageClickthroughData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailsProto_ImageClickthroughData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DetailsProto_ImageClickthroughData& from);
  void MergeFrom(const DetailsProto_ImageClickthroughData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetailsProto_ImageClickthroughData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DetailsProto.ImageClickthroughData";
  }
  protected:
  explicit DetailsProto_ImageClickthroughData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kPositiveTextFieldNumber = 3,
    kNegativeTextFieldNumber = 4,
    kClickthroughUrlFieldNumber = 5,
    kAllowClickthroughFieldNumber = 1,
  };
  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string positive_text = 3;
  bool has_positive_text() const;
  private:
  bool _internal_has_positive_text() const;
  public:
  void clear_positive_text();
  const std::string& positive_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_positive_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_positive_text();
  PROTOBUF_NODISCARD std::string* release_positive_text();
  void set_allocated_positive_text(std::string* positive_text);
  private:
  const std::string& _internal_positive_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_positive_text(const std::string& value);
  std::string* _internal_mutable_positive_text();
  public:

  // optional string negative_text = 4;
  bool has_negative_text() const;
  private:
  bool _internal_has_negative_text() const;
  public:
  void clear_negative_text();
  const std::string& negative_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_negative_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_negative_text();
  PROTOBUF_NODISCARD std::string* release_negative_text();
  void set_allocated_negative_text(std::string* negative_text);
  private:
  const std::string& _internal_negative_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_negative_text(const std::string& value);
  std::string* _internal_mutable_negative_text();
  public:

  // optional string clickthrough_url = 5;
  bool has_clickthrough_url() const;
  private:
  bool _internal_has_clickthrough_url() const;
  public:
  void clear_clickthrough_url();
  const std::string& clickthrough_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clickthrough_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clickthrough_url();
  PROTOBUF_NODISCARD std::string* release_clickthrough_url();
  void set_allocated_clickthrough_url(std::string* clickthrough_url);
  private:
  const std::string& _internal_clickthrough_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clickthrough_url(const std::string& value);
  std::string* _internal_mutable_clickthrough_url();
  public:

  // optional bool allow_clickthrough = 1;
  bool has_allow_clickthrough() const;
  private:
  bool _internal_has_allow_clickthrough() const;
  public:
  void clear_allow_clickthrough();
  bool allow_clickthrough() const;
  void set_allow_clickthrough(bool value);
  private:
  bool _internal_allow_clickthrough() const;
  void _internal_set_allow_clickthrough(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DetailsProto.ImageClickthroughData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr positive_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr negative_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clickthrough_url_;
  bool allow_clickthrough_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DetailsProto_PlaceholdersConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DetailsProto.PlaceholdersConfiguration) */ {
 public:
  inline DetailsProto_PlaceholdersConfiguration() : DetailsProto_PlaceholdersConfiguration(nullptr) {}
  ~DetailsProto_PlaceholdersConfiguration() override;
  explicit PROTOBUF_CONSTEXPR DetailsProto_PlaceholdersConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailsProto_PlaceholdersConfiguration(const DetailsProto_PlaceholdersConfiguration& from);
  DetailsProto_PlaceholdersConfiguration(DetailsProto_PlaceholdersConfiguration&& from) noexcept
    : DetailsProto_PlaceholdersConfiguration() {
    *this = ::std::move(from);
  }

  inline DetailsProto_PlaceholdersConfiguration& operator=(const DetailsProto_PlaceholdersConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailsProto_PlaceholdersConfiguration& operator=(DetailsProto_PlaceholdersConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DetailsProto_PlaceholdersConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailsProto_PlaceholdersConfiguration* internal_default_instance() {
    return reinterpret_cast<const DetailsProto_PlaceholdersConfiguration*>(
               &_DetailsProto_PlaceholdersConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    138;

  friend void swap(DetailsProto_PlaceholdersConfiguration& a, DetailsProto_PlaceholdersConfiguration& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DetailsProto_PlaceholdersConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailsProto_PlaceholdersConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailsProto_PlaceholdersConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailsProto_PlaceholdersConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DetailsProto_PlaceholdersConfiguration& from);
  void MergeFrom(const DetailsProto_PlaceholdersConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetailsProto_PlaceholdersConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DetailsProto.PlaceholdersConfiguration";
  }
  protected:
  explicit DetailsProto_PlaceholdersConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShowImagePlaceholderFieldNumber = 1,
    kShowTitlePlaceholderFieldNumber = 2,
    kShowDescriptionLine1PlaceholderFieldNumber = 3,
    kShowDescriptionLine2PlaceholderFieldNumber = 4,
    kShowDescriptionLine3PlaceholderFieldNumber = 5,
  };
  // optional bool show_image_placeholder = 1;
  bool has_show_image_placeholder() const;
  private:
  bool _internal_has_show_image_placeholder() const;
  public:
  void clear_show_image_placeholder();
  bool show_image_placeholder() const;
  void set_show_image_placeholder(bool value);
  private:
  bool _internal_show_image_placeholder() const;
  void _internal_set_show_image_placeholder(bool value);
  public:

  // optional bool show_title_placeholder = 2;
  bool has_show_title_placeholder() const;
  private:
  bool _internal_has_show_title_placeholder() const;
  public:
  void clear_show_title_placeholder();
  bool show_title_placeholder() const;
  void set_show_title_placeholder(bool value);
  private:
  bool _internal_show_title_placeholder() const;
  void _internal_set_show_title_placeholder(bool value);
  public:

  // optional bool show_description_line_1_placeholder = 3;
  bool has_show_description_line_1_placeholder() const;
  private:
  bool _internal_has_show_description_line_1_placeholder() const;
  public:
  void clear_show_description_line_1_placeholder();
  bool show_description_line_1_placeholder() const;
  void set_show_description_line_1_placeholder(bool value);
  private:
  bool _internal_show_description_line_1_placeholder() const;
  void _internal_set_show_description_line_1_placeholder(bool value);
  public:

  // optional bool show_description_line_2_placeholder = 4;
  bool has_show_description_line_2_placeholder() const;
  private:
  bool _internal_has_show_description_line_2_placeholder() const;
  public:
  void clear_show_description_line_2_placeholder();
  bool show_description_line_2_placeholder() const;
  void set_show_description_line_2_placeholder(bool value);
  private:
  bool _internal_show_description_line_2_placeholder() const;
  void _internal_set_show_description_line_2_placeholder(bool value);
  public:

  // optional bool show_description_line_3_placeholder = 5;
  bool has_show_description_line_3_placeholder() const;
  private:
  bool _internal_has_show_description_line_3_placeholder() const;
  public:
  void clear_show_description_line_3_placeholder();
  bool show_description_line_3_placeholder() const;
  void set_show_description_line_3_placeholder(bool value);
  private:
  bool _internal_show_description_line_3_placeholder() const;
  void _internal_set_show_description_line_3_placeholder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool show_image_placeholder_;
  bool show_title_placeholder_;
  bool show_description_line_1_placeholder_;
  bool show_description_line_2_placeholder_;
  bool show_description_line_3_placeholder_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DetailsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DetailsProto) */ {
 public:
  inline DetailsProto() : DetailsProto(nullptr) {}
  ~DetailsProto() override;
  explicit PROTOBUF_CONSTEXPR DetailsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailsProto(const DetailsProto& from);
  DetailsProto(DetailsProto&& from) noexcept
    : DetailsProto() {
    *this = ::std::move(from);
  }

  inline DetailsProto& operator=(const DetailsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailsProto& operator=(DetailsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DetailsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailsProto* internal_default_instance() {
    return reinterpret_cast<const DetailsProto*>(
               &_DetailsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    139;

  friend void swap(DetailsProto& a, DetailsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DetailsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DetailsProto& from);
  void MergeFrom(const DetailsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetailsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DetailsProto";
  }
  protected:
  explicit DetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DetailsProto_ImageClickthroughData ImageClickthroughData;
  typedef DetailsProto_PlaceholdersConfiguration PlaceholdersConfiguration;

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kImageUrlFieldNumber = 2,
    kDescriptionFieldNumber = 4,
    kTotalPriceFieldNumber = 6,
    kDescriptionLine1FieldNumber = 7,
    kDescriptionLine2FieldNumber = 8,
    kTotalPriceLabelFieldNumber = 9,
    kDescriptionLine3FieldNumber = 13,
    kImageAccessibilityHintFieldNumber = 14,
    kDatetimeFieldNumber = 3,
    kImageClickthroughDataFieldNumber = 12,
    kPlaceholdersFieldNumber = 15,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string image_url = 2;
  bool has_image_url() const;
  private:
  bool _internal_has_image_url() const;
  public:
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string total_price = 6;
  bool has_total_price() const;
  private:
  bool _internal_has_total_price() const;
  public:
  void clear_total_price();
  const std::string& total_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_total_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_total_price();
  PROTOBUF_NODISCARD std::string* release_total_price();
  void set_allocated_total_price(std::string* total_price);
  private:
  const std::string& _internal_total_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_price(const std::string& value);
  std::string* _internal_mutable_total_price();
  public:

  // optional string description_line_1 = 7;
  bool has_description_line_1() const;
  private:
  bool _internal_has_description_line_1() const;
  public:
  void clear_description_line_1();
  const std::string& description_line_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_1();
  PROTOBUF_NODISCARD std::string* release_description_line_1();
  void set_allocated_description_line_1(std::string* description_line_1);
  private:
  const std::string& _internal_description_line_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_1(const std::string& value);
  std::string* _internal_mutable_description_line_1();
  public:

  // optional string description_line_2 = 8;
  bool has_description_line_2() const;
  private:
  bool _internal_has_description_line_2() const;
  public:
  void clear_description_line_2();
  const std::string& description_line_2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_2();
  PROTOBUF_NODISCARD std::string* release_description_line_2();
  void set_allocated_description_line_2(std::string* description_line_2);
  private:
  const std::string& _internal_description_line_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_2(const std::string& value);
  std::string* _internal_mutable_description_line_2();
  public:

  // optional string total_price_label = 9;
  bool has_total_price_label() const;
  private:
  bool _internal_has_total_price_label() const;
  public:
  void clear_total_price_label();
  const std::string& total_price_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_total_price_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_total_price_label();
  PROTOBUF_NODISCARD std::string* release_total_price_label();
  void set_allocated_total_price_label(std::string* total_price_label);
  private:
  const std::string& _internal_total_price_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_price_label(const std::string& value);
  std::string* _internal_mutable_total_price_label();
  public:

  // optional string description_line_3 = 13;
  bool has_description_line_3() const;
  private:
  bool _internal_has_description_line_3() const;
  public:
  void clear_description_line_3();
  const std::string& description_line_3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_3();
  PROTOBUF_NODISCARD std::string* release_description_line_3();
  void set_allocated_description_line_3(std::string* description_line_3);
  private:
  const std::string& _internal_description_line_3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_3(const std::string& value);
  std::string* _internal_mutable_description_line_3();
  public:

  // optional string image_accessibility_hint = 14;
  bool has_image_accessibility_hint() const;
  private:
  bool _internal_has_image_accessibility_hint() const;
  public:
  void clear_image_accessibility_hint();
  const std::string& image_accessibility_hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_accessibility_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_accessibility_hint();
  PROTOBUF_NODISCARD std::string* release_image_accessibility_hint();
  void set_allocated_image_accessibility_hint(std::string* image_accessibility_hint);
  private:
  const std::string& _internal_image_accessibility_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_accessibility_hint(const std::string& value);
  std::string* _internal_mutable_image_accessibility_hint();
  public:

  // optional .autofill_assistant.DateTimeProto datetime = 3;
  bool has_datetime() const;
  private:
  bool _internal_has_datetime() const;
  public:
  void clear_datetime();
  const ::autofill_assistant::DateTimeProto& datetime() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DateTimeProto* release_datetime();
  ::autofill_assistant::DateTimeProto* mutable_datetime();
  void set_allocated_datetime(::autofill_assistant::DateTimeProto* datetime);
  private:
  const ::autofill_assistant::DateTimeProto& _internal_datetime() const;
  ::autofill_assistant::DateTimeProto* _internal_mutable_datetime();
  public:
  void unsafe_arena_set_allocated_datetime(
      ::autofill_assistant::DateTimeProto* datetime);
  ::autofill_assistant::DateTimeProto* unsafe_arena_release_datetime();

  // optional .autofill_assistant.DetailsProto.ImageClickthroughData image_clickthrough_data = 12;
  bool has_image_clickthrough_data() const;
  private:
  bool _internal_has_image_clickthrough_data() const;
  public:
  void clear_image_clickthrough_data();
  const ::autofill_assistant::DetailsProto_ImageClickthroughData& image_clickthrough_data() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DetailsProto_ImageClickthroughData* release_image_clickthrough_data();
  ::autofill_assistant::DetailsProto_ImageClickthroughData* mutable_image_clickthrough_data();
  void set_allocated_image_clickthrough_data(::autofill_assistant::DetailsProto_ImageClickthroughData* image_clickthrough_data);
  private:
  const ::autofill_assistant::DetailsProto_ImageClickthroughData& _internal_image_clickthrough_data() const;
  ::autofill_assistant::DetailsProto_ImageClickthroughData* _internal_mutable_image_clickthrough_data();
  public:
  void unsafe_arena_set_allocated_image_clickthrough_data(
      ::autofill_assistant::DetailsProto_ImageClickthroughData* image_clickthrough_data);
  ::autofill_assistant::DetailsProto_ImageClickthroughData* unsafe_arena_release_image_clickthrough_data();

  // optional .autofill_assistant.DetailsProto.PlaceholdersConfiguration placeholders = 15;
  bool has_placeholders() const;
  private:
  bool _internal_has_placeholders() const;
  public:
  void clear_placeholders();
  const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration& placeholders() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* release_placeholders();
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* mutable_placeholders();
  void set_allocated_placeholders(::autofill_assistant::DetailsProto_PlaceholdersConfiguration* placeholders);
  private:
  const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration& _internal_placeholders() const;
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* _internal_mutable_placeholders();
  public:
  void unsafe_arena_set_allocated_placeholders(
      ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* placeholders);
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* unsafe_arena_release_placeholders();

  // @@protoc_insertion_point(class_scope:autofill_assistant.DetailsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_price_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_price_label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_3_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_accessibility_hint_;
  ::autofill_assistant::DateTimeProto* datetime_;
  ::autofill_assistant::DetailsProto_ImageClickthroughData* image_clickthrough_data_;
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* placeholders_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowDetailsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowDetailsProto) */ {
 public:
  inline ShowDetailsProto() : ShowDetailsProto(nullptr) {}
  ~ShowDetailsProto() override;
  explicit PROTOBUF_CONSTEXPR ShowDetailsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowDetailsProto(const ShowDetailsProto& from);
  ShowDetailsProto(ShowDetailsProto&& from) noexcept
    : ShowDetailsProto() {
    *this = ::std::move(from);
  }

  inline ShowDetailsProto& operator=(const ShowDetailsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowDetailsProto& operator=(ShowDetailsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowDetailsProto& default_instance() {
    return *internal_default_instance();
  }
  enum DataToShowCase {
    kDetails = 1,
    kContactDetails = 3,
    kCreditCard = 4,
    kShippingAddress = 5,
    DATA_TO_SHOW_NOT_SET = 0,
  };

  static inline const ShowDetailsProto* internal_default_instance() {
    return reinterpret_cast<const ShowDetailsProto*>(
               &_ShowDetailsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    140;

  friend void swap(ShowDetailsProto& a, ShowDetailsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowDetailsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowDetailsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowDetailsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowDetailsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowDetailsProto& from);
  void MergeFrom(const ShowDetailsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowDetailsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowDetailsProto";
  }
  protected:
  explicit ShowDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeFlagsFieldNumber = 2,
    kAppendFieldNumber = 6,
    kDelayMsFieldNumber = 7,
    kDetailsFieldNumber = 1,
    kContactDetailsFieldNumber = 3,
    kCreditCardFieldNumber = 4,
    kShippingAddressFieldNumber = 5,
  };
  // optional .autofill_assistant.DetailsChangesProto change_flags = 2;
  bool has_change_flags() const;
  private:
  bool _internal_has_change_flags() const;
  public:
  void clear_change_flags();
  const ::autofill_assistant::DetailsChangesProto& change_flags() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DetailsChangesProto* release_change_flags();
  ::autofill_assistant::DetailsChangesProto* mutable_change_flags();
  void set_allocated_change_flags(::autofill_assistant::DetailsChangesProto* change_flags);
  private:
  const ::autofill_assistant::DetailsChangesProto& _internal_change_flags() const;
  ::autofill_assistant::DetailsChangesProto* _internal_mutable_change_flags();
  public:
  void unsafe_arena_set_allocated_change_flags(
      ::autofill_assistant::DetailsChangesProto* change_flags);
  ::autofill_assistant::DetailsChangesProto* unsafe_arena_release_change_flags();

  // optional bool append = 6;
  bool has_append() const;
  private:
  bool _internal_has_append() const;
  public:
  void clear_append();
  bool append() const;
  void set_append(bool value);
  private:
  bool _internal_append() const;
  void _internal_set_append(bool value);
  public:

  // optional int32 delay_ms = 7;
  bool has_delay_ms() const;
  private:
  bool _internal_has_delay_ms() const;
  public:
  void clear_delay_ms();
  int32_t delay_ms() const;
  void set_delay_ms(int32_t value);
  private:
  int32_t _internal_delay_ms() const;
  void _internal_set_delay_ms(int32_t value);
  public:

  // .autofill_assistant.DetailsProto details = 1;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::autofill_assistant::DetailsProto& details() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DetailsProto* release_details();
  ::autofill_assistant::DetailsProto* mutable_details();
  void set_allocated_details(::autofill_assistant::DetailsProto* details);
  private:
  const ::autofill_assistant::DetailsProto& _internal_details() const;
  ::autofill_assistant::DetailsProto* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::autofill_assistant::DetailsProto* details);
  ::autofill_assistant::DetailsProto* unsafe_arena_release_details();

  // string contact_details = 3;
  bool has_contact_details() const;
  private:
  bool _internal_has_contact_details() const;
  public:
  void clear_contact_details();
  const std::string& contact_details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_details();
  PROTOBUF_NODISCARD std::string* release_contact_details();
  void set_allocated_contact_details(std::string* contact_details);
  private:
  const std::string& _internal_contact_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_details(const std::string& value);
  std::string* _internal_mutable_contact_details();
  public:

  // bool credit_card = 4;
  bool has_credit_card() const;
  private:
  bool _internal_has_credit_card() const;
  public:
  void clear_credit_card();
  bool credit_card() const;
  void set_credit_card(bool value);
  private:
  bool _internal_credit_card() const;
  void _internal_set_credit_card(bool value);
  public:

  // string shipping_address = 5;
  bool has_shipping_address() const;
  private:
  bool _internal_has_shipping_address() const;
  public:
  void clear_shipping_address();
  const std::string& shipping_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shipping_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shipping_address();
  PROTOBUF_NODISCARD std::string* release_shipping_address();
  void set_allocated_shipping_address(std::string* shipping_address);
  private:
  const std::string& _internal_shipping_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shipping_address(const std::string& value);
  std::string* _internal_mutable_shipping_address();
  public:

  void clear_data_to_show();
  DataToShowCase data_to_show_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowDetailsProto)
 private:
  class _Internal;
  void set_has_details();
  void set_has_contact_details();
  void set_has_credit_card();
  void set_has_shipping_address();

  inline bool has_data_to_show() const;
  inline void clear_has_data_to_show();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::DetailsChangesProto* change_flags_;
  bool append_;
  int32_t delay_ms_;
  union DataToShowUnion {
    constexpr DataToShowUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::DetailsProto* details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_details_;
    bool credit_card_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shipping_address_;
  } data_to_show_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GeneratePasswordForFormFieldProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GeneratePasswordForFormFieldProto) */ {
 public:
  inline GeneratePasswordForFormFieldProto() : GeneratePasswordForFormFieldProto(nullptr) {}
  ~GeneratePasswordForFormFieldProto() override;
  explicit PROTOBUF_CONSTEXPR GeneratePasswordForFormFieldProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeneratePasswordForFormFieldProto(const GeneratePasswordForFormFieldProto& from);
  GeneratePasswordForFormFieldProto(GeneratePasswordForFormFieldProto&& from) noexcept
    : GeneratePasswordForFormFieldProto() {
    *this = ::std::move(from);
  }

  inline GeneratePasswordForFormFieldProto& operator=(const GeneratePasswordForFormFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneratePasswordForFormFieldProto& operator=(GeneratePasswordForFormFieldProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GeneratePasswordForFormFieldProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeneratePasswordForFormFieldProto* internal_default_instance() {
    return reinterpret_cast<const GeneratePasswordForFormFieldProto*>(
               &_GeneratePasswordForFormFieldProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    141;

  friend void swap(GeneratePasswordForFormFieldProto& a, GeneratePasswordForFormFieldProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GeneratePasswordForFormFieldProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneratePasswordForFormFieldProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeneratePasswordForFormFieldProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeneratePasswordForFormFieldProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GeneratePasswordForFormFieldProto& from);
  void MergeFrom(const GeneratePasswordForFormFieldProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GeneratePasswordForFormFieldProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GeneratePasswordForFormFieldProto";
  }
  protected:
  explicit GeneratePasswordForFormFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryKeyFieldNumber = 2,
    kElementFieldNumber = 1,
  };
  // optional string memory_key = 2;
  bool has_memory_key() const;
  private:
  bool _internal_has_memory_key() const;
  public:
  void clear_memory_key();
  const std::string& memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_key();
  PROTOBUF_NODISCARD std::string* release_memory_key();
  void set_allocated_memory_key(std::string* memory_key);
  private:
  const std::string& _internal_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_key(const std::string& value);
  std::string* _internal_mutable_memory_key();
  public:

  // optional .autofill_assistant.SelectorProto element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::autofill_assistant::SelectorProto& element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_element();
  ::autofill_assistant::SelectorProto* mutable_element();
  void set_allocated_element(::autofill_assistant::SelectorProto* element);
  private:
  const ::autofill_assistant::SelectorProto& _internal_element() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::autofill_assistant::SelectorProto* element);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_element();

  // @@protoc_insertion_point(class_scope:autofill_assistant.GeneratePasswordForFormFieldProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_key_;
  ::autofill_assistant::SelectorProto* element_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PresaveGeneratedPasswordProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PresaveGeneratedPasswordProto) */ {
 public:
  inline PresaveGeneratedPasswordProto() : PresaveGeneratedPasswordProto(nullptr) {}
  ~PresaveGeneratedPasswordProto() override;
  explicit PROTOBUF_CONSTEXPR PresaveGeneratedPasswordProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PresaveGeneratedPasswordProto(const PresaveGeneratedPasswordProto& from);
  PresaveGeneratedPasswordProto(PresaveGeneratedPasswordProto&& from) noexcept
    : PresaveGeneratedPasswordProto() {
    *this = ::std::move(from);
  }

  inline PresaveGeneratedPasswordProto& operator=(const PresaveGeneratedPasswordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresaveGeneratedPasswordProto& operator=(PresaveGeneratedPasswordProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PresaveGeneratedPasswordProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresaveGeneratedPasswordProto* internal_default_instance() {
    return reinterpret_cast<const PresaveGeneratedPasswordProto*>(
               &_PresaveGeneratedPasswordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    142;

  friend void swap(PresaveGeneratedPasswordProto& a, PresaveGeneratedPasswordProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PresaveGeneratedPasswordProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresaveGeneratedPasswordProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PresaveGeneratedPasswordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PresaveGeneratedPasswordProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PresaveGeneratedPasswordProto& from);
  void MergeFrom(const PresaveGeneratedPasswordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PresaveGeneratedPasswordProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PresaveGeneratedPasswordProto";
  }
  protected:
  explicit PresaveGeneratedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryKeyFieldNumber = 1,
  };
  // optional string memory_key = 1;
  bool has_memory_key() const;
  private:
  bool _internal_has_memory_key() const;
  public:
  void clear_memory_key();
  const std::string& memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_key();
  PROTOBUF_NODISCARD std::string* release_memory_key();
  void set_allocated_memory_key(std::string* memory_key);
  private:
  const std::string& _internal_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_key(const std::string& value);
  std::string* _internal_mutable_memory_key();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PresaveGeneratedPasswordProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_key_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SaveGeneratedPasswordProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SaveGeneratedPasswordProto) */ {
 public:
  inline SaveGeneratedPasswordProto() : SaveGeneratedPasswordProto(nullptr) {}
  ~SaveGeneratedPasswordProto() override;
  explicit PROTOBUF_CONSTEXPR SaveGeneratedPasswordProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveGeneratedPasswordProto(const SaveGeneratedPasswordProto& from);
  SaveGeneratedPasswordProto(SaveGeneratedPasswordProto&& from) noexcept
    : SaveGeneratedPasswordProto() {
    *this = ::std::move(from);
  }

  inline SaveGeneratedPasswordProto& operator=(const SaveGeneratedPasswordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveGeneratedPasswordProto& operator=(SaveGeneratedPasswordProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SaveGeneratedPasswordProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveGeneratedPasswordProto* internal_default_instance() {
    return reinterpret_cast<const SaveGeneratedPasswordProto*>(
               &_SaveGeneratedPasswordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    143;

  friend void swap(SaveGeneratedPasswordProto& a, SaveGeneratedPasswordProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SaveGeneratedPasswordProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveGeneratedPasswordProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveGeneratedPasswordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveGeneratedPasswordProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SaveGeneratedPasswordProto& from);
  void MergeFrom(const SaveGeneratedPasswordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveGeneratedPasswordProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SaveGeneratedPasswordProto";
  }
  protected:
  explicit SaveGeneratedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryKeyFieldNumber = 1,
  };
  // optional string memory_key = 1;
  bool has_memory_key() const;
  private:
  bool _internal_has_memory_key() const;
  public:
  void clear_memory_key();
  const std::string& memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_key();
  PROTOBUF_NODISCARD std::string* release_memory_key();
  void set_allocated_memory_key(std::string* memory_key);
  private:
  const std::string& _internal_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_key(const std::string& value);
  std::string* _internal_mutable_memory_key();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SaveGeneratedPasswordProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_key_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteSelectedPasswordProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DeleteSelectedPasswordProto) */ {
 public:
  inline DeleteSelectedPasswordProto() : DeleteSelectedPasswordProto(nullptr) {}
  ~DeleteSelectedPasswordProto() override;
  explicit PROTOBUF_CONSTEXPR DeleteSelectedPasswordProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSelectedPasswordProto(const DeleteSelectedPasswordProto& from);
  DeleteSelectedPasswordProto(DeleteSelectedPasswordProto&& from) noexcept
    : DeleteSelectedPasswordProto() {
    *this = ::std::move(from);
  }

  inline DeleteSelectedPasswordProto& operator=(const DeleteSelectedPasswordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSelectedPasswordProto& operator=(DeleteSelectedPasswordProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeleteSelectedPasswordProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSelectedPasswordProto* internal_default_instance() {
    return reinterpret_cast<const DeleteSelectedPasswordProto*>(
               &_DeleteSelectedPasswordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    144;

  friend void swap(DeleteSelectedPasswordProto& a, DeleteSelectedPasswordProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DeleteSelectedPasswordProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSelectedPasswordProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSelectedPasswordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSelectedPasswordProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeleteSelectedPasswordProto& from);
  void MergeFrom(const DeleteSelectedPasswordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteSelectedPasswordProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DeleteSelectedPasswordProto";
  }
  protected:
  explicit DeleteSelectedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.DeleteSelectedPasswordProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class EditSelectedPasswordProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.EditSelectedPasswordProto) */ {
 public:
  inline EditSelectedPasswordProto() : EditSelectedPasswordProto(nullptr) {}
  ~EditSelectedPasswordProto() override;
  explicit PROTOBUF_CONSTEXPR EditSelectedPasswordProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditSelectedPasswordProto(const EditSelectedPasswordProto& from);
  EditSelectedPasswordProto(EditSelectedPasswordProto&& from) noexcept
    : EditSelectedPasswordProto() {
    *this = ::std::move(from);
  }

  inline EditSelectedPasswordProto& operator=(const EditSelectedPasswordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditSelectedPasswordProto& operator=(EditSelectedPasswordProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EditSelectedPasswordProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditSelectedPasswordProto* internal_default_instance() {
    return reinterpret_cast<const EditSelectedPasswordProto*>(
               &_EditSelectedPasswordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    145;

  friend void swap(EditSelectedPasswordProto& a, EditSelectedPasswordProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EditSelectedPasswordProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditSelectedPasswordProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditSelectedPasswordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditSelectedPasswordProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EditSelectedPasswordProto& from);
  void MergeFrom(const EditSelectedPasswordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EditSelectedPasswordProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.EditSelectedPasswordProto";
  }
  protected:
  explicit EditSelectedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryKeyFieldNumber = 1,
  };
  // optional string memory_key = 1;
  bool has_memory_key() const;
  private:
  bool _internal_has_memory_key() const;
  public:
  void clear_memory_key();
  const std::string& memory_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memory_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memory_key();
  PROTOBUF_NODISCARD std::string* release_memory_key();
  void set_allocated_memory_key(std::string* memory_key);
  private:
  const std::string& _internal_memory_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memory_key(const std::string& value);
  std::string* _internal_mutable_memory_key();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.EditSelectedPasswordProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memory_key_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ResetPendingCredentialsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ResetPendingCredentialsProto) */ {
 public:
  inline ResetPendingCredentialsProto() : ResetPendingCredentialsProto(nullptr) {}
  ~ResetPendingCredentialsProto() override;
  explicit PROTOBUF_CONSTEXPR ResetPendingCredentialsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetPendingCredentialsProto(const ResetPendingCredentialsProto& from);
  ResetPendingCredentialsProto(ResetPendingCredentialsProto&& from) noexcept
    : ResetPendingCredentialsProto() {
    *this = ::std::move(from);
  }

  inline ResetPendingCredentialsProto& operator=(const ResetPendingCredentialsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetPendingCredentialsProto& operator=(ResetPendingCredentialsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ResetPendingCredentialsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetPendingCredentialsProto* internal_default_instance() {
    return reinterpret_cast<const ResetPendingCredentialsProto*>(
               &_ResetPendingCredentialsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    146;

  friend void swap(ResetPendingCredentialsProto& a, ResetPendingCredentialsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ResetPendingCredentialsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetPendingCredentialsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetPendingCredentialsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetPendingCredentialsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResetPendingCredentialsProto& from);
  void MergeFrom(const ResetPendingCredentialsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetPendingCredentialsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ResetPendingCredentialsProto";
  }
  protected:
  explicit ResetPendingCredentialsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.ResetPendingCredentialsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SaveSubmittedPasswordProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SaveSubmittedPasswordProto.Result) */ {
 public:
  inline SaveSubmittedPasswordProto_Result() : SaveSubmittedPasswordProto_Result(nullptr) {}
  ~SaveSubmittedPasswordProto_Result() override;
  explicit PROTOBUF_CONSTEXPR SaveSubmittedPasswordProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSubmittedPasswordProto_Result(const SaveSubmittedPasswordProto_Result& from);
  SaveSubmittedPasswordProto_Result(SaveSubmittedPasswordProto_Result&& from) noexcept
    : SaveSubmittedPasswordProto_Result() {
    *this = ::std::move(from);
  }

  inline SaveSubmittedPasswordProto_Result& operator=(const SaveSubmittedPasswordProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSubmittedPasswordProto_Result& operator=(SaveSubmittedPasswordProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SaveSubmittedPasswordProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSubmittedPasswordProto_Result* internal_default_instance() {
    return reinterpret_cast<const SaveSubmittedPasswordProto_Result*>(
               &_SaveSubmittedPasswordProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    147;

  friend void swap(SaveSubmittedPasswordProto_Result& a, SaveSubmittedPasswordProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SaveSubmittedPasswordProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSubmittedPasswordProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSubmittedPasswordProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSubmittedPasswordProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SaveSubmittedPasswordProto_Result& from);
  void MergeFrom(const SaveSubmittedPasswordProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveSubmittedPasswordProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SaveSubmittedPasswordProto.Result";
  }
  protected:
  explicit SaveSubmittedPasswordProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsedSamePasswordFieldNumber = 1,
    kUsedLeakedCredentialFieldNumber = 2,
  };
  // optional bool used_same_password = 1;
  bool has_used_same_password() const;
  private:
  bool _internal_has_used_same_password() const;
  public:
  void clear_used_same_password();
  bool used_same_password() const;
  void set_used_same_password(bool value);
  private:
  bool _internal_used_same_password() const;
  void _internal_set_used_same_password(bool value);
  public:

  // optional bool used_leaked_credential = 2;
  bool has_used_leaked_credential() const;
  private:
  bool _internal_has_used_leaked_credential() const;
  public:
  void clear_used_leaked_credential();
  bool used_leaked_credential() const;
  void set_used_leaked_credential(bool value);
  private:
  bool _internal_used_leaked_credential() const;
  void _internal_set_used_leaked_credential(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SaveSubmittedPasswordProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool used_same_password_;
  bool used_leaked_credential_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SaveSubmittedPasswordProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SaveSubmittedPasswordProto) */ {
 public:
  inline SaveSubmittedPasswordProto() : SaveSubmittedPasswordProto(nullptr) {}
  ~SaveSubmittedPasswordProto() override;
  explicit PROTOBUF_CONSTEXPR SaveSubmittedPasswordProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveSubmittedPasswordProto(const SaveSubmittedPasswordProto& from);
  SaveSubmittedPasswordProto(SaveSubmittedPasswordProto&& from) noexcept
    : SaveSubmittedPasswordProto() {
    *this = ::std::move(from);
  }

  inline SaveSubmittedPasswordProto& operator=(const SaveSubmittedPasswordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveSubmittedPasswordProto& operator=(SaveSubmittedPasswordProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SaveSubmittedPasswordProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveSubmittedPasswordProto* internal_default_instance() {
    return reinterpret_cast<const SaveSubmittedPasswordProto*>(
               &_SaveSubmittedPasswordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    148;

  friend void swap(SaveSubmittedPasswordProto& a, SaveSubmittedPasswordProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SaveSubmittedPasswordProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveSubmittedPasswordProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveSubmittedPasswordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveSubmittedPasswordProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SaveSubmittedPasswordProto& from);
  void MergeFrom(const SaveSubmittedPasswordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SaveSubmittedPasswordProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SaveSubmittedPasswordProto";
  }
  protected:
  explicit SaveSubmittedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SaveSubmittedPasswordProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kLeakDetectionTimeoutMsFieldNumber = 1,
  };
  // optional int32 leak_detection_timeout_ms = 1;
  bool has_leak_detection_timeout_ms() const;
  private:
  bool _internal_has_leak_detection_timeout_ms() const;
  public:
  void clear_leak_detection_timeout_ms();
  int32_t leak_detection_timeout_ms() const;
  void set_leak_detection_timeout_ms(int32_t value);
  private:
  int32_t _internal_leak_detection_timeout_ms() const;
  void _internal_set_leak_detection_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SaveSubmittedPasswordProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t leak_detection_timeout_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterPasswordResetRequestProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.RegisterPasswordResetRequestProto) */ {
 public:
  inline RegisterPasswordResetRequestProto() : RegisterPasswordResetRequestProto(nullptr) {}
  ~RegisterPasswordResetRequestProto() override;
  explicit PROTOBUF_CONSTEXPR RegisterPasswordResetRequestProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPasswordResetRequestProto(const RegisterPasswordResetRequestProto& from);
  RegisterPasswordResetRequestProto(RegisterPasswordResetRequestProto&& from) noexcept
    : RegisterPasswordResetRequestProto() {
    *this = ::std::move(from);
  }

  inline RegisterPasswordResetRequestProto& operator=(const RegisterPasswordResetRequestProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPasswordResetRequestProto& operator=(RegisterPasswordResetRequestProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RegisterPasswordResetRequestProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPasswordResetRequestProto* internal_default_instance() {
    return reinterpret_cast<const RegisterPasswordResetRequestProto*>(
               &_RegisterPasswordResetRequestProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    149;

  friend void swap(RegisterPasswordResetRequestProto& a, RegisterPasswordResetRequestProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RegisterPasswordResetRequestProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPasswordResetRequestProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPasswordResetRequestProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPasswordResetRequestProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RegisterPasswordResetRequestProto& from);
  void MergeFrom(const RegisterPasswordResetRequestProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterPasswordResetRequestProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.RegisterPasswordResetRequestProto";
  }
  protected:
  explicit RegisterPasswordResetRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.RegisterPasswordResetRequestProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ConfigureUiStateProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ConfigureUiStateProto) */ {
 public:
  inline ConfigureUiStateProto() : ConfigureUiStateProto(nullptr) {}
  ~ConfigureUiStateProto() override;
  explicit PROTOBUF_CONSTEXPR ConfigureUiStateProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureUiStateProto(const ConfigureUiStateProto& from);
  ConfigureUiStateProto(ConfigureUiStateProto&& from) noexcept
    : ConfigureUiStateProto() {
    *this = ::std::move(from);
  }

  inline ConfigureUiStateProto& operator=(const ConfigureUiStateProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureUiStateProto& operator=(ConfigureUiStateProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigureUiStateProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureUiStateProto* internal_default_instance() {
    return reinterpret_cast<const ConfigureUiStateProto*>(
               &_ConfigureUiStateProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    150;

  friend void swap(ConfigureUiStateProto& a, ConfigureUiStateProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ConfigureUiStateProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureUiStateProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureUiStateProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureUiStateProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigureUiStateProto& from);
  void MergeFrom(const ConfigureUiStateProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigureUiStateProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ConfigureUiStateProto";
  }
  protected:
  explicit ConfigureUiStateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConfigureUiStateProto_OverlayBehavior OverlayBehavior;
  static constexpr OverlayBehavior DEFAULT =
    ConfigureUiStateProto_OverlayBehavior_DEFAULT;
  static constexpr OverlayBehavior HIDDEN =
    ConfigureUiStateProto_OverlayBehavior_HIDDEN;
  static inline bool OverlayBehavior_IsValid(int value) {
    return ConfigureUiStateProto_OverlayBehavior_IsValid(value);
  }
  static constexpr OverlayBehavior OverlayBehavior_MIN =
    ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_MIN;
  static constexpr OverlayBehavior OverlayBehavior_MAX =
    ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_MAX;
  static constexpr int OverlayBehavior_ARRAYSIZE =
    ConfigureUiStateProto_OverlayBehavior_OverlayBehavior_ARRAYSIZE;
  template<typename T>
  static inline const std::string& OverlayBehavior_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OverlayBehavior>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OverlayBehavior_Name.");
    return ConfigureUiStateProto_OverlayBehavior_Name(enum_t_value);
  }
  static inline bool OverlayBehavior_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OverlayBehavior* value) {
    return ConfigureUiStateProto_OverlayBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayBehaviorFieldNumber = 1,
  };
  // optional .autofill_assistant.ConfigureUiStateProto.OverlayBehavior overlay_behavior = 1;
  bool has_overlay_behavior() const;
  private:
  bool _internal_has_overlay_behavior() const;
  public:
  void clear_overlay_behavior();
  ::autofill_assistant::ConfigureUiStateProto_OverlayBehavior overlay_behavior() const;
  void set_overlay_behavior(::autofill_assistant::ConfigureUiStateProto_OverlayBehavior value);
  private:
  ::autofill_assistant::ConfigureUiStateProto_OverlayBehavior _internal_overlay_behavior() const;
  void _internal_set_overlay_behavior(::autofill_assistant::ConfigureUiStateProto_OverlayBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ConfigureUiStateProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int overlay_behavior_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SetAttributeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetAttributeProto) */ {
 public:
  inline SetAttributeProto() : SetAttributeProto(nullptr) {}
  ~SetAttributeProto() override;
  explicit PROTOBUF_CONSTEXPR SetAttributeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAttributeProto(const SetAttributeProto& from);
  SetAttributeProto(SetAttributeProto&& from) noexcept
    : SetAttributeProto() {
    *this = ::std::move(from);
  }

  inline SetAttributeProto& operator=(const SetAttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAttributeProto& operator=(SetAttributeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetAttributeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAttributeProto* internal_default_instance() {
    return reinterpret_cast<const SetAttributeProto*>(
               &_SetAttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    151;

  friend void swap(SetAttributeProto& a, SetAttributeProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetAttributeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAttributeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAttributeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAttributeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetAttributeProto& from);
  void MergeFrom(const SetAttributeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetAttributeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetAttributeProto";
  }
  protected:
  explicit SetAttributeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeFieldNumber = 2,
    kValueFieldNumber = 3,
    kElementFieldNumber = 1,
  };
  // repeated string attribute = 2;
  int attribute_size() const;
  private:
  int _internal_attribute_size() const;
  public:
  void clear_attribute();
  const std::string& attribute(int index) const;
  std::string* mutable_attribute(int index);
  void set_attribute(int index, const std::string& value);
  void set_attribute(int index, std::string&& value);
  void set_attribute(int index, const char* value);
  void set_attribute(int index, const char* value, size_t size);
  std::string* add_attribute();
  void add_attribute(const std::string& value);
  void add_attribute(std::string&& value);
  void add_attribute(const char* value);
  void add_attribute(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attribute() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attribute();
  private:
  const std::string& _internal_attribute(int index) const;
  std::string* _internal_add_attribute();
  public:

  // optional string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .autofill_assistant.SelectorProto element = 1;
  bool has_element() const;
  private:
  bool _internal_has_element() const;
  public:
  void clear_element();
  const ::autofill_assistant::SelectorProto& element() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_element();
  ::autofill_assistant::SelectorProto* mutable_element();
  void set_allocated_element(::autofill_assistant::SelectorProto* element);
  private:
  const ::autofill_assistant::SelectorProto& _internal_element() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_element();
  public:
  void unsafe_arena_set_allocated_element(
      ::autofill_assistant::SelectorProto* element);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_element();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetAttributeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::autofill_assistant::SelectorProto* element_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class InfoBoxProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InfoBoxProto) */ {
 public:
  inline InfoBoxProto() : InfoBoxProto(nullptr) {}
  ~InfoBoxProto() override;
  explicit PROTOBUF_CONSTEXPR InfoBoxProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoBoxProto(const InfoBoxProto& from);
  InfoBoxProto(InfoBoxProto&& from) noexcept
    : InfoBoxProto() {
    *this = ::std::move(from);
  }

  inline InfoBoxProto& operator=(const InfoBoxProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoBoxProto& operator=(InfoBoxProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InfoBoxProto& default_instance() {
    return *internal_default_instance();
  }
  enum ImageCase {
    kImagePath = 1,
    kDrawable = 4,
    IMAGE_NOT_SET = 0,
  };

  static inline const InfoBoxProto* internal_default_instance() {
    return reinterpret_cast<const InfoBoxProto*>(
               &_InfoBoxProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    152;

  friend void swap(InfoBoxProto& a, InfoBoxProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InfoBoxProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoBoxProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoBoxProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoBoxProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InfoBoxProto& from);
  void MergeFrom(const InfoBoxProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoBoxProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InfoBoxProto";
  }
  protected:
  explicit InfoBoxProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExplanationFieldNumber = 2,
    kImagePathFieldNumber = 1,
    kDrawableFieldNumber = 4,
  };
  // optional string explanation = 2;
  bool has_explanation() const;
  private:
  bool _internal_has_explanation() const;
  public:
  void clear_explanation();
  const std::string& explanation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_explanation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_explanation();
  PROTOBUF_NODISCARD std::string* release_explanation();
  void set_allocated_explanation(std::string* explanation);
  private:
  const std::string& _internal_explanation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_explanation(const std::string& value);
  std::string* _internal_mutable_explanation();
  public:

  // string image_path = 1;
  bool has_image_path() const;
  private:
  bool _internal_has_image_path() const;
  public:
  void clear_image_path();
  const std::string& image_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_path();
  PROTOBUF_NODISCARD std::string* release_image_path();
  void set_allocated_image_path(std::string* image_path);
  private:
  const std::string& _internal_image_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_path(const std::string& value);
  std::string* _internal_mutable_image_path();
  public:

  // .autofill_assistant.DrawableProto drawable = 4;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::autofill_assistant::DrawableProto& drawable() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DrawableProto* release_drawable();
  ::autofill_assistant::DrawableProto* mutable_drawable();
  void set_allocated_drawable(::autofill_assistant::DrawableProto* drawable);
  private:
  const ::autofill_assistant::DrawableProto& _internal_drawable() const;
  ::autofill_assistant::DrawableProto* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::autofill_assistant::DrawableProto* drawable);
  ::autofill_assistant::DrawableProto* unsafe_arena_release_drawable();

  void clear_image();
  ImageCase image_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.InfoBoxProto)
 private:
  class _Internal;
  void set_has_image_path();
  void set_has_drawable();

  inline bool has_image() const;
  inline void clear_has_image();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr explanation_;
  union ImageUnion {
    constexpr ImageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_path_;
    ::autofill_assistant::DrawableProto* drawable_;
  } image_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowInfoBoxProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowInfoBoxProto) */ {
 public:
  inline ShowInfoBoxProto() : ShowInfoBoxProto(nullptr) {}
  ~ShowInfoBoxProto() override;
  explicit PROTOBUF_CONSTEXPR ShowInfoBoxProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowInfoBoxProto(const ShowInfoBoxProto& from);
  ShowInfoBoxProto(ShowInfoBoxProto&& from) noexcept
    : ShowInfoBoxProto() {
    *this = ::std::move(from);
  }

  inline ShowInfoBoxProto& operator=(const ShowInfoBoxProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowInfoBoxProto& operator=(ShowInfoBoxProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowInfoBoxProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowInfoBoxProto* internal_default_instance() {
    return reinterpret_cast<const ShowInfoBoxProto*>(
               &_ShowInfoBoxProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    153;

  friend void swap(ShowInfoBoxProto& a, ShowInfoBoxProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowInfoBoxProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowInfoBoxProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowInfoBoxProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowInfoBoxProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowInfoBoxProto& from);
  void MergeFrom(const ShowInfoBoxProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowInfoBoxProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowInfoBoxProto";
  }
  protected:
  explicit ShowInfoBoxProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoBoxFieldNumber = 1,
  };
  // optional .autofill_assistant.InfoBoxProto info_box = 1;
  bool has_info_box() const;
  private:
  bool _internal_has_info_box() const;
  public:
  void clear_info_box();
  const ::autofill_assistant::InfoBoxProto& info_box() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoBoxProto* release_info_box();
  ::autofill_assistant::InfoBoxProto* mutable_info_box();
  void set_allocated_info_box(::autofill_assistant::InfoBoxProto* info_box);
  private:
  const ::autofill_assistant::InfoBoxProto& _internal_info_box() const;
  ::autofill_assistant::InfoBoxProto* _internal_mutable_info_box();
  public:
  void unsafe_arena_set_allocated_info_box(
      ::autofill_assistant::InfoBoxProto* info_box);
  ::autofill_assistant::InfoBoxProto* unsafe_arena_release_info_box();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowInfoBoxProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::InfoBoxProto* info_box_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ConfigureBottomSheetProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ConfigureBottomSheetProto) */ {
 public:
  inline ConfigureBottomSheetProto() : ConfigureBottomSheetProto(nullptr) {}
  ~ConfigureBottomSheetProto() override;
  explicit PROTOBUF_CONSTEXPR ConfigureBottomSheetProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureBottomSheetProto(const ConfigureBottomSheetProto& from);
  ConfigureBottomSheetProto(ConfigureBottomSheetProto&& from) noexcept
    : ConfigureBottomSheetProto() {
    *this = ::std::move(from);
  }

  inline ConfigureBottomSheetProto& operator=(const ConfigureBottomSheetProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureBottomSheetProto& operator=(ConfigureBottomSheetProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigureBottomSheetProto& default_instance() {
    return *internal_default_instance();
  }
  enum ApplyStateCase {
    kExpand = 4,
    kCollapse = 5,
    APPLY_STATE_NOT_SET = 0,
  };

  static inline const ConfigureBottomSheetProto* internal_default_instance() {
    return reinterpret_cast<const ConfigureBottomSheetProto*>(
               &_ConfigureBottomSheetProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    154;

  friend void swap(ConfigureBottomSheetProto& a, ConfigureBottomSheetProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ConfigureBottomSheetProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureBottomSheetProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureBottomSheetProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureBottomSheetProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigureBottomSheetProto& from);
  void MergeFrom(const ConfigureBottomSheetProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigureBottomSheetProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ConfigureBottomSheetProto";
  }
  protected:
  explicit ConfigureBottomSheetProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ConfigureBottomSheetProto_ViewportResizing ViewportResizing;
  static constexpr ViewportResizing NO_CHANGE =
    ConfigureBottomSheetProto_ViewportResizing_NO_CHANGE;
  static constexpr ViewportResizing RESIZE_LAYOUT_VIEWPORT =
    ConfigureBottomSheetProto_ViewportResizing_RESIZE_LAYOUT_VIEWPORT;
  static constexpr ViewportResizing NO_RESIZE =
    ConfigureBottomSheetProto_ViewportResizing_NO_RESIZE;
  static constexpr ViewportResizing RESIZE_VISUAL_VIEWPORT =
    ConfigureBottomSheetProto_ViewportResizing_RESIZE_VISUAL_VIEWPORT;
  static inline bool ViewportResizing_IsValid(int value) {
    return ConfigureBottomSheetProto_ViewportResizing_IsValid(value);
  }
  static constexpr ViewportResizing ViewportResizing_MIN =
    ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_MIN;
  static constexpr ViewportResizing ViewportResizing_MAX =
    ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_MAX;
  static constexpr int ViewportResizing_ARRAYSIZE =
    ConfigureBottomSheetProto_ViewportResizing_ViewportResizing_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ViewportResizing_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ViewportResizing>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ViewportResizing_Name.");
    return ConfigureBottomSheetProto_ViewportResizing_Name(enum_t_value);
  }
  static inline bool ViewportResizing_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ViewportResizing* value) {
    return ConfigureBottomSheetProto_ViewportResizing_Parse(name, value);
  }

  typedef ConfigureBottomSheetProto_PeekMode PeekMode;
  static constexpr PeekMode UNDEFINED_PEEK_MODE =
    ConfigureBottomSheetProto_PeekMode_UNDEFINED_PEEK_MODE;
  static constexpr PeekMode HANDLE =
    ConfigureBottomSheetProto_PeekMode_HANDLE;
  static constexpr PeekMode HANDLE_HEADER =
    ConfigureBottomSheetProto_PeekMode_HANDLE_HEADER;
  static constexpr PeekMode HANDLE_HEADER_CAROUSELS =
    ConfigureBottomSheetProto_PeekMode_HANDLE_HEADER_CAROUSELS;
  static inline bool PeekMode_IsValid(int value) {
    return ConfigureBottomSheetProto_PeekMode_IsValid(value);
  }
  static constexpr PeekMode PeekMode_MIN =
    ConfigureBottomSheetProto_PeekMode_PeekMode_MIN;
  static constexpr PeekMode PeekMode_MAX =
    ConfigureBottomSheetProto_PeekMode_PeekMode_MAX;
  static constexpr int PeekMode_ARRAYSIZE =
    ConfigureBottomSheetProto_PeekMode_PeekMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PeekMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PeekMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PeekMode_Name.");
    return ConfigureBottomSheetProto_PeekMode_Name(enum_t_value);
  }
  static inline bool PeekMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PeekMode* value) {
    return ConfigureBottomSheetProto_PeekMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kViewportResizingFieldNumber = 1,
    kPeekModeFieldNumber = 2,
    kResizeTimeoutMsFieldNumber = 3,
    kExpandFieldNumber = 4,
    kCollapseFieldNumber = 5,
  };
  // optional .autofill_assistant.ConfigureBottomSheetProto.ViewportResizing viewport_resizing = 1;
  bool has_viewport_resizing() const;
  private:
  bool _internal_has_viewport_resizing() const;
  public:
  void clear_viewport_resizing();
  ::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing viewport_resizing() const;
  void set_viewport_resizing(::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing value);
  private:
  ::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing _internal_viewport_resizing() const;
  void _internal_set_viewport_resizing(::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing value);
  public:

  // optional .autofill_assistant.ConfigureBottomSheetProto.PeekMode peek_mode = 2;
  bool has_peek_mode() const;
  private:
  bool _internal_has_peek_mode() const;
  public:
  void clear_peek_mode();
  ::autofill_assistant::ConfigureBottomSheetProto_PeekMode peek_mode() const;
  void set_peek_mode(::autofill_assistant::ConfigureBottomSheetProto_PeekMode value);
  private:
  ::autofill_assistant::ConfigureBottomSheetProto_PeekMode _internal_peek_mode() const;
  void _internal_set_peek_mode(::autofill_assistant::ConfigureBottomSheetProto_PeekMode value);
  public:

  // optional int32 resize_timeout_ms = 3;
  bool has_resize_timeout_ms() const;
  private:
  bool _internal_has_resize_timeout_ms() const;
  public:
  void clear_resize_timeout_ms();
  int32_t resize_timeout_ms() const;
  void set_resize_timeout_ms(int32_t value);
  private:
  int32_t _internal_resize_timeout_ms() const;
  void _internal_set_resize_timeout_ms(int32_t value);
  public:

  // bool expand = 4;
  bool has_expand() const;
  private:
  bool _internal_has_expand() const;
  public:
  void clear_expand();
  bool expand() const;
  void set_expand(bool value);
  private:
  bool _internal_expand() const;
  void _internal_set_expand(bool value);
  public:

  // bool collapse = 5;
  bool has_collapse() const;
  private:
  bool _internal_has_collapse() const;
  public:
  void clear_collapse();
  bool collapse() const;
  void set_collapse(bool value);
  private:
  bool _internal_collapse() const;
  void _internal_set_collapse(bool value);
  public:

  void clear_apply_state();
  ApplyStateCase apply_state_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ConfigureBottomSheetProto)
 private:
  class _Internal;
  void set_has_expand();
  void set_has_collapse();

  inline bool has_apply_state() const;
  inline void clear_has_apply_state();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int viewport_resizing_;
  int peek_mode_;
  int32_t resize_timeout_ms_;
  union ApplyStateUnion {
    constexpr ApplyStateUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool expand_;
    bool collapse_;
  } apply_state_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ShowFormProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShowFormProto) */ {
 public:
  inline ShowFormProto() : ShowFormProto(nullptr) {}
  ~ShowFormProto() override;
  explicit PROTOBUF_CONSTEXPR ShowFormProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowFormProto(const ShowFormProto& from);
  ShowFormProto(ShowFormProto&& from) noexcept
    : ShowFormProto() {
    *this = ::std::move(from);
  }

  inline ShowFormProto& operator=(const ShowFormProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowFormProto& operator=(ShowFormProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShowFormProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowFormProto* internal_default_instance() {
    return reinterpret_cast<const ShowFormProto*>(
               &_ShowFormProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    155;

  friend void swap(ShowFormProto& a, ShowFormProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShowFormProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowFormProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowFormProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowFormProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShowFormProto& from);
  void MergeFrom(const ShowFormProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShowFormProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShowFormProto";
  }
  protected:
  explicit ShowFormProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormFieldNumber = 1,
    kChipFieldNumber = 2,
  };
  // optional .autofill_assistant.FormProto form = 1;
  bool has_form() const;
  private:
  bool _internal_has_form() const;
  public:
  void clear_form();
  const ::autofill_assistant::FormProto& form() const;
  PROTOBUF_NODISCARD ::autofill_assistant::FormProto* release_form();
  ::autofill_assistant::FormProto* mutable_form();
  void set_allocated_form(::autofill_assistant::FormProto* form);
  private:
  const ::autofill_assistant::FormProto& _internal_form() const;
  ::autofill_assistant::FormProto* _internal_mutable_form();
  public:
  void unsafe_arena_set_allocated_form(
      ::autofill_assistant::FormProto* form);
  ::autofill_assistant::FormProto* unsafe_arena_release_form();

  // optional .autofill_assistant.ChipProto chip = 2;
  bool has_chip() const;
  private:
  bool _internal_has_chip() const;
  public:
  void clear_chip();
  const ::autofill_assistant::ChipProto& chip() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ChipProto* release_chip();
  ::autofill_assistant::ChipProto* mutable_chip();
  void set_allocated_chip(::autofill_assistant::ChipProto* chip);
  private:
  const ::autofill_assistant::ChipProto& _internal_chip() const;
  ::autofill_assistant::ChipProto* _internal_mutable_chip();
  public:
  void unsafe_arena_set_allocated_chip(
      ::autofill_assistant::ChipProto* chip);
  ::autofill_assistant::ChipProto* unsafe_arena_release_chip();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShowFormProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::FormProto* form_;
  ::autofill_assistant::ChipProto* chip_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class FormProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FormProto.Result) */ {
 public:
  inline FormProto_Result() : FormProto_Result(nullptr) {}
  ~FormProto_Result() override;
  explicit PROTOBUF_CONSTEXPR FormProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormProto_Result(const FormProto_Result& from);
  FormProto_Result(FormProto_Result&& from) noexcept
    : FormProto_Result() {
    *this = ::std::move(from);
  }

  inline FormProto_Result& operator=(const FormProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormProto_Result& operator=(FormProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FormProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormProto_Result* internal_default_instance() {
    return reinterpret_cast<const FormProto_Result*>(
               &_FormProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    156;

  friend void swap(FormProto_Result& a, FormProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FormProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FormProto_Result& from);
  void MergeFrom(const FormProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FormProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FormProto.Result";
  }
  protected:
  explicit FormProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputResultsFieldNumber = 1,
    kLinkFieldNumber = 2,
  };
  // repeated .autofill_assistant.FormInputProto.Result input_results = 1;
  int input_results_size() const;
  private:
  int _internal_input_results_size() const;
  public:
  void clear_input_results();
  ::autofill_assistant::FormInputProto_Result* mutable_input_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto_Result >*
      mutable_input_results();
  private:
  const ::autofill_assistant::FormInputProto_Result& _internal_input_results(int index) const;
  ::autofill_assistant::FormInputProto_Result* _internal_add_input_results();
  public:
  const ::autofill_assistant::FormInputProto_Result& input_results(int index) const;
  ::autofill_assistant::FormInputProto_Result* add_input_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto_Result >&
      input_results() const;

  // optional int32 link = 2;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  int32_t link() const;
  void set_link(int32_t value);
  private:
  int32_t _internal_link() const;
  void _internal_set_link(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.FormProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto_Result > input_results_;
  int32_t link_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class FormProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FormProto) */ {
 public:
  inline FormProto() : FormProto(nullptr) {}
  ~FormProto() override;
  explicit PROTOBUF_CONSTEXPR FormProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormProto(const FormProto& from);
  FormProto(FormProto&& from) noexcept
    : FormProto() {
    *this = ::std::move(from);
  }

  inline FormProto& operator=(const FormProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormProto& operator=(FormProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FormProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormProto* internal_default_instance() {
    return reinterpret_cast<const FormProto*>(
               &_FormProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    157;

  friend void swap(FormProto& a, FormProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FormProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FormProto& from);
  void MergeFrom(const FormProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FormProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FormProto";
  }
  protected:
  explicit FormProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FormProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 1,
    kInfoLabelFieldNumber = 2,
    kInfoPopupFieldNumber = 3,
  };
  // repeated .autofill_assistant.FormInputProto inputs = 1;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::autofill_assistant::FormInputProto* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto >*
      mutable_inputs();
  private:
  const ::autofill_assistant::FormInputProto& _internal_inputs(int index) const;
  ::autofill_assistant::FormInputProto* _internal_add_inputs();
  public:
  const ::autofill_assistant::FormInputProto& inputs(int index) const;
  ::autofill_assistant::FormInputProto* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto >&
      inputs() const;

  // optional string info_label = 2;
  bool has_info_label() const;
  private:
  bool _internal_has_info_label() const;
  public:
  void clear_info_label();
  const std::string& info_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info_label();
  PROTOBUF_NODISCARD std::string* release_info_label();
  void set_allocated_info_label(std::string* info_label);
  private:
  const std::string& _internal_info_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info_label(const std::string& value);
  std::string* _internal_mutable_info_label();
  public:

  // optional .autofill_assistant.InfoPopupProto info_popup = 3;
  bool has_info_popup() const;
  private:
  bool _internal_has_info_popup() const;
  public:
  void clear_info_popup();
  const ::autofill_assistant::InfoPopupProto& info_popup() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto* release_info_popup();
  ::autofill_assistant::InfoPopupProto* mutable_info_popup();
  void set_allocated_info_popup(::autofill_assistant::InfoPopupProto* info_popup);
  private:
  const ::autofill_assistant::InfoPopupProto& _internal_info_popup() const;
  ::autofill_assistant::InfoPopupProto* _internal_mutable_info_popup();
  public:
  void unsafe_arena_set_allocated_info_popup(
      ::autofill_assistant::InfoPopupProto* info_popup);
  ::autofill_assistant::InfoPopupProto* unsafe_arena_release_info_popup();

  // @@protoc_insertion_point(class_scope:autofill_assistant.FormProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto > inputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_label_;
  ::autofill_assistant::InfoPopupProto* info_popup_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class FormInputProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FormInputProto.Result) */ {
 public:
  inline FormInputProto_Result() : FormInputProto_Result(nullptr) {}
  ~FormInputProto_Result() override;
  explicit PROTOBUF_CONSTEXPR FormInputProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormInputProto_Result(const FormInputProto_Result& from);
  FormInputProto_Result(FormInputProto_Result&& from) noexcept
    : FormInputProto_Result() {
    *this = ::std::move(from);
  }

  inline FormInputProto_Result& operator=(const FormInputProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormInputProto_Result& operator=(FormInputProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FormInputProto_Result& default_instance() {
    return *internal_default_instance();
  }
  enum InputTypeCase {
    kCounter = 1,
    kSelection = 2,
    INPUT_TYPE_NOT_SET = 0,
  };

  static inline const FormInputProto_Result* internal_default_instance() {
    return reinterpret_cast<const FormInputProto_Result*>(
               &_FormInputProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    158;

  friend void swap(FormInputProto_Result& a, FormInputProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FormInputProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormInputProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormInputProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormInputProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FormInputProto_Result& from);
  void MergeFrom(const FormInputProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FormInputProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FormInputProto.Result";
  }
  protected:
  explicit FormInputProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCounterFieldNumber = 1,
    kSelectionFieldNumber = 2,
  };
  // .autofill_assistant.CounterInputProto.Result counter = 1;
  bool has_counter() const;
  private:
  bool _internal_has_counter() const;
  public:
  void clear_counter();
  const ::autofill_assistant::CounterInputProto_Result& counter() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CounterInputProto_Result* release_counter();
  ::autofill_assistant::CounterInputProto_Result* mutable_counter();
  void set_allocated_counter(::autofill_assistant::CounterInputProto_Result* counter);
  private:
  const ::autofill_assistant::CounterInputProto_Result& _internal_counter() const;
  ::autofill_assistant::CounterInputProto_Result* _internal_mutable_counter();
  public:
  void unsafe_arena_set_allocated_counter(
      ::autofill_assistant::CounterInputProto_Result* counter);
  ::autofill_assistant::CounterInputProto_Result* unsafe_arena_release_counter();

  // .autofill_assistant.SelectionInputProto.Result selection = 2;
  bool has_selection() const;
  private:
  bool _internal_has_selection() const;
  public:
  void clear_selection();
  const ::autofill_assistant::SelectionInputProto_Result& selection() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectionInputProto_Result* release_selection();
  ::autofill_assistant::SelectionInputProto_Result* mutable_selection();
  void set_allocated_selection(::autofill_assistant::SelectionInputProto_Result* selection);
  private:
  const ::autofill_assistant::SelectionInputProto_Result& _internal_selection() const;
  ::autofill_assistant::SelectionInputProto_Result* _internal_mutable_selection();
  public:
  void unsafe_arena_set_allocated_selection(
      ::autofill_assistant::SelectionInputProto_Result* selection);
  ::autofill_assistant::SelectionInputProto_Result* unsafe_arena_release_selection();

  void clear_input_type();
  InputTypeCase input_type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.FormInputProto.Result)
 private:
  class _Internal;
  void set_has_counter();
  void set_has_selection();

  inline bool has_input_type() const;
  inline void clear_has_input_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InputTypeUnion {
    constexpr InputTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::CounterInputProto_Result* counter_;
    ::autofill_assistant::SelectionInputProto_Result* selection_;
  } input_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class FormInputProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FormInputProto) */ {
 public:
  inline FormInputProto() : FormInputProto(nullptr) {}
  ~FormInputProto() override;
  explicit PROTOBUF_CONSTEXPR FormInputProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormInputProto(const FormInputProto& from);
  FormInputProto(FormInputProto&& from) noexcept
    : FormInputProto() {
    *this = ::std::move(from);
  }

  inline FormInputProto& operator=(const FormInputProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormInputProto& operator=(FormInputProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FormInputProto& default_instance() {
    return *internal_default_instance();
  }
  enum InputTypeCase {
    kCounter = 1,
    kSelection = 2,
    INPUT_TYPE_NOT_SET = 0,
  };

  static inline const FormInputProto* internal_default_instance() {
    return reinterpret_cast<const FormInputProto*>(
               &_FormInputProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    159;

  friend void swap(FormInputProto& a, FormInputProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FormInputProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormInputProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormInputProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormInputProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FormInputProto& from);
  void MergeFrom(const FormInputProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FormInputProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FormInputProto";
  }
  protected:
  explicit FormInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FormInputProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kCounterFieldNumber = 1,
    kSelectionFieldNumber = 2,
  };
  // .autofill_assistant.CounterInputProto counter = 1;
  bool has_counter() const;
  private:
  bool _internal_has_counter() const;
  public:
  void clear_counter();
  const ::autofill_assistant::CounterInputProto& counter() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CounterInputProto* release_counter();
  ::autofill_assistant::CounterInputProto* mutable_counter();
  void set_allocated_counter(::autofill_assistant::CounterInputProto* counter);
  private:
  const ::autofill_assistant::CounterInputProto& _internal_counter() const;
  ::autofill_assistant::CounterInputProto* _internal_mutable_counter();
  public:
  void unsafe_arena_set_allocated_counter(
      ::autofill_assistant::CounterInputProto* counter);
  ::autofill_assistant::CounterInputProto* unsafe_arena_release_counter();

  // .autofill_assistant.SelectionInputProto selection = 2;
  bool has_selection() const;
  private:
  bool _internal_has_selection() const;
  public:
  void clear_selection();
  const ::autofill_assistant::SelectionInputProto& selection() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectionInputProto* release_selection();
  ::autofill_assistant::SelectionInputProto* mutable_selection();
  void set_allocated_selection(::autofill_assistant::SelectionInputProto* selection);
  private:
  const ::autofill_assistant::SelectionInputProto& _internal_selection() const;
  ::autofill_assistant::SelectionInputProto* _internal_mutable_selection();
  public:
  void unsafe_arena_set_allocated_selection(
      ::autofill_assistant::SelectionInputProto* selection);
  ::autofill_assistant::SelectionInputProto* unsafe_arena_release_selection();

  void clear_input_type();
  InputTypeCase input_type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.FormInputProto)
 private:
  class _Internal;
  void set_has_counter();
  void set_has_selection();

  inline bool has_input_type() const;
  inline void clear_has_input_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InputTypeUnion {
    constexpr InputTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::CounterInputProto* counter_;
    ::autofill_assistant::SelectionInputProto* selection_;
  } input_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto_Counter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto.Counter) */ {
 public:
  inline CounterInputProto_Counter() : CounterInputProto_Counter(nullptr) {}
  ~CounterInputProto_Counter() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto_Counter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto_Counter(const CounterInputProto_Counter& from);
  CounterInputProto_Counter(CounterInputProto_Counter&& from) noexcept
    : CounterInputProto_Counter() {
    *this = ::std::move(from);
  }

  inline CounterInputProto_Counter& operator=(const CounterInputProto_Counter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto_Counter& operator=(CounterInputProto_Counter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto_Counter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterInputProto_Counter* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto_Counter*>(
               &_CounterInputProto_Counter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    160;

  friend void swap(CounterInputProto_Counter& a, CounterInputProto_Counter& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto_Counter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto_Counter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto_Counter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto_Counter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto_Counter& from);
  void MergeFrom(const CounterInputProto_Counter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto_Counter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto.Counter";
  }
  protected:
  explicit CounterInputProto_Counter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedValuesFieldNumber = 6,
    kLabelFieldNumber = 1,
    kDescriptionLine1FieldNumber = 5,
    kDescriptionLine2FieldNumber = 8,
    kInitialValueFieldNumber = 4,
    kSizeFieldNumber = 9,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };
  // repeated int32 allowed_values = 6;
  int allowed_values_size() const;
  private:
  int _internal_allowed_values_size() const;
  public:
  void clear_allowed_values();
  private:
  int32_t _internal_allowed_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_allowed_values() const;
  void _internal_add_allowed_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_allowed_values();
  public:
  int32_t allowed_values(int index) const;
  void set_allowed_values(int index, int32_t value);
  void add_allowed_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      allowed_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_allowed_values();

  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional string description_line_1 = 5;
  bool has_description_line_1() const;
  private:
  bool _internal_has_description_line_1() const;
  public:
  void clear_description_line_1();
  const std::string& description_line_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_1();
  PROTOBUF_NODISCARD std::string* release_description_line_1();
  void set_allocated_description_line_1(std::string* description_line_1);
  private:
  const std::string& _internal_description_line_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_1(const std::string& value);
  std::string* _internal_mutable_description_line_1();
  public:

  // optional string description_line_2 = 8;
  bool has_description_line_2() const;
  private:
  bool _internal_has_description_line_2() const;
  public:
  void clear_description_line_2();
  const std::string& description_line_2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_2();
  PROTOBUF_NODISCARD std::string* release_description_line_2();
  void set_allocated_description_line_2(std::string* description_line_2);
  private:
  const std::string& _internal_description_line_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_2(const std::string& value);
  std::string* _internal_mutable_description_line_2();
  public:

  // optional int32 initial_value = 4 [default = 0];
  bool has_initial_value() const;
  private:
  bool _internal_has_initial_value() const;
  public:
  void clear_initial_value();
  int32_t initial_value() const;
  void set_initial_value(int32_t value);
  private:
  int32_t _internal_initial_value() const;
  void _internal_set_initial_value(int32_t value);
  public:

  // optional int32 size = 9 [default = 1];
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // optional int32 min_value = 2 [default = -2147483648];
  bool has_min_value() const;
  private:
  bool _internal_has_min_value() const;
  public:
  void clear_min_value();
  int32_t min_value() const;
  void set_min_value(int32_t value);
  private:
  int32_t _internal_min_value() const;
  void _internal_set_min_value(int32_t value);
  public:

  // optional int32 max_value = 3 [default = 2147483647];
  bool has_max_value() const;
  private:
  bool _internal_has_max_value() const;
  public:
  void clear_max_value();
  int32_t max_value() const;
  void set_max_value(int32_t value);
  private:
  int32_t _internal_max_value() const;
  void _internal_set_max_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto.Counter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > allowed_values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_2_;
  int32_t initial_value_;
  int32_t size_;
  int32_t min_value_;
  int32_t max_value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto.Result) */ {
 public:
  inline CounterInputProto_Result() : CounterInputProto_Result(nullptr) {}
  ~CounterInputProto_Result() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto_Result(const CounterInputProto_Result& from);
  CounterInputProto_Result(CounterInputProto_Result&& from) noexcept
    : CounterInputProto_Result() {
    *this = ::std::move(from);
  }

  inline CounterInputProto_Result& operator=(const CounterInputProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto_Result& operator=(CounterInputProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterInputProto_Result* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto_Result*>(
               &_CounterInputProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    161;

  friend void swap(CounterInputProto_Result& a, CounterInputProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto_Result& from);
  void MergeFrom(const CounterInputProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto.Result";
  }
  protected:
  explicit CounterInputProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto_ValidationRule_BooleanRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule) */ {
 public:
  inline CounterInputProto_ValidationRule_BooleanRule() : CounterInputProto_ValidationRule_BooleanRule(nullptr) {}
  ~CounterInputProto_ValidationRule_BooleanRule() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_BooleanRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto_ValidationRule_BooleanRule(const CounterInputProto_ValidationRule_BooleanRule& from);
  CounterInputProto_ValidationRule_BooleanRule(CounterInputProto_ValidationRule_BooleanRule&& from) noexcept
    : CounterInputProto_ValidationRule_BooleanRule() {
    *this = ::std::move(from);
  }

  inline CounterInputProto_ValidationRule_BooleanRule& operator=(const CounterInputProto_ValidationRule_BooleanRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto_ValidationRule_BooleanRule& operator=(CounterInputProto_ValidationRule_BooleanRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto_ValidationRule_BooleanRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterInputProto_ValidationRule_BooleanRule* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto_ValidationRule_BooleanRule*>(
               &_CounterInputProto_ValidationRule_BooleanRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    162;

  friend void swap(CounterInputProto_ValidationRule_BooleanRule& a, CounterInputProto_ValidationRule_BooleanRule& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto_ValidationRule_BooleanRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto_ValidationRule_BooleanRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto_ValidationRule_BooleanRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto_ValidationRule_BooleanRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto_ValidationRule_BooleanRule& from);
  void MergeFrom(const CounterInputProto_ValidationRule_BooleanRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto_ValidationRule_BooleanRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto.ValidationRule.BooleanRule";
  }
  protected:
  explicit CounterInputProto_ValidationRule_BooleanRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubRulesFieldNumber = 1,
    kMinSatisfiedRulesFieldNumber = 2,
    kMaxSatisfiedRulesFieldNumber = 3,
  };
  // repeated .autofill_assistant.CounterInputProto.ValidationRule sub_rules = 1;
  int sub_rules_size() const;
  private:
  int _internal_sub_rules_size() const;
  public:
  void clear_sub_rules();
  ::autofill_assistant::CounterInputProto_ValidationRule* mutable_sub_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_ValidationRule >*
      mutable_sub_rules();
  private:
  const ::autofill_assistant::CounterInputProto_ValidationRule& _internal_sub_rules(int index) const;
  ::autofill_assistant::CounterInputProto_ValidationRule* _internal_add_sub_rules();
  public:
  const ::autofill_assistant::CounterInputProto_ValidationRule& sub_rules(int index) const;
  ::autofill_assistant::CounterInputProto_ValidationRule* add_sub_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_ValidationRule >&
      sub_rules() const;

  // optional int32 min_satisfied_rules = 2 [default = 0];
  bool has_min_satisfied_rules() const;
  private:
  bool _internal_has_min_satisfied_rules() const;
  public:
  void clear_min_satisfied_rules();
  int32_t min_satisfied_rules() const;
  void set_min_satisfied_rules(int32_t value);
  private:
  int32_t _internal_min_satisfied_rules() const;
  void _internal_set_min_satisfied_rules(int32_t value);
  public:

  // optional int32 max_satisfied_rules = 3 [default = 2147483647];
  bool has_max_satisfied_rules() const;
  private:
  bool _internal_has_max_satisfied_rules() const;
  public:
  void clear_max_satisfied_rules();
  int32_t max_satisfied_rules() const;
  void set_max_satisfied_rules(int32_t value);
  private:
  int32_t _internal_max_satisfied_rules() const;
  void _internal_set_max_satisfied_rules(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_ValidationRule > sub_rules_;
  int32_t min_satisfied_rules_;
  int32_t max_satisfied_rules_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto_ValidationRule_CounterRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto.ValidationRule.CounterRule) */ {
 public:
  inline CounterInputProto_ValidationRule_CounterRule() : CounterInputProto_ValidationRule_CounterRule(nullptr) {}
  ~CounterInputProto_ValidationRule_CounterRule() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_CounterRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto_ValidationRule_CounterRule(const CounterInputProto_ValidationRule_CounterRule& from);
  CounterInputProto_ValidationRule_CounterRule(CounterInputProto_ValidationRule_CounterRule&& from) noexcept
    : CounterInputProto_ValidationRule_CounterRule() {
    *this = ::std::move(from);
  }

  inline CounterInputProto_ValidationRule_CounterRule& operator=(const CounterInputProto_ValidationRule_CounterRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto_ValidationRule_CounterRule& operator=(CounterInputProto_ValidationRule_CounterRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto_ValidationRule_CounterRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterInputProto_ValidationRule_CounterRule* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto_ValidationRule_CounterRule*>(
               &_CounterInputProto_ValidationRule_CounterRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    163;

  friend void swap(CounterInputProto_ValidationRule_CounterRule& a, CounterInputProto_ValidationRule_CounterRule& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto_ValidationRule_CounterRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto_ValidationRule_CounterRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto_ValidationRule_CounterRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto_ValidationRule_CounterRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto_ValidationRule_CounterRule& from);
  void MergeFrom(const CounterInputProto_ValidationRule_CounterRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto_ValidationRule_CounterRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto.ValidationRule.CounterRule";
  }
  protected:
  explicit CounterInputProto_ValidationRule_CounterRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCounterIndexFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };
  // optional int32 counter_index = 1;
  bool has_counter_index() const;
  private:
  bool _internal_has_counter_index() const;
  public:
  void clear_counter_index();
  int32_t counter_index() const;
  void set_counter_index(int32_t value);
  private:
  int32_t _internal_counter_index() const;
  void _internal_set_counter_index(int32_t value);
  public:

  // optional int32 min_value = 2 [default = -2147483648];
  bool has_min_value() const;
  private:
  bool _internal_has_min_value() const;
  public:
  void clear_min_value();
  int32_t min_value() const;
  void set_min_value(int32_t value);
  private:
  int32_t _internal_min_value() const;
  void _internal_set_min_value(int32_t value);
  public:

  // optional int32 max_value = 3 [default = 2147483647];
  bool has_max_value() const;
  private:
  bool _internal_has_max_value() const;
  public:
  void clear_max_value();
  int32_t max_value() const;
  void set_max_value(int32_t value);
  private:
  int32_t _internal_max_value() const;
  void _internal_set_max_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t counter_index_;
  int32_t min_value_;
  int32_t max_value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto_ValidationRule_CountersSumRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule) */ {
 public:
  inline CounterInputProto_ValidationRule_CountersSumRule() : CounterInputProto_ValidationRule_CountersSumRule(nullptr) {}
  ~CounterInputProto_ValidationRule_CountersSumRule() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_CountersSumRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto_ValidationRule_CountersSumRule(const CounterInputProto_ValidationRule_CountersSumRule& from);
  CounterInputProto_ValidationRule_CountersSumRule(CounterInputProto_ValidationRule_CountersSumRule&& from) noexcept
    : CounterInputProto_ValidationRule_CountersSumRule() {
    *this = ::std::move(from);
  }

  inline CounterInputProto_ValidationRule_CountersSumRule& operator=(const CounterInputProto_ValidationRule_CountersSumRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto_ValidationRule_CountersSumRule& operator=(CounterInputProto_ValidationRule_CountersSumRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto_ValidationRule_CountersSumRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterInputProto_ValidationRule_CountersSumRule* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto_ValidationRule_CountersSumRule*>(
               &_CounterInputProto_ValidationRule_CountersSumRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    164;

  friend void swap(CounterInputProto_ValidationRule_CountersSumRule& a, CounterInputProto_ValidationRule_CountersSumRule& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto_ValidationRule_CountersSumRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto_ValidationRule_CountersSumRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto_ValidationRule_CountersSumRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto_ValidationRule_CountersSumRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto_ValidationRule_CountersSumRule& from);
  void MergeFrom(const CounterInputProto_ValidationRule_CountersSumRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto_ValidationRule_CountersSumRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule";
  }
  protected:
  explicit CounterInputProto_ValidationRule_CountersSumRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinValueFieldNumber = 1,
    kMaxValueFieldNumber = 2,
  };
  // optional int64 min_value = 1 [default = -9223372036854775808];
  bool has_min_value() const;
  private:
  bool _internal_has_min_value() const;
  public:
  void clear_min_value();
  int64_t min_value() const;
  void set_min_value(int64_t value);
  private:
  int64_t _internal_min_value() const;
  void _internal_set_min_value(int64_t value);
  public:

  // optional int64 max_value = 2 [default = 9223372036854775807];
  bool has_max_value() const;
  private:
  bool _internal_has_max_value() const;
  public:
  void clear_max_value();
  int64_t max_value() const;
  void set_max_value(int64_t value);
  private:
  int64_t _internal_max_value() const;
  void _internal_set_max_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t min_value_;
  int64_t max_value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto_ValidationRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto.ValidationRule) */ {
 public:
  inline CounterInputProto_ValidationRule() : CounterInputProto_ValidationRule(nullptr) {}
  ~CounterInputProto_ValidationRule() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto_ValidationRule(const CounterInputProto_ValidationRule& from);
  CounterInputProto_ValidationRule(CounterInputProto_ValidationRule&& from) noexcept
    : CounterInputProto_ValidationRule() {
    *this = ::std::move(from);
  }

  inline CounterInputProto_ValidationRule& operator=(const CounterInputProto_ValidationRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto_ValidationRule& operator=(CounterInputProto_ValidationRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto_ValidationRule& default_instance() {
    return *internal_default_instance();
  }
  enum RuleTypeCase {
    kBoolean = 1,
    kCounter = 2,
    kCountersSum = 3,
    RULE_TYPE_NOT_SET = 0,
  };

  static inline const CounterInputProto_ValidationRule* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto_ValidationRule*>(
               &_CounterInputProto_ValidationRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    165;

  friend void swap(CounterInputProto_ValidationRule& a, CounterInputProto_ValidationRule& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto_ValidationRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto_ValidationRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto_ValidationRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto_ValidationRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto_ValidationRule& from);
  void MergeFrom(const CounterInputProto_ValidationRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto_ValidationRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto.ValidationRule";
  }
  protected:
  explicit CounterInputProto_ValidationRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CounterInputProto_ValidationRule_BooleanRule BooleanRule;
  typedef CounterInputProto_ValidationRule_CounterRule CounterRule;
  typedef CounterInputProto_ValidationRule_CountersSumRule CountersSumRule;

  // accessors -------------------------------------------------------

  enum : int {
    kBooleanFieldNumber = 1,
    kCounterFieldNumber = 2,
    kCountersSumFieldNumber = 3,
  };
  // .autofill_assistant.CounterInputProto.ValidationRule.BooleanRule boolean = 1;
  bool has_boolean() const;
  private:
  bool _internal_has_boolean() const;
  public:
  void clear_boolean();
  const ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule& boolean() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* release_boolean();
  ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* mutable_boolean();
  void set_allocated_boolean(::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* boolean);
  private:
  const ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule& _internal_boolean() const;
  ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* _internal_mutable_boolean();
  public:
  void unsafe_arena_set_allocated_boolean(
      ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* boolean);
  ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* unsafe_arena_release_boolean();

  // .autofill_assistant.CounterInputProto.ValidationRule.CounterRule counter = 2;
  bool has_counter() const;
  private:
  bool _internal_has_counter() const;
  public:
  void clear_counter();
  const ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule& counter() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* release_counter();
  ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* mutable_counter();
  void set_allocated_counter(::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* counter);
  private:
  const ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule& _internal_counter() const;
  ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* _internal_mutable_counter();
  public:
  void unsafe_arena_set_allocated_counter(
      ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* counter);
  ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* unsafe_arena_release_counter();

  // .autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule counters_sum = 3;
  bool has_counters_sum() const;
  private:
  bool _internal_has_counters_sum() const;
  public:
  void clear_counters_sum();
  const ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule& counters_sum() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* release_counters_sum();
  ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* mutable_counters_sum();
  void set_allocated_counters_sum(::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* counters_sum);
  private:
  const ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule& _internal_counters_sum() const;
  ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* _internal_mutable_counters_sum();
  public:
  void unsafe_arena_set_allocated_counters_sum(
      ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* counters_sum);
  ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* unsafe_arena_release_counters_sum();

  void clear_rule_type();
  RuleTypeCase rule_type_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto.ValidationRule)
 private:
  class _Internal;
  void set_has_boolean();
  void set_has_counter();
  void set_has_counters_sum();

  inline bool has_rule_type() const;
  inline void clear_has_rule_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RuleTypeUnion {
    constexpr RuleTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* boolean_;
    ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* counter_;
    ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* counters_sum_;
  } rule_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CounterInputProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CounterInputProto) */ {
 public:
  inline CounterInputProto() : CounterInputProto(nullptr) {}
  ~CounterInputProto() override;
  explicit PROTOBUF_CONSTEXPR CounterInputProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterInputProto(const CounterInputProto& from);
  CounterInputProto(CounterInputProto&& from) noexcept
    : CounterInputProto() {
    *this = ::std::move(from);
  }

  inline CounterInputProto& operator=(const CounterInputProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterInputProto& operator=(CounterInputProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CounterInputProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterInputProto* internal_default_instance() {
    return reinterpret_cast<const CounterInputProto*>(
               &_CounterInputProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    166;

  friend void swap(CounterInputProto& a, CounterInputProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CounterInputProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterInputProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterInputProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterInputProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CounterInputProto& from);
  void MergeFrom(const CounterInputProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CounterInputProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CounterInputProto";
  }
  protected:
  explicit CounterInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CounterInputProto_Counter Counter;
  typedef CounterInputProto_Result Result;
  typedef CounterInputProto_ValidationRule ValidationRule;

  // accessors -------------------------------------------------------

  enum : int {
    kCountersFieldNumber = 2,
    kLabelFieldNumber = 1,
    kExpandTextFieldNumber = 4,
    kMinimizeTextFieldNumber = 5,
    kValidationRuleFieldNumber = 6,
    kMinimizedCountFieldNumber = 3,
    kMinCountersSumFieldNumber = 7,
    kMaxCountersSumFieldNumber = 8,
  };
  // repeated .autofill_assistant.CounterInputProto.Counter counters = 2;
  int counters_size() const;
  private:
  int _internal_counters_size() const;
  public:
  void clear_counters();
  ::autofill_assistant::CounterInputProto_Counter* mutable_counters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_Counter >*
      mutable_counters();
  private:
  const ::autofill_assistant::CounterInputProto_Counter& _internal_counters(int index) const;
  ::autofill_assistant::CounterInputProto_Counter* _internal_add_counters();
  public:
  const ::autofill_assistant::CounterInputProto_Counter& counters(int index) const;
  ::autofill_assistant::CounterInputProto_Counter* add_counters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_Counter >&
      counters() const;

  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional string expand_text = 4;
  bool has_expand_text() const;
  private:
  bool _internal_has_expand_text() const;
  public:
  void clear_expand_text();
  const std::string& expand_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expand_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expand_text();
  PROTOBUF_NODISCARD std::string* release_expand_text();
  void set_allocated_expand_text(std::string* expand_text);
  private:
  const std::string& _internal_expand_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expand_text(const std::string& value);
  std::string* _internal_mutable_expand_text();
  public:

  // optional string minimize_text = 5;
  bool has_minimize_text() const;
  private:
  bool _internal_has_minimize_text() const;
  public:
  void clear_minimize_text();
  const std::string& minimize_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimize_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimize_text();
  PROTOBUF_NODISCARD std::string* release_minimize_text();
  void set_allocated_minimize_text(std::string* minimize_text);
  private:
  const std::string& _internal_minimize_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimize_text(const std::string& value);
  std::string* _internal_mutable_minimize_text();
  public:

  // optional .autofill_assistant.CounterInputProto.ValidationRule validation_rule = 6;
  bool has_validation_rule() const;
  private:
  bool _internal_has_validation_rule() const;
  public:
  void clear_validation_rule();
  const ::autofill_assistant::CounterInputProto_ValidationRule& validation_rule() const;
  PROTOBUF_NODISCARD ::autofill_assistant::CounterInputProto_ValidationRule* release_validation_rule();
  ::autofill_assistant::CounterInputProto_ValidationRule* mutable_validation_rule();
  void set_allocated_validation_rule(::autofill_assistant::CounterInputProto_ValidationRule* validation_rule);
  private:
  const ::autofill_assistant::CounterInputProto_ValidationRule& _internal_validation_rule() const;
  ::autofill_assistant::CounterInputProto_ValidationRule* _internal_mutable_validation_rule();
  public:
  void unsafe_arena_set_allocated_validation_rule(
      ::autofill_assistant::CounterInputProto_ValidationRule* validation_rule);
  ::autofill_assistant::CounterInputProto_ValidationRule* unsafe_arena_release_validation_rule();

  // optional int32 minimized_count = 3 [default = 2147483647];
  bool has_minimized_count() const;
  private:
  bool _internal_has_minimized_count() const;
  public:
  void clear_minimized_count();
  int32_t minimized_count() const;
  void set_minimized_count(int32_t value);
  private:
  int32_t _internal_minimized_count() const;
  void _internal_set_minimized_count(int32_t value);
  public:

  // optional int64 min_counters_sum = 7 [default = -9223372036854775808];
  bool has_min_counters_sum() const;
  private:
  bool _internal_has_min_counters_sum() const;
  public:
  void clear_min_counters_sum();
  int64_t min_counters_sum() const;
  void set_min_counters_sum(int64_t value);
  private:
  int64_t _internal_min_counters_sum() const;
  void _internal_set_min_counters_sum(int64_t value);
  public:

  // optional int64 max_counters_sum = 8 [default = 9223372036854775807];
  bool has_max_counters_sum() const;
  private:
  bool _internal_has_max_counters_sum() const;
  public:
  void clear_max_counters_sum();
  int64_t max_counters_sum() const;
  void set_max_counters_sum(int64_t value);
  private:
  int64_t _internal_max_counters_sum() const;
  void _internal_set_max_counters_sum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CounterInputProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_Counter > counters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expand_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimize_text_;
  ::autofill_assistant::CounterInputProto_ValidationRule* validation_rule_;
  int32_t minimized_count_;
  int64_t min_counters_sum_;
  int64_t max_counters_sum_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectionInputProto_Choice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectionInputProto.Choice) */ {
 public:
  inline SelectionInputProto_Choice() : SelectionInputProto_Choice(nullptr) {}
  ~SelectionInputProto_Choice() override;
  explicit PROTOBUF_CONSTEXPR SelectionInputProto_Choice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionInputProto_Choice(const SelectionInputProto_Choice& from);
  SelectionInputProto_Choice(SelectionInputProto_Choice&& from) noexcept
    : SelectionInputProto_Choice() {
    *this = ::std::move(from);
  }

  inline SelectionInputProto_Choice& operator=(const SelectionInputProto_Choice& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionInputProto_Choice& operator=(SelectionInputProto_Choice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectionInputProto_Choice& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectionInputProto_Choice* internal_default_instance() {
    return reinterpret_cast<const SelectionInputProto_Choice*>(
               &_SelectionInputProto_Choice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    167;

  friend void swap(SelectionInputProto_Choice& a, SelectionInputProto_Choice& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectionInputProto_Choice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionInputProto_Choice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionInputProto_Choice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionInputProto_Choice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectionInputProto_Choice& from);
  void MergeFrom(const SelectionInputProto_Choice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectionInputProto_Choice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectionInputProto.Choice";
  }
  protected:
  explicit SelectionInputProto_Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kDescriptionLine1FieldNumber = 3,
    kDescriptionLine2FieldNumber = 4,
    kSelectedFieldNumber = 2,
  };
  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional string description_line_1 = 3;
  bool has_description_line_1() const;
  private:
  bool _internal_has_description_line_1() const;
  public:
  void clear_description_line_1();
  const std::string& description_line_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_1();
  PROTOBUF_NODISCARD std::string* release_description_line_1();
  void set_allocated_description_line_1(std::string* description_line_1);
  private:
  const std::string& _internal_description_line_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_1(const std::string& value);
  std::string* _internal_mutable_description_line_1();
  public:

  // optional string description_line_2 = 4;
  bool has_description_line_2() const;
  private:
  bool _internal_has_description_line_2() const;
  public:
  void clear_description_line_2();
  const std::string& description_line_2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description_line_2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description_line_2();
  PROTOBUF_NODISCARD std::string* release_description_line_2();
  void set_allocated_description_line_2(std::string* description_line_2);
  private:
  const std::string& _internal_description_line_2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description_line_2(const std::string& value);
  std::string* _internal_mutable_description_line_2();
  public:

  // optional bool selected = 2 [default = false];
  bool has_selected() const;
  private:
  bool _internal_has_selected() const;
  public:
  void clear_selected();
  bool selected() const;
  void set_selected(bool value);
  private:
  bool _internal_selected() const;
  void _internal_set_selected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectionInputProto.Choice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_line_2_;
  bool selected_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectionInputProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectionInputProto.Result) */ {
 public:
  inline SelectionInputProto_Result() : SelectionInputProto_Result(nullptr) {}
  ~SelectionInputProto_Result() override;
  explicit PROTOBUF_CONSTEXPR SelectionInputProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionInputProto_Result(const SelectionInputProto_Result& from);
  SelectionInputProto_Result(SelectionInputProto_Result&& from) noexcept
    : SelectionInputProto_Result() {
    *this = ::std::move(from);
  }

  inline SelectionInputProto_Result& operator=(const SelectionInputProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionInputProto_Result& operator=(SelectionInputProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectionInputProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectionInputProto_Result* internal_default_instance() {
    return reinterpret_cast<const SelectionInputProto_Result*>(
               &_SelectionInputProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    168;

  friend void swap(SelectionInputProto_Result& a, SelectionInputProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectionInputProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionInputProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionInputProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionInputProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectionInputProto_Result& from);
  void MergeFrom(const SelectionInputProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectionInputProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectionInputProto.Result";
  }
  protected:
  explicit SelectionInputProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedFieldNumber = 1,
  };
  // repeated bool selected = 1;
  int selected_size() const;
  private:
  int _internal_selected_size() const;
  public:
  void clear_selected();
  private:
  bool _internal_selected(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_selected() const;
  void _internal_add_selected(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_selected();
  public:
  bool selected(int index) const;
  void set_selected(int index, bool value);
  void add_selected(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      selected() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_selected();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectionInputProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > selected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SelectionInputProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectionInputProto) */ {
 public:
  inline SelectionInputProto() : SelectionInputProto(nullptr) {}
  ~SelectionInputProto() override;
  explicit PROTOBUF_CONSTEXPR SelectionInputProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionInputProto(const SelectionInputProto& from);
  SelectionInputProto(SelectionInputProto&& from) noexcept
    : SelectionInputProto() {
    *this = ::std::move(from);
  }

  inline SelectionInputProto& operator=(const SelectionInputProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionInputProto& operator=(SelectionInputProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectionInputProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectionInputProto* internal_default_instance() {
    return reinterpret_cast<const SelectionInputProto*>(
               &_SelectionInputProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    169;

  friend void swap(SelectionInputProto& a, SelectionInputProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectionInputProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionInputProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionInputProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionInputProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectionInputProto& from);
  void MergeFrom(const SelectionInputProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectionInputProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectionInputProto";
  }
  protected:
  explicit SelectionInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SelectionInputProto_Choice Choice;
  typedef SelectionInputProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kChoicesFieldNumber = 2,
    kLabelFieldNumber = 1,
    kAllowMultipleFieldNumber = 3,
    kMinSelectedChoicesFieldNumber = 4,
  };
  // repeated .autofill_assistant.SelectionInputProto.Choice choices = 2;
  int choices_size() const;
  private:
  int _internal_choices_size() const;
  public:
  void clear_choices();
  ::autofill_assistant::SelectionInputProto_Choice* mutable_choices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectionInputProto_Choice >*
      mutable_choices();
  private:
  const ::autofill_assistant::SelectionInputProto_Choice& _internal_choices(int index) const;
  ::autofill_assistant::SelectionInputProto_Choice* _internal_add_choices();
  public:
  const ::autofill_assistant::SelectionInputProto_Choice& choices(int index) const;
  ::autofill_assistant::SelectionInputProto_Choice* add_choices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectionInputProto_Choice >&
      choices() const;

  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional bool allow_multiple = 3 [default = false];
  bool has_allow_multiple() const;
  private:
  bool _internal_has_allow_multiple() const;
  public:
  void clear_allow_multiple();
  bool allow_multiple() const;
  void set_allow_multiple(bool value);
  private:
  bool _internal_allow_multiple() const;
  void _internal_set_allow_multiple(bool value);
  public:

  // optional int32 min_selected_choices = 4 [default = 1];
  bool has_min_selected_choices() const;
  private:
  bool _internal_has_min_selected_choices() const;
  public:
  void clear_min_selected_choices();
  int32_t min_selected_choices() const;
  void set_min_selected_choices(int32_t value);
  private:
  int32_t _internal_min_selected_choices() const;
  void _internal_set_min_selected_choices(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectionInputProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectionInputProto_Choice > choices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  bool allow_multiple_;
  int32_t min_selected_choices_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class PopupMessageProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.PopupMessageProto) */ {
 public:
  inline PopupMessageProto() : PopupMessageProto(nullptr) {}
  ~PopupMessageProto() override;
  explicit PROTOBUF_CONSTEXPR PopupMessageProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PopupMessageProto(const PopupMessageProto& from);
  PopupMessageProto(PopupMessageProto&& from) noexcept
    : PopupMessageProto() {
    *this = ::std::move(from);
  }

  inline PopupMessageProto& operator=(const PopupMessageProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline PopupMessageProto& operator=(PopupMessageProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PopupMessageProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const PopupMessageProto* internal_default_instance() {
    return reinterpret_cast<const PopupMessageProto*>(
               &_PopupMessageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    170;

  friend void swap(PopupMessageProto& a, PopupMessageProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PopupMessageProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PopupMessageProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PopupMessageProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PopupMessageProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PopupMessageProto& from);
  void MergeFrom(const PopupMessageProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PopupMessageProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.PopupMessageProto";
  }
  protected:
  explicit PopupMessageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // optional string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.PopupMessageProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto.Result) */ {
 public:
  inline GetElementStatusProto_Result() : GetElementStatusProto_Result(nullptr) {}
  ~GetElementStatusProto_Result() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto_Result(const GetElementStatusProto_Result& from);
  GetElementStatusProto_Result(GetElementStatusProto_Result&& from) noexcept
    : GetElementStatusProto_Result() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto_Result& operator=(const GetElementStatusProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto_Result& operator=(GetElementStatusProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetElementStatusProto_Result* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto_Result*>(
               &_GetElementStatusProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    171;

  friend void swap(GetElementStatusProto_Result& a, GetElementStatusProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto_Result& from);
  void MergeFrom(const GetElementStatusProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto.Result";
  }
  protected:
  explicit GetElementStatusProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportsFieldNumber = 3,
    kNotEmptyFieldNumber = 1,
    kMatchSuccessFieldNumber = 2,
    kExpectedEmptyMatchFieldNumber = 4,
  };
  // repeated .autofill_assistant.GetElementStatusProto.ComparisonReport reports = 3;
  int reports_size() const;
  private:
  int _internal_reports_size() const;
  public:
  void clear_reports();
  ::autofill_assistant::GetElementStatusProto_ComparisonReport* mutable_reports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetElementStatusProto_ComparisonReport >*
      mutable_reports();
  private:
  const ::autofill_assistant::GetElementStatusProto_ComparisonReport& _internal_reports(int index) const;
  ::autofill_assistant::GetElementStatusProto_ComparisonReport* _internal_add_reports();
  public:
  const ::autofill_assistant::GetElementStatusProto_ComparisonReport& reports(int index) const;
  ::autofill_assistant::GetElementStatusProto_ComparisonReport* add_reports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetElementStatusProto_ComparisonReport >&
      reports() const;

  // optional bool not_empty = 1;
  bool has_not_empty() const;
  private:
  bool _internal_has_not_empty() const;
  public:
  void clear_not_empty();
  bool not_empty() const;
  void set_not_empty(bool value);
  private:
  bool _internal_not_empty() const;
  void _internal_set_not_empty(bool value);
  public:

  // optional bool match_success = 2;
  bool has_match_success() const;
  private:
  bool _internal_has_match_success() const;
  public:
  void clear_match_success();
  bool match_success() const;
  void set_match_success(bool value);
  private:
  bool _internal_match_success() const;
  void _internal_set_match_success(bool value);
  public:

  // optional bool expected_empty_match = 4;
  bool has_expected_empty_match() const;
  private:
  bool _internal_has_expected_empty_match() const;
  public:
  void clear_expected_empty_match();
  bool expected_empty_match() const;
  void set_expected_empty_match(bool value);
  private:
  bool _internal_expected_empty_match() const;
  void _internal_set_expected_empty_match(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetElementStatusProto_ComparisonReport > reports_;
  bool not_empty_;
  bool match_success_;
  bool expected_empty_match_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto_MatchOptions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto.MatchOptions) */ {
 public:
  inline GetElementStatusProto_MatchOptions() : GetElementStatusProto_MatchOptions(nullptr) {}
  ~GetElementStatusProto_MatchOptions() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto_MatchOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto_MatchOptions(const GetElementStatusProto_MatchOptions& from);
  GetElementStatusProto_MatchOptions(GetElementStatusProto_MatchOptions&& from) noexcept
    : GetElementStatusProto_MatchOptions() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto_MatchOptions& operator=(const GetElementStatusProto_MatchOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto_MatchOptions& operator=(GetElementStatusProto_MatchOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto_MatchOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetElementStatusProto_MatchOptions* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto_MatchOptions*>(
               &_GetElementStatusProto_MatchOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    172;

  friend void swap(GetElementStatusProto_MatchOptions& a, GetElementStatusProto_MatchOptions& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto_MatchOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto_MatchOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto_MatchOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto_MatchOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto_MatchOptions& from);
  void MergeFrom(const GetElementStatusProto_MatchOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto_MatchOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto.MatchOptions";
  }
  protected:
  explicit GetElementStatusProto_MatchOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFindAndRemoveRe2FieldNumber = 3,
    kCaseSensitiveFieldNumber = 1,
    kRemoveSpaceFieldNumber = 2,
  };
  // optional string find_and_remove_re2 = 3;
  bool has_find_and_remove_re2() const;
  private:
  bool _internal_has_find_and_remove_re2() const;
  public:
  void clear_find_and_remove_re2();
  const std::string& find_and_remove_re2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_find_and_remove_re2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_find_and_remove_re2();
  PROTOBUF_NODISCARD std::string* release_find_and_remove_re2();
  void set_allocated_find_and_remove_re2(std::string* find_and_remove_re2);
  private:
  const std::string& _internal_find_and_remove_re2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_find_and_remove_re2(const std::string& value);
  std::string* _internal_mutable_find_and_remove_re2();
  public:

  // optional bool case_sensitive = 1;
  bool has_case_sensitive() const;
  private:
  bool _internal_has_case_sensitive() const;
  public:
  void clear_case_sensitive();
  bool case_sensitive() const;
  void set_case_sensitive(bool value);
  private:
  bool _internal_case_sensitive() const;
  void _internal_set_case_sensitive(bool value);
  public:

  // optional bool remove_space = 2;
  bool has_remove_space() const;
  private:
  bool _internal_has_remove_space() const;
  public:
  void clear_remove_space();
  bool remove_space() const;
  void set_remove_space(bool value);
  private:
  bool _internal_remove_space() const;
  void _internal_set_remove_space(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto.MatchOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr find_and_remove_re2_;
  bool case_sensitive_;
  bool remove_space_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto_MatchExpectation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto.MatchExpectation) */ {
 public:
  inline GetElementStatusProto_MatchExpectation() : GetElementStatusProto_MatchExpectation(nullptr) {}
  ~GetElementStatusProto_MatchExpectation() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto_MatchExpectation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto_MatchExpectation(const GetElementStatusProto_MatchExpectation& from);
  GetElementStatusProto_MatchExpectation(GetElementStatusProto_MatchExpectation&& from) noexcept
    : GetElementStatusProto_MatchExpectation() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto_MatchExpectation& operator=(const GetElementStatusProto_MatchExpectation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto_MatchExpectation& operator=(GetElementStatusProto_MatchExpectation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto_MatchExpectation& default_instance() {
    return *internal_default_instance();
  }
  enum MatchLevelCase {
    kFullMatch = 2,
    kContains = 3,
    kStartsWith = 4,
    kEndsWith = 5,
    MATCH_LEVEL_NOT_SET = 0,
  };

  static inline const GetElementStatusProto_MatchExpectation* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto_MatchExpectation*>(
               &_GetElementStatusProto_MatchExpectation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    173;

  friend void swap(GetElementStatusProto_MatchExpectation& a, GetElementStatusProto_MatchExpectation& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto_MatchExpectation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto_MatchExpectation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto_MatchExpectation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto_MatchExpectation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto_MatchExpectation& from);
  void MergeFrom(const GetElementStatusProto_MatchExpectation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto_MatchExpectation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto.MatchExpectation";
  }
  protected:
  explicit GetElementStatusProto_MatchExpectation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchOptionsFieldNumber = 1,
    kFullMatchFieldNumber = 2,
    kContainsFieldNumber = 3,
    kStartsWithFieldNumber = 4,
    kEndsWithFieldNumber = 5,
  };
  // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
  bool has_match_options() const;
  private:
  bool _internal_has_match_options() const;
  public:
  void clear_match_options();
  const ::autofill_assistant::GetElementStatusProto_MatchOptions& match_options() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto_MatchOptions* release_match_options();
  ::autofill_assistant::GetElementStatusProto_MatchOptions* mutable_match_options();
  void set_allocated_match_options(::autofill_assistant::GetElementStatusProto_MatchOptions* match_options);
  private:
  const ::autofill_assistant::GetElementStatusProto_MatchOptions& _internal_match_options() const;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* _internal_mutable_match_options();
  public:
  void unsafe_arena_set_allocated_match_options(
      ::autofill_assistant::GetElementStatusProto_MatchOptions* match_options);
  ::autofill_assistant::GetElementStatusProto_MatchOptions* unsafe_arena_release_match_options();

  // bool full_match = 2;
  bool has_full_match() const;
  private:
  bool _internal_has_full_match() const;
  public:
  void clear_full_match();
  bool full_match() const;
  void set_full_match(bool value);
  private:
  bool _internal_full_match() const;
  void _internal_set_full_match(bool value);
  public:

  // bool contains = 3;
  bool has_contains() const;
  private:
  bool _internal_has_contains() const;
  public:
  void clear_contains();
  bool contains() const;
  void set_contains(bool value);
  private:
  bool _internal_contains() const;
  void _internal_set_contains(bool value);
  public:

  // bool starts_with = 4;
  bool has_starts_with() const;
  private:
  bool _internal_has_starts_with() const;
  public:
  void clear_starts_with();
  bool starts_with() const;
  void set_starts_with(bool value);
  private:
  bool _internal_starts_with() const;
  void _internal_set_starts_with(bool value);
  public:

  // bool ends_with = 5;
  bool has_ends_with() const;
  private:
  bool _internal_has_ends_with() const;
  public:
  void clear_ends_with();
  bool ends_with() const;
  void set_ends_with(bool value);
  private:
  bool _internal_ends_with() const;
  void _internal_set_ends_with(bool value);
  public:

  void clear_match_level();
  MatchLevelCase match_level_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto.MatchExpectation)
 private:
  class _Internal;
  void set_has_full_match();
  void set_has_contains();
  void set_has_starts_with();
  void set_has_ends_with();

  inline bool has_match_level() const;
  inline void clear_has_match_level();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* match_options_;
  union MatchLevelUnion {
    constexpr MatchLevelUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool full_match_;
    bool contains_;
    bool starts_with_;
    bool ends_with_;
  } match_level_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto_TextMatch final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto.TextMatch) */ {
 public:
  inline GetElementStatusProto_TextMatch() : GetElementStatusProto_TextMatch(nullptr) {}
  ~GetElementStatusProto_TextMatch() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto_TextMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto_TextMatch(const GetElementStatusProto_TextMatch& from);
  GetElementStatusProto_TextMatch(GetElementStatusProto_TextMatch&& from) noexcept
    : GetElementStatusProto_TextMatch() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto_TextMatch& operator=(const GetElementStatusProto_TextMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto_TextMatch& operator=(GetElementStatusProto_TextMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto_TextMatch& default_instance() {
    return *internal_default_instance();
  }
  enum ValueSourceCase {
    kRe2 = 4,
    kTextValue = 5,
    VALUE_SOURCE_NOT_SET = 0,
  };

  static inline const GetElementStatusProto_TextMatch* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto_TextMatch*>(
               &_GetElementStatusProto_TextMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    174;

  friend void swap(GetElementStatusProto_TextMatch& a, GetElementStatusProto_TextMatch& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto_TextMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto_TextMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto_TextMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto_TextMatch>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto_TextMatch& from);
  void MergeFrom(const GetElementStatusProto_TextMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto_TextMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto.TextMatch";
  }
  protected:
  explicit GetElementStatusProto_TextMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchExpectationFieldNumber = 3,
    kRe2FieldNumber = 4,
    kTextValueFieldNumber = 5,
  };
  // optional .autofill_assistant.GetElementStatusProto.MatchExpectation match_expectation = 3;
  bool has_match_expectation() const;
  private:
  bool _internal_has_match_expectation() const;
  public:
  void clear_match_expectation();
  const ::autofill_assistant::GetElementStatusProto_MatchExpectation& match_expectation() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto_MatchExpectation* release_match_expectation();
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* mutable_match_expectation();
  void set_allocated_match_expectation(::autofill_assistant::GetElementStatusProto_MatchExpectation* match_expectation);
  private:
  const ::autofill_assistant::GetElementStatusProto_MatchExpectation& _internal_match_expectation() const;
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* _internal_mutable_match_expectation();
  public:
  void unsafe_arena_set_allocated_match_expectation(
      ::autofill_assistant::GetElementStatusProto_MatchExpectation* match_expectation);
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* unsafe_arena_release_match_expectation();

  // string re2 = 4;
  bool has_re2() const;
  private:
  bool _internal_has_re2() const;
  public:
  void clear_re2();
  const std::string& re2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_re2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_re2();
  PROTOBUF_NODISCARD std::string* release_re2();
  void set_allocated_re2(std::string* re2);
  private:
  const std::string& _internal_re2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_re2(const std::string& value);
  std::string* _internal_mutable_re2();
  public:

  // .autofill_assistant.TextValue text_value = 5;
  bool has_text_value() const;
  private:
  bool _internal_has_text_value() const;
  public:
  void clear_text_value();
  const ::autofill_assistant::TextValue& text_value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextValue* release_text_value();
  ::autofill_assistant::TextValue* mutable_text_value();
  void set_allocated_text_value(::autofill_assistant::TextValue* text_value);
  private:
  const ::autofill_assistant::TextValue& _internal_text_value() const;
  ::autofill_assistant::TextValue* _internal_mutable_text_value();
  public:
  void unsafe_arena_set_allocated_text_value(
      ::autofill_assistant::TextValue* text_value);
  ::autofill_assistant::TextValue* unsafe_arena_release_text_value();

  void clear_value_source();
  ValueSourceCase value_source_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto.TextMatch)
 private:
  class _Internal;
  void set_has_re2();
  void set_has_text_value();

  inline bool has_value_source() const;
  inline void clear_has_value_source();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* match_expectation_;
  union ValueSourceUnion {
    constexpr ValueSourceUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr re2_;
    ::autofill_assistant::TextValue* text_value_;
  } value_source_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto_ValueMatch final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto.ValueMatch) */ {
 public:
  inline GetElementStatusProto_ValueMatch() : GetElementStatusProto_ValueMatch(nullptr) {}
  ~GetElementStatusProto_ValueMatch() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto_ValueMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto_ValueMatch(const GetElementStatusProto_ValueMatch& from);
  GetElementStatusProto_ValueMatch(GetElementStatusProto_ValueMatch&& from) noexcept
    : GetElementStatusProto_ValueMatch() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto_ValueMatch& operator=(const GetElementStatusProto_ValueMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto_ValueMatch& operator=(GetElementStatusProto_ValueMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto_ValueMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetElementStatusProto_ValueMatch* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto_ValueMatch*>(
               &_GetElementStatusProto_ValueMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    175;

  friend void swap(GetElementStatusProto_ValueMatch& a, GetElementStatusProto_ValueMatch& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto_ValueMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto_ValueMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto_ValueMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto_ValueMatch>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto_ValueMatch& from);
  void MergeFrom(const GetElementStatusProto_ValueMatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto_ValueMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto.ValueMatch";
  }
  protected:
  explicit GetElementStatusProto_ValueMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextMatchFieldNumber = 1,
  };
  // optional .autofill_assistant.GetElementStatusProto.TextMatch text_match = 1;
  bool has_text_match() const;
  private:
  bool _internal_has_text_match() const;
  public:
  void clear_text_match();
  const ::autofill_assistant::GetElementStatusProto_TextMatch& text_match() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto_TextMatch* release_text_match();
  ::autofill_assistant::GetElementStatusProto_TextMatch* mutable_text_match();
  void set_allocated_text_match(::autofill_assistant::GetElementStatusProto_TextMatch* text_match);
  private:
  const ::autofill_assistant::GetElementStatusProto_TextMatch& _internal_text_match() const;
  ::autofill_assistant::GetElementStatusProto_TextMatch* _internal_mutable_text_match();
  public:
  void unsafe_arena_set_allocated_text_match(
      ::autofill_assistant::GetElementStatusProto_TextMatch* text_match);
  ::autofill_assistant::GetElementStatusProto_TextMatch* unsafe_arena_release_text_match();

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto.ValueMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GetElementStatusProto_TextMatch* text_match_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto_ComparisonReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto.ComparisonReport) */ {
 public:
  inline GetElementStatusProto_ComparisonReport() : GetElementStatusProto_ComparisonReport(nullptr) {}
  ~GetElementStatusProto_ComparisonReport() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto_ComparisonReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto_ComparisonReport(const GetElementStatusProto_ComparisonReport& from);
  GetElementStatusProto_ComparisonReport(GetElementStatusProto_ComparisonReport&& from) noexcept
    : GetElementStatusProto_ComparisonReport() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto_ComparisonReport& operator=(const GetElementStatusProto_ComparisonReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto_ComparisonReport& operator=(GetElementStatusProto_ComparisonReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto_ComparisonReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetElementStatusProto_ComparisonReport* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto_ComparisonReport*>(
               &_GetElementStatusProto_ComparisonReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    176;

  friend void swap(GetElementStatusProto_ComparisonReport& a, GetElementStatusProto_ComparisonReport& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto_ComparisonReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto_ComparisonReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto_ComparisonReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto_ComparisonReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto_ComparisonReport& from);
  void MergeFrom(const GetElementStatusProto_ComparisonReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto_ComparisonReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto.ComparisonReport";
  }
  protected:
  explicit GetElementStatusProto_ComparisonReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchOptionsFieldNumber = 1,
    kFullMatchFieldNumber = 2,
    kContainsFieldNumber = 3,
    kStartsWithFieldNumber = 4,
    kEndsWithFieldNumber = 5,
    kEmptyFieldNumber = 6,
    kExpectedEmptyMatchFieldNumber = 7,
  };
  // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
  bool has_match_options() const;
  private:
  bool _internal_has_match_options() const;
  public:
  void clear_match_options();
  const ::autofill_assistant::GetElementStatusProto_MatchOptions& match_options() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto_MatchOptions* release_match_options();
  ::autofill_assistant::GetElementStatusProto_MatchOptions* mutable_match_options();
  void set_allocated_match_options(::autofill_assistant::GetElementStatusProto_MatchOptions* match_options);
  private:
  const ::autofill_assistant::GetElementStatusProto_MatchOptions& _internal_match_options() const;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* _internal_mutable_match_options();
  public:
  void unsafe_arena_set_allocated_match_options(
      ::autofill_assistant::GetElementStatusProto_MatchOptions* match_options);
  ::autofill_assistant::GetElementStatusProto_MatchOptions* unsafe_arena_release_match_options();

  // optional bool full_match = 2;
  bool has_full_match() const;
  private:
  bool _internal_has_full_match() const;
  public:
  void clear_full_match();
  bool full_match() const;
  void set_full_match(bool value);
  private:
  bool _internal_full_match() const;
  void _internal_set_full_match(bool value);
  public:

  // optional bool contains = 3;
  bool has_contains() const;
  private:
  bool _internal_has_contains() const;
  public:
  void clear_contains();
  bool contains() const;
  void set_contains(bool value);
  private:
  bool _internal_contains() const;
  void _internal_set_contains(bool value);
  public:

  // optional bool starts_with = 4;
  bool has_starts_with() const;
  private:
  bool _internal_has_starts_with() const;
  public:
  void clear_starts_with();
  bool starts_with() const;
  void set_starts_with(bool value);
  private:
  bool _internal_starts_with() const;
  void _internal_set_starts_with(bool value);
  public:

  // optional bool ends_with = 5;
  bool has_ends_with() const;
  private:
  bool _internal_has_ends_with() const;
  public:
  void clear_ends_with();
  bool ends_with() const;
  void set_ends_with(bool value);
  private:
  bool _internal_ends_with() const;
  void _internal_set_ends_with(bool value);
  public:

  // optional bool empty = 6;
  bool has_empty() const;
  private:
  bool _internal_has_empty() const;
  public:
  void clear_empty();
  bool empty() const;
  void set_empty(bool value);
  private:
  bool _internal_empty() const;
  void _internal_set_empty(bool value);
  public:

  // optional bool expected_empty_match = 7;
  bool has_expected_empty_match() const;
  private:
  bool _internal_has_expected_empty_match() const;
  public:
  void clear_expected_empty_match();
  bool expected_empty_match() const;
  void set_expected_empty_match(bool value);
  private:
  bool _internal_expected_empty_match() const;
  void _internal_set_expected_empty_match(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto.ComparisonReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* match_options_;
  bool full_match_;
  bool contains_;
  bool starts_with_;
  bool ends_with_;
  bool empty_;
  bool expected_empty_match_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class GetElementStatusProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.GetElementStatusProto) */ {
 public:
  inline GetElementStatusProto() : GetElementStatusProto(nullptr) {}
  ~GetElementStatusProto() override;
  explicit PROTOBUF_CONSTEXPR GetElementStatusProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetElementStatusProto(const GetElementStatusProto& from);
  GetElementStatusProto(GetElementStatusProto&& from) noexcept
    : GetElementStatusProto() {
    *this = ::std::move(from);
  }

  inline GetElementStatusProto& operator=(const GetElementStatusProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetElementStatusProto& operator=(GetElementStatusProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetElementStatusProto& default_instance() {
    return *internal_default_instance();
  }
  enum ElementCase {
    kSelector = 1,
    kClientId = 5,
    ELEMENT_NOT_SET = 0,
  };

  static inline const GetElementStatusProto* internal_default_instance() {
    return reinterpret_cast<const GetElementStatusProto*>(
               &_GetElementStatusProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    177;

  friend void swap(GetElementStatusProto& a, GetElementStatusProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetElementStatusProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetElementStatusProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetElementStatusProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetElementStatusProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetElementStatusProto& from);
  void MergeFrom(const GetElementStatusProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetElementStatusProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.GetElementStatusProto";
  }
  protected:
  explicit GetElementStatusProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GetElementStatusProto_Result Result;
  typedef GetElementStatusProto_MatchOptions MatchOptions;
  typedef GetElementStatusProto_MatchExpectation MatchExpectation;
  typedef GetElementStatusProto_TextMatch TextMatch;
  typedef GetElementStatusProto_ValueMatch ValueMatch;
  typedef GetElementStatusProto_ComparisonReport ComparisonReport;

  typedef GetElementStatusProto_ValueSource ValueSource;
  static constexpr ValueSource NOT_SET =
    GetElementStatusProto_ValueSource_NOT_SET;
  static constexpr ValueSource VALUE =
    GetElementStatusProto_ValueSource_VALUE;
  static constexpr ValueSource INNER_TEXT =
    GetElementStatusProto_ValueSource_INNER_TEXT;
  static inline bool ValueSource_IsValid(int value) {
    return GetElementStatusProto_ValueSource_IsValid(value);
  }
  static constexpr ValueSource ValueSource_MIN =
    GetElementStatusProto_ValueSource_ValueSource_MIN;
  static constexpr ValueSource ValueSource_MAX =
    GetElementStatusProto_ValueSource_ValueSource_MAX;
  static constexpr int ValueSource_ARRAYSIZE =
    GetElementStatusProto_ValueSource_ValueSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ValueSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValueSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValueSource_Name.");
    return GetElementStatusProto_ValueSource_Name(enum_t_value);
  }
  static inline bool ValueSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValueSource* value) {
    return GetElementStatusProto_ValueSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExpectedValueMatchFieldNumber = 2,
    kMismatchShouldFailFieldNumber = 3,
    kValueSourceFieldNumber = 4,
    kSelectorFieldNumber = 1,
    kClientIdFieldNumber = 5,
  };
  // optional .autofill_assistant.GetElementStatusProto.ValueMatch expected_value_match = 2;
  bool has_expected_value_match() const;
  private:
  bool _internal_has_expected_value_match() const;
  public:
  void clear_expected_value_match();
  const ::autofill_assistant::GetElementStatusProto_ValueMatch& expected_value_match() const;
  PROTOBUF_NODISCARD ::autofill_assistant::GetElementStatusProto_ValueMatch* release_expected_value_match();
  ::autofill_assistant::GetElementStatusProto_ValueMatch* mutable_expected_value_match();
  void set_allocated_expected_value_match(::autofill_assistant::GetElementStatusProto_ValueMatch* expected_value_match);
  private:
  const ::autofill_assistant::GetElementStatusProto_ValueMatch& _internal_expected_value_match() const;
  ::autofill_assistant::GetElementStatusProto_ValueMatch* _internal_mutable_expected_value_match();
  public:
  void unsafe_arena_set_allocated_expected_value_match(
      ::autofill_assistant::GetElementStatusProto_ValueMatch* expected_value_match);
  ::autofill_assistant::GetElementStatusProto_ValueMatch* unsafe_arena_release_expected_value_match();

  // optional bool mismatch_should_fail = 3;
  bool has_mismatch_should_fail() const;
  private:
  bool _internal_has_mismatch_should_fail() const;
  public:
  void clear_mismatch_should_fail();
  bool mismatch_should_fail() const;
  void set_mismatch_should_fail(bool value);
  private:
  bool _internal_mismatch_should_fail() const;
  void _internal_set_mismatch_should_fail(bool value);
  public:

  // optional .autofill_assistant.GetElementStatusProto.ValueSource value_source = 4;
  bool has_value_source() const;
  private:
  bool _internal_has_value_source() const;
  public:
  void clear_value_source();
  ::autofill_assistant::GetElementStatusProto_ValueSource value_source() const;
  void set_value_source(::autofill_assistant::GetElementStatusProto_ValueSource value);
  private:
  ::autofill_assistant::GetElementStatusProto_ValueSource _internal_value_source() const;
  void _internal_set_value_source(::autofill_assistant::GetElementStatusProto_ValueSource value);
  public:

  // .autofill_assistant.SelectorProto selector = 1;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::autofill_assistant::SelectorProto& selector() const;
  PROTOBUF_NODISCARD ::autofill_assistant::SelectorProto* release_selector();
  ::autofill_assistant::SelectorProto* mutable_selector();
  void set_allocated_selector(::autofill_assistant::SelectorProto* selector);
  private:
  const ::autofill_assistant::SelectorProto& _internal_selector() const;
  ::autofill_assistant::SelectorProto* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::autofill_assistant::SelectorProto* selector);
  ::autofill_assistant::SelectorProto* unsafe_arena_release_selector();

  // .autofill_assistant.ClientIdProto client_id = 5;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  void clear_element();
  ElementCase element_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.GetElementStatusProto)
 private:
  class _Internal;
  void set_has_selector();
  void set_has_client_id();

  inline bool has_element() const;
  inline void clear_has_element();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::GetElementStatusProto_ValueMatch* expected_value_match_;
  bool mismatch_should_fail_;
  int value_source_;
  union ElementUnion {
    constexpr ElementUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::SelectorProto* selector_;
    ::autofill_assistant::ClientIdProto* client_id_;
  } element_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ReleaseElementsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ReleaseElementsProto) */ {
 public:
  inline ReleaseElementsProto() : ReleaseElementsProto(nullptr) {}
  ~ReleaseElementsProto() override;
  explicit PROTOBUF_CONSTEXPR ReleaseElementsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseElementsProto(const ReleaseElementsProto& from);
  ReleaseElementsProto(ReleaseElementsProto&& from) noexcept
    : ReleaseElementsProto() {
    *this = ::std::move(from);
  }

  inline ReleaseElementsProto& operator=(const ReleaseElementsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseElementsProto& operator=(ReleaseElementsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReleaseElementsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseElementsProto* internal_default_instance() {
    return reinterpret_cast<const ReleaseElementsProto*>(
               &_ReleaseElementsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    178;

  friend void swap(ReleaseElementsProto& a, ReleaseElementsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ReleaseElementsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseElementsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseElementsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReleaseElementsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReleaseElementsProto& from);
  void MergeFrom(const ReleaseElementsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReleaseElementsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ReleaseElementsProto";
  }
  protected:
  explicit ReleaseElementsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 1,
  };
  // repeated .autofill_assistant.ClientIdProto client_ids = 1;
  int client_ids_size() const;
  private:
  int _internal_client_ids_size() const;
  public:
  void clear_client_ids();
  ::autofill_assistant::ClientIdProto* mutable_client_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientIdProto >*
      mutable_client_ids();
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_ids(int index) const;
  ::autofill_assistant::ClientIdProto* _internal_add_client_ids();
  public:
  const ::autofill_assistant::ClientIdProto& client_ids(int index) const;
  ::autofill_assistant::ClientIdProto* add_client_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientIdProto >&
      client_ids() const;

  // @@protoc_insertion_point(class_scope:autofill_assistant.ReleaseElementsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientIdProto > client_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DispatchJsEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DispatchJsEventProto) */ {
 public:
  inline DispatchJsEventProto() : DispatchJsEventProto(nullptr) {}
  ~DispatchJsEventProto() override;
  explicit PROTOBUF_CONSTEXPR DispatchJsEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DispatchJsEventProto(const DispatchJsEventProto& from);
  DispatchJsEventProto(DispatchJsEventProto&& from) noexcept
    : DispatchJsEventProto() {
    *this = ::std::move(from);
  }

  inline DispatchJsEventProto& operator=(const DispatchJsEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DispatchJsEventProto& operator=(DispatchJsEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DispatchJsEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DispatchJsEventProto* internal_default_instance() {
    return reinterpret_cast<const DispatchJsEventProto*>(
               &_DispatchJsEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    179;

  friend void swap(DispatchJsEventProto& a, DispatchJsEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DispatchJsEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DispatchJsEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DispatchJsEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DispatchJsEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DispatchJsEventProto& from);
  void MergeFrom(const DispatchJsEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DispatchJsEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DispatchJsEventProto";
  }
  protected:
  explicit DispatchJsEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.DispatchJsEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class JsFlowProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.JsFlowProto.Result) */ {
 public:
  inline JsFlowProto_Result() : JsFlowProto_Result(nullptr) {}
  ~JsFlowProto_Result() override;
  explicit PROTOBUF_CONSTEXPR JsFlowProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JsFlowProto_Result(const JsFlowProto_Result& from);
  JsFlowProto_Result(JsFlowProto_Result&& from) noexcept
    : JsFlowProto_Result() {
    *this = ::std::move(from);
  }

  inline JsFlowProto_Result& operator=(const JsFlowProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsFlowProto_Result& operator=(JsFlowProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JsFlowProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsFlowProto_Result* internal_default_instance() {
    return reinterpret_cast<const JsFlowProto_Result*>(
               &_JsFlowProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    180;

  friend void swap(JsFlowProto_Result& a, JsFlowProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(JsFlowProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsFlowProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsFlowProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsFlowProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JsFlowProto_Result& from);
  void MergeFrom(const JsFlowProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JsFlowProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.JsFlowProto.Result";
  }
  protected:
  explicit JsFlowProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultJsonFieldNumber = 1,
  };
  // optional string result_json = 1;
  bool has_result_json() const;
  private:
  bool _internal_has_result_json() const;
  public:
  void clear_result_json();
  const std::string& result_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_json();
  PROTOBUF_NODISCARD std::string* release_result_json();
  void set_allocated_result_json(std::string* result_json);
  private:
  const std::string& _internal_result_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_json(const std::string& value);
  std::string* _internal_mutable_result_json();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.JsFlowProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_json_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class JsFlowProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.JsFlowProto) */ {
 public:
  inline JsFlowProto() : JsFlowProto(nullptr) {}
  ~JsFlowProto() override;
  explicit PROTOBUF_CONSTEXPR JsFlowProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JsFlowProto(const JsFlowProto& from);
  JsFlowProto(JsFlowProto&& from) noexcept
    : JsFlowProto() {
    *this = ::std::move(from);
  }

  inline JsFlowProto& operator=(const JsFlowProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsFlowProto& operator=(JsFlowProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JsFlowProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsFlowProto* internal_default_instance() {
    return reinterpret_cast<const JsFlowProto*>(
               &_JsFlowProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    181;

  friend void swap(JsFlowProto& a, JsFlowProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(JsFlowProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsFlowProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsFlowProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsFlowProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JsFlowProto& from);
  void MergeFrom(const JsFlowProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JsFlowProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.JsFlowProto";
  }
  protected:
  explicit JsFlowProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef JsFlowProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kJsFlowFieldNumber = 1,
  };
  // optional string js_flow = 1;
  bool has_js_flow() const;
  private:
  bool _internal_has_js_flow() const;
  public:
  void clear_js_flow();
  const std::string& js_flow() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_js_flow(ArgT0&& arg0, ArgT... args);
  std::string* mutable_js_flow();
  PROTOBUF_NODISCARD std::string* release_js_flow();
  void set_allocated_js_flow(std::string* js_flow);
  private:
  const std::string& _internal_js_flow() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_js_flow(const std::string& value);
  std::string* _internal_mutable_js_flow();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.JsFlowProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr js_flow_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ExternalActionProto_ExternalCondition final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ExternalActionProto.ExternalCondition) */ {
 public:
  inline ExternalActionProto_ExternalCondition() : ExternalActionProto_ExternalCondition(nullptr) {}
  ~ExternalActionProto_ExternalCondition() override;
  explicit PROTOBUF_CONSTEXPR ExternalActionProto_ExternalCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalActionProto_ExternalCondition(const ExternalActionProto_ExternalCondition& from);
  ExternalActionProto_ExternalCondition(ExternalActionProto_ExternalCondition&& from) noexcept
    : ExternalActionProto_ExternalCondition() {
    *this = ::std::move(from);
  }

  inline ExternalActionProto_ExternalCondition& operator=(const ExternalActionProto_ExternalCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalActionProto_ExternalCondition& operator=(ExternalActionProto_ExternalCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExternalActionProto_ExternalCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalActionProto_ExternalCondition* internal_default_instance() {
    return reinterpret_cast<const ExternalActionProto_ExternalCondition*>(
               &_ExternalActionProto_ExternalCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    182;

  friend void swap(ExternalActionProto_ExternalCondition& a, ExternalActionProto_ExternalCondition& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExternalActionProto_ExternalCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalActionProto_ExternalCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalActionProto_ExternalCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalActionProto_ExternalCondition>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExternalActionProto_ExternalCondition& from);
  void MergeFrom(const ExternalActionProto_ExternalCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExternalActionProto_ExternalCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ExternalActionProto.ExternalCondition";
  }
  protected:
  explicit ExternalActionProto_ExternalCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementConditionFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ElementConditionProto element_condition = 2;
  bool has_element_condition() const;
  private:
  bool _internal_has_element_condition() const;
  public:
  void clear_element_condition();
  const ::autofill_assistant::ElementConditionProto& element_condition() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ElementConditionProto* release_element_condition();
  ::autofill_assistant::ElementConditionProto* mutable_element_condition();
  void set_allocated_element_condition(::autofill_assistant::ElementConditionProto* element_condition);
  private:
  const ::autofill_assistant::ElementConditionProto& _internal_element_condition() const;
  ::autofill_assistant::ElementConditionProto* _internal_mutable_element_condition();
  public:
  void unsafe_arena_set_allocated_element_condition(
      ::autofill_assistant::ElementConditionProto* element_condition);
  ::autofill_assistant::ElementConditionProto* unsafe_arena_release_element_condition();

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ExternalActionProto.ExternalCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ElementConditionProto* element_condition_;
  int32_t id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ExternalActionProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ExternalActionProto.Result) */ {
 public:
  inline ExternalActionProto_Result() : ExternalActionProto_Result(nullptr) {}
  ~ExternalActionProto_Result() override;
  explicit PROTOBUF_CONSTEXPR ExternalActionProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalActionProto_Result(const ExternalActionProto_Result& from);
  ExternalActionProto_Result(ExternalActionProto_Result&& from) noexcept
    : ExternalActionProto_Result() {
    *this = ::std::move(from);
  }

  inline ExternalActionProto_Result& operator=(const ExternalActionProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalActionProto_Result& operator=(ExternalActionProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExternalActionProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalActionProto_Result* internal_default_instance() {
    return reinterpret_cast<const ExternalActionProto_Result*>(
               &_ExternalActionProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    183;

  friend void swap(ExternalActionProto_Result& a, ExternalActionProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExternalActionProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalActionProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalActionProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalActionProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExternalActionProto_Result& from);
  void MergeFrom(const ExternalActionProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExternalActionProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ExternalActionProto.Result";
  }
  protected:
  explicit ExternalActionProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultInfoFieldNumber = 1,
  };
  // optional .autofill_assistant.external.ResultInfo result_info = 1;
  bool has_result_info() const;
  private:
  bool _internal_has_result_info() const;
  public:
  void clear_result_info();
  const ::autofill_assistant::external::ResultInfo& result_info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::external::ResultInfo* release_result_info();
  ::autofill_assistant::external::ResultInfo* mutable_result_info();
  void set_allocated_result_info(::autofill_assistant::external::ResultInfo* result_info);
  private:
  const ::autofill_assistant::external::ResultInfo& _internal_result_info() const;
  ::autofill_assistant::external::ResultInfo* _internal_mutable_result_info();
  public:
  void unsafe_arena_set_allocated_result_info(
      ::autofill_assistant::external::ResultInfo* result_info);
  ::autofill_assistant::external::ResultInfo* unsafe_arena_release_result_info();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ExternalActionProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::external::ResultInfo* result_info_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ExternalActionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ExternalActionProto) */ {
 public:
  inline ExternalActionProto() : ExternalActionProto(nullptr) {}
  ~ExternalActionProto() override;
  explicit PROTOBUF_CONSTEXPR ExternalActionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExternalActionProto(const ExternalActionProto& from);
  ExternalActionProto(ExternalActionProto&& from) noexcept
    : ExternalActionProto() {
    *this = ::std::move(from);
  }

  inline ExternalActionProto& operator=(const ExternalActionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalActionProto& operator=(ExternalActionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExternalActionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExternalActionProto* internal_default_instance() {
    return reinterpret_cast<const ExternalActionProto*>(
               &_ExternalActionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    184;

  friend void swap(ExternalActionProto& a, ExternalActionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExternalActionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExternalActionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExternalActionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExternalActionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExternalActionProto& from);
  void MergeFrom(const ExternalActionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExternalActionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ExternalActionProto";
  }
  protected:
  explicit ExternalActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExternalActionProto_ExternalCondition ExternalCondition;
  typedef ExternalActionProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 4,
    kInfoFieldNumber = 1,
    kShowTouchableAreaFieldNumber = 2,
    kAllowInterruptFieldNumber = 3,
  };
  // repeated .autofill_assistant.ExternalActionProto.ExternalCondition conditions = 4;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::autofill_assistant::ExternalActionProto_ExternalCondition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ExternalActionProto_ExternalCondition >*
      mutable_conditions();
  private:
  const ::autofill_assistant::ExternalActionProto_ExternalCondition& _internal_conditions(int index) const;
  ::autofill_assistant::ExternalActionProto_ExternalCondition* _internal_add_conditions();
  public:
  const ::autofill_assistant::ExternalActionProto_ExternalCondition& conditions(int index) const;
  ::autofill_assistant::ExternalActionProto_ExternalCondition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ExternalActionProto_ExternalCondition >&
      conditions() const;

  // optional .autofill_assistant.external.ActionInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::autofill_assistant::external::ActionInfo& info() const;
  PROTOBUF_NODISCARD ::autofill_assistant::external::ActionInfo* release_info();
  ::autofill_assistant::external::ActionInfo* mutable_info();
  void set_allocated_info(::autofill_assistant::external::ActionInfo* info);
  private:
  const ::autofill_assistant::external::ActionInfo& _internal_info() const;
  ::autofill_assistant::external::ActionInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::autofill_assistant::external::ActionInfo* info);
  ::autofill_assistant::external::ActionInfo* unsafe_arena_release_info();

  // optional bool show_touchable_area = 2;
  bool has_show_touchable_area() const;
  private:
  bool _internal_has_show_touchable_area() const;
  public:
  void clear_show_touchable_area();
  bool show_touchable_area() const;
  void set_show_touchable_area(bool value);
  private:
  bool _internal_show_touchable_area() const;
  void _internal_set_show_touchable_area(bool value);
  public:

  // optional bool allow_interrupt = 3;
  bool has_allow_interrupt() const;
  private:
  bool _internal_has_allow_interrupt() const;
  public:
  void clear_allow_interrupt();
  bool allow_interrupt() const;
  void set_allow_interrupt(bool value);
  private:
  bool _internal_allow_interrupt() const;
  void _internal_set_allow_interrupt(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ExternalActionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ExternalActionProto_ExternalCondition > conditions_;
  ::autofill_assistant::external::ActionInfo* info_;
  bool show_touchable_area_;
  bool allow_interrupt_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FieldTrialProto

// optional string trial_name = 1;
inline bool FieldTrialProto::_internal_has_trial_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FieldTrialProto::has_trial_name() const {
  return _internal_has_trial_name();
}
inline void FieldTrialProto::clear_trial_name() {
  trial_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FieldTrialProto::trial_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FieldTrialProto.trial_name)
  return _internal_trial_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldTrialProto::set_trial_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 trial_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.FieldTrialProto.trial_name)
}
inline std::string* FieldTrialProto::mutable_trial_name() {
  std::string* _s = _internal_mutable_trial_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FieldTrialProto.trial_name)
  return _s;
}
inline const std::string& FieldTrialProto::_internal_trial_name() const {
  return trial_name_.Get();
}
inline void FieldTrialProto::_internal_set_trial_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  trial_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldTrialProto::_internal_mutable_trial_name() {
  _has_bits_[0] |= 0x00000001u;
  return trial_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldTrialProto::release_trial_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FieldTrialProto.trial_name)
  if (!_internal_has_trial_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = trial_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trial_name_.IsDefault()) {
    trial_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FieldTrialProto::set_allocated_trial_name(std::string* trial_name) {
  if (trial_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trial_name_.SetAllocated(trial_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trial_name_.IsDefault()) {
    trial_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FieldTrialProto.trial_name)
}

// optional string group_name = 2;
inline bool FieldTrialProto::_internal_has_group_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FieldTrialProto::has_group_name() const {
  return _internal_has_group_name();
}
inline void FieldTrialProto::clear_group_name() {
  group_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FieldTrialProto::group_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FieldTrialProto.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldTrialProto::set_group_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 group_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.FieldTrialProto.group_name)
}
inline std::string* FieldTrialProto::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FieldTrialProto.group_name)
  return _s;
}
inline const std::string& FieldTrialProto::_internal_group_name() const {
  return group_name_.Get();
}
inline void FieldTrialProto::_internal_set_group_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldTrialProto::_internal_mutable_group_name() {
  _has_bits_[0] |= 0x00000002u;
  return group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldTrialProto::release_group_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FieldTrialProto.group_name)
  if (!_internal_has_group_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = group_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_name_.IsDefault()) {
    group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FieldTrialProto::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_name_.IsDefault()) {
    group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FieldTrialProto.group_name)
}

// -------------------------------------------------------------------

// ClientContextProto_Chrome

// optional string chrome_version = 1;
inline bool ClientContextProto_Chrome::_internal_has_chrome_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientContextProto_Chrome::has_chrome_version() const {
  return _internal_has_chrome_version();
}
inline void ClientContextProto_Chrome::clear_chrome_version() {
  chrome_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientContextProto_Chrome::chrome_version() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.Chrome.chrome_version)
  return _internal_chrome_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientContextProto_Chrome::set_chrome_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 chrome_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.Chrome.chrome_version)
}
inline std::string* ClientContextProto_Chrome::mutable_chrome_version() {
  std::string* _s = _internal_mutable_chrome_version();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.Chrome.chrome_version)
  return _s;
}
inline const std::string& ClientContextProto_Chrome::_internal_chrome_version() const {
  return chrome_version_.Get();
}
inline void ClientContextProto_Chrome::_internal_set_chrome_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  chrome_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientContextProto_Chrome::_internal_mutable_chrome_version() {
  _has_bits_[0] |= 0x00000001u;
  return chrome_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientContextProto_Chrome::release_chrome_version() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.Chrome.chrome_version)
  if (!_internal_has_chrome_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = chrome_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chrome_version_.IsDefault()) {
    chrome_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientContextProto_Chrome::set_allocated_chrome_version(std::string* chrome_version) {
  if (chrome_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chrome_version_.SetAllocated(chrome_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chrome_version_.IsDefault()) {
    chrome_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.Chrome.chrome_version)
}

// repeated .autofill_assistant.FieldTrialProto active_field_trials = 2;
inline int ClientContextProto_Chrome::_internal_active_field_trials_size() const {
  return active_field_trials_.size();
}
inline int ClientContextProto_Chrome::active_field_trials_size() const {
  return _internal_active_field_trials_size();
}
inline void ClientContextProto_Chrome::clear_active_field_trials() {
  active_field_trials_.Clear();
}
inline ::autofill_assistant::FieldTrialProto* ClientContextProto_Chrome::mutable_active_field_trials(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.Chrome.active_field_trials)
  return active_field_trials_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FieldTrialProto >*
ClientContextProto_Chrome::mutable_active_field_trials() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ClientContextProto.Chrome.active_field_trials)
  return &active_field_trials_;
}
inline const ::autofill_assistant::FieldTrialProto& ClientContextProto_Chrome::_internal_active_field_trials(int index) const {
  return active_field_trials_.Get(index);
}
inline const ::autofill_assistant::FieldTrialProto& ClientContextProto_Chrome::active_field_trials(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.Chrome.active_field_trials)
  return _internal_active_field_trials(index);
}
inline ::autofill_assistant::FieldTrialProto* ClientContextProto_Chrome::_internal_add_active_field_trials() {
  return active_field_trials_.Add();
}
inline ::autofill_assistant::FieldTrialProto* ClientContextProto_Chrome::add_active_field_trials() {
  ::autofill_assistant::FieldTrialProto* _add = _internal_add_active_field_trials();
  // @@protoc_insertion_point(field_add:autofill_assistant.ClientContextProto.Chrome.active_field_trials)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FieldTrialProto >&
ClientContextProto_Chrome::active_field_trials() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ClientContextProto.Chrome.active_field_trials)
  return active_field_trials_;
}

// -------------------------------------------------------------------

// ClientContextProto_DeviceContextProto_VersionProto

// optional int32 sdk_int = 1;
inline bool ClientContextProto_DeviceContextProto_VersionProto::_internal_has_sdk_int() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientContextProto_DeviceContextProto_VersionProto::has_sdk_int() const {
  return _internal_has_sdk_int();
}
inline void ClientContextProto_DeviceContextProto_VersionProto::clear_sdk_int() {
  sdk_int_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ClientContextProto_DeviceContextProto_VersionProto::_internal_sdk_int() const {
  return sdk_int_;
}
inline int32_t ClientContextProto_DeviceContextProto_VersionProto::sdk_int() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto.sdk_int)
  return _internal_sdk_int();
}
inline void ClientContextProto_DeviceContextProto_VersionProto::_internal_set_sdk_int(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  sdk_int_ = value;
}
inline void ClientContextProto_DeviceContextProto_VersionProto::set_sdk_int(int32_t value) {
  _internal_set_sdk_int(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto.sdk_int)
}

// -------------------------------------------------------------------

// ClientContextProto_DeviceContextProto

// optional .autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto version = 1;
inline bool ClientContextProto_DeviceContextProto::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || version_ != nullptr);
  return value;
}
inline bool ClientContextProto_DeviceContextProto::has_version() const {
  return _internal_has_version();
}
inline void ClientContextProto_DeviceContextProto::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto& ClientContextProto_DeviceContextProto::_internal_version() const {
  const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* p = version_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto&>(
      ::autofill_assistant::_ClientContextProto_DeviceContextProto_VersionProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto& ClientContextProto_DeviceContextProto::version() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.DeviceContextProto.version)
  return _internal_version();
}
inline void ClientContextProto_DeviceContextProto::unsafe_arena_set_allocated_version(
    ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientContextProto.DeviceContextProto.version)
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* ClientContextProto_DeviceContextProto::release_version() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* temp = version_;
  version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* ClientContextProto_DeviceContextProto::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.DeviceContextProto.version)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* ClientContextProto_DeviceContextProto::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto>(GetArenaForAllocation());
    version_ = p;
  }
  return version_;
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* ClientContextProto_DeviceContextProto::mutable_version() {
  ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.DeviceContextProto.version)
  return _msg;
}
inline void ClientContextProto_DeviceContextProto::set_allocated_version(::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.DeviceContextProto.version)
}

// optional string manufacturer = 2;
inline bool ClientContextProto_DeviceContextProto::_internal_has_manufacturer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientContextProto_DeviceContextProto::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void ClientContextProto_DeviceContextProto::clear_manufacturer() {
  manufacturer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientContextProto_DeviceContextProto::manufacturer() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.DeviceContextProto.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientContextProto_DeviceContextProto::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.DeviceContextProto.manufacturer)
}
inline std::string* ClientContextProto_DeviceContextProto::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.DeviceContextProto.manufacturer)
  return _s;
}
inline const std::string& ClientContextProto_DeviceContextProto::_internal_manufacturer() const {
  return manufacturer_.Get();
}
inline void ClientContextProto_DeviceContextProto::_internal_set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientContextProto_DeviceContextProto::_internal_mutable_manufacturer() {
  _has_bits_[0] |= 0x00000001u;
  return manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientContextProto_DeviceContextProto::release_manufacturer() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.DeviceContextProto.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientContextProto_DeviceContextProto::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.DeviceContextProto.manufacturer)
}

// optional string model = 3;
inline bool ClientContextProto_DeviceContextProto::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientContextProto_DeviceContextProto::has_model() const {
  return _internal_has_model();
}
inline void ClientContextProto_DeviceContextProto::clear_model() {
  model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientContextProto_DeviceContextProto::model() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.DeviceContextProto.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientContextProto_DeviceContextProto::set_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.DeviceContextProto.model)
}
inline std::string* ClientContextProto_DeviceContextProto::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.DeviceContextProto.model)
  return _s;
}
inline const std::string& ClientContextProto_DeviceContextProto::_internal_model() const {
  return model_.Get();
}
inline void ClientContextProto_DeviceContextProto::_internal_set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientContextProto_DeviceContextProto::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000002u;
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientContextProto_DeviceContextProto::release_model() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.DeviceContextProto.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientContextProto_DeviceContextProto::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.DeviceContextProto.model)
}

// -------------------------------------------------------------------

// ClientContextProto_WindowSize

// optional int32 height_pixels = 1;
inline bool ClientContextProto_WindowSize::_internal_has_height_pixels() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientContextProto_WindowSize::has_height_pixels() const {
  return _internal_has_height_pixels();
}
inline void ClientContextProto_WindowSize::clear_height_pixels() {
  height_pixels_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ClientContextProto_WindowSize::_internal_height_pixels() const {
  return height_pixels_;
}
inline int32_t ClientContextProto_WindowSize::height_pixels() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.WindowSize.height_pixels)
  return _internal_height_pixels();
}
inline void ClientContextProto_WindowSize::_internal_set_height_pixels(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  height_pixels_ = value;
}
inline void ClientContextProto_WindowSize::set_height_pixels(int32_t value) {
  _internal_set_height_pixels(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.WindowSize.height_pixels)
}

// optional int32 width_pixels = 2;
inline bool ClientContextProto_WindowSize::_internal_has_width_pixels() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientContextProto_WindowSize::has_width_pixels() const {
  return _internal_has_width_pixels();
}
inline void ClientContextProto_WindowSize::clear_width_pixels() {
  width_pixels_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ClientContextProto_WindowSize::_internal_width_pixels() const {
  return width_pixels_;
}
inline int32_t ClientContextProto_WindowSize::width_pixels() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.WindowSize.width_pixels)
  return _internal_width_pixels();
}
inline void ClientContextProto_WindowSize::_internal_set_width_pixels(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  width_pixels_ = value;
}
inline void ClientContextProto_WindowSize::set_width_pixels(int32_t value) {
  _internal_set_width_pixels(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.WindowSize.width_pixels)
}

// -------------------------------------------------------------------

// ClientContextProto_AnnotateDomModelContextProto

// optional int64 model_version = 1;
inline bool ClientContextProto_AnnotateDomModelContextProto::_internal_has_model_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientContextProto_AnnotateDomModelContextProto::has_model_version() const {
  return _internal_has_model_version();
}
inline void ClientContextProto_AnnotateDomModelContextProto::clear_model_version() {
  model_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t ClientContextProto_AnnotateDomModelContextProto::_internal_model_version() const {
  return model_version_;
}
inline int64_t ClientContextProto_AnnotateDomModelContextProto::model_version() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto.model_version)
  return _internal_model_version();
}
inline void ClientContextProto_AnnotateDomModelContextProto::_internal_set_model_version(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  model_version_ = value;
}
inline void ClientContextProto_AnnotateDomModelContextProto::set_model_version(int64_t value) {
  _internal_set_model_version(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto.model_version)
}

// optional bool force_semantic_selection = 2;
inline bool ClientContextProto_AnnotateDomModelContextProto::_internal_has_force_semantic_selection() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientContextProto_AnnotateDomModelContextProto::has_force_semantic_selection() const {
  return _internal_has_force_semantic_selection();
}
inline void ClientContextProto_AnnotateDomModelContextProto::clear_force_semantic_selection() {
  force_semantic_selection_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ClientContextProto_AnnotateDomModelContextProto::_internal_force_semantic_selection() const {
  return force_semantic_selection_;
}
inline bool ClientContextProto_AnnotateDomModelContextProto::force_semantic_selection() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto.force_semantic_selection)
  return _internal_force_semantic_selection();
}
inline void ClientContextProto_AnnotateDomModelContextProto::_internal_set_force_semantic_selection(bool value) {
  _has_bits_[0] |= 0x00000002u;
  force_semantic_selection_ = value;
}
inline void ClientContextProto_AnnotateDomModelContextProto::set_force_semantic_selection(bool value) {
  _internal_set_force_semantic_selection(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto.force_semantic_selection)
}

// -------------------------------------------------------------------

// ClientContextProto

// .autofill_assistant.ClientContextProto.Chrome chrome = 1;
inline bool ClientContextProto::_internal_has_chrome() const {
  return client_case() == kChrome;
}
inline bool ClientContextProto::has_chrome() const {
  return _internal_has_chrome();
}
inline void ClientContextProto::set_has_chrome() {
  _oneof_case_[0] = kChrome;
}
inline void ClientContextProto::clear_chrome() {
  if (_internal_has_chrome()) {
    if (GetArenaForAllocation() == nullptr) {
      delete client_.chrome_;
    }
    clear_has_client();
  }
}
inline ::autofill_assistant::ClientContextProto_Chrome* ClientContextProto::release_chrome() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.chrome)
  if (_internal_has_chrome()) {
    clear_has_client();
    ::autofill_assistant::ClientContextProto_Chrome* temp = client_.chrome_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    client_.chrome_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ClientContextProto_Chrome& ClientContextProto::_internal_chrome() const {
  return _internal_has_chrome()
      ? *client_.chrome_
      : reinterpret_cast< ::autofill_assistant::ClientContextProto_Chrome&>(::autofill_assistant::_ClientContextProto_Chrome_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto_Chrome& ClientContextProto::chrome() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.chrome)
  return _internal_chrome();
}
inline ::autofill_assistant::ClientContextProto_Chrome* ClientContextProto::unsafe_arena_release_chrome() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ClientContextProto.chrome)
  if (_internal_has_chrome()) {
    clear_has_client();
    ::autofill_assistant::ClientContextProto_Chrome* temp = client_.chrome_;
    client_.chrome_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientContextProto::unsafe_arena_set_allocated_chrome(::autofill_assistant::ClientContextProto_Chrome* chrome) {
  clear_client();
  if (chrome) {
    set_has_chrome();
    client_.chrome_ = chrome;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientContextProto.chrome)
}
inline ::autofill_assistant::ClientContextProto_Chrome* ClientContextProto::_internal_mutable_chrome() {
  if (!_internal_has_chrome()) {
    clear_client();
    set_has_chrome();
    client_.chrome_ = CreateMaybeMessage< ::autofill_assistant::ClientContextProto_Chrome >(GetArenaForAllocation());
  }
  return client_.chrome_;
}
inline ::autofill_assistant::ClientContextProto_Chrome* ClientContextProto::mutable_chrome() {
  ::autofill_assistant::ClientContextProto_Chrome* _msg = _internal_mutable_chrome();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.chrome)
  return _msg;
}

// optional string locale = 5;
inline bool ClientContextProto::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientContextProto::has_locale() const {
  return _internal_has_locale();
}
inline void ClientContextProto::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientContextProto::locale() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientContextProto::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.locale)
}
inline std::string* ClientContextProto::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.locale)
  return _s;
}
inline const std::string& ClientContextProto::_internal_locale() const {
  return locale_.Get();
}
inline void ClientContextProto::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientContextProto::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientContextProto::release_locale() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientContextProto::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.locale)
}

// optional string country = 6;
inline bool ClientContextProto::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientContextProto::has_country() const {
  return _internal_has_country();
}
inline void ClientContextProto::clear_country() {
  country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientContextProto::country() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientContextProto::set_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 country_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.country)
}
inline std::string* ClientContextProto::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.country)
  return _s;
}
inline const std::string& ClientContextProto::_internal_country() const {
  return country_.Get();
}
inline void ClientContextProto::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  country_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientContextProto::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000002u;
  return country_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientContextProto::release_country() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = country_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault()) {
    country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientContextProto::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  country_.SetAllocated(country, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault()) {
    country_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.country)
}

// optional string experiment_ids = 7;
inline bool ClientContextProto::_internal_has_experiment_ids() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientContextProto::has_experiment_ids() const {
  return _internal_has_experiment_ids();
}
inline void ClientContextProto::clear_experiment_ids() {
  experiment_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientContextProto::experiment_ids() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.experiment_ids)
  return _internal_experiment_ids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientContextProto::set_experiment_ids(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 experiment_ids_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.experiment_ids)
}
inline std::string* ClientContextProto::mutable_experiment_ids() {
  std::string* _s = _internal_mutable_experiment_ids();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.experiment_ids)
  return _s;
}
inline const std::string& ClientContextProto::_internal_experiment_ids() const {
  return experiment_ids_.Get();
}
inline void ClientContextProto::_internal_set_experiment_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  experiment_ids_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientContextProto::_internal_mutable_experiment_ids() {
  _has_bits_[0] |= 0x00000004u;
  return experiment_ids_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientContextProto::release_experiment_ids() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.experiment_ids)
  if (!_internal_has_experiment_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = experiment_ids_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (experiment_ids_.IsDefault()) {
    experiment_ids_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientContextProto::set_allocated_experiment_ids(std::string* experiment_ids) {
  if (experiment_ids != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  experiment_ids_.SetAllocated(experiment_ids, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (experiment_ids_.IsDefault()) {
    experiment_ids_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.experiment_ids)
}

// optional bool is_cct = 8;
inline bool ClientContextProto::_internal_has_is_cct() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientContextProto::has_is_cct() const {
  return _internal_has_is_cct();
}
inline void ClientContextProto::clear_is_cct() {
  is_cct_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ClientContextProto::_internal_is_cct() const {
  return is_cct_;
}
inline bool ClientContextProto::is_cct() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.is_cct)
  return _internal_is_cct();
}
inline void ClientContextProto::_internal_set_is_cct(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_cct_ = value;
}
inline void ClientContextProto::set_is_cct(bool value) {
  _internal_set_is_cct(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.is_cct)
}

// optional bool is_onboarding_shown = 10;
inline bool ClientContextProto::_internal_has_is_onboarding_shown() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClientContextProto::has_is_onboarding_shown() const {
  return _internal_has_is_onboarding_shown();
}
inline void ClientContextProto::clear_is_onboarding_shown() {
  is_onboarding_shown_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ClientContextProto::_internal_is_onboarding_shown() const {
  return is_onboarding_shown_;
}
inline bool ClientContextProto::is_onboarding_shown() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.is_onboarding_shown)
  return _internal_is_onboarding_shown();
}
inline void ClientContextProto::_internal_set_is_onboarding_shown(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_onboarding_shown_ = value;
}
inline void ClientContextProto::set_is_onboarding_shown(bool value) {
  _internal_set_is_onboarding_shown(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.is_onboarding_shown)
}

// optional bool is_direct_action = 9;
inline bool ClientContextProto::_internal_has_is_direct_action() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ClientContextProto::has_is_direct_action() const {
  return _internal_has_is_direct_action();
}
inline void ClientContextProto::clear_is_direct_action() {
  is_direct_action_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ClientContextProto::_internal_is_direct_action() const {
  return is_direct_action_;
}
inline bool ClientContextProto::is_direct_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.is_direct_action)
  return _internal_is_direct_action();
}
inline void ClientContextProto::_internal_set_is_direct_action(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_direct_action_ = value;
}
inline void ClientContextProto::set_is_direct_action(bool value) {
  _internal_set_is_direct_action(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.is_direct_action)
}

// optional bool is_in_chrome_triggered = 17;
inline bool ClientContextProto::_internal_has_is_in_chrome_triggered() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ClientContextProto::has_is_in_chrome_triggered() const {
  return _internal_has_is_in_chrome_triggered();
}
inline void ClientContextProto::clear_is_in_chrome_triggered() {
  is_in_chrome_triggered_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ClientContextProto::_internal_is_in_chrome_triggered() const {
  return is_in_chrome_triggered_;
}
inline bool ClientContextProto::is_in_chrome_triggered() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.is_in_chrome_triggered)
  return _internal_is_in_chrome_triggered();
}
inline void ClientContextProto::_internal_set_is_in_chrome_triggered(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_in_chrome_triggered_ = value;
}
inline void ClientContextProto::set_is_in_chrome_triggered(bool value) {
  _internal_set_is_in_chrome_triggered(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.is_in_chrome_triggered)
}

// optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 18;
inline bool ClientContextProto::_internal_has_trigger_ui_type() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ClientContextProto::has_trigger_ui_type() const {
  return _internal_has_trigger_ui_type();
}
inline void ClientContextProto::clear_trigger_ui_type() {
  trigger_ui_type_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::autofill_assistant::TriggerScriptProto_TriggerUIType ClientContextProto::_internal_trigger_ui_type() const {
  return static_cast< ::autofill_assistant::TriggerScriptProto_TriggerUIType >(trigger_ui_type_);
}
inline ::autofill_assistant::TriggerScriptProto_TriggerUIType ClientContextProto::trigger_ui_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.trigger_ui_type)
  return _internal_trigger_ui_type();
}
inline void ClientContextProto::_internal_set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value) {
  assert(::autofill_assistant::TriggerScriptProto_TriggerUIType_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  trigger_ui_type_ = value;
}
inline void ClientContextProto::set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value) {
  _internal_set_trigger_ui_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.trigger_ui_type)
}

// optional .autofill_assistant.ClientContextProto.DeviceContextProto device_context = 11;
inline bool ClientContextProto::_internal_has_device_context() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || device_context_ != nullptr);
  return value;
}
inline bool ClientContextProto::has_device_context() const {
  return _internal_has_device_context();
}
inline void ClientContextProto::clear_device_context() {
  if (device_context_ != nullptr) device_context_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::ClientContextProto_DeviceContextProto& ClientContextProto::_internal_device_context() const {
  const ::autofill_assistant::ClientContextProto_DeviceContextProto* p = device_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto_DeviceContextProto&>(
      ::autofill_assistant::_ClientContextProto_DeviceContextProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto_DeviceContextProto& ClientContextProto::device_context() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.device_context)
  return _internal_device_context();
}
inline void ClientContextProto::unsafe_arena_set_allocated_device_context(
    ::autofill_assistant::ClientContextProto_DeviceContextProto* device_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_context_);
  }
  device_context_ = device_context;
  if (device_context) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientContextProto.device_context)
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto* ClientContextProto::release_device_context() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientContextProto_DeviceContextProto* temp = device_context_;
  device_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto* ClientContextProto::unsafe_arena_release_device_context() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.device_context)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientContextProto_DeviceContextProto* temp = device_context_;
  device_context_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto* ClientContextProto::_internal_mutable_device_context() {
  _has_bits_[0] |= 0x00000008u;
  if (device_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto_DeviceContextProto>(GetArenaForAllocation());
    device_context_ = p;
  }
  return device_context_;
}
inline ::autofill_assistant::ClientContextProto_DeviceContextProto* ClientContextProto::mutable_device_context() {
  ::autofill_assistant::ClientContextProto_DeviceContextProto* _msg = _internal_mutable_device_context();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.device_context)
  return _msg;
}
inline void ClientContextProto::set_allocated_device_context(::autofill_assistant::ClientContextProto_DeviceContextProto* device_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_context_;
  }
  if (device_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_context);
    if (message_arena != submessage_arena) {
      device_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_context_ = device_context;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.device_context)
}

// optional .autofill_assistant.ClientContextProto.AccountsMatchingStatus accounts_matching_status = 12;
inline bool ClientContextProto::_internal_has_accounts_matching_status() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ClientContextProto::has_accounts_matching_status() const {
  return _internal_has_accounts_matching_status();
}
inline void ClientContextProto::clear_accounts_matching_status() {
  accounts_matching_status_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::autofill_assistant::ClientContextProto_AccountsMatchingStatus ClientContextProto::_internal_accounts_matching_status() const {
  return static_cast< ::autofill_assistant::ClientContextProto_AccountsMatchingStatus >(accounts_matching_status_);
}
inline ::autofill_assistant::ClientContextProto_AccountsMatchingStatus ClientContextProto::accounts_matching_status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.accounts_matching_status)
  return _internal_accounts_matching_status();
}
inline void ClientContextProto::_internal_set_accounts_matching_status(::autofill_assistant::ClientContextProto_AccountsMatchingStatus value) {
  assert(::autofill_assistant::ClientContextProto_AccountsMatchingStatus_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  accounts_matching_status_ = value;
}
inline void ClientContextProto::set_accounts_matching_status(::autofill_assistant::ClientContextProto_AccountsMatchingStatus value) {
  _internal_set_accounts_matching_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.accounts_matching_status)
}

// optional bool accessibility_enabled = 13;
inline bool ClientContextProto::_internal_has_accessibility_enabled() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ClientContextProto::has_accessibility_enabled() const {
  return _internal_has_accessibility_enabled();
}
inline void ClientContextProto::clear_accessibility_enabled() {
  accessibility_enabled_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ClientContextProto::_internal_accessibility_enabled() const {
  return accessibility_enabled_;
}
inline bool ClientContextProto::accessibility_enabled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.accessibility_enabled)
  return _internal_accessibility_enabled();
}
inline void ClientContextProto::_internal_set_accessibility_enabled(bool value) {
  _has_bits_[0] |= 0x00004000u;
  accessibility_enabled_ = value;
}
inline void ClientContextProto::set_accessibility_enabled(bool value) {
  _internal_set_accessibility_enabled(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.accessibility_enabled)
}

// optional .autofill_assistant.ClientContextProto.SignedIntoChromeStatus signed_into_chrome_status = 14;
inline bool ClientContextProto::_internal_has_signed_into_chrome_status() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ClientContextProto::has_signed_into_chrome_status() const {
  return _internal_has_signed_into_chrome_status();
}
inline void ClientContextProto::clear_signed_into_chrome_status() {
  signed_into_chrome_status_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::autofill_assistant::ClientContextProto_SignedIntoChromeStatus ClientContextProto::_internal_signed_into_chrome_status() const {
  return static_cast< ::autofill_assistant::ClientContextProto_SignedIntoChromeStatus >(signed_into_chrome_status_);
}
inline ::autofill_assistant::ClientContextProto_SignedIntoChromeStatus ClientContextProto::signed_into_chrome_status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.signed_into_chrome_status)
  return _internal_signed_into_chrome_status();
}
inline void ClientContextProto::_internal_set_signed_into_chrome_status(::autofill_assistant::ClientContextProto_SignedIntoChromeStatus value) {
  assert(::autofill_assistant::ClientContextProto_SignedIntoChromeStatus_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  signed_into_chrome_status_ = value;
}
inline void ClientContextProto::set_signed_into_chrome_status(::autofill_assistant::ClientContextProto_SignedIntoChromeStatus value) {
  _internal_set_signed_into_chrome_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.signed_into_chrome_status)
}

// optional .autofill_assistant.ClientContextProto.WindowSize window_size = 15;
inline bool ClientContextProto::_internal_has_window_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || window_size_ != nullptr);
  return value;
}
inline bool ClientContextProto::has_window_size() const {
  return _internal_has_window_size();
}
inline void ClientContextProto::clear_window_size() {
  if (window_size_ != nullptr) window_size_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill_assistant::ClientContextProto_WindowSize& ClientContextProto::_internal_window_size() const {
  const ::autofill_assistant::ClientContextProto_WindowSize* p = window_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto_WindowSize&>(
      ::autofill_assistant::_ClientContextProto_WindowSize_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto_WindowSize& ClientContextProto::window_size() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.window_size)
  return _internal_window_size();
}
inline void ClientContextProto::unsafe_arena_set_allocated_window_size(
    ::autofill_assistant::ClientContextProto_WindowSize* window_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_size_);
  }
  window_size_ = window_size;
  if (window_size) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientContextProto.window_size)
}
inline ::autofill_assistant::ClientContextProto_WindowSize* ClientContextProto::release_window_size() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ClientContextProto_WindowSize* temp = window_size_;
  window_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto_WindowSize* ClientContextProto::unsafe_arena_release_window_size() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.window_size)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ClientContextProto_WindowSize* temp = window_size_;
  window_size_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto_WindowSize* ClientContextProto::_internal_mutable_window_size() {
  _has_bits_[0] |= 0x00000010u;
  if (window_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto_WindowSize>(GetArenaForAllocation());
    window_size_ = p;
  }
  return window_size_;
}
inline ::autofill_assistant::ClientContextProto_WindowSize* ClientContextProto::mutable_window_size() {
  ::autofill_assistant::ClientContextProto_WindowSize* _msg = _internal_mutable_window_size();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.window_size)
  return _msg;
}
inline void ClientContextProto::set_allocated_window_size(::autofill_assistant::ClientContextProto_WindowSize* window_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_size_;
  }
  if (window_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(window_size);
    if (message_arena != submessage_arena) {
      window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  window_size_ = window_size;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.window_size)
}

// optional .autofill_assistant.ClientContextProto.ScreenOrientation screen_orientation = 16;
inline bool ClientContextProto::_internal_has_screen_orientation() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ClientContextProto::has_screen_orientation() const {
  return _internal_has_screen_orientation();
}
inline void ClientContextProto::clear_screen_orientation() {
  screen_orientation_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::autofill_assistant::ClientContextProto_ScreenOrientation ClientContextProto::_internal_screen_orientation() const {
  return static_cast< ::autofill_assistant::ClientContextProto_ScreenOrientation >(screen_orientation_);
}
inline ::autofill_assistant::ClientContextProto_ScreenOrientation ClientContextProto::screen_orientation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.screen_orientation)
  return _internal_screen_orientation();
}
inline void ClientContextProto::_internal_set_screen_orientation(::autofill_assistant::ClientContextProto_ScreenOrientation value) {
  assert(::autofill_assistant::ClientContextProto_ScreenOrientation_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  screen_orientation_ = value;
}
inline void ClientContextProto::set_screen_orientation(::autofill_assistant::ClientContextProto_ScreenOrientation value) {
  _internal_set_screen_orientation(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.screen_orientation)
}

// optional .autofill_assistant.ClientContextProto.PlatformType platform_type = 20;
inline bool ClientContextProto::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ClientContextProto::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void ClientContextProto::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::autofill_assistant::ClientContextProto_PlatformType ClientContextProto::_internal_platform_type() const {
  return static_cast< ::autofill_assistant::ClientContextProto_PlatformType >(platform_type_);
}
inline ::autofill_assistant::ClientContextProto_PlatformType ClientContextProto::platform_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.platform_type)
  return _internal_platform_type();
}
inline void ClientContextProto::_internal_set_platform_type(::autofill_assistant::ClientContextProto_PlatformType value) {
  assert(::autofill_assistant::ClientContextProto_PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  platform_type_ = value;
}
inline void ClientContextProto::set_platform_type(::autofill_assistant::ClientContextProto_PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.platform_type)
}

// optional .autofill_assistant.ClientContextProto.AnnotateDomModelContextProto annotate_dom_model_context = 22;
inline bool ClientContextProto::_internal_has_annotate_dom_model_context() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || annotate_dom_model_context_ != nullptr);
  return value;
}
inline bool ClientContextProto::has_annotate_dom_model_context() const {
  return _internal_has_annotate_dom_model_context();
}
inline void ClientContextProto::clear_annotate_dom_model_context() {
  if (annotate_dom_model_context_ != nullptr) annotate_dom_model_context_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto& ClientContextProto::_internal_annotate_dom_model_context() const {
  const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* p = annotate_dom_model_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto&>(
      ::autofill_assistant::_ClientContextProto_AnnotateDomModelContextProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto& ClientContextProto::annotate_dom_model_context() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.annotate_dom_model_context)
  return _internal_annotate_dom_model_context();
}
inline void ClientContextProto::unsafe_arena_set_allocated_annotate_dom_model_context(
    ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* annotate_dom_model_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotate_dom_model_context_);
  }
  annotate_dom_model_context_ = annotate_dom_model_context;
  if (annotate_dom_model_context) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientContextProto.annotate_dom_model_context)
}
inline ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* ClientContextProto::release_annotate_dom_model_context() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* temp = annotate_dom_model_context_;
  annotate_dom_model_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* ClientContextProto::unsafe_arena_release_annotate_dom_model_context() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientContextProto.annotate_dom_model_context)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* temp = annotate_dom_model_context_;
  annotate_dom_model_context_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* ClientContextProto::_internal_mutable_annotate_dom_model_context() {
  _has_bits_[0] |= 0x00000020u;
  if (annotate_dom_model_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto>(GetArenaForAllocation());
    annotate_dom_model_context_ = p;
  }
  return annotate_dom_model_context_;
}
inline ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* ClientContextProto::mutable_annotate_dom_model_context() {
  ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* _msg = _internal_mutable_annotate_dom_model_context();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientContextProto.annotate_dom_model_context)
  return _msg;
}
inline void ClientContextProto::set_allocated_annotate_dom_model_context(::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto* annotate_dom_model_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete annotate_dom_model_context_;
  }
  if (annotate_dom_model_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotate_dom_model_context);
    if (message_arena != submessage_arena) {
      annotate_dom_model_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotate_dom_model_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  annotate_dom_model_context_ = annotate_dom_model_context;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.annotate_dom_model_context)
}

// optional bool js_flow_library_loaded = 23;
inline bool ClientContextProto::_internal_has_js_flow_library_loaded() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ClientContextProto::has_js_flow_library_loaded() const {
  return _internal_has_js_flow_library_loaded();
}
inline void ClientContextProto::clear_js_flow_library_loaded() {
  js_flow_library_loaded_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool ClientContextProto::_internal_js_flow_library_loaded() const {
  return js_flow_library_loaded_;
}
inline bool ClientContextProto::js_flow_library_loaded() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientContextProto.js_flow_library_loaded)
  return _internal_js_flow_library_loaded();
}
inline void ClientContextProto::_internal_set_js_flow_library_loaded(bool value) {
  _has_bits_[0] |= 0x00008000u;
  js_flow_library_loaded_ = value;
}
inline void ClientContextProto::set_js_flow_library_loaded(bool value) {
  _internal_set_js_flow_library_loaded(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientContextProto.js_flow_library_loaded)
}

inline bool ClientContextProto::has_client() const {
  return client_case() != CLIENT_NOT_SET;
}
inline void ClientContextProto::clear_has_client() {
  _oneof_case_[0] = CLIENT_NOT_SET;
}
inline ClientContextProto::ClientCase ClientContextProto::client_case() const {
  return ClientContextProto::ClientCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SupportsScriptRequestProto

// optional string url = 1;
inline bool SupportsScriptRequestProto::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SupportsScriptRequestProto::has_url() const {
  return _internal_has_url();
}
inline void SupportsScriptRequestProto::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SupportsScriptRequestProto::url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptRequestProto.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SupportsScriptRequestProto::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportsScriptRequestProto.url)
}
inline std::string* SupportsScriptRequestProto::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptRequestProto.url)
  return _s;
}
inline const std::string& SupportsScriptRequestProto::_internal_url() const {
  return url_.Get();
}
inline void SupportsScriptRequestProto::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* SupportsScriptRequestProto::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* SupportsScriptRequestProto::release_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportsScriptRequestProto.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SupportsScriptRequestProto::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportsScriptRequestProto.url)
}

// repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
inline int SupportsScriptRequestProto::_internal_script_parameters_size() const {
  return script_parameters_.size();
}
inline int SupportsScriptRequestProto::script_parameters_size() const {
  return _internal_script_parameters_size();
}
inline void SupportsScriptRequestProto::clear_script_parameters() {
  script_parameters_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* SupportsScriptRequestProto::mutable_script_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptRequestProto.script_parameters)
  return script_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
SupportsScriptRequestProto::mutable_script_parameters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SupportsScriptRequestProto.script_parameters)
  return &script_parameters_;
}
inline const ::autofill_assistant::ScriptParameterProto& SupportsScriptRequestProto::_internal_script_parameters(int index) const {
  return script_parameters_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& SupportsScriptRequestProto::script_parameters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptRequestProto.script_parameters)
  return _internal_script_parameters(index);
}
inline ::autofill_assistant::ScriptParameterProto* SupportsScriptRequestProto::_internal_add_script_parameters() {
  return script_parameters_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* SupportsScriptRequestProto::add_script_parameters() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_script_parameters();
  // @@protoc_insertion_point(field_add:autofill_assistant.SupportsScriptRequestProto.script_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
SupportsScriptRequestProto::script_parameters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SupportsScriptRequestProto.script_parameters)
  return script_parameters_;
}

// optional .autofill_assistant.ClientContextProto client_context = 3;
inline bool SupportsScriptRequestProto::_internal_has_client_context() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || client_context_ != nullptr);
  return value;
}
inline bool SupportsScriptRequestProto::has_client_context() const {
  return _internal_has_client_context();
}
inline void SupportsScriptRequestProto::clear_client_context() {
  if (client_context_ != nullptr) client_context_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientContextProto& SupportsScriptRequestProto::_internal_client_context() const {
  const ::autofill_assistant::ClientContextProto* p = client_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto&>(
      ::autofill_assistant::_ClientContextProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto& SupportsScriptRequestProto::client_context() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptRequestProto.client_context)
  return _internal_client_context();
}
inline void SupportsScriptRequestProto::unsafe_arena_set_allocated_client_context(
    ::autofill_assistant::ClientContextProto* client_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_context_);
  }
  client_context_ = client_context;
  if (client_context) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportsScriptRequestProto.client_context)
}
inline ::autofill_assistant::ClientContextProto* SupportsScriptRequestProto::release_client_context() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto* SupportsScriptRequestProto::unsafe_arena_release_client_context() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportsScriptRequestProto.client_context)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto* SupportsScriptRequestProto::_internal_mutable_client_context() {
  _has_bits_[0] |= 0x00000002u;
  if (client_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto>(GetArenaForAllocation());
    client_context_ = p;
  }
  return client_context_;
}
inline ::autofill_assistant::ClientContextProto* SupportsScriptRequestProto::mutable_client_context() {
  ::autofill_assistant::ClientContextProto* _msg = _internal_mutable_client_context();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptRequestProto.client_context)
  return _msg;
}
inline void SupportsScriptRequestProto::set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_context_;
  }
  if (client_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_context);
    if (message_arena != submessage_arena) {
      client_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_context_ = client_context;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportsScriptRequestProto.client_context)
}

// -------------------------------------------------------------------

// ImplicitTriggeringDebugParametersProto

// repeated .autofill_assistant.ScriptParameterProto additional_script_parameters = 1;
inline int ImplicitTriggeringDebugParametersProto::_internal_additional_script_parameters_size() const {
  return additional_script_parameters_.size();
}
inline int ImplicitTriggeringDebugParametersProto::additional_script_parameters_size() const {
  return _internal_additional_script_parameters_size();
}
inline void ImplicitTriggeringDebugParametersProto::clear_additional_script_parameters() {
  additional_script_parameters_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* ImplicitTriggeringDebugParametersProto::mutable_additional_script_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ImplicitTriggeringDebugParametersProto.additional_script_parameters)
  return additional_script_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
ImplicitTriggeringDebugParametersProto::mutable_additional_script_parameters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ImplicitTriggeringDebugParametersProto.additional_script_parameters)
  return &additional_script_parameters_;
}
inline const ::autofill_assistant::ScriptParameterProto& ImplicitTriggeringDebugParametersProto::_internal_additional_script_parameters(int index) const {
  return additional_script_parameters_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& ImplicitTriggeringDebugParametersProto::additional_script_parameters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ImplicitTriggeringDebugParametersProto.additional_script_parameters)
  return _internal_additional_script_parameters(index);
}
inline ::autofill_assistant::ScriptParameterProto* ImplicitTriggeringDebugParametersProto::_internal_add_additional_script_parameters() {
  return additional_script_parameters_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* ImplicitTriggeringDebugParametersProto::add_additional_script_parameters() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_additional_script_parameters();
  // @@protoc_insertion_point(field_add:autofill_assistant.ImplicitTriggeringDebugParametersProto.additional_script_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
ImplicitTriggeringDebugParametersProto::additional_script_parameters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ImplicitTriggeringDebugParametersProto.additional_script_parameters)
  return additional_script_parameters_;
}

// -------------------------------------------------------------------

// ScriptParameterProto

// optional string name = 3;
inline bool ScriptParameterProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScriptParameterProto::has_name() const {
  return _internal_has_name();
}
inline void ScriptParameterProto::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ScriptParameterProto::name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptParameterProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptParameterProto::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptParameterProto.name)
}
inline std::string* ScriptParameterProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptParameterProto.name)
  return _s;
}
inline const std::string& ScriptParameterProto::_internal_name() const {
  return name_.Get();
}
inline void ScriptParameterProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptParameterProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptParameterProto::release_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptParameterProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptParameterProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptParameterProto.name)
}

// optional string value = 2;
inline bool ScriptParameterProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScriptParameterProto::has_value() const {
  return _internal_has_value();
}
inline void ScriptParameterProto::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScriptParameterProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptParameterProto.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptParameterProto::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptParameterProto.value)
}
inline std::string* ScriptParameterProto::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptParameterProto.value)
  return _s;
}
inline const std::string& ScriptParameterProto::_internal_value() const {
  return value_.Get();
}
inline void ScriptParameterProto::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptParameterProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptParameterProto::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptParameterProto.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptParameterProto::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptParameterProto.value)
}

// -------------------------------------------------------------------

// SupportsScriptResponseProto

// repeated .autofill_assistant.SupportedScriptProto scripts = 1;
inline int SupportsScriptResponseProto::_internal_scripts_size() const {
  return scripts_.size();
}
inline int SupportsScriptResponseProto::scripts_size() const {
  return _internal_scripts_size();
}
inline void SupportsScriptResponseProto::clear_scripts() {
  scripts_.Clear();
}
inline ::autofill_assistant::SupportedScriptProto* SupportsScriptResponseProto::mutable_scripts(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptResponseProto.scripts)
  return scripts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >*
SupportsScriptResponseProto::mutable_scripts() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SupportsScriptResponseProto.scripts)
  return &scripts_;
}
inline const ::autofill_assistant::SupportedScriptProto& SupportsScriptResponseProto::_internal_scripts(int index) const {
  return scripts_.Get(index);
}
inline const ::autofill_assistant::SupportedScriptProto& SupportsScriptResponseProto::scripts(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptResponseProto.scripts)
  return _internal_scripts(index);
}
inline ::autofill_assistant::SupportedScriptProto* SupportsScriptResponseProto::_internal_add_scripts() {
  return scripts_.Add();
}
inline ::autofill_assistant::SupportedScriptProto* SupportsScriptResponseProto::add_scripts() {
  ::autofill_assistant::SupportedScriptProto* _add = _internal_add_scripts();
  // @@protoc_insertion_point(field_add:autofill_assistant.SupportsScriptResponseProto.scripts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >&
SupportsScriptResponseProto::scripts() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SupportsScriptResponseProto.scripts)
  return scripts_;
}

// optional .autofill_assistant.ScriptTimeoutError script_timeout_error = 2;
inline bool SupportsScriptResponseProto::_internal_has_script_timeout_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || script_timeout_error_ != nullptr);
  return value;
}
inline bool SupportsScriptResponseProto::has_script_timeout_error() const {
  return _internal_has_script_timeout_error();
}
inline void SupportsScriptResponseProto::clear_script_timeout_error() {
  if (script_timeout_error_ != nullptr) script_timeout_error_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ScriptTimeoutError& SupportsScriptResponseProto::_internal_script_timeout_error() const {
  const ::autofill_assistant::ScriptTimeoutError* p = script_timeout_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ScriptTimeoutError&>(
      ::autofill_assistant::_ScriptTimeoutError_default_instance_);
}
inline const ::autofill_assistant::ScriptTimeoutError& SupportsScriptResponseProto::script_timeout_error() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptResponseProto.script_timeout_error)
  return _internal_script_timeout_error();
}
inline void SupportsScriptResponseProto::unsafe_arena_set_allocated_script_timeout_error(
    ::autofill_assistant::ScriptTimeoutError* script_timeout_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(script_timeout_error_);
  }
  script_timeout_error_ = script_timeout_error;
  if (script_timeout_error) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportsScriptResponseProto.script_timeout_error)
}
inline ::autofill_assistant::ScriptTimeoutError* SupportsScriptResponseProto::release_script_timeout_error() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ScriptTimeoutError* temp = script_timeout_error_;
  script_timeout_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ScriptTimeoutError* SupportsScriptResponseProto::unsafe_arena_release_script_timeout_error() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportsScriptResponseProto.script_timeout_error)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ScriptTimeoutError* temp = script_timeout_error_;
  script_timeout_error_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ScriptTimeoutError* SupportsScriptResponseProto::_internal_mutable_script_timeout_error() {
  _has_bits_[0] |= 0x00000001u;
  if (script_timeout_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ScriptTimeoutError>(GetArenaForAllocation());
    script_timeout_error_ = p;
  }
  return script_timeout_error_;
}
inline ::autofill_assistant::ScriptTimeoutError* SupportsScriptResponseProto::mutable_script_timeout_error() {
  ::autofill_assistant::ScriptTimeoutError* _msg = _internal_mutable_script_timeout_error();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptResponseProto.script_timeout_error)
  return _msg;
}
inline void SupportsScriptResponseProto::set_allocated_script_timeout_error(::autofill_assistant::ScriptTimeoutError* script_timeout_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete script_timeout_error_;
  }
  if (script_timeout_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(script_timeout_error);
    if (message_arena != submessage_arena) {
      script_timeout_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, script_timeout_error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_timeout_error_ = script_timeout_error;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportsScriptResponseProto.script_timeout_error)
}

// optional .autofill_assistant.ClientSettingsProto client_settings = 3;
inline bool SupportsScriptResponseProto::_internal_has_client_settings() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || client_settings_ != nullptr);
  return value;
}
inline bool SupportsScriptResponseProto::has_client_settings() const {
  return _internal_has_client_settings();
}
inline void SupportsScriptResponseProto::clear_client_settings() {
  if (client_settings_ != nullptr) client_settings_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientSettingsProto& SupportsScriptResponseProto::_internal_client_settings() const {
  const ::autofill_assistant::ClientSettingsProto* p = client_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientSettingsProto&>(
      ::autofill_assistant::_ClientSettingsProto_default_instance_);
}
inline const ::autofill_assistant::ClientSettingsProto& SupportsScriptResponseProto::client_settings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptResponseProto.client_settings)
  return _internal_client_settings();
}
inline void SupportsScriptResponseProto::unsafe_arena_set_allocated_client_settings(
    ::autofill_assistant::ClientSettingsProto* client_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_settings_);
  }
  client_settings_ = client_settings;
  if (client_settings) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportsScriptResponseProto.client_settings)
}
inline ::autofill_assistant::ClientSettingsProto* SupportsScriptResponseProto::release_client_settings() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientSettingsProto* temp = client_settings_;
  client_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto* SupportsScriptResponseProto::unsafe_arena_release_client_settings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportsScriptResponseProto.client_settings)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientSettingsProto* temp = client_settings_;
  client_settings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto* SupportsScriptResponseProto::_internal_mutable_client_settings() {
  _has_bits_[0] |= 0x00000002u;
  if (client_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientSettingsProto>(GetArenaForAllocation());
    client_settings_ = p;
  }
  return client_settings_;
}
inline ::autofill_assistant::ClientSettingsProto* SupportsScriptResponseProto::mutable_client_settings() {
  ::autofill_assistant::ClientSettingsProto* _msg = _internal_mutable_client_settings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptResponseProto.client_settings)
  return _msg;
}
inline void SupportsScriptResponseProto::set_allocated_client_settings(::autofill_assistant::ClientSettingsProto* client_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_settings_;
  }
  if (client_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_settings);
    if (message_arena != submessage_arena) {
      client_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_settings_ = client_settings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportsScriptResponseProto.client_settings)
}

// optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
inline bool SupportsScriptResponseProto::_internal_has_script_store_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || script_store_config_ != nullptr);
  return value;
}
inline bool SupportsScriptResponseProto::has_script_store_config() const {
  return _internal_has_script_store_config();
}
inline void SupportsScriptResponseProto::clear_script_store_config() {
  if (script_store_config_ != nullptr) script_store_config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ScriptStoreConfig& SupportsScriptResponseProto::_internal_script_store_config() const {
  const ::autofill_assistant::ScriptStoreConfig* p = script_store_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ScriptStoreConfig&>(
      ::autofill_assistant::_ScriptStoreConfig_default_instance_);
}
inline const ::autofill_assistant::ScriptStoreConfig& SupportsScriptResponseProto::script_store_config() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptResponseProto.script_store_config)
  return _internal_script_store_config();
}
inline void SupportsScriptResponseProto::unsafe_arena_set_allocated_script_store_config(
    ::autofill_assistant::ScriptStoreConfig* script_store_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(script_store_config_);
  }
  script_store_config_ = script_store_config;
  if (script_store_config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportsScriptResponseProto.script_store_config)
}
inline ::autofill_assistant::ScriptStoreConfig* SupportsScriptResponseProto::release_script_store_config() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ScriptStoreConfig* temp = script_store_config_;
  script_store_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ScriptStoreConfig* SupportsScriptResponseProto::unsafe_arena_release_script_store_config() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportsScriptResponseProto.script_store_config)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ScriptStoreConfig* temp = script_store_config_;
  script_store_config_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ScriptStoreConfig* SupportsScriptResponseProto::_internal_mutable_script_store_config() {
  _has_bits_[0] |= 0x00000004u;
  if (script_store_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ScriptStoreConfig>(GetArenaForAllocation());
    script_store_config_ = p;
  }
  return script_store_config_;
}
inline ::autofill_assistant::ScriptStoreConfig* SupportsScriptResponseProto::mutable_script_store_config() {
  ::autofill_assistant::ScriptStoreConfig* _msg = _internal_mutable_script_store_config();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptResponseProto.script_store_config)
  return _msg;
}
inline void SupportsScriptResponseProto::set_allocated_script_store_config(::autofill_assistant::ScriptStoreConfig* script_store_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete script_store_config_;
  }
  if (script_store_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(script_store_config);
    if (message_arena != submessage_arena) {
      script_store_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, script_store_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  script_store_config_ = script_store_config;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportsScriptResponseProto.script_store_config)
}

// optional .autofill_assistant.SemanticSelectorPolicy semantic_selector_policy = 7;
inline bool SupportsScriptResponseProto::_internal_has_semantic_selector_policy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || semantic_selector_policy_ != nullptr);
  return value;
}
inline bool SupportsScriptResponseProto::has_semantic_selector_policy() const {
  return _internal_has_semantic_selector_policy();
}
inline const ::autofill_assistant::SemanticSelectorPolicy& SupportsScriptResponseProto::_internal_semantic_selector_policy() const {
  const ::autofill_assistant::SemanticSelectorPolicy* p = semantic_selector_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SemanticSelectorPolicy&>(
      ::autofill_assistant::_SemanticSelectorPolicy_default_instance_);
}
inline const ::autofill_assistant::SemanticSelectorPolicy& SupportsScriptResponseProto::semantic_selector_policy() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportsScriptResponseProto.semantic_selector_policy)
  return _internal_semantic_selector_policy();
}
inline void SupportsScriptResponseProto::unsafe_arena_set_allocated_semantic_selector_policy(
    ::autofill_assistant::SemanticSelectorPolicy* semantic_selector_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(semantic_selector_policy_);
  }
  semantic_selector_policy_ = semantic_selector_policy;
  if (semantic_selector_policy) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportsScriptResponseProto.semantic_selector_policy)
}
inline ::autofill_assistant::SemanticSelectorPolicy* SupportsScriptResponseProto::release_semantic_selector_policy() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::SemanticSelectorPolicy* temp = semantic_selector_policy_;
  semantic_selector_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SemanticSelectorPolicy* SupportsScriptResponseProto::unsafe_arena_release_semantic_selector_policy() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportsScriptResponseProto.semantic_selector_policy)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::SemanticSelectorPolicy* temp = semantic_selector_policy_;
  semantic_selector_policy_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SemanticSelectorPolicy* SupportsScriptResponseProto::_internal_mutable_semantic_selector_policy() {
  _has_bits_[0] |= 0x00000008u;
  if (semantic_selector_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SemanticSelectorPolicy>(GetArenaForAllocation());
    semantic_selector_policy_ = p;
  }
  return semantic_selector_policy_;
}
inline ::autofill_assistant::SemanticSelectorPolicy* SupportsScriptResponseProto::mutable_semantic_selector_policy() {
  ::autofill_assistant::SemanticSelectorPolicy* _msg = _internal_mutable_semantic_selector_policy();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportsScriptResponseProto.semantic_selector_policy)
  return _msg;
}
inline void SupportsScriptResponseProto::set_allocated_semantic_selector_policy(::autofill_assistant::SemanticSelectorPolicy* semantic_selector_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(semantic_selector_policy_);
  }
  if (semantic_selector_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(semantic_selector_policy));
    if (message_arena != submessage_arena) {
      semantic_selector_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, semantic_selector_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  semantic_selector_policy_ = semantic_selector_policy;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportsScriptResponseProto.semantic_selector_policy)
}

// -------------------------------------------------------------------

// GetCapabilitiesByHashPrefixRequestProto

// optional uint32 hash_prefix_length = 1;
inline bool GetCapabilitiesByHashPrefixRequestProto::_internal_has_hash_prefix_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetCapabilitiesByHashPrefixRequestProto::has_hash_prefix_length() const {
  return _internal_has_hash_prefix_length();
}
inline void GetCapabilitiesByHashPrefixRequestProto::clear_hash_prefix_length() {
  hash_prefix_length_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t GetCapabilitiesByHashPrefixRequestProto::_internal_hash_prefix_length() const {
  return hash_prefix_length_;
}
inline uint32_t GetCapabilitiesByHashPrefixRequestProto::hash_prefix_length() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix_length)
  return _internal_hash_prefix_length();
}
inline void GetCapabilitiesByHashPrefixRequestProto::_internal_set_hash_prefix_length(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  hash_prefix_length_ = value;
}
inline void GetCapabilitiesByHashPrefixRequestProto::set_hash_prefix_length(uint32_t value) {
  _internal_set_hash_prefix_length(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix_length)
}

// repeated uint64 hash_prefix = 2 [packed = true];
inline int GetCapabilitiesByHashPrefixRequestProto::_internal_hash_prefix_size() const {
  return hash_prefix_.size();
}
inline int GetCapabilitiesByHashPrefixRequestProto::hash_prefix_size() const {
  return _internal_hash_prefix_size();
}
inline void GetCapabilitiesByHashPrefixRequestProto::clear_hash_prefix() {
  hash_prefix_.Clear();
}
inline uint64_t GetCapabilitiesByHashPrefixRequestProto::_internal_hash_prefix(int index) const {
  return hash_prefix_.Get(index);
}
inline uint64_t GetCapabilitiesByHashPrefixRequestProto::hash_prefix(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix)
  return _internal_hash_prefix(index);
}
inline void GetCapabilitiesByHashPrefixRequestProto::set_hash_prefix(int index, uint64_t value) {
  hash_prefix_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix)
}
inline void GetCapabilitiesByHashPrefixRequestProto::_internal_add_hash_prefix(uint64_t value) {
  hash_prefix_.Add(value);
}
inline void GetCapabilitiesByHashPrefixRequestProto::add_hash_prefix(uint64_t value) {
  _internal_add_hash_prefix(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetCapabilitiesByHashPrefixRequestProto::_internal_hash_prefix() const {
  return hash_prefix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetCapabilitiesByHashPrefixRequestProto::hash_prefix() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix)
  return _internal_hash_prefix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetCapabilitiesByHashPrefixRequestProto::_internal_mutable_hash_prefix() {
  return &hash_prefix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetCapabilitiesByHashPrefixRequestProto::mutable_hash_prefix() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.hash_prefix)
  return _internal_mutable_hash_prefix();
}

// optional .autofill_assistant.ClientContextProto client_context = 3;
inline bool GetCapabilitiesByHashPrefixRequestProto::_internal_has_client_context() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_context_ != nullptr);
  return value;
}
inline bool GetCapabilitiesByHashPrefixRequestProto::has_client_context() const {
  return _internal_has_client_context();
}
inline void GetCapabilitiesByHashPrefixRequestProto::clear_client_context() {
  if (client_context_ != nullptr) client_context_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientContextProto& GetCapabilitiesByHashPrefixRequestProto::_internal_client_context() const {
  const ::autofill_assistant::ClientContextProto* p = client_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto&>(
      ::autofill_assistant::_ClientContextProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto& GetCapabilitiesByHashPrefixRequestProto::client_context() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.client_context)
  return _internal_client_context();
}
inline void GetCapabilitiesByHashPrefixRequestProto::unsafe_arena_set_allocated_client_context(
    ::autofill_assistant::ClientContextProto* client_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_context_);
  }
  client_context_ = client_context;
  if (client_context) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.client_context)
}
inline ::autofill_assistant::ClientContextProto* GetCapabilitiesByHashPrefixRequestProto::release_client_context() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto* GetCapabilitiesByHashPrefixRequestProto::unsafe_arena_release_client_context() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.client_context)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto* GetCapabilitiesByHashPrefixRequestProto::_internal_mutable_client_context() {
  _has_bits_[0] |= 0x00000001u;
  if (client_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto>(GetArenaForAllocation());
    client_context_ = p;
  }
  return client_context_;
}
inline ::autofill_assistant::ClientContextProto* GetCapabilitiesByHashPrefixRequestProto::mutable_client_context() {
  ::autofill_assistant::ClientContextProto* _msg = _internal_mutable_client_context();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.client_context)
  return _msg;
}
inline void GetCapabilitiesByHashPrefixRequestProto::set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_context_;
  }
  if (client_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_context);
    if (message_arena != submessage_arena) {
      client_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_context_ = client_context;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.client_context)
}

// repeated .autofill_assistant.ScriptParameterProto script_parameters = 4;
inline int GetCapabilitiesByHashPrefixRequestProto::_internal_script_parameters_size() const {
  return script_parameters_.size();
}
inline int GetCapabilitiesByHashPrefixRequestProto::script_parameters_size() const {
  return _internal_script_parameters_size();
}
inline void GetCapabilitiesByHashPrefixRequestProto::clear_script_parameters() {
  script_parameters_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* GetCapabilitiesByHashPrefixRequestProto::mutable_script_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.script_parameters)
  return script_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
GetCapabilitiesByHashPrefixRequestProto::mutable_script_parameters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.script_parameters)
  return &script_parameters_;
}
inline const ::autofill_assistant::ScriptParameterProto& GetCapabilitiesByHashPrefixRequestProto::_internal_script_parameters(int index) const {
  return script_parameters_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& GetCapabilitiesByHashPrefixRequestProto::script_parameters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.script_parameters)
  return _internal_script_parameters(index);
}
inline ::autofill_assistant::ScriptParameterProto* GetCapabilitiesByHashPrefixRequestProto::_internal_add_script_parameters() {
  return script_parameters_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* GetCapabilitiesByHashPrefixRequestProto::add_script_parameters() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_script_parameters();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.script_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
GetCapabilitiesByHashPrefixRequestProto::script_parameters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto.script_parameters)
  return script_parameters_;
}

// -------------------------------------------------------------------

// GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto

// optional string url_match = 1;
inline bool GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_has_url_match() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::has_url_match() const {
  return _internal_has_url_match();
}
inline void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::clear_url_match() {
  url_match_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::url_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.url_match)
  return _internal_url_match();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::set_url_match(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_match_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.url_match)
}
inline std::string* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::mutable_url_match() {
  std::string* _s = _internal_mutable_url_match();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.url_match)
  return _s;
}
inline const std::string& GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_url_match() const {
  return url_match_.Get();
}
inline void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_set_url_match(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_match_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_mutable_url_match() {
  _has_bits_[0] |= 0x00000001u;
  return url_match_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::release_url_match() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.url_match)
  if (!_internal_has_url_match()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_match_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_match_.IsDefault()) {
    url_match_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::set_allocated_url_match(std::string* url_match) {
  if (url_match != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_match_.SetAllocated(url_match, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_match_.IsDefault()) {
    url_match_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.url_match)
}

// repeated .autofill_assistant.ScriptParameterProto script_parameters_override = 2;
inline int GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_script_parameters_override_size() const {
  return script_parameters_override_.size();
}
inline int GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::script_parameters_override_size() const {
  return _internal_script_parameters_override_size();
}
inline void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::clear_script_parameters_override() {
  script_parameters_override_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::mutable_script_parameters_override(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.script_parameters_override)
  return script_parameters_override_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::mutable_script_parameters_override() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.script_parameters_override)
  return &script_parameters_override_;
}
inline const ::autofill_assistant::ScriptParameterProto& GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_script_parameters_override(int index) const {
  return script_parameters_override_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::script_parameters_override(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.script_parameters_override)
  return _internal_script_parameters_override(index);
}
inline ::autofill_assistant::ScriptParameterProto* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_internal_add_script_parameters_override() {
  return script_parameters_override_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::add_script_parameters_override() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_script_parameters_override();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.script_parameters_override)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::script_parameters_override() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto.script_parameters_override)
  return script_parameters_override_;
}

// -------------------------------------------------------------------

// GetCapabilitiesByHashPrefixResponseProto

// repeated .autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto match_info = 1;
inline int GetCapabilitiesByHashPrefixResponseProto::_internal_match_info_size() const {
  return match_info_.size();
}
inline int GetCapabilitiesByHashPrefixResponseProto::match_info_size() const {
  return _internal_match_info_size();
}
inline void GetCapabilitiesByHashPrefixResponseProto::clear_match_info() {
  match_info_.Clear();
}
inline ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* GetCapabilitiesByHashPrefixResponseProto::mutable_match_info(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.match_info)
  return match_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto >*
GetCapabilitiesByHashPrefixResponseProto::mutable_match_info() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.match_info)
  return &match_info_;
}
inline const ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& GetCapabilitiesByHashPrefixResponseProto::_internal_match_info(int index) const {
  return match_info_.Get(index);
}
inline const ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& GetCapabilitiesByHashPrefixResponseProto::match_info(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.match_info)
  return _internal_match_info(index);
}
inline ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* GetCapabilitiesByHashPrefixResponseProto::_internal_add_match_info() {
  return match_info_.Add();
}
inline ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* GetCapabilitiesByHashPrefixResponseProto::add_match_info() {
  ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* _add = _internal_add_match_info();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.match_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto >&
GetCapabilitiesByHashPrefixResponseProto::match_info() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.match_info)
  return match_info_;
}

// -------------------------------------------------------------------

// GetUserDataRequestProto_PaymentMethodRequest

// optional bytes client_token = 1;
inline bool GetUserDataRequestProto_PaymentMethodRequest::_internal_has_client_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetUserDataRequestProto_PaymentMethodRequest::has_client_token() const {
  return _internal_has_client_token();
}
inline void GetUserDataRequestProto_PaymentMethodRequest::clear_client_token() {
  client_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetUserDataRequestProto_PaymentMethodRequest::client_token() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.client_token)
  return _internal_client_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataRequestProto_PaymentMethodRequest::set_client_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.client_token)
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::mutable_client_token() {
  std::string* _s = _internal_mutable_client_token();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.client_token)
  return _s;
}
inline const std::string& GetUserDataRequestProto_PaymentMethodRequest::_internal_client_token() const {
  return client_token_.Get();
}
inline void GetUserDataRequestProto_PaymentMethodRequest::_internal_set_client_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::_internal_mutable_client_token() {
  _has_bits_[0] |= 0x00000001u;
  return client_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::release_client_token() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.client_token)
  if (!_internal_has_client_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = client_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_token_.IsDefault()) {
    client_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_allocated_client_token(std::string* client_token) {
  if (client_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_token_.SetAllocated(client_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_token_.IsDefault()) {
    client_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.client_token)
}

// repeated string supported_card_networks = 2;
inline int GetUserDataRequestProto_PaymentMethodRequest::_internal_supported_card_networks_size() const {
  return supported_card_networks_.size();
}
inline int GetUserDataRequestProto_PaymentMethodRequest::supported_card_networks_size() const {
  return _internal_supported_card_networks_size();
}
inline void GetUserDataRequestProto_PaymentMethodRequest::clear_supported_card_networks() {
  supported_card_networks_.Clear();
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::add_supported_card_networks() {
  std::string* _s = _internal_add_supported_card_networks();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
  return _s;
}
inline const std::string& GetUserDataRequestProto_PaymentMethodRequest::_internal_supported_card_networks(int index) const {
  return supported_card_networks_.Get(index);
}
inline const std::string& GetUserDataRequestProto_PaymentMethodRequest::supported_card_networks(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
  return _internal_supported_card_networks(index);
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::mutable_supported_card_networks(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
  return supported_card_networks_.Mutable(index);
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_supported_card_networks(int index, const std::string& value) {
  supported_card_networks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_supported_card_networks(int index, std::string&& value) {
  supported_card_networks_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_supported_card_networks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_card_networks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_supported_card_networks(int index, const char* value, size_t size) {
  supported_card_networks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::_internal_add_supported_card_networks() {
  return supported_card_networks_.Add();
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_supported_card_networks(const std::string& value) {
  supported_card_networks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_supported_card_networks(std::string&& value) {
  supported_card_networks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_supported_card_networks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_card_networks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_supported_card_networks(const char* value, size_t size) {
  supported_card_networks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetUserDataRequestProto_PaymentMethodRequest::supported_card_networks() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
  return supported_card_networks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetUserDataRequestProto_PaymentMethodRequest::mutable_supported_card_networks() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.supported_card_networks)
  return &supported_card_networks_;
}

// repeated string preexisting_ids = 3;
inline int GetUserDataRequestProto_PaymentMethodRequest::_internal_preexisting_ids_size() const {
  return preexisting_ids_.size();
}
inline int GetUserDataRequestProto_PaymentMethodRequest::preexisting_ids_size() const {
  return _internal_preexisting_ids_size();
}
inline void GetUserDataRequestProto_PaymentMethodRequest::clear_preexisting_ids() {
  preexisting_ids_.Clear();
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::add_preexisting_ids() {
  std::string* _s = _internal_add_preexisting_ids();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
  return _s;
}
inline const std::string& GetUserDataRequestProto_PaymentMethodRequest::_internal_preexisting_ids(int index) const {
  return preexisting_ids_.Get(index);
}
inline const std::string& GetUserDataRequestProto_PaymentMethodRequest::preexisting_ids(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
  return _internal_preexisting_ids(index);
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::mutable_preexisting_ids(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
  return preexisting_ids_.Mutable(index);
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_preexisting_ids(int index, const std::string& value) {
  preexisting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_preexisting_ids(int index, std::string&& value) {
  preexisting_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_preexisting_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preexisting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::set_preexisting_ids(int index, const char* value, size_t size) {
  preexisting_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline std::string* GetUserDataRequestProto_PaymentMethodRequest::_internal_add_preexisting_ids() {
  return preexisting_ids_.Add();
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_preexisting_ids(const std::string& value) {
  preexisting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_preexisting_ids(std::string&& value) {
  preexisting_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_preexisting_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preexisting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_PaymentMethodRequest::add_preexisting_ids(const char* value, size_t size) {
  preexisting_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetUserDataRequestProto_PaymentMethodRequest::preexisting_ids() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
  return preexisting_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetUserDataRequestProto_PaymentMethodRequest::mutable_preexisting_ids() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest.preexisting_ids)
  return &preexisting_ids_;
}

// -------------------------------------------------------------------

// GetUserDataRequestProto_AddressRequest

// repeated string preexisting_ids = 1;
inline int GetUserDataRequestProto_AddressRequest::_internal_preexisting_ids_size() const {
  return preexisting_ids_.size();
}
inline int GetUserDataRequestProto_AddressRequest::preexisting_ids_size() const {
  return _internal_preexisting_ids_size();
}
inline void GetUserDataRequestProto_AddressRequest::clear_preexisting_ids() {
  preexisting_ids_.Clear();
}
inline std::string* GetUserDataRequestProto_AddressRequest::add_preexisting_ids() {
  std::string* _s = _internal_add_preexisting_ids();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
  return _s;
}
inline const std::string& GetUserDataRequestProto_AddressRequest::_internal_preexisting_ids(int index) const {
  return preexisting_ids_.Get(index);
}
inline const std::string& GetUserDataRequestProto_AddressRequest::preexisting_ids(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
  return _internal_preexisting_ids(index);
}
inline std::string* GetUserDataRequestProto_AddressRequest::mutable_preexisting_ids(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
  return preexisting_ids_.Mutable(index);
}
inline void GetUserDataRequestProto_AddressRequest::set_preexisting_ids(int index, const std::string& value) {
  preexisting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_AddressRequest::set_preexisting_ids(int index, std::string&& value) {
  preexisting_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_AddressRequest::set_preexisting_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preexisting_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_AddressRequest::set_preexisting_ids(int index, const char* value, size_t size) {
  preexisting_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline std::string* GetUserDataRequestProto_AddressRequest::_internal_add_preexisting_ids() {
  return preexisting_ids_.Add();
}
inline void GetUserDataRequestProto_AddressRequest::add_preexisting_ids(const std::string& value) {
  preexisting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_AddressRequest::add_preexisting_ids(std::string&& value) {
  preexisting_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_AddressRequest::add_preexisting_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preexisting_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline void GetUserDataRequestProto_AddressRequest::add_preexisting_ids(const char* value, size_t size) {
  preexisting_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetUserDataRequestProto_AddressRequest::preexisting_ids() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
  return preexisting_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetUserDataRequestProto_AddressRequest::mutable_preexisting_ids() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataRequestProto.AddressRequest.preexisting_ids)
  return &preexisting_ids_;
}

// -------------------------------------------------------------------

// GetUserDataRequestProto

// optional uint64 run_id = 1;
inline bool GetUserDataRequestProto::_internal_has_run_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetUserDataRequestProto::has_run_id() const {
  return _internal_has_run_id();
}
inline void GetUserDataRequestProto::clear_run_id() {
  run_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t GetUserDataRequestProto::_internal_run_id() const {
  return run_id_;
}
inline uint64_t GetUserDataRequestProto::run_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.run_id)
  return _internal_run_id();
}
inline void GetUserDataRequestProto::_internal_set_run_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  run_id_ = value;
}
inline void GetUserDataRequestProto::set_run_id(uint64_t value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.run_id)
}

// optional bool request_name = 2;
inline bool GetUserDataRequestProto::_internal_has_request_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetUserDataRequestProto::has_request_name() const {
  return _internal_has_request_name();
}
inline void GetUserDataRequestProto::clear_request_name() {
  request_name_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GetUserDataRequestProto::_internal_request_name() const {
  return request_name_;
}
inline bool GetUserDataRequestProto::request_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.request_name)
  return _internal_request_name();
}
inline void GetUserDataRequestProto::_internal_set_request_name(bool value) {
  _has_bits_[0] |= 0x00000008u;
  request_name_ = value;
}
inline void GetUserDataRequestProto::set_request_name(bool value) {
  _internal_set_request_name(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.request_name)
}

// optional bool request_email = 3;
inline bool GetUserDataRequestProto::_internal_has_request_email() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetUserDataRequestProto::has_request_email() const {
  return _internal_has_request_email();
}
inline void GetUserDataRequestProto::clear_request_email() {
  request_email_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GetUserDataRequestProto::_internal_request_email() const {
  return request_email_;
}
inline bool GetUserDataRequestProto::request_email() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.request_email)
  return _internal_request_email();
}
inline void GetUserDataRequestProto::_internal_set_request_email(bool value) {
  _has_bits_[0] |= 0x00000010u;
  request_email_ = value;
}
inline void GetUserDataRequestProto::set_request_email(bool value) {
  _internal_set_request_email(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.request_email)
}

// optional bool request_phone = 4;
inline bool GetUserDataRequestProto::_internal_has_request_phone() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetUserDataRequestProto::has_request_phone() const {
  return _internal_has_request_phone();
}
inline void GetUserDataRequestProto::clear_request_phone() {
  request_phone_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GetUserDataRequestProto::_internal_request_phone() const {
  return request_phone_;
}
inline bool GetUserDataRequestProto::request_phone() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.request_phone)
  return _internal_request_phone();
}
inline void GetUserDataRequestProto::_internal_set_request_phone(bool value) {
  _has_bits_[0] |= 0x00000020u;
  request_phone_ = value;
}
inline void GetUserDataRequestProto::set_request_phone(bool value) {
  _internal_set_request_phone(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataRequestProto.request_phone)
}

// optional .autofill_assistant.GetUserDataRequestProto.AddressRequest request_shipping_addresses = 8;
inline bool GetUserDataRequestProto::_internal_has_request_shipping_addresses() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || request_shipping_addresses_ != nullptr);
  return value;
}
inline bool GetUserDataRequestProto::has_request_shipping_addresses() const {
  return _internal_has_request_shipping_addresses();
}
inline void GetUserDataRequestProto::clear_request_shipping_addresses() {
  if (request_shipping_addresses_ != nullptr) request_shipping_addresses_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::GetUserDataRequestProto_AddressRequest& GetUserDataRequestProto::_internal_request_shipping_addresses() const {
  const ::autofill_assistant::GetUserDataRequestProto_AddressRequest* p = request_shipping_addresses_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetUserDataRequestProto_AddressRequest&>(
      ::autofill_assistant::_GetUserDataRequestProto_AddressRequest_default_instance_);
}
inline const ::autofill_assistant::GetUserDataRequestProto_AddressRequest& GetUserDataRequestProto::request_shipping_addresses() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.request_shipping_addresses)
  return _internal_request_shipping_addresses();
}
inline void GetUserDataRequestProto::unsafe_arena_set_allocated_request_shipping_addresses(
    ::autofill_assistant::GetUserDataRequestProto_AddressRequest* request_shipping_addresses) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_shipping_addresses_);
  }
  request_shipping_addresses_ = request_shipping_addresses;
  if (request_shipping_addresses) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetUserDataRequestProto.request_shipping_addresses)
}
inline ::autofill_assistant::GetUserDataRequestProto_AddressRequest* GetUserDataRequestProto::release_request_shipping_addresses() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* temp = request_shipping_addresses_;
  request_shipping_addresses_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetUserDataRequestProto_AddressRequest* GetUserDataRequestProto::unsafe_arena_release_request_shipping_addresses() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataRequestProto.request_shipping_addresses)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* temp = request_shipping_addresses_;
  request_shipping_addresses_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetUserDataRequestProto_AddressRequest* GetUserDataRequestProto::_internal_mutable_request_shipping_addresses() {
  _has_bits_[0] |= 0x00000002u;
  if (request_shipping_addresses_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetUserDataRequestProto_AddressRequest>(GetArenaForAllocation());
    request_shipping_addresses_ = p;
  }
  return request_shipping_addresses_;
}
inline ::autofill_assistant::GetUserDataRequestProto_AddressRequest* GetUserDataRequestProto::mutable_request_shipping_addresses() {
  ::autofill_assistant::GetUserDataRequestProto_AddressRequest* _msg = _internal_mutable_request_shipping_addresses();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataRequestProto.request_shipping_addresses)
  return _msg;
}
inline void GetUserDataRequestProto::set_allocated_request_shipping_addresses(::autofill_assistant::GetUserDataRequestProto_AddressRequest* request_shipping_addresses) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_shipping_addresses_;
  }
  if (request_shipping_addresses) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_shipping_addresses);
    if (message_arena != submessage_arena) {
      request_shipping_addresses = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_shipping_addresses, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  request_shipping_addresses_ = request_shipping_addresses;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataRequestProto.request_shipping_addresses)
}

// optional .autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest request_payment_methods = 7;
inline bool GetUserDataRequestProto::_internal_has_request_payment_methods() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || request_payment_methods_ != nullptr);
  return value;
}
inline bool GetUserDataRequestProto::has_request_payment_methods() const {
  return _internal_has_request_payment_methods();
}
inline void GetUserDataRequestProto::clear_request_payment_methods() {
  if (request_payment_methods_ != nullptr) request_payment_methods_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest& GetUserDataRequestProto::_internal_request_payment_methods() const {
  const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* p = request_payment_methods_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest&>(
      ::autofill_assistant::_GetUserDataRequestProto_PaymentMethodRequest_default_instance_);
}
inline const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest& GetUserDataRequestProto::request_payment_methods() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataRequestProto.request_payment_methods)
  return _internal_request_payment_methods();
}
inline void GetUserDataRequestProto::unsafe_arena_set_allocated_request_payment_methods(
    ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* request_payment_methods) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_payment_methods_);
  }
  request_payment_methods_ = request_payment_methods;
  if (request_payment_methods) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetUserDataRequestProto.request_payment_methods)
}
inline ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* GetUserDataRequestProto::release_request_payment_methods() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* temp = request_payment_methods_;
  request_payment_methods_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* GetUserDataRequestProto::unsafe_arena_release_request_payment_methods() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataRequestProto.request_payment_methods)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* temp = request_payment_methods_;
  request_payment_methods_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* GetUserDataRequestProto::_internal_mutable_request_payment_methods() {
  _has_bits_[0] |= 0x00000001u;
  if (request_payment_methods_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest>(GetArenaForAllocation());
    request_payment_methods_ = p;
  }
  return request_payment_methods_;
}
inline ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* GetUserDataRequestProto::mutable_request_payment_methods() {
  ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* _msg = _internal_mutable_request_payment_methods();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataRequestProto.request_payment_methods)
  return _msg;
}
inline void GetUserDataRequestProto::set_allocated_request_payment_methods(::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest* request_payment_methods) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_payment_methods_;
  }
  if (request_payment_methods) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_payment_methods);
    if (message_arena != submessage_arena) {
      request_payment_methods = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_payment_methods, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  request_payment_methods_ = request_payment_methods;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataRequestProto.request_payment_methods)
}

// -------------------------------------------------------------------

// GetUserDataResponseProto

// optional string locale = 3;
inline bool GetUserDataResponseProto::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_locale() const {
  return _internal_has_locale();
}
inline void GetUserDataResponseProto::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetUserDataResponseProto::locale() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.locale)
}
inline std::string* GetUserDataResponseProto::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.locale)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_locale() const {
  return locale_.Get();
}
inline void GetUserDataResponseProto::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_locale() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.locale)
}

// repeated .autofill_assistant.ProfileProto available_contacts = 1;
inline int GetUserDataResponseProto::_internal_available_contacts_size() const {
  return available_contacts_.size();
}
inline int GetUserDataResponseProto::available_contacts_size() const {
  return _internal_available_contacts_size();
}
inline void GetUserDataResponseProto::clear_available_contacts() {
  available_contacts_.Clear();
}
inline ::autofill_assistant::ProfileProto* GetUserDataResponseProto::mutable_available_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.available_contacts)
  return available_contacts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >*
GetUserDataResponseProto::mutable_available_contacts() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataResponseProto.available_contacts)
  return &available_contacts_;
}
inline const ::autofill_assistant::ProfileProto& GetUserDataResponseProto::_internal_available_contacts(int index) const {
  return available_contacts_.Get(index);
}
inline const ::autofill_assistant::ProfileProto& GetUserDataResponseProto::available_contacts(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.available_contacts)
  return _internal_available_contacts(index);
}
inline ::autofill_assistant::ProfileProto* GetUserDataResponseProto::_internal_add_available_contacts() {
  return available_contacts_.Add();
}
inline ::autofill_assistant::ProfileProto* GetUserDataResponseProto::add_available_contacts() {
  ::autofill_assistant::ProfileProto* _add = _internal_add_available_contacts();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataResponseProto.available_contacts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >&
GetUserDataResponseProto::available_contacts() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataResponseProto.available_contacts)
  return available_contacts_;
}

// optional string selected_contact_identifier = 5;
inline bool GetUserDataResponseProto::_internal_has_selected_contact_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_selected_contact_identifier() const {
  return _internal_has_selected_contact_identifier();
}
inline void GetUserDataResponseProto::clear_selected_contact_identifier() {
  selected_contact_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetUserDataResponseProto::selected_contact_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.selected_contact_identifier)
  return _internal_selected_contact_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_selected_contact_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 selected_contact_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.selected_contact_identifier)
}
inline std::string* GetUserDataResponseProto::mutable_selected_contact_identifier() {
  std::string* _s = _internal_mutable_selected_contact_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.selected_contact_identifier)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_selected_contact_identifier() const {
  return selected_contact_identifier_.Get();
}
inline void GetUserDataResponseProto::_internal_set_selected_contact_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  selected_contact_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_selected_contact_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return selected_contact_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_selected_contact_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.selected_contact_identifier)
  if (!_internal_has_selected_contact_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = selected_contact_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_contact_identifier_.IsDefault()) {
    selected_contact_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_selected_contact_identifier(std::string* selected_contact_identifier) {
  if (selected_contact_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  selected_contact_identifier_.SetAllocated(selected_contact_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_contact_identifier_.IsDefault()) {
    selected_contact_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.selected_contact_identifier)
}

// repeated .autofill_assistant.PhoneNumberProto available_phone_numbers = 10;
inline int GetUserDataResponseProto::_internal_available_phone_numbers_size() const {
  return available_phone_numbers_.size();
}
inline int GetUserDataResponseProto::available_phone_numbers_size() const {
  return _internal_available_phone_numbers_size();
}
inline void GetUserDataResponseProto::clear_available_phone_numbers() {
  available_phone_numbers_.Clear();
}
inline ::autofill_assistant::PhoneNumberProto* GetUserDataResponseProto::mutable_available_phone_numbers(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.available_phone_numbers)
  return available_phone_numbers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PhoneNumberProto >*
GetUserDataResponseProto::mutable_available_phone_numbers() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataResponseProto.available_phone_numbers)
  return &available_phone_numbers_;
}
inline const ::autofill_assistant::PhoneNumberProto& GetUserDataResponseProto::_internal_available_phone_numbers(int index) const {
  return available_phone_numbers_.Get(index);
}
inline const ::autofill_assistant::PhoneNumberProto& GetUserDataResponseProto::available_phone_numbers(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.available_phone_numbers)
  return _internal_available_phone_numbers(index);
}
inline ::autofill_assistant::PhoneNumberProto* GetUserDataResponseProto::_internal_add_available_phone_numbers() {
  return available_phone_numbers_.Add();
}
inline ::autofill_assistant::PhoneNumberProto* GetUserDataResponseProto::add_available_phone_numbers() {
  ::autofill_assistant::PhoneNumberProto* _add = _internal_add_available_phone_numbers();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataResponseProto.available_phone_numbers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PhoneNumberProto >&
GetUserDataResponseProto::available_phone_numbers() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataResponseProto.available_phone_numbers)
  return available_phone_numbers_;
}

// optional string selected_phone_number_identifier = 11;
inline bool GetUserDataResponseProto::_internal_has_selected_phone_number_identifier() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_selected_phone_number_identifier() const {
  return _internal_has_selected_phone_number_identifier();
}
inline void GetUserDataResponseProto::clear_selected_phone_number_identifier() {
  selected_phone_number_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& GetUserDataResponseProto::selected_phone_number_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.selected_phone_number_identifier)
  return _internal_selected_phone_number_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_selected_phone_number_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 selected_phone_number_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.selected_phone_number_identifier)
}
inline std::string* GetUserDataResponseProto::mutable_selected_phone_number_identifier() {
  std::string* _s = _internal_mutable_selected_phone_number_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.selected_phone_number_identifier)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_selected_phone_number_identifier() const {
  return selected_phone_number_identifier_.Get();
}
inline void GetUserDataResponseProto::_internal_set_selected_phone_number_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  selected_phone_number_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_selected_phone_number_identifier() {
  _has_bits_[0] |= 0x00000040u;
  return selected_phone_number_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_selected_phone_number_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.selected_phone_number_identifier)
  if (!_internal_has_selected_phone_number_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = selected_phone_number_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_phone_number_identifier_.IsDefault()) {
    selected_phone_number_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_selected_phone_number_identifier(std::string* selected_phone_number_identifier) {
  if (selected_phone_number_identifier != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  selected_phone_number_identifier_.SetAllocated(selected_phone_number_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_phone_number_identifier_.IsDefault()) {
    selected_phone_number_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.selected_phone_number_identifier)
}

// repeated .autofill_assistant.ProfileProto available_addresses = 4;
inline int GetUserDataResponseProto::_internal_available_addresses_size() const {
  return available_addresses_.size();
}
inline int GetUserDataResponseProto::available_addresses_size() const {
  return _internal_available_addresses_size();
}
inline void GetUserDataResponseProto::clear_available_addresses() {
  available_addresses_.Clear();
}
inline ::autofill_assistant::ProfileProto* GetUserDataResponseProto::mutable_available_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.available_addresses)
  return available_addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >*
GetUserDataResponseProto::mutable_available_addresses() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataResponseProto.available_addresses)
  return &available_addresses_;
}
inline const ::autofill_assistant::ProfileProto& GetUserDataResponseProto::_internal_available_addresses(int index) const {
  return available_addresses_.Get(index);
}
inline const ::autofill_assistant::ProfileProto& GetUserDataResponseProto::available_addresses(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.available_addresses)
  return _internal_available_addresses(index);
}
inline ::autofill_assistant::ProfileProto* GetUserDataResponseProto::_internal_add_available_addresses() {
  return available_addresses_.Add();
}
inline ::autofill_assistant::ProfileProto* GetUserDataResponseProto::add_available_addresses() {
  ::autofill_assistant::ProfileProto* _add = _internal_add_available_addresses();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataResponseProto.available_addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProfileProto >&
GetUserDataResponseProto::available_addresses() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataResponseProto.available_addresses)
  return available_addresses_;
}

// optional string selected_shipping_address_identifier = 6;
inline bool GetUserDataResponseProto::_internal_has_selected_shipping_address_identifier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_selected_shipping_address_identifier() const {
  return _internal_has_selected_shipping_address_identifier();
}
inline void GetUserDataResponseProto::clear_selected_shipping_address_identifier() {
  selected_shipping_address_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetUserDataResponseProto::selected_shipping_address_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.selected_shipping_address_identifier)
  return _internal_selected_shipping_address_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_selected_shipping_address_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 selected_shipping_address_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.selected_shipping_address_identifier)
}
inline std::string* GetUserDataResponseProto::mutable_selected_shipping_address_identifier() {
  std::string* _s = _internal_mutable_selected_shipping_address_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.selected_shipping_address_identifier)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_selected_shipping_address_identifier() const {
  return selected_shipping_address_identifier_.Get();
}
inline void GetUserDataResponseProto::_internal_set_selected_shipping_address_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  selected_shipping_address_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_selected_shipping_address_identifier() {
  _has_bits_[0] |= 0x00000004u;
  return selected_shipping_address_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_selected_shipping_address_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.selected_shipping_address_identifier)
  if (!_internal_has_selected_shipping_address_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = selected_shipping_address_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_shipping_address_identifier_.IsDefault()) {
    selected_shipping_address_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_selected_shipping_address_identifier(std::string* selected_shipping_address_identifier) {
  if (selected_shipping_address_identifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  selected_shipping_address_identifier_.SetAllocated(selected_shipping_address_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_shipping_address_identifier_.IsDefault()) {
    selected_shipping_address_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.selected_shipping_address_identifier)
}

// optional bytes add_address_token = 8;
inline bool GetUserDataResponseProto::_internal_has_add_address_token() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_add_address_token() const {
  return _internal_has_add_address_token();
}
inline void GetUserDataResponseProto::clear_add_address_token() {
  add_address_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GetUserDataResponseProto::add_address_token() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.add_address_token)
  return _internal_add_address_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_add_address_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 add_address_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.add_address_token)
}
inline std::string* GetUserDataResponseProto::mutable_add_address_token() {
  std::string* _s = _internal_mutable_add_address_token();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.add_address_token)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_add_address_token() const {
  return add_address_token_.Get();
}
inline void GetUserDataResponseProto::_internal_set_add_address_token(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  add_address_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_add_address_token() {
  _has_bits_[0] |= 0x00000010u;
  return add_address_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_add_address_token() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.add_address_token)
  if (!_internal_has_add_address_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = add_address_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (add_address_token_.IsDefault()) {
    add_address_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_add_address_token(std::string* add_address_token) {
  if (add_address_token != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  add_address_token_.SetAllocated(add_address_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (add_address_token_.IsDefault()) {
    add_address_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.add_address_token)
}

// repeated .autofill_assistant.PaymentInstrumentProto available_payment_instruments = 2;
inline int GetUserDataResponseProto::_internal_available_payment_instruments_size() const {
  return available_payment_instruments_.size();
}
inline int GetUserDataResponseProto::available_payment_instruments_size() const {
  return _internal_available_payment_instruments_size();
}
inline void GetUserDataResponseProto::clear_available_payment_instruments() {
  available_payment_instruments_.Clear();
}
inline ::autofill_assistant::PaymentInstrumentProto* GetUserDataResponseProto::mutable_available_payment_instruments(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.available_payment_instruments)
  return available_payment_instruments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PaymentInstrumentProto >*
GetUserDataResponseProto::mutable_available_payment_instruments() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetUserDataResponseProto.available_payment_instruments)
  return &available_payment_instruments_;
}
inline const ::autofill_assistant::PaymentInstrumentProto& GetUserDataResponseProto::_internal_available_payment_instruments(int index) const {
  return available_payment_instruments_.Get(index);
}
inline const ::autofill_assistant::PaymentInstrumentProto& GetUserDataResponseProto::available_payment_instruments(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.available_payment_instruments)
  return _internal_available_payment_instruments(index);
}
inline ::autofill_assistant::PaymentInstrumentProto* GetUserDataResponseProto::_internal_add_available_payment_instruments() {
  return available_payment_instruments_.Add();
}
inline ::autofill_assistant::PaymentInstrumentProto* GetUserDataResponseProto::add_available_payment_instruments() {
  ::autofill_assistant::PaymentInstrumentProto* _add = _internal_add_available_payment_instruments();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetUserDataResponseProto.available_payment_instruments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PaymentInstrumentProto >&
GetUserDataResponseProto::available_payment_instruments() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetUserDataResponseProto.available_payment_instruments)
  return available_payment_instruments_;
}

// optional string selected_payment_instrument_identifier = 7;
inline bool GetUserDataResponseProto::_internal_has_selected_payment_instrument_identifier() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_selected_payment_instrument_identifier() const {
  return _internal_has_selected_payment_instrument_identifier();
}
inline void GetUserDataResponseProto::clear_selected_payment_instrument_identifier() {
  selected_payment_instrument_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GetUserDataResponseProto::selected_payment_instrument_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.selected_payment_instrument_identifier)
  return _internal_selected_payment_instrument_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_selected_payment_instrument_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 selected_payment_instrument_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.selected_payment_instrument_identifier)
}
inline std::string* GetUserDataResponseProto::mutable_selected_payment_instrument_identifier() {
  std::string* _s = _internal_mutable_selected_payment_instrument_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.selected_payment_instrument_identifier)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_selected_payment_instrument_identifier() const {
  return selected_payment_instrument_identifier_.Get();
}
inline void GetUserDataResponseProto::_internal_set_selected_payment_instrument_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  selected_payment_instrument_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_selected_payment_instrument_identifier() {
  _has_bits_[0] |= 0x00000008u;
  return selected_payment_instrument_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_selected_payment_instrument_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.selected_payment_instrument_identifier)
  if (!_internal_has_selected_payment_instrument_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = selected_payment_instrument_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_payment_instrument_identifier_.IsDefault()) {
    selected_payment_instrument_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_selected_payment_instrument_identifier(std::string* selected_payment_instrument_identifier) {
  if (selected_payment_instrument_identifier != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  selected_payment_instrument_identifier_.SetAllocated(selected_payment_instrument_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_payment_instrument_identifier_.IsDefault()) {
    selected_payment_instrument_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.selected_payment_instrument_identifier)
}

// optional bytes add_payment_instrument_token = 9;
inline bool GetUserDataResponseProto::_internal_has_add_payment_instrument_token() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetUserDataResponseProto::has_add_payment_instrument_token() const {
  return _internal_has_add_payment_instrument_token();
}
inline void GetUserDataResponseProto::clear_add_payment_instrument_token() {
  add_payment_instrument_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& GetUserDataResponseProto::add_payment_instrument_token() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetUserDataResponseProto.add_payment_instrument_token)
  return _internal_add_payment_instrument_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserDataResponseProto::set_add_payment_instrument_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 add_payment_instrument_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetUserDataResponseProto.add_payment_instrument_token)
}
inline std::string* GetUserDataResponseProto::mutable_add_payment_instrument_token() {
  std::string* _s = _internal_mutable_add_payment_instrument_token();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetUserDataResponseProto.add_payment_instrument_token)
  return _s;
}
inline const std::string& GetUserDataResponseProto::_internal_add_payment_instrument_token() const {
  return add_payment_instrument_token_.Get();
}
inline void GetUserDataResponseProto::_internal_set_add_payment_instrument_token(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  add_payment_instrument_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::_internal_mutable_add_payment_instrument_token() {
  _has_bits_[0] |= 0x00000020u;
  return add_payment_instrument_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserDataResponseProto::release_add_payment_instrument_token() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetUserDataResponseProto.add_payment_instrument_token)
  if (!_internal_has_add_payment_instrument_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = add_payment_instrument_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (add_payment_instrument_token_.IsDefault()) {
    add_payment_instrument_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetUserDataResponseProto::set_allocated_add_payment_instrument_token(std::string* add_payment_instrument_token) {
  if (add_payment_instrument_token != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  add_payment_instrument_token_.SetAllocated(add_payment_instrument_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (add_payment_instrument_token_.IsDefault()) {
    add_payment_instrument_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetUserDataResponseProto.add_payment_instrument_token)
}

// -------------------------------------------------------------------

// OverlayImageProto

// string image_url = 1;
inline bool OverlayImageProto::_internal_has_image_url() const {
  return image_case() == kImageUrl;
}
inline bool OverlayImageProto::has_image_url() const {
  return _internal_has_image_url();
}
inline void OverlayImageProto::set_has_image_url() {
  _oneof_case_[0] = kImageUrl;
}
inline void OverlayImageProto::clear_image_url() {
  if (_internal_has_image_url()) {
    image_.image_url_.Destroy();
    clear_has_image();
  }
}
inline const std::string& OverlayImageProto::image_url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline void OverlayImageProto::set_image_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image_url()) {
    clear_image();
    set_has_image_url();
    image_.image_url_.InitDefault();
  }
  image_.image_url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OverlayImageProto.image_url)
}
inline std::string* OverlayImageProto::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.image_url)
  return _s;
}
inline const std::string& OverlayImageProto::_internal_image_url() const {
  if (_internal_has_image_url()) {
    return image_.image_url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void OverlayImageProto::_internal_set_image_url(const std::string& value) {
  if (!_internal_has_image_url()) {
    clear_image();
    set_has_image_url();
    image_.image_url_.InitDefault();
  }
  image_.image_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OverlayImageProto::_internal_mutable_image_url() {
  if (!_internal_has_image_url()) {
    clear_image();
    set_has_image_url();
    image_.image_url_.InitDefault();
  }
  return image_.image_url_.Mutable(      GetArenaForAllocation());
}
inline std::string* OverlayImageProto::release_image_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.image_url)
  if (_internal_has_image_url()) {
    clear_has_image();
    return image_.image_url_.Release();
  } else {
    return nullptr;
  }
}
inline void OverlayImageProto::set_allocated_image_url(std::string* image_url) {
  if (has_image()) {
    clear_image();
  }
  if (image_url != nullptr) {
    set_has_image_url();
    image_.image_url_.InitAllocated(image_url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.image_url)
}

// .autofill_assistant.DrawableProto image_drawable = 8;
inline bool OverlayImageProto::_internal_has_image_drawable() const {
  return image_case() == kImageDrawable;
}
inline bool OverlayImageProto::has_image_drawable() const {
  return _internal_has_image_drawable();
}
inline void OverlayImageProto::set_has_image_drawable() {
  _oneof_case_[0] = kImageDrawable;
}
inline ::autofill_assistant::DrawableProto* OverlayImageProto::release_image_drawable() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.image_drawable)
  if (_internal_has_image_drawable()) {
    clear_has_image();
    ::autofill_assistant::DrawableProto* temp = image_.image_drawable_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.image_drawable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DrawableProto& OverlayImageProto::_internal_image_drawable() const {
  return _internal_has_image_drawable()
      ? *image_.image_drawable_
      : reinterpret_cast< ::autofill_assistant::DrawableProto&>(::autofill_assistant::_DrawableProto_default_instance_);
}
inline const ::autofill_assistant::DrawableProto& OverlayImageProto::image_drawable() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.image_drawable)
  return _internal_image_drawable();
}
inline ::autofill_assistant::DrawableProto* OverlayImageProto::unsafe_arena_release_image_drawable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.OverlayImageProto.image_drawable)
  if (_internal_has_image_drawable()) {
    clear_has_image();
    ::autofill_assistant::DrawableProto* temp = image_.image_drawable_;
    image_.image_drawable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OverlayImageProto::unsafe_arena_set_allocated_image_drawable(::autofill_assistant::DrawableProto* image_drawable) {
  clear_image();
  if (image_drawable) {
    set_has_image_drawable();
    image_.image_drawable_ = image_drawable;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.OverlayImageProto.image_drawable)
}
inline ::autofill_assistant::DrawableProto* OverlayImageProto::_internal_mutable_image_drawable() {
  if (!_internal_has_image_drawable()) {
    clear_image();
    set_has_image_drawable();
    image_.image_drawable_ = CreateMaybeMessage< ::autofill_assistant::DrawableProto >(GetArenaForAllocation());
  }
  return image_.image_drawable_;
}
inline ::autofill_assistant::DrawableProto* OverlayImageProto::mutable_image_drawable() {
  ::autofill_assistant::DrawableProto* _msg = _internal_mutable_image_drawable();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.image_drawable)
  return _msg;
}

// optional .autofill_assistant.ClientDimensionProto image_size = 2;
inline bool OverlayImageProto::_internal_has_image_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || image_size_ != nullptr);
  return value;
}
inline bool OverlayImageProto::has_image_size() const {
  return _internal_has_image_size();
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::_internal_image_size() const {
  const ::autofill_assistant::ClientDimensionProto* p = image_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::image_size() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.image_size)
  return _internal_image_size();
}
inline void OverlayImageProto::unsafe_arena_set_allocated_image_size(
    ::autofill_assistant::ClientDimensionProto* image_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_size_);
  }
  image_size_ = image_size;
  if (image_size) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.OverlayImageProto.image_size)
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::release_image_size() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientDimensionProto* temp = image_size_;
  image_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::unsafe_arena_release_image_size() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.image_size)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientDimensionProto* temp = image_size_;
  image_size_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::_internal_mutable_image_size() {
  _has_bits_[0] |= 0x00000004u;
  if (image_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    image_size_ = p;
  }
  return image_size_;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::mutable_image_size() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_image_size();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.image_size)
  return _msg;
}
inline void OverlayImageProto::set_allocated_image_size(::autofill_assistant::ClientDimensionProto* image_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_size_);
  }
  if (image_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_size));
    if (message_arena != submessage_arena) {
      image_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  image_size_ = image_size;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.image_size)
}

// optional .autofill_assistant.ClientDimensionProto image_top_margin = 3;
inline bool OverlayImageProto::_internal_has_image_top_margin() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || image_top_margin_ != nullptr);
  return value;
}
inline bool OverlayImageProto::has_image_top_margin() const {
  return _internal_has_image_top_margin();
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::_internal_image_top_margin() const {
  const ::autofill_assistant::ClientDimensionProto* p = image_top_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::image_top_margin() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.image_top_margin)
  return _internal_image_top_margin();
}
inline void OverlayImageProto::unsafe_arena_set_allocated_image_top_margin(
    ::autofill_assistant::ClientDimensionProto* image_top_margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_top_margin_);
  }
  image_top_margin_ = image_top_margin;
  if (image_top_margin) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.OverlayImageProto.image_top_margin)
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::release_image_top_margin() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientDimensionProto* temp = image_top_margin_;
  image_top_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::unsafe_arena_release_image_top_margin() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.image_top_margin)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientDimensionProto* temp = image_top_margin_;
  image_top_margin_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::_internal_mutable_image_top_margin() {
  _has_bits_[0] |= 0x00000008u;
  if (image_top_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    image_top_margin_ = p;
  }
  return image_top_margin_;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::mutable_image_top_margin() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_image_top_margin();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.image_top_margin)
  return _msg;
}
inline void OverlayImageProto::set_allocated_image_top_margin(::autofill_assistant::ClientDimensionProto* image_top_margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_top_margin_);
  }
  if (image_top_margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_top_margin));
    if (message_arena != submessage_arena) {
      image_top_margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_top_margin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  image_top_margin_ = image_top_margin;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.image_top_margin)
}

// optional .autofill_assistant.ClientDimensionProto image_bottom_margin = 4;
inline bool OverlayImageProto::_internal_has_image_bottom_margin() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || image_bottom_margin_ != nullptr);
  return value;
}
inline bool OverlayImageProto::has_image_bottom_margin() const {
  return _internal_has_image_bottom_margin();
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::_internal_image_bottom_margin() const {
  const ::autofill_assistant::ClientDimensionProto* p = image_bottom_margin_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::image_bottom_margin() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.image_bottom_margin)
  return _internal_image_bottom_margin();
}
inline void OverlayImageProto::unsafe_arena_set_allocated_image_bottom_margin(
    ::autofill_assistant::ClientDimensionProto* image_bottom_margin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_bottom_margin_);
  }
  image_bottom_margin_ = image_bottom_margin;
  if (image_bottom_margin) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.OverlayImageProto.image_bottom_margin)
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::release_image_bottom_margin() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ClientDimensionProto* temp = image_bottom_margin_;
  image_bottom_margin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::unsafe_arena_release_image_bottom_margin() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.image_bottom_margin)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ClientDimensionProto* temp = image_bottom_margin_;
  image_bottom_margin_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::_internal_mutable_image_bottom_margin() {
  _has_bits_[0] |= 0x00000010u;
  if (image_bottom_margin_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    image_bottom_margin_ = p;
  }
  return image_bottom_margin_;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::mutable_image_bottom_margin() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_image_bottom_margin();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.image_bottom_margin)
  return _msg;
}
inline void OverlayImageProto::set_allocated_image_bottom_margin(::autofill_assistant::ClientDimensionProto* image_bottom_margin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_bottom_margin_);
  }
  if (image_bottom_margin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_bottom_margin));
    if (message_arena != submessage_arena) {
      image_bottom_margin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_bottom_margin, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  image_bottom_margin_ = image_bottom_margin;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.image_bottom_margin)
}

// optional string text = 5;
inline bool OverlayImageProto::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OverlayImageProto::has_text() const {
  return _internal_has_text();
}
inline void OverlayImageProto::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OverlayImageProto::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverlayImageProto::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OverlayImageProto.text)
}
inline std::string* OverlayImageProto::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.text)
  return _s;
}
inline const std::string& OverlayImageProto::_internal_text() const {
  return text_.Get();
}
inline void OverlayImageProto::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* OverlayImageProto::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* OverlayImageProto::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OverlayImageProto::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.text)
}

// optional string text_color = 6;
inline bool OverlayImageProto::_internal_has_text_color() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OverlayImageProto::has_text_color() const {
  return _internal_has_text_color();
}
inline void OverlayImageProto::clear_text_color() {
  text_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OverlayImageProto::text_color() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.text_color)
  return _internal_text_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverlayImageProto::set_text_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 text_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.OverlayImageProto.text_color)
}
inline std::string* OverlayImageProto::mutable_text_color() {
  std::string* _s = _internal_mutable_text_color();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.text_color)
  return _s;
}
inline const std::string& OverlayImageProto::_internal_text_color() const {
  return text_color_.Get();
}
inline void OverlayImageProto::_internal_set_text_color(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_color_.Set(value, GetArenaForAllocation());
}
inline std::string* OverlayImageProto::_internal_mutable_text_color() {
  _has_bits_[0] |= 0x00000002u;
  return text_color_.Mutable(GetArenaForAllocation());
}
inline std::string* OverlayImageProto::release_text_color() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.text_color)
  if (!_internal_has_text_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = text_color_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_color_.IsDefault()) {
    text_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OverlayImageProto::set_allocated_text_color(std::string* text_color) {
  if (text_color != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_color_.SetAllocated(text_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_color_.IsDefault()) {
    text_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.text_color)
}

// optional .autofill_assistant.ClientDimensionProto text_size = 7;
inline bool OverlayImageProto::_internal_has_text_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || text_size_ != nullptr);
  return value;
}
inline bool OverlayImageProto::has_text_size() const {
  return _internal_has_text_size();
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::_internal_text_size() const {
  const ::autofill_assistant::ClientDimensionProto* p = text_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& OverlayImageProto::text_size() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.OverlayImageProto.text_size)
  return _internal_text_size();
}
inline void OverlayImageProto::unsafe_arena_set_allocated_text_size(
    ::autofill_assistant::ClientDimensionProto* text_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_size_);
  }
  text_size_ = text_size;
  if (text_size) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.OverlayImageProto.text_size)
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::release_text_size() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill_assistant::ClientDimensionProto* temp = text_size_;
  text_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::unsafe_arena_release_text_size() {
  // @@protoc_insertion_point(field_release:autofill_assistant.OverlayImageProto.text_size)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill_assistant::ClientDimensionProto* temp = text_size_;
  text_size_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::_internal_mutable_text_size() {
  _has_bits_[0] |= 0x00000020u;
  if (text_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    text_size_ = p;
  }
  return text_size_;
}
inline ::autofill_assistant::ClientDimensionProto* OverlayImageProto::mutable_text_size() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_text_size();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.OverlayImageProto.text_size)
  return _msg;
}
inline void OverlayImageProto::set_allocated_text_size(::autofill_assistant::ClientDimensionProto* text_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_size_);
  }
  if (text_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_size));
    if (message_arena != submessage_arena) {
      text_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  text_size_ = text_size;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.text_size)
}

inline bool OverlayImageProto::has_image() const {
  return image_case() != IMAGE_NOT_SET;
}
inline void OverlayImageProto::clear_has_image() {
  _oneof_case_[0] = IMAGE_NOT_SET;
}
inline OverlayImageProto::ImageCase OverlayImageProto::image_case() const {
  return OverlayImageProto::ImageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientSettingsProto_IntegrationTestSettings

// optional bool disable_header_animations = 1;
inline bool ClientSettingsProto_IntegrationTestSettings::_internal_has_disable_header_animations() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientSettingsProto_IntegrationTestSettings::has_disable_header_animations() const {
  return _internal_has_disable_header_animations();
}
inline void ClientSettingsProto_IntegrationTestSettings::clear_disable_header_animations() {
  disable_header_animations_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ClientSettingsProto_IntegrationTestSettings::_internal_disable_header_animations() const {
  return disable_header_animations_;
}
inline bool ClientSettingsProto_IntegrationTestSettings::disable_header_animations() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.IntegrationTestSettings.disable_header_animations)
  return _internal_disable_header_animations();
}
inline void ClientSettingsProto_IntegrationTestSettings::_internal_set_disable_header_animations(bool value) {
  _has_bits_[0] |= 0x00000001u;
  disable_header_animations_ = value;
}
inline void ClientSettingsProto_IntegrationTestSettings::set_disable_header_animations(bool value) {
  _internal_set_disable_header_animations(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.IntegrationTestSettings.disable_header_animations)
}

// optional bool disable_carousel_change_animations = 2;
inline bool ClientSettingsProto_IntegrationTestSettings::_internal_has_disable_carousel_change_animations() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientSettingsProto_IntegrationTestSettings::has_disable_carousel_change_animations() const {
  return _internal_has_disable_carousel_change_animations();
}
inline void ClientSettingsProto_IntegrationTestSettings::clear_disable_carousel_change_animations() {
  disable_carousel_change_animations_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ClientSettingsProto_IntegrationTestSettings::_internal_disable_carousel_change_animations() const {
  return disable_carousel_change_animations_;
}
inline bool ClientSettingsProto_IntegrationTestSettings::disable_carousel_change_animations() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.IntegrationTestSettings.disable_carousel_change_animations)
  return _internal_disable_carousel_change_animations();
}
inline void ClientSettingsProto_IntegrationTestSettings::_internal_set_disable_carousel_change_animations(bool value) {
  _has_bits_[0] |= 0x00000002u;
  disable_carousel_change_animations_ = value;
}
inline void ClientSettingsProto_IntegrationTestSettings::set_disable_carousel_change_animations(bool value) {
  _internal_set_disable_carousel_change_animations(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.IntegrationTestSettings.disable_carousel_change_animations)
}

// -------------------------------------------------------------------

// ClientSettingsProto_BackButtonSettings

// optional string undo_label = 2;
inline bool ClientSettingsProto_BackButtonSettings::_internal_has_undo_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientSettingsProto_BackButtonSettings::has_undo_label() const {
  return _internal_has_undo_label();
}
inline void ClientSettingsProto_BackButtonSettings::clear_undo_label() {
  undo_label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientSettingsProto_BackButtonSettings::undo_label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.BackButtonSettings.undo_label)
  return _internal_undo_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientSettingsProto_BackButtonSettings::set_undo_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 undo_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.BackButtonSettings.undo_label)
}
inline std::string* ClientSettingsProto_BackButtonSettings::mutable_undo_label() {
  std::string* _s = _internal_mutable_undo_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.BackButtonSettings.undo_label)
  return _s;
}
inline const std::string& ClientSettingsProto_BackButtonSettings::_internal_undo_label() const {
  return undo_label_.Get();
}
inline void ClientSettingsProto_BackButtonSettings::_internal_set_undo_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  undo_label_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_BackButtonSettings::_internal_mutable_undo_label() {
  _has_bits_[0] |= 0x00000001u;
  return undo_label_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_BackButtonSettings::release_undo_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.BackButtonSettings.undo_label)
  if (!_internal_has_undo_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = undo_label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (undo_label_.IsDefault()) {
    undo_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientSettingsProto_BackButtonSettings::set_allocated_undo_label(std::string* undo_label) {
  if (undo_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  undo_label_.SetAllocated(undo_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (undo_label_.IsDefault()) {
    undo_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.BackButtonSettings.undo_label)
}

// -------------------------------------------------------------------

// ClientSettingsProto_SlowWarningSettings

// optional bool enable_slow_connection_warnings = 1;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_enable_slow_connection_warnings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_enable_slow_connection_warnings() const {
  return _internal_has_enable_slow_connection_warnings();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_enable_slow_connection_warnings() {
  enable_slow_connection_warnings_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ClientSettingsProto_SlowWarningSettings::_internal_enable_slow_connection_warnings() const {
  return enable_slow_connection_warnings_;
}
inline bool ClientSettingsProto_SlowWarningSettings::enable_slow_connection_warnings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.enable_slow_connection_warnings)
  return _internal_enable_slow_connection_warnings();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_enable_slow_connection_warnings(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_slow_connection_warnings_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_enable_slow_connection_warnings(bool value) {
  _internal_set_enable_slow_connection_warnings(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.enable_slow_connection_warnings)
}

// optional bool enable_slow_website_warnings = 2;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_enable_slow_website_warnings() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_enable_slow_website_warnings() const {
  return _internal_has_enable_slow_website_warnings();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_enable_slow_website_warnings() {
  enable_slow_website_warnings_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClientSettingsProto_SlowWarningSettings::_internal_enable_slow_website_warnings() const {
  return enable_slow_website_warnings_;
}
inline bool ClientSettingsProto_SlowWarningSettings::enable_slow_website_warnings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.enable_slow_website_warnings)
  return _internal_enable_slow_website_warnings();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_enable_slow_website_warnings(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_slow_website_warnings_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_enable_slow_website_warnings(bool value) {
  _internal_set_enable_slow_website_warnings(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.enable_slow_website_warnings)
}

// optional bool only_show_warning_once = 3;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_only_show_warning_once() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_only_show_warning_once() const {
  return _internal_has_only_show_warning_once();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_only_show_warning_once() {
  only_show_warning_once_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ClientSettingsProto_SlowWarningSettings::_internal_only_show_warning_once() const {
  return only_show_warning_once_;
}
inline bool ClientSettingsProto_SlowWarningSettings::only_show_warning_once() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.only_show_warning_once)
  return _internal_only_show_warning_once();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_only_show_warning_once(bool value) {
  _has_bits_[0] |= 0x00000010u;
  only_show_warning_once_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_only_show_warning_once(bool value) {
  _internal_set_only_show_warning_once(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.only_show_warning_once)
}

// optional bool only_show_connection_warning_once = 4;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_only_show_connection_warning_once() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_only_show_connection_warning_once() const {
  return _internal_has_only_show_connection_warning_once();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_only_show_connection_warning_once() {
  only_show_connection_warning_once_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ClientSettingsProto_SlowWarningSettings::_internal_only_show_connection_warning_once() const {
  return only_show_connection_warning_once_;
}
inline bool ClientSettingsProto_SlowWarningSettings::only_show_connection_warning_once() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.only_show_connection_warning_once)
  return _internal_only_show_connection_warning_once();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_only_show_connection_warning_once(bool value) {
  _has_bits_[0] |= 0x00000020u;
  only_show_connection_warning_once_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_only_show_connection_warning_once(bool value) {
  _internal_set_only_show_connection_warning_once(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.only_show_connection_warning_once)
}

// optional bool only_show_website_warning_once = 5;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_only_show_website_warning_once() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_only_show_website_warning_once() const {
  return _internal_has_only_show_website_warning_once();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_only_show_website_warning_once() {
  only_show_website_warning_once_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ClientSettingsProto_SlowWarningSettings::_internal_only_show_website_warning_once() const {
  return only_show_website_warning_once_;
}
inline bool ClientSettingsProto_SlowWarningSettings::only_show_website_warning_once() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.only_show_website_warning_once)
  return _internal_only_show_website_warning_once();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_only_show_website_warning_once(bool value) {
  _has_bits_[0] |= 0x00000040u;
  only_show_website_warning_once_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_only_show_website_warning_once(bool value) {
  _internal_set_only_show_website_warning_once(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.only_show_website_warning_once)
}

// optional int32 warning_delay_ms = 6;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_warning_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_warning_delay_ms() const {
  return _internal_has_warning_delay_ms();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_warning_delay_ms() {
  warning_delay_ms_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::_internal_warning_delay_ms() const {
  return warning_delay_ms_;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::warning_delay_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.warning_delay_ms)
  return _internal_warning_delay_ms();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_warning_delay_ms(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  warning_delay_ms_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_warning_delay_ms(int32_t value) {
  _internal_set_warning_delay_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.warning_delay_ms)
}

// optional int32 slow_roundtrip_threshold_ms = 7;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_slow_roundtrip_threshold_ms() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_slow_roundtrip_threshold_ms() const {
  return _internal_has_slow_roundtrip_threshold_ms();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_slow_roundtrip_threshold_ms() {
  slow_roundtrip_threshold_ms_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::_internal_slow_roundtrip_threshold_ms() const {
  return slow_roundtrip_threshold_ms_;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::slow_roundtrip_threshold_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_roundtrip_threshold_ms)
  return _internal_slow_roundtrip_threshold_ms();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_slow_roundtrip_threshold_ms(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  slow_roundtrip_threshold_ms_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_slow_roundtrip_threshold_ms(int32_t value) {
  _internal_set_slow_roundtrip_threshold_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_roundtrip_threshold_ms)
}

// optional int32 max_consecutive_slow_roundtrips = 8;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_max_consecutive_slow_roundtrips() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_max_consecutive_slow_roundtrips() const {
  return _internal_has_max_consecutive_slow_roundtrips();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_max_consecutive_slow_roundtrips() {
  max_consecutive_slow_roundtrips_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::_internal_max_consecutive_slow_roundtrips() const {
  return max_consecutive_slow_roundtrips_;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::max_consecutive_slow_roundtrips() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.max_consecutive_slow_roundtrips)
  return _internal_max_consecutive_slow_roundtrips();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_max_consecutive_slow_roundtrips(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  max_consecutive_slow_roundtrips_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_max_consecutive_slow_roundtrips(int32_t value) {
  _internal_set_max_consecutive_slow_roundtrips(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.max_consecutive_slow_roundtrips)
}

// optional string slow_connection_message = 9;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_slow_connection_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_slow_connection_message() const {
  return _internal_has_slow_connection_message();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_slow_connection_message() {
  slow_connection_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientSettingsProto_SlowWarningSettings::slow_connection_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_connection_message)
  return _internal_slow_connection_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientSettingsProto_SlowWarningSettings::set_slow_connection_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 slow_connection_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_connection_message)
}
inline std::string* ClientSettingsProto_SlowWarningSettings::mutable_slow_connection_message() {
  std::string* _s = _internal_mutable_slow_connection_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_connection_message)
  return _s;
}
inline const std::string& ClientSettingsProto_SlowWarningSettings::_internal_slow_connection_message() const {
  return slow_connection_message_.Get();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_slow_connection_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  slow_connection_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_SlowWarningSettings::_internal_mutable_slow_connection_message() {
  _has_bits_[0] |= 0x00000001u;
  return slow_connection_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_SlowWarningSettings::release_slow_connection_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_connection_message)
  if (!_internal_has_slow_connection_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = slow_connection_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slow_connection_message_.IsDefault()) {
    slow_connection_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientSettingsProto_SlowWarningSettings::set_allocated_slow_connection_message(std::string* slow_connection_message) {
  if (slow_connection_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  slow_connection_message_.SetAllocated(slow_connection_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slow_connection_message_.IsDefault()) {
    slow_connection_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_connection_message)
}

// optional string slow_website_message = 10;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_slow_website_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_slow_website_message() const {
  return _internal_has_slow_website_message();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_slow_website_message() {
  slow_website_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientSettingsProto_SlowWarningSettings::slow_website_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_website_message)
  return _internal_slow_website_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientSettingsProto_SlowWarningSettings::set_slow_website_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 slow_website_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_website_message)
}
inline std::string* ClientSettingsProto_SlowWarningSettings::mutable_slow_website_message() {
  std::string* _s = _internal_mutable_slow_website_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_website_message)
  return _s;
}
inline const std::string& ClientSettingsProto_SlowWarningSettings::_internal_slow_website_message() const {
  return slow_website_message_.Get();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_slow_website_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  slow_website_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_SlowWarningSettings::_internal_mutable_slow_website_message() {
  _has_bits_[0] |= 0x00000002u;
  return slow_website_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_SlowWarningSettings::release_slow_website_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_website_message)
  if (!_internal_has_slow_website_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = slow_website_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slow_website_message_.IsDefault()) {
    slow_website_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientSettingsProto_SlowWarningSettings::set_allocated_slow_website_message(std::string* slow_website_message) {
  if (slow_website_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  slow_website_message_.SetAllocated(slow_website_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slow_website_message_.IsDefault()) {
    slow_website_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.SlowWarningSettings.slow_website_message)
}

// optional int32 minimum_warning_message_duration_ms = 11;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_minimum_warning_message_duration_ms() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_minimum_warning_message_duration_ms() const {
  return _internal_has_minimum_warning_message_duration_ms();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_minimum_warning_message_duration_ms() {
  minimum_warning_message_duration_ms_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::_internal_minimum_warning_message_duration_ms() const {
  return minimum_warning_message_duration_ms_;
}
inline int32_t ClientSettingsProto_SlowWarningSettings::minimum_warning_message_duration_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.minimum_warning_message_duration_ms)
  return _internal_minimum_warning_message_duration_ms();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_minimum_warning_message_duration_ms(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  minimum_warning_message_duration_ms_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_minimum_warning_message_duration_ms(int32_t value) {
  _internal_set_minimum_warning_message_duration_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.minimum_warning_message_duration_ms)
}

// optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings.MessageMode message_mode = 12;
inline bool ClientSettingsProto_SlowWarningSettings::_internal_has_message_mode() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ClientSettingsProto_SlowWarningSettings::has_message_mode() const {
  return _internal_has_message_mode();
}
inline void ClientSettingsProto_SlowWarningSettings::clear_message_mode() {
  message_mode_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::_internal_message_mode() const {
  return static_cast< ::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode >(message_mode_);
}
inline ::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::message_mode() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.SlowWarningSettings.message_mode)
  return _internal_message_mode();
}
inline void ClientSettingsProto_SlowWarningSettings::_internal_set_message_mode(::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode value) {
  assert(::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  message_mode_ = value;
}
inline void ClientSettingsProto_SlowWarningSettings::set_message_mode(::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode value) {
  _internal_set_message_mode(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.SlowWarningSettings.message_mode)
}

// -------------------------------------------------------------------

// ClientSettingsProto_DisplayString

// optional .autofill_assistant.ClientSettingsProto.DisplayStringId id = 1;
inline bool ClientSettingsProto_DisplayString::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientSettingsProto_DisplayString::has_id() const {
  return _internal_has_id();
}
inline void ClientSettingsProto_DisplayString::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::ClientSettingsProto_DisplayStringId ClientSettingsProto_DisplayString::_internal_id() const {
  return static_cast< ::autofill_assistant::ClientSettingsProto_DisplayStringId >(id_);
}
inline ::autofill_assistant::ClientSettingsProto_DisplayStringId ClientSettingsProto_DisplayString::id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.DisplayString.id)
  return _internal_id();
}
inline void ClientSettingsProto_DisplayString::_internal_set_id(::autofill_assistant::ClientSettingsProto_DisplayStringId value) {
  assert(::autofill_assistant::ClientSettingsProto_DisplayStringId_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void ClientSettingsProto_DisplayString::set_id(::autofill_assistant::ClientSettingsProto_DisplayStringId value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.DisplayString.id)
}

// optional string value = 2;
inline bool ClientSettingsProto_DisplayString::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientSettingsProto_DisplayString::has_value() const {
  return _internal_has_value();
}
inline void ClientSettingsProto_DisplayString::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientSettingsProto_DisplayString::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.DisplayString.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientSettingsProto_DisplayString::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.DisplayString.value)
}
inline std::string* ClientSettingsProto_DisplayString::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.DisplayString.value)
  return _s;
}
inline const std::string& ClientSettingsProto_DisplayString::_internal_value() const {
  return value_.Get();
}
inline void ClientSettingsProto_DisplayString::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_DisplayString::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientSettingsProto_DisplayString::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.DisplayString.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientSettingsProto_DisplayString::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.DisplayString.value)
}

// -------------------------------------------------------------------

// ClientSettingsProto

// optional int32 periodic_script_check_interval_ms = 1;
inline bool ClientSettingsProto::_internal_has_periodic_script_check_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_periodic_script_check_interval_ms() const {
  return _internal_has_periodic_script_check_interval_ms();
}
inline void ClientSettingsProto::clear_periodic_script_check_interval_ms() {
  periodic_script_check_interval_ms_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ClientSettingsProto::_internal_periodic_script_check_interval_ms() const {
  return periodic_script_check_interval_ms_;
}
inline int32_t ClientSettingsProto::periodic_script_check_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.periodic_script_check_interval_ms)
  return _internal_periodic_script_check_interval_ms();
}
inline void ClientSettingsProto::_internal_set_periodic_script_check_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  periodic_script_check_interval_ms_ = value;
}
inline void ClientSettingsProto::set_periodic_script_check_interval_ms(int32_t value) {
  _internal_set_periodic_script_check_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.periodic_script_check_interval_ms)
}

// optional int32 periodic_element_check_interval_ms = 2;
inline bool ClientSettingsProto::_internal_has_periodic_element_check_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_periodic_element_check_interval_ms() const {
  return _internal_has_periodic_element_check_interval_ms();
}
inline void ClientSettingsProto::clear_periodic_element_check_interval_ms() {
  periodic_element_check_interval_ms_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ClientSettingsProto::_internal_periodic_element_check_interval_ms() const {
  return periodic_element_check_interval_ms_;
}
inline int32_t ClientSettingsProto::periodic_element_check_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.periodic_element_check_interval_ms)
  return _internal_periodic_element_check_interval_ms();
}
inline void ClientSettingsProto::_internal_set_periodic_element_check_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  periodic_element_check_interval_ms_ = value;
}
inline void ClientSettingsProto::set_periodic_element_check_interval_ms(int32_t value) {
  _internal_set_periodic_element_check_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.periodic_element_check_interval_ms)
}

// optional int32 periodic_script_check_count = 3;
inline bool ClientSettingsProto::_internal_has_periodic_script_check_count() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_periodic_script_check_count() const {
  return _internal_has_periodic_script_check_count();
}
inline void ClientSettingsProto::clear_periodic_script_check_count() {
  periodic_script_check_count_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ClientSettingsProto::_internal_periodic_script_check_count() const {
  return periodic_script_check_count_;
}
inline int32_t ClientSettingsProto::periodic_script_check_count() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.periodic_script_check_count)
  return _internal_periodic_script_check_count();
}
inline void ClientSettingsProto::_internal_set_periodic_script_check_count(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  periodic_script_check_count_ = value;
}
inline void ClientSettingsProto::set_periodic_script_check_count(int32_t value) {
  _internal_set_periodic_script_check_count(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.periodic_script_check_count)
}

// optional int32 element_position_update_interval_ms = 4;
inline bool ClientSettingsProto::_internal_has_element_position_update_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_element_position_update_interval_ms() const {
  return _internal_has_element_position_update_interval_ms();
}
inline void ClientSettingsProto::clear_element_position_update_interval_ms() {
  element_position_update_interval_ms_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ClientSettingsProto::_internal_element_position_update_interval_ms() const {
  return element_position_update_interval_ms_;
}
inline int32_t ClientSettingsProto::element_position_update_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.element_position_update_interval_ms)
  return _internal_element_position_update_interval_ms();
}
inline void ClientSettingsProto::_internal_set_element_position_update_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  element_position_update_interval_ms_ = value;
}
inline void ClientSettingsProto::set_element_position_update_interval_ms(int32_t value) {
  _internal_set_element_position_update_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.element_position_update_interval_ms)
}

// optional int32 short_wait_for_element_deadline_ms = 5;
inline bool ClientSettingsProto::_internal_has_short_wait_for_element_deadline_ms() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_short_wait_for_element_deadline_ms() const {
  return _internal_has_short_wait_for_element_deadline_ms();
}
inline void ClientSettingsProto::clear_short_wait_for_element_deadline_ms() {
  short_wait_for_element_deadline_ms_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ClientSettingsProto::_internal_short_wait_for_element_deadline_ms() const {
  return short_wait_for_element_deadline_ms_;
}
inline int32_t ClientSettingsProto::short_wait_for_element_deadline_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.short_wait_for_element_deadline_ms)
  return _internal_short_wait_for_element_deadline_ms();
}
inline void ClientSettingsProto::_internal_set_short_wait_for_element_deadline_ms(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  short_wait_for_element_deadline_ms_ = value;
}
inline void ClientSettingsProto::set_short_wait_for_element_deadline_ms(int32_t value) {
  _internal_set_short_wait_for_element_deadline_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.short_wait_for_element_deadline_ms)
}

// optional int32 box_model_check_interval_ms = 6;
inline bool ClientSettingsProto::_internal_has_box_model_check_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_box_model_check_interval_ms() const {
  return _internal_has_box_model_check_interval_ms();
}
inline void ClientSettingsProto::clear_box_model_check_interval_ms() {
  box_model_check_interval_ms_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t ClientSettingsProto::_internal_box_model_check_interval_ms() const {
  return box_model_check_interval_ms_;
}
inline int32_t ClientSettingsProto::box_model_check_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.box_model_check_interval_ms)
  return _internal_box_model_check_interval_ms();
}
inline void ClientSettingsProto::_internal_set_box_model_check_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  box_model_check_interval_ms_ = value;
}
inline void ClientSettingsProto::set_box_model_check_interval_ms(int32_t value) {
  _internal_set_box_model_check_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.box_model_check_interval_ms)
}

// optional int32 box_model_check_count = 7;
inline bool ClientSettingsProto::_internal_has_box_model_check_count() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_box_model_check_count() const {
  return _internal_has_box_model_check_count();
}
inline void ClientSettingsProto::clear_box_model_check_count() {
  box_model_check_count_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline int32_t ClientSettingsProto::_internal_box_model_check_count() const {
  return box_model_check_count_;
}
inline int32_t ClientSettingsProto::box_model_check_count() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.box_model_check_count)
  return _internal_box_model_check_count();
}
inline void ClientSettingsProto::_internal_set_box_model_check_count(int32_t value) {
  _has_bits_[0] |= 0x00000800u;
  box_model_check_count_ = value;
}
inline void ClientSettingsProto::set_box_model_check_count(int32_t value) {
  _internal_set_box_model_check_count(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.box_model_check_count)
}

// optional int32 document_ready_check_timeout_ms = 20;
inline bool ClientSettingsProto::_internal_has_document_ready_check_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_document_ready_check_timeout_ms() const {
  return _internal_has_document_ready_check_timeout_ms();
}
inline void ClientSettingsProto::clear_document_ready_check_timeout_ms() {
  document_ready_check_timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline int32_t ClientSettingsProto::_internal_document_ready_check_timeout_ms() const {
  return document_ready_check_timeout_ms_;
}
inline int32_t ClientSettingsProto::document_ready_check_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.document_ready_check_timeout_ms)
  return _internal_document_ready_check_timeout_ms();
}
inline void ClientSettingsProto::_internal_set_document_ready_check_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00020000u;
  document_ready_check_timeout_ms_ = value;
}
inline void ClientSettingsProto::set_document_ready_check_timeout_ms(int32_t value) {
  _internal_set_document_ready_check_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.document_ready_check_timeout_ms)
}

// optional int32 cancel_delay_ms = 12;
inline bool ClientSettingsProto::_internal_has_cancel_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_cancel_delay_ms() const {
  return _internal_has_cancel_delay_ms();
}
inline void ClientSettingsProto::clear_cancel_delay_ms() {
  cancel_delay_ms_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline int32_t ClientSettingsProto::_internal_cancel_delay_ms() const {
  return cancel_delay_ms_;
}
inline int32_t ClientSettingsProto::cancel_delay_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.cancel_delay_ms)
  return _internal_cancel_delay_ms();
}
inline void ClientSettingsProto::_internal_set_cancel_delay_ms(int32_t value) {
  _has_bits_[0] |= 0x00001000u;
  cancel_delay_ms_ = value;
}
inline void ClientSettingsProto::set_cancel_delay_ms(int32_t value) {
  _internal_set_cancel_delay_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.cancel_delay_ms)
}

// optional int32 tap_count = 13;
inline bool ClientSettingsProto::_internal_has_tap_count() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_tap_count() const {
  return _internal_has_tap_count();
}
inline void ClientSettingsProto::clear_tap_count() {
  tap_count_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline int32_t ClientSettingsProto::_internal_tap_count() const {
  return tap_count_;
}
inline int32_t ClientSettingsProto::tap_count() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.tap_count)
  return _internal_tap_count();
}
inline void ClientSettingsProto::_internal_set_tap_count(int32_t value) {
  _has_bits_[0] |= 0x00002000u;
  tap_count_ = value;
}
inline void ClientSettingsProto::set_tap_count(int32_t value) {
  _internal_set_tap_count(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.tap_count)
}

// optional int32 tap_tracking_duration_ms = 14;
inline bool ClientSettingsProto::_internal_has_tap_tracking_duration_ms() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_tap_tracking_duration_ms() const {
  return _internal_has_tap_tracking_duration_ms();
}
inline void ClientSettingsProto::clear_tap_tracking_duration_ms() {
  tap_tracking_duration_ms_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline int32_t ClientSettingsProto::_internal_tap_tracking_duration_ms() const {
  return tap_tracking_duration_ms_;
}
inline int32_t ClientSettingsProto::tap_tracking_duration_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.tap_tracking_duration_ms)
  return _internal_tap_tracking_duration_ms();
}
inline void ClientSettingsProto::_internal_set_tap_tracking_duration_ms(int32_t value) {
  _has_bits_[0] |= 0x00004000u;
  tap_tracking_duration_ms_ = value;
}
inline void ClientSettingsProto::set_tap_tracking_duration_ms(int32_t value) {
  _internal_set_tap_tracking_duration_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.tap_tracking_duration_ms)
}

// optional int32 tap_shutdown_delay_ms = 15;
inline bool ClientSettingsProto::_internal_has_tap_shutdown_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_tap_shutdown_delay_ms() const {
  return _internal_has_tap_shutdown_delay_ms();
}
inline void ClientSettingsProto::clear_tap_shutdown_delay_ms() {
  tap_shutdown_delay_ms_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline int32_t ClientSettingsProto::_internal_tap_shutdown_delay_ms() const {
  return tap_shutdown_delay_ms_;
}
inline int32_t ClientSettingsProto::tap_shutdown_delay_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.tap_shutdown_delay_ms)
  return _internal_tap_shutdown_delay_ms();
}
inline void ClientSettingsProto::_internal_set_tap_shutdown_delay_ms(int32_t value) {
  _has_bits_[0] |= 0x00008000u;
  tap_shutdown_delay_ms_ = value;
}
inline void ClientSettingsProto::set_tap_shutdown_delay_ms(int32_t value) {
  _internal_set_tap_shutdown_delay_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.tap_shutdown_delay_ms)
}

// optional .autofill_assistant.OverlayImageProto overlay_image = 16;
inline bool ClientSettingsProto::_internal_has_overlay_image() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || overlay_image_ != nullptr);
  return value;
}
inline bool ClientSettingsProto::has_overlay_image() const {
  return _internal_has_overlay_image();
}
inline void ClientSettingsProto::clear_overlay_image() {
  if (overlay_image_ != nullptr) overlay_image_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::OverlayImageProto& ClientSettingsProto::_internal_overlay_image() const {
  const ::autofill_assistant::OverlayImageProto* p = overlay_image_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::OverlayImageProto&>(
      ::autofill_assistant::_OverlayImageProto_default_instance_);
}
inline const ::autofill_assistant::OverlayImageProto& ClientSettingsProto::overlay_image() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.overlay_image)
  return _internal_overlay_image();
}
inline void ClientSettingsProto::unsafe_arena_set_allocated_overlay_image(
    ::autofill_assistant::OverlayImageProto* overlay_image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overlay_image_);
  }
  overlay_image_ = overlay_image;
  if (overlay_image) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientSettingsProto.overlay_image)
}
inline ::autofill_assistant::OverlayImageProto* ClientSettingsProto::release_overlay_image() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::OverlayImageProto* temp = overlay_image_;
  overlay_image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::OverlayImageProto* ClientSettingsProto::unsafe_arena_release_overlay_image() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.overlay_image)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::OverlayImageProto* temp = overlay_image_;
  overlay_image_ = nullptr;
  return temp;
}
inline ::autofill_assistant::OverlayImageProto* ClientSettingsProto::_internal_mutable_overlay_image() {
  _has_bits_[0] |= 0x00000002u;
  if (overlay_image_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::OverlayImageProto>(GetArenaForAllocation());
    overlay_image_ = p;
  }
  return overlay_image_;
}
inline ::autofill_assistant::OverlayImageProto* ClientSettingsProto::mutable_overlay_image() {
  ::autofill_assistant::OverlayImageProto* _msg = _internal_mutable_overlay_image();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.overlay_image)
  return _msg;
}
inline void ClientSettingsProto::set_allocated_overlay_image(::autofill_assistant::OverlayImageProto* overlay_image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete overlay_image_;
  }
  if (overlay_image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overlay_image);
    if (message_arena != submessage_arena) {
      overlay_image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overlay_image, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  overlay_image_ = overlay_image;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.overlay_image)
}

// optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;
inline bool ClientSettingsProto::_internal_has_integration_test_settings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || integration_test_settings_ != nullptr);
  return value;
}
inline bool ClientSettingsProto::has_integration_test_settings() const {
  return _internal_has_integration_test_settings();
}
inline void ClientSettingsProto::clear_integration_test_settings() {
  if (integration_test_settings_ != nullptr) integration_test_settings_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings& ClientSettingsProto::_internal_integration_test_settings() const {
  const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* p = integration_test_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings&>(
      ::autofill_assistant::_ClientSettingsProto_IntegrationTestSettings_default_instance_);
}
inline const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings& ClientSettingsProto::integration_test_settings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.integration_test_settings)
  return _internal_integration_test_settings();
}
inline void ClientSettingsProto::unsafe_arena_set_allocated_integration_test_settings(
    ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* integration_test_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(integration_test_settings_);
  }
  integration_test_settings_ = integration_test_settings;
  if (integration_test_settings) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientSettingsProto.integration_test_settings)
}
inline ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* ClientSettingsProto::release_integration_test_settings() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* temp = integration_test_settings_;
  integration_test_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* ClientSettingsProto::unsafe_arena_release_integration_test_settings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.integration_test_settings)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* temp = integration_test_settings_;
  integration_test_settings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* ClientSettingsProto::_internal_mutable_integration_test_settings() {
  _has_bits_[0] |= 0x00000004u;
  if (integration_test_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_IntegrationTestSettings>(GetArenaForAllocation());
    integration_test_settings_ = p;
  }
  return integration_test_settings_;
}
inline ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* ClientSettingsProto::mutable_integration_test_settings() {
  ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* _msg = _internal_mutable_integration_test_settings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.integration_test_settings)
  return _msg;
}
inline void ClientSettingsProto::set_allocated_integration_test_settings(::autofill_assistant::ClientSettingsProto_IntegrationTestSettings* integration_test_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete integration_test_settings_;
  }
  if (integration_test_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(integration_test_settings);
    if (message_arena != submessage_arena) {
      integration_test_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, integration_test_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  integration_test_settings_ = integration_test_settings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.integration_test_settings)
}

// optional float talkback_sheet_size_fraction = 18;
inline bool ClientSettingsProto::_internal_has_talkback_sheet_size_fraction() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_talkback_sheet_size_fraction() const {
  return _internal_has_talkback_sheet_size_fraction();
}
inline void ClientSettingsProto::clear_talkback_sheet_size_fraction() {
  talkback_sheet_size_fraction_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float ClientSettingsProto::_internal_talkback_sheet_size_fraction() const {
  return talkback_sheet_size_fraction_;
}
inline float ClientSettingsProto::talkback_sheet_size_fraction() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.talkback_sheet_size_fraction)
  return _internal_talkback_sheet_size_fraction();
}
inline void ClientSettingsProto::_internal_set_talkback_sheet_size_fraction(float value) {
  _has_bits_[0] |= 0x00010000u;
  talkback_sheet_size_fraction_ = value;
}
inline void ClientSettingsProto::set_talkback_sheet_size_fraction(float value) {
  _internal_set_talkback_sheet_size_fraction(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.talkback_sheet_size_fraction)
}

// optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;
inline bool ClientSettingsProto::_internal_has_back_button_settings() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || back_button_settings_ != nullptr);
  return value;
}
inline bool ClientSettingsProto::has_back_button_settings() const {
  return _internal_has_back_button_settings();
}
inline void ClientSettingsProto::clear_back_button_settings() {
  if (back_button_settings_ != nullptr) back_button_settings_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::ClientSettingsProto_BackButtonSettings& ClientSettingsProto::_internal_back_button_settings() const {
  const ::autofill_assistant::ClientSettingsProto_BackButtonSettings* p = back_button_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientSettingsProto_BackButtonSettings&>(
      ::autofill_assistant::_ClientSettingsProto_BackButtonSettings_default_instance_);
}
inline const ::autofill_assistant::ClientSettingsProto_BackButtonSettings& ClientSettingsProto::back_button_settings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.back_button_settings)
  return _internal_back_button_settings();
}
inline void ClientSettingsProto::unsafe_arena_set_allocated_back_button_settings(
    ::autofill_assistant::ClientSettingsProto_BackButtonSettings* back_button_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(back_button_settings_);
  }
  back_button_settings_ = back_button_settings;
  if (back_button_settings) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientSettingsProto.back_button_settings)
}
inline ::autofill_assistant::ClientSettingsProto_BackButtonSettings* ClientSettingsProto::release_back_button_settings() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* temp = back_button_settings_;
  back_button_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto_BackButtonSettings* ClientSettingsProto::unsafe_arena_release_back_button_settings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.back_button_settings)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* temp = back_button_settings_;
  back_button_settings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto_BackButtonSettings* ClientSettingsProto::_internal_mutable_back_button_settings() {
  _has_bits_[0] |= 0x00000008u;
  if (back_button_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_BackButtonSettings>(GetArenaForAllocation());
    back_button_settings_ = p;
  }
  return back_button_settings_;
}
inline ::autofill_assistant::ClientSettingsProto_BackButtonSettings* ClientSettingsProto::mutable_back_button_settings() {
  ::autofill_assistant::ClientSettingsProto_BackButtonSettings* _msg = _internal_mutable_back_button_settings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.back_button_settings)
  return _msg;
}
inline void ClientSettingsProto::set_allocated_back_button_settings(::autofill_assistant::ClientSettingsProto_BackButtonSettings* back_button_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete back_button_settings_;
  }
  if (back_button_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(back_button_settings);
    if (message_arena != submessage_arena) {
      back_button_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, back_button_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  back_button_settings_ = back_button_settings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.back_button_settings)
}

// optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings slow_warning_settings = 21;
inline bool ClientSettingsProto::_internal_has_slow_warning_settings() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || slow_warning_settings_ != nullptr);
  return value;
}
inline bool ClientSettingsProto::has_slow_warning_settings() const {
  return _internal_has_slow_warning_settings();
}
inline void ClientSettingsProto::clear_slow_warning_settings() {
  if (slow_warning_settings_ != nullptr) slow_warning_settings_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings& ClientSettingsProto::_internal_slow_warning_settings() const {
  const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* p = slow_warning_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings&>(
      ::autofill_assistant::_ClientSettingsProto_SlowWarningSettings_default_instance_);
}
inline const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings& ClientSettingsProto::slow_warning_settings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.slow_warning_settings)
  return _internal_slow_warning_settings();
}
inline void ClientSettingsProto::unsafe_arena_set_allocated_slow_warning_settings(
    ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* slow_warning_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(slow_warning_settings_);
  }
  slow_warning_settings_ = slow_warning_settings;
  if (slow_warning_settings) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ClientSettingsProto.slow_warning_settings)
}
inline ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* ClientSettingsProto::release_slow_warning_settings() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* temp = slow_warning_settings_;
  slow_warning_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* ClientSettingsProto::unsafe_arena_release_slow_warning_settings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.slow_warning_settings)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* temp = slow_warning_settings_;
  slow_warning_settings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* ClientSettingsProto::_internal_mutable_slow_warning_settings() {
  _has_bits_[0] |= 0x00000010u;
  if (slow_warning_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientSettingsProto_SlowWarningSettings>(GetArenaForAllocation());
    slow_warning_settings_ = p;
  }
  return slow_warning_settings_;
}
inline ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* ClientSettingsProto::mutable_slow_warning_settings() {
  ::autofill_assistant::ClientSettingsProto_SlowWarningSettings* _msg = _internal_mutable_slow_warning_settings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.slow_warning_settings)
  return _msg;
}
inline void ClientSettingsProto::set_allocated_slow_warning_settings(::autofill_assistant::ClientSettingsProto_SlowWarningSettings* slow_warning_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete slow_warning_settings_;
  }
  if (slow_warning_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(slow_warning_settings);
    if (message_arena != submessage_arena) {
      slow_warning_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slow_warning_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  slow_warning_settings_ = slow_warning_settings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.slow_warning_settings)
}

// repeated .autofill_assistant.ClientSettingsProto.DisplayString display_strings = 22;
inline int ClientSettingsProto::_internal_display_strings_size() const {
  return display_strings_.size();
}
inline int ClientSettingsProto::display_strings_size() const {
  return _internal_display_strings_size();
}
inline void ClientSettingsProto::clear_display_strings() {
  display_strings_.Clear();
}
inline ::autofill_assistant::ClientSettingsProto_DisplayString* ClientSettingsProto::mutable_display_strings(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.display_strings)
  return display_strings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientSettingsProto_DisplayString >*
ClientSettingsProto::mutable_display_strings() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ClientSettingsProto.display_strings)
  return &display_strings_;
}
inline const ::autofill_assistant::ClientSettingsProto_DisplayString& ClientSettingsProto::_internal_display_strings(int index) const {
  return display_strings_.Get(index);
}
inline const ::autofill_assistant::ClientSettingsProto_DisplayString& ClientSettingsProto::display_strings(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.display_strings)
  return _internal_display_strings(index);
}
inline ::autofill_assistant::ClientSettingsProto_DisplayString* ClientSettingsProto::_internal_add_display_strings() {
  return display_strings_.Add();
}
inline ::autofill_assistant::ClientSettingsProto_DisplayString* ClientSettingsProto::add_display_strings() {
  ::autofill_assistant::ClientSettingsProto_DisplayString* _add = _internal_add_display_strings();
  // @@protoc_insertion_point(field_add:autofill_assistant.ClientSettingsProto.display_strings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientSettingsProto_DisplayString >&
ClientSettingsProto::display_strings() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ClientSettingsProto.display_strings)
  return display_strings_;
}

// optional string display_strings_locale = 23;
inline bool ClientSettingsProto::_internal_has_display_strings_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_display_strings_locale() const {
  return _internal_has_display_strings_locale();
}
inline void ClientSettingsProto::clear_display_strings_locale() {
  display_strings_locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientSettingsProto::display_strings_locale() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.display_strings_locale)
  return _internal_display_strings_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientSettingsProto::set_display_strings_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 display_strings_locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.display_strings_locale)
}
inline std::string* ClientSettingsProto::mutable_display_strings_locale() {
  std::string* _s = _internal_mutable_display_strings_locale();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientSettingsProto.display_strings_locale)
  return _s;
}
inline const std::string& ClientSettingsProto::_internal_display_strings_locale() const {
  return display_strings_locale_.Get();
}
inline void ClientSettingsProto::_internal_set_display_strings_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  display_strings_locale_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientSettingsProto::_internal_mutable_display_strings_locale() {
  _has_bits_[0] |= 0x00000001u;
  return display_strings_locale_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientSettingsProto::release_display_strings_locale() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientSettingsProto.display_strings_locale)
  if (!_internal_has_display_strings_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = display_strings_locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_strings_locale_.IsDefault()) {
    display_strings_locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientSettingsProto::set_allocated_display_strings_locale(std::string* display_strings_locale) {
  if (display_strings_locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  display_strings_locale_.SetAllocated(display_strings_locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_strings_locale_.IsDefault()) {
    display_strings_locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientSettingsProto.display_strings_locale)
}

// optional int32 selector_observer_extra_timeout_ms = 24;
inline bool ClientSettingsProto::_internal_has_selector_observer_extra_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_selector_observer_extra_timeout_ms() const {
  return _internal_has_selector_observer_extra_timeout_ms();
}
inline void ClientSettingsProto::clear_selector_observer_extra_timeout_ms() {
  selector_observer_extra_timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t ClientSettingsProto::_internal_selector_observer_extra_timeout_ms() const {
  return selector_observer_extra_timeout_ms_;
}
inline int32_t ClientSettingsProto::selector_observer_extra_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.selector_observer_extra_timeout_ms)
  return _internal_selector_observer_extra_timeout_ms();
}
inline void ClientSettingsProto::_internal_set_selector_observer_extra_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  selector_observer_extra_timeout_ms_ = value;
}
inline void ClientSettingsProto::set_selector_observer_extra_timeout_ms(int32_t value) {
  _internal_set_selector_observer_extra_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.selector_observer_extra_timeout_ms)
}

// optional int32 selector_observer_debounce_interval_ms = 25;
inline bool ClientSettingsProto::_internal_has_selector_observer_debounce_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ClientSettingsProto::has_selector_observer_debounce_interval_ms() const {
  return _internal_has_selector_observer_debounce_interval_ms();
}
inline void ClientSettingsProto::clear_selector_observer_debounce_interval_ms() {
  selector_observer_debounce_interval_ms_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline int32_t ClientSettingsProto::_internal_selector_observer_debounce_interval_ms() const {
  return selector_observer_debounce_interval_ms_;
}
inline int32_t ClientSettingsProto::selector_observer_debounce_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientSettingsProto.selector_observer_debounce_interval_ms)
  return _internal_selector_observer_debounce_interval_ms();
}
inline void ClientSettingsProto::_internal_set_selector_observer_debounce_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00080000u;
  selector_observer_debounce_interval_ms_ = value;
}
inline void ClientSettingsProto::set_selector_observer_debounce_interval_ms(int32_t value) {
  _internal_set_selector_observer_debounce_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientSettingsProto.selector_observer_debounce_interval_ms)
}

// -------------------------------------------------------------------

// ScriptTimeoutError

// optional int32 timeout_ms = 1;
inline bool ScriptTimeoutError::_internal_has_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScriptTimeoutError::has_timeout_ms() const {
  return _internal_has_timeout_ms();
}
inline void ScriptTimeoutError::clear_timeout_ms() {
  timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ScriptTimeoutError::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline int32_t ScriptTimeoutError::timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptTimeoutError.timeout_ms)
  return _internal_timeout_ms();
}
inline void ScriptTimeoutError::_internal_set_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timeout_ms_ = value;
}
inline void ScriptTimeoutError::set_timeout_ms(int32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptTimeoutError.timeout_ms)
}

// optional string script_path = 2;
inline bool ScriptTimeoutError::_internal_has_script_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScriptTimeoutError::has_script_path() const {
  return _internal_has_script_path();
}
inline void ScriptTimeoutError::clear_script_path() {
  script_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScriptTimeoutError::script_path() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptTimeoutError.script_path)
  return _internal_script_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptTimeoutError::set_script_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 script_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptTimeoutError.script_path)
}
inline std::string* ScriptTimeoutError::mutable_script_path() {
  std::string* _s = _internal_mutable_script_path();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptTimeoutError.script_path)
  return _s;
}
inline const std::string& ScriptTimeoutError::_internal_script_path() const {
  return script_path_.Get();
}
inline void ScriptTimeoutError::_internal_set_script_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  script_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptTimeoutError::_internal_mutable_script_path() {
  _has_bits_[0] |= 0x00000001u;
  return script_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptTimeoutError::release_script_path() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptTimeoutError.script_path)
  if (!_internal_has_script_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = script_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_path_.IsDefault()) {
    script_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptTimeoutError::set_allocated_script_path(std::string* script_path) {
  if (script_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_path_.SetAllocated(script_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_path_.IsDefault()) {
    script_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptTimeoutError.script_path)
}

// -------------------------------------------------------------------

// SupportedScriptProto_PresentationProto

// optional .autofill_assistant.ScriptPreconditionProto precondition = 3;
inline bool SupportedScriptProto_PresentationProto::_internal_has_precondition() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || precondition_ != nullptr);
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_precondition() const {
  return _internal_has_precondition();
}
inline void SupportedScriptProto_PresentationProto::clear_precondition() {
  if (precondition_ != nullptr) precondition_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ScriptPreconditionProto& SupportedScriptProto_PresentationProto::_internal_precondition() const {
  const ::autofill_assistant::ScriptPreconditionProto* p = precondition_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ScriptPreconditionProto&>(
      ::autofill_assistant::_ScriptPreconditionProto_default_instance_);
}
inline const ::autofill_assistant::ScriptPreconditionProto& SupportedScriptProto_PresentationProto::precondition() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.precondition)
  return _internal_precondition();
}
inline void SupportedScriptProto_PresentationProto::unsafe_arena_set_allocated_precondition(
    ::autofill_assistant::ScriptPreconditionProto* precondition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(precondition_);
  }
  precondition_ = precondition;
  if (precondition) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportedScriptProto.PresentationProto.precondition)
}
inline ::autofill_assistant::ScriptPreconditionProto* SupportedScriptProto_PresentationProto::release_precondition() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ScriptPreconditionProto* temp = precondition_;
  precondition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ScriptPreconditionProto* SupportedScriptProto_PresentationProto::unsafe_arena_release_precondition() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportedScriptProto.PresentationProto.precondition)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ScriptPreconditionProto* temp = precondition_;
  precondition_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ScriptPreconditionProto* SupportedScriptProto_PresentationProto::_internal_mutable_precondition() {
  _has_bits_[0] |= 0x00000002u;
  if (precondition_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ScriptPreconditionProto>(GetArenaForAllocation());
    precondition_ = p;
  }
  return precondition_;
}
inline ::autofill_assistant::ScriptPreconditionProto* SupportedScriptProto_PresentationProto::mutable_precondition() {
  ::autofill_assistant::ScriptPreconditionProto* _msg = _internal_mutable_precondition();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportedScriptProto.PresentationProto.precondition)
  return _msg;
}
inline void SupportedScriptProto_PresentationProto::set_allocated_precondition(::autofill_assistant::ScriptPreconditionProto* precondition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete precondition_;
  }
  if (precondition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(precondition);
    if (message_arena != submessage_arena) {
      precondition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, precondition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  precondition_ = precondition;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportedScriptProto.PresentationProto.precondition)
}

// optional int32 priority = 5;
inline bool SupportedScriptProto_PresentationProto::_internal_has_priority() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_priority() const {
  return _internal_has_priority();
}
inline void SupportedScriptProto_PresentationProto::clear_priority() {
  priority_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t SupportedScriptProto_PresentationProto::_internal_priority() const {
  return priority_;
}
inline int32_t SupportedScriptProto_PresentationProto::priority() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.priority)
  return _internal_priority();
}
inline void SupportedScriptProto_PresentationProto::_internal_set_priority(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  priority_ = value;
}
inline void SupportedScriptProto_PresentationProto::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportedScriptProto.PresentationProto.priority)
}

// optional .autofill_assistant.DirectActionProto direct_action = 13;
inline bool SupportedScriptProto_PresentationProto::_internal_has_direct_action() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || direct_action_ != nullptr);
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_direct_action() const {
  return _internal_has_direct_action();
}
inline const ::autofill_assistant::DirectActionProto& SupportedScriptProto_PresentationProto::_internal_direct_action() const {
  const ::autofill_assistant::DirectActionProto* p = direct_action_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DirectActionProto&>(
      ::autofill_assistant::_DirectActionProto_default_instance_);
}
inline const ::autofill_assistant::DirectActionProto& SupportedScriptProto_PresentationProto::direct_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.direct_action)
  return _internal_direct_action();
}
inline void SupportedScriptProto_PresentationProto::unsafe_arena_set_allocated_direct_action(
    ::autofill_assistant::DirectActionProto* direct_action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direct_action_);
  }
  direct_action_ = direct_action;
  if (direct_action) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportedScriptProto.PresentationProto.direct_action)
}
inline ::autofill_assistant::DirectActionProto* SupportedScriptProto_PresentationProto::release_direct_action() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::DirectActionProto* temp = direct_action_;
  direct_action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DirectActionProto* SupportedScriptProto_PresentationProto::unsafe_arena_release_direct_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportedScriptProto.PresentationProto.direct_action)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::DirectActionProto* temp = direct_action_;
  direct_action_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DirectActionProto* SupportedScriptProto_PresentationProto::_internal_mutable_direct_action() {
  _has_bits_[0] |= 0x00000004u;
  if (direct_action_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DirectActionProto>(GetArenaForAllocation());
    direct_action_ = p;
  }
  return direct_action_;
}
inline ::autofill_assistant::DirectActionProto* SupportedScriptProto_PresentationProto::mutable_direct_action() {
  ::autofill_assistant::DirectActionProto* _msg = _internal_mutable_direct_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportedScriptProto.PresentationProto.direct_action)
  return _msg;
}
inline void SupportedScriptProto_PresentationProto::set_allocated_direct_action(::autofill_assistant::DirectActionProto* direct_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(direct_action_);
  }
  if (direct_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direct_action));
    if (message_arena != submessage_arena) {
      direct_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direct_action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  direct_action_ = direct_action;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportedScriptProto.PresentationProto.direct_action)
}

// optional bool autostart = 8;
inline bool SupportedScriptProto_PresentationProto::_internal_has_autostart() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_autostart() const {
  return _internal_has_autostart();
}
inline void SupportedScriptProto_PresentationProto::clear_autostart() {
  autostart_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SupportedScriptProto_PresentationProto::_internal_autostart() const {
  return autostart_;
}
inline bool SupportedScriptProto_PresentationProto::autostart() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.autostart)
  return _internal_autostart();
}
inline void SupportedScriptProto_PresentationProto::_internal_set_autostart(bool value) {
  _has_bits_[0] |= 0x00000010u;
  autostart_ = value;
}
inline void SupportedScriptProto_PresentationProto::set_autostart(bool value) {
  _internal_set_autostart(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportedScriptProto.PresentationProto.autostart)
}

// optional bool interrupt = 9;
inline bool SupportedScriptProto_PresentationProto::_internal_has_interrupt() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_interrupt() const {
  return _internal_has_interrupt();
}
inline void SupportedScriptProto_PresentationProto::clear_interrupt() {
  interrupt_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SupportedScriptProto_PresentationProto::_internal_interrupt() const {
  return interrupt_;
}
inline bool SupportedScriptProto_PresentationProto::interrupt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.interrupt)
  return _internal_interrupt();
}
inline void SupportedScriptProto_PresentationProto::_internal_set_interrupt(bool value) {
  _has_bits_[0] |= 0x00000020u;
  interrupt_ = value;
}
inline void SupportedScriptProto_PresentationProto::set_interrupt(bool value) {
  _internal_set_interrupt(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportedScriptProto.PresentationProto.interrupt)
}

// optional string start_message = 14;
inline bool SupportedScriptProto_PresentationProto::_internal_has_start_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_start_message() const {
  return _internal_has_start_message();
}
inline void SupportedScriptProto_PresentationProto::clear_start_message() {
  start_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SupportedScriptProto_PresentationProto::start_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.start_message)
  return _internal_start_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SupportedScriptProto_PresentationProto::set_start_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 start_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportedScriptProto.PresentationProto.start_message)
}
inline std::string* SupportedScriptProto_PresentationProto::mutable_start_message() {
  std::string* _s = _internal_mutable_start_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportedScriptProto.PresentationProto.start_message)
  return _s;
}
inline const std::string& SupportedScriptProto_PresentationProto::_internal_start_message() const {
  return start_message_.Get();
}
inline void SupportedScriptProto_PresentationProto::_internal_set_start_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_message_.Set(value, GetArenaForAllocation());
}
inline std::string* SupportedScriptProto_PresentationProto::_internal_mutable_start_message() {
  _has_bits_[0] |= 0x00000001u;
  return start_message_.Mutable(GetArenaForAllocation());
}
inline std::string* SupportedScriptProto_PresentationProto::release_start_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportedScriptProto.PresentationProto.start_message)
  if (!_internal_has_start_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = start_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (start_message_.IsDefault()) {
    start_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SupportedScriptProto_PresentationProto::set_allocated_start_message(std::string* start_message) {
  if (start_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_message_.SetAllocated(start_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (start_message_.IsDefault()) {
    start_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportedScriptProto.PresentationProto.start_message)
}

// optional bool needs_ui = 15 [default = true];
inline bool SupportedScriptProto_PresentationProto::_internal_has_needs_ui() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SupportedScriptProto_PresentationProto::has_needs_ui() const {
  return _internal_has_needs_ui();
}
inline void SupportedScriptProto_PresentationProto::clear_needs_ui() {
  needs_ui_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool SupportedScriptProto_PresentationProto::_internal_needs_ui() const {
  return needs_ui_;
}
inline bool SupportedScriptProto_PresentationProto::needs_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.PresentationProto.needs_ui)
  return _internal_needs_ui();
}
inline void SupportedScriptProto_PresentationProto::_internal_set_needs_ui(bool value) {
  _has_bits_[0] |= 0x00000040u;
  needs_ui_ = value;
}
inline void SupportedScriptProto_PresentationProto::set_needs_ui(bool value) {
  _internal_set_needs_ui(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportedScriptProto.PresentationProto.needs_ui)
}

// -------------------------------------------------------------------

// SupportedScriptProto

// optional string path = 1;
inline bool SupportedScriptProto::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SupportedScriptProto::has_path() const {
  return _internal_has_path();
}
inline void SupportedScriptProto::clear_path() {
  path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SupportedScriptProto::path() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SupportedScriptProto::set_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SupportedScriptProto.path)
}
inline std::string* SupportedScriptProto::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportedScriptProto.path)
  return _s;
}
inline const std::string& SupportedScriptProto::_internal_path() const {
  return path_.Get();
}
inline void SupportedScriptProto::_internal_set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* SupportedScriptProto::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000001u;
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* SupportedScriptProto::release_path() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportedScriptProto.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SupportedScriptProto::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportedScriptProto.path)
}

// optional .autofill_assistant.SupportedScriptProto.PresentationProto presentation = 2;
inline bool SupportedScriptProto::_internal_has_presentation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || presentation_ != nullptr);
  return value;
}
inline bool SupportedScriptProto::has_presentation() const {
  return _internal_has_presentation();
}
inline void SupportedScriptProto::clear_presentation() {
  if (presentation_ != nullptr) presentation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::SupportedScriptProto_PresentationProto& SupportedScriptProto::_internal_presentation() const {
  const ::autofill_assistant::SupportedScriptProto_PresentationProto* p = presentation_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SupportedScriptProto_PresentationProto&>(
      ::autofill_assistant::_SupportedScriptProto_PresentationProto_default_instance_);
}
inline const ::autofill_assistant::SupportedScriptProto_PresentationProto& SupportedScriptProto::presentation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SupportedScriptProto.presentation)
  return _internal_presentation();
}
inline void SupportedScriptProto::unsafe_arena_set_allocated_presentation(
    ::autofill_assistant::SupportedScriptProto_PresentationProto* presentation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(presentation_);
  }
  presentation_ = presentation;
  if (presentation) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SupportedScriptProto.presentation)
}
inline ::autofill_assistant::SupportedScriptProto_PresentationProto* SupportedScriptProto::release_presentation() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SupportedScriptProto_PresentationProto* temp = presentation_;
  presentation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SupportedScriptProto_PresentationProto* SupportedScriptProto::unsafe_arena_release_presentation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SupportedScriptProto.presentation)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SupportedScriptProto_PresentationProto* temp = presentation_;
  presentation_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SupportedScriptProto_PresentationProto* SupportedScriptProto::_internal_mutable_presentation() {
  _has_bits_[0] |= 0x00000002u;
  if (presentation_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SupportedScriptProto_PresentationProto>(GetArenaForAllocation());
    presentation_ = p;
  }
  return presentation_;
}
inline ::autofill_assistant::SupportedScriptProto_PresentationProto* SupportedScriptProto::mutable_presentation() {
  ::autofill_assistant::SupportedScriptProto_PresentationProto* _msg = _internal_mutable_presentation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SupportedScriptProto.presentation)
  return _msg;
}
inline void SupportedScriptProto::set_allocated_presentation(::autofill_assistant::SupportedScriptProto_PresentationProto* presentation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete presentation_;
  }
  if (presentation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(presentation);
    if (message_arena != submessage_arena) {
      presentation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presentation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  presentation_ = presentation;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SupportedScriptProto.presentation)
}

// -------------------------------------------------------------------

// ScriptPreconditionProto

// repeated string path_pattern = 5;
inline int ScriptPreconditionProto::_internal_path_pattern_size() const {
  return path_pattern_.size();
}
inline int ScriptPreconditionProto::path_pattern_size() const {
  return _internal_path_pattern_size();
}
inline void ScriptPreconditionProto::clear_path_pattern() {
  path_pattern_.Clear();
}
inline std::string* ScriptPreconditionProto::add_path_pattern() {
  std::string* _s = _internal_add_path_pattern();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.ScriptPreconditionProto.path_pattern)
  return _s;
}
inline const std::string& ScriptPreconditionProto::_internal_path_pattern(int index) const {
  return path_pattern_.Get(index);
}
inline const std::string& ScriptPreconditionProto::path_pattern(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptPreconditionProto.path_pattern)
  return _internal_path_pattern(index);
}
inline std::string* ScriptPreconditionProto::mutable_path_pattern(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptPreconditionProto.path_pattern)
  return path_pattern_.Mutable(index);
}
inline void ScriptPreconditionProto::set_path_pattern(int index, const std::string& value) {
  path_pattern_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline void ScriptPreconditionProto::set_path_pattern(int index, std::string&& value) {
  path_pattern_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline void ScriptPreconditionProto::set_path_pattern(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_pattern_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline void ScriptPreconditionProto::set_path_pattern(int index, const char* value, size_t size) {
  path_pattern_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline std::string* ScriptPreconditionProto::_internal_add_path_pattern() {
  return path_pattern_.Add();
}
inline void ScriptPreconditionProto::add_path_pattern(const std::string& value) {
  path_pattern_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline void ScriptPreconditionProto::add_path_pattern(std::string&& value) {
  path_pattern_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline void ScriptPreconditionProto::add_path_pattern(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_pattern_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline void ScriptPreconditionProto::add_path_pattern(const char* value, size_t size) {
  path_pattern_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.ScriptPreconditionProto.path_pattern)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ScriptPreconditionProto::path_pattern() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ScriptPreconditionProto.path_pattern)
  return path_pattern_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ScriptPreconditionProto::mutable_path_pattern() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ScriptPreconditionProto.path_pattern)
  return &path_pattern_;
}

// repeated string domain = 6;
inline int ScriptPreconditionProto::_internal_domain_size() const {
  return domain_.size();
}
inline int ScriptPreconditionProto::domain_size() const {
  return _internal_domain_size();
}
inline void ScriptPreconditionProto::clear_domain() {
  domain_.Clear();
}
inline std::string* ScriptPreconditionProto::add_domain() {
  std::string* _s = _internal_add_domain();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.ScriptPreconditionProto.domain)
  return _s;
}
inline const std::string& ScriptPreconditionProto::_internal_domain(int index) const {
  return domain_.Get(index);
}
inline const std::string& ScriptPreconditionProto::domain(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptPreconditionProto.domain)
  return _internal_domain(index);
}
inline std::string* ScriptPreconditionProto::mutable_domain(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptPreconditionProto.domain)
  return domain_.Mutable(index);
}
inline void ScriptPreconditionProto::set_domain(int index, const std::string& value) {
  domain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptPreconditionProto.domain)
}
inline void ScriptPreconditionProto::set_domain(int index, std::string&& value) {
  domain_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptPreconditionProto.domain)
}
inline void ScriptPreconditionProto::set_domain(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  domain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.ScriptPreconditionProto.domain)
}
inline void ScriptPreconditionProto::set_domain(int index, const char* value, size_t size) {
  domain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.ScriptPreconditionProto.domain)
}
inline std::string* ScriptPreconditionProto::_internal_add_domain() {
  return domain_.Add();
}
inline void ScriptPreconditionProto::add_domain(const std::string& value) {
  domain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.ScriptPreconditionProto.domain)
}
inline void ScriptPreconditionProto::add_domain(std::string&& value) {
  domain_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.ScriptPreconditionProto.domain)
}
inline void ScriptPreconditionProto::add_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  domain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.ScriptPreconditionProto.domain)
}
inline void ScriptPreconditionProto::add_domain(const char* value, size_t size) {
  domain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.ScriptPreconditionProto.domain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ScriptPreconditionProto::domain() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ScriptPreconditionProto.domain)
  return domain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ScriptPreconditionProto::mutable_domain() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ScriptPreconditionProto.domain)
  return &domain_;
}

// repeated .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 7;
inline int ScriptPreconditionProto::_internal_script_parameter_match_size() const {
  return script_parameter_match_.size();
}
inline int ScriptPreconditionProto::script_parameter_match_size() const {
  return _internal_script_parameter_match_size();
}
inline void ScriptPreconditionProto::clear_script_parameter_match() {
  script_parameter_match_.Clear();
}
inline ::autofill_assistant::ScriptParameterMatchProto* ScriptPreconditionProto::mutable_script_parameter_match(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptPreconditionProto.script_parameter_match)
  return script_parameter_match_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterMatchProto >*
ScriptPreconditionProto::mutable_script_parameter_match() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ScriptPreconditionProto.script_parameter_match)
  return &script_parameter_match_;
}
inline const ::autofill_assistant::ScriptParameterMatchProto& ScriptPreconditionProto::_internal_script_parameter_match(int index) const {
  return script_parameter_match_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterMatchProto& ScriptPreconditionProto::script_parameter_match(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptPreconditionProto.script_parameter_match)
  return _internal_script_parameter_match(index);
}
inline ::autofill_assistant::ScriptParameterMatchProto* ScriptPreconditionProto::_internal_add_script_parameter_match() {
  return script_parameter_match_.Add();
}
inline ::autofill_assistant::ScriptParameterMatchProto* ScriptPreconditionProto::add_script_parameter_match() {
  ::autofill_assistant::ScriptParameterMatchProto* _add = _internal_add_script_parameter_match();
  // @@protoc_insertion_point(field_add:autofill_assistant.ScriptPreconditionProto.script_parameter_match)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterMatchProto >&
ScriptPreconditionProto::script_parameter_match() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ScriptPreconditionProto.script_parameter_match)
  return script_parameter_match_;
}

// optional .autofill_assistant.ElementConditionProto element_condition = 10;
inline bool ScriptPreconditionProto::_internal_has_element_condition() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || element_condition_ != nullptr);
  return value;
}
inline bool ScriptPreconditionProto::has_element_condition() const {
  return _internal_has_element_condition();
}
inline void ScriptPreconditionProto::clear_element_condition() {
  if (element_condition_ != nullptr) element_condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ElementConditionProto& ScriptPreconditionProto::_internal_element_condition() const {
  const ::autofill_assistant::ElementConditionProto* p = element_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementConditionProto&>(
      ::autofill_assistant::_ElementConditionProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionProto& ScriptPreconditionProto::element_condition() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptPreconditionProto.element_condition)
  return _internal_element_condition();
}
inline void ScriptPreconditionProto::unsafe_arena_set_allocated_element_condition(
    ::autofill_assistant::ElementConditionProto* element_condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_condition_);
  }
  element_condition_ = element_condition;
  if (element_condition) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScriptPreconditionProto.element_condition)
}
inline ::autofill_assistant::ElementConditionProto* ScriptPreconditionProto::release_element_condition() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementConditionProto* temp = element_condition_;
  element_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* ScriptPreconditionProto::unsafe_arena_release_element_condition() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptPreconditionProto.element_condition)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementConditionProto* temp = element_condition_;
  element_condition_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* ScriptPreconditionProto::_internal_mutable_element_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (element_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(GetArenaForAllocation());
    element_condition_ = p;
  }
  return element_condition_;
}
inline ::autofill_assistant::ElementConditionProto* ScriptPreconditionProto::mutable_element_condition() {
  ::autofill_assistant::ElementConditionProto* _msg = _internal_mutable_element_condition();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptPreconditionProto.element_condition)
  return _msg;
}
inline void ScriptPreconditionProto::set_allocated_element_condition(::autofill_assistant::ElementConditionProto* element_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_condition_;
  }
  if (element_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element_condition);
    if (message_arena != submessage_arena) {
      element_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element_condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  element_condition_ = element_condition;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptPreconditionProto.element_condition)
}

// -------------------------------------------------------------------

// ScriptParameterMatchProto

// optional string name = 4;
inline bool ScriptParameterMatchProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScriptParameterMatchProto::has_name() const {
  return _internal_has_name();
}
inline void ScriptParameterMatchProto::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ScriptParameterMatchProto::name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptParameterMatchProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptParameterMatchProto::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptParameterMatchProto.name)
}
inline std::string* ScriptParameterMatchProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptParameterMatchProto.name)
  return _s;
}
inline const std::string& ScriptParameterMatchProto::_internal_name() const {
  return name_.Get();
}
inline void ScriptParameterMatchProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptParameterMatchProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptParameterMatchProto::release_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptParameterMatchProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptParameterMatchProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptParameterMatchProto.name)
}

// optional bool exists = 2 [default = true];
inline bool ScriptParameterMatchProto::_internal_has_exists() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScriptParameterMatchProto::has_exists() const {
  return _internal_has_exists();
}
inline void ScriptParameterMatchProto::clear_exists() {
  exists_ = true;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ScriptParameterMatchProto::_internal_exists() const {
  return exists_;
}
inline bool ScriptParameterMatchProto::exists() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptParameterMatchProto.exists)
  return _internal_exists();
}
inline void ScriptParameterMatchProto::_internal_set_exists(bool value) {
  _has_bits_[0] |= 0x00000004u;
  exists_ = value;
}
inline void ScriptParameterMatchProto::set_exists(bool value) {
  _internal_set_exists(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptParameterMatchProto.exists)
}

// optional string value_equals = 3;
inline bool ScriptParameterMatchProto::_internal_has_value_equals() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScriptParameterMatchProto::has_value_equals() const {
  return _internal_has_value_equals();
}
inline void ScriptParameterMatchProto::clear_value_equals() {
  value_equals_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScriptParameterMatchProto::value_equals() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptParameterMatchProto.value_equals)
  return _internal_value_equals();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptParameterMatchProto::set_value_equals(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_equals_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptParameterMatchProto.value_equals)
}
inline std::string* ScriptParameterMatchProto::mutable_value_equals() {
  std::string* _s = _internal_mutable_value_equals();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptParameterMatchProto.value_equals)
  return _s;
}
inline const std::string& ScriptParameterMatchProto::_internal_value_equals() const {
  return value_equals_.Get();
}
inline void ScriptParameterMatchProto::_internal_set_value_equals(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_equals_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptParameterMatchProto::_internal_mutable_value_equals() {
  _has_bits_[0] |= 0x00000001u;
  return value_equals_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptParameterMatchProto::release_value_equals() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptParameterMatchProto.value_equals)
  if (!_internal_has_value_equals()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_equals_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_equals_.IsDefault()) {
    value_equals_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptParameterMatchProto::set_allocated_value_equals(std::string* value_equals) {
  if (value_equals != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_equals_.SetAllocated(value_equals, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_equals_.IsDefault()) {
    value_equals_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptParameterMatchProto.value_equals)
}

// -------------------------------------------------------------------

// CUPRequestData

// optional bytes request = 1;
inline bool CUPRequestData::_internal_has_request() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CUPRequestData::has_request() const {
  return _internal_has_request();
}
inline void CUPRequestData::clear_request() {
  request_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CUPRequestData::request() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CUPRequestData.request)
  return _internal_request();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CUPRequestData::set_request(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 request_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CUPRequestData.request)
}
inline std::string* CUPRequestData::mutable_request() {
  std::string* _s = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CUPRequestData.request)
  return _s;
}
inline const std::string& CUPRequestData::_internal_request() const {
  return request_.Get();
}
inline void CUPRequestData::_internal_set_request(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  request_.Set(value, GetArenaForAllocation());
}
inline std::string* CUPRequestData::_internal_mutable_request() {
  _has_bits_[0] |= 0x00000001u;
  return request_.Mutable(GetArenaForAllocation());
}
inline std::string* CUPRequestData::release_request() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CUPRequestData.request)
  if (!_internal_has_request()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = request_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_.IsDefault()) {
    request_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CUPRequestData::set_allocated_request(std::string* request) {
  if (request != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  request_.SetAllocated(request, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_.IsDefault()) {
    request_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CUPRequestData.request)
}

// optional bytes query_cup2key = 2;
inline bool CUPRequestData::_internal_has_query_cup2key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CUPRequestData::has_query_cup2key() const {
  return _internal_has_query_cup2key();
}
inline void CUPRequestData::clear_query_cup2key() {
  query_cup2key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CUPRequestData::query_cup2key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CUPRequestData.query_cup2key)
  return _internal_query_cup2key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CUPRequestData::set_query_cup2key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 query_cup2key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CUPRequestData.query_cup2key)
}
inline std::string* CUPRequestData::mutable_query_cup2key() {
  std::string* _s = _internal_mutable_query_cup2key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CUPRequestData.query_cup2key)
  return _s;
}
inline const std::string& CUPRequestData::_internal_query_cup2key() const {
  return query_cup2key_.Get();
}
inline void CUPRequestData::_internal_set_query_cup2key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  query_cup2key_.Set(value, GetArenaForAllocation());
}
inline std::string* CUPRequestData::_internal_mutable_query_cup2key() {
  _has_bits_[0] |= 0x00000002u;
  return query_cup2key_.Mutable(GetArenaForAllocation());
}
inline std::string* CUPRequestData::release_query_cup2key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CUPRequestData.query_cup2key)
  if (!_internal_has_query_cup2key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = query_cup2key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (query_cup2key_.IsDefault()) {
    query_cup2key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CUPRequestData::set_allocated_query_cup2key(std::string* query_cup2key) {
  if (query_cup2key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  query_cup2key_.SetAllocated(query_cup2key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (query_cup2key_.IsDefault()) {
    query_cup2key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CUPRequestData.query_cup2key)
}

// optional bytes hash_hex = 3;
inline bool CUPRequestData::_internal_has_hash_hex() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CUPRequestData::has_hash_hex() const {
  return _internal_has_hash_hex();
}
inline void CUPRequestData::clear_hash_hex() {
  hash_hex_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CUPRequestData::hash_hex() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CUPRequestData.hash_hex)
  return _internal_hash_hex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CUPRequestData::set_hash_hex(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 hash_hex_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CUPRequestData.hash_hex)
}
inline std::string* CUPRequestData::mutable_hash_hex() {
  std::string* _s = _internal_mutable_hash_hex();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CUPRequestData.hash_hex)
  return _s;
}
inline const std::string& CUPRequestData::_internal_hash_hex() const {
  return hash_hex_.Get();
}
inline void CUPRequestData::_internal_set_hash_hex(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  hash_hex_.Set(value, GetArenaForAllocation());
}
inline std::string* CUPRequestData::_internal_mutable_hash_hex() {
  _has_bits_[0] |= 0x00000004u;
  return hash_hex_.Mutable(GetArenaForAllocation());
}
inline std::string* CUPRequestData::release_hash_hex() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CUPRequestData.hash_hex)
  if (!_internal_has_hash_hex()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = hash_hex_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_hex_.IsDefault()) {
    hash_hex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CUPRequestData::set_allocated_hash_hex(std::string* hash_hex) {
  if (hash_hex != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hash_hex_.SetAllocated(hash_hex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_hex_.IsDefault()) {
    hash_hex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CUPRequestData.hash_hex)
}

// -------------------------------------------------------------------

// ScriptActionRequestProto

// optional .autofill_assistant.CUPRequestData cup_data = 11;
inline bool ScriptActionRequestProto::_internal_has_cup_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || cup_data_ != nullptr);
  return value;
}
inline bool ScriptActionRequestProto::has_cup_data() const {
  return _internal_has_cup_data();
}
inline void ScriptActionRequestProto::clear_cup_data() {
  if (cup_data_ != nullptr) cup_data_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::CUPRequestData& ScriptActionRequestProto::_internal_cup_data() const {
  const ::autofill_assistant::CUPRequestData* p = cup_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::CUPRequestData&>(
      ::autofill_assistant::_CUPRequestData_default_instance_);
}
inline const ::autofill_assistant::CUPRequestData& ScriptActionRequestProto::cup_data() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptActionRequestProto.cup_data)
  return _internal_cup_data();
}
inline void ScriptActionRequestProto::unsafe_arena_set_allocated_cup_data(
    ::autofill_assistant::CUPRequestData* cup_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cup_data_);
  }
  cup_data_ = cup_data;
  if (cup_data) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScriptActionRequestProto.cup_data)
}
inline ::autofill_assistant::CUPRequestData* ScriptActionRequestProto::release_cup_data() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::CUPRequestData* temp = cup_data_;
  cup_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::CUPRequestData* ScriptActionRequestProto::unsafe_arena_release_cup_data() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptActionRequestProto.cup_data)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::CUPRequestData* temp = cup_data_;
  cup_data_ = nullptr;
  return temp;
}
inline ::autofill_assistant::CUPRequestData* ScriptActionRequestProto::_internal_mutable_cup_data() {
  _has_bits_[0] |= 0x00000008u;
  if (cup_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::CUPRequestData>(GetArenaForAllocation());
    cup_data_ = p;
  }
  return cup_data_;
}
inline ::autofill_assistant::CUPRequestData* ScriptActionRequestProto::mutable_cup_data() {
  ::autofill_assistant::CUPRequestData* _msg = _internal_mutable_cup_data();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptActionRequestProto.cup_data)
  return _msg;
}
inline void ScriptActionRequestProto::set_allocated_cup_data(::autofill_assistant::CUPRequestData* cup_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cup_data_;
  }
  if (cup_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cup_data);
    if (message_arena != submessage_arena) {
      cup_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cup_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cup_data_ = cup_data;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptActionRequestProto.cup_data)
}

// optional .autofill_assistant.ClientContextProto client_context = 7;
inline bool ScriptActionRequestProto::_internal_has_client_context() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || client_context_ != nullptr);
  return value;
}
inline bool ScriptActionRequestProto::has_client_context() const {
  return _internal_has_client_context();
}
inline void ScriptActionRequestProto::clear_client_context() {
  if (client_context_ != nullptr) client_context_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ClientContextProto& ScriptActionRequestProto::_internal_client_context() const {
  const ::autofill_assistant::ClientContextProto* p = client_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto&>(
      ::autofill_assistant::_ClientContextProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto& ScriptActionRequestProto::client_context() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptActionRequestProto.client_context)
  return _internal_client_context();
}
inline void ScriptActionRequestProto::unsafe_arena_set_allocated_client_context(
    ::autofill_assistant::ClientContextProto* client_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_context_);
  }
  client_context_ = client_context;
  if (client_context) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScriptActionRequestProto.client_context)
}
inline ::autofill_assistant::ClientContextProto* ScriptActionRequestProto::release_client_context() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto* ScriptActionRequestProto::unsafe_arena_release_client_context() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptActionRequestProto.client_context)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto* ScriptActionRequestProto::_internal_mutable_client_context() {
  _has_bits_[0] |= 0x00000004u;
  if (client_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto>(GetArenaForAllocation());
    client_context_ = p;
  }
  return client_context_;
}
inline ::autofill_assistant::ClientContextProto* ScriptActionRequestProto::mutable_client_context() {
  ::autofill_assistant::ClientContextProto* _msg = _internal_mutable_client_context();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptActionRequestProto.client_context)
  return _msg;
}
inline void ScriptActionRequestProto::set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_context_;
  }
  if (client_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_context);
    if (message_arena != submessage_arena) {
      client_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  client_context_ = client_context;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptActionRequestProto.client_context)
}

// optional bytes global_payload = 8;
inline bool ScriptActionRequestProto::_internal_has_global_payload() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScriptActionRequestProto::has_global_payload() const {
  return _internal_has_global_payload();
}
inline void ScriptActionRequestProto::clear_global_payload() {
  global_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ScriptActionRequestProto::global_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptActionRequestProto.global_payload)
  return _internal_global_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptActionRequestProto::set_global_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 global_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptActionRequestProto.global_payload)
}
inline std::string* ScriptActionRequestProto::mutable_global_payload() {
  std::string* _s = _internal_mutable_global_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptActionRequestProto.global_payload)
  return _s;
}
inline const std::string& ScriptActionRequestProto::_internal_global_payload() const {
  return global_payload_.Get();
}
inline void ScriptActionRequestProto::_internal_set_global_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  global_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptActionRequestProto::_internal_mutable_global_payload() {
  _has_bits_[0] |= 0x00000002u;
  return global_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptActionRequestProto::release_global_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptActionRequestProto.global_payload)
  if (!_internal_has_global_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = global_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (global_payload_.IsDefault()) {
    global_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptActionRequestProto::set_allocated_global_payload(std::string* global_payload) {
  if (global_payload != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  global_payload_.SetAllocated(global_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (global_payload_.IsDefault()) {
    global_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptActionRequestProto.global_payload)
}

// optional bytes script_payload = 2;
inline bool ScriptActionRequestProto::_internal_has_script_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScriptActionRequestProto::has_script_payload() const {
  return _internal_has_script_payload();
}
inline void ScriptActionRequestProto::clear_script_payload() {
  script_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScriptActionRequestProto::script_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptActionRequestProto.script_payload)
  return _internal_script_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptActionRequestProto::set_script_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 script_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptActionRequestProto.script_payload)
}
inline std::string* ScriptActionRequestProto::mutable_script_payload() {
  std::string* _s = _internal_mutable_script_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptActionRequestProto.script_payload)
  return _s;
}
inline const std::string& ScriptActionRequestProto::_internal_script_payload() const {
  return script_payload_.Get();
}
inline void ScriptActionRequestProto::_internal_set_script_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  script_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptActionRequestProto::_internal_mutable_script_payload() {
  _has_bits_[0] |= 0x00000001u;
  return script_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptActionRequestProto::release_script_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptActionRequestProto.script_payload)
  if (!_internal_has_script_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = script_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_payload_.IsDefault()) {
    script_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptActionRequestProto::set_allocated_script_payload(std::string* script_payload) {
  if (script_payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_payload_.SetAllocated(script_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_payload_.IsDefault()) {
    script_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptActionRequestProto.script_payload)
}

// .autofill_assistant.InitialScriptActionsRequestProto initial_request = 4;
inline bool ScriptActionRequestProto::_internal_has_initial_request() const {
  return request_case() == kInitialRequest;
}
inline bool ScriptActionRequestProto::has_initial_request() const {
  return _internal_has_initial_request();
}
inline void ScriptActionRequestProto::set_has_initial_request() {
  _oneof_case_[0] = kInitialRequest;
}
inline void ScriptActionRequestProto::clear_initial_request() {
  if (_internal_has_initial_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.initial_request_;
    }
    clear_has_request();
  }
}
inline ::autofill_assistant::InitialScriptActionsRequestProto* ScriptActionRequestProto::release_initial_request() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptActionRequestProto.initial_request)
  if (_internal_has_initial_request()) {
    clear_has_request();
    ::autofill_assistant::InitialScriptActionsRequestProto* temp = request_.initial_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.initial_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::InitialScriptActionsRequestProto& ScriptActionRequestProto::_internal_initial_request() const {
  return _internal_has_initial_request()
      ? *request_.initial_request_
      : reinterpret_cast< ::autofill_assistant::InitialScriptActionsRequestProto&>(::autofill_assistant::_InitialScriptActionsRequestProto_default_instance_);
}
inline const ::autofill_assistant::InitialScriptActionsRequestProto& ScriptActionRequestProto::initial_request() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptActionRequestProto.initial_request)
  return _internal_initial_request();
}
inline ::autofill_assistant::InitialScriptActionsRequestProto* ScriptActionRequestProto::unsafe_arena_release_initial_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ScriptActionRequestProto.initial_request)
  if (_internal_has_initial_request()) {
    clear_has_request();
    ::autofill_assistant::InitialScriptActionsRequestProto* temp = request_.initial_request_;
    request_.initial_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScriptActionRequestProto::unsafe_arena_set_allocated_initial_request(::autofill_assistant::InitialScriptActionsRequestProto* initial_request) {
  clear_request();
  if (initial_request) {
    set_has_initial_request();
    request_.initial_request_ = initial_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScriptActionRequestProto.initial_request)
}
inline ::autofill_assistant::InitialScriptActionsRequestProto* ScriptActionRequestProto::_internal_mutable_initial_request() {
  if (!_internal_has_initial_request()) {
    clear_request();
    set_has_initial_request();
    request_.initial_request_ = CreateMaybeMessage< ::autofill_assistant::InitialScriptActionsRequestProto >(GetArenaForAllocation());
  }
  return request_.initial_request_;
}
inline ::autofill_assistant::InitialScriptActionsRequestProto* ScriptActionRequestProto::mutable_initial_request() {
  ::autofill_assistant::InitialScriptActionsRequestProto* _msg = _internal_mutable_initial_request();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptActionRequestProto.initial_request)
  return _msg;
}

// .autofill_assistant.NextScriptActionsRequestProto next_request = 5;
inline bool ScriptActionRequestProto::_internal_has_next_request() const {
  return request_case() == kNextRequest;
}
inline bool ScriptActionRequestProto::has_next_request() const {
  return _internal_has_next_request();
}
inline void ScriptActionRequestProto::set_has_next_request() {
  _oneof_case_[0] = kNextRequest;
}
inline void ScriptActionRequestProto::clear_next_request() {
  if (_internal_has_next_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.next_request_;
    }
    clear_has_request();
  }
}
inline ::autofill_assistant::NextScriptActionsRequestProto* ScriptActionRequestProto::release_next_request() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptActionRequestProto.next_request)
  if (_internal_has_next_request()) {
    clear_has_request();
    ::autofill_assistant::NextScriptActionsRequestProto* temp = request_.next_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.next_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::NextScriptActionsRequestProto& ScriptActionRequestProto::_internal_next_request() const {
  return _internal_has_next_request()
      ? *request_.next_request_
      : reinterpret_cast< ::autofill_assistant::NextScriptActionsRequestProto&>(::autofill_assistant::_NextScriptActionsRequestProto_default_instance_);
}
inline const ::autofill_assistant::NextScriptActionsRequestProto& ScriptActionRequestProto::next_request() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptActionRequestProto.next_request)
  return _internal_next_request();
}
inline ::autofill_assistant::NextScriptActionsRequestProto* ScriptActionRequestProto::unsafe_arena_release_next_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ScriptActionRequestProto.next_request)
  if (_internal_has_next_request()) {
    clear_has_request();
    ::autofill_assistant::NextScriptActionsRequestProto* temp = request_.next_request_;
    request_.next_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScriptActionRequestProto::unsafe_arena_set_allocated_next_request(::autofill_assistant::NextScriptActionsRequestProto* next_request) {
  clear_request();
  if (next_request) {
    set_has_next_request();
    request_.next_request_ = next_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScriptActionRequestProto.next_request)
}
inline ::autofill_assistant::NextScriptActionsRequestProto* ScriptActionRequestProto::_internal_mutable_next_request() {
  if (!_internal_has_next_request()) {
    clear_request();
    set_has_next_request();
    request_.next_request_ = CreateMaybeMessage< ::autofill_assistant::NextScriptActionsRequestProto >(GetArenaForAllocation());
  }
  return request_.next_request_;
}
inline ::autofill_assistant::NextScriptActionsRequestProto* ScriptActionRequestProto::mutable_next_request() {
  ::autofill_assistant::NextScriptActionsRequestProto* _msg = _internal_mutable_next_request();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptActionRequestProto.next_request)
  return _msg;
}

inline bool ScriptActionRequestProto::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void ScriptActionRequestProto::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline ScriptActionRequestProto::RequestCase ScriptActionRequestProto::request_case() const {
  return ScriptActionRequestProto::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ScriptStoreConfig

// optional string bundle_path = 2;
inline bool ScriptStoreConfig::_internal_has_bundle_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScriptStoreConfig::has_bundle_path() const {
  return _internal_has_bundle_path();
}
inline void ScriptStoreConfig::clear_bundle_path() {
  bundle_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScriptStoreConfig::bundle_path() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptStoreConfig.bundle_path)
  return _internal_bundle_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScriptStoreConfig::set_bundle_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 bundle_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptStoreConfig.bundle_path)
}
inline std::string* ScriptStoreConfig::mutable_bundle_path() {
  std::string* _s = _internal_mutable_bundle_path();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScriptStoreConfig.bundle_path)
  return _s;
}
inline const std::string& ScriptStoreConfig::_internal_bundle_path() const {
  return bundle_path_.Get();
}
inline void ScriptStoreConfig::_internal_set_bundle_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bundle_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ScriptStoreConfig::_internal_mutable_bundle_path() {
  _has_bits_[0] |= 0x00000001u;
  return bundle_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ScriptStoreConfig::release_bundle_path() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScriptStoreConfig.bundle_path)
  if (!_internal_has_bundle_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = bundle_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bundle_path_.IsDefault()) {
    bundle_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScriptStoreConfig::set_allocated_bundle_path(std::string* bundle_path) {
  if (bundle_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bundle_path_.SetAllocated(bundle_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bundle_path_.IsDefault()) {
    bundle_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptStoreConfig.bundle_path)
}

// optional int64 bundle_version = 3;
inline bool ScriptStoreConfig::_internal_has_bundle_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScriptStoreConfig::has_bundle_version() const {
  return _internal_has_bundle_version();
}
inline void ScriptStoreConfig::clear_bundle_version() {
  bundle_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ScriptStoreConfig::_internal_bundle_version() const {
  return bundle_version_;
}
inline int64_t ScriptStoreConfig::bundle_version() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScriptStoreConfig.bundle_version)
  return _internal_bundle_version();
}
inline void ScriptStoreConfig::_internal_set_bundle_version(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  bundle_version_ = value;
}
inline void ScriptStoreConfig::set_bundle_version(int64_t value) {
  _internal_set_bundle_version(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScriptStoreConfig.bundle_version)
}

// -------------------------------------------------------------------

// InitialScriptActionsRequestProto_QueryProto

// repeated string script_path = 1;
inline int InitialScriptActionsRequestProto_QueryProto::_internal_script_path_size() const {
  return script_path_.size();
}
inline int InitialScriptActionsRequestProto_QueryProto::script_path_size() const {
  return _internal_script_path_size();
}
inline void InitialScriptActionsRequestProto_QueryProto::clear_script_path() {
  script_path_.Clear();
}
inline std::string* InitialScriptActionsRequestProto_QueryProto::add_script_path() {
  std::string* _s = _internal_add_script_path();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
  return _s;
}
inline const std::string& InitialScriptActionsRequestProto_QueryProto::_internal_script_path(int index) const {
  return script_path_.Get(index);
}
inline const std::string& InitialScriptActionsRequestProto_QueryProto::script_path(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
  return _internal_script_path(index);
}
inline std::string* InitialScriptActionsRequestProto_QueryProto::mutable_script_path(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
  return script_path_.Mutable(index);
}
inline void InitialScriptActionsRequestProto_QueryProto::set_script_path(int index, const std::string& value) {
  script_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline void InitialScriptActionsRequestProto_QueryProto::set_script_path(int index, std::string&& value) {
  script_path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline void InitialScriptActionsRequestProto_QueryProto::set_script_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  script_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline void InitialScriptActionsRequestProto_QueryProto::set_script_path(int index, const char* value, size_t size) {
  script_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline std::string* InitialScriptActionsRequestProto_QueryProto::_internal_add_script_path() {
  return script_path_.Add();
}
inline void InitialScriptActionsRequestProto_QueryProto::add_script_path(const std::string& value) {
  script_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline void InitialScriptActionsRequestProto_QueryProto::add_script_path(std::string&& value) {
  script_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline void InitialScriptActionsRequestProto_QueryProto::add_script_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  script_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline void InitialScriptActionsRequestProto_QueryProto::add_script_path(const char* value, size_t size) {
  script_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InitialScriptActionsRequestProto_QueryProto::script_path() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
  return script_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InitialScriptActionsRequestProto_QueryProto::mutable_script_path() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.script_path)
  return &script_path_;
}

// optional string url = 2;
inline bool InitialScriptActionsRequestProto_QueryProto::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitialScriptActionsRequestProto_QueryProto::has_url() const {
  return _internal_has_url();
}
inline void InitialScriptActionsRequestProto_QueryProto::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitialScriptActionsRequestProto_QueryProto::url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitialScriptActionsRequestProto_QueryProto::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.url)
}
inline std::string* InitialScriptActionsRequestProto_QueryProto::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.url)
  return _s;
}
inline const std::string& InitialScriptActionsRequestProto_QueryProto::_internal_url() const {
  return url_.Get();
}
inline void InitialScriptActionsRequestProto_QueryProto::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* InitialScriptActionsRequestProto_QueryProto::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* InitialScriptActionsRequestProto_QueryProto::release_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitialScriptActionsRequestProto_QueryProto::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.url)
}

// optional .autofill_assistant.PolicyType policy = 3;
inline bool InitialScriptActionsRequestProto_QueryProto::_internal_has_policy() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InitialScriptActionsRequestProto_QueryProto::has_policy() const {
  return _internal_has_policy();
}
inline void InitialScriptActionsRequestProto_QueryProto::clear_policy() {
  policy_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::PolicyType InitialScriptActionsRequestProto_QueryProto::_internal_policy() const {
  return static_cast< ::autofill_assistant::PolicyType >(policy_);
}
inline ::autofill_assistant::PolicyType InitialScriptActionsRequestProto_QueryProto::policy() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.policy)
  return _internal_policy();
}
inline void InitialScriptActionsRequestProto_QueryProto::_internal_set_policy(::autofill_assistant::PolicyType value) {
  assert(::autofill_assistant::PolicyType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  policy_ = value;
}
inline void InitialScriptActionsRequestProto_QueryProto::set_policy(::autofill_assistant::PolicyType value) {
  _internal_set_policy(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.InitialScriptActionsRequestProto.QueryProto.policy)
}

// -------------------------------------------------------------------

// InitialScriptActionsRequestProto

// optional .autofill_assistant.InitialScriptActionsRequestProto.QueryProto query = 3;
inline bool InitialScriptActionsRequestProto::_internal_has_query() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || query_ != nullptr);
  return value;
}
inline bool InitialScriptActionsRequestProto::has_query() const {
  return _internal_has_query();
}
inline void InitialScriptActionsRequestProto::clear_query() {
  if (query_ != nullptr) query_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto& InitialScriptActionsRequestProto::_internal_query() const {
  const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* p = query_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto&>(
      ::autofill_assistant::_InitialScriptActionsRequestProto_QueryProto_default_instance_);
}
inline const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto& InitialScriptActionsRequestProto::query() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InitialScriptActionsRequestProto.query)
  return _internal_query();
}
inline void InitialScriptActionsRequestProto::unsafe_arena_set_allocated_query(
    ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_);
  }
  query_ = query;
  if (query) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InitialScriptActionsRequestProto.query)
}
inline ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* InitialScriptActionsRequestProto::release_query() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* temp = query_;
  query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* InitialScriptActionsRequestProto::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InitialScriptActionsRequestProto.query)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* temp = query_;
  query_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* InitialScriptActionsRequestProto::_internal_mutable_query() {
  _has_bits_[0] |= 0x00000001u;
  if (query_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InitialScriptActionsRequestProto_QueryProto>(GetArenaForAllocation());
    query_ = p;
  }
  return query_;
}
inline ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* InitialScriptActionsRequestProto::mutable_query() {
  ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InitialScriptActionsRequestProto.query)
  return _msg;
}
inline void InitialScriptActionsRequestProto::set_allocated_query(::autofill_assistant::InitialScriptActionsRequestProto_QueryProto* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InitialScriptActionsRequestProto.query)
}

// repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
inline int InitialScriptActionsRequestProto::_internal_script_parameters_size() const {
  return script_parameters_.size();
}
inline int InitialScriptActionsRequestProto::script_parameters_size() const {
  return _internal_script_parameters_size();
}
inline void InitialScriptActionsRequestProto::clear_script_parameters() {
  script_parameters_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* InitialScriptActionsRequestProto::mutable_script_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InitialScriptActionsRequestProto.script_parameters)
  return script_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
InitialScriptActionsRequestProto::mutable_script_parameters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.InitialScriptActionsRequestProto.script_parameters)
  return &script_parameters_;
}
inline const ::autofill_assistant::ScriptParameterProto& InitialScriptActionsRequestProto::_internal_script_parameters(int index) const {
  return script_parameters_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& InitialScriptActionsRequestProto::script_parameters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InitialScriptActionsRequestProto.script_parameters)
  return _internal_script_parameters(index);
}
inline ::autofill_assistant::ScriptParameterProto* InitialScriptActionsRequestProto::_internal_add_script_parameters() {
  return script_parameters_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* InitialScriptActionsRequestProto::add_script_parameters() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_script_parameters();
  // @@protoc_insertion_point(field_add:autofill_assistant.InitialScriptActionsRequestProto.script_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
InitialScriptActionsRequestProto::script_parameters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.InitialScriptActionsRequestProto.script_parameters)
  return script_parameters_;
}

// optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
inline bool InitialScriptActionsRequestProto::_internal_has_script_store_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || script_store_config_ != nullptr);
  return value;
}
inline bool InitialScriptActionsRequestProto::has_script_store_config() const {
  return _internal_has_script_store_config();
}
inline void InitialScriptActionsRequestProto::clear_script_store_config() {
  if (script_store_config_ != nullptr) script_store_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ScriptStoreConfig& InitialScriptActionsRequestProto::_internal_script_store_config() const {
  const ::autofill_assistant::ScriptStoreConfig* p = script_store_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ScriptStoreConfig&>(
      ::autofill_assistant::_ScriptStoreConfig_default_instance_);
}
inline const ::autofill_assistant::ScriptStoreConfig& InitialScriptActionsRequestProto::script_store_config() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InitialScriptActionsRequestProto.script_store_config)
  return _internal_script_store_config();
}
inline void InitialScriptActionsRequestProto::unsafe_arena_set_allocated_script_store_config(
    ::autofill_assistant::ScriptStoreConfig* script_store_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(script_store_config_);
  }
  script_store_config_ = script_store_config;
  if (script_store_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InitialScriptActionsRequestProto.script_store_config)
}
inline ::autofill_assistant::ScriptStoreConfig* InitialScriptActionsRequestProto::release_script_store_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ScriptStoreConfig* temp = script_store_config_;
  script_store_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ScriptStoreConfig* InitialScriptActionsRequestProto::unsafe_arena_release_script_store_config() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InitialScriptActionsRequestProto.script_store_config)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ScriptStoreConfig* temp = script_store_config_;
  script_store_config_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ScriptStoreConfig* InitialScriptActionsRequestProto::_internal_mutable_script_store_config() {
  _has_bits_[0] |= 0x00000002u;
  if (script_store_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ScriptStoreConfig>(GetArenaForAllocation());
    script_store_config_ = p;
  }
  return script_store_config_;
}
inline ::autofill_assistant::ScriptStoreConfig* InitialScriptActionsRequestProto::mutable_script_store_config() {
  ::autofill_assistant::ScriptStoreConfig* _msg = _internal_mutable_script_store_config();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InitialScriptActionsRequestProto.script_store_config)
  return _msg;
}
inline void InitialScriptActionsRequestProto::set_allocated_script_store_config(::autofill_assistant::ScriptStoreConfig* script_store_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete script_store_config_;
  }
  if (script_store_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(script_store_config);
    if (message_arena != submessage_arena) {
      script_store_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, script_store_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  script_store_config_ = script_store_config;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InitialScriptActionsRequestProto.script_store_config)
}

// -------------------------------------------------------------------

// RoundtripTimingStats

// optional int64 roundtrip_time_ms = 1;
inline bool RoundtripTimingStats::_internal_has_roundtrip_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoundtripTimingStats::has_roundtrip_time_ms() const {
  return _internal_has_roundtrip_time_ms();
}
inline void RoundtripTimingStats::clear_roundtrip_time_ms() {
  roundtrip_time_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t RoundtripTimingStats::_internal_roundtrip_time_ms() const {
  return roundtrip_time_ms_;
}
inline int64_t RoundtripTimingStats::roundtrip_time_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripTimingStats.roundtrip_time_ms)
  return _internal_roundtrip_time_ms();
}
inline void RoundtripTimingStats::_internal_set_roundtrip_time_ms(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  roundtrip_time_ms_ = value;
}
inline void RoundtripTimingStats::set_roundtrip_time_ms(int64_t value) {
  _internal_set_roundtrip_time_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripTimingStats.roundtrip_time_ms)
}

// optional int64 client_time_ms = 2;
inline bool RoundtripTimingStats::_internal_has_client_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoundtripTimingStats::has_client_time_ms() const {
  return _internal_has_client_time_ms();
}
inline void RoundtripTimingStats::clear_client_time_ms() {
  client_time_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t RoundtripTimingStats::_internal_client_time_ms() const {
  return client_time_ms_;
}
inline int64_t RoundtripTimingStats::client_time_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripTimingStats.client_time_ms)
  return _internal_client_time_ms();
}
inline void RoundtripTimingStats::_internal_set_client_time_ms(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_time_ms_ = value;
}
inline void RoundtripTimingStats::set_client_time_ms(int64_t value) {
  _internal_set_client_time_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripTimingStats.client_time_ms)
}

// -------------------------------------------------------------------

// RoundtripNetworkStats_ActionNetworkStats

// optional int32 action_info_case = 1;
inline bool RoundtripNetworkStats_ActionNetworkStats::_internal_has_action_info_case() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoundtripNetworkStats_ActionNetworkStats::has_action_info_case() const {
  return _internal_has_action_info_case();
}
inline void RoundtripNetworkStats_ActionNetworkStats::clear_action_info_case() {
  action_info_case_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t RoundtripNetworkStats_ActionNetworkStats::_internal_action_info_case() const {
  return action_info_case_;
}
inline int32_t RoundtripNetworkStats_ActionNetworkStats::action_info_case() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats.action_info_case)
  return _internal_action_info_case();
}
inline void RoundtripNetworkStats_ActionNetworkStats::_internal_set_action_info_case(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  action_info_case_ = value;
}
inline void RoundtripNetworkStats_ActionNetworkStats::set_action_info_case(int32_t value) {
  _internal_set_action_info_case(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats.action_info_case)
}

// optional int64 decoded_size_bytes = 2;
inline bool RoundtripNetworkStats_ActionNetworkStats::_internal_has_decoded_size_bytes() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoundtripNetworkStats_ActionNetworkStats::has_decoded_size_bytes() const {
  return _internal_has_decoded_size_bytes();
}
inline void RoundtripNetworkStats_ActionNetworkStats::clear_decoded_size_bytes() {
  decoded_size_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t RoundtripNetworkStats_ActionNetworkStats::_internal_decoded_size_bytes() const {
  return decoded_size_bytes_;
}
inline int64_t RoundtripNetworkStats_ActionNetworkStats::decoded_size_bytes() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats.decoded_size_bytes)
  return _internal_decoded_size_bytes();
}
inline void RoundtripNetworkStats_ActionNetworkStats::_internal_set_decoded_size_bytes(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  decoded_size_bytes_ = value;
}
inline void RoundtripNetworkStats_ActionNetworkStats::set_decoded_size_bytes(int64_t value) {
  _internal_set_decoded_size_bytes(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats.decoded_size_bytes)
}

// -------------------------------------------------------------------

// RoundtripNetworkStats

// optional int64 roundtrip_encoded_body_size_bytes = 1;
inline bool RoundtripNetworkStats::_internal_has_roundtrip_encoded_body_size_bytes() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoundtripNetworkStats::has_roundtrip_encoded_body_size_bytes() const {
  return _internal_has_roundtrip_encoded_body_size_bytes();
}
inline void RoundtripNetworkStats::clear_roundtrip_encoded_body_size_bytes() {
  roundtrip_encoded_body_size_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t RoundtripNetworkStats::_internal_roundtrip_encoded_body_size_bytes() const {
  return roundtrip_encoded_body_size_bytes_;
}
inline int64_t RoundtripNetworkStats::roundtrip_encoded_body_size_bytes() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripNetworkStats.roundtrip_encoded_body_size_bytes)
  return _internal_roundtrip_encoded_body_size_bytes();
}
inline void RoundtripNetworkStats::_internal_set_roundtrip_encoded_body_size_bytes(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  roundtrip_encoded_body_size_bytes_ = value;
}
inline void RoundtripNetworkStats::set_roundtrip_encoded_body_size_bytes(int64_t value) {
  _internal_set_roundtrip_encoded_body_size_bytes(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripNetworkStats.roundtrip_encoded_body_size_bytes)
}

// optional int64 roundtrip_decoded_body_size_bytes = 2;
inline bool RoundtripNetworkStats::_internal_has_roundtrip_decoded_body_size_bytes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoundtripNetworkStats::has_roundtrip_decoded_body_size_bytes() const {
  return _internal_has_roundtrip_decoded_body_size_bytes();
}
inline void RoundtripNetworkStats::clear_roundtrip_decoded_body_size_bytes() {
  roundtrip_decoded_body_size_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t RoundtripNetworkStats::_internal_roundtrip_decoded_body_size_bytes() const {
  return roundtrip_decoded_body_size_bytes_;
}
inline int64_t RoundtripNetworkStats::roundtrip_decoded_body_size_bytes() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripNetworkStats.roundtrip_decoded_body_size_bytes)
  return _internal_roundtrip_decoded_body_size_bytes();
}
inline void RoundtripNetworkStats::_internal_set_roundtrip_decoded_body_size_bytes(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  roundtrip_decoded_body_size_bytes_ = value;
}
inline void RoundtripNetworkStats::set_roundtrip_decoded_body_size_bytes(int64_t value) {
  _internal_set_roundtrip_decoded_body_size_bytes(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripNetworkStats.roundtrip_decoded_body_size_bytes)
}

// repeated .autofill_assistant.RoundtripNetworkStats.ActionNetworkStats action_stats = 3;
inline int RoundtripNetworkStats::_internal_action_stats_size() const {
  return action_stats_.size();
}
inline int RoundtripNetworkStats::action_stats_size() const {
  return _internal_action_stats_size();
}
inline void RoundtripNetworkStats::clear_action_stats() {
  action_stats_.Clear();
}
inline ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* RoundtripNetworkStats::mutable_action_stats(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.RoundtripNetworkStats.action_stats)
  return action_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats >*
RoundtripNetworkStats::mutable_action_stats() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.RoundtripNetworkStats.action_stats)
  return &action_stats_;
}
inline const ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats& RoundtripNetworkStats::_internal_action_stats(int index) const {
  return action_stats_.Get(index);
}
inline const ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats& RoundtripNetworkStats::action_stats(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripNetworkStats.action_stats)
  return _internal_action_stats(index);
}
inline ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* RoundtripNetworkStats::_internal_add_action_stats() {
  return action_stats_.Add();
}
inline ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* RoundtripNetworkStats::add_action_stats() {
  ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats* _add = _internal_add_action_stats();
  // @@protoc_insertion_point(field_add:autofill_assistant.RoundtripNetworkStats.action_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats >&
RoundtripNetworkStats::action_stats() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.RoundtripNetworkStats.action_stats)
  return action_stats_;
}

// optional int32 num_roundtrips = 4;
inline bool RoundtripNetworkStats::_internal_has_num_roundtrips() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoundtripNetworkStats::has_num_roundtrips() const {
  return _internal_has_num_roundtrips();
}
inline void RoundtripNetworkStats::clear_num_roundtrips() {
  num_roundtrips_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t RoundtripNetworkStats::_internal_num_roundtrips() const {
  return num_roundtrips_;
}
inline int32_t RoundtripNetworkStats::num_roundtrips() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RoundtripNetworkStats.num_roundtrips)
  return _internal_num_roundtrips();
}
inline void RoundtripNetworkStats::_internal_set_num_roundtrips(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  num_roundtrips_ = value;
}
inline void RoundtripNetworkStats::set_num_roundtrips(int32_t value) {
  _internal_set_num_roundtrips(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RoundtripNetworkStats.num_roundtrips)
}

// -------------------------------------------------------------------

// NextScriptActionsRequestProto

// repeated .autofill_assistant.ProcessedActionProto processed_actions = 1;
inline int NextScriptActionsRequestProto::_internal_processed_actions_size() const {
  return processed_actions_.size();
}
inline int NextScriptActionsRequestProto::processed_actions_size() const {
  return _internal_processed_actions_size();
}
inline void NextScriptActionsRequestProto::clear_processed_actions() {
  processed_actions_.Clear();
}
inline ::autofill_assistant::ProcessedActionProto* NextScriptActionsRequestProto::mutable_processed_actions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.NextScriptActionsRequestProto.processed_actions)
  return processed_actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProcessedActionProto >*
NextScriptActionsRequestProto::mutable_processed_actions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.NextScriptActionsRequestProto.processed_actions)
  return &processed_actions_;
}
inline const ::autofill_assistant::ProcessedActionProto& NextScriptActionsRequestProto::_internal_processed_actions(int index) const {
  return processed_actions_.Get(index);
}
inline const ::autofill_assistant::ProcessedActionProto& NextScriptActionsRequestProto::processed_actions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NextScriptActionsRequestProto.processed_actions)
  return _internal_processed_actions(index);
}
inline ::autofill_assistant::ProcessedActionProto* NextScriptActionsRequestProto::_internal_add_processed_actions() {
  return processed_actions_.Add();
}
inline ::autofill_assistant::ProcessedActionProto* NextScriptActionsRequestProto::add_processed_actions() {
  ::autofill_assistant::ProcessedActionProto* _add = _internal_add_processed_actions();
  // @@protoc_insertion_point(field_add:autofill_assistant.NextScriptActionsRequestProto.processed_actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ProcessedActionProto >&
NextScriptActionsRequestProto::processed_actions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.NextScriptActionsRequestProto.processed_actions)
  return processed_actions_;
}

// optional .autofill_assistant.RoundtripTimingStats timing_stats = 2;
inline bool NextScriptActionsRequestProto::_internal_has_timing_stats() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || timing_stats_ != nullptr);
  return value;
}
inline bool NextScriptActionsRequestProto::has_timing_stats() const {
  return _internal_has_timing_stats();
}
inline void NextScriptActionsRequestProto::clear_timing_stats() {
  if (timing_stats_ != nullptr) timing_stats_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::RoundtripTimingStats& NextScriptActionsRequestProto::_internal_timing_stats() const {
  const ::autofill_assistant::RoundtripTimingStats* p = timing_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::RoundtripTimingStats&>(
      ::autofill_assistant::_RoundtripTimingStats_default_instance_);
}
inline const ::autofill_assistant::RoundtripTimingStats& NextScriptActionsRequestProto::timing_stats() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NextScriptActionsRequestProto.timing_stats)
  return _internal_timing_stats();
}
inline void NextScriptActionsRequestProto::unsafe_arena_set_allocated_timing_stats(
    ::autofill_assistant::RoundtripTimingStats* timing_stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timing_stats_);
  }
  timing_stats_ = timing_stats;
  if (timing_stats) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.NextScriptActionsRequestProto.timing_stats)
}
inline ::autofill_assistant::RoundtripTimingStats* NextScriptActionsRequestProto::release_timing_stats() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::RoundtripTimingStats* temp = timing_stats_;
  timing_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::RoundtripTimingStats* NextScriptActionsRequestProto::unsafe_arena_release_timing_stats() {
  // @@protoc_insertion_point(field_release:autofill_assistant.NextScriptActionsRequestProto.timing_stats)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::RoundtripTimingStats* temp = timing_stats_;
  timing_stats_ = nullptr;
  return temp;
}
inline ::autofill_assistant::RoundtripTimingStats* NextScriptActionsRequestProto::_internal_mutable_timing_stats() {
  _has_bits_[0] |= 0x00000001u;
  if (timing_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::RoundtripTimingStats>(GetArenaForAllocation());
    timing_stats_ = p;
  }
  return timing_stats_;
}
inline ::autofill_assistant::RoundtripTimingStats* NextScriptActionsRequestProto::mutable_timing_stats() {
  ::autofill_assistant::RoundtripTimingStats* _msg = _internal_mutable_timing_stats();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.NextScriptActionsRequestProto.timing_stats)
  return _msg;
}
inline void NextScriptActionsRequestProto::set_allocated_timing_stats(::autofill_assistant::RoundtripTimingStats* timing_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timing_stats_;
  }
  if (timing_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timing_stats);
    if (message_arena != submessage_arena) {
      timing_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  timing_stats_ = timing_stats;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.NextScriptActionsRequestProto.timing_stats)
}

// optional .autofill_assistant.SlowWarningStatus slow_connection_warning = 34;
inline bool NextScriptActionsRequestProto::_internal_has_slow_connection_warning() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NextScriptActionsRequestProto::has_slow_connection_warning() const {
  return _internal_has_slow_connection_warning();
}
inline void NextScriptActionsRequestProto::clear_slow_connection_warning() {
  slow_connection_warning_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::SlowWarningStatus NextScriptActionsRequestProto::_internal_slow_connection_warning() const {
  return static_cast< ::autofill_assistant::SlowWarningStatus >(slow_connection_warning_);
}
inline ::autofill_assistant::SlowWarningStatus NextScriptActionsRequestProto::slow_connection_warning() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NextScriptActionsRequestProto.slow_connection_warning)
  return _internal_slow_connection_warning();
}
inline void NextScriptActionsRequestProto::_internal_set_slow_connection_warning(::autofill_assistant::SlowWarningStatus value) {
  assert(::autofill_assistant::SlowWarningStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  slow_connection_warning_ = value;
}
inline void NextScriptActionsRequestProto::set_slow_connection_warning(::autofill_assistant::SlowWarningStatus value) {
  _internal_set_slow_connection_warning(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NextScriptActionsRequestProto.slow_connection_warning)
}

// optional .autofill_assistant.RoundtripNetworkStats network_stats = 3;
inline bool NextScriptActionsRequestProto::_internal_has_network_stats() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || network_stats_ != nullptr);
  return value;
}
inline bool NextScriptActionsRequestProto::has_network_stats() const {
  return _internal_has_network_stats();
}
inline void NextScriptActionsRequestProto::clear_network_stats() {
  if (network_stats_ != nullptr) network_stats_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::RoundtripNetworkStats& NextScriptActionsRequestProto::_internal_network_stats() const {
  const ::autofill_assistant::RoundtripNetworkStats* p = network_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::RoundtripNetworkStats&>(
      ::autofill_assistant::_RoundtripNetworkStats_default_instance_);
}
inline const ::autofill_assistant::RoundtripNetworkStats& NextScriptActionsRequestProto::network_stats() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NextScriptActionsRequestProto.network_stats)
  return _internal_network_stats();
}
inline void NextScriptActionsRequestProto::unsafe_arena_set_allocated_network_stats(
    ::autofill_assistant::RoundtripNetworkStats* network_stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_stats_);
  }
  network_stats_ = network_stats;
  if (network_stats) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.NextScriptActionsRequestProto.network_stats)
}
inline ::autofill_assistant::RoundtripNetworkStats* NextScriptActionsRequestProto::release_network_stats() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::RoundtripNetworkStats* temp = network_stats_;
  network_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::RoundtripNetworkStats* NextScriptActionsRequestProto::unsafe_arena_release_network_stats() {
  // @@protoc_insertion_point(field_release:autofill_assistant.NextScriptActionsRequestProto.network_stats)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::RoundtripNetworkStats* temp = network_stats_;
  network_stats_ = nullptr;
  return temp;
}
inline ::autofill_assistant::RoundtripNetworkStats* NextScriptActionsRequestProto::_internal_mutable_network_stats() {
  _has_bits_[0] |= 0x00000002u;
  if (network_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::RoundtripNetworkStats>(GetArenaForAllocation());
    network_stats_ = p;
  }
  return network_stats_;
}
inline ::autofill_assistant::RoundtripNetworkStats* NextScriptActionsRequestProto::mutable_network_stats() {
  ::autofill_assistant::RoundtripNetworkStats* _msg = _internal_mutable_network_stats();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.NextScriptActionsRequestProto.network_stats)
  return _msg;
}
inline void NextScriptActionsRequestProto::set_allocated_network_stats(::autofill_assistant::RoundtripNetworkStats* network_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete network_stats_;
  }
  if (network_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_stats);
    if (message_arena != submessage_arena) {
      network_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  network_stats_ = network_stats;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.NextScriptActionsRequestProto.network_stats)
}

// -------------------------------------------------------------------

// CUPResponseData

// optional bytes response = 1;
inline bool CUPResponseData::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CUPResponseData::has_response() const {
  return _internal_has_response();
}
inline void CUPResponseData::clear_response() {
  response_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CUPResponseData::response() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CUPResponseData.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CUPResponseData::set_response(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 response_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CUPResponseData.response)
}
inline std::string* CUPResponseData::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CUPResponseData.response)
  return _s;
}
inline const std::string& CUPResponseData::_internal_response() const {
  return response_.Get();
}
inline void CUPResponseData::_internal_set_response(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  response_.Set(value, GetArenaForAllocation());
}
inline std::string* CUPResponseData::_internal_mutable_response() {
  _has_bits_[0] |= 0x00000001u;
  return response_.Mutable(GetArenaForAllocation());
}
inline std::string* CUPResponseData::release_response() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CUPResponseData.response)
  if (!_internal_has_response()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_.IsDefault()) {
    response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CUPResponseData::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  response_.SetAllocated(response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_.IsDefault()) {
    response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CUPResponseData.response)
}

// optional bytes ecdsa_signature = 2;
inline bool CUPResponseData::_internal_has_ecdsa_signature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CUPResponseData::has_ecdsa_signature() const {
  return _internal_has_ecdsa_signature();
}
inline void CUPResponseData::clear_ecdsa_signature() {
  ecdsa_signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CUPResponseData::ecdsa_signature() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CUPResponseData.ecdsa_signature)
  return _internal_ecdsa_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CUPResponseData::set_ecdsa_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ecdsa_signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CUPResponseData.ecdsa_signature)
}
inline std::string* CUPResponseData::mutable_ecdsa_signature() {
  std::string* _s = _internal_mutable_ecdsa_signature();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CUPResponseData.ecdsa_signature)
  return _s;
}
inline const std::string& CUPResponseData::_internal_ecdsa_signature() const {
  return ecdsa_signature_.Get();
}
inline void CUPResponseData::_internal_set_ecdsa_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ecdsa_signature_.Set(value, GetArenaForAllocation());
}
inline std::string* CUPResponseData::_internal_mutable_ecdsa_signature() {
  _has_bits_[0] |= 0x00000002u;
  return ecdsa_signature_.Mutable(GetArenaForAllocation());
}
inline std::string* CUPResponseData::release_ecdsa_signature() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CUPResponseData.ecdsa_signature)
  if (!_internal_has_ecdsa_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ecdsa_signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ecdsa_signature_.IsDefault()) {
    ecdsa_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CUPResponseData::set_allocated_ecdsa_signature(std::string* ecdsa_signature) {
  if (ecdsa_signature != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ecdsa_signature_.SetAllocated(ecdsa_signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ecdsa_signature_.IsDefault()) {
    ecdsa_signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CUPResponseData.ecdsa_signature)
}

// -------------------------------------------------------------------

// ActionsResponseProto_UpdateScriptListProto

// repeated .autofill_assistant.SupportedScriptProto scripts = 1;
inline int ActionsResponseProto_UpdateScriptListProto::_internal_scripts_size() const {
  return scripts_.size();
}
inline int ActionsResponseProto_UpdateScriptListProto::scripts_size() const {
  return _internal_scripts_size();
}
inline void ActionsResponseProto_UpdateScriptListProto::clear_scripts() {
  scripts_.Clear();
}
inline ::autofill_assistant::SupportedScriptProto* ActionsResponseProto_UpdateScriptListProto::mutable_scripts(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.UpdateScriptListProto.scripts)
  return scripts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >*
ActionsResponseProto_UpdateScriptListProto::mutable_scripts() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ActionsResponseProto.UpdateScriptListProto.scripts)
  return &scripts_;
}
inline const ::autofill_assistant::SupportedScriptProto& ActionsResponseProto_UpdateScriptListProto::_internal_scripts(int index) const {
  return scripts_.Get(index);
}
inline const ::autofill_assistant::SupportedScriptProto& ActionsResponseProto_UpdateScriptListProto::scripts(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.UpdateScriptListProto.scripts)
  return _internal_scripts(index);
}
inline ::autofill_assistant::SupportedScriptProto* ActionsResponseProto_UpdateScriptListProto::_internal_add_scripts() {
  return scripts_.Add();
}
inline ::autofill_assistant::SupportedScriptProto* ActionsResponseProto_UpdateScriptListProto::add_scripts() {
  ::autofill_assistant::SupportedScriptProto* _add = _internal_add_scripts();
  // @@protoc_insertion_point(field_add:autofill_assistant.ActionsResponseProto.UpdateScriptListProto.scripts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SupportedScriptProto >&
ActionsResponseProto_UpdateScriptListProto::scripts() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ActionsResponseProto.UpdateScriptListProto.scripts)
  return scripts_;
}

// -------------------------------------------------------------------

// ActionsResponseProto

// optional .autofill_assistant.CUPResponseData cup_data = 11;
inline bool ActionsResponseProto::_internal_has_cup_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || cup_data_ != nullptr);
  return value;
}
inline bool ActionsResponseProto::has_cup_data() const {
  return _internal_has_cup_data();
}
inline void ActionsResponseProto::clear_cup_data() {
  if (cup_data_ != nullptr) cup_data_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill_assistant::CUPResponseData& ActionsResponseProto::_internal_cup_data() const {
  const ::autofill_assistant::CUPResponseData* p = cup_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::CUPResponseData&>(
      ::autofill_assistant::_CUPResponseData_default_instance_);
}
inline const ::autofill_assistant::CUPResponseData& ActionsResponseProto::cup_data() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.cup_data)
  return _internal_cup_data();
}
inline void ActionsResponseProto::unsafe_arena_set_allocated_cup_data(
    ::autofill_assistant::CUPResponseData* cup_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cup_data_);
  }
  cup_data_ = cup_data;
  if (cup_data) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionsResponseProto.cup_data)
}
inline ::autofill_assistant::CUPResponseData* ActionsResponseProto::release_cup_data() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill_assistant::CUPResponseData* temp = cup_data_;
  cup_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::CUPResponseData* ActionsResponseProto::unsafe_arena_release_cup_data() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionsResponseProto.cup_data)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill_assistant::CUPResponseData* temp = cup_data_;
  cup_data_ = nullptr;
  return temp;
}
inline ::autofill_assistant::CUPResponseData* ActionsResponseProto::_internal_mutable_cup_data() {
  _has_bits_[0] |= 0x00000020u;
  if (cup_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::CUPResponseData>(GetArenaForAllocation());
    cup_data_ = p;
  }
  return cup_data_;
}
inline ::autofill_assistant::CUPResponseData* ActionsResponseProto::mutable_cup_data() {
  ::autofill_assistant::CUPResponseData* _msg = _internal_mutable_cup_data();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.cup_data)
  return _msg;
}
inline void ActionsResponseProto::set_allocated_cup_data(::autofill_assistant::CUPResponseData* cup_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cup_data_;
  }
  if (cup_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cup_data);
    if (message_arena != submessage_arena) {
      cup_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cup_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  cup_data_ = cup_data;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionsResponseProto.cup_data)
}

// optional bytes global_payload = 4;
inline bool ActionsResponseProto::_internal_has_global_payload() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionsResponseProto::has_global_payload() const {
  return _internal_has_global_payload();
}
inline void ActionsResponseProto::clear_global_payload() {
  global_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionsResponseProto::global_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.global_payload)
  return _internal_global_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionsResponseProto::set_global_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 global_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionsResponseProto.global_payload)
}
inline std::string* ActionsResponseProto::mutable_global_payload() {
  std::string* _s = _internal_mutable_global_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.global_payload)
  return _s;
}
inline const std::string& ActionsResponseProto::_internal_global_payload() const {
  return global_payload_.Get();
}
inline void ActionsResponseProto::_internal_set_global_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  global_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::_internal_mutable_global_payload() {
  _has_bits_[0] |= 0x00000002u;
  return global_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::release_global_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionsResponseProto.global_payload)
  if (!_internal_has_global_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = global_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (global_payload_.IsDefault()) {
    global_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionsResponseProto::set_allocated_global_payload(std::string* global_payload) {
  if (global_payload != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  global_payload_.SetAllocated(global_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (global_payload_.IsDefault()) {
    global_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionsResponseProto.global_payload)
}

// optional bytes script_payload = 2;
inline bool ActionsResponseProto::_internal_has_script_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionsResponseProto::has_script_payload() const {
  return _internal_has_script_payload();
}
inline void ActionsResponseProto::clear_script_payload() {
  script_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionsResponseProto::script_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.script_payload)
  return _internal_script_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionsResponseProto::set_script_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 script_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionsResponseProto.script_payload)
}
inline std::string* ActionsResponseProto::mutable_script_payload() {
  std::string* _s = _internal_mutable_script_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.script_payload)
  return _s;
}
inline const std::string& ActionsResponseProto::_internal_script_payload() const {
  return script_payload_.Get();
}
inline void ActionsResponseProto::_internal_set_script_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  script_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::_internal_mutable_script_payload() {
  _has_bits_[0] |= 0x00000001u;
  return script_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::release_script_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionsResponseProto.script_payload)
  if (!_internal_has_script_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = script_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_payload_.IsDefault()) {
    script_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionsResponseProto::set_allocated_script_payload(std::string* script_payload) {
  if (script_payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_payload_.SetAllocated(script_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_payload_.IsDefault()) {
    script_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionsResponseProto.script_payload)
}

// repeated .autofill_assistant.ActionProto actions = 3;
inline int ActionsResponseProto::_internal_actions_size() const {
  return actions_.size();
}
inline int ActionsResponseProto::actions_size() const {
  return _internal_actions_size();
}
inline void ActionsResponseProto::clear_actions() {
  actions_.Clear();
}
inline ::autofill_assistant::ActionProto* ActionsResponseProto::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ActionProto >*
ActionsResponseProto::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ActionsResponseProto.actions)
  return &actions_;
}
inline const ::autofill_assistant::ActionProto& ActionsResponseProto::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::autofill_assistant::ActionProto& ActionsResponseProto::actions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.actions)
  return _internal_actions(index);
}
inline ::autofill_assistant::ActionProto* ActionsResponseProto::_internal_add_actions() {
  return actions_.Add();
}
inline ::autofill_assistant::ActionProto* ActionsResponseProto::add_actions() {
  ::autofill_assistant::ActionProto* _add = _internal_add_actions();
  // @@protoc_insertion_point(field_add:autofill_assistant.ActionsResponseProto.actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ActionProto >&
ActionsResponseProto::actions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ActionsResponseProto.actions)
  return actions_;
}

// optional .autofill_assistant.ActionsResponseProto.UpdateScriptListProto update_script_list = 5;
inline bool ActionsResponseProto::_internal_has_update_script_list() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || update_script_list_ != nullptr);
  return value;
}
inline bool ActionsResponseProto::has_update_script_list() const {
  return _internal_has_update_script_list();
}
inline void ActionsResponseProto::clear_update_script_list() {
  if (update_script_list_ != nullptr) update_script_list_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto& ActionsResponseProto::_internal_update_script_list() const {
  const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* p = update_script_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto&>(
      ::autofill_assistant::_ActionsResponseProto_UpdateScriptListProto_default_instance_);
}
inline const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto& ActionsResponseProto::update_script_list() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.update_script_list)
  return _internal_update_script_list();
}
inline void ActionsResponseProto::unsafe_arena_set_allocated_update_script_list(
    ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* update_script_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_script_list_);
  }
  update_script_list_ = update_script_list;
  if (update_script_list) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionsResponseProto.update_script_list)
}
inline ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* ActionsResponseProto::release_update_script_list() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* temp = update_script_list_;
  update_script_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* ActionsResponseProto::unsafe_arena_release_update_script_list() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionsResponseProto.update_script_list)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* temp = update_script_list_;
  update_script_list_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* ActionsResponseProto::_internal_mutable_update_script_list() {
  _has_bits_[0] |= 0x00000010u;
  if (update_script_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ActionsResponseProto_UpdateScriptListProto>(GetArenaForAllocation());
    update_script_list_ = p;
  }
  return update_script_list_;
}
inline ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* ActionsResponseProto::mutable_update_script_list() {
  ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* _msg = _internal_mutable_update_script_list();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.update_script_list)
  return _msg;
}
inline void ActionsResponseProto::set_allocated_update_script_list(::autofill_assistant::ActionsResponseProto_UpdateScriptListProto* update_script_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete update_script_list_;
  }
  if (update_script_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_script_list);
    if (message_arena != submessage_arena) {
      update_script_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_script_list, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  update_script_list_ = update_script_list;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionsResponseProto.update_script_list)
}

// optional string js_flow_library = 13;
inline bool ActionsResponseProto::_internal_has_js_flow_library() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActionsResponseProto::has_js_flow_library() const {
  return _internal_has_js_flow_library();
}
inline void ActionsResponseProto::clear_js_flow_library() {
  js_flow_library_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ActionsResponseProto::js_flow_library() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.js_flow_library)
  return _internal_js_flow_library();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionsResponseProto::set_js_flow_library(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 js_flow_library_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionsResponseProto.js_flow_library)
}
inline std::string* ActionsResponseProto::mutable_js_flow_library() {
  std::string* _s = _internal_mutable_js_flow_library();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.js_flow_library)
  return _s;
}
inline const std::string& ActionsResponseProto::_internal_js_flow_library() const {
  return js_flow_library_.Get();
}
inline void ActionsResponseProto::_internal_set_js_flow_library(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  js_flow_library_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::_internal_mutable_js_flow_library() {
  _has_bits_[0] |= 0x00000004u;
  return js_flow_library_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::release_js_flow_library() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionsResponseProto.js_flow_library)
  if (!_internal_has_js_flow_library()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = js_flow_library_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_flow_library_.IsDefault()) {
    js_flow_library_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionsResponseProto::set_allocated_js_flow_library(std::string* js_flow_library) {
  if (js_flow_library != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  js_flow_library_.SetAllocated(js_flow_library, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_flow_library_.IsDefault()) {
    js_flow_library_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionsResponseProto.js_flow_library)
}

// optional uint64 run_id = 12;
inline bool ActionsResponseProto::_internal_has_run_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ActionsResponseProto::has_run_id() const {
  return _internal_has_run_id();
}
inline void ActionsResponseProto::clear_run_id() {
  run_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t ActionsResponseProto::_internal_run_id() const {
  return run_id_;
}
inline uint64_t ActionsResponseProto::run_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.run_id)
  return _internal_run_id();
}
inline void ActionsResponseProto::_internal_set_run_id(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  run_id_ = value;
}
inline void ActionsResponseProto::set_run_id(uint64_t value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionsResponseProto.run_id)
}

// optional string report_token = 14;
inline bool ActionsResponseProto::_internal_has_report_token() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ActionsResponseProto::has_report_token() const {
  return _internal_has_report_token();
}
inline void ActionsResponseProto::clear_report_token() {
  report_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ActionsResponseProto::report_token() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionsResponseProto.report_token)
  return _internal_report_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionsResponseProto::set_report_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 report_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionsResponseProto.report_token)
}
inline std::string* ActionsResponseProto::mutable_report_token() {
  std::string* _s = _internal_mutable_report_token();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionsResponseProto.report_token)
  return _s;
}
inline const std::string& ActionsResponseProto::_internal_report_token() const {
  return report_token_.Get();
}
inline void ActionsResponseProto::_internal_set_report_token(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  report_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::_internal_mutable_report_token() {
  _has_bits_[0] |= 0x00000008u;
  return report_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionsResponseProto::release_report_token() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionsResponseProto.report_token)
  if (!_internal_has_report_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = report_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (report_token_.IsDefault()) {
    report_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionsResponseProto::set_allocated_report_token(std::string* report_token) {
  if (report_token != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  report_token_.SetAllocated(report_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (report_token_.IsDefault()) {
    report_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionsResponseProto.report_token)
}

// -------------------------------------------------------------------

// GetTriggerScriptsRequestProto

// optional string url = 1;
inline bool GetTriggerScriptsRequestProto::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetTriggerScriptsRequestProto::has_url() const {
  return _internal_has_url();
}
inline void GetTriggerScriptsRequestProto::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetTriggerScriptsRequestProto::url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsRequestProto.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTriggerScriptsRequestProto::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetTriggerScriptsRequestProto.url)
}
inline std::string* GetTriggerScriptsRequestProto::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetTriggerScriptsRequestProto.url)
  return _s;
}
inline const std::string& GetTriggerScriptsRequestProto::_internal_url() const {
  return url_.Get();
}
inline void GetTriggerScriptsRequestProto::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTriggerScriptsRequestProto::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTriggerScriptsRequestProto::release_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetTriggerScriptsRequestProto.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetTriggerScriptsRequestProto::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetTriggerScriptsRequestProto.url)
}

// optional .autofill_assistant.ClientContextProto client_context = 2;
inline bool GetTriggerScriptsRequestProto::_internal_has_client_context() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || client_context_ != nullptr);
  return value;
}
inline bool GetTriggerScriptsRequestProto::has_client_context() const {
  return _internal_has_client_context();
}
inline void GetTriggerScriptsRequestProto::clear_client_context() {
  if (client_context_ != nullptr) client_context_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientContextProto& GetTriggerScriptsRequestProto::_internal_client_context() const {
  const ::autofill_assistant::ClientContextProto* p = client_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientContextProto&>(
      ::autofill_assistant::_ClientContextProto_default_instance_);
}
inline const ::autofill_assistant::ClientContextProto& GetTriggerScriptsRequestProto::client_context() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsRequestProto.client_context)
  return _internal_client_context();
}
inline void GetTriggerScriptsRequestProto::unsafe_arena_set_allocated_client_context(
    ::autofill_assistant::ClientContextProto* client_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_context_);
  }
  client_context_ = client_context;
  if (client_context) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetTriggerScriptsRequestProto.client_context)
}
inline ::autofill_assistant::ClientContextProto* GetTriggerScriptsRequestProto::release_client_context() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientContextProto* GetTriggerScriptsRequestProto::unsafe_arena_release_client_context() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetTriggerScriptsRequestProto.client_context)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientContextProto* temp = client_context_;
  client_context_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientContextProto* GetTriggerScriptsRequestProto::_internal_mutable_client_context() {
  _has_bits_[0] |= 0x00000002u;
  if (client_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientContextProto>(GetArenaForAllocation());
    client_context_ = p;
  }
  return client_context_;
}
inline ::autofill_assistant::ClientContextProto* GetTriggerScriptsRequestProto::mutable_client_context() {
  ::autofill_assistant::ClientContextProto* _msg = _internal_mutable_client_context();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetTriggerScriptsRequestProto.client_context)
  return _msg;
}
inline void GetTriggerScriptsRequestProto::set_allocated_client_context(::autofill_assistant::ClientContextProto* client_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_context_;
  }
  if (client_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_context);
    if (message_arena != submessage_arena) {
      client_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_context_ = client_context;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetTriggerScriptsRequestProto.client_context)
}

// repeated .autofill_assistant.ScriptParameterProto script_parameters = 3;
inline int GetTriggerScriptsRequestProto::_internal_script_parameters_size() const {
  return script_parameters_.size();
}
inline int GetTriggerScriptsRequestProto::script_parameters_size() const {
  return _internal_script_parameters_size();
}
inline void GetTriggerScriptsRequestProto::clear_script_parameters() {
  script_parameters_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* GetTriggerScriptsRequestProto::mutable_script_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetTriggerScriptsRequestProto.script_parameters)
  return script_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
GetTriggerScriptsRequestProto::mutable_script_parameters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetTriggerScriptsRequestProto.script_parameters)
  return &script_parameters_;
}
inline const ::autofill_assistant::ScriptParameterProto& GetTriggerScriptsRequestProto::_internal_script_parameters(int index) const {
  return script_parameters_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& GetTriggerScriptsRequestProto::script_parameters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsRequestProto.script_parameters)
  return _internal_script_parameters(index);
}
inline ::autofill_assistant::ScriptParameterProto* GetTriggerScriptsRequestProto::_internal_add_script_parameters() {
  return script_parameters_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* GetTriggerScriptsRequestProto::add_script_parameters() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_script_parameters();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetTriggerScriptsRequestProto.script_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
GetTriggerScriptsRequestProto::script_parameters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetTriggerScriptsRequestProto.script_parameters)
  return script_parameters_;
}

// -------------------------------------------------------------------

// GetTriggerScriptsResponseProto

// repeated .autofill_assistant.TriggerScriptProto trigger_scripts = 1;
inline int GetTriggerScriptsResponseProto::_internal_trigger_scripts_size() const {
  return trigger_scripts_.size();
}
inline int GetTriggerScriptsResponseProto::trigger_scripts_size() const {
  return _internal_trigger_scripts_size();
}
inline void GetTriggerScriptsResponseProto::clear_trigger_scripts() {
  trigger_scripts_.Clear();
}
inline ::autofill_assistant::TriggerScriptProto* GetTriggerScriptsResponseProto::mutable_trigger_scripts(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetTriggerScriptsResponseProto.trigger_scripts)
  return trigger_scripts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptProto >*
GetTriggerScriptsResponseProto::mutable_trigger_scripts() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetTriggerScriptsResponseProto.trigger_scripts)
  return &trigger_scripts_;
}
inline const ::autofill_assistant::TriggerScriptProto& GetTriggerScriptsResponseProto::_internal_trigger_scripts(int index) const {
  return trigger_scripts_.Get(index);
}
inline const ::autofill_assistant::TriggerScriptProto& GetTriggerScriptsResponseProto::trigger_scripts(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsResponseProto.trigger_scripts)
  return _internal_trigger_scripts(index);
}
inline ::autofill_assistant::TriggerScriptProto* GetTriggerScriptsResponseProto::_internal_add_trigger_scripts() {
  return trigger_scripts_.Add();
}
inline ::autofill_assistant::TriggerScriptProto* GetTriggerScriptsResponseProto::add_trigger_scripts() {
  ::autofill_assistant::TriggerScriptProto* _add = _internal_add_trigger_scripts();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetTriggerScriptsResponseProto.trigger_scripts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptProto >&
GetTriggerScriptsResponseProto::trigger_scripts() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetTriggerScriptsResponseProto.trigger_scripts)
  return trigger_scripts_;
}

// repeated string additional_allowed_domains = 2;
inline int GetTriggerScriptsResponseProto::_internal_additional_allowed_domains_size() const {
  return additional_allowed_domains_.size();
}
inline int GetTriggerScriptsResponseProto::additional_allowed_domains_size() const {
  return _internal_additional_allowed_domains_size();
}
inline void GetTriggerScriptsResponseProto::clear_additional_allowed_domains() {
  additional_allowed_domains_.Clear();
}
inline std::string* GetTriggerScriptsResponseProto::add_additional_allowed_domains() {
  std::string* _s = _internal_add_additional_allowed_domains();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
  return _s;
}
inline const std::string& GetTriggerScriptsResponseProto::_internal_additional_allowed_domains(int index) const {
  return additional_allowed_domains_.Get(index);
}
inline const std::string& GetTriggerScriptsResponseProto::additional_allowed_domains(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
  return _internal_additional_allowed_domains(index);
}
inline std::string* GetTriggerScriptsResponseProto::mutable_additional_allowed_domains(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
  return additional_allowed_domains_.Mutable(index);
}
inline void GetTriggerScriptsResponseProto::set_additional_allowed_domains(int index, const std::string& value) {
  additional_allowed_domains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline void GetTriggerScriptsResponseProto::set_additional_allowed_domains(int index, std::string&& value) {
  additional_allowed_domains_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline void GetTriggerScriptsResponseProto::set_additional_allowed_domains(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_allowed_domains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline void GetTriggerScriptsResponseProto::set_additional_allowed_domains(int index, const char* value, size_t size) {
  additional_allowed_domains_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline std::string* GetTriggerScriptsResponseProto::_internal_add_additional_allowed_domains() {
  return additional_allowed_domains_.Add();
}
inline void GetTriggerScriptsResponseProto::add_additional_allowed_domains(const std::string& value) {
  additional_allowed_domains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline void GetTriggerScriptsResponseProto::add_additional_allowed_domains(std::string&& value) {
  additional_allowed_domains_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline void GetTriggerScriptsResponseProto::add_additional_allowed_domains(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  additional_allowed_domains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline void GetTriggerScriptsResponseProto::add_additional_allowed_domains(const char* value, size_t size) {
  additional_allowed_domains_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTriggerScriptsResponseProto::additional_allowed_domains() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
  return additional_allowed_domains_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetTriggerScriptsResponseProto::mutable_additional_allowed_domains() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetTriggerScriptsResponseProto.additional_allowed_domains)
  return &additional_allowed_domains_;
}

// optional int32 trigger_condition_timeout_ms = 3;
inline bool GetTriggerScriptsResponseProto::_internal_has_trigger_condition_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetTriggerScriptsResponseProto::has_trigger_condition_timeout_ms() const {
  return _internal_has_trigger_condition_timeout_ms();
}
inline void GetTriggerScriptsResponseProto::clear_trigger_condition_timeout_ms() {
  trigger_condition_timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t GetTriggerScriptsResponseProto::_internal_trigger_condition_timeout_ms() const {
  return trigger_condition_timeout_ms_;
}
inline int32_t GetTriggerScriptsResponseProto::trigger_condition_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsResponseProto.trigger_condition_timeout_ms)
  return _internal_trigger_condition_timeout_ms();
}
inline void GetTriggerScriptsResponseProto::_internal_set_trigger_condition_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  trigger_condition_timeout_ms_ = value;
}
inline void GetTriggerScriptsResponseProto::set_trigger_condition_timeout_ms(int32_t value) {
  _internal_set_trigger_condition_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetTriggerScriptsResponseProto.trigger_condition_timeout_ms)
}

// optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];
inline bool GetTriggerScriptsResponseProto::_internal_has_trigger_condition_check_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetTriggerScriptsResponseProto::has_trigger_condition_check_interval_ms() const {
  return _internal_has_trigger_condition_check_interval_ms();
}
inline void GetTriggerScriptsResponseProto::clear_trigger_condition_check_interval_ms() {
  trigger_condition_check_interval_ms_ = 1000;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t GetTriggerScriptsResponseProto::_internal_trigger_condition_check_interval_ms() const {
  return trigger_condition_check_interval_ms_;
}
inline int32_t GetTriggerScriptsResponseProto::trigger_condition_check_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsResponseProto.trigger_condition_check_interval_ms)
  return _internal_trigger_condition_check_interval_ms();
}
inline void GetTriggerScriptsResponseProto::_internal_set_trigger_condition_check_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  trigger_condition_check_interval_ms_ = value;
}
inline void GetTriggerScriptsResponseProto::set_trigger_condition_check_interval_ms(int32_t value) {
  _internal_set_trigger_condition_check_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetTriggerScriptsResponseProto.trigger_condition_check_interval_ms)
}

// repeated .autofill_assistant.ScriptParameterProto script_parameters = 5;
inline int GetTriggerScriptsResponseProto::_internal_script_parameters_size() const {
  return script_parameters_.size();
}
inline int GetTriggerScriptsResponseProto::script_parameters_size() const {
  return _internal_script_parameters_size();
}
inline void GetTriggerScriptsResponseProto::clear_script_parameters() {
  script_parameters_.Clear();
}
inline ::autofill_assistant::ScriptParameterProto* GetTriggerScriptsResponseProto::mutable_script_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetTriggerScriptsResponseProto.script_parameters)
  return script_parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >*
GetTriggerScriptsResponseProto::mutable_script_parameters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetTriggerScriptsResponseProto.script_parameters)
  return &script_parameters_;
}
inline const ::autofill_assistant::ScriptParameterProto& GetTriggerScriptsResponseProto::_internal_script_parameters(int index) const {
  return script_parameters_.Get(index);
}
inline const ::autofill_assistant::ScriptParameterProto& GetTriggerScriptsResponseProto::script_parameters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetTriggerScriptsResponseProto.script_parameters)
  return _internal_script_parameters(index);
}
inline ::autofill_assistant::ScriptParameterProto* GetTriggerScriptsResponseProto::_internal_add_script_parameters() {
  return script_parameters_.Add();
}
inline ::autofill_assistant::ScriptParameterProto* GetTriggerScriptsResponseProto::add_script_parameters() {
  ::autofill_assistant::ScriptParameterProto* _add = _internal_add_script_parameters();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetTriggerScriptsResponseProto.script_parameters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ScriptParameterProto >&
GetTriggerScriptsResponseProto::script_parameters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetTriggerScriptsResponseProto.script_parameters)
  return script_parameters_;
}

// -------------------------------------------------------------------

// TriggerScriptProto

// optional .autofill_assistant.TriggerScriptConditionProto trigger_condition = 1;
inline bool TriggerScriptProto::_internal_has_trigger_condition() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || trigger_condition_ != nullptr);
  return value;
}
inline bool TriggerScriptProto::has_trigger_condition() const {
  return _internal_has_trigger_condition();
}
inline void TriggerScriptProto::clear_trigger_condition() {
  if (trigger_condition_ != nullptr) trigger_condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::TriggerScriptConditionProto& TriggerScriptProto::_internal_trigger_condition() const {
  const ::autofill_assistant::TriggerScriptConditionProto* p = trigger_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TriggerScriptConditionProto&>(
      ::autofill_assistant::_TriggerScriptConditionProto_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptConditionProto& TriggerScriptProto::trigger_condition() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptProto.trigger_condition)
  return _internal_trigger_condition();
}
inline void TriggerScriptProto::unsafe_arena_set_allocated_trigger_condition(
    ::autofill_assistant::TriggerScriptConditionProto* trigger_condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_condition_);
  }
  trigger_condition_ = trigger_condition;
  if (trigger_condition) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptProto.trigger_condition)
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptProto::release_trigger_condition() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::TriggerScriptConditionProto* temp = trigger_condition_;
  trigger_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptProto::unsafe_arena_release_trigger_condition() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptProto.trigger_condition)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::TriggerScriptConditionProto* temp = trigger_condition_;
  trigger_condition_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptProto::_internal_mutable_trigger_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (trigger_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TriggerScriptConditionProto>(GetArenaForAllocation());
    trigger_condition_ = p;
  }
  return trigger_condition_;
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptProto::mutable_trigger_condition() {
  ::autofill_assistant::TriggerScriptConditionProto* _msg = _internal_mutable_trigger_condition();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptProto.trigger_condition)
  return _msg;
}
inline void TriggerScriptProto::set_allocated_trigger_condition(::autofill_assistant::TriggerScriptConditionProto* trigger_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trigger_condition_;
  }
  if (trigger_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trigger_condition);
    if (message_arena != submessage_arena) {
      trigger_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger_condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trigger_condition_ = trigger_condition;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptProto.trigger_condition)
}

// optional .autofill_assistant.TriggerScriptUIProto user_interface = 3;
inline bool TriggerScriptProto::_internal_has_user_interface() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || user_interface_ != nullptr);
  return value;
}
inline bool TriggerScriptProto::has_user_interface() const {
  return _internal_has_user_interface();
}
inline void TriggerScriptProto::clear_user_interface() {
  if (user_interface_ != nullptr) user_interface_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::TriggerScriptUIProto& TriggerScriptProto::_internal_user_interface() const {
  const ::autofill_assistant::TriggerScriptUIProto* p = user_interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TriggerScriptUIProto&>(
      ::autofill_assistant::_TriggerScriptUIProto_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptUIProto& TriggerScriptProto::user_interface() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptProto.user_interface)
  return _internal_user_interface();
}
inline void TriggerScriptProto::unsafe_arena_set_allocated_user_interface(
    ::autofill_assistant::TriggerScriptUIProto* user_interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_interface_);
  }
  user_interface_ = user_interface;
  if (user_interface) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptProto.user_interface)
}
inline ::autofill_assistant::TriggerScriptUIProto* TriggerScriptProto::release_user_interface() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TriggerScriptUIProto* temp = user_interface_;
  user_interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TriggerScriptUIProto* TriggerScriptProto::unsafe_arena_release_user_interface() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptProto.user_interface)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TriggerScriptUIProto* temp = user_interface_;
  user_interface_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TriggerScriptUIProto* TriggerScriptProto::_internal_mutable_user_interface() {
  _has_bits_[0] |= 0x00000002u;
  if (user_interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto>(GetArenaForAllocation());
    user_interface_ = p;
  }
  return user_interface_;
}
inline ::autofill_assistant::TriggerScriptUIProto* TriggerScriptProto::mutable_user_interface() {
  ::autofill_assistant::TriggerScriptUIProto* _msg = _internal_mutable_user_interface();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptProto.user_interface)
  return _msg;
}
inline void TriggerScriptProto::set_allocated_user_interface(::autofill_assistant::TriggerScriptUIProto* user_interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_interface_;
  }
  if (user_interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_interface);
    if (message_arena != submessage_arena) {
      user_interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_interface, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_interface_ = user_interface;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptProto.user_interface)
}

// optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction on_swipe_to_dismiss = 4 [default = CANCEL_SESSION];
inline bool TriggerScriptProto::_internal_has_on_swipe_to_dismiss() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TriggerScriptProto::has_on_swipe_to_dismiss() const {
  return _internal_has_on_swipe_to_dismiss();
}
inline void TriggerScriptProto::clear_on_swipe_to_dismiss() {
  on_swipe_to_dismiss_ = 2;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::TriggerScriptProto_TriggerScriptAction TriggerScriptProto::_internal_on_swipe_to_dismiss() const {
  return static_cast< ::autofill_assistant::TriggerScriptProto_TriggerScriptAction >(on_swipe_to_dismiss_);
}
inline ::autofill_assistant::TriggerScriptProto_TriggerScriptAction TriggerScriptProto::on_swipe_to_dismiss() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptProto.on_swipe_to_dismiss)
  return _internal_on_swipe_to_dismiss();
}
inline void TriggerScriptProto::_internal_set_on_swipe_to_dismiss(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value) {
  assert(::autofill_assistant::TriggerScriptProto_TriggerScriptAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  on_swipe_to_dismiss_ = value;
}
inline void TriggerScriptProto::set_on_swipe_to_dismiss(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value) {
  _internal_set_on_swipe_to_dismiss(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptProto.on_swipe_to_dismiss)
}

// optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 7;
inline bool TriggerScriptProto::_internal_has_trigger_ui_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TriggerScriptProto::has_trigger_ui_type() const {
  return _internal_has_trigger_ui_type();
}
inline void TriggerScriptProto::clear_trigger_ui_type() {
  trigger_ui_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::TriggerScriptProto_TriggerUIType TriggerScriptProto::_internal_trigger_ui_type() const {
  return static_cast< ::autofill_assistant::TriggerScriptProto_TriggerUIType >(trigger_ui_type_);
}
inline ::autofill_assistant::TriggerScriptProto_TriggerUIType TriggerScriptProto::trigger_ui_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptProto.trigger_ui_type)
  return _internal_trigger_ui_type();
}
inline void TriggerScriptProto::_internal_set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value) {
  assert(::autofill_assistant::TriggerScriptProto_TriggerUIType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  trigger_ui_type_ = value;
}
inline void TriggerScriptProto::set_trigger_ui_type(::autofill_assistant::TriggerScriptProto_TriggerUIType value) {
  _internal_set_trigger_ui_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptProto.trigger_ui_type)
}

// -------------------------------------------------------------------

// TriggerScriptConditionProto_DocumentReadyStateCondition

// optional .autofill_assistant.DocumentReadyState min_document_ready_state = 1;
inline bool TriggerScriptConditionProto_DocumentReadyStateCondition::_internal_has_min_document_ready_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerScriptConditionProto_DocumentReadyStateCondition::has_min_document_ready_state() const {
  return _internal_has_min_document_ready_state();
}
inline void TriggerScriptConditionProto_DocumentReadyStateCondition::clear_min_document_ready_state() {
  min_document_ready_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::DocumentReadyState TriggerScriptConditionProto_DocumentReadyStateCondition::_internal_min_document_ready_state() const {
  return static_cast< ::autofill_assistant::DocumentReadyState >(min_document_ready_state_);
}
inline ::autofill_assistant::DocumentReadyState TriggerScriptConditionProto_DocumentReadyStateCondition::min_document_ready_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.min_document_ready_state)
  return _internal_min_document_ready_state();
}
inline void TriggerScriptConditionProto_DocumentReadyStateCondition::_internal_set_min_document_ready_state(::autofill_assistant::DocumentReadyState value) {
  assert(::autofill_assistant::DocumentReadyState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  min_document_ready_state_ = value;
}
inline void TriggerScriptConditionProto_DocumentReadyStateCondition::set_min_document_ready_state(::autofill_assistant::DocumentReadyState value) {
  _internal_set_min_document_ready_state(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.min_document_ready_state)
}

// optional .autofill_assistant.SelectorProto frame = 2;
inline bool TriggerScriptConditionProto_DocumentReadyStateCondition::_internal_has_frame() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || frame_ != nullptr);
  return value;
}
inline bool TriggerScriptConditionProto_DocumentReadyStateCondition::has_frame() const {
  return _internal_has_frame();
}
inline void TriggerScriptConditionProto_DocumentReadyStateCondition::clear_frame() {
  if (frame_ != nullptr) frame_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& TriggerScriptConditionProto_DocumentReadyStateCondition::_internal_frame() const {
  const ::autofill_assistant::SelectorProto* p = frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& TriggerScriptConditionProto_DocumentReadyStateCondition::frame() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.frame)
  return _internal_frame();
}
inline void TriggerScriptConditionProto_DocumentReadyStateCondition::unsafe_arena_set_allocated_frame(
    ::autofill_assistant::SelectorProto* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.frame)
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto_DocumentReadyStateCondition::release_frame() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = frame_;
  frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto_DocumentReadyStateCondition::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.frame)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto_DocumentReadyStateCondition::_internal_mutable_frame() {
  _has_bits_[0] |= 0x00000001u;
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    frame_ = p;
  }
  return frame_;
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto_DocumentReadyStateCondition::mutable_frame() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.frame)
  return _msg;
}
inline void TriggerScriptConditionProto_DocumentReadyStateCondition::set_allocated_frame(::autofill_assistant::SelectorProto* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition.frame)
}

// -------------------------------------------------------------------

// TriggerScriptConditionProto

// .autofill_assistant.TriggerScriptConditionsProto all_of = 1;
inline bool TriggerScriptConditionProto::_internal_has_all_of() const {
  return type_case() == kAllOf;
}
inline bool TriggerScriptConditionProto::has_all_of() const {
  return _internal_has_all_of();
}
inline void TriggerScriptConditionProto::set_has_all_of() {
  _oneof_case_[0] = kAllOf;
}
inline void TriggerScriptConditionProto::clear_all_of() {
  if (_internal_has_all_of()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.all_of_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::release_all_of() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.all_of)
  if (_internal_has_all_of()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionsProto* temp = type_.all_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.all_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TriggerScriptConditionsProto& TriggerScriptConditionProto::_internal_all_of() const {
  return _internal_has_all_of()
      ? *type_.all_of_
      : reinterpret_cast< ::autofill_assistant::TriggerScriptConditionsProto&>(::autofill_assistant::_TriggerScriptConditionsProto_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptConditionsProto& TriggerScriptConditionProto::all_of() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.all_of)
  return _internal_all_of();
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::unsafe_arena_release_all_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.all_of)
  if (_internal_has_all_of()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionsProto* temp = type_.all_of_;
    type_.all_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_all_of(::autofill_assistant::TriggerScriptConditionsProto* all_of) {
  clear_type();
  if (all_of) {
    set_has_all_of();
    type_.all_of_ = all_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.all_of)
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::_internal_mutable_all_of() {
  if (!_internal_has_all_of()) {
    clear_type();
    set_has_all_of();
    type_.all_of_ = CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionsProto >(GetArenaForAllocation());
  }
  return type_.all_of_;
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::mutable_all_of() {
  ::autofill_assistant::TriggerScriptConditionsProto* _msg = _internal_mutable_all_of();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.all_of)
  return _msg;
}

// .autofill_assistant.TriggerScriptConditionsProto any_of = 2;
inline bool TriggerScriptConditionProto::_internal_has_any_of() const {
  return type_case() == kAnyOf;
}
inline bool TriggerScriptConditionProto::has_any_of() const {
  return _internal_has_any_of();
}
inline void TriggerScriptConditionProto::set_has_any_of() {
  _oneof_case_[0] = kAnyOf;
}
inline void TriggerScriptConditionProto::clear_any_of() {
  if (_internal_has_any_of()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.any_of_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::release_any_of() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.any_of)
  if (_internal_has_any_of()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionsProto* temp = type_.any_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.any_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TriggerScriptConditionsProto& TriggerScriptConditionProto::_internal_any_of() const {
  return _internal_has_any_of()
      ? *type_.any_of_
      : reinterpret_cast< ::autofill_assistant::TriggerScriptConditionsProto&>(::autofill_assistant::_TriggerScriptConditionsProto_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptConditionsProto& TriggerScriptConditionProto::any_of() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.any_of)
  return _internal_any_of();
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::unsafe_arena_release_any_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.any_of)
  if (_internal_has_any_of()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionsProto* temp = type_.any_of_;
    type_.any_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_any_of(::autofill_assistant::TriggerScriptConditionsProto* any_of) {
  clear_type();
  if (any_of) {
    set_has_any_of();
    type_.any_of_ = any_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.any_of)
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::_internal_mutable_any_of() {
  if (!_internal_has_any_of()) {
    clear_type();
    set_has_any_of();
    type_.any_of_ = CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionsProto >(GetArenaForAllocation());
  }
  return type_.any_of_;
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::mutable_any_of() {
  ::autofill_assistant::TriggerScriptConditionsProto* _msg = _internal_mutable_any_of();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.any_of)
  return _msg;
}

// .autofill_assistant.TriggerScriptConditionsProto none_of = 3;
inline bool TriggerScriptConditionProto::_internal_has_none_of() const {
  return type_case() == kNoneOf;
}
inline bool TriggerScriptConditionProto::has_none_of() const {
  return _internal_has_none_of();
}
inline void TriggerScriptConditionProto::set_has_none_of() {
  _oneof_case_[0] = kNoneOf;
}
inline void TriggerScriptConditionProto::clear_none_of() {
  if (_internal_has_none_of()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.none_of_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::release_none_of() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.none_of)
  if (_internal_has_none_of()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionsProto* temp = type_.none_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.none_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TriggerScriptConditionsProto& TriggerScriptConditionProto::_internal_none_of() const {
  return _internal_has_none_of()
      ? *type_.none_of_
      : reinterpret_cast< ::autofill_assistant::TriggerScriptConditionsProto&>(::autofill_assistant::_TriggerScriptConditionsProto_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptConditionsProto& TriggerScriptConditionProto::none_of() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.none_of)
  return _internal_none_of();
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::unsafe_arena_release_none_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.none_of)
  if (_internal_has_none_of()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionsProto* temp = type_.none_of_;
    type_.none_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_none_of(::autofill_assistant::TriggerScriptConditionsProto* none_of) {
  clear_type();
  if (none_of) {
    set_has_none_of();
    type_.none_of_ = none_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.none_of)
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::_internal_mutable_none_of() {
  if (!_internal_has_none_of()) {
    clear_type();
    set_has_none_of();
    type_.none_of_ = CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionsProto >(GetArenaForAllocation());
  }
  return type_.none_of_;
}
inline ::autofill_assistant::TriggerScriptConditionsProto* TriggerScriptConditionProto::mutable_none_of() {
  ::autofill_assistant::TriggerScriptConditionsProto* _msg = _internal_mutable_none_of();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.none_of)
  return _msg;
}

// .autofill_assistant.SelectorProto selector = 8;
inline bool TriggerScriptConditionProto::_internal_has_selector() const {
  return type_case() == kSelector;
}
inline bool TriggerScriptConditionProto::has_selector() const {
  return _internal_has_selector();
}
inline void TriggerScriptConditionProto::set_has_selector() {
  _oneof_case_[0] = kSelector;
}
inline void TriggerScriptConditionProto::clear_selector() {
  if (_internal_has_selector()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.selector_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto::release_selector() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.selector)
  if (_internal_has_selector()) {
    clear_has_type();
    ::autofill_assistant::SelectorProto* temp = type_.selector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto& TriggerScriptConditionProto::_internal_selector() const {
  return _internal_has_selector()
      ? *type_.selector_
      : reinterpret_cast< ::autofill_assistant::SelectorProto&>(::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& TriggerScriptConditionProto::selector() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.selector)
  return _internal_selector();
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.selector)
  if (_internal_has_selector()) {
    clear_has_type();
    ::autofill_assistant::SelectorProto* temp = type_.selector_;
    type_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_selector(::autofill_assistant::SelectorProto* selector) {
  clear_type();
  if (selector) {
    set_has_selector();
    type_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.selector)
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto::_internal_mutable_selector() {
  if (!_internal_has_selector()) {
    clear_type();
    set_has_selector();
    type_.selector_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto >(GetArenaForAllocation());
  }
  return type_.selector_;
}
inline ::autofill_assistant::SelectorProto* TriggerScriptConditionProto::mutable_selector() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.selector)
  return _msg;
}

// .autofill_assistant.Empty stored_login_credentials = 5;
inline bool TriggerScriptConditionProto::_internal_has_stored_login_credentials() const {
  return type_case() == kStoredLoginCredentials;
}
inline bool TriggerScriptConditionProto::has_stored_login_credentials() const {
  return _internal_has_stored_login_credentials();
}
inline void TriggerScriptConditionProto::set_has_stored_login_credentials() {
  _oneof_case_[0] = kStoredLoginCredentials;
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::release_stored_login_credentials() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.stored_login_credentials)
  if (_internal_has_stored_login_credentials()) {
    clear_has_type();
    ::autofill_assistant::Empty* temp = type_.stored_login_credentials_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.stored_login_credentials_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::Empty& TriggerScriptConditionProto::_internal_stored_login_credentials() const {
  return _internal_has_stored_login_credentials()
      ? *type_.stored_login_credentials_
      : reinterpret_cast< ::autofill_assistant::Empty&>(::autofill_assistant::_Empty_default_instance_);
}
inline const ::autofill_assistant::Empty& TriggerScriptConditionProto::stored_login_credentials() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.stored_login_credentials)
  return _internal_stored_login_credentials();
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::unsafe_arena_release_stored_login_credentials() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.stored_login_credentials)
  if (_internal_has_stored_login_credentials()) {
    clear_has_type();
    ::autofill_assistant::Empty* temp = type_.stored_login_credentials_;
    type_.stored_login_credentials_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_stored_login_credentials(::autofill_assistant::Empty* stored_login_credentials) {
  clear_type();
  if (stored_login_credentials) {
    set_has_stored_login_credentials();
    type_.stored_login_credentials_ = stored_login_credentials;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.stored_login_credentials)
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::_internal_mutable_stored_login_credentials() {
  if (!_internal_has_stored_login_credentials()) {
    clear_type();
    set_has_stored_login_credentials();
    type_.stored_login_credentials_ = CreateMaybeMessage< ::autofill_assistant::Empty >(GetArenaForAllocation());
  }
  return type_.stored_login_credentials_;
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::mutable_stored_login_credentials() {
  ::autofill_assistant::Empty* _msg = _internal_mutable_stored_login_credentials();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.stored_login_credentials)
  return _msg;
}

// .autofill_assistant.Empty is_first_time_user = 6;
inline bool TriggerScriptConditionProto::_internal_has_is_first_time_user() const {
  return type_case() == kIsFirstTimeUser;
}
inline bool TriggerScriptConditionProto::has_is_first_time_user() const {
  return _internal_has_is_first_time_user();
}
inline void TriggerScriptConditionProto::set_has_is_first_time_user() {
  _oneof_case_[0] = kIsFirstTimeUser;
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::release_is_first_time_user() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.is_first_time_user)
  if (_internal_has_is_first_time_user()) {
    clear_has_type();
    ::autofill_assistant::Empty* temp = type_.is_first_time_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.is_first_time_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::Empty& TriggerScriptConditionProto::_internal_is_first_time_user() const {
  return _internal_has_is_first_time_user()
      ? *type_.is_first_time_user_
      : reinterpret_cast< ::autofill_assistant::Empty&>(::autofill_assistant::_Empty_default_instance_);
}
inline const ::autofill_assistant::Empty& TriggerScriptConditionProto::is_first_time_user() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.is_first_time_user)
  return _internal_is_first_time_user();
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::unsafe_arena_release_is_first_time_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.is_first_time_user)
  if (_internal_has_is_first_time_user()) {
    clear_has_type();
    ::autofill_assistant::Empty* temp = type_.is_first_time_user_;
    type_.is_first_time_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_is_first_time_user(::autofill_assistant::Empty* is_first_time_user) {
  clear_type();
  if (is_first_time_user) {
    set_has_is_first_time_user();
    type_.is_first_time_user_ = is_first_time_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.is_first_time_user)
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::_internal_mutable_is_first_time_user() {
  if (!_internal_has_is_first_time_user()) {
    clear_type();
    set_has_is_first_time_user();
    type_.is_first_time_user_ = CreateMaybeMessage< ::autofill_assistant::Empty >(GetArenaForAllocation());
  }
  return type_.is_first_time_user_;
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::mutable_is_first_time_user() {
  ::autofill_assistant::Empty* _msg = _internal_mutable_is_first_time_user();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.is_first_time_user)
  return _msg;
}

// int32 experiment_id = 7;
inline bool TriggerScriptConditionProto::_internal_has_experiment_id() const {
  return type_case() == kExperimentId;
}
inline bool TriggerScriptConditionProto::has_experiment_id() const {
  return _internal_has_experiment_id();
}
inline void TriggerScriptConditionProto::set_has_experiment_id() {
  _oneof_case_[0] = kExperimentId;
}
inline void TriggerScriptConditionProto::clear_experiment_id() {
  if (_internal_has_experiment_id()) {
    type_.experiment_id_ = 0;
    clear_has_type();
  }
}
inline int32_t TriggerScriptConditionProto::_internal_experiment_id() const {
  if (_internal_has_experiment_id()) {
    return type_.experiment_id_;
  }
  return 0;
}
inline void TriggerScriptConditionProto::_internal_set_experiment_id(int32_t value) {
  if (!_internal_has_experiment_id()) {
    clear_type();
    set_has_experiment_id();
  }
  type_.experiment_id_ = value;
}
inline int32_t TriggerScriptConditionProto::experiment_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.experiment_id)
  return _internal_experiment_id();
}
inline void TriggerScriptConditionProto::set_experiment_id(int32_t value) {
  _internal_set_experiment_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptConditionProto.experiment_id)
}

// .autofill_assistant.Empty keyboard_hidden = 9;
inline bool TriggerScriptConditionProto::_internal_has_keyboard_hidden() const {
  return type_case() == kKeyboardHidden;
}
inline bool TriggerScriptConditionProto::has_keyboard_hidden() const {
  return _internal_has_keyboard_hidden();
}
inline void TriggerScriptConditionProto::set_has_keyboard_hidden() {
  _oneof_case_[0] = kKeyboardHidden;
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::release_keyboard_hidden() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.keyboard_hidden)
  if (_internal_has_keyboard_hidden()) {
    clear_has_type();
    ::autofill_assistant::Empty* temp = type_.keyboard_hidden_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.keyboard_hidden_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::Empty& TriggerScriptConditionProto::_internal_keyboard_hidden() const {
  return _internal_has_keyboard_hidden()
      ? *type_.keyboard_hidden_
      : reinterpret_cast< ::autofill_assistant::Empty&>(::autofill_assistant::_Empty_default_instance_);
}
inline const ::autofill_assistant::Empty& TriggerScriptConditionProto::keyboard_hidden() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.keyboard_hidden)
  return _internal_keyboard_hidden();
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::unsafe_arena_release_keyboard_hidden() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.keyboard_hidden)
  if (_internal_has_keyboard_hidden()) {
    clear_has_type();
    ::autofill_assistant::Empty* temp = type_.keyboard_hidden_;
    type_.keyboard_hidden_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_keyboard_hidden(::autofill_assistant::Empty* keyboard_hidden) {
  clear_type();
  if (keyboard_hidden) {
    set_has_keyboard_hidden();
    type_.keyboard_hidden_ = keyboard_hidden;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.keyboard_hidden)
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::_internal_mutable_keyboard_hidden() {
  if (!_internal_has_keyboard_hidden()) {
    clear_type();
    set_has_keyboard_hidden();
    type_.keyboard_hidden_ = CreateMaybeMessage< ::autofill_assistant::Empty >(GetArenaForAllocation());
  }
  return type_.keyboard_hidden_;
}
inline ::autofill_assistant::Empty* TriggerScriptConditionProto::mutable_keyboard_hidden() {
  ::autofill_assistant::Empty* _msg = _internal_mutable_keyboard_hidden();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.keyboard_hidden)
  return _msg;
}

// .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 10;
inline bool TriggerScriptConditionProto::_internal_has_script_parameter_match() const {
  return type_case() == kScriptParameterMatch;
}
inline bool TriggerScriptConditionProto::has_script_parameter_match() const {
  return _internal_has_script_parameter_match();
}
inline void TriggerScriptConditionProto::set_has_script_parameter_match() {
  _oneof_case_[0] = kScriptParameterMatch;
}
inline void TriggerScriptConditionProto::clear_script_parameter_match() {
  if (_internal_has_script_parameter_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.script_parameter_match_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::ScriptParameterMatchProto* TriggerScriptConditionProto::release_script_parameter_match() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.script_parameter_match)
  if (_internal_has_script_parameter_match()) {
    clear_has_type();
    ::autofill_assistant::ScriptParameterMatchProto* temp = type_.script_parameter_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.script_parameter_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ScriptParameterMatchProto& TriggerScriptConditionProto::_internal_script_parameter_match() const {
  return _internal_has_script_parameter_match()
      ? *type_.script_parameter_match_
      : reinterpret_cast< ::autofill_assistant::ScriptParameterMatchProto&>(::autofill_assistant::_ScriptParameterMatchProto_default_instance_);
}
inline const ::autofill_assistant::ScriptParameterMatchProto& TriggerScriptConditionProto::script_parameter_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.script_parameter_match)
  return _internal_script_parameter_match();
}
inline ::autofill_assistant::ScriptParameterMatchProto* TriggerScriptConditionProto::unsafe_arena_release_script_parameter_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.script_parameter_match)
  if (_internal_has_script_parameter_match()) {
    clear_has_type();
    ::autofill_assistant::ScriptParameterMatchProto* temp = type_.script_parameter_match_;
    type_.script_parameter_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_script_parameter_match(::autofill_assistant::ScriptParameterMatchProto* script_parameter_match) {
  clear_type();
  if (script_parameter_match) {
    set_has_script_parameter_match();
    type_.script_parameter_match_ = script_parameter_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.script_parameter_match)
}
inline ::autofill_assistant::ScriptParameterMatchProto* TriggerScriptConditionProto::_internal_mutable_script_parameter_match() {
  if (!_internal_has_script_parameter_match()) {
    clear_type();
    set_has_script_parameter_match();
    type_.script_parameter_match_ = CreateMaybeMessage< ::autofill_assistant::ScriptParameterMatchProto >(GetArenaForAllocation());
  }
  return type_.script_parameter_match_;
}
inline ::autofill_assistant::ScriptParameterMatchProto* TriggerScriptConditionProto::mutable_script_parameter_match() {
  ::autofill_assistant::ScriptParameterMatchProto* _msg = _internal_mutable_script_parameter_match();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.script_parameter_match)
  return _msg;
}

// string path_pattern = 11;
inline bool TriggerScriptConditionProto::_internal_has_path_pattern() const {
  return type_case() == kPathPattern;
}
inline bool TriggerScriptConditionProto::has_path_pattern() const {
  return _internal_has_path_pattern();
}
inline void TriggerScriptConditionProto::set_has_path_pattern() {
  _oneof_case_[0] = kPathPattern;
}
inline void TriggerScriptConditionProto::clear_path_pattern() {
  if (_internal_has_path_pattern()) {
    type_.path_pattern_.Destroy();
    clear_has_type();
  }
}
inline const std::string& TriggerScriptConditionProto::path_pattern() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.path_pattern)
  return _internal_path_pattern();
}
template <typename ArgT0, typename... ArgT>
inline void TriggerScriptConditionProto::set_path_pattern(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_path_pattern()) {
    clear_type();
    set_has_path_pattern();
    type_.path_pattern_.InitDefault();
  }
  type_.path_pattern_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptConditionProto.path_pattern)
}
inline std::string* TriggerScriptConditionProto::mutable_path_pattern() {
  std::string* _s = _internal_mutable_path_pattern();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.path_pattern)
  return _s;
}
inline const std::string& TriggerScriptConditionProto::_internal_path_pattern() const {
  if (_internal_has_path_pattern()) {
    return type_.path_pattern_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TriggerScriptConditionProto::_internal_set_path_pattern(const std::string& value) {
  if (!_internal_has_path_pattern()) {
    clear_type();
    set_has_path_pattern();
    type_.path_pattern_.InitDefault();
  }
  type_.path_pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerScriptConditionProto::_internal_mutable_path_pattern() {
  if (!_internal_has_path_pattern()) {
    clear_type();
    set_has_path_pattern();
    type_.path_pattern_.InitDefault();
  }
  return type_.path_pattern_.Mutable(      GetArenaForAllocation());
}
inline std::string* TriggerScriptConditionProto::release_path_pattern() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.path_pattern)
  if (_internal_has_path_pattern()) {
    clear_has_type();
    return type_.path_pattern_.Release();
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::set_allocated_path_pattern(std::string* path_pattern) {
  if (has_type()) {
    clear_type();
  }
  if (path_pattern != nullptr) {
    set_has_path_pattern();
    type_.path_pattern_.InitAllocated(path_pattern, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.path_pattern)
}

// string domain_with_scheme = 12;
inline bool TriggerScriptConditionProto::_internal_has_domain_with_scheme() const {
  return type_case() == kDomainWithScheme;
}
inline bool TriggerScriptConditionProto::has_domain_with_scheme() const {
  return _internal_has_domain_with_scheme();
}
inline void TriggerScriptConditionProto::set_has_domain_with_scheme() {
  _oneof_case_[0] = kDomainWithScheme;
}
inline void TriggerScriptConditionProto::clear_domain_with_scheme() {
  if (_internal_has_domain_with_scheme()) {
    type_.domain_with_scheme_.Destroy();
    clear_has_type();
  }
}
inline const std::string& TriggerScriptConditionProto::domain_with_scheme() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.domain_with_scheme)
  return _internal_domain_with_scheme();
}
template <typename ArgT0, typename... ArgT>
inline void TriggerScriptConditionProto::set_domain_with_scheme(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_domain_with_scheme()) {
    clear_type();
    set_has_domain_with_scheme();
    type_.domain_with_scheme_.InitDefault();
  }
  type_.domain_with_scheme_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptConditionProto.domain_with_scheme)
}
inline std::string* TriggerScriptConditionProto::mutable_domain_with_scheme() {
  std::string* _s = _internal_mutable_domain_with_scheme();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.domain_with_scheme)
  return _s;
}
inline const std::string& TriggerScriptConditionProto::_internal_domain_with_scheme() const {
  if (_internal_has_domain_with_scheme()) {
    return type_.domain_with_scheme_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TriggerScriptConditionProto::_internal_set_domain_with_scheme(const std::string& value) {
  if (!_internal_has_domain_with_scheme()) {
    clear_type();
    set_has_domain_with_scheme();
    type_.domain_with_scheme_.InitDefault();
  }
  type_.domain_with_scheme_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerScriptConditionProto::_internal_mutable_domain_with_scheme() {
  if (!_internal_has_domain_with_scheme()) {
    clear_type();
    set_has_domain_with_scheme();
    type_.domain_with_scheme_.InitDefault();
  }
  return type_.domain_with_scheme_.Mutable(      GetArenaForAllocation());
}
inline std::string* TriggerScriptConditionProto::release_domain_with_scheme() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.domain_with_scheme)
  if (_internal_has_domain_with_scheme()) {
    clear_has_type();
    return type_.domain_with_scheme_.Release();
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::set_allocated_domain_with_scheme(std::string* domain_with_scheme) {
  if (has_type()) {
    clear_type();
  }
  if (domain_with_scheme != nullptr) {
    set_has_domain_with_scheme();
    type_.domain_with_scheme_.InitAllocated(domain_with_scheme, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.domain_with_scheme)
}

// .autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition document_ready_state = 13;
inline bool TriggerScriptConditionProto::_internal_has_document_ready_state() const {
  return type_case() == kDocumentReadyState;
}
inline bool TriggerScriptConditionProto::has_document_ready_state() const {
  return _internal_has_document_ready_state();
}
inline void TriggerScriptConditionProto::set_has_document_ready_state() {
  _oneof_case_[0] = kDocumentReadyState;
}
inline void TriggerScriptConditionProto::clear_document_ready_state() {
  if (_internal_has_document_ready_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.document_ready_state_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* TriggerScriptConditionProto::release_document_ready_state() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptConditionProto.document_ready_state)
  if (_internal_has_document_ready_state()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* temp = type_.document_ready_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.document_ready_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition& TriggerScriptConditionProto::_internal_document_ready_state() const {
  return _internal_has_document_ready_state()
      ? *type_.document_ready_state_
      : reinterpret_cast< ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition&>(::autofill_assistant::_TriggerScriptConditionProto_DocumentReadyStateCondition_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition& TriggerScriptConditionProto::document_ready_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionProto.document_ready_state)
  return _internal_document_ready_state();
}
inline ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* TriggerScriptConditionProto::unsafe_arena_release_document_ready_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.TriggerScriptConditionProto.document_ready_state)
  if (_internal_has_document_ready_state()) {
    clear_has_type();
    ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* temp = type_.document_ready_state_;
    type_.document_ready_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TriggerScriptConditionProto::unsafe_arena_set_allocated_document_ready_state(::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* document_ready_state) {
  clear_type();
  if (document_ready_state) {
    set_has_document_ready_state();
    type_.document_ready_state_ = document_ready_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptConditionProto.document_ready_state)
}
inline ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* TriggerScriptConditionProto::_internal_mutable_document_ready_state() {
  if (!_internal_has_document_ready_state()) {
    clear_type();
    set_has_document_ready_state();
    type_.document_ready_state_ = CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition >(GetArenaForAllocation());
  }
  return type_.document_ready_state_;
}
inline ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* TriggerScriptConditionProto::mutable_document_ready_state() {
  ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* _msg = _internal_mutable_document_ready_state();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionProto.document_ready_state)
  return _msg;
}

inline bool TriggerScriptConditionProto::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void TriggerScriptConditionProto::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline TriggerScriptConditionProto::TypeCase TriggerScriptConditionProto::type_case() const {
  return TriggerScriptConditionProto::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TriggerScriptConditionsProto

// repeated .autofill_assistant.TriggerScriptConditionProto conditions = 1;
inline int TriggerScriptConditionsProto::_internal_conditions_size() const {
  return conditions_.size();
}
inline int TriggerScriptConditionsProto::conditions_size() const {
  return _internal_conditions_size();
}
inline void TriggerScriptConditionsProto::clear_conditions() {
  conditions_.Clear();
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptConditionsProto::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptConditionsProto.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptConditionProto >*
TriggerScriptConditionsProto::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.TriggerScriptConditionsProto.conditions)
  return &conditions_;
}
inline const ::autofill_assistant::TriggerScriptConditionProto& TriggerScriptConditionsProto::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::autofill_assistant::TriggerScriptConditionProto& TriggerScriptConditionsProto::conditions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptConditionsProto.conditions)
  return _internal_conditions(index);
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptConditionsProto::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::autofill_assistant::TriggerScriptConditionProto* TriggerScriptConditionsProto::add_conditions() {
  ::autofill_assistant::TriggerScriptConditionProto* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:autofill_assistant.TriggerScriptConditionsProto.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptConditionProto >&
TriggerScriptConditionsProto::conditions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.TriggerScriptConditionsProto.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// TriggerScriptUIProto_ProgressBar

// repeated .autofill_assistant.DrawableProto step_icons = 1;
inline int TriggerScriptUIProto_ProgressBar::_internal_step_icons_size() const {
  return step_icons_.size();
}
inline int TriggerScriptUIProto_ProgressBar::step_icons_size() const {
  return _internal_step_icons_size();
}
inline ::autofill_assistant::DrawableProto* TriggerScriptUIProto_ProgressBar::mutable_step_icons(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.ProgressBar.step_icons)
  return step_icons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DrawableProto >*
TriggerScriptUIProto_ProgressBar::mutable_step_icons() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.TriggerScriptUIProto.ProgressBar.step_icons)
  return &step_icons_;
}
inline const ::autofill_assistant::DrawableProto& TriggerScriptUIProto_ProgressBar::_internal_step_icons(int index) const {
  return step_icons_.Get(index);
}
inline const ::autofill_assistant::DrawableProto& TriggerScriptUIProto_ProgressBar::step_icons(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.ProgressBar.step_icons)
  return _internal_step_icons(index);
}
inline ::autofill_assistant::DrawableProto* TriggerScriptUIProto_ProgressBar::_internal_add_step_icons() {
  return step_icons_.Add();
}
inline ::autofill_assistant::DrawableProto* TriggerScriptUIProto_ProgressBar::add_step_icons() {
  ::autofill_assistant::DrawableProto* _add = _internal_add_step_icons();
  // @@protoc_insertion_point(field_add:autofill_assistant.TriggerScriptUIProto.ProgressBar.step_icons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::DrawableProto >&
TriggerScriptUIProto_ProgressBar::step_icons() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.TriggerScriptUIProto.ProgressBar.step_icons)
  return step_icons_;
}

// optional int32 active_step = 2;
inline bool TriggerScriptUIProto_ProgressBar::_internal_has_active_step() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TriggerScriptUIProto_ProgressBar::has_active_step() const {
  return _internal_has_active_step();
}
inline void TriggerScriptUIProto_ProgressBar::clear_active_step() {
  active_step_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t TriggerScriptUIProto_ProgressBar::_internal_active_step() const {
  return active_step_;
}
inline int32_t TriggerScriptUIProto_ProgressBar::active_step() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.ProgressBar.active_step)
  return _internal_active_step();
}
inline void TriggerScriptUIProto_ProgressBar::_internal_set_active_step(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  active_step_ = value;
}
inline void TriggerScriptUIProto_ProgressBar::set_active_step(int32_t value) {
  _internal_set_active_step(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.ProgressBar.active_step)
}

// -------------------------------------------------------------------

// TriggerScriptUIProto_TriggerChip

// optional .autofill_assistant.ChipProto chip = 1;
inline bool TriggerScriptUIProto_TriggerChip::_internal_has_chip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || chip_ != nullptr);
  return value;
}
inline bool TriggerScriptUIProto_TriggerChip::has_chip() const {
  return _internal_has_chip();
}
inline const ::autofill_assistant::ChipProto& TriggerScriptUIProto_TriggerChip::_internal_chip() const {
  const ::autofill_assistant::ChipProto* p = chip_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ChipProto&>(
      ::autofill_assistant::_ChipProto_default_instance_);
}
inline const ::autofill_assistant::ChipProto& TriggerScriptUIProto_TriggerChip::chip() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.TriggerChip.chip)
  return _internal_chip();
}
inline void TriggerScriptUIProto_TriggerChip::unsafe_arena_set_allocated_chip(
    ::autofill_assistant::ChipProto* chip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  chip_ = chip;
  if (chip) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptUIProto.TriggerChip.chip)
}
inline ::autofill_assistant::ChipProto* TriggerScriptUIProto_TriggerChip::release_chip() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ChipProto* TriggerScriptUIProto_TriggerChip::unsafe_arena_release_chip() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.TriggerChip.chip)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ChipProto* TriggerScriptUIProto_TriggerChip::_internal_mutable_chip() {
  _has_bits_[0] |= 0x00000001u;
  if (chip_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ChipProto>(GetArenaForAllocation());
    chip_ = p;
  }
  return chip_;
}
inline ::autofill_assistant::ChipProto* TriggerScriptUIProto_TriggerChip::mutable_chip() {
  ::autofill_assistant::ChipProto* _msg = _internal_mutable_chip();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.TriggerChip.chip)
  return _msg;
}
inline void TriggerScriptUIProto_TriggerChip::set_allocated_chip(::autofill_assistant::ChipProto* chip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  if (chip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip));
    if (message_arena != submessage_arena) {
      chip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  chip_ = chip;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.TriggerChip.chip)
}

// optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
inline bool TriggerScriptUIProto_TriggerChip::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerScriptUIProto_TriggerChip::has_action() const {
  return _internal_has_action();
}
inline void TriggerScriptUIProto_TriggerChip::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::TriggerScriptProto_TriggerScriptAction TriggerScriptUIProto_TriggerChip::_internal_action() const {
  return static_cast< ::autofill_assistant::TriggerScriptProto_TriggerScriptAction >(action_);
}
inline ::autofill_assistant::TriggerScriptProto_TriggerScriptAction TriggerScriptUIProto_TriggerChip::action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.TriggerChip.action)
  return _internal_action();
}
inline void TriggerScriptUIProto_TriggerChip::_internal_set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value) {
  assert(::autofill_assistant::TriggerScriptProto_TriggerScriptAction_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
}
inline void TriggerScriptUIProto_TriggerChip::set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.TriggerChip.action)
}

// -------------------------------------------------------------------

// TriggerScriptUIProto_Popup_Choice

// optional string text = 1;
inline bool TriggerScriptUIProto_Popup_Choice::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TriggerScriptUIProto_Popup_Choice::has_text() const {
  return _internal_has_text();
}
inline void TriggerScriptUIProto_Popup_Choice::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TriggerScriptUIProto_Popup_Choice::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.Popup.Choice.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerScriptUIProto_Popup_Choice::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.Popup.Choice.text)
}
inline std::string* TriggerScriptUIProto_Popup_Choice::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.Popup.Choice.text)
  return _s;
}
inline const std::string& TriggerScriptUIProto_Popup_Choice::_internal_text() const {
  return text_.Get();
}
inline void TriggerScriptUIProto_Popup_Choice::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto_Popup_Choice::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto_Popup_Choice::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.Popup.Choice.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TriggerScriptUIProto_Popup_Choice::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.Popup.Choice.text)
}

// optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
inline bool TriggerScriptUIProto_Popup_Choice::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerScriptUIProto_Popup_Choice::has_action() const {
  return _internal_has_action();
}
inline void TriggerScriptUIProto_Popup_Choice::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::TriggerScriptProto_TriggerScriptAction TriggerScriptUIProto_Popup_Choice::_internal_action() const {
  return static_cast< ::autofill_assistant::TriggerScriptProto_TriggerScriptAction >(action_);
}
inline ::autofill_assistant::TriggerScriptProto_TriggerScriptAction TriggerScriptUIProto_Popup_Choice::action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.Popup.Choice.action)
  return _internal_action();
}
inline void TriggerScriptUIProto_Popup_Choice::_internal_set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value) {
  assert(::autofill_assistant::TriggerScriptProto_TriggerScriptAction_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
}
inline void TriggerScriptUIProto_Popup_Choice::set_action(::autofill_assistant::TriggerScriptProto_TriggerScriptAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.Popup.Choice.action)
}

// -------------------------------------------------------------------

// TriggerScriptUIProto_Popup

// repeated .autofill_assistant.TriggerScriptUIProto.Popup.Choice choices = 1;
inline int TriggerScriptUIProto_Popup::_internal_choices_size() const {
  return choices_.size();
}
inline int TriggerScriptUIProto_Popup::choices_size() const {
  return _internal_choices_size();
}
inline void TriggerScriptUIProto_Popup::clear_choices() {
  choices_.Clear();
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* TriggerScriptUIProto_Popup::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.Popup.choices)
  return choices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice >*
TriggerScriptUIProto_Popup::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.TriggerScriptUIProto.Popup.choices)
  return &choices_;
}
inline const ::autofill_assistant::TriggerScriptUIProto_Popup_Choice& TriggerScriptUIProto_Popup::_internal_choices(int index) const {
  return choices_.Get(index);
}
inline const ::autofill_assistant::TriggerScriptUIProto_Popup_Choice& TriggerScriptUIProto_Popup::choices(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.Popup.choices)
  return _internal_choices(index);
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* TriggerScriptUIProto_Popup::_internal_add_choices() {
  return choices_.Add();
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* TriggerScriptUIProto_Popup::add_choices() {
  ::autofill_assistant::TriggerScriptUIProto_Popup_Choice* _add = _internal_add_choices();
  // @@protoc_insertion_point(field_add:autofill_assistant.TriggerScriptUIProto.Popup.choices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice >&
TriggerScriptUIProto_Popup::choices() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.TriggerScriptUIProto.Popup.choices)
  return choices_;
}

// -------------------------------------------------------------------

// TriggerScriptUIProto

// optional string status_message = 1;
inline bool TriggerScriptUIProto::_internal_has_status_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TriggerScriptUIProto::has_status_message() const {
  return _internal_has_status_message();
}
inline void TriggerScriptUIProto::clear_status_message() {
  status_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TriggerScriptUIProto::status_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerScriptUIProto::set_status_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.status_message)
}
inline std::string* TriggerScriptUIProto::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.status_message)
  return _s;
}
inline const std::string& TriggerScriptUIProto::_internal_status_message() const {
  return status_message_.Get();
}
inline void TriggerScriptUIProto::_internal_set_status_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto::_internal_mutable_status_message() {
  _has_bits_[0] |= 0x00000001u;
  return status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto::release_status_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.status_message)
  if (!_internal_has_status_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = status_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_message_.IsDefault()) {
    status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TriggerScriptUIProto::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_message_.SetAllocated(status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_message_.IsDefault()) {
    status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.status_message)
}

// optional string callout_message = 2;
inline bool TriggerScriptUIProto::_internal_has_callout_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TriggerScriptUIProto::has_callout_message() const {
  return _internal_has_callout_message();
}
inline void TriggerScriptUIProto::clear_callout_message() {
  callout_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TriggerScriptUIProto::callout_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.callout_message)
  return _internal_callout_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerScriptUIProto::set_callout_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 callout_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.callout_message)
}
inline std::string* TriggerScriptUIProto::mutable_callout_message() {
  std::string* _s = _internal_mutable_callout_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.callout_message)
  return _s;
}
inline const std::string& TriggerScriptUIProto::_internal_callout_message() const {
  return callout_message_.Get();
}
inline void TriggerScriptUIProto::_internal_set_callout_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  callout_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto::_internal_mutable_callout_message() {
  _has_bits_[0] |= 0x00000002u;
  return callout_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto::release_callout_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.callout_message)
  if (!_internal_has_callout_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = callout_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (callout_message_.IsDefault()) {
    callout_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TriggerScriptUIProto::set_allocated_callout_message(std::string* callout_message) {
  if (callout_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  callout_message_.SetAllocated(callout_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (callout_message_.IsDefault()) {
    callout_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.callout_message)
}

// optional .autofill_assistant.TriggerScriptUIProto.ProgressBar progress_bar = 3;
inline bool TriggerScriptUIProto::_internal_has_progress_bar() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || progress_bar_ != nullptr);
  return value;
}
inline bool TriggerScriptUIProto::has_progress_bar() const {
  return _internal_has_progress_bar();
}
inline void TriggerScriptUIProto::clear_progress_bar() {
  if (progress_bar_ != nullptr) progress_bar_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::TriggerScriptUIProto_ProgressBar& TriggerScriptUIProto::_internal_progress_bar() const {
  const ::autofill_assistant::TriggerScriptUIProto_ProgressBar* p = progress_bar_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TriggerScriptUIProto_ProgressBar&>(
      ::autofill_assistant::_TriggerScriptUIProto_ProgressBar_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptUIProto_ProgressBar& TriggerScriptUIProto::progress_bar() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.progress_bar)
  return _internal_progress_bar();
}
inline void TriggerScriptUIProto::unsafe_arena_set_allocated_progress_bar(
    ::autofill_assistant::TriggerScriptUIProto_ProgressBar* progress_bar) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(progress_bar_);
  }
  progress_bar_ = progress_bar;
  if (progress_bar) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptUIProto.progress_bar)
}
inline ::autofill_assistant::TriggerScriptUIProto_ProgressBar* TriggerScriptUIProto::release_progress_bar() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* temp = progress_bar_;
  progress_bar_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TriggerScriptUIProto_ProgressBar* TriggerScriptUIProto::unsafe_arena_release_progress_bar() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.progress_bar)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* temp = progress_bar_;
  progress_bar_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TriggerScriptUIProto_ProgressBar* TriggerScriptUIProto::_internal_mutable_progress_bar() {
  _has_bits_[0] |= 0x00000008u;
  if (progress_bar_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto_ProgressBar>(GetArenaForAllocation());
    progress_bar_ = p;
  }
  return progress_bar_;
}
inline ::autofill_assistant::TriggerScriptUIProto_ProgressBar* TriggerScriptUIProto::mutable_progress_bar() {
  ::autofill_assistant::TriggerScriptUIProto_ProgressBar* _msg = _internal_mutable_progress_bar();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.progress_bar)
  return _msg;
}
inline void TriggerScriptUIProto::set_allocated_progress_bar(::autofill_assistant::TriggerScriptUIProto_ProgressBar* progress_bar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete progress_bar_;
  }
  if (progress_bar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(progress_bar);
    if (message_arena != submessage_arena) {
      progress_bar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, progress_bar, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  progress_bar_ = progress_bar;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.progress_bar)
}

// optional .autofill_assistant.TriggerScriptUIProto.Popup cancel_popup = 4;
inline bool TriggerScriptUIProto::_internal_has_cancel_popup() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || cancel_popup_ != nullptr);
  return value;
}
inline bool TriggerScriptUIProto::has_cancel_popup() const {
  return _internal_has_cancel_popup();
}
inline void TriggerScriptUIProto::clear_cancel_popup() {
  if (cancel_popup_ != nullptr) cancel_popup_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill_assistant::TriggerScriptUIProto_Popup& TriggerScriptUIProto::_internal_cancel_popup() const {
  const ::autofill_assistant::TriggerScriptUIProto_Popup* p = cancel_popup_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TriggerScriptUIProto_Popup&>(
      ::autofill_assistant::_TriggerScriptUIProto_Popup_default_instance_);
}
inline const ::autofill_assistant::TriggerScriptUIProto_Popup& TriggerScriptUIProto::cancel_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.cancel_popup)
  return _internal_cancel_popup();
}
inline void TriggerScriptUIProto::unsafe_arena_set_allocated_cancel_popup(
    ::autofill_assistant::TriggerScriptUIProto_Popup* cancel_popup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cancel_popup_);
  }
  cancel_popup_ = cancel_popup;
  if (cancel_popup) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TriggerScriptUIProto.cancel_popup)
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup* TriggerScriptUIProto::release_cancel_popup() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::TriggerScriptUIProto_Popup* temp = cancel_popup_;
  cancel_popup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup* TriggerScriptUIProto::unsafe_arena_release_cancel_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.cancel_popup)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::TriggerScriptUIProto_Popup* temp = cancel_popup_;
  cancel_popup_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup* TriggerScriptUIProto::_internal_mutable_cancel_popup() {
  _has_bits_[0] |= 0x00000010u;
  if (cancel_popup_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TriggerScriptUIProto_Popup>(GetArenaForAllocation());
    cancel_popup_ = p;
  }
  return cancel_popup_;
}
inline ::autofill_assistant::TriggerScriptUIProto_Popup* TriggerScriptUIProto::mutable_cancel_popup() {
  ::autofill_assistant::TriggerScriptUIProto_Popup* _msg = _internal_mutable_cancel_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.cancel_popup)
  return _msg;
}
inline void TriggerScriptUIProto::set_allocated_cancel_popup(::autofill_assistant::TriggerScriptUIProto_Popup* cancel_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cancel_popup_;
  }
  if (cancel_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cancel_popup);
    if (message_arena != submessage_arena) {
      cancel_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cancel_popup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  cancel_popup_ = cancel_popup;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.cancel_popup)
}

// repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip left_aligned_chips = 5;
inline int TriggerScriptUIProto::_internal_left_aligned_chips_size() const {
  return left_aligned_chips_.size();
}
inline int TriggerScriptUIProto::left_aligned_chips_size() const {
  return _internal_left_aligned_chips_size();
}
inline void TriggerScriptUIProto::clear_left_aligned_chips() {
  left_aligned_chips_.Clear();
}
inline ::autofill_assistant::TriggerScriptUIProto_TriggerChip* TriggerScriptUIProto::mutable_left_aligned_chips(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.left_aligned_chips)
  return left_aligned_chips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >*
TriggerScriptUIProto::mutable_left_aligned_chips() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.TriggerScriptUIProto.left_aligned_chips)
  return &left_aligned_chips_;
}
inline const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& TriggerScriptUIProto::_internal_left_aligned_chips(int index) const {
  return left_aligned_chips_.Get(index);
}
inline const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& TriggerScriptUIProto::left_aligned_chips(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.left_aligned_chips)
  return _internal_left_aligned_chips(index);
}
inline ::autofill_assistant::TriggerScriptUIProto_TriggerChip* TriggerScriptUIProto::_internal_add_left_aligned_chips() {
  return left_aligned_chips_.Add();
}
inline ::autofill_assistant::TriggerScriptUIProto_TriggerChip* TriggerScriptUIProto::add_left_aligned_chips() {
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* _add = _internal_add_left_aligned_chips();
  // @@protoc_insertion_point(field_add:autofill_assistant.TriggerScriptUIProto.left_aligned_chips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >&
TriggerScriptUIProto::left_aligned_chips() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.TriggerScriptUIProto.left_aligned_chips)
  return left_aligned_chips_;
}

// repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip right_aligned_chips = 6;
inline int TriggerScriptUIProto::_internal_right_aligned_chips_size() const {
  return right_aligned_chips_.size();
}
inline int TriggerScriptUIProto::right_aligned_chips_size() const {
  return _internal_right_aligned_chips_size();
}
inline void TriggerScriptUIProto::clear_right_aligned_chips() {
  right_aligned_chips_.Clear();
}
inline ::autofill_assistant::TriggerScriptUIProto_TriggerChip* TriggerScriptUIProto::mutable_right_aligned_chips(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.right_aligned_chips)
  return right_aligned_chips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >*
TriggerScriptUIProto::mutable_right_aligned_chips() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.TriggerScriptUIProto.right_aligned_chips)
  return &right_aligned_chips_;
}
inline const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& TriggerScriptUIProto::_internal_right_aligned_chips(int index) const {
  return right_aligned_chips_.Get(index);
}
inline const ::autofill_assistant::TriggerScriptUIProto_TriggerChip& TriggerScriptUIProto::right_aligned_chips(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.right_aligned_chips)
  return _internal_right_aligned_chips(index);
}
inline ::autofill_assistant::TriggerScriptUIProto_TriggerChip* TriggerScriptUIProto::_internal_add_right_aligned_chips() {
  return right_aligned_chips_.Add();
}
inline ::autofill_assistant::TriggerScriptUIProto_TriggerChip* TriggerScriptUIProto::add_right_aligned_chips() {
  ::autofill_assistant::TriggerScriptUIProto_TriggerChip* _add = _internal_add_right_aligned_chips();
  // @@protoc_insertion_point(field_add:autofill_assistant.TriggerScriptUIProto.right_aligned_chips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >&
TriggerScriptUIProto::right_aligned_chips() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.TriggerScriptUIProto.right_aligned_chips)
  return right_aligned_chips_;
}

// optional string regular_script_loading_status_message = 7;
inline bool TriggerScriptUIProto::_internal_has_regular_script_loading_status_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TriggerScriptUIProto::has_regular_script_loading_status_message() const {
  return _internal_has_regular_script_loading_status_message();
}
inline void TriggerScriptUIProto::clear_regular_script_loading_status_message() {
  regular_script_loading_status_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TriggerScriptUIProto::regular_script_loading_status_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.regular_script_loading_status_message)
  return _internal_regular_script_loading_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TriggerScriptUIProto::set_regular_script_loading_status_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 regular_script_loading_status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.regular_script_loading_status_message)
}
inline std::string* TriggerScriptUIProto::mutable_regular_script_loading_status_message() {
  std::string* _s = _internal_mutable_regular_script_loading_status_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TriggerScriptUIProto.regular_script_loading_status_message)
  return _s;
}
inline const std::string& TriggerScriptUIProto::_internal_regular_script_loading_status_message() const {
  return regular_script_loading_status_message_.Get();
}
inline void TriggerScriptUIProto::_internal_set_regular_script_loading_status_message(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  regular_script_loading_status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto::_internal_mutable_regular_script_loading_status_message() {
  _has_bits_[0] |= 0x00000004u;
  return regular_script_loading_status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TriggerScriptUIProto::release_regular_script_loading_status_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TriggerScriptUIProto.regular_script_loading_status_message)
  if (!_internal_has_regular_script_loading_status_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = regular_script_loading_status_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regular_script_loading_status_message_.IsDefault()) {
    regular_script_loading_status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TriggerScriptUIProto::set_allocated_regular_script_loading_status_message(std::string* regular_script_loading_status_message) {
  if (regular_script_loading_status_message != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  regular_script_loading_status_message_.SetAllocated(regular_script_loading_status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regular_script_loading_status_message_.IsDefault()) {
    regular_script_loading_status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptUIProto.regular_script_loading_status_message)
}

// optional bool resize_visual_viewport = 8;
inline bool TriggerScriptUIProto::_internal_has_resize_visual_viewport() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TriggerScriptUIProto::has_resize_visual_viewport() const {
  return _internal_has_resize_visual_viewport();
}
inline void TriggerScriptUIProto::clear_resize_visual_viewport() {
  resize_visual_viewport_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool TriggerScriptUIProto::_internal_resize_visual_viewport() const {
  return resize_visual_viewport_;
}
inline bool TriggerScriptUIProto::resize_visual_viewport() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.resize_visual_viewport)
  return _internal_resize_visual_viewport();
}
inline void TriggerScriptUIProto::_internal_set_resize_visual_viewport(bool value) {
  _has_bits_[0] |= 0x00000020u;
  resize_visual_viewport_ = value;
}
inline void TriggerScriptUIProto::set_resize_visual_viewport(bool value) {
  _internal_set_resize_visual_viewport(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.resize_visual_viewport)
}

// optional bool scroll_to_hide = 9;
inline bool TriggerScriptUIProto::_internal_has_scroll_to_hide() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TriggerScriptUIProto::has_scroll_to_hide() const {
  return _internal_has_scroll_to_hide();
}
inline void TriggerScriptUIProto::clear_scroll_to_hide() {
  scroll_to_hide_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool TriggerScriptUIProto::_internal_scroll_to_hide() const {
  return scroll_to_hide_;
}
inline bool TriggerScriptUIProto::scroll_to_hide() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.scroll_to_hide)
  return _internal_scroll_to_hide();
}
inline void TriggerScriptUIProto::_internal_set_scroll_to_hide(bool value) {
  _has_bits_[0] |= 0x00000040u;
  scroll_to_hide_ = value;
}
inline void TriggerScriptUIProto::set_scroll_to_hide(bool value) {
  _internal_set_scroll_to_hide(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.scroll_to_hide)
}

// optional int32 ui_timeout_ms = 10;
inline bool TriggerScriptUIProto::_internal_has_ui_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TriggerScriptUIProto::has_ui_timeout_ms() const {
  return _internal_has_ui_timeout_ms();
}
inline void TriggerScriptUIProto::clear_ui_timeout_ms() {
  ui_timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t TriggerScriptUIProto::_internal_ui_timeout_ms() const {
  return ui_timeout_ms_;
}
inline int32_t TriggerScriptUIProto::ui_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TriggerScriptUIProto.ui_timeout_ms)
  return _internal_ui_timeout_ms();
}
inline void TriggerScriptUIProto::_internal_set_ui_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  ui_timeout_ms_ = value;
}
inline void TriggerScriptUIProto::set_ui_timeout_ms(int32_t value) {
  _internal_set_ui_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TriggerScriptUIProto.ui_timeout_ms)
}

// -------------------------------------------------------------------

// ActionProto

// optional int32 action_delay_ms = 3;
inline bool ActionProto::_internal_has_action_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionProto::has_action_delay_ms() const {
  return _internal_has_action_delay_ms();
}
inline void ActionProto::clear_action_delay_ms() {
  action_delay_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ActionProto::_internal_action_delay_ms() const {
  return action_delay_ms_;
}
inline int32_t ActionProto::action_delay_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.action_delay_ms)
  return _internal_action_delay_ms();
}
inline void ActionProto::_internal_set_action_delay_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  action_delay_ms_ = value;
}
inline void ActionProto::set_action_delay_ms(int32_t value) {
  _internal_set_action_delay_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionProto.action_delay_ms)
}

// optional bytes server_payload = 4;
inline bool ActionProto::_internal_has_server_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionProto::has_server_payload() const {
  return _internal_has_server_payload();
}
inline void ActionProto::clear_server_payload() {
  server_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionProto::server_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.server_payload)
  return _internal_server_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionProto::set_server_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionProto.server_payload)
}
inline std::string* ActionProto::mutable_server_payload() {
  std::string* _s = _internal_mutable_server_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.server_payload)
  return _s;
}
inline const std::string& ActionProto::_internal_server_payload() const {
  return server_payload_.Get();
}
inline void ActionProto::_internal_set_server_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionProto::_internal_mutable_server_payload() {
  _has_bits_[0] |= 0x00000001u;
  return server_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionProto::release_server_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.server_payload)
  if (!_internal_has_server_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_payload_.IsDefault()) {
    server_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ActionProto::set_allocated_server_payload(std::string* server_payload) {
  if (server_payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_payload_.SetAllocated(server_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_payload_.IsDefault()) {
    server_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.server_payload)
}

// .autofill_assistant.SelectOptionProto select_option = 7;
inline bool ActionProto::_internal_has_select_option() const {
  return action_info_case() == kSelectOption;
}
inline bool ActionProto::has_select_option() const {
  return _internal_has_select_option();
}
inline void ActionProto::set_has_select_option() {
  _oneof_case_[0] = kSelectOption;
}
inline void ActionProto::clear_select_option() {
  if (_internal_has_select_option()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.select_option_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::SelectOptionProto* ActionProto::release_select_option() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.select_option)
  if (_internal_has_select_option()) {
    clear_has_action_info();
    ::autofill_assistant::SelectOptionProto* temp = action_info_.select_option_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.select_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectOptionProto& ActionProto::_internal_select_option() const {
  return _internal_has_select_option()
      ? *action_info_.select_option_
      : reinterpret_cast< ::autofill_assistant::SelectOptionProto&>(::autofill_assistant::_SelectOptionProto_default_instance_);
}
inline const ::autofill_assistant::SelectOptionProto& ActionProto::select_option() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.select_option)
  return _internal_select_option();
}
inline ::autofill_assistant::SelectOptionProto* ActionProto::unsafe_arena_release_select_option() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.select_option)
  if (_internal_has_select_option()) {
    clear_has_action_info();
    ::autofill_assistant::SelectOptionProto* temp = action_info_.select_option_;
    action_info_.select_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_select_option(::autofill_assistant::SelectOptionProto* select_option) {
  clear_action_info();
  if (select_option) {
    set_has_select_option();
    action_info_.select_option_ = select_option;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.select_option)
}
inline ::autofill_assistant::SelectOptionProto* ActionProto::_internal_mutable_select_option() {
  if (!_internal_has_select_option()) {
    clear_action_info();
    set_has_select_option();
    action_info_.select_option_ = CreateMaybeMessage< ::autofill_assistant::SelectOptionProto >(GetArenaForAllocation());
  }
  return action_info_.select_option_;
}
inline ::autofill_assistant::SelectOptionProto* ActionProto::mutable_select_option() {
  ::autofill_assistant::SelectOptionProto* _msg = _internal_mutable_select_option();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.select_option)
  return _msg;
}

// .autofill_assistant.NavigateProto navigate = 9;
inline bool ActionProto::_internal_has_navigate() const {
  return action_info_case() == kNavigate;
}
inline bool ActionProto::has_navigate() const {
  return _internal_has_navigate();
}
inline void ActionProto::set_has_navigate() {
  _oneof_case_[0] = kNavigate;
}
inline void ActionProto::clear_navigate() {
  if (_internal_has_navigate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.navigate_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::NavigateProto* ActionProto::release_navigate() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.navigate)
  if (_internal_has_navigate()) {
    clear_has_action_info();
    ::autofill_assistant::NavigateProto* temp = action_info_.navigate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.navigate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::NavigateProto& ActionProto::_internal_navigate() const {
  return _internal_has_navigate()
      ? *action_info_.navigate_
      : reinterpret_cast< ::autofill_assistant::NavigateProto&>(::autofill_assistant::_NavigateProto_default_instance_);
}
inline const ::autofill_assistant::NavigateProto& ActionProto::navigate() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.navigate)
  return _internal_navigate();
}
inline ::autofill_assistant::NavigateProto* ActionProto::unsafe_arena_release_navigate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.navigate)
  if (_internal_has_navigate()) {
    clear_has_action_info();
    ::autofill_assistant::NavigateProto* temp = action_info_.navigate_;
    action_info_.navigate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_navigate(::autofill_assistant::NavigateProto* navigate) {
  clear_action_info();
  if (navigate) {
    set_has_navigate();
    action_info_.navigate_ = navigate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.navigate)
}
inline ::autofill_assistant::NavigateProto* ActionProto::_internal_mutable_navigate() {
  if (!_internal_has_navigate()) {
    clear_action_info();
    set_has_navigate();
    action_info_.navigate_ = CreateMaybeMessage< ::autofill_assistant::NavigateProto >(GetArenaForAllocation());
  }
  return action_info_.navigate_;
}
inline ::autofill_assistant::NavigateProto* ActionProto::mutable_navigate() {
  ::autofill_assistant::NavigateProto* _msg = _internal_mutable_navigate();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.navigate)
  return _msg;
}

// .autofill_assistant.PromptProto prompt = 10;
inline bool ActionProto::_internal_has_prompt() const {
  return action_info_case() == kPrompt;
}
inline bool ActionProto::has_prompt() const {
  return _internal_has_prompt();
}
inline void ActionProto::set_has_prompt() {
  _oneof_case_[0] = kPrompt;
}
inline void ActionProto::clear_prompt() {
  if (_internal_has_prompt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.prompt_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::PromptProto* ActionProto::release_prompt() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.prompt)
  if (_internal_has_prompt()) {
    clear_has_action_info();
    ::autofill_assistant::PromptProto* temp = action_info_.prompt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.prompt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PromptProto& ActionProto::_internal_prompt() const {
  return _internal_has_prompt()
      ? *action_info_.prompt_
      : reinterpret_cast< ::autofill_assistant::PromptProto&>(::autofill_assistant::_PromptProto_default_instance_);
}
inline const ::autofill_assistant::PromptProto& ActionProto::prompt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.prompt)
  return _internal_prompt();
}
inline ::autofill_assistant::PromptProto* ActionProto::unsafe_arena_release_prompt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.prompt)
  if (_internal_has_prompt()) {
    clear_has_action_info();
    ::autofill_assistant::PromptProto* temp = action_info_.prompt_;
    action_info_.prompt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_prompt(::autofill_assistant::PromptProto* prompt) {
  clear_action_info();
  if (prompt) {
    set_has_prompt();
    action_info_.prompt_ = prompt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.prompt)
}
inline ::autofill_assistant::PromptProto* ActionProto::_internal_mutable_prompt() {
  if (!_internal_has_prompt()) {
    clear_action_info();
    set_has_prompt();
    action_info_.prompt_ = CreateMaybeMessage< ::autofill_assistant::PromptProto >(GetArenaForAllocation());
  }
  return action_info_.prompt_;
}
inline ::autofill_assistant::PromptProto* ActionProto::mutable_prompt() {
  ::autofill_assistant::PromptProto* _msg = _internal_mutable_prompt();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.prompt)
  return _msg;
}

// .autofill_assistant.TellProto tell = 11;
inline bool ActionProto::_internal_has_tell() const {
  return action_info_case() == kTell;
}
inline bool ActionProto::has_tell() const {
  return _internal_has_tell();
}
inline void ActionProto::set_has_tell() {
  _oneof_case_[0] = kTell;
}
inline void ActionProto::clear_tell() {
  if (_internal_has_tell()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.tell_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::TellProto* ActionProto::release_tell() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.tell)
  if (_internal_has_tell()) {
    clear_has_action_info();
    ::autofill_assistant::TellProto* temp = action_info_.tell_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.tell_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TellProto& ActionProto::_internal_tell() const {
  return _internal_has_tell()
      ? *action_info_.tell_
      : reinterpret_cast< ::autofill_assistant::TellProto&>(::autofill_assistant::_TellProto_default_instance_);
}
inline const ::autofill_assistant::TellProto& ActionProto::tell() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.tell)
  return _internal_tell();
}
inline ::autofill_assistant::TellProto* ActionProto::unsafe_arena_release_tell() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.tell)
  if (_internal_has_tell()) {
    clear_has_action_info();
    ::autofill_assistant::TellProto* temp = action_info_.tell_;
    action_info_.tell_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_tell(::autofill_assistant::TellProto* tell) {
  clear_action_info();
  if (tell) {
    set_has_tell();
    action_info_.tell_ = tell;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.tell)
}
inline ::autofill_assistant::TellProto* ActionProto::_internal_mutable_tell() {
  if (!_internal_has_tell()) {
    clear_action_info();
    set_has_tell();
    action_info_.tell_ = CreateMaybeMessage< ::autofill_assistant::TellProto >(GetArenaForAllocation());
  }
  return action_info_.tell_;
}
inline ::autofill_assistant::TellProto* ActionProto::mutable_tell() {
  ::autofill_assistant::TellProto* _msg = _internal_mutable_tell();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.tell)
  return _msg;
}

// .autofill_assistant.ShowCastProto show_cast = 12;
inline bool ActionProto::_internal_has_show_cast() const {
  return action_info_case() == kShowCast;
}
inline bool ActionProto::has_show_cast() const {
  return _internal_has_show_cast();
}
inline void ActionProto::set_has_show_cast() {
  _oneof_case_[0] = kShowCast;
}
inline void ActionProto::clear_show_cast() {
  if (_internal_has_show_cast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.show_cast_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ShowCastProto* ActionProto::release_show_cast() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.show_cast)
  if (_internal_has_show_cast()) {
    clear_has_action_info();
    ::autofill_assistant::ShowCastProto* temp = action_info_.show_cast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.show_cast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowCastProto& ActionProto::_internal_show_cast() const {
  return _internal_has_show_cast()
      ? *action_info_.show_cast_
      : reinterpret_cast< ::autofill_assistant::ShowCastProto&>(::autofill_assistant::_ShowCastProto_default_instance_);
}
inline const ::autofill_assistant::ShowCastProto& ActionProto::show_cast() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.show_cast)
  return _internal_show_cast();
}
inline ::autofill_assistant::ShowCastProto* ActionProto::unsafe_arena_release_show_cast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.show_cast)
  if (_internal_has_show_cast()) {
    clear_has_action_info();
    ::autofill_assistant::ShowCastProto* temp = action_info_.show_cast_;
    action_info_.show_cast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_show_cast(::autofill_assistant::ShowCastProto* show_cast) {
  clear_action_info();
  if (show_cast) {
    set_has_show_cast();
    action_info_.show_cast_ = show_cast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.show_cast)
}
inline ::autofill_assistant::ShowCastProto* ActionProto::_internal_mutable_show_cast() {
  if (!_internal_has_show_cast()) {
    clear_action_info();
    set_has_show_cast();
    action_info_.show_cast_ = CreateMaybeMessage< ::autofill_assistant::ShowCastProto >(GetArenaForAllocation());
  }
  return action_info_.show_cast_;
}
inline ::autofill_assistant::ShowCastProto* ActionProto::mutable_show_cast() {
  ::autofill_assistant::ShowCastProto* _msg = _internal_mutable_show_cast();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.show_cast)
  return _msg;
}

// .autofill_assistant.WaitForDomProto wait_for_dom = 19;
inline bool ActionProto::_internal_has_wait_for_dom() const {
  return action_info_case() == kWaitForDom;
}
inline bool ActionProto::has_wait_for_dom() const {
  return _internal_has_wait_for_dom();
}
inline void ActionProto::set_has_wait_for_dom() {
  _oneof_case_[0] = kWaitForDom;
}
inline void ActionProto::clear_wait_for_dom() {
  if (_internal_has_wait_for_dom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.wait_for_dom_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::WaitForDomProto* ActionProto::release_wait_for_dom() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.wait_for_dom)
  if (_internal_has_wait_for_dom()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDomProto* temp = action_info_.wait_for_dom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.wait_for_dom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForDomProto& ActionProto::_internal_wait_for_dom() const {
  return _internal_has_wait_for_dom()
      ? *action_info_.wait_for_dom_
      : reinterpret_cast< ::autofill_assistant::WaitForDomProto&>(::autofill_assistant::_WaitForDomProto_default_instance_);
}
inline const ::autofill_assistant::WaitForDomProto& ActionProto::wait_for_dom() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.wait_for_dom)
  return _internal_wait_for_dom();
}
inline ::autofill_assistant::WaitForDomProto* ActionProto::unsafe_arena_release_wait_for_dom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.wait_for_dom)
  if (_internal_has_wait_for_dom()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDomProto* temp = action_info_.wait_for_dom_;
    action_info_.wait_for_dom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_wait_for_dom(::autofill_assistant::WaitForDomProto* wait_for_dom) {
  clear_action_info();
  if (wait_for_dom) {
    set_has_wait_for_dom();
    action_info_.wait_for_dom_ = wait_for_dom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.wait_for_dom)
}
inline ::autofill_assistant::WaitForDomProto* ActionProto::_internal_mutable_wait_for_dom() {
  if (!_internal_has_wait_for_dom()) {
    clear_action_info();
    set_has_wait_for_dom();
    action_info_.wait_for_dom_ = CreateMaybeMessage< ::autofill_assistant::WaitForDomProto >(GetArenaForAllocation());
  }
  return action_info_.wait_for_dom_;
}
inline ::autofill_assistant::WaitForDomProto* ActionProto::mutable_wait_for_dom() {
  ::autofill_assistant::WaitForDomProto* _msg = _internal_mutable_wait_for_dom();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.wait_for_dom)
  return _msg;
}

// .autofill_assistant.UseCreditCardProto use_card = 28;
inline bool ActionProto::_internal_has_use_card() const {
  return action_info_case() == kUseCard;
}
inline bool ActionProto::has_use_card() const {
  return _internal_has_use_card();
}
inline void ActionProto::set_has_use_card() {
  _oneof_case_[0] = kUseCard;
}
inline void ActionProto::clear_use_card() {
  if (_internal_has_use_card()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.use_card_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::UseCreditCardProto* ActionProto::release_use_card() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.use_card)
  if (_internal_has_use_card()) {
    clear_has_action_info();
    ::autofill_assistant::UseCreditCardProto* temp = action_info_.use_card_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.use_card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::UseCreditCardProto& ActionProto::_internal_use_card() const {
  return _internal_has_use_card()
      ? *action_info_.use_card_
      : reinterpret_cast< ::autofill_assistant::UseCreditCardProto&>(::autofill_assistant::_UseCreditCardProto_default_instance_);
}
inline const ::autofill_assistant::UseCreditCardProto& ActionProto::use_card() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.use_card)
  return _internal_use_card();
}
inline ::autofill_assistant::UseCreditCardProto* ActionProto::unsafe_arena_release_use_card() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.use_card)
  if (_internal_has_use_card()) {
    clear_has_action_info();
    ::autofill_assistant::UseCreditCardProto* temp = action_info_.use_card_;
    action_info_.use_card_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_use_card(::autofill_assistant::UseCreditCardProto* use_card) {
  clear_action_info();
  if (use_card) {
    set_has_use_card();
    action_info_.use_card_ = use_card;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.use_card)
}
inline ::autofill_assistant::UseCreditCardProto* ActionProto::_internal_mutable_use_card() {
  if (!_internal_has_use_card()) {
    clear_action_info();
    set_has_use_card();
    action_info_.use_card_ = CreateMaybeMessage< ::autofill_assistant::UseCreditCardProto >(GetArenaForAllocation());
  }
  return action_info_.use_card_;
}
inline ::autofill_assistant::UseCreditCardProto* ActionProto::mutable_use_card() {
  ::autofill_assistant::UseCreditCardProto* _msg = _internal_mutable_use_card();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.use_card)
  return _msg;
}

// .autofill_assistant.UseAddressProto use_address = 29;
inline bool ActionProto::_internal_has_use_address() const {
  return action_info_case() == kUseAddress;
}
inline bool ActionProto::has_use_address() const {
  return _internal_has_use_address();
}
inline void ActionProto::set_has_use_address() {
  _oneof_case_[0] = kUseAddress;
}
inline void ActionProto::clear_use_address() {
  if (_internal_has_use_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.use_address_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::UseAddressProto* ActionProto::release_use_address() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.use_address)
  if (_internal_has_use_address()) {
    clear_has_action_info();
    ::autofill_assistant::UseAddressProto* temp = action_info_.use_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.use_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::UseAddressProto& ActionProto::_internal_use_address() const {
  return _internal_has_use_address()
      ? *action_info_.use_address_
      : reinterpret_cast< ::autofill_assistant::UseAddressProto&>(::autofill_assistant::_UseAddressProto_default_instance_);
}
inline const ::autofill_assistant::UseAddressProto& ActionProto::use_address() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.use_address)
  return _internal_use_address();
}
inline ::autofill_assistant::UseAddressProto* ActionProto::unsafe_arena_release_use_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.use_address)
  if (_internal_has_use_address()) {
    clear_has_action_info();
    ::autofill_assistant::UseAddressProto* temp = action_info_.use_address_;
    action_info_.use_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_use_address(::autofill_assistant::UseAddressProto* use_address) {
  clear_action_info();
  if (use_address) {
    set_has_use_address();
    action_info_.use_address_ = use_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.use_address)
}
inline ::autofill_assistant::UseAddressProto* ActionProto::_internal_mutable_use_address() {
  if (!_internal_has_use_address()) {
    clear_action_info();
    set_has_use_address();
    action_info_.use_address_ = CreateMaybeMessage< ::autofill_assistant::UseAddressProto >(GetArenaForAllocation());
  }
  return action_info_.use_address_;
}
inline ::autofill_assistant::UseAddressProto* ActionProto::mutable_use_address() {
  ::autofill_assistant::UseAddressProto* _msg = _internal_mutable_use_address();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.use_address)
  return _msg;
}

// .autofill_assistant.UploadDomProto upload_dom = 18;
inline bool ActionProto::_internal_has_upload_dom() const {
  return action_info_case() == kUploadDom;
}
inline bool ActionProto::has_upload_dom() const {
  return _internal_has_upload_dom();
}
inline void ActionProto::set_has_upload_dom() {
  _oneof_case_[0] = kUploadDom;
}
inline void ActionProto::clear_upload_dom() {
  if (_internal_has_upload_dom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.upload_dom_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::UploadDomProto* ActionProto::release_upload_dom() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.upload_dom)
  if (_internal_has_upload_dom()) {
    clear_has_action_info();
    ::autofill_assistant::UploadDomProto* temp = action_info_.upload_dom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.upload_dom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::UploadDomProto& ActionProto::_internal_upload_dom() const {
  return _internal_has_upload_dom()
      ? *action_info_.upload_dom_
      : reinterpret_cast< ::autofill_assistant::UploadDomProto&>(::autofill_assistant::_UploadDomProto_default_instance_);
}
inline const ::autofill_assistant::UploadDomProto& ActionProto::upload_dom() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.upload_dom)
  return _internal_upload_dom();
}
inline ::autofill_assistant::UploadDomProto* ActionProto::unsafe_arena_release_upload_dom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.upload_dom)
  if (_internal_has_upload_dom()) {
    clear_has_action_info();
    ::autofill_assistant::UploadDomProto* temp = action_info_.upload_dom_;
    action_info_.upload_dom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_upload_dom(::autofill_assistant::UploadDomProto* upload_dom) {
  clear_action_info();
  if (upload_dom) {
    set_has_upload_dom();
    action_info_.upload_dom_ = upload_dom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.upload_dom)
}
inline ::autofill_assistant::UploadDomProto* ActionProto::_internal_mutable_upload_dom() {
  if (!_internal_has_upload_dom()) {
    clear_action_info();
    set_has_upload_dom();
    action_info_.upload_dom_ = CreateMaybeMessage< ::autofill_assistant::UploadDomProto >(GetArenaForAllocation());
  }
  return action_info_.upload_dom_;
}
inline ::autofill_assistant::UploadDomProto* ActionProto::mutable_upload_dom() {
  ::autofill_assistant::UploadDomProto* _msg = _internal_mutable_upload_dom();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.upload_dom)
  return _msg;
}

// .autofill_assistant.ShowProgressBarProto show_progress_bar = 24;
inline bool ActionProto::_internal_has_show_progress_bar() const {
  return action_info_case() == kShowProgressBar;
}
inline bool ActionProto::has_show_progress_bar() const {
  return _internal_has_show_progress_bar();
}
inline void ActionProto::set_has_show_progress_bar() {
  _oneof_case_[0] = kShowProgressBar;
}
inline void ActionProto::clear_show_progress_bar() {
  if (_internal_has_show_progress_bar()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.show_progress_bar_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ShowProgressBarProto* ActionProto::release_show_progress_bar() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.show_progress_bar)
  if (_internal_has_show_progress_bar()) {
    clear_has_action_info();
    ::autofill_assistant::ShowProgressBarProto* temp = action_info_.show_progress_bar_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.show_progress_bar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowProgressBarProto& ActionProto::_internal_show_progress_bar() const {
  return _internal_has_show_progress_bar()
      ? *action_info_.show_progress_bar_
      : reinterpret_cast< ::autofill_assistant::ShowProgressBarProto&>(::autofill_assistant::_ShowProgressBarProto_default_instance_);
}
inline const ::autofill_assistant::ShowProgressBarProto& ActionProto::show_progress_bar() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.show_progress_bar)
  return _internal_show_progress_bar();
}
inline ::autofill_assistant::ShowProgressBarProto* ActionProto::unsafe_arena_release_show_progress_bar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.show_progress_bar)
  if (_internal_has_show_progress_bar()) {
    clear_has_action_info();
    ::autofill_assistant::ShowProgressBarProto* temp = action_info_.show_progress_bar_;
    action_info_.show_progress_bar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_show_progress_bar(::autofill_assistant::ShowProgressBarProto* show_progress_bar) {
  clear_action_info();
  if (show_progress_bar) {
    set_has_show_progress_bar();
    action_info_.show_progress_bar_ = show_progress_bar;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.show_progress_bar)
}
inline ::autofill_assistant::ShowProgressBarProto* ActionProto::_internal_mutable_show_progress_bar() {
  if (!_internal_has_show_progress_bar()) {
    clear_action_info();
    set_has_show_progress_bar();
    action_info_.show_progress_bar_ = CreateMaybeMessage< ::autofill_assistant::ShowProgressBarProto >(GetArenaForAllocation());
  }
  return action_info_.show_progress_bar_;
}
inline ::autofill_assistant::ShowProgressBarProto* ActionProto::mutable_show_progress_bar() {
  ::autofill_assistant::ShowProgressBarProto* _msg = _internal_mutable_show_progress_bar();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.show_progress_bar)
  return _msg;
}

// .autofill_assistant.ShowDetailsProto show_details = 32;
inline bool ActionProto::_internal_has_show_details() const {
  return action_info_case() == kShowDetails;
}
inline bool ActionProto::has_show_details() const {
  return _internal_has_show_details();
}
inline void ActionProto::set_has_show_details() {
  _oneof_case_[0] = kShowDetails;
}
inline void ActionProto::clear_show_details() {
  if (_internal_has_show_details()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.show_details_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ShowDetailsProto* ActionProto::release_show_details() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.show_details)
  if (_internal_has_show_details()) {
    clear_has_action_info();
    ::autofill_assistant::ShowDetailsProto* temp = action_info_.show_details_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.show_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowDetailsProto& ActionProto::_internal_show_details() const {
  return _internal_has_show_details()
      ? *action_info_.show_details_
      : reinterpret_cast< ::autofill_assistant::ShowDetailsProto&>(::autofill_assistant::_ShowDetailsProto_default_instance_);
}
inline const ::autofill_assistant::ShowDetailsProto& ActionProto::show_details() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.show_details)
  return _internal_show_details();
}
inline ::autofill_assistant::ShowDetailsProto* ActionProto::unsafe_arena_release_show_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.show_details)
  if (_internal_has_show_details()) {
    clear_has_action_info();
    ::autofill_assistant::ShowDetailsProto* temp = action_info_.show_details_;
    action_info_.show_details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_show_details(::autofill_assistant::ShowDetailsProto* show_details) {
  clear_action_info();
  if (show_details) {
    set_has_show_details();
    action_info_.show_details_ = show_details;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.show_details)
}
inline ::autofill_assistant::ShowDetailsProto* ActionProto::_internal_mutable_show_details() {
  if (!_internal_has_show_details()) {
    clear_action_info();
    set_has_show_details();
    action_info_.show_details_ = CreateMaybeMessage< ::autofill_assistant::ShowDetailsProto >(GetArenaForAllocation());
  }
  return action_info_.show_details_;
}
inline ::autofill_assistant::ShowDetailsProto* ActionProto::mutable_show_details() {
  ::autofill_assistant::ShowDetailsProto* _msg = _internal_mutable_show_details();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.show_details)
  return _msg;
}

// .autofill_assistant.StopProto stop = 35;
inline bool ActionProto::_internal_has_stop() const {
  return action_info_case() == kStop;
}
inline bool ActionProto::has_stop() const {
  return _internal_has_stop();
}
inline void ActionProto::set_has_stop() {
  _oneof_case_[0] = kStop;
}
inline void ActionProto::clear_stop() {
  if (_internal_has_stop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.stop_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::StopProto* ActionProto::release_stop() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.stop)
  if (_internal_has_stop()) {
    clear_has_action_info();
    ::autofill_assistant::StopProto* temp = action_info_.stop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::StopProto& ActionProto::_internal_stop() const {
  return _internal_has_stop()
      ? *action_info_.stop_
      : reinterpret_cast< ::autofill_assistant::StopProto&>(::autofill_assistant::_StopProto_default_instance_);
}
inline const ::autofill_assistant::StopProto& ActionProto::stop() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.stop)
  return _internal_stop();
}
inline ::autofill_assistant::StopProto* ActionProto::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.stop)
  if (_internal_has_stop()) {
    clear_has_action_info();
    ::autofill_assistant::StopProto* temp = action_info_.stop_;
    action_info_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_stop(::autofill_assistant::StopProto* stop) {
  clear_action_info();
  if (stop) {
    set_has_stop();
    action_info_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.stop)
}
inline ::autofill_assistant::StopProto* ActionProto::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_action_info();
    set_has_stop();
    action_info_.stop_ = CreateMaybeMessage< ::autofill_assistant::StopProto >(GetArenaForAllocation());
  }
  return action_info_.stop_;
}
inline ::autofill_assistant::StopProto* ActionProto::mutable_stop() {
  ::autofill_assistant::StopProto* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.stop)
  return _msg;
}

// .autofill_assistant.CollectUserDataProto collect_user_data = 36;
inline bool ActionProto::_internal_has_collect_user_data() const {
  return action_info_case() == kCollectUserData;
}
inline bool ActionProto::has_collect_user_data() const {
  return _internal_has_collect_user_data();
}
inline void ActionProto::set_has_collect_user_data() {
  _oneof_case_[0] = kCollectUserData;
}
inline void ActionProto::clear_collect_user_data() {
  if (_internal_has_collect_user_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.collect_user_data_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::CollectUserDataProto* ActionProto::release_collect_user_data() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.collect_user_data)
  if (_internal_has_collect_user_data()) {
    clear_has_action_info();
    ::autofill_assistant::CollectUserDataProto* temp = action_info_.collect_user_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.collect_user_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CollectUserDataProto& ActionProto::_internal_collect_user_data() const {
  return _internal_has_collect_user_data()
      ? *action_info_.collect_user_data_
      : reinterpret_cast< ::autofill_assistant::CollectUserDataProto&>(::autofill_assistant::_CollectUserDataProto_default_instance_);
}
inline const ::autofill_assistant::CollectUserDataProto& ActionProto::collect_user_data() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.collect_user_data)
  return _internal_collect_user_data();
}
inline ::autofill_assistant::CollectUserDataProto* ActionProto::unsafe_arena_release_collect_user_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.collect_user_data)
  if (_internal_has_collect_user_data()) {
    clear_has_action_info();
    ::autofill_assistant::CollectUserDataProto* temp = action_info_.collect_user_data_;
    action_info_.collect_user_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_collect_user_data(::autofill_assistant::CollectUserDataProto* collect_user_data) {
  clear_action_info();
  if (collect_user_data) {
    set_has_collect_user_data();
    action_info_.collect_user_data_ = collect_user_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.collect_user_data)
}
inline ::autofill_assistant::CollectUserDataProto* ActionProto::_internal_mutable_collect_user_data() {
  if (!_internal_has_collect_user_data()) {
    clear_action_info();
    set_has_collect_user_data();
    action_info_.collect_user_data_ = CreateMaybeMessage< ::autofill_assistant::CollectUserDataProto >(GetArenaForAllocation());
  }
  return action_info_.collect_user_data_;
}
inline ::autofill_assistant::CollectUserDataProto* ActionProto::mutable_collect_user_data() {
  ::autofill_assistant::CollectUserDataProto* _msg = _internal_mutable_collect_user_data();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.collect_user_data)
  return _msg;
}

// .autofill_assistant.SetAttributeProto set_attribute = 37;
inline bool ActionProto::_internal_has_set_attribute() const {
  return action_info_case() == kSetAttribute;
}
inline bool ActionProto::has_set_attribute() const {
  return _internal_has_set_attribute();
}
inline void ActionProto::set_has_set_attribute() {
  _oneof_case_[0] = kSetAttribute;
}
inline void ActionProto::clear_set_attribute() {
  if (_internal_has_set_attribute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.set_attribute_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::SetAttributeProto* ActionProto::release_set_attribute() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.set_attribute)
  if (_internal_has_set_attribute()) {
    clear_has_action_info();
    ::autofill_assistant::SetAttributeProto* temp = action_info_.set_attribute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.set_attribute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetAttributeProto& ActionProto::_internal_set_attribute() const {
  return _internal_has_set_attribute()
      ? *action_info_.set_attribute_
      : reinterpret_cast< ::autofill_assistant::SetAttributeProto&>(::autofill_assistant::_SetAttributeProto_default_instance_);
}
inline const ::autofill_assistant::SetAttributeProto& ActionProto::set_attribute() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.set_attribute)
  return _internal_set_attribute();
}
inline ::autofill_assistant::SetAttributeProto* ActionProto::unsafe_arena_release_set_attribute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.set_attribute)
  if (_internal_has_set_attribute()) {
    clear_has_action_info();
    ::autofill_assistant::SetAttributeProto* temp = action_info_.set_attribute_;
    action_info_.set_attribute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_set_attribute(::autofill_assistant::SetAttributeProto* set_attribute) {
  clear_action_info();
  if (set_attribute) {
    set_has_set_attribute();
    action_info_.set_attribute_ = set_attribute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.set_attribute)
}
inline ::autofill_assistant::SetAttributeProto* ActionProto::_internal_mutable_set_attribute() {
  if (!_internal_has_set_attribute()) {
    clear_action_info();
    set_has_set_attribute();
    action_info_.set_attribute_ = CreateMaybeMessage< ::autofill_assistant::SetAttributeProto >(GetArenaForAllocation());
  }
  return action_info_.set_attribute_;
}
inline ::autofill_assistant::SetAttributeProto* ActionProto::mutable_set_attribute() {
  ::autofill_assistant::SetAttributeProto* _msg = _internal_mutable_set_attribute();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.set_attribute)
  return _msg;
}

// .autofill_assistant.ShowInfoBoxProto show_info_box = 39;
inline bool ActionProto::_internal_has_show_info_box() const {
  return action_info_case() == kShowInfoBox;
}
inline bool ActionProto::has_show_info_box() const {
  return _internal_has_show_info_box();
}
inline void ActionProto::set_has_show_info_box() {
  _oneof_case_[0] = kShowInfoBox;
}
inline void ActionProto::clear_show_info_box() {
  if (_internal_has_show_info_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.show_info_box_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ShowInfoBoxProto* ActionProto::release_show_info_box() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.show_info_box)
  if (_internal_has_show_info_box()) {
    clear_has_action_info();
    ::autofill_assistant::ShowInfoBoxProto* temp = action_info_.show_info_box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.show_info_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowInfoBoxProto& ActionProto::_internal_show_info_box() const {
  return _internal_has_show_info_box()
      ? *action_info_.show_info_box_
      : reinterpret_cast< ::autofill_assistant::ShowInfoBoxProto&>(::autofill_assistant::_ShowInfoBoxProto_default_instance_);
}
inline const ::autofill_assistant::ShowInfoBoxProto& ActionProto::show_info_box() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.show_info_box)
  return _internal_show_info_box();
}
inline ::autofill_assistant::ShowInfoBoxProto* ActionProto::unsafe_arena_release_show_info_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.show_info_box)
  if (_internal_has_show_info_box()) {
    clear_has_action_info();
    ::autofill_assistant::ShowInfoBoxProto* temp = action_info_.show_info_box_;
    action_info_.show_info_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_show_info_box(::autofill_assistant::ShowInfoBoxProto* show_info_box) {
  clear_action_info();
  if (show_info_box) {
    set_has_show_info_box();
    action_info_.show_info_box_ = show_info_box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.show_info_box)
}
inline ::autofill_assistant::ShowInfoBoxProto* ActionProto::_internal_mutable_show_info_box() {
  if (!_internal_has_show_info_box()) {
    clear_action_info();
    set_has_show_info_box();
    action_info_.show_info_box_ = CreateMaybeMessage< ::autofill_assistant::ShowInfoBoxProto >(GetArenaForAllocation());
  }
  return action_info_.show_info_box_;
}
inline ::autofill_assistant::ShowInfoBoxProto* ActionProto::mutable_show_info_box() {
  ::autofill_assistant::ShowInfoBoxProto* _msg = _internal_mutable_show_info_box();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.show_info_box)
  return _msg;
}

// .autofill_assistant.ExpectNavigationProto expect_navigation = 40;
inline bool ActionProto::_internal_has_expect_navigation() const {
  return action_info_case() == kExpectNavigation;
}
inline bool ActionProto::has_expect_navigation() const {
  return _internal_has_expect_navigation();
}
inline void ActionProto::set_has_expect_navigation() {
  _oneof_case_[0] = kExpectNavigation;
}
inline void ActionProto::clear_expect_navigation() {
  if (_internal_has_expect_navigation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.expect_navigation_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ExpectNavigationProto* ActionProto::release_expect_navigation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.expect_navigation)
  if (_internal_has_expect_navigation()) {
    clear_has_action_info();
    ::autofill_assistant::ExpectNavigationProto* temp = action_info_.expect_navigation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.expect_navigation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ExpectNavigationProto& ActionProto::_internal_expect_navigation() const {
  return _internal_has_expect_navigation()
      ? *action_info_.expect_navigation_
      : reinterpret_cast< ::autofill_assistant::ExpectNavigationProto&>(::autofill_assistant::_ExpectNavigationProto_default_instance_);
}
inline const ::autofill_assistant::ExpectNavigationProto& ActionProto::expect_navigation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.expect_navigation)
  return _internal_expect_navigation();
}
inline ::autofill_assistant::ExpectNavigationProto* ActionProto::unsafe_arena_release_expect_navigation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.expect_navigation)
  if (_internal_has_expect_navigation()) {
    clear_has_action_info();
    ::autofill_assistant::ExpectNavigationProto* temp = action_info_.expect_navigation_;
    action_info_.expect_navigation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_expect_navigation(::autofill_assistant::ExpectNavigationProto* expect_navigation) {
  clear_action_info();
  if (expect_navigation) {
    set_has_expect_navigation();
    action_info_.expect_navigation_ = expect_navigation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.expect_navigation)
}
inline ::autofill_assistant::ExpectNavigationProto* ActionProto::_internal_mutable_expect_navigation() {
  if (!_internal_has_expect_navigation()) {
    clear_action_info();
    set_has_expect_navigation();
    action_info_.expect_navigation_ = CreateMaybeMessage< ::autofill_assistant::ExpectNavigationProto >(GetArenaForAllocation());
  }
  return action_info_.expect_navigation_;
}
inline ::autofill_assistant::ExpectNavigationProto* ActionProto::mutable_expect_navigation() {
  ::autofill_assistant::ExpectNavigationProto* _msg = _internal_mutable_expect_navigation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.expect_navigation)
  return _msg;
}

// .autofill_assistant.WaitForNavigationProto wait_for_navigation = 41;
inline bool ActionProto::_internal_has_wait_for_navigation() const {
  return action_info_case() == kWaitForNavigation;
}
inline bool ActionProto::has_wait_for_navigation() const {
  return _internal_has_wait_for_navigation();
}
inline void ActionProto::set_has_wait_for_navigation() {
  _oneof_case_[0] = kWaitForNavigation;
}
inline void ActionProto::clear_wait_for_navigation() {
  if (_internal_has_wait_for_navigation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.wait_for_navigation_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::WaitForNavigationProto* ActionProto::release_wait_for_navigation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.wait_for_navigation)
  if (_internal_has_wait_for_navigation()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForNavigationProto* temp = action_info_.wait_for_navigation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.wait_for_navigation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForNavigationProto& ActionProto::_internal_wait_for_navigation() const {
  return _internal_has_wait_for_navigation()
      ? *action_info_.wait_for_navigation_
      : reinterpret_cast< ::autofill_assistant::WaitForNavigationProto&>(::autofill_assistant::_WaitForNavigationProto_default_instance_);
}
inline const ::autofill_assistant::WaitForNavigationProto& ActionProto::wait_for_navigation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.wait_for_navigation)
  return _internal_wait_for_navigation();
}
inline ::autofill_assistant::WaitForNavigationProto* ActionProto::unsafe_arena_release_wait_for_navigation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.wait_for_navigation)
  if (_internal_has_wait_for_navigation()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForNavigationProto* temp = action_info_.wait_for_navigation_;
    action_info_.wait_for_navigation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_wait_for_navigation(::autofill_assistant::WaitForNavigationProto* wait_for_navigation) {
  clear_action_info();
  if (wait_for_navigation) {
    set_has_wait_for_navigation();
    action_info_.wait_for_navigation_ = wait_for_navigation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.wait_for_navigation)
}
inline ::autofill_assistant::WaitForNavigationProto* ActionProto::_internal_mutable_wait_for_navigation() {
  if (!_internal_has_wait_for_navigation()) {
    clear_action_info();
    set_has_wait_for_navigation();
    action_info_.wait_for_navigation_ = CreateMaybeMessage< ::autofill_assistant::WaitForNavigationProto >(GetArenaForAllocation());
  }
  return action_info_.wait_for_navigation_;
}
inline ::autofill_assistant::WaitForNavigationProto* ActionProto::mutable_wait_for_navigation() {
  ::autofill_assistant::WaitForNavigationProto* _msg = _internal_mutable_wait_for_navigation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.wait_for_navigation)
  return _msg;
}

// .autofill_assistant.ConfigureBottomSheetProto configure_bottom_sheet = 42;
inline bool ActionProto::_internal_has_configure_bottom_sheet() const {
  return action_info_case() == kConfigureBottomSheet;
}
inline bool ActionProto::has_configure_bottom_sheet() const {
  return _internal_has_configure_bottom_sheet();
}
inline void ActionProto::set_has_configure_bottom_sheet() {
  _oneof_case_[0] = kConfigureBottomSheet;
}
inline void ActionProto::clear_configure_bottom_sheet() {
  if (_internal_has_configure_bottom_sheet()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.configure_bottom_sheet_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ConfigureBottomSheetProto* ActionProto::release_configure_bottom_sheet() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.configure_bottom_sheet)
  if (_internal_has_configure_bottom_sheet()) {
    clear_has_action_info();
    ::autofill_assistant::ConfigureBottomSheetProto* temp = action_info_.configure_bottom_sheet_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.configure_bottom_sheet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ConfigureBottomSheetProto& ActionProto::_internal_configure_bottom_sheet() const {
  return _internal_has_configure_bottom_sheet()
      ? *action_info_.configure_bottom_sheet_
      : reinterpret_cast< ::autofill_assistant::ConfigureBottomSheetProto&>(::autofill_assistant::_ConfigureBottomSheetProto_default_instance_);
}
inline const ::autofill_assistant::ConfigureBottomSheetProto& ActionProto::configure_bottom_sheet() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.configure_bottom_sheet)
  return _internal_configure_bottom_sheet();
}
inline ::autofill_assistant::ConfigureBottomSheetProto* ActionProto::unsafe_arena_release_configure_bottom_sheet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.configure_bottom_sheet)
  if (_internal_has_configure_bottom_sheet()) {
    clear_has_action_info();
    ::autofill_assistant::ConfigureBottomSheetProto* temp = action_info_.configure_bottom_sheet_;
    action_info_.configure_bottom_sheet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_configure_bottom_sheet(::autofill_assistant::ConfigureBottomSheetProto* configure_bottom_sheet) {
  clear_action_info();
  if (configure_bottom_sheet) {
    set_has_configure_bottom_sheet();
    action_info_.configure_bottom_sheet_ = configure_bottom_sheet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.configure_bottom_sheet)
}
inline ::autofill_assistant::ConfigureBottomSheetProto* ActionProto::_internal_mutable_configure_bottom_sheet() {
  if (!_internal_has_configure_bottom_sheet()) {
    clear_action_info();
    set_has_configure_bottom_sheet();
    action_info_.configure_bottom_sheet_ = CreateMaybeMessage< ::autofill_assistant::ConfigureBottomSheetProto >(GetArenaForAllocation());
  }
  return action_info_.configure_bottom_sheet_;
}
inline ::autofill_assistant::ConfigureBottomSheetProto* ActionProto::mutable_configure_bottom_sheet() {
  ::autofill_assistant::ConfigureBottomSheetProto* _msg = _internal_mutable_configure_bottom_sheet();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.configure_bottom_sheet)
  return _msg;
}

// .autofill_assistant.ShowFormProto show_form = 43;
inline bool ActionProto::_internal_has_show_form() const {
  return action_info_case() == kShowForm;
}
inline bool ActionProto::has_show_form() const {
  return _internal_has_show_form();
}
inline void ActionProto::set_has_show_form() {
  _oneof_case_[0] = kShowForm;
}
inline void ActionProto::clear_show_form() {
  if (_internal_has_show_form()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.show_form_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ShowFormProto* ActionProto::release_show_form() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.show_form)
  if (_internal_has_show_form()) {
    clear_has_action_info();
    ::autofill_assistant::ShowFormProto* temp = action_info_.show_form_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.show_form_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowFormProto& ActionProto::_internal_show_form() const {
  return _internal_has_show_form()
      ? *action_info_.show_form_
      : reinterpret_cast< ::autofill_assistant::ShowFormProto&>(::autofill_assistant::_ShowFormProto_default_instance_);
}
inline const ::autofill_assistant::ShowFormProto& ActionProto::show_form() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.show_form)
  return _internal_show_form();
}
inline ::autofill_assistant::ShowFormProto* ActionProto::unsafe_arena_release_show_form() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.show_form)
  if (_internal_has_show_form()) {
    clear_has_action_info();
    ::autofill_assistant::ShowFormProto* temp = action_info_.show_form_;
    action_info_.show_form_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_show_form(::autofill_assistant::ShowFormProto* show_form) {
  clear_action_info();
  if (show_form) {
    set_has_show_form();
    action_info_.show_form_ = show_form;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.show_form)
}
inline ::autofill_assistant::ShowFormProto* ActionProto::_internal_mutable_show_form() {
  if (!_internal_has_show_form()) {
    clear_action_info();
    set_has_show_form();
    action_info_.show_form_ = CreateMaybeMessage< ::autofill_assistant::ShowFormProto >(GetArenaForAllocation());
  }
  return action_info_.show_form_;
}
inline ::autofill_assistant::ShowFormProto* ActionProto::mutable_show_form() {
  ::autofill_assistant::ShowFormProto* _msg = _internal_mutable_show_form();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.show_form)
  return _msg;
}

// .autofill_assistant.PopupMessageProto popup_message = 44;
inline bool ActionProto::_internal_has_popup_message() const {
  return action_info_case() == kPopupMessage;
}
inline bool ActionProto::has_popup_message() const {
  return _internal_has_popup_message();
}
inline void ActionProto::set_has_popup_message() {
  _oneof_case_[0] = kPopupMessage;
}
inline void ActionProto::clear_popup_message() {
  if (_internal_has_popup_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.popup_message_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::PopupMessageProto* ActionProto::release_popup_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.popup_message)
  if (_internal_has_popup_message()) {
    clear_has_action_info();
    ::autofill_assistant::PopupMessageProto* temp = action_info_.popup_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.popup_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PopupMessageProto& ActionProto::_internal_popup_message() const {
  return _internal_has_popup_message()
      ? *action_info_.popup_message_
      : reinterpret_cast< ::autofill_assistant::PopupMessageProto&>(::autofill_assistant::_PopupMessageProto_default_instance_);
}
inline const ::autofill_assistant::PopupMessageProto& ActionProto::popup_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.popup_message)
  return _internal_popup_message();
}
inline ::autofill_assistant::PopupMessageProto* ActionProto::unsafe_arena_release_popup_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.popup_message)
  if (_internal_has_popup_message()) {
    clear_has_action_info();
    ::autofill_assistant::PopupMessageProto* temp = action_info_.popup_message_;
    action_info_.popup_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_popup_message(::autofill_assistant::PopupMessageProto* popup_message) {
  clear_action_info();
  if (popup_message) {
    set_has_popup_message();
    action_info_.popup_message_ = popup_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.popup_message)
}
inline ::autofill_assistant::PopupMessageProto* ActionProto::_internal_mutable_popup_message() {
  if (!_internal_has_popup_message()) {
    clear_action_info();
    set_has_popup_message();
    action_info_.popup_message_ = CreateMaybeMessage< ::autofill_assistant::PopupMessageProto >(GetArenaForAllocation());
  }
  return action_info_.popup_message_;
}
inline ::autofill_assistant::PopupMessageProto* ActionProto::mutable_popup_message() {
  ::autofill_assistant::PopupMessageProto* _msg = _internal_mutable_popup_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.popup_message)
  return _msg;
}

// .autofill_assistant.WaitForDocumentProto wait_for_document = 45;
inline bool ActionProto::_internal_has_wait_for_document() const {
  return action_info_case() == kWaitForDocument;
}
inline bool ActionProto::has_wait_for_document() const {
  return _internal_has_wait_for_document();
}
inline void ActionProto::set_has_wait_for_document() {
  _oneof_case_[0] = kWaitForDocument;
}
inline void ActionProto::clear_wait_for_document() {
  if (_internal_has_wait_for_document()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.wait_for_document_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::WaitForDocumentProto* ActionProto::release_wait_for_document() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.wait_for_document)
  if (_internal_has_wait_for_document()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDocumentProto* temp = action_info_.wait_for_document_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.wait_for_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForDocumentProto& ActionProto::_internal_wait_for_document() const {
  return _internal_has_wait_for_document()
      ? *action_info_.wait_for_document_
      : reinterpret_cast< ::autofill_assistant::WaitForDocumentProto&>(::autofill_assistant::_WaitForDocumentProto_default_instance_);
}
inline const ::autofill_assistant::WaitForDocumentProto& ActionProto::wait_for_document() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.wait_for_document)
  return _internal_wait_for_document();
}
inline ::autofill_assistant::WaitForDocumentProto* ActionProto::unsafe_arena_release_wait_for_document() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.wait_for_document)
  if (_internal_has_wait_for_document()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDocumentProto* temp = action_info_.wait_for_document_;
    action_info_.wait_for_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_wait_for_document(::autofill_assistant::WaitForDocumentProto* wait_for_document) {
  clear_action_info();
  if (wait_for_document) {
    set_has_wait_for_document();
    action_info_.wait_for_document_ = wait_for_document;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.wait_for_document)
}
inline ::autofill_assistant::WaitForDocumentProto* ActionProto::_internal_mutable_wait_for_document() {
  if (!_internal_has_wait_for_document()) {
    clear_action_info();
    set_has_wait_for_document();
    action_info_.wait_for_document_ = CreateMaybeMessage< ::autofill_assistant::WaitForDocumentProto >(GetArenaForAllocation());
  }
  return action_info_.wait_for_document_;
}
inline ::autofill_assistant::WaitForDocumentProto* ActionProto::mutable_wait_for_document() {
  ::autofill_assistant::WaitForDocumentProto* _msg = _internal_mutable_wait_for_document();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.wait_for_document)
  return _msg;
}

// .autofill_assistant.ShowGenericUiProto show_generic_ui = 49;
inline bool ActionProto::_internal_has_show_generic_ui() const {
  return action_info_case() == kShowGenericUi;
}
inline bool ActionProto::has_show_generic_ui() const {
  return _internal_has_show_generic_ui();
}
inline void ActionProto::set_has_show_generic_ui() {
  _oneof_case_[0] = kShowGenericUi;
}
inline void ActionProto::clear_show_generic_ui() {
  if (_internal_has_show_generic_ui()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.show_generic_ui_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ShowGenericUiProto* ActionProto::release_show_generic_ui() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.show_generic_ui)
  if (_internal_has_show_generic_ui()) {
    clear_has_action_info();
    ::autofill_assistant::ShowGenericUiProto* temp = action_info_.show_generic_ui_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.show_generic_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowGenericUiProto& ActionProto::_internal_show_generic_ui() const {
  return _internal_has_show_generic_ui()
      ? *action_info_.show_generic_ui_
      : reinterpret_cast< ::autofill_assistant::ShowGenericUiProto&>(::autofill_assistant::_ShowGenericUiProto_default_instance_);
}
inline const ::autofill_assistant::ShowGenericUiProto& ActionProto::show_generic_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.show_generic_ui)
  return _internal_show_generic_ui();
}
inline ::autofill_assistant::ShowGenericUiProto* ActionProto::unsafe_arena_release_show_generic_ui() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.show_generic_ui)
  if (_internal_has_show_generic_ui()) {
    clear_has_action_info();
    ::autofill_assistant::ShowGenericUiProto* temp = action_info_.show_generic_ui_;
    action_info_.show_generic_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_show_generic_ui(::autofill_assistant::ShowGenericUiProto* show_generic_ui) {
  clear_action_info();
  if (show_generic_ui) {
    set_has_show_generic_ui();
    action_info_.show_generic_ui_ = show_generic_ui;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.show_generic_ui)
}
inline ::autofill_assistant::ShowGenericUiProto* ActionProto::_internal_mutable_show_generic_ui() {
  if (!_internal_has_show_generic_ui()) {
    clear_action_info();
    set_has_show_generic_ui();
    action_info_.show_generic_ui_ = CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto >(GetArenaForAllocation());
  }
  return action_info_.show_generic_ui_;
}
inline ::autofill_assistant::ShowGenericUiProto* ActionProto::mutable_show_generic_ui() {
  ::autofill_assistant::ShowGenericUiProto* _msg = _internal_mutable_show_generic_ui();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.show_generic_ui)
  return _msg;
}

// .autofill_assistant.GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
inline bool ActionProto::_internal_has_generate_password_for_form_field() const {
  return action_info_case() == kGeneratePasswordForFormField;
}
inline bool ActionProto::has_generate_password_for_form_field() const {
  return _internal_has_generate_password_for_form_field();
}
inline void ActionProto::set_has_generate_password_for_form_field() {
  _oneof_case_[0] = kGeneratePasswordForFormField;
}
inline void ActionProto::clear_generate_password_for_form_field() {
  if (_internal_has_generate_password_for_form_field()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.generate_password_for_form_field_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::GeneratePasswordForFormFieldProto* ActionProto::release_generate_password_for_form_field() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.generate_password_for_form_field)
  if (_internal_has_generate_password_for_form_field()) {
    clear_has_action_info();
    ::autofill_assistant::GeneratePasswordForFormFieldProto* temp = action_info_.generate_password_for_form_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.generate_password_for_form_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::GeneratePasswordForFormFieldProto& ActionProto::_internal_generate_password_for_form_field() const {
  return _internal_has_generate_password_for_form_field()
      ? *action_info_.generate_password_for_form_field_
      : reinterpret_cast< ::autofill_assistant::GeneratePasswordForFormFieldProto&>(::autofill_assistant::_GeneratePasswordForFormFieldProto_default_instance_);
}
inline const ::autofill_assistant::GeneratePasswordForFormFieldProto& ActionProto::generate_password_for_form_field() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.generate_password_for_form_field)
  return _internal_generate_password_for_form_field();
}
inline ::autofill_assistant::GeneratePasswordForFormFieldProto* ActionProto::unsafe_arena_release_generate_password_for_form_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.generate_password_for_form_field)
  if (_internal_has_generate_password_for_form_field()) {
    clear_has_action_info();
    ::autofill_assistant::GeneratePasswordForFormFieldProto* temp = action_info_.generate_password_for_form_field_;
    action_info_.generate_password_for_form_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_generate_password_for_form_field(::autofill_assistant::GeneratePasswordForFormFieldProto* generate_password_for_form_field) {
  clear_action_info();
  if (generate_password_for_form_field) {
    set_has_generate_password_for_form_field();
    action_info_.generate_password_for_form_field_ = generate_password_for_form_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.generate_password_for_form_field)
}
inline ::autofill_assistant::GeneratePasswordForFormFieldProto* ActionProto::_internal_mutable_generate_password_for_form_field() {
  if (!_internal_has_generate_password_for_form_field()) {
    clear_action_info();
    set_has_generate_password_for_form_field();
    action_info_.generate_password_for_form_field_ = CreateMaybeMessage< ::autofill_assistant::GeneratePasswordForFormFieldProto >(GetArenaForAllocation());
  }
  return action_info_.generate_password_for_form_field_;
}
inline ::autofill_assistant::GeneratePasswordForFormFieldProto* ActionProto::mutable_generate_password_for_form_field() {
  ::autofill_assistant::GeneratePasswordForFormFieldProto* _msg = _internal_mutable_generate_password_for_form_field();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.generate_password_for_form_field)
  return _msg;
}

// .autofill_assistant.SaveGeneratedPasswordProto save_generated_password = 53;
inline bool ActionProto::_internal_has_save_generated_password() const {
  return action_info_case() == kSaveGeneratedPassword;
}
inline bool ActionProto::has_save_generated_password() const {
  return _internal_has_save_generated_password();
}
inline void ActionProto::set_has_save_generated_password() {
  _oneof_case_[0] = kSaveGeneratedPassword;
}
inline void ActionProto::clear_save_generated_password() {
  if (_internal_has_save_generated_password()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.save_generated_password_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::SaveGeneratedPasswordProto* ActionProto::release_save_generated_password() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.save_generated_password)
  if (_internal_has_save_generated_password()) {
    clear_has_action_info();
    ::autofill_assistant::SaveGeneratedPasswordProto* temp = action_info_.save_generated_password_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.save_generated_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SaveGeneratedPasswordProto& ActionProto::_internal_save_generated_password() const {
  return _internal_has_save_generated_password()
      ? *action_info_.save_generated_password_
      : reinterpret_cast< ::autofill_assistant::SaveGeneratedPasswordProto&>(::autofill_assistant::_SaveGeneratedPasswordProto_default_instance_);
}
inline const ::autofill_assistant::SaveGeneratedPasswordProto& ActionProto::save_generated_password() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.save_generated_password)
  return _internal_save_generated_password();
}
inline ::autofill_assistant::SaveGeneratedPasswordProto* ActionProto::unsafe_arena_release_save_generated_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.save_generated_password)
  if (_internal_has_save_generated_password()) {
    clear_has_action_info();
    ::autofill_assistant::SaveGeneratedPasswordProto* temp = action_info_.save_generated_password_;
    action_info_.save_generated_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_save_generated_password(::autofill_assistant::SaveGeneratedPasswordProto* save_generated_password) {
  clear_action_info();
  if (save_generated_password) {
    set_has_save_generated_password();
    action_info_.save_generated_password_ = save_generated_password;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.save_generated_password)
}
inline ::autofill_assistant::SaveGeneratedPasswordProto* ActionProto::_internal_mutable_save_generated_password() {
  if (!_internal_has_save_generated_password()) {
    clear_action_info();
    set_has_save_generated_password();
    action_info_.save_generated_password_ = CreateMaybeMessage< ::autofill_assistant::SaveGeneratedPasswordProto >(GetArenaForAllocation());
  }
  return action_info_.save_generated_password_;
}
inline ::autofill_assistant::SaveGeneratedPasswordProto* ActionProto::mutable_save_generated_password() {
  ::autofill_assistant::SaveGeneratedPasswordProto* _msg = _internal_mutable_save_generated_password();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.save_generated_password)
  return _msg;
}

// .autofill_assistant.ConfigureUiStateProto configure_ui_state = 54;
inline bool ActionProto::_internal_has_configure_ui_state() const {
  return action_info_case() == kConfigureUiState;
}
inline bool ActionProto::has_configure_ui_state() const {
  return _internal_has_configure_ui_state();
}
inline void ActionProto::set_has_configure_ui_state() {
  _oneof_case_[0] = kConfigureUiState;
}
inline void ActionProto::clear_configure_ui_state() {
  if (_internal_has_configure_ui_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.configure_ui_state_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ConfigureUiStateProto* ActionProto::release_configure_ui_state() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.configure_ui_state)
  if (_internal_has_configure_ui_state()) {
    clear_has_action_info();
    ::autofill_assistant::ConfigureUiStateProto* temp = action_info_.configure_ui_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.configure_ui_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ConfigureUiStateProto& ActionProto::_internal_configure_ui_state() const {
  return _internal_has_configure_ui_state()
      ? *action_info_.configure_ui_state_
      : reinterpret_cast< ::autofill_assistant::ConfigureUiStateProto&>(::autofill_assistant::_ConfigureUiStateProto_default_instance_);
}
inline const ::autofill_assistant::ConfigureUiStateProto& ActionProto::configure_ui_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.configure_ui_state)
  return _internal_configure_ui_state();
}
inline ::autofill_assistant::ConfigureUiStateProto* ActionProto::unsafe_arena_release_configure_ui_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.configure_ui_state)
  if (_internal_has_configure_ui_state()) {
    clear_has_action_info();
    ::autofill_assistant::ConfigureUiStateProto* temp = action_info_.configure_ui_state_;
    action_info_.configure_ui_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_configure_ui_state(::autofill_assistant::ConfigureUiStateProto* configure_ui_state) {
  clear_action_info();
  if (configure_ui_state) {
    set_has_configure_ui_state();
    action_info_.configure_ui_state_ = configure_ui_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.configure_ui_state)
}
inline ::autofill_assistant::ConfigureUiStateProto* ActionProto::_internal_mutable_configure_ui_state() {
  if (!_internal_has_configure_ui_state()) {
    clear_action_info();
    set_has_configure_ui_state();
    action_info_.configure_ui_state_ = CreateMaybeMessage< ::autofill_assistant::ConfigureUiStateProto >(GetArenaForAllocation());
  }
  return action_info_.configure_ui_state_;
}
inline ::autofill_assistant::ConfigureUiStateProto* ActionProto::mutable_configure_ui_state() {
  ::autofill_assistant::ConfigureUiStateProto* _msg = _internal_mutable_configure_ui_state();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.configure_ui_state)
  return _msg;
}

// .autofill_assistant.PresaveGeneratedPasswordProto presave_generated_password = 55;
inline bool ActionProto::_internal_has_presave_generated_password() const {
  return action_info_case() == kPresaveGeneratedPassword;
}
inline bool ActionProto::has_presave_generated_password() const {
  return _internal_has_presave_generated_password();
}
inline void ActionProto::set_has_presave_generated_password() {
  _oneof_case_[0] = kPresaveGeneratedPassword;
}
inline void ActionProto::clear_presave_generated_password() {
  if (_internal_has_presave_generated_password()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.presave_generated_password_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::PresaveGeneratedPasswordProto* ActionProto::release_presave_generated_password() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.presave_generated_password)
  if (_internal_has_presave_generated_password()) {
    clear_has_action_info();
    ::autofill_assistant::PresaveGeneratedPasswordProto* temp = action_info_.presave_generated_password_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.presave_generated_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PresaveGeneratedPasswordProto& ActionProto::_internal_presave_generated_password() const {
  return _internal_has_presave_generated_password()
      ? *action_info_.presave_generated_password_
      : reinterpret_cast< ::autofill_assistant::PresaveGeneratedPasswordProto&>(::autofill_assistant::_PresaveGeneratedPasswordProto_default_instance_);
}
inline const ::autofill_assistant::PresaveGeneratedPasswordProto& ActionProto::presave_generated_password() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.presave_generated_password)
  return _internal_presave_generated_password();
}
inline ::autofill_assistant::PresaveGeneratedPasswordProto* ActionProto::unsafe_arena_release_presave_generated_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.presave_generated_password)
  if (_internal_has_presave_generated_password()) {
    clear_has_action_info();
    ::autofill_assistant::PresaveGeneratedPasswordProto* temp = action_info_.presave_generated_password_;
    action_info_.presave_generated_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_presave_generated_password(::autofill_assistant::PresaveGeneratedPasswordProto* presave_generated_password) {
  clear_action_info();
  if (presave_generated_password) {
    set_has_presave_generated_password();
    action_info_.presave_generated_password_ = presave_generated_password;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.presave_generated_password)
}
inline ::autofill_assistant::PresaveGeneratedPasswordProto* ActionProto::_internal_mutable_presave_generated_password() {
  if (!_internal_has_presave_generated_password()) {
    clear_action_info();
    set_has_presave_generated_password();
    action_info_.presave_generated_password_ = CreateMaybeMessage< ::autofill_assistant::PresaveGeneratedPasswordProto >(GetArenaForAllocation());
  }
  return action_info_.presave_generated_password_;
}
inline ::autofill_assistant::PresaveGeneratedPasswordProto* ActionProto::mutable_presave_generated_password() {
  ::autofill_assistant::PresaveGeneratedPasswordProto* _msg = _internal_mutable_presave_generated_password();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.presave_generated_password)
  return _msg;
}

// .autofill_assistant.GetElementStatusProto get_element_status = 56;
inline bool ActionProto::_internal_has_get_element_status() const {
  return action_info_case() == kGetElementStatus;
}
inline bool ActionProto::has_get_element_status() const {
  return _internal_has_get_element_status();
}
inline void ActionProto::set_has_get_element_status() {
  _oneof_case_[0] = kGetElementStatus;
}
inline void ActionProto::clear_get_element_status() {
  if (_internal_has_get_element_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.get_element_status_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::GetElementStatusProto* ActionProto::release_get_element_status() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.get_element_status)
  if (_internal_has_get_element_status()) {
    clear_has_action_info();
    ::autofill_assistant::GetElementStatusProto* temp = action_info_.get_element_status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.get_element_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::GetElementStatusProto& ActionProto::_internal_get_element_status() const {
  return _internal_has_get_element_status()
      ? *action_info_.get_element_status_
      : reinterpret_cast< ::autofill_assistant::GetElementStatusProto&>(::autofill_assistant::_GetElementStatusProto_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto& ActionProto::get_element_status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.get_element_status)
  return _internal_get_element_status();
}
inline ::autofill_assistant::GetElementStatusProto* ActionProto::unsafe_arena_release_get_element_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.get_element_status)
  if (_internal_has_get_element_status()) {
    clear_has_action_info();
    ::autofill_assistant::GetElementStatusProto* temp = action_info_.get_element_status_;
    action_info_.get_element_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_get_element_status(::autofill_assistant::GetElementStatusProto* get_element_status) {
  clear_action_info();
  if (get_element_status) {
    set_has_get_element_status();
    action_info_.get_element_status_ = get_element_status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.get_element_status)
}
inline ::autofill_assistant::GetElementStatusProto* ActionProto::_internal_mutable_get_element_status() {
  if (!_internal_has_get_element_status()) {
    clear_action_info();
    set_has_get_element_status();
    action_info_.get_element_status_ = CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto >(GetArenaForAllocation());
  }
  return action_info_.get_element_status_;
}
inline ::autofill_assistant::GetElementStatusProto* ActionProto::mutable_get_element_status() {
  ::autofill_assistant::GetElementStatusProto* _msg = _internal_mutable_get_element_status();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.get_element_status)
  return _msg;
}

// .autofill_assistant.ScrollIntoViewProto scroll_into_view = 57;
inline bool ActionProto::_internal_has_scroll_into_view() const {
  return action_info_case() == kScrollIntoView;
}
inline bool ActionProto::has_scroll_into_view() const {
  return _internal_has_scroll_into_view();
}
inline void ActionProto::set_has_scroll_into_view() {
  _oneof_case_[0] = kScrollIntoView;
}
inline ::autofill_assistant::ScrollIntoViewProto* ActionProto::release_scroll_into_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.scroll_into_view)
  if (_internal_has_scroll_into_view()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollIntoViewProto* temp = action_info_.scroll_into_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.scroll_into_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ScrollIntoViewProto& ActionProto::_internal_scroll_into_view() const {
  return _internal_has_scroll_into_view()
      ? *action_info_.scroll_into_view_
      : reinterpret_cast< ::autofill_assistant::ScrollIntoViewProto&>(::autofill_assistant::_ScrollIntoViewProto_default_instance_);
}
inline const ::autofill_assistant::ScrollIntoViewProto& ActionProto::scroll_into_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.scroll_into_view)
  return _internal_scroll_into_view();
}
inline ::autofill_assistant::ScrollIntoViewProto* ActionProto::unsafe_arena_release_scroll_into_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.scroll_into_view)
  if (_internal_has_scroll_into_view()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollIntoViewProto* temp = action_info_.scroll_into_view_;
    action_info_.scroll_into_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_scroll_into_view(::autofill_assistant::ScrollIntoViewProto* scroll_into_view) {
  clear_action_info();
  if (scroll_into_view) {
    set_has_scroll_into_view();
    action_info_.scroll_into_view_ = scroll_into_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.scroll_into_view)
}
inline ::autofill_assistant::ScrollIntoViewProto* ActionProto::_internal_mutable_scroll_into_view() {
  if (!_internal_has_scroll_into_view()) {
    clear_action_info();
    set_has_scroll_into_view();
    action_info_.scroll_into_view_ = CreateMaybeMessage< ::autofill_assistant::ScrollIntoViewProto >(GetArenaForAllocation());
  }
  return action_info_.scroll_into_view_;
}
inline ::autofill_assistant::ScrollIntoViewProto* ActionProto::mutable_scroll_into_view() {
  ::autofill_assistant::ScrollIntoViewProto* _msg = _internal_mutable_scroll_into_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.scroll_into_view)
  return _msg;
}

// .autofill_assistant.WaitForDocumentToBecomeInteractiveProto wait_for_document_to_become_interactive = 58;
inline bool ActionProto::_internal_has_wait_for_document_to_become_interactive() const {
  return action_info_case() == kWaitForDocumentToBecomeInteractive;
}
inline bool ActionProto::has_wait_for_document_to_become_interactive() const {
  return _internal_has_wait_for_document_to_become_interactive();
}
inline void ActionProto::set_has_wait_for_document_to_become_interactive() {
  _oneof_case_[0] = kWaitForDocumentToBecomeInteractive;
}
inline ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* ActionProto::release_wait_for_document_to_become_interactive() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.wait_for_document_to_become_interactive)
  if (_internal_has_wait_for_document_to_become_interactive()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* temp = action_info_.wait_for_document_to_become_interactive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.wait_for_document_to_become_interactive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto& ActionProto::_internal_wait_for_document_to_become_interactive() const {
  return _internal_has_wait_for_document_to_become_interactive()
      ? *action_info_.wait_for_document_to_become_interactive_
      : reinterpret_cast< ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto&>(::autofill_assistant::_WaitForDocumentToBecomeInteractiveProto_default_instance_);
}
inline const ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto& ActionProto::wait_for_document_to_become_interactive() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.wait_for_document_to_become_interactive)
  return _internal_wait_for_document_to_become_interactive();
}
inline ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* ActionProto::unsafe_arena_release_wait_for_document_to_become_interactive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.wait_for_document_to_become_interactive)
  if (_internal_has_wait_for_document_to_become_interactive()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* temp = action_info_.wait_for_document_to_become_interactive_;
    action_info_.wait_for_document_to_become_interactive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_wait_for_document_to_become_interactive(::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* wait_for_document_to_become_interactive) {
  clear_action_info();
  if (wait_for_document_to_become_interactive) {
    set_has_wait_for_document_to_become_interactive();
    action_info_.wait_for_document_to_become_interactive_ = wait_for_document_to_become_interactive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.wait_for_document_to_become_interactive)
}
inline ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* ActionProto::_internal_mutable_wait_for_document_to_become_interactive() {
  if (!_internal_has_wait_for_document_to_become_interactive()) {
    clear_action_info();
    set_has_wait_for_document_to_become_interactive();
    action_info_.wait_for_document_to_become_interactive_ = CreateMaybeMessage< ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto >(GetArenaForAllocation());
  }
  return action_info_.wait_for_document_to_become_interactive_;
}
inline ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* ActionProto::mutable_wait_for_document_to_become_interactive() {
  ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* _msg = _internal_mutable_wait_for_document_to_become_interactive();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.wait_for_document_to_become_interactive)
  return _msg;
}

// .autofill_assistant.WaitForDocumentToBecomeCompleteProto wait_for_document_to_become_complete = 59;
inline bool ActionProto::_internal_has_wait_for_document_to_become_complete() const {
  return action_info_case() == kWaitForDocumentToBecomeComplete;
}
inline bool ActionProto::has_wait_for_document_to_become_complete() const {
  return _internal_has_wait_for_document_to_become_complete();
}
inline void ActionProto::set_has_wait_for_document_to_become_complete() {
  _oneof_case_[0] = kWaitForDocumentToBecomeComplete;
}
inline ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* ActionProto::release_wait_for_document_to_become_complete() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.wait_for_document_to_become_complete)
  if (_internal_has_wait_for_document_to_become_complete()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* temp = action_info_.wait_for_document_to_become_complete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.wait_for_document_to_become_complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForDocumentToBecomeCompleteProto& ActionProto::_internal_wait_for_document_to_become_complete() const {
  return _internal_has_wait_for_document_to_become_complete()
      ? *action_info_.wait_for_document_to_become_complete_
      : reinterpret_cast< ::autofill_assistant::WaitForDocumentToBecomeCompleteProto&>(::autofill_assistant::_WaitForDocumentToBecomeCompleteProto_default_instance_);
}
inline const ::autofill_assistant::WaitForDocumentToBecomeCompleteProto& ActionProto::wait_for_document_to_become_complete() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.wait_for_document_to_become_complete)
  return _internal_wait_for_document_to_become_complete();
}
inline ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* ActionProto::unsafe_arena_release_wait_for_document_to_become_complete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.wait_for_document_to_become_complete)
  if (_internal_has_wait_for_document_to_become_complete()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* temp = action_info_.wait_for_document_to_become_complete_;
    action_info_.wait_for_document_to_become_complete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_wait_for_document_to_become_complete(::autofill_assistant::WaitForDocumentToBecomeCompleteProto* wait_for_document_to_become_complete) {
  clear_action_info();
  if (wait_for_document_to_become_complete) {
    set_has_wait_for_document_to_become_complete();
    action_info_.wait_for_document_to_become_complete_ = wait_for_document_to_become_complete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.wait_for_document_to_become_complete)
}
inline ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* ActionProto::_internal_mutable_wait_for_document_to_become_complete() {
  if (!_internal_has_wait_for_document_to_become_complete()) {
    clear_action_info();
    set_has_wait_for_document_to_become_complete();
    action_info_.wait_for_document_to_become_complete_ = CreateMaybeMessage< ::autofill_assistant::WaitForDocumentToBecomeCompleteProto >(GetArenaForAllocation());
  }
  return action_info_.wait_for_document_to_become_complete_;
}
inline ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* ActionProto::mutable_wait_for_document_to_become_complete() {
  ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* _msg = _internal_mutable_wait_for_document_to_become_complete();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.wait_for_document_to_become_complete)
  return _msg;
}

// .autofill_assistant.SendClickEventProto send_click_event = 60;
inline bool ActionProto::_internal_has_send_click_event() const {
  return action_info_case() == kSendClickEvent;
}
inline bool ActionProto::has_send_click_event() const {
  return _internal_has_send_click_event();
}
inline void ActionProto::set_has_send_click_event() {
  _oneof_case_[0] = kSendClickEvent;
}
inline ::autofill_assistant::SendClickEventProto* ActionProto::release_send_click_event() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.send_click_event)
  if (_internal_has_send_click_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendClickEventProto* temp = action_info_.send_click_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.send_click_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SendClickEventProto& ActionProto::_internal_send_click_event() const {
  return _internal_has_send_click_event()
      ? *action_info_.send_click_event_
      : reinterpret_cast< ::autofill_assistant::SendClickEventProto&>(::autofill_assistant::_SendClickEventProto_default_instance_);
}
inline const ::autofill_assistant::SendClickEventProto& ActionProto::send_click_event() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.send_click_event)
  return _internal_send_click_event();
}
inline ::autofill_assistant::SendClickEventProto* ActionProto::unsafe_arena_release_send_click_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.send_click_event)
  if (_internal_has_send_click_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendClickEventProto* temp = action_info_.send_click_event_;
    action_info_.send_click_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_send_click_event(::autofill_assistant::SendClickEventProto* send_click_event) {
  clear_action_info();
  if (send_click_event) {
    set_has_send_click_event();
    action_info_.send_click_event_ = send_click_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.send_click_event)
}
inline ::autofill_assistant::SendClickEventProto* ActionProto::_internal_mutable_send_click_event() {
  if (!_internal_has_send_click_event()) {
    clear_action_info();
    set_has_send_click_event();
    action_info_.send_click_event_ = CreateMaybeMessage< ::autofill_assistant::SendClickEventProto >(GetArenaForAllocation());
  }
  return action_info_.send_click_event_;
}
inline ::autofill_assistant::SendClickEventProto* ActionProto::mutable_send_click_event() {
  ::autofill_assistant::SendClickEventProto* _msg = _internal_mutable_send_click_event();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.send_click_event)
  return _msg;
}

// .autofill_assistant.SendTapEventProto send_tap_event = 61;
inline bool ActionProto::_internal_has_send_tap_event() const {
  return action_info_case() == kSendTapEvent;
}
inline bool ActionProto::has_send_tap_event() const {
  return _internal_has_send_tap_event();
}
inline void ActionProto::set_has_send_tap_event() {
  _oneof_case_[0] = kSendTapEvent;
}
inline ::autofill_assistant::SendTapEventProto* ActionProto::release_send_tap_event() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.send_tap_event)
  if (_internal_has_send_tap_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendTapEventProto* temp = action_info_.send_tap_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.send_tap_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SendTapEventProto& ActionProto::_internal_send_tap_event() const {
  return _internal_has_send_tap_event()
      ? *action_info_.send_tap_event_
      : reinterpret_cast< ::autofill_assistant::SendTapEventProto&>(::autofill_assistant::_SendTapEventProto_default_instance_);
}
inline const ::autofill_assistant::SendTapEventProto& ActionProto::send_tap_event() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.send_tap_event)
  return _internal_send_tap_event();
}
inline ::autofill_assistant::SendTapEventProto* ActionProto::unsafe_arena_release_send_tap_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.send_tap_event)
  if (_internal_has_send_tap_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendTapEventProto* temp = action_info_.send_tap_event_;
    action_info_.send_tap_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_send_tap_event(::autofill_assistant::SendTapEventProto* send_tap_event) {
  clear_action_info();
  if (send_tap_event) {
    set_has_send_tap_event();
    action_info_.send_tap_event_ = send_tap_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.send_tap_event)
}
inline ::autofill_assistant::SendTapEventProto* ActionProto::_internal_mutable_send_tap_event() {
  if (!_internal_has_send_tap_event()) {
    clear_action_info();
    set_has_send_tap_event();
    action_info_.send_tap_event_ = CreateMaybeMessage< ::autofill_assistant::SendTapEventProto >(GetArenaForAllocation());
  }
  return action_info_.send_tap_event_;
}
inline ::autofill_assistant::SendTapEventProto* ActionProto::mutable_send_tap_event() {
  ::autofill_assistant::SendTapEventProto* _msg = _internal_mutable_send_tap_event();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.send_tap_event)
  return _msg;
}

// .autofill_assistant.JsClickProto js_click = 62;
inline bool ActionProto::_internal_has_js_click() const {
  return action_info_case() == kJsClick;
}
inline bool ActionProto::has_js_click() const {
  return _internal_has_js_click();
}
inline void ActionProto::set_has_js_click() {
  _oneof_case_[0] = kJsClick;
}
inline ::autofill_assistant::JsClickProto* ActionProto::release_js_click() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.js_click)
  if (_internal_has_js_click()) {
    clear_has_action_info();
    ::autofill_assistant::JsClickProto* temp = action_info_.js_click_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.js_click_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::JsClickProto& ActionProto::_internal_js_click() const {
  return _internal_has_js_click()
      ? *action_info_.js_click_
      : reinterpret_cast< ::autofill_assistant::JsClickProto&>(::autofill_assistant::_JsClickProto_default_instance_);
}
inline const ::autofill_assistant::JsClickProto& ActionProto::js_click() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.js_click)
  return _internal_js_click();
}
inline ::autofill_assistant::JsClickProto* ActionProto::unsafe_arena_release_js_click() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.js_click)
  if (_internal_has_js_click()) {
    clear_has_action_info();
    ::autofill_assistant::JsClickProto* temp = action_info_.js_click_;
    action_info_.js_click_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_js_click(::autofill_assistant::JsClickProto* js_click) {
  clear_action_info();
  if (js_click) {
    set_has_js_click();
    action_info_.js_click_ = js_click;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.js_click)
}
inline ::autofill_assistant::JsClickProto* ActionProto::_internal_mutable_js_click() {
  if (!_internal_has_js_click()) {
    clear_action_info();
    set_has_js_click();
    action_info_.js_click_ = CreateMaybeMessage< ::autofill_assistant::JsClickProto >(GetArenaForAllocation());
  }
  return action_info_.js_click_;
}
inline ::autofill_assistant::JsClickProto* ActionProto::mutable_js_click() {
  ::autofill_assistant::JsClickProto* _msg = _internal_mutable_js_click();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.js_click)
  return _msg;
}

// .autofill_assistant.SendKeystrokeEventsProto send_keystroke_events = 63;
inline bool ActionProto::_internal_has_send_keystroke_events() const {
  return action_info_case() == kSendKeystrokeEvents;
}
inline bool ActionProto::has_send_keystroke_events() const {
  return _internal_has_send_keystroke_events();
}
inline void ActionProto::set_has_send_keystroke_events() {
  _oneof_case_[0] = kSendKeystrokeEvents;
}
inline ::autofill_assistant::SendKeystrokeEventsProto* ActionProto::release_send_keystroke_events() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.send_keystroke_events)
  if (_internal_has_send_keystroke_events()) {
    clear_has_action_info();
    ::autofill_assistant::SendKeystrokeEventsProto* temp = action_info_.send_keystroke_events_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.send_keystroke_events_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SendKeystrokeEventsProto& ActionProto::_internal_send_keystroke_events() const {
  return _internal_has_send_keystroke_events()
      ? *action_info_.send_keystroke_events_
      : reinterpret_cast< ::autofill_assistant::SendKeystrokeEventsProto&>(::autofill_assistant::_SendKeystrokeEventsProto_default_instance_);
}
inline const ::autofill_assistant::SendKeystrokeEventsProto& ActionProto::send_keystroke_events() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.send_keystroke_events)
  return _internal_send_keystroke_events();
}
inline ::autofill_assistant::SendKeystrokeEventsProto* ActionProto::unsafe_arena_release_send_keystroke_events() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.send_keystroke_events)
  if (_internal_has_send_keystroke_events()) {
    clear_has_action_info();
    ::autofill_assistant::SendKeystrokeEventsProto* temp = action_info_.send_keystroke_events_;
    action_info_.send_keystroke_events_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_send_keystroke_events(::autofill_assistant::SendKeystrokeEventsProto* send_keystroke_events) {
  clear_action_info();
  if (send_keystroke_events) {
    set_has_send_keystroke_events();
    action_info_.send_keystroke_events_ = send_keystroke_events;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.send_keystroke_events)
}
inline ::autofill_assistant::SendKeystrokeEventsProto* ActionProto::_internal_mutable_send_keystroke_events() {
  if (!_internal_has_send_keystroke_events()) {
    clear_action_info();
    set_has_send_keystroke_events();
    action_info_.send_keystroke_events_ = CreateMaybeMessage< ::autofill_assistant::SendKeystrokeEventsProto >(GetArenaForAllocation());
  }
  return action_info_.send_keystroke_events_;
}
inline ::autofill_assistant::SendKeystrokeEventsProto* ActionProto::mutable_send_keystroke_events() {
  ::autofill_assistant::SendKeystrokeEventsProto* _msg = _internal_mutable_send_keystroke_events();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.send_keystroke_events)
  return _msg;
}

// .autofill_assistant.SendChangeEventProto send_change_event = 64;
inline bool ActionProto::_internal_has_send_change_event() const {
  return action_info_case() == kSendChangeEvent;
}
inline bool ActionProto::has_send_change_event() const {
  return _internal_has_send_change_event();
}
inline void ActionProto::set_has_send_change_event() {
  _oneof_case_[0] = kSendChangeEvent;
}
inline ::autofill_assistant::SendChangeEventProto* ActionProto::release_send_change_event() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.send_change_event)
  if (_internal_has_send_change_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendChangeEventProto* temp = action_info_.send_change_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.send_change_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SendChangeEventProto& ActionProto::_internal_send_change_event() const {
  return _internal_has_send_change_event()
      ? *action_info_.send_change_event_
      : reinterpret_cast< ::autofill_assistant::SendChangeEventProto&>(::autofill_assistant::_SendChangeEventProto_default_instance_);
}
inline const ::autofill_assistant::SendChangeEventProto& ActionProto::send_change_event() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.send_change_event)
  return _internal_send_change_event();
}
inline ::autofill_assistant::SendChangeEventProto* ActionProto::unsafe_arena_release_send_change_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.send_change_event)
  if (_internal_has_send_change_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendChangeEventProto* temp = action_info_.send_change_event_;
    action_info_.send_change_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_send_change_event(::autofill_assistant::SendChangeEventProto* send_change_event) {
  clear_action_info();
  if (send_change_event) {
    set_has_send_change_event();
    action_info_.send_change_event_ = send_change_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.send_change_event)
}
inline ::autofill_assistant::SendChangeEventProto* ActionProto::_internal_mutable_send_change_event() {
  if (!_internal_has_send_change_event()) {
    clear_action_info();
    set_has_send_change_event();
    action_info_.send_change_event_ = CreateMaybeMessage< ::autofill_assistant::SendChangeEventProto >(GetArenaForAllocation());
  }
  return action_info_.send_change_event_;
}
inline ::autofill_assistant::SendChangeEventProto* ActionProto::mutable_send_change_event() {
  ::autofill_assistant::SendChangeEventProto* _msg = _internal_mutable_send_change_event();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.send_change_event)
  return _msg;
}

// .autofill_assistant.SetElementAttributeProto set_element_attribute = 65;
inline bool ActionProto::_internal_has_set_element_attribute() const {
  return action_info_case() == kSetElementAttribute;
}
inline bool ActionProto::has_set_element_attribute() const {
  return _internal_has_set_element_attribute();
}
inline void ActionProto::set_has_set_element_attribute() {
  _oneof_case_[0] = kSetElementAttribute;
}
inline ::autofill_assistant::SetElementAttributeProto* ActionProto::release_set_element_attribute() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.set_element_attribute)
  if (_internal_has_set_element_attribute()) {
    clear_has_action_info();
    ::autofill_assistant::SetElementAttributeProto* temp = action_info_.set_element_attribute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.set_element_attribute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetElementAttributeProto& ActionProto::_internal_set_element_attribute() const {
  return _internal_has_set_element_attribute()
      ? *action_info_.set_element_attribute_
      : reinterpret_cast< ::autofill_assistant::SetElementAttributeProto&>(::autofill_assistant::_SetElementAttributeProto_default_instance_);
}
inline const ::autofill_assistant::SetElementAttributeProto& ActionProto::set_element_attribute() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.set_element_attribute)
  return _internal_set_element_attribute();
}
inline ::autofill_assistant::SetElementAttributeProto* ActionProto::unsafe_arena_release_set_element_attribute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.set_element_attribute)
  if (_internal_has_set_element_attribute()) {
    clear_has_action_info();
    ::autofill_assistant::SetElementAttributeProto* temp = action_info_.set_element_attribute_;
    action_info_.set_element_attribute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_set_element_attribute(::autofill_assistant::SetElementAttributeProto* set_element_attribute) {
  clear_action_info();
  if (set_element_attribute) {
    set_has_set_element_attribute();
    action_info_.set_element_attribute_ = set_element_attribute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.set_element_attribute)
}
inline ::autofill_assistant::SetElementAttributeProto* ActionProto::_internal_mutable_set_element_attribute() {
  if (!_internal_has_set_element_attribute()) {
    clear_action_info();
    set_has_set_element_attribute();
    action_info_.set_element_attribute_ = CreateMaybeMessage< ::autofill_assistant::SetElementAttributeProto >(GetArenaForAllocation());
  }
  return action_info_.set_element_attribute_;
}
inline ::autofill_assistant::SetElementAttributeProto* ActionProto::mutable_set_element_attribute() {
  ::autofill_assistant::SetElementAttributeProto* _msg = _internal_mutable_set_element_attribute();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.set_element_attribute)
  return _msg;
}

// .autofill_assistant.SelectFieldValueProto select_field_value = 66;
inline bool ActionProto::_internal_has_select_field_value() const {
  return action_info_case() == kSelectFieldValue;
}
inline bool ActionProto::has_select_field_value() const {
  return _internal_has_select_field_value();
}
inline void ActionProto::set_has_select_field_value() {
  _oneof_case_[0] = kSelectFieldValue;
}
inline ::autofill_assistant::SelectFieldValueProto* ActionProto::release_select_field_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.select_field_value)
  if (_internal_has_select_field_value()) {
    clear_has_action_info();
    ::autofill_assistant::SelectFieldValueProto* temp = action_info_.select_field_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.select_field_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectFieldValueProto& ActionProto::_internal_select_field_value() const {
  return _internal_has_select_field_value()
      ? *action_info_.select_field_value_
      : reinterpret_cast< ::autofill_assistant::SelectFieldValueProto&>(::autofill_assistant::_SelectFieldValueProto_default_instance_);
}
inline const ::autofill_assistant::SelectFieldValueProto& ActionProto::select_field_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.select_field_value)
  return _internal_select_field_value();
}
inline ::autofill_assistant::SelectFieldValueProto* ActionProto::unsafe_arena_release_select_field_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.select_field_value)
  if (_internal_has_select_field_value()) {
    clear_has_action_info();
    ::autofill_assistant::SelectFieldValueProto* temp = action_info_.select_field_value_;
    action_info_.select_field_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_select_field_value(::autofill_assistant::SelectFieldValueProto* select_field_value) {
  clear_action_info();
  if (select_field_value) {
    set_has_select_field_value();
    action_info_.select_field_value_ = select_field_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.select_field_value)
}
inline ::autofill_assistant::SelectFieldValueProto* ActionProto::_internal_mutable_select_field_value() {
  if (!_internal_has_select_field_value()) {
    clear_action_info();
    set_has_select_field_value();
    action_info_.select_field_value_ = CreateMaybeMessage< ::autofill_assistant::SelectFieldValueProto >(GetArenaForAllocation());
  }
  return action_info_.select_field_value_;
}
inline ::autofill_assistant::SelectFieldValueProto* ActionProto::mutable_select_field_value() {
  ::autofill_assistant::SelectFieldValueProto* _msg = _internal_mutable_select_field_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.select_field_value)
  return _msg;
}

// .autofill_assistant.FocusFieldProto focus_field = 67;
inline bool ActionProto::_internal_has_focus_field() const {
  return action_info_case() == kFocusField;
}
inline bool ActionProto::has_focus_field() const {
  return _internal_has_focus_field();
}
inline void ActionProto::set_has_focus_field() {
  _oneof_case_[0] = kFocusField;
}
inline ::autofill_assistant::FocusFieldProto* ActionProto::release_focus_field() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.focus_field)
  if (_internal_has_focus_field()) {
    clear_has_action_info();
    ::autofill_assistant::FocusFieldProto* temp = action_info_.focus_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.focus_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::FocusFieldProto& ActionProto::_internal_focus_field() const {
  return _internal_has_focus_field()
      ? *action_info_.focus_field_
      : reinterpret_cast< ::autofill_assistant::FocusFieldProto&>(::autofill_assistant::_FocusFieldProto_default_instance_);
}
inline const ::autofill_assistant::FocusFieldProto& ActionProto::focus_field() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.focus_field)
  return _internal_focus_field();
}
inline ::autofill_assistant::FocusFieldProto* ActionProto::unsafe_arena_release_focus_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.focus_field)
  if (_internal_has_focus_field()) {
    clear_has_action_info();
    ::autofill_assistant::FocusFieldProto* temp = action_info_.focus_field_;
    action_info_.focus_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_focus_field(::autofill_assistant::FocusFieldProto* focus_field) {
  clear_action_info();
  if (focus_field) {
    set_has_focus_field();
    action_info_.focus_field_ = focus_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.focus_field)
}
inline ::autofill_assistant::FocusFieldProto* ActionProto::_internal_mutable_focus_field() {
  if (!_internal_has_focus_field()) {
    clear_action_info();
    set_has_focus_field();
    action_info_.focus_field_ = CreateMaybeMessage< ::autofill_assistant::FocusFieldProto >(GetArenaForAllocation());
  }
  return action_info_.focus_field_;
}
inline ::autofill_assistant::FocusFieldProto* ActionProto::mutable_focus_field() {
  ::autofill_assistant::FocusFieldProto* _msg = _internal_mutable_focus_field();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.focus_field)
  return _msg;
}

// .autofill_assistant.WaitForElementToBecomeStableProto wait_for_element_to_become_stable = 68;
inline bool ActionProto::_internal_has_wait_for_element_to_become_stable() const {
  return action_info_case() == kWaitForElementToBecomeStable;
}
inline bool ActionProto::has_wait_for_element_to_become_stable() const {
  return _internal_has_wait_for_element_to_become_stable();
}
inline void ActionProto::set_has_wait_for_element_to_become_stable() {
  _oneof_case_[0] = kWaitForElementToBecomeStable;
}
inline ::autofill_assistant::WaitForElementToBecomeStableProto* ActionProto::release_wait_for_element_to_become_stable() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.wait_for_element_to_become_stable)
  if (_internal_has_wait_for_element_to_become_stable()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForElementToBecomeStableProto* temp = action_info_.wait_for_element_to_become_stable_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.wait_for_element_to_become_stable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForElementToBecomeStableProto& ActionProto::_internal_wait_for_element_to_become_stable() const {
  return _internal_has_wait_for_element_to_become_stable()
      ? *action_info_.wait_for_element_to_become_stable_
      : reinterpret_cast< ::autofill_assistant::WaitForElementToBecomeStableProto&>(::autofill_assistant::_WaitForElementToBecomeStableProto_default_instance_);
}
inline const ::autofill_assistant::WaitForElementToBecomeStableProto& ActionProto::wait_for_element_to_become_stable() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.wait_for_element_to_become_stable)
  return _internal_wait_for_element_to_become_stable();
}
inline ::autofill_assistant::WaitForElementToBecomeStableProto* ActionProto::unsafe_arena_release_wait_for_element_to_become_stable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.wait_for_element_to_become_stable)
  if (_internal_has_wait_for_element_to_become_stable()) {
    clear_has_action_info();
    ::autofill_assistant::WaitForElementToBecomeStableProto* temp = action_info_.wait_for_element_to_become_stable_;
    action_info_.wait_for_element_to_become_stable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_wait_for_element_to_become_stable(::autofill_assistant::WaitForElementToBecomeStableProto* wait_for_element_to_become_stable) {
  clear_action_info();
  if (wait_for_element_to_become_stable) {
    set_has_wait_for_element_to_become_stable();
    action_info_.wait_for_element_to_become_stable_ = wait_for_element_to_become_stable;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.wait_for_element_to_become_stable)
}
inline ::autofill_assistant::WaitForElementToBecomeStableProto* ActionProto::_internal_mutable_wait_for_element_to_become_stable() {
  if (!_internal_has_wait_for_element_to_become_stable()) {
    clear_action_info();
    set_has_wait_for_element_to_become_stable();
    action_info_.wait_for_element_to_become_stable_ = CreateMaybeMessage< ::autofill_assistant::WaitForElementToBecomeStableProto >(GetArenaForAllocation());
  }
  return action_info_.wait_for_element_to_become_stable_;
}
inline ::autofill_assistant::WaitForElementToBecomeStableProto* ActionProto::mutable_wait_for_element_to_become_stable() {
  ::autofill_assistant::WaitForElementToBecomeStableProto* _msg = _internal_mutable_wait_for_element_to_become_stable();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.wait_for_element_to_become_stable)
  return _msg;
}

// .autofill_assistant.CheckElementIsOnTopProto check_element_is_on_top = 69;
inline bool ActionProto::_internal_has_check_element_is_on_top() const {
  return action_info_case() == kCheckElementIsOnTop;
}
inline bool ActionProto::has_check_element_is_on_top() const {
  return _internal_has_check_element_is_on_top();
}
inline void ActionProto::set_has_check_element_is_on_top() {
  _oneof_case_[0] = kCheckElementIsOnTop;
}
inline ::autofill_assistant::CheckElementIsOnTopProto* ActionProto::release_check_element_is_on_top() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.check_element_is_on_top)
  if (_internal_has_check_element_is_on_top()) {
    clear_has_action_info();
    ::autofill_assistant::CheckElementIsOnTopProto* temp = action_info_.check_element_is_on_top_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.check_element_is_on_top_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CheckElementIsOnTopProto& ActionProto::_internal_check_element_is_on_top() const {
  return _internal_has_check_element_is_on_top()
      ? *action_info_.check_element_is_on_top_
      : reinterpret_cast< ::autofill_assistant::CheckElementIsOnTopProto&>(::autofill_assistant::_CheckElementIsOnTopProto_default_instance_);
}
inline const ::autofill_assistant::CheckElementIsOnTopProto& ActionProto::check_element_is_on_top() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.check_element_is_on_top)
  return _internal_check_element_is_on_top();
}
inline ::autofill_assistant::CheckElementIsOnTopProto* ActionProto::unsafe_arena_release_check_element_is_on_top() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.check_element_is_on_top)
  if (_internal_has_check_element_is_on_top()) {
    clear_has_action_info();
    ::autofill_assistant::CheckElementIsOnTopProto* temp = action_info_.check_element_is_on_top_;
    action_info_.check_element_is_on_top_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_check_element_is_on_top(::autofill_assistant::CheckElementIsOnTopProto* check_element_is_on_top) {
  clear_action_info();
  if (check_element_is_on_top) {
    set_has_check_element_is_on_top();
    action_info_.check_element_is_on_top_ = check_element_is_on_top;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.check_element_is_on_top)
}
inline ::autofill_assistant::CheckElementIsOnTopProto* ActionProto::_internal_mutable_check_element_is_on_top() {
  if (!_internal_has_check_element_is_on_top()) {
    clear_action_info();
    set_has_check_element_is_on_top();
    action_info_.check_element_is_on_top_ = CreateMaybeMessage< ::autofill_assistant::CheckElementIsOnTopProto >(GetArenaForAllocation());
  }
  return action_info_.check_element_is_on_top_;
}
inline ::autofill_assistant::CheckElementIsOnTopProto* ActionProto::mutable_check_element_is_on_top() {
  ::autofill_assistant::CheckElementIsOnTopProto* _msg = _internal_mutable_check_element_is_on_top();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.check_element_is_on_top)
  return _msg;
}

// .autofill_assistant.ReleaseElementsProto release_elements = 70;
inline bool ActionProto::_internal_has_release_elements() const {
  return action_info_case() == kReleaseElements;
}
inline bool ActionProto::has_release_elements() const {
  return _internal_has_release_elements();
}
inline void ActionProto::set_has_release_elements() {
  _oneof_case_[0] = kReleaseElements;
}
inline void ActionProto::clear_release_elements() {
  if (_internal_has_release_elements()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.release_elements_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ReleaseElementsProto* ActionProto::release_release_elements() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.release_elements)
  if (_internal_has_release_elements()) {
    clear_has_action_info();
    ::autofill_assistant::ReleaseElementsProto* temp = action_info_.release_elements_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.release_elements_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ReleaseElementsProto& ActionProto::_internal_release_elements() const {
  return _internal_has_release_elements()
      ? *action_info_.release_elements_
      : reinterpret_cast< ::autofill_assistant::ReleaseElementsProto&>(::autofill_assistant::_ReleaseElementsProto_default_instance_);
}
inline const ::autofill_assistant::ReleaseElementsProto& ActionProto::release_elements() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.release_elements)
  return _internal_release_elements();
}
inline ::autofill_assistant::ReleaseElementsProto* ActionProto::unsafe_arena_release_release_elements() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.release_elements)
  if (_internal_has_release_elements()) {
    clear_has_action_info();
    ::autofill_assistant::ReleaseElementsProto* temp = action_info_.release_elements_;
    action_info_.release_elements_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_release_elements(::autofill_assistant::ReleaseElementsProto* release_elements) {
  clear_action_info();
  if (release_elements) {
    set_has_release_elements();
    action_info_.release_elements_ = release_elements;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.release_elements)
}
inline ::autofill_assistant::ReleaseElementsProto* ActionProto::_internal_mutable_release_elements() {
  if (!_internal_has_release_elements()) {
    clear_action_info();
    set_has_release_elements();
    action_info_.release_elements_ = CreateMaybeMessage< ::autofill_assistant::ReleaseElementsProto >(GetArenaForAllocation());
  }
  return action_info_.release_elements_;
}
inline ::autofill_assistant::ReleaseElementsProto* ActionProto::mutable_release_elements() {
  ::autofill_assistant::ReleaseElementsProto* _msg = _internal_mutable_release_elements();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.release_elements)
  return _msg;
}

// .autofill_assistant.DispatchJsEventProto dispatch_js_event = 72;
inline bool ActionProto::_internal_has_dispatch_js_event() const {
  return action_info_case() == kDispatchJsEvent;
}
inline bool ActionProto::has_dispatch_js_event() const {
  return _internal_has_dispatch_js_event();
}
inline void ActionProto::set_has_dispatch_js_event() {
  _oneof_case_[0] = kDispatchJsEvent;
}
inline void ActionProto::clear_dispatch_js_event() {
  if (_internal_has_dispatch_js_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.dispatch_js_event_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::DispatchJsEventProto* ActionProto::release_dispatch_js_event() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.dispatch_js_event)
  if (_internal_has_dispatch_js_event()) {
    clear_has_action_info();
    ::autofill_assistant::DispatchJsEventProto* temp = action_info_.dispatch_js_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.dispatch_js_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DispatchJsEventProto& ActionProto::_internal_dispatch_js_event() const {
  return _internal_has_dispatch_js_event()
      ? *action_info_.dispatch_js_event_
      : reinterpret_cast< ::autofill_assistant::DispatchJsEventProto&>(::autofill_assistant::_DispatchJsEventProto_default_instance_);
}
inline const ::autofill_assistant::DispatchJsEventProto& ActionProto::dispatch_js_event() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.dispatch_js_event)
  return _internal_dispatch_js_event();
}
inline ::autofill_assistant::DispatchJsEventProto* ActionProto::unsafe_arena_release_dispatch_js_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.dispatch_js_event)
  if (_internal_has_dispatch_js_event()) {
    clear_has_action_info();
    ::autofill_assistant::DispatchJsEventProto* temp = action_info_.dispatch_js_event_;
    action_info_.dispatch_js_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_dispatch_js_event(::autofill_assistant::DispatchJsEventProto* dispatch_js_event) {
  clear_action_info();
  if (dispatch_js_event) {
    set_has_dispatch_js_event();
    action_info_.dispatch_js_event_ = dispatch_js_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.dispatch_js_event)
}
inline ::autofill_assistant::DispatchJsEventProto* ActionProto::_internal_mutable_dispatch_js_event() {
  if (!_internal_has_dispatch_js_event()) {
    clear_action_info();
    set_has_dispatch_js_event();
    action_info_.dispatch_js_event_ = CreateMaybeMessage< ::autofill_assistant::DispatchJsEventProto >(GetArenaForAllocation());
  }
  return action_info_.dispatch_js_event_;
}
inline ::autofill_assistant::DispatchJsEventProto* ActionProto::mutable_dispatch_js_event() {
  ::autofill_assistant::DispatchJsEventProto* _msg = _internal_mutable_dispatch_js_event();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.dispatch_js_event)
  return _msg;
}

// .autofill_assistant.SendKeyEventProto send_key_event = 73;
inline bool ActionProto::_internal_has_send_key_event() const {
  return action_info_case() == kSendKeyEvent;
}
inline bool ActionProto::has_send_key_event() const {
  return _internal_has_send_key_event();
}
inline void ActionProto::set_has_send_key_event() {
  _oneof_case_[0] = kSendKeyEvent;
}
inline ::autofill_assistant::SendKeyEventProto* ActionProto::release_send_key_event() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.send_key_event)
  if (_internal_has_send_key_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendKeyEventProto* temp = action_info_.send_key_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.send_key_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SendKeyEventProto& ActionProto::_internal_send_key_event() const {
  return _internal_has_send_key_event()
      ? *action_info_.send_key_event_
      : reinterpret_cast< ::autofill_assistant::SendKeyEventProto&>(::autofill_assistant::_SendKeyEventProto_default_instance_);
}
inline const ::autofill_assistant::SendKeyEventProto& ActionProto::send_key_event() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.send_key_event)
  return _internal_send_key_event();
}
inline ::autofill_assistant::SendKeyEventProto* ActionProto::unsafe_arena_release_send_key_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.send_key_event)
  if (_internal_has_send_key_event()) {
    clear_has_action_info();
    ::autofill_assistant::SendKeyEventProto* temp = action_info_.send_key_event_;
    action_info_.send_key_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_send_key_event(::autofill_assistant::SendKeyEventProto* send_key_event) {
  clear_action_info();
  if (send_key_event) {
    set_has_send_key_event();
    action_info_.send_key_event_ = send_key_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.send_key_event)
}
inline ::autofill_assistant::SendKeyEventProto* ActionProto::_internal_mutable_send_key_event() {
  if (!_internal_has_send_key_event()) {
    clear_action_info();
    set_has_send_key_event();
    action_info_.send_key_event_ = CreateMaybeMessage< ::autofill_assistant::SendKeyEventProto >(GetArenaForAllocation());
  }
  return action_info_.send_key_event_;
}
inline ::autofill_assistant::SendKeyEventProto* ActionProto::mutable_send_key_event() {
  ::autofill_assistant::SendKeyEventProto* _msg = _internal_mutable_send_key_event();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.send_key_event)
  return _msg;
}

// .autofill_assistant.SelectOptionElementProto select_option_element = 74;
inline bool ActionProto::_internal_has_select_option_element() const {
  return action_info_case() == kSelectOptionElement;
}
inline bool ActionProto::has_select_option_element() const {
  return _internal_has_select_option_element();
}
inline void ActionProto::set_has_select_option_element() {
  _oneof_case_[0] = kSelectOptionElement;
}
inline ::autofill_assistant::SelectOptionElementProto* ActionProto::release_select_option_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.select_option_element)
  if (_internal_has_select_option_element()) {
    clear_has_action_info();
    ::autofill_assistant::SelectOptionElementProto* temp = action_info_.select_option_element_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.select_option_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectOptionElementProto& ActionProto::_internal_select_option_element() const {
  return _internal_has_select_option_element()
      ? *action_info_.select_option_element_
      : reinterpret_cast< ::autofill_assistant::SelectOptionElementProto&>(::autofill_assistant::_SelectOptionElementProto_default_instance_);
}
inline const ::autofill_assistant::SelectOptionElementProto& ActionProto::select_option_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.select_option_element)
  return _internal_select_option_element();
}
inline ::autofill_assistant::SelectOptionElementProto* ActionProto::unsafe_arena_release_select_option_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.select_option_element)
  if (_internal_has_select_option_element()) {
    clear_has_action_info();
    ::autofill_assistant::SelectOptionElementProto* temp = action_info_.select_option_element_;
    action_info_.select_option_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_select_option_element(::autofill_assistant::SelectOptionElementProto* select_option_element) {
  clear_action_info();
  if (select_option_element) {
    set_has_select_option_element();
    action_info_.select_option_element_ = select_option_element;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.select_option_element)
}
inline ::autofill_assistant::SelectOptionElementProto* ActionProto::_internal_mutable_select_option_element() {
  if (!_internal_has_select_option_element()) {
    clear_action_info();
    set_has_select_option_element();
    action_info_.select_option_element_ = CreateMaybeMessage< ::autofill_assistant::SelectOptionElementProto >(GetArenaForAllocation());
  }
  return action_info_.select_option_element_;
}
inline ::autofill_assistant::SelectOptionElementProto* ActionProto::mutable_select_option_element() {
  ::autofill_assistant::SelectOptionElementProto* _msg = _internal_mutable_select_option_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.select_option_element)
  return _msg;
}

// .autofill_assistant.CheckElementTagProto check_element_tag = 75;
inline bool ActionProto::_internal_has_check_element_tag() const {
  return action_info_case() == kCheckElementTag;
}
inline bool ActionProto::has_check_element_tag() const {
  return _internal_has_check_element_tag();
}
inline void ActionProto::set_has_check_element_tag() {
  _oneof_case_[0] = kCheckElementTag;
}
inline ::autofill_assistant::CheckElementTagProto* ActionProto::release_check_element_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.check_element_tag)
  if (_internal_has_check_element_tag()) {
    clear_has_action_info();
    ::autofill_assistant::CheckElementTagProto* temp = action_info_.check_element_tag_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.check_element_tag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CheckElementTagProto& ActionProto::_internal_check_element_tag() const {
  return _internal_has_check_element_tag()
      ? *action_info_.check_element_tag_
      : reinterpret_cast< ::autofill_assistant::CheckElementTagProto&>(::autofill_assistant::_CheckElementTagProto_default_instance_);
}
inline const ::autofill_assistant::CheckElementTagProto& ActionProto::check_element_tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.check_element_tag)
  return _internal_check_element_tag();
}
inline ::autofill_assistant::CheckElementTagProto* ActionProto::unsafe_arena_release_check_element_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.check_element_tag)
  if (_internal_has_check_element_tag()) {
    clear_has_action_info();
    ::autofill_assistant::CheckElementTagProto* temp = action_info_.check_element_tag_;
    action_info_.check_element_tag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_check_element_tag(::autofill_assistant::CheckElementTagProto* check_element_tag) {
  clear_action_info();
  if (check_element_tag) {
    set_has_check_element_tag();
    action_info_.check_element_tag_ = check_element_tag;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.check_element_tag)
}
inline ::autofill_assistant::CheckElementTagProto* ActionProto::_internal_mutable_check_element_tag() {
  if (!_internal_has_check_element_tag()) {
    clear_action_info();
    set_has_check_element_tag();
    action_info_.check_element_tag_ = CreateMaybeMessage< ::autofill_assistant::CheckElementTagProto >(GetArenaForAllocation());
  }
  return action_info_.check_element_tag_;
}
inline ::autofill_assistant::CheckElementTagProto* ActionProto::mutable_check_element_tag() {
  ::autofill_assistant::CheckElementTagProto* _msg = _internal_mutable_check_element_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.check_element_tag)
  return _msg;
}

// .autofill_assistant.CheckOptionElementProto check_option_element = 76;
inline bool ActionProto::_internal_has_check_option_element() const {
  return action_info_case() == kCheckOptionElement;
}
inline bool ActionProto::has_check_option_element() const {
  return _internal_has_check_option_element();
}
inline void ActionProto::set_has_check_option_element() {
  _oneof_case_[0] = kCheckOptionElement;
}
inline ::autofill_assistant::CheckOptionElementProto* ActionProto::release_check_option_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.check_option_element)
  if (_internal_has_check_option_element()) {
    clear_has_action_info();
    ::autofill_assistant::CheckOptionElementProto* temp = action_info_.check_option_element_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.check_option_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CheckOptionElementProto& ActionProto::_internal_check_option_element() const {
  return _internal_has_check_option_element()
      ? *action_info_.check_option_element_
      : reinterpret_cast< ::autofill_assistant::CheckOptionElementProto&>(::autofill_assistant::_CheckOptionElementProto_default_instance_);
}
inline const ::autofill_assistant::CheckOptionElementProto& ActionProto::check_option_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.check_option_element)
  return _internal_check_option_element();
}
inline ::autofill_assistant::CheckOptionElementProto* ActionProto::unsafe_arena_release_check_option_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.check_option_element)
  if (_internal_has_check_option_element()) {
    clear_has_action_info();
    ::autofill_assistant::CheckOptionElementProto* temp = action_info_.check_option_element_;
    action_info_.check_option_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_check_option_element(::autofill_assistant::CheckOptionElementProto* check_option_element) {
  clear_action_info();
  if (check_option_element) {
    set_has_check_option_element();
    action_info_.check_option_element_ = check_option_element;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.check_option_element)
}
inline ::autofill_assistant::CheckOptionElementProto* ActionProto::_internal_mutable_check_option_element() {
  if (!_internal_has_check_option_element()) {
    clear_action_info();
    set_has_check_option_element();
    action_info_.check_option_element_ = CreateMaybeMessage< ::autofill_assistant::CheckOptionElementProto >(GetArenaForAllocation());
  }
  return action_info_.check_option_element_;
}
inline ::autofill_assistant::CheckOptionElementProto* ActionProto::mutable_check_option_element() {
  ::autofill_assistant::CheckOptionElementProto* _msg = _internal_mutable_check_option_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.check_option_element)
  return _msg;
}

// .autofill_assistant.SetPersistentUiProto set_persistent_ui = 77;
inline bool ActionProto::_internal_has_set_persistent_ui() const {
  return action_info_case() == kSetPersistentUi;
}
inline bool ActionProto::has_set_persistent_ui() const {
  return _internal_has_set_persistent_ui();
}
inline void ActionProto::set_has_set_persistent_ui() {
  _oneof_case_[0] = kSetPersistentUi;
}
inline void ActionProto::clear_set_persistent_ui() {
  if (_internal_has_set_persistent_ui()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.set_persistent_ui_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::SetPersistentUiProto* ActionProto::release_set_persistent_ui() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.set_persistent_ui)
  if (_internal_has_set_persistent_ui()) {
    clear_has_action_info();
    ::autofill_assistant::SetPersistentUiProto* temp = action_info_.set_persistent_ui_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.set_persistent_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetPersistentUiProto& ActionProto::_internal_set_persistent_ui() const {
  return _internal_has_set_persistent_ui()
      ? *action_info_.set_persistent_ui_
      : reinterpret_cast< ::autofill_assistant::SetPersistentUiProto&>(::autofill_assistant::_SetPersistentUiProto_default_instance_);
}
inline const ::autofill_assistant::SetPersistentUiProto& ActionProto::set_persistent_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.set_persistent_ui)
  return _internal_set_persistent_ui();
}
inline ::autofill_assistant::SetPersistentUiProto* ActionProto::unsafe_arena_release_set_persistent_ui() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.set_persistent_ui)
  if (_internal_has_set_persistent_ui()) {
    clear_has_action_info();
    ::autofill_assistant::SetPersistentUiProto* temp = action_info_.set_persistent_ui_;
    action_info_.set_persistent_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_set_persistent_ui(::autofill_assistant::SetPersistentUiProto* set_persistent_ui) {
  clear_action_info();
  if (set_persistent_ui) {
    set_has_set_persistent_ui();
    action_info_.set_persistent_ui_ = set_persistent_ui;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.set_persistent_ui)
}
inline ::autofill_assistant::SetPersistentUiProto* ActionProto::_internal_mutable_set_persistent_ui() {
  if (!_internal_has_set_persistent_ui()) {
    clear_action_info();
    set_has_set_persistent_ui();
    action_info_.set_persistent_ui_ = CreateMaybeMessage< ::autofill_assistant::SetPersistentUiProto >(GetArenaForAllocation());
  }
  return action_info_.set_persistent_ui_;
}
inline ::autofill_assistant::SetPersistentUiProto* ActionProto::mutable_set_persistent_ui() {
  ::autofill_assistant::SetPersistentUiProto* _msg = _internal_mutable_set_persistent_ui();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.set_persistent_ui)
  return _msg;
}

// .autofill_assistant.ClearPersistentUiProto clear_persistent_ui = 78;
inline bool ActionProto::_internal_has_clear_persistent_ui() const {
  return action_info_case() == kClearPersistentUi;
}
inline bool ActionProto::has_clear_persistent_ui() const {
  return _internal_has_clear_persistent_ui();
}
inline void ActionProto::set_has_clear_persistent_ui() {
  _oneof_case_[0] = kClearPersistentUi;
}
inline void ActionProto::clear_clear_persistent_ui() {
  if (_internal_has_clear_persistent_ui()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.clear_persistent_ui_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ClearPersistentUiProto* ActionProto::release_clear_persistent_ui() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.clear_persistent_ui)
  if (_internal_has_clear_persistent_ui()) {
    clear_has_action_info();
    ::autofill_assistant::ClearPersistentUiProto* temp = action_info_.clear_persistent_ui_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.clear_persistent_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ClearPersistentUiProto& ActionProto::_internal_clear_persistent_ui() const {
  return _internal_has_clear_persistent_ui()
      ? *action_info_.clear_persistent_ui_
      : reinterpret_cast< ::autofill_assistant::ClearPersistentUiProto&>(::autofill_assistant::_ClearPersistentUiProto_default_instance_);
}
inline const ::autofill_assistant::ClearPersistentUiProto& ActionProto::clear_persistent_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.clear_persistent_ui)
  return _internal_clear_persistent_ui();
}
inline ::autofill_assistant::ClearPersistentUiProto* ActionProto::unsafe_arena_release_clear_persistent_ui() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.clear_persistent_ui)
  if (_internal_has_clear_persistent_ui()) {
    clear_has_action_info();
    ::autofill_assistant::ClearPersistentUiProto* temp = action_info_.clear_persistent_ui_;
    action_info_.clear_persistent_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_clear_persistent_ui(::autofill_assistant::ClearPersistentUiProto* clear_persistent_ui) {
  clear_action_info();
  if (clear_persistent_ui) {
    set_has_clear_persistent_ui();
    action_info_.clear_persistent_ui_ = clear_persistent_ui;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.clear_persistent_ui)
}
inline ::autofill_assistant::ClearPersistentUiProto* ActionProto::_internal_mutable_clear_persistent_ui() {
  if (!_internal_has_clear_persistent_ui()) {
    clear_action_info();
    set_has_clear_persistent_ui();
    action_info_.clear_persistent_ui_ = CreateMaybeMessage< ::autofill_assistant::ClearPersistentUiProto >(GetArenaForAllocation());
  }
  return action_info_.clear_persistent_ui_;
}
inline ::autofill_assistant::ClearPersistentUiProto* ActionProto::mutable_clear_persistent_ui() {
  ::autofill_assistant::ClearPersistentUiProto* _msg = _internal_mutable_clear_persistent_ui();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.clear_persistent_ui)
  return _msg;
}

// .autofill_assistant.ScrollIntoViewIfNeededProto scroll_into_view_if_needed = 79;
inline bool ActionProto::_internal_has_scroll_into_view_if_needed() const {
  return action_info_case() == kScrollIntoViewIfNeeded;
}
inline bool ActionProto::has_scroll_into_view_if_needed() const {
  return _internal_has_scroll_into_view_if_needed();
}
inline void ActionProto::set_has_scroll_into_view_if_needed() {
  _oneof_case_[0] = kScrollIntoViewIfNeeded;
}
inline ::autofill_assistant::ScrollIntoViewIfNeededProto* ActionProto::release_scroll_into_view_if_needed() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.scroll_into_view_if_needed)
  if (_internal_has_scroll_into_view_if_needed()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollIntoViewIfNeededProto* temp = action_info_.scroll_into_view_if_needed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.scroll_into_view_if_needed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ScrollIntoViewIfNeededProto& ActionProto::_internal_scroll_into_view_if_needed() const {
  return _internal_has_scroll_into_view_if_needed()
      ? *action_info_.scroll_into_view_if_needed_
      : reinterpret_cast< ::autofill_assistant::ScrollIntoViewIfNeededProto&>(::autofill_assistant::_ScrollIntoViewIfNeededProto_default_instance_);
}
inline const ::autofill_assistant::ScrollIntoViewIfNeededProto& ActionProto::scroll_into_view_if_needed() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.scroll_into_view_if_needed)
  return _internal_scroll_into_view_if_needed();
}
inline ::autofill_assistant::ScrollIntoViewIfNeededProto* ActionProto::unsafe_arena_release_scroll_into_view_if_needed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.scroll_into_view_if_needed)
  if (_internal_has_scroll_into_view_if_needed()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollIntoViewIfNeededProto* temp = action_info_.scroll_into_view_if_needed_;
    action_info_.scroll_into_view_if_needed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_scroll_into_view_if_needed(::autofill_assistant::ScrollIntoViewIfNeededProto* scroll_into_view_if_needed) {
  clear_action_info();
  if (scroll_into_view_if_needed) {
    set_has_scroll_into_view_if_needed();
    action_info_.scroll_into_view_if_needed_ = scroll_into_view_if_needed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.scroll_into_view_if_needed)
}
inline ::autofill_assistant::ScrollIntoViewIfNeededProto* ActionProto::_internal_mutable_scroll_into_view_if_needed() {
  if (!_internal_has_scroll_into_view_if_needed()) {
    clear_action_info();
    set_has_scroll_into_view_if_needed();
    action_info_.scroll_into_view_if_needed_ = CreateMaybeMessage< ::autofill_assistant::ScrollIntoViewIfNeededProto >(GetArenaForAllocation());
  }
  return action_info_.scroll_into_view_if_needed_;
}
inline ::autofill_assistant::ScrollIntoViewIfNeededProto* ActionProto::mutable_scroll_into_view_if_needed() {
  ::autofill_assistant::ScrollIntoViewIfNeededProto* _msg = _internal_mutable_scroll_into_view_if_needed();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.scroll_into_view_if_needed)
  return _msg;
}

// .autofill_assistant.ScrollWindowProto scroll_window = 80;
inline bool ActionProto::_internal_has_scroll_window() const {
  return action_info_case() == kScrollWindow;
}
inline bool ActionProto::has_scroll_window() const {
  return _internal_has_scroll_window();
}
inline void ActionProto::set_has_scroll_window() {
  _oneof_case_[0] = kScrollWindow;
}
inline ::autofill_assistant::ScrollWindowProto* ActionProto::release_scroll_window() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.scroll_window)
  if (_internal_has_scroll_window()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollWindowProto* temp = action_info_.scroll_window_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.scroll_window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ScrollWindowProto& ActionProto::_internal_scroll_window() const {
  return _internal_has_scroll_window()
      ? *action_info_.scroll_window_
      : reinterpret_cast< ::autofill_assistant::ScrollWindowProto&>(::autofill_assistant::_ScrollWindowProto_default_instance_);
}
inline const ::autofill_assistant::ScrollWindowProto& ActionProto::scroll_window() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.scroll_window)
  return _internal_scroll_window();
}
inline ::autofill_assistant::ScrollWindowProto* ActionProto::unsafe_arena_release_scroll_window() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.scroll_window)
  if (_internal_has_scroll_window()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollWindowProto* temp = action_info_.scroll_window_;
    action_info_.scroll_window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_scroll_window(::autofill_assistant::ScrollWindowProto* scroll_window) {
  clear_action_info();
  if (scroll_window) {
    set_has_scroll_window();
    action_info_.scroll_window_ = scroll_window;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.scroll_window)
}
inline ::autofill_assistant::ScrollWindowProto* ActionProto::_internal_mutable_scroll_window() {
  if (!_internal_has_scroll_window()) {
    clear_action_info();
    set_has_scroll_window();
    action_info_.scroll_window_ = CreateMaybeMessage< ::autofill_assistant::ScrollWindowProto >(GetArenaForAllocation());
  }
  return action_info_.scroll_window_;
}
inline ::autofill_assistant::ScrollWindowProto* ActionProto::mutable_scroll_window() {
  ::autofill_assistant::ScrollWindowProto* _msg = _internal_mutable_scroll_window();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.scroll_window)
  return _msg;
}

// .autofill_assistant.ScrollContainerProto scroll_container = 81;
inline bool ActionProto::_internal_has_scroll_container() const {
  return action_info_case() == kScrollContainer;
}
inline bool ActionProto::has_scroll_container() const {
  return _internal_has_scroll_container();
}
inline void ActionProto::set_has_scroll_container() {
  _oneof_case_[0] = kScrollContainer;
}
inline ::autofill_assistant::ScrollContainerProto* ActionProto::release_scroll_container() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.scroll_container)
  if (_internal_has_scroll_container()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollContainerProto* temp = action_info_.scroll_container_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.scroll_container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ScrollContainerProto& ActionProto::_internal_scroll_container() const {
  return _internal_has_scroll_container()
      ? *action_info_.scroll_container_
      : reinterpret_cast< ::autofill_assistant::ScrollContainerProto&>(::autofill_assistant::_ScrollContainerProto_default_instance_);
}
inline const ::autofill_assistant::ScrollContainerProto& ActionProto::scroll_container() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.scroll_container)
  return _internal_scroll_container();
}
inline ::autofill_assistant::ScrollContainerProto* ActionProto::unsafe_arena_release_scroll_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.scroll_container)
  if (_internal_has_scroll_container()) {
    clear_has_action_info();
    ::autofill_assistant::ScrollContainerProto* temp = action_info_.scroll_container_;
    action_info_.scroll_container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_scroll_container(::autofill_assistant::ScrollContainerProto* scroll_container) {
  clear_action_info();
  if (scroll_container) {
    set_has_scroll_container();
    action_info_.scroll_container_ = scroll_container;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.scroll_container)
}
inline ::autofill_assistant::ScrollContainerProto* ActionProto::_internal_mutable_scroll_container() {
  if (!_internal_has_scroll_container()) {
    clear_action_info();
    set_has_scroll_container();
    action_info_.scroll_container_ = CreateMaybeMessage< ::autofill_assistant::ScrollContainerProto >(GetArenaForAllocation());
  }
  return action_info_.scroll_container_;
}
inline ::autofill_assistant::ScrollContainerProto* ActionProto::mutable_scroll_container() {
  ::autofill_assistant::ScrollContainerProto* _msg = _internal_mutable_scroll_container();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.scroll_container)
  return _msg;
}

// .autofill_assistant.SetTouchableAreaProto set_touchable_area = 82;
inline bool ActionProto::_internal_has_set_touchable_area() const {
  return action_info_case() == kSetTouchableArea;
}
inline bool ActionProto::has_set_touchable_area() const {
  return _internal_has_set_touchable_area();
}
inline void ActionProto::set_has_set_touchable_area() {
  _oneof_case_[0] = kSetTouchableArea;
}
inline void ActionProto::clear_set_touchable_area() {
  if (_internal_has_set_touchable_area()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.set_touchable_area_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::SetTouchableAreaProto* ActionProto::release_set_touchable_area() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.set_touchable_area)
  if (_internal_has_set_touchable_area()) {
    clear_has_action_info();
    ::autofill_assistant::SetTouchableAreaProto* temp = action_info_.set_touchable_area_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.set_touchable_area_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetTouchableAreaProto& ActionProto::_internal_set_touchable_area() const {
  return _internal_has_set_touchable_area()
      ? *action_info_.set_touchable_area_
      : reinterpret_cast< ::autofill_assistant::SetTouchableAreaProto&>(::autofill_assistant::_SetTouchableAreaProto_default_instance_);
}
inline const ::autofill_assistant::SetTouchableAreaProto& ActionProto::set_touchable_area() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.set_touchable_area)
  return _internal_set_touchable_area();
}
inline ::autofill_assistant::SetTouchableAreaProto* ActionProto::unsafe_arena_release_set_touchable_area() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.set_touchable_area)
  if (_internal_has_set_touchable_area()) {
    clear_has_action_info();
    ::autofill_assistant::SetTouchableAreaProto* temp = action_info_.set_touchable_area_;
    action_info_.set_touchable_area_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_set_touchable_area(::autofill_assistant::SetTouchableAreaProto* set_touchable_area) {
  clear_action_info();
  if (set_touchable_area) {
    set_has_set_touchable_area();
    action_info_.set_touchable_area_ = set_touchable_area;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.set_touchable_area)
}
inline ::autofill_assistant::SetTouchableAreaProto* ActionProto::_internal_mutable_set_touchable_area() {
  if (!_internal_has_set_touchable_area()) {
    clear_action_info();
    set_has_set_touchable_area();
    action_info_.set_touchable_area_ = CreateMaybeMessage< ::autofill_assistant::SetTouchableAreaProto >(GetArenaForAllocation());
  }
  return action_info_.set_touchable_area_;
}
inline ::autofill_assistant::SetTouchableAreaProto* ActionProto::mutable_set_touchable_area() {
  ::autofill_assistant::SetTouchableAreaProto* _msg = _internal_mutable_set_touchable_area();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.set_touchable_area)
  return _msg;
}

// .autofill_assistant.DeleteSelectedPasswordProto delete_password = 83;
inline bool ActionProto::_internal_has_delete_password() const {
  return action_info_case() == kDeletePassword;
}
inline bool ActionProto::has_delete_password() const {
  return _internal_has_delete_password();
}
inline void ActionProto::set_has_delete_password() {
  _oneof_case_[0] = kDeletePassword;
}
inline void ActionProto::clear_delete_password() {
  if (_internal_has_delete_password()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.delete_password_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::DeleteSelectedPasswordProto* ActionProto::release_delete_password() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.delete_password)
  if (_internal_has_delete_password()) {
    clear_has_action_info();
    ::autofill_assistant::DeleteSelectedPasswordProto* temp = action_info_.delete_password_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.delete_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DeleteSelectedPasswordProto& ActionProto::_internal_delete_password() const {
  return _internal_has_delete_password()
      ? *action_info_.delete_password_
      : reinterpret_cast< ::autofill_assistant::DeleteSelectedPasswordProto&>(::autofill_assistant::_DeleteSelectedPasswordProto_default_instance_);
}
inline const ::autofill_assistant::DeleteSelectedPasswordProto& ActionProto::delete_password() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.delete_password)
  return _internal_delete_password();
}
inline ::autofill_assistant::DeleteSelectedPasswordProto* ActionProto::unsafe_arena_release_delete_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.delete_password)
  if (_internal_has_delete_password()) {
    clear_has_action_info();
    ::autofill_assistant::DeleteSelectedPasswordProto* temp = action_info_.delete_password_;
    action_info_.delete_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_delete_password(::autofill_assistant::DeleteSelectedPasswordProto* delete_password) {
  clear_action_info();
  if (delete_password) {
    set_has_delete_password();
    action_info_.delete_password_ = delete_password;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.delete_password)
}
inline ::autofill_assistant::DeleteSelectedPasswordProto* ActionProto::_internal_mutable_delete_password() {
  if (!_internal_has_delete_password()) {
    clear_action_info();
    set_has_delete_password();
    action_info_.delete_password_ = CreateMaybeMessage< ::autofill_assistant::DeleteSelectedPasswordProto >(GetArenaForAllocation());
  }
  return action_info_.delete_password_;
}
inline ::autofill_assistant::DeleteSelectedPasswordProto* ActionProto::mutable_delete_password() {
  ::autofill_assistant::DeleteSelectedPasswordProto* _msg = _internal_mutable_delete_password();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.delete_password)
  return _msg;
}

// .autofill_assistant.EditSelectedPasswordProto edit_password = 84;
inline bool ActionProto::_internal_has_edit_password() const {
  return action_info_case() == kEditPassword;
}
inline bool ActionProto::has_edit_password() const {
  return _internal_has_edit_password();
}
inline void ActionProto::set_has_edit_password() {
  _oneof_case_[0] = kEditPassword;
}
inline void ActionProto::clear_edit_password() {
  if (_internal_has_edit_password()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.edit_password_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::EditSelectedPasswordProto* ActionProto::release_edit_password() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.edit_password)
  if (_internal_has_edit_password()) {
    clear_has_action_info();
    ::autofill_assistant::EditSelectedPasswordProto* temp = action_info_.edit_password_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.edit_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::EditSelectedPasswordProto& ActionProto::_internal_edit_password() const {
  return _internal_has_edit_password()
      ? *action_info_.edit_password_
      : reinterpret_cast< ::autofill_assistant::EditSelectedPasswordProto&>(::autofill_assistant::_EditSelectedPasswordProto_default_instance_);
}
inline const ::autofill_assistant::EditSelectedPasswordProto& ActionProto::edit_password() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.edit_password)
  return _internal_edit_password();
}
inline ::autofill_assistant::EditSelectedPasswordProto* ActionProto::unsafe_arena_release_edit_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.edit_password)
  if (_internal_has_edit_password()) {
    clear_has_action_info();
    ::autofill_assistant::EditSelectedPasswordProto* temp = action_info_.edit_password_;
    action_info_.edit_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_edit_password(::autofill_assistant::EditSelectedPasswordProto* edit_password) {
  clear_action_info();
  if (edit_password) {
    set_has_edit_password();
    action_info_.edit_password_ = edit_password;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.edit_password)
}
inline ::autofill_assistant::EditSelectedPasswordProto* ActionProto::_internal_mutable_edit_password() {
  if (!_internal_has_edit_password()) {
    clear_action_info();
    set_has_edit_password();
    action_info_.edit_password_ = CreateMaybeMessage< ::autofill_assistant::EditSelectedPasswordProto >(GetArenaForAllocation());
  }
  return action_info_.edit_password_;
}
inline ::autofill_assistant::EditSelectedPasswordProto* ActionProto::mutable_edit_password() {
  ::autofill_assistant::EditSelectedPasswordProto* _msg = _internal_mutable_edit_password();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.edit_password)
  return _msg;
}

// .autofill_assistant.BlurFieldProto blur_field = 85;
inline bool ActionProto::_internal_has_blur_field() const {
  return action_info_case() == kBlurField;
}
inline bool ActionProto::has_blur_field() const {
  return _internal_has_blur_field();
}
inline void ActionProto::set_has_blur_field() {
  _oneof_case_[0] = kBlurField;
}
inline ::autofill_assistant::BlurFieldProto* ActionProto::release_blur_field() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.blur_field)
  if (_internal_has_blur_field()) {
    clear_has_action_info();
    ::autofill_assistant::BlurFieldProto* temp = action_info_.blur_field_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.blur_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::BlurFieldProto& ActionProto::_internal_blur_field() const {
  return _internal_has_blur_field()
      ? *action_info_.blur_field_
      : reinterpret_cast< ::autofill_assistant::BlurFieldProto&>(::autofill_assistant::_BlurFieldProto_default_instance_);
}
inline const ::autofill_assistant::BlurFieldProto& ActionProto::blur_field() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.blur_field)
  return _internal_blur_field();
}
inline ::autofill_assistant::BlurFieldProto* ActionProto::unsafe_arena_release_blur_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.blur_field)
  if (_internal_has_blur_field()) {
    clear_has_action_info();
    ::autofill_assistant::BlurFieldProto* temp = action_info_.blur_field_;
    action_info_.blur_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_blur_field(::autofill_assistant::BlurFieldProto* blur_field) {
  clear_action_info();
  if (blur_field) {
    set_has_blur_field();
    action_info_.blur_field_ = blur_field;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.blur_field)
}
inline ::autofill_assistant::BlurFieldProto* ActionProto::_internal_mutable_blur_field() {
  if (!_internal_has_blur_field()) {
    clear_action_info();
    set_has_blur_field();
    action_info_.blur_field_ = CreateMaybeMessage< ::autofill_assistant::BlurFieldProto >(GetArenaForAllocation());
  }
  return action_info_.blur_field_;
}
inline ::autofill_assistant::BlurFieldProto* ActionProto::mutable_blur_field() {
  ::autofill_assistant::BlurFieldProto* _msg = _internal_mutable_blur_field();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.blur_field)
  return _msg;
}

// .autofill_assistant.ResetPendingCredentialsProto reset_pending_credentials = 86;
inline bool ActionProto::_internal_has_reset_pending_credentials() const {
  return action_info_case() == kResetPendingCredentials;
}
inline bool ActionProto::has_reset_pending_credentials() const {
  return _internal_has_reset_pending_credentials();
}
inline void ActionProto::set_has_reset_pending_credentials() {
  _oneof_case_[0] = kResetPendingCredentials;
}
inline void ActionProto::clear_reset_pending_credentials() {
  if (_internal_has_reset_pending_credentials()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.reset_pending_credentials_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ResetPendingCredentialsProto* ActionProto::release_reset_pending_credentials() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.reset_pending_credentials)
  if (_internal_has_reset_pending_credentials()) {
    clear_has_action_info();
    ::autofill_assistant::ResetPendingCredentialsProto* temp = action_info_.reset_pending_credentials_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.reset_pending_credentials_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ResetPendingCredentialsProto& ActionProto::_internal_reset_pending_credentials() const {
  return _internal_has_reset_pending_credentials()
      ? *action_info_.reset_pending_credentials_
      : reinterpret_cast< ::autofill_assistant::ResetPendingCredentialsProto&>(::autofill_assistant::_ResetPendingCredentialsProto_default_instance_);
}
inline const ::autofill_assistant::ResetPendingCredentialsProto& ActionProto::reset_pending_credentials() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.reset_pending_credentials)
  return _internal_reset_pending_credentials();
}
inline ::autofill_assistant::ResetPendingCredentialsProto* ActionProto::unsafe_arena_release_reset_pending_credentials() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.reset_pending_credentials)
  if (_internal_has_reset_pending_credentials()) {
    clear_has_action_info();
    ::autofill_assistant::ResetPendingCredentialsProto* temp = action_info_.reset_pending_credentials_;
    action_info_.reset_pending_credentials_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_reset_pending_credentials(::autofill_assistant::ResetPendingCredentialsProto* reset_pending_credentials) {
  clear_action_info();
  if (reset_pending_credentials) {
    set_has_reset_pending_credentials();
    action_info_.reset_pending_credentials_ = reset_pending_credentials;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.reset_pending_credentials)
}
inline ::autofill_assistant::ResetPendingCredentialsProto* ActionProto::_internal_mutable_reset_pending_credentials() {
  if (!_internal_has_reset_pending_credentials()) {
    clear_action_info();
    set_has_reset_pending_credentials();
    action_info_.reset_pending_credentials_ = CreateMaybeMessage< ::autofill_assistant::ResetPendingCredentialsProto >(GetArenaForAllocation());
  }
  return action_info_.reset_pending_credentials_;
}
inline ::autofill_assistant::ResetPendingCredentialsProto* ActionProto::mutable_reset_pending_credentials() {
  ::autofill_assistant::ResetPendingCredentialsProto* _msg = _internal_mutable_reset_pending_credentials();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.reset_pending_credentials)
  return _msg;
}

// .autofill_assistant.SaveSubmittedPasswordProto save_submitted_password = 87;
inline bool ActionProto::_internal_has_save_submitted_password() const {
  return action_info_case() == kSaveSubmittedPassword;
}
inline bool ActionProto::has_save_submitted_password() const {
  return _internal_has_save_submitted_password();
}
inline void ActionProto::set_has_save_submitted_password() {
  _oneof_case_[0] = kSaveSubmittedPassword;
}
inline void ActionProto::clear_save_submitted_password() {
  if (_internal_has_save_submitted_password()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.save_submitted_password_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::SaveSubmittedPasswordProto* ActionProto::release_save_submitted_password() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.save_submitted_password)
  if (_internal_has_save_submitted_password()) {
    clear_has_action_info();
    ::autofill_assistant::SaveSubmittedPasswordProto* temp = action_info_.save_submitted_password_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.save_submitted_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SaveSubmittedPasswordProto& ActionProto::_internal_save_submitted_password() const {
  return _internal_has_save_submitted_password()
      ? *action_info_.save_submitted_password_
      : reinterpret_cast< ::autofill_assistant::SaveSubmittedPasswordProto&>(::autofill_assistant::_SaveSubmittedPasswordProto_default_instance_);
}
inline const ::autofill_assistant::SaveSubmittedPasswordProto& ActionProto::save_submitted_password() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.save_submitted_password)
  return _internal_save_submitted_password();
}
inline ::autofill_assistant::SaveSubmittedPasswordProto* ActionProto::unsafe_arena_release_save_submitted_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.save_submitted_password)
  if (_internal_has_save_submitted_password()) {
    clear_has_action_info();
    ::autofill_assistant::SaveSubmittedPasswordProto* temp = action_info_.save_submitted_password_;
    action_info_.save_submitted_password_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_save_submitted_password(::autofill_assistant::SaveSubmittedPasswordProto* save_submitted_password) {
  clear_action_info();
  if (save_submitted_password) {
    set_has_save_submitted_password();
    action_info_.save_submitted_password_ = save_submitted_password;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.save_submitted_password)
}
inline ::autofill_assistant::SaveSubmittedPasswordProto* ActionProto::_internal_mutable_save_submitted_password() {
  if (!_internal_has_save_submitted_password()) {
    clear_action_info();
    set_has_save_submitted_password();
    action_info_.save_submitted_password_ = CreateMaybeMessage< ::autofill_assistant::SaveSubmittedPasswordProto >(GetArenaForAllocation());
  }
  return action_info_.save_submitted_password_;
}
inline ::autofill_assistant::SaveSubmittedPasswordProto* ActionProto::mutable_save_submitted_password() {
  ::autofill_assistant::SaveSubmittedPasswordProto* _msg = _internal_mutable_save_submitted_password();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.save_submitted_password)
  return _msg;
}

// .autofill_assistant.UpdateClientSettingsProto update_client_settings = 89;
inline bool ActionProto::_internal_has_update_client_settings() const {
  return action_info_case() == kUpdateClientSettings;
}
inline bool ActionProto::has_update_client_settings() const {
  return _internal_has_update_client_settings();
}
inline void ActionProto::set_has_update_client_settings() {
  _oneof_case_[0] = kUpdateClientSettings;
}
inline void ActionProto::clear_update_client_settings() {
  if (_internal_has_update_client_settings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.update_client_settings_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::UpdateClientSettingsProto* ActionProto::release_update_client_settings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.update_client_settings)
  if (_internal_has_update_client_settings()) {
    clear_has_action_info();
    ::autofill_assistant::UpdateClientSettingsProto* temp = action_info_.update_client_settings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.update_client_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::UpdateClientSettingsProto& ActionProto::_internal_update_client_settings() const {
  return _internal_has_update_client_settings()
      ? *action_info_.update_client_settings_
      : reinterpret_cast< ::autofill_assistant::UpdateClientSettingsProto&>(::autofill_assistant::_UpdateClientSettingsProto_default_instance_);
}
inline const ::autofill_assistant::UpdateClientSettingsProto& ActionProto::update_client_settings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.update_client_settings)
  return _internal_update_client_settings();
}
inline ::autofill_assistant::UpdateClientSettingsProto* ActionProto::unsafe_arena_release_update_client_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.update_client_settings)
  if (_internal_has_update_client_settings()) {
    clear_has_action_info();
    ::autofill_assistant::UpdateClientSettingsProto* temp = action_info_.update_client_settings_;
    action_info_.update_client_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_update_client_settings(::autofill_assistant::UpdateClientSettingsProto* update_client_settings) {
  clear_action_info();
  if (update_client_settings) {
    set_has_update_client_settings();
    action_info_.update_client_settings_ = update_client_settings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.update_client_settings)
}
inline ::autofill_assistant::UpdateClientSettingsProto* ActionProto::_internal_mutable_update_client_settings() {
  if (!_internal_has_update_client_settings()) {
    clear_action_info();
    set_has_update_client_settings();
    action_info_.update_client_settings_ = CreateMaybeMessage< ::autofill_assistant::UpdateClientSettingsProto >(GetArenaForAllocation());
  }
  return action_info_.update_client_settings_;
}
inline ::autofill_assistant::UpdateClientSettingsProto* ActionProto::mutable_update_client_settings() {
  ::autofill_assistant::UpdateClientSettingsProto* _msg = _internal_mutable_update_client_settings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.update_client_settings)
  return _msg;
}

// .autofill_assistant.JsFlowProto js_flow = 92;
inline bool ActionProto::_internal_has_js_flow() const {
  return action_info_case() == kJsFlow;
}
inline bool ActionProto::has_js_flow() const {
  return _internal_has_js_flow();
}
inline void ActionProto::set_has_js_flow() {
  _oneof_case_[0] = kJsFlow;
}
inline void ActionProto::clear_js_flow() {
  if (_internal_has_js_flow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.js_flow_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::JsFlowProto* ActionProto::release_js_flow() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.js_flow)
  if (_internal_has_js_flow()) {
    clear_has_action_info();
    ::autofill_assistant::JsFlowProto* temp = action_info_.js_flow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.js_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::JsFlowProto& ActionProto::_internal_js_flow() const {
  return _internal_has_js_flow()
      ? *action_info_.js_flow_
      : reinterpret_cast< ::autofill_assistant::JsFlowProto&>(::autofill_assistant::_JsFlowProto_default_instance_);
}
inline const ::autofill_assistant::JsFlowProto& ActionProto::js_flow() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.js_flow)
  return _internal_js_flow();
}
inline ::autofill_assistant::JsFlowProto* ActionProto::unsafe_arena_release_js_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.js_flow)
  if (_internal_has_js_flow()) {
    clear_has_action_info();
    ::autofill_assistant::JsFlowProto* temp = action_info_.js_flow_;
    action_info_.js_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_js_flow(::autofill_assistant::JsFlowProto* js_flow) {
  clear_action_info();
  if (js_flow) {
    set_has_js_flow();
    action_info_.js_flow_ = js_flow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.js_flow)
}
inline ::autofill_assistant::JsFlowProto* ActionProto::_internal_mutable_js_flow() {
  if (!_internal_has_js_flow()) {
    clear_action_info();
    set_has_js_flow();
    action_info_.js_flow_ = CreateMaybeMessage< ::autofill_assistant::JsFlowProto >(GetArenaForAllocation());
  }
  return action_info_.js_flow_;
}
inline ::autofill_assistant::JsFlowProto* ActionProto::mutable_js_flow() {
  ::autofill_assistant::JsFlowProto* _msg = _internal_mutable_js_flow();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.js_flow)
  return _msg;
}

// .autofill_assistant.ExecuteJsProto execute_js = 93;
inline bool ActionProto::_internal_has_execute_js() const {
  return action_info_case() == kExecuteJs;
}
inline bool ActionProto::has_execute_js() const {
  return _internal_has_execute_js();
}
inline void ActionProto::set_has_execute_js() {
  _oneof_case_[0] = kExecuteJs;
}
inline ::autofill_assistant::ExecuteJsProto* ActionProto::release_execute_js() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.execute_js)
  if (_internal_has_execute_js()) {
    clear_has_action_info();
    ::autofill_assistant::ExecuteJsProto* temp = action_info_.execute_js_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.execute_js_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ExecuteJsProto& ActionProto::_internal_execute_js() const {
  return _internal_has_execute_js()
      ? *action_info_.execute_js_
      : reinterpret_cast< ::autofill_assistant::ExecuteJsProto&>(::autofill_assistant::_ExecuteJsProto_default_instance_);
}
inline const ::autofill_assistant::ExecuteJsProto& ActionProto::execute_js() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.execute_js)
  return _internal_execute_js();
}
inline ::autofill_assistant::ExecuteJsProto* ActionProto::unsafe_arena_release_execute_js() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.execute_js)
  if (_internal_has_execute_js()) {
    clear_has_action_info();
    ::autofill_assistant::ExecuteJsProto* temp = action_info_.execute_js_;
    action_info_.execute_js_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_execute_js(::autofill_assistant::ExecuteJsProto* execute_js) {
  clear_action_info();
  if (execute_js) {
    set_has_execute_js();
    action_info_.execute_js_ = execute_js;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.execute_js)
}
inline ::autofill_assistant::ExecuteJsProto* ActionProto::_internal_mutable_execute_js() {
  if (!_internal_has_execute_js()) {
    clear_action_info();
    set_has_execute_js();
    action_info_.execute_js_ = CreateMaybeMessage< ::autofill_assistant::ExecuteJsProto >(GetArenaForAllocation());
  }
  return action_info_.execute_js_;
}
inline ::autofill_assistant::ExecuteJsProto* ActionProto::mutable_execute_js() {
  ::autofill_assistant::ExecuteJsProto* _msg = _internal_mutable_execute_js();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.execute_js)
  return _msg;
}

// .autofill_assistant.RegisterPasswordResetRequestProto register_password_reset_request = 94;
inline bool ActionProto::_internal_has_register_password_reset_request() const {
  return action_info_case() == kRegisterPasswordResetRequest;
}
inline bool ActionProto::has_register_password_reset_request() const {
  return _internal_has_register_password_reset_request();
}
inline void ActionProto::set_has_register_password_reset_request() {
  _oneof_case_[0] = kRegisterPasswordResetRequest;
}
inline void ActionProto::clear_register_password_reset_request() {
  if (_internal_has_register_password_reset_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.register_password_reset_request_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::RegisterPasswordResetRequestProto* ActionProto::release_register_password_reset_request() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.register_password_reset_request)
  if (_internal_has_register_password_reset_request()) {
    clear_has_action_info();
    ::autofill_assistant::RegisterPasswordResetRequestProto* temp = action_info_.register_password_reset_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.register_password_reset_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::RegisterPasswordResetRequestProto& ActionProto::_internal_register_password_reset_request() const {
  return _internal_has_register_password_reset_request()
      ? *action_info_.register_password_reset_request_
      : reinterpret_cast< ::autofill_assistant::RegisterPasswordResetRequestProto&>(::autofill_assistant::_RegisterPasswordResetRequestProto_default_instance_);
}
inline const ::autofill_assistant::RegisterPasswordResetRequestProto& ActionProto::register_password_reset_request() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.register_password_reset_request)
  return _internal_register_password_reset_request();
}
inline ::autofill_assistant::RegisterPasswordResetRequestProto* ActionProto::unsafe_arena_release_register_password_reset_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.register_password_reset_request)
  if (_internal_has_register_password_reset_request()) {
    clear_has_action_info();
    ::autofill_assistant::RegisterPasswordResetRequestProto* temp = action_info_.register_password_reset_request_;
    action_info_.register_password_reset_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_register_password_reset_request(::autofill_assistant::RegisterPasswordResetRequestProto* register_password_reset_request) {
  clear_action_info();
  if (register_password_reset_request) {
    set_has_register_password_reset_request();
    action_info_.register_password_reset_request_ = register_password_reset_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.register_password_reset_request)
}
inline ::autofill_assistant::RegisterPasswordResetRequestProto* ActionProto::_internal_mutable_register_password_reset_request() {
  if (!_internal_has_register_password_reset_request()) {
    clear_action_info();
    set_has_register_password_reset_request();
    action_info_.register_password_reset_request_ = CreateMaybeMessage< ::autofill_assistant::RegisterPasswordResetRequestProto >(GetArenaForAllocation());
  }
  return action_info_.register_password_reset_request_;
}
inline ::autofill_assistant::RegisterPasswordResetRequestProto* ActionProto::mutable_register_password_reset_request() {
  ::autofill_assistant::RegisterPasswordResetRequestProto* _msg = _internal_mutable_register_password_reset_request();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.register_password_reset_request)
  return _msg;
}

// .autofill_assistant.ExternalActionProto external_action = 95;
inline bool ActionProto::_internal_has_external_action() const {
  return action_info_case() == kExternalAction;
}
inline bool ActionProto::has_external_action() const {
  return _internal_has_external_action();
}
inline void ActionProto::set_has_external_action() {
  _oneof_case_[0] = kExternalAction;
}
inline void ActionProto::clear_external_action() {
  if (_internal_has_external_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.external_action_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::ExternalActionProto* ActionProto::release_external_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.external_action)
  if (_internal_has_external_action()) {
    clear_has_action_info();
    ::autofill_assistant::ExternalActionProto* temp = action_info_.external_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.external_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ExternalActionProto& ActionProto::_internal_external_action() const {
  return _internal_has_external_action()
      ? *action_info_.external_action_
      : reinterpret_cast< ::autofill_assistant::ExternalActionProto&>(::autofill_assistant::_ExternalActionProto_default_instance_);
}
inline const ::autofill_assistant::ExternalActionProto& ActionProto::external_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.external_action)
  return _internal_external_action();
}
inline ::autofill_assistant::ExternalActionProto* ActionProto::unsafe_arena_release_external_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.external_action)
  if (_internal_has_external_action()) {
    clear_has_action_info();
    ::autofill_assistant::ExternalActionProto* temp = action_info_.external_action_;
    action_info_.external_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_external_action(::autofill_assistant::ExternalActionProto* external_action) {
  clear_action_info();
  if (external_action) {
    set_has_external_action();
    action_info_.external_action_ = external_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.external_action)
}
inline ::autofill_assistant::ExternalActionProto* ActionProto::_internal_mutable_external_action() {
  if (!_internal_has_external_action()) {
    clear_action_info();
    set_has_external_action();
    action_info_.external_action_ = CreateMaybeMessage< ::autofill_assistant::ExternalActionProto >(GetArenaForAllocation());
  }
  return action_info_.external_action_;
}
inline ::autofill_assistant::ExternalActionProto* ActionProto::mutable_external_action() {
  ::autofill_assistant::ExternalActionProto* _msg = _internal_mutable_external_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.external_action)
  return _msg;
}

// .autofill_assistant.SetNativeValueProto set_native_value = 96;
inline bool ActionProto::_internal_has_set_native_value() const {
  return action_info_case() == kSetNativeValue;
}
inline bool ActionProto::has_set_native_value() const {
  return _internal_has_set_native_value();
}
inline void ActionProto::set_has_set_native_value() {
  _oneof_case_[0] = kSetNativeValue;
}
inline ::autofill_assistant::SetNativeValueProto* ActionProto::release_set_native_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.set_native_value)
  if (_internal_has_set_native_value()) {
    clear_has_action_info();
    ::autofill_assistant::SetNativeValueProto* temp = action_info_.set_native_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.set_native_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetNativeValueProto& ActionProto::_internal_set_native_value() const {
  return _internal_has_set_native_value()
      ? *action_info_.set_native_value_
      : reinterpret_cast< ::autofill_assistant::SetNativeValueProto&>(::autofill_assistant::_SetNativeValueProto_default_instance_);
}
inline const ::autofill_assistant::SetNativeValueProto& ActionProto::set_native_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.set_native_value)
  return _internal_set_native_value();
}
inline ::autofill_assistant::SetNativeValueProto* ActionProto::unsafe_arena_release_set_native_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.set_native_value)
  if (_internal_has_set_native_value()) {
    clear_has_action_info();
    ::autofill_assistant::SetNativeValueProto* temp = action_info_.set_native_value_;
    action_info_.set_native_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_set_native_value(::autofill_assistant::SetNativeValueProto* set_native_value) {
  clear_action_info();
  if (set_native_value) {
    set_has_set_native_value();
    action_info_.set_native_value_ = set_native_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.set_native_value)
}
inline ::autofill_assistant::SetNativeValueProto* ActionProto::_internal_mutable_set_native_value() {
  if (!_internal_has_set_native_value()) {
    clear_action_info();
    set_has_set_native_value();
    action_info_.set_native_value_ = CreateMaybeMessage< ::autofill_assistant::SetNativeValueProto >(GetArenaForAllocation());
  }
  return action_info_.set_native_value_;
}
inline ::autofill_assistant::SetNativeValueProto* ActionProto::mutable_set_native_value() {
  ::autofill_assistant::SetNativeValueProto* _msg = _internal_mutable_set_native_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.set_native_value)
  return _msg;
}

// .autofill_assistant.SetNativeCheckedProto set_native_checked = 97;
inline bool ActionProto::_internal_has_set_native_checked() const {
  return action_info_case() == kSetNativeChecked;
}
inline bool ActionProto::has_set_native_checked() const {
  return _internal_has_set_native_checked();
}
inline void ActionProto::set_has_set_native_checked() {
  _oneof_case_[0] = kSetNativeChecked;
}
inline ::autofill_assistant::SetNativeCheckedProto* ActionProto::release_set_native_checked() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.set_native_checked)
  if (_internal_has_set_native_checked()) {
    clear_has_action_info();
    ::autofill_assistant::SetNativeCheckedProto* temp = action_info_.set_native_checked_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.set_native_checked_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SetNativeCheckedProto& ActionProto::_internal_set_native_checked() const {
  return _internal_has_set_native_checked()
      ? *action_info_.set_native_checked_
      : reinterpret_cast< ::autofill_assistant::SetNativeCheckedProto&>(::autofill_assistant::_SetNativeCheckedProto_default_instance_);
}
inline const ::autofill_assistant::SetNativeCheckedProto& ActionProto::set_native_checked() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.set_native_checked)
  return _internal_set_native_checked();
}
inline ::autofill_assistant::SetNativeCheckedProto* ActionProto::unsafe_arena_release_set_native_checked() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.set_native_checked)
  if (_internal_has_set_native_checked()) {
    clear_has_action_info();
    ::autofill_assistant::SetNativeCheckedProto* temp = action_info_.set_native_checked_;
    action_info_.set_native_checked_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_set_native_checked(::autofill_assistant::SetNativeCheckedProto* set_native_checked) {
  clear_action_info();
  if (set_native_checked) {
    set_has_set_native_checked();
    action_info_.set_native_checked_ = set_native_checked;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.set_native_checked)
}
inline ::autofill_assistant::SetNativeCheckedProto* ActionProto::_internal_mutable_set_native_checked() {
  if (!_internal_has_set_native_checked()) {
    clear_action_info();
    set_has_set_native_checked();
    action_info_.set_native_checked_ = CreateMaybeMessage< ::autofill_assistant::SetNativeCheckedProto >(GetArenaForAllocation());
  }
  return action_info_.set_native_checked_;
}
inline ::autofill_assistant::SetNativeCheckedProto* ActionProto::mutable_set_native_checked() {
  ::autofill_assistant::SetNativeCheckedProto* _msg = _internal_mutable_set_native_checked();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.set_native_checked)
  return _msg;
}

// .autofill_assistant.PromptQrCodeScanProto prompt_qr_code_scan = 98;
inline bool ActionProto::_internal_has_prompt_qr_code_scan() const {
  return action_info_case() == kPromptQrCodeScan;
}
inline bool ActionProto::has_prompt_qr_code_scan() const {
  return _internal_has_prompt_qr_code_scan();
}
inline void ActionProto::set_has_prompt_qr_code_scan() {
  _oneof_case_[0] = kPromptQrCodeScan;
}
inline void ActionProto::clear_prompt_qr_code_scan() {
  if (_internal_has_prompt_qr_code_scan()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.prompt_qr_code_scan_;
    }
    clear_has_action_info();
  }
}
inline ::autofill_assistant::PromptQrCodeScanProto* ActionProto::release_prompt_qr_code_scan() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ActionProto.prompt_qr_code_scan)
  if (_internal_has_prompt_qr_code_scan()) {
    clear_has_action_info();
    ::autofill_assistant::PromptQrCodeScanProto* temp = action_info_.prompt_qr_code_scan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_info_.prompt_qr_code_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PromptQrCodeScanProto& ActionProto::_internal_prompt_qr_code_scan() const {
  return _internal_has_prompt_qr_code_scan()
      ? *action_info_.prompt_qr_code_scan_
      : reinterpret_cast< ::autofill_assistant::PromptQrCodeScanProto&>(::autofill_assistant::_PromptQrCodeScanProto_default_instance_);
}
inline const ::autofill_assistant::PromptQrCodeScanProto& ActionProto::prompt_qr_code_scan() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.prompt_qr_code_scan)
  return _internal_prompt_qr_code_scan();
}
inline ::autofill_assistant::PromptQrCodeScanProto* ActionProto::unsafe_arena_release_prompt_qr_code_scan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ActionProto.prompt_qr_code_scan)
  if (_internal_has_prompt_qr_code_scan()) {
    clear_has_action_info();
    ::autofill_assistant::PromptQrCodeScanProto* temp = action_info_.prompt_qr_code_scan_;
    action_info_.prompt_qr_code_scan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionProto::unsafe_arena_set_allocated_prompt_qr_code_scan(::autofill_assistant::PromptQrCodeScanProto* prompt_qr_code_scan) {
  clear_action_info();
  if (prompt_qr_code_scan) {
    set_has_prompt_qr_code_scan();
    action_info_.prompt_qr_code_scan_ = prompt_qr_code_scan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ActionProto.prompt_qr_code_scan)
}
inline ::autofill_assistant::PromptQrCodeScanProto* ActionProto::_internal_mutable_prompt_qr_code_scan() {
  if (!_internal_has_prompt_qr_code_scan()) {
    clear_action_info();
    set_has_prompt_qr_code_scan();
    action_info_.prompt_qr_code_scan_ = CreateMaybeMessage< ::autofill_assistant::PromptQrCodeScanProto >(GetArenaForAllocation());
  }
  return action_info_.prompt_qr_code_scan_;
}
inline ::autofill_assistant::PromptQrCodeScanProto* ActionProto::mutable_prompt_qr_code_scan() {
  ::autofill_assistant::PromptQrCodeScanProto* _msg = _internal_mutable_prompt_qr_code_scan();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ActionProto.prompt_qr_code_scan)
  return _msg;
}

// optional bool clean_contextual_ui = 33;
inline bool ActionProto::_internal_has_clean_contextual_ui() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActionProto::has_clean_contextual_ui() const {
  return _internal_has_clean_contextual_ui();
}
inline void ActionProto::clear_clean_contextual_ui() {
  clean_contextual_ui_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ActionProto::_internal_clean_contextual_ui() const {
  return clean_contextual_ui_;
}
inline bool ActionProto::clean_contextual_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionProto.clean_contextual_ui)
  return _internal_clean_contextual_ui();
}
inline void ActionProto::_internal_set_clean_contextual_ui(bool value) {
  _has_bits_[0] |= 0x00000004u;
  clean_contextual_ui_ = value;
}
inline void ActionProto::set_clean_contextual_ui(bool value) {
  _internal_set_clean_contextual_ui(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionProto.clean_contextual_ui)
}

inline bool ActionProto::has_action_info() const {
  return action_info_case() != ACTION_INFO_NOT_SET;
}
inline void ActionProto::clear_has_action_info() {
  _oneof_case_[0] = ACTION_INFO_NOT_SET;
}
inline ActionProto::ActionInfoCase ActionProto::action_info_case() const {
  return ActionProto::ActionInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CollectUserDataResultProto

// optional string card_issuer_network = 1;
inline bool CollectUserDataResultProto::_internal_has_card_issuer_network() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_card_issuer_network() const {
  return _internal_has_card_issuer_network();
}
inline void CollectUserDataResultProto::clear_card_issuer_network() {
  card_issuer_network_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollectUserDataResultProto::card_issuer_network() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.card_issuer_network)
  return _internal_card_issuer_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataResultProto::set_card_issuer_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 card_issuer_network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.card_issuer_network)
}
inline std::string* CollectUserDataResultProto::mutable_card_issuer_network() {
  std::string* _s = _internal_mutable_card_issuer_network();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.card_issuer_network)
  return _s;
}
inline const std::string& CollectUserDataResultProto::_internal_card_issuer_network() const {
  return card_issuer_network_.Get();
}
inline void CollectUserDataResultProto::_internal_set_card_issuer_network(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  card_issuer_network_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::_internal_mutable_card_issuer_network() {
  _has_bits_[0] |= 0x00000001u;
  return card_issuer_network_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::release_card_issuer_network() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataResultProto.card_issuer_network)
  if (!_internal_has_card_issuer_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = card_issuer_network_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (card_issuer_network_.IsDefault()) {
    card_issuer_network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataResultProto::set_allocated_card_issuer_network(std::string* card_issuer_network) {
  if (card_issuer_network != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  card_issuer_network_.SetAllocated(card_issuer_network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (card_issuer_network_.IsDefault()) {
    card_issuer_network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataResultProto.card_issuer_network)
}

// optional bool is_terms_and_conditions_accepted = 2;
inline bool CollectUserDataResultProto::_internal_has_is_terms_and_conditions_accepted() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_is_terms_and_conditions_accepted() const {
  return _internal_has_is_terms_and_conditions_accepted();
}
inline void CollectUserDataResultProto::clear_is_terms_and_conditions_accepted() {
  is_terms_and_conditions_accepted_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CollectUserDataResultProto::_internal_is_terms_and_conditions_accepted() const {
  return is_terms_and_conditions_accepted_;
}
inline bool CollectUserDataResultProto::is_terms_and_conditions_accepted() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.is_terms_and_conditions_accepted)
  return _internal_is_terms_and_conditions_accepted();
}
inline void CollectUserDataResultProto::_internal_set_is_terms_and_conditions_accepted(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_terms_and_conditions_accepted_ = value;
}
inline void CollectUserDataResultProto::set_is_terms_and_conditions_accepted(bool value) {
  _internal_set_is_terms_and_conditions_accepted(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.is_terms_and_conditions_accepted)
}

// optional string payer_email = 3;
inline bool CollectUserDataResultProto::_internal_has_payer_email() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_payer_email() const {
  return _internal_has_payer_email();
}
inline void CollectUserDataResultProto::clear_payer_email() {
  payer_email_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollectUserDataResultProto::payer_email() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.payer_email)
  return _internal_payer_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataResultProto::set_payer_email(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 payer_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.payer_email)
}
inline std::string* CollectUserDataResultProto::mutable_payer_email() {
  std::string* _s = _internal_mutable_payer_email();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.payer_email)
  return _s;
}
inline const std::string& CollectUserDataResultProto::_internal_payer_email() const {
  return payer_email_.Get();
}
inline void CollectUserDataResultProto::_internal_set_payer_email(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  payer_email_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::_internal_mutable_payer_email() {
  _has_bits_[0] |= 0x00000002u;
  return payer_email_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::release_payer_email() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataResultProto.payer_email)
  if (!_internal_has_payer_email()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = payer_email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payer_email_.IsDefault()) {
    payer_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataResultProto::set_allocated_payer_email(std::string* payer_email) {
  if (payer_email != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payer_email_.SetAllocated(payer_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payer_email_.IsDefault()) {
    payer_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataResultProto.payer_email)
}

// optional int32 additional_action_index = 4;
inline bool CollectUserDataResultProto::_internal_has_additional_action_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_additional_action_index() const {
  return _internal_has_additional_action_index();
}
inline void CollectUserDataResultProto::clear_additional_action_index() {
  additional_action_index_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CollectUserDataResultProto::_internal_additional_action_index() const {
  return additional_action_index_;
}
inline int32_t CollectUserDataResultProto::additional_action_index() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.additional_action_index)
  return _internal_additional_action_index();
}
inline void CollectUserDataResultProto::_internal_set_additional_action_index(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  additional_action_index_ = value;
}
inline void CollectUserDataResultProto::set_additional_action_index(int32_t value) {
  _internal_set_additional_action_index(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.additional_action_index)
}

// optional int32 terms_link = 5;
inline bool CollectUserDataResultProto::_internal_has_terms_link() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_terms_link() const {
  return _internal_has_terms_link();
}
inline void CollectUserDataResultProto::clear_terms_link() {
  terms_link_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CollectUserDataResultProto::_internal_terms_link() const {
  return terms_link_;
}
inline int32_t CollectUserDataResultProto::terms_link() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.terms_link)
  return _internal_terms_link();
}
inline void CollectUserDataResultProto::_internal_set_terms_link(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  terms_link_ = value;
}
inline void CollectUserDataResultProto::set_terms_link(int32_t value) {
  _internal_set_terms_link(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.terms_link)
}

// bytes login_payload = 6;
inline bool CollectUserDataResultProto::_internal_has_login_payload() const {
  return payload_or_tag_case() == kLoginPayload;
}
inline bool CollectUserDataResultProto::has_login_payload() const {
  return _internal_has_login_payload();
}
inline void CollectUserDataResultProto::set_has_login_payload() {
  _oneof_case_[0] = kLoginPayload;
}
inline void CollectUserDataResultProto::clear_login_payload() {
  if (_internal_has_login_payload()) {
    payload_or_tag_.login_payload_.Destroy();
    clear_has_payload_or_tag();
  }
}
inline const std::string& CollectUserDataResultProto::login_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.login_payload)
  return _internal_login_payload();
}
template <typename ArgT0, typename... ArgT>
inline void CollectUserDataResultProto::set_login_payload(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_login_payload()) {
    clear_payload_or_tag();
    set_has_login_payload();
    payload_or_tag_.login_payload_.InitDefault();
  }
  payload_or_tag_.login_payload_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.login_payload)
}
inline std::string* CollectUserDataResultProto::mutable_login_payload() {
  std::string* _s = _internal_mutable_login_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.login_payload)
  return _s;
}
inline const std::string& CollectUserDataResultProto::_internal_login_payload() const {
  if (_internal_has_login_payload()) {
    return payload_or_tag_.login_payload_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CollectUserDataResultProto::_internal_set_login_payload(const std::string& value) {
  if (!_internal_has_login_payload()) {
    clear_payload_or_tag();
    set_has_login_payload();
    payload_or_tag_.login_payload_.InitDefault();
  }
  payload_or_tag_.login_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::_internal_mutable_login_payload() {
  if (!_internal_has_login_payload()) {
    clear_payload_or_tag();
    set_has_login_payload();
    payload_or_tag_.login_payload_.InitDefault();
  }
  return payload_or_tag_.login_payload_.Mutable(      GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::release_login_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataResultProto.login_payload)
  if (_internal_has_login_payload()) {
    clear_has_payload_or_tag();
    return payload_or_tag_.login_payload_.Release();
  } else {
    return nullptr;
  }
}
inline void CollectUserDataResultProto::set_allocated_login_payload(std::string* login_payload) {
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (login_payload != nullptr) {
    set_has_login_payload();
    payload_or_tag_.login_payload_.InitAllocated(login_payload, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataResultProto.login_payload)
}

// string login_tag = 21;
inline bool CollectUserDataResultProto::_internal_has_login_tag() const {
  return payload_or_tag_case() == kLoginTag;
}
inline bool CollectUserDataResultProto::has_login_tag() const {
  return _internal_has_login_tag();
}
inline void CollectUserDataResultProto::set_has_login_tag() {
  _oneof_case_[0] = kLoginTag;
}
inline void CollectUserDataResultProto::clear_login_tag() {
  if (_internal_has_login_tag()) {
    payload_or_tag_.login_tag_.Destroy();
    clear_has_payload_or_tag();
  }
}
inline const std::string& CollectUserDataResultProto::login_tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.login_tag)
  return _internal_login_tag();
}
template <typename ArgT0, typename... ArgT>
inline void CollectUserDataResultProto::set_login_tag(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_login_tag()) {
    clear_payload_or_tag();
    set_has_login_tag();
    payload_or_tag_.login_tag_.InitDefault();
  }
  payload_or_tag_.login_tag_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.login_tag)
}
inline std::string* CollectUserDataResultProto::mutable_login_tag() {
  std::string* _s = _internal_mutable_login_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.login_tag)
  return _s;
}
inline const std::string& CollectUserDataResultProto::_internal_login_tag() const {
  if (_internal_has_login_tag()) {
    return payload_or_tag_.login_tag_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CollectUserDataResultProto::_internal_set_login_tag(const std::string& value) {
  if (!_internal_has_login_tag()) {
    clear_payload_or_tag();
    set_has_login_tag();
    payload_or_tag_.login_tag_.InitDefault();
  }
  payload_or_tag_.login_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::_internal_mutable_login_tag() {
  if (!_internal_has_login_tag()) {
    clear_payload_or_tag();
    set_has_login_tag();
    payload_or_tag_.login_tag_.InitDefault();
  }
  return payload_or_tag_.login_tag_.Mutable(      GetArenaForAllocation());
}
inline std::string* CollectUserDataResultProto::release_login_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataResultProto.login_tag)
  if (_internal_has_login_tag()) {
    clear_has_payload_or_tag();
    return payload_or_tag_.login_tag_.Release();
  } else {
    return nullptr;
  }
}
inline void CollectUserDataResultProto::set_allocated_login_tag(std::string* login_tag) {
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (login_tag != nullptr) {
    set_has_login_tag();
    payload_or_tag_.login_tag_.InitAllocated(login_tag, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataResultProto.login_tag)
}

// optional .autofill_assistant.ModelProto model = 9;
inline bool CollectUserDataResultProto::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || model_ != nullptr);
  return value;
}
inline bool CollectUserDataResultProto::has_model() const {
  return _internal_has_model();
}
inline const ::autofill_assistant::ModelProto& CollectUserDataResultProto::_internal_model() const {
  const ::autofill_assistant::ModelProto* p = model_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ModelProto&>(
      ::autofill_assistant::_ModelProto_default_instance_);
}
inline const ::autofill_assistant::ModelProto& CollectUserDataResultProto::model() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.model)
  return _internal_model();
}
inline void CollectUserDataResultProto::unsafe_arena_set_allocated_model(
    ::autofill_assistant::ModelProto* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  model_ = model;
  if (model) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataResultProto.model)
}
inline ::autofill_assistant::ModelProto* CollectUserDataResultProto::release_model() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ModelProto* temp = model_;
  model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ModelProto* CollectUserDataResultProto::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataResultProto.model)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ModelProto* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ModelProto* CollectUserDataResultProto::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000004u;
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ModelProto>(GetArenaForAllocation());
    model_ = p;
  }
  return model_;
}
inline ::autofill_assistant::ModelProto* CollectUserDataResultProto::mutable_model() {
  ::autofill_assistant::ModelProto* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.model)
  return _msg;
}
inline void CollectUserDataResultProto::set_allocated_model(::autofill_assistant::ModelProto* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model));
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataResultProto.model)
}

// repeated string set_text_input_memory_keys = 10;
inline int CollectUserDataResultProto::_internal_set_text_input_memory_keys_size() const {
  return set_text_input_memory_keys_.size();
}
inline int CollectUserDataResultProto::set_text_input_memory_keys_size() const {
  return _internal_set_text_input_memory_keys_size();
}
inline void CollectUserDataResultProto::clear_set_text_input_memory_keys() {
  set_text_input_memory_keys_.Clear();
}
inline std::string* CollectUserDataResultProto::add_set_text_input_memory_keys() {
  std::string* _s = _internal_add_set_text_input_memory_keys();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
  return _s;
}
inline const std::string& CollectUserDataResultProto::_internal_set_text_input_memory_keys(int index) const {
  return set_text_input_memory_keys_.Get(index);
}
inline const std::string& CollectUserDataResultProto::set_text_input_memory_keys(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
  return _internal_set_text_input_memory_keys(index);
}
inline std::string* CollectUserDataResultProto::mutable_set_text_input_memory_keys(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
  return set_text_input_memory_keys_.Mutable(index);
}
inline void CollectUserDataResultProto::set_set_text_input_memory_keys(int index, const std::string& value) {
  set_text_input_memory_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline void CollectUserDataResultProto::set_set_text_input_memory_keys(int index, std::string&& value) {
  set_text_input_memory_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline void CollectUserDataResultProto::set_set_text_input_memory_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  set_text_input_memory_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline void CollectUserDataResultProto::set_set_text_input_memory_keys(int index, const char* value, size_t size) {
  set_text_input_memory_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline std::string* CollectUserDataResultProto::_internal_add_set_text_input_memory_keys() {
  return set_text_input_memory_keys_.Add();
}
inline void CollectUserDataResultProto::add_set_text_input_memory_keys(const std::string& value) {
  set_text_input_memory_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline void CollectUserDataResultProto::add_set_text_input_memory_keys(std::string&& value) {
  set_text_input_memory_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline void CollectUserDataResultProto::add_set_text_input_memory_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  set_text_input_memory_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline void CollectUserDataResultProto::add_set_text_input_memory_keys(const char* value, size_t size) {
  set_text_input_memory_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CollectUserDataResultProto::set_text_input_memory_keys() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
  return set_text_input_memory_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CollectUserDataResultProto::mutable_set_text_input_memory_keys() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataResultProto.set_text_input_memory_keys)
  return &set_text_input_memory_keys_;
}

// repeated .autofill_assistant.ModelProto.ModelValue additional_sections_values = 15;
inline int CollectUserDataResultProto::_internal_additional_sections_values_size() const {
  return additional_sections_values_.size();
}
inline int CollectUserDataResultProto::additional_sections_values_size() const {
  return _internal_additional_sections_values_size();
}
inline ::autofill_assistant::ModelProto_ModelValue* CollectUserDataResultProto::mutable_additional_sections_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataResultProto.additional_sections_values)
  return additional_sections_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >*
CollectUserDataResultProto::mutable_additional_sections_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataResultProto.additional_sections_values)
  return &additional_sections_values_;
}
inline const ::autofill_assistant::ModelProto_ModelValue& CollectUserDataResultProto::_internal_additional_sections_values(int index) const {
  return additional_sections_values_.Get(index);
}
inline const ::autofill_assistant::ModelProto_ModelValue& CollectUserDataResultProto::additional_sections_values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.additional_sections_values)
  return _internal_additional_sections_values(index);
}
inline ::autofill_assistant::ModelProto_ModelValue* CollectUserDataResultProto::_internal_add_additional_sections_values() {
  return additional_sections_values_.Add();
}
inline ::autofill_assistant::ModelProto_ModelValue* CollectUserDataResultProto::add_additional_sections_values() {
  ::autofill_assistant::ModelProto_ModelValue* _add = _internal_add_additional_sections_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataResultProto.additional_sections_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ModelProto_ModelValue >&
CollectUserDataResultProto::additional_sections_values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataResultProto.additional_sections_values)
  return additional_sections_values_;
}

// optional bool shown_to_user = 16;
inline bool CollectUserDataResultProto::_internal_has_shown_to_user() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_shown_to_user() const {
  return _internal_has_shown_to_user();
}
inline void CollectUserDataResultProto::clear_shown_to_user() {
  shown_to_user_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CollectUserDataResultProto::_internal_shown_to_user() const {
  return shown_to_user_;
}
inline bool CollectUserDataResultProto::shown_to_user() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.shown_to_user)
  return _internal_shown_to_user();
}
inline void CollectUserDataResultProto::_internal_set_shown_to_user(bool value) {
  _has_bits_[0] |= 0x00000040u;
  shown_to_user_ = value;
}
inline void CollectUserDataResultProto::set_shown_to_user(bool value) {
  _internal_set_shown_to_user(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.shown_to_user)
}

// optional bool login_missing_username = 17;
inline bool CollectUserDataResultProto::_internal_has_login_missing_username() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CollectUserDataResultProto::has_login_missing_username() const {
  return _internal_has_login_missing_username();
}
inline void CollectUserDataResultProto::clear_login_missing_username() {
  login_missing_username_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CollectUserDataResultProto::_internal_login_missing_username() const {
  return login_missing_username_;
}
inline bool CollectUserDataResultProto::login_missing_username() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataResultProto.login_missing_username)
  return _internal_login_missing_username();
}
inline void CollectUserDataResultProto::_internal_set_login_missing_username(bool value) {
  _has_bits_[0] |= 0x00000080u;
  login_missing_username_ = value;
}
inline void CollectUserDataResultProto::set_login_missing_username(bool value) {
  _internal_set_login_missing_username(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataResultProto.login_missing_username)
}

inline bool CollectUserDataResultProto::has_payload_or_tag() const {
  return payload_or_tag_case() != PAYLOAD_OR_TAG_NOT_SET;
}
inline void CollectUserDataResultProto::clear_has_payload_or_tag() {
  _oneof_case_[0] = PAYLOAD_OR_TAG_NOT_SET;
}
inline CollectUserDataResultProto::PayloadOrTagCase CollectUserDataResultProto::payload_or_tag_case() const {
  return CollectUserDataResultProto::PayloadOrTagCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionTimingStats

// optional int64 delay_ms = 1;
inline bool ActionTimingStats::_internal_has_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ActionTimingStats::has_delay_ms() const {
  return _internal_has_delay_ms();
}
inline void ActionTimingStats::clear_delay_ms() {
  delay_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t ActionTimingStats::_internal_delay_ms() const {
  return delay_ms_;
}
inline int64_t ActionTimingStats::delay_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionTimingStats.delay_ms)
  return _internal_delay_ms();
}
inline void ActionTimingStats::_internal_set_delay_ms(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  delay_ms_ = value;
}
inline void ActionTimingStats::set_delay_ms(int64_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionTimingStats.delay_ms)
}

// optional int64 active_time_ms = 2;
inline bool ActionTimingStats::_internal_has_active_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ActionTimingStats::has_active_time_ms() const {
  return _internal_has_active_time_ms();
}
inline void ActionTimingStats::clear_active_time_ms() {
  active_time_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ActionTimingStats::_internal_active_time_ms() const {
  return active_time_ms_;
}
inline int64_t ActionTimingStats::active_time_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionTimingStats.active_time_ms)
  return _internal_active_time_ms();
}
inline void ActionTimingStats::_internal_set_active_time_ms(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  active_time_ms_ = value;
}
inline void ActionTimingStats::set_active_time_ms(int64_t value) {
  _internal_set_active_time_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionTimingStats.active_time_ms)
}

// optional int64 wait_time_ms = 3;
inline bool ActionTimingStats::_internal_has_wait_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ActionTimingStats::has_wait_time_ms() const {
  return _internal_has_wait_time_ms();
}
inline void ActionTimingStats::clear_wait_time_ms() {
  wait_time_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t ActionTimingStats::_internal_wait_time_ms() const {
  return wait_time_ms_;
}
inline int64_t ActionTimingStats::wait_time_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ActionTimingStats.wait_time_ms)
  return _internal_wait_time_ms();
}
inline void ActionTimingStats::_internal_set_wait_time_ms(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  wait_time_ms_ = value;
}
inline void ActionTimingStats::set_wait_time_ms(int64_t value) {
  _internal_set_wait_time_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ActionTimingStats.wait_time_ms)
}

// -------------------------------------------------------------------

// ProcessedActionProto

// optional .autofill_assistant.ActionProto action = 1;
inline bool ProcessedActionProto::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || action_ != nullptr);
  return value;
}
inline bool ProcessedActionProto::has_action() const {
  return _internal_has_action();
}
inline void ProcessedActionProto::clear_action() {
  if (action_ != nullptr) action_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ActionProto& ProcessedActionProto::_internal_action() const {
  const ::autofill_assistant::ActionProto* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ActionProto&>(
      ::autofill_assistant::_ActionProto_default_instance_);
}
inline const ::autofill_assistant::ActionProto& ProcessedActionProto::action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.action)
  return _internal_action();
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_action(
    ::autofill_assistant::ActionProto* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.action)
}
inline ::autofill_assistant::ActionProto* ProcessedActionProto::release_action() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ActionProto* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ActionProto* ProcessedActionProto::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.action)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ActionProto* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ActionProto* ProcessedActionProto::_internal_mutable_action() {
  _has_bits_[0] |= 0x00000001u;
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ActionProto>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::autofill_assistant::ActionProto* ProcessedActionProto::mutable_action() {
  ::autofill_assistant::ActionProto* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.action)
  return _msg;
}
inline void ProcessedActionProto::set_allocated_action(::autofill_assistant::ActionProto* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.action)
}

// optional .autofill_assistant.ProcessedActionStatusProto status = 2;
inline bool ProcessedActionProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ProcessedActionProto::has_status() const {
  return _internal_has_status();
}
inline void ProcessedActionProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::autofill_assistant::ProcessedActionStatusProto ProcessedActionProto::_internal_status() const {
  return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(status_);
}
inline ::autofill_assistant::ProcessedActionStatusProto ProcessedActionProto::status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.status)
  return _internal_status();
}
inline void ProcessedActionProto::_internal_set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  assert(::autofill_assistant::ProcessedActionStatusProto_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void ProcessedActionProto::set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ProcessedActionProto.status)
}

// optional .autofill_assistant.ProcessedActionStatusDetailsProto status_details = 19;
inline bool ProcessedActionProto::_internal_has_status_details() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || status_details_ != nullptr);
  return value;
}
inline bool ProcessedActionProto::has_status_details() const {
  return _internal_has_status_details();
}
inline void ProcessedActionProto::clear_status_details() {
  if (status_details_ != nullptr) status_details_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ProcessedActionStatusDetailsProto& ProcessedActionProto::_internal_status_details() const {
  const ::autofill_assistant::ProcessedActionStatusDetailsProto* p = status_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ProcessedActionStatusDetailsProto&>(
      ::autofill_assistant::_ProcessedActionStatusDetailsProto_default_instance_);
}
inline const ::autofill_assistant::ProcessedActionStatusDetailsProto& ProcessedActionProto::status_details() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.status_details)
  return _internal_status_details();
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_status_details(
    ::autofill_assistant::ProcessedActionStatusDetailsProto* status_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_details_);
  }
  status_details_ = status_details;
  if (status_details) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.status_details)
}
inline ::autofill_assistant::ProcessedActionStatusDetailsProto* ProcessedActionProto::release_status_details() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ProcessedActionStatusDetailsProto* temp = status_details_;
  status_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ProcessedActionStatusDetailsProto* ProcessedActionProto::unsafe_arena_release_status_details() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.status_details)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ProcessedActionStatusDetailsProto* temp = status_details_;
  status_details_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ProcessedActionStatusDetailsProto* ProcessedActionProto::_internal_mutable_status_details() {
  _has_bits_[0] |= 0x00000002u;
  if (status_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ProcessedActionStatusDetailsProto>(GetArenaForAllocation());
    status_details_ = p;
  }
  return status_details_;
}
inline ::autofill_assistant::ProcessedActionStatusDetailsProto* ProcessedActionProto::mutable_status_details() {
  ::autofill_assistant::ProcessedActionStatusDetailsProto* _msg = _internal_mutable_status_details();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.status_details)
  return _msg;
}
inline void ProcessedActionProto::set_allocated_status_details(::autofill_assistant::ProcessedActionStatusDetailsProto* status_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_details_;
  }
  if (status_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status_details);
    if (message_arena != submessage_arena) {
      status_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_details_ = status_details;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.status_details)
}

// .autofill_assistant.PromptProto.Result prompt_choice = 5;
inline bool ProcessedActionProto::_internal_has_prompt_choice() const {
  return result_data_case() == kPromptChoice;
}
inline bool ProcessedActionProto::has_prompt_choice() const {
  return _internal_has_prompt_choice();
}
inline void ProcessedActionProto::set_has_prompt_choice() {
  _oneof_case_[0] = kPromptChoice;
}
inline void ProcessedActionProto::clear_prompt_choice() {
  if (_internal_has_prompt_choice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.prompt_choice_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::PromptProto_Result* ProcessedActionProto::release_prompt_choice() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.prompt_choice)
  if (_internal_has_prompt_choice()) {
    clear_has_result_data();
    ::autofill_assistant::PromptProto_Result* temp = result_data_.prompt_choice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.prompt_choice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PromptProto_Result& ProcessedActionProto::_internal_prompt_choice() const {
  return _internal_has_prompt_choice()
      ? *result_data_.prompt_choice_
      : reinterpret_cast< ::autofill_assistant::PromptProto_Result&>(::autofill_assistant::_PromptProto_Result_default_instance_);
}
inline const ::autofill_assistant::PromptProto_Result& ProcessedActionProto::prompt_choice() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.prompt_choice)
  return _internal_prompt_choice();
}
inline ::autofill_assistant::PromptProto_Result* ProcessedActionProto::unsafe_arena_release_prompt_choice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.prompt_choice)
  if (_internal_has_prompt_choice()) {
    clear_has_result_data();
    ::autofill_assistant::PromptProto_Result* temp = result_data_.prompt_choice_;
    result_data_.prompt_choice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_prompt_choice(::autofill_assistant::PromptProto_Result* prompt_choice) {
  clear_result_data();
  if (prompt_choice) {
    set_has_prompt_choice();
    result_data_.prompt_choice_ = prompt_choice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.prompt_choice)
}
inline ::autofill_assistant::PromptProto_Result* ProcessedActionProto::_internal_mutable_prompt_choice() {
  if (!_internal_has_prompt_choice()) {
    clear_result_data();
    set_has_prompt_choice();
    result_data_.prompt_choice_ = CreateMaybeMessage< ::autofill_assistant::PromptProto_Result >(GetArenaForAllocation());
  }
  return result_data_.prompt_choice_;
}
inline ::autofill_assistant::PromptProto_Result* ProcessedActionProto::mutable_prompt_choice() {
  ::autofill_assistant::PromptProto_Result* _msg = _internal_mutable_prompt_choice();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.prompt_choice)
  return _msg;
}

// .autofill_assistant.CollectUserDataResultProto collect_user_data_result = 15;
inline bool ProcessedActionProto::_internal_has_collect_user_data_result() const {
  return result_data_case() == kCollectUserDataResult;
}
inline bool ProcessedActionProto::has_collect_user_data_result() const {
  return _internal_has_collect_user_data_result();
}
inline void ProcessedActionProto::set_has_collect_user_data_result() {
  _oneof_case_[0] = kCollectUserDataResult;
}
inline void ProcessedActionProto::clear_collect_user_data_result() {
  if (_internal_has_collect_user_data_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.collect_user_data_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::CollectUserDataResultProto* ProcessedActionProto::release_collect_user_data_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.collect_user_data_result)
  if (_internal_has_collect_user_data_result()) {
    clear_has_result_data();
    ::autofill_assistant::CollectUserDataResultProto* temp = result_data_.collect_user_data_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.collect_user_data_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CollectUserDataResultProto& ProcessedActionProto::_internal_collect_user_data_result() const {
  return _internal_has_collect_user_data_result()
      ? *result_data_.collect_user_data_result_
      : reinterpret_cast< ::autofill_assistant::CollectUserDataResultProto&>(::autofill_assistant::_CollectUserDataResultProto_default_instance_);
}
inline const ::autofill_assistant::CollectUserDataResultProto& ProcessedActionProto::collect_user_data_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.collect_user_data_result)
  return _internal_collect_user_data_result();
}
inline ::autofill_assistant::CollectUserDataResultProto* ProcessedActionProto::unsafe_arena_release_collect_user_data_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.collect_user_data_result)
  if (_internal_has_collect_user_data_result()) {
    clear_has_result_data();
    ::autofill_assistant::CollectUserDataResultProto* temp = result_data_.collect_user_data_result_;
    result_data_.collect_user_data_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_collect_user_data_result(::autofill_assistant::CollectUserDataResultProto* collect_user_data_result) {
  clear_result_data();
  if (collect_user_data_result) {
    set_has_collect_user_data_result();
    result_data_.collect_user_data_result_ = collect_user_data_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.collect_user_data_result)
}
inline ::autofill_assistant::CollectUserDataResultProto* ProcessedActionProto::_internal_mutable_collect_user_data_result() {
  if (!_internal_has_collect_user_data_result()) {
    clear_result_data();
    set_has_collect_user_data_result();
    result_data_.collect_user_data_result_ = CreateMaybeMessage< ::autofill_assistant::CollectUserDataResultProto >(GetArenaForAllocation());
  }
  return result_data_.collect_user_data_result_;
}
inline ::autofill_assistant::CollectUserDataResultProto* ProcessedActionProto::mutable_collect_user_data_result() {
  ::autofill_assistant::CollectUserDataResultProto* _msg = _internal_mutable_collect_user_data_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.collect_user_data_result)
  return _msg;
}

// .autofill_assistant.WaitForDomProto.Result wait_for_dom_result = 22;
inline bool ProcessedActionProto::_internal_has_wait_for_dom_result() const {
  return result_data_case() == kWaitForDomResult;
}
inline bool ProcessedActionProto::has_wait_for_dom_result() const {
  return _internal_has_wait_for_dom_result();
}
inline void ProcessedActionProto::set_has_wait_for_dom_result() {
  _oneof_case_[0] = kWaitForDomResult;
}
inline void ProcessedActionProto::clear_wait_for_dom_result() {
  if (_internal_has_wait_for_dom_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.wait_for_dom_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::WaitForDomProto_Result* ProcessedActionProto::release_wait_for_dom_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.wait_for_dom_result)
  if (_internal_has_wait_for_dom_result()) {
    clear_has_result_data();
    ::autofill_assistant::WaitForDomProto_Result* temp = result_data_.wait_for_dom_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.wait_for_dom_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForDomProto_Result& ProcessedActionProto::_internal_wait_for_dom_result() const {
  return _internal_has_wait_for_dom_result()
      ? *result_data_.wait_for_dom_result_
      : reinterpret_cast< ::autofill_assistant::WaitForDomProto_Result&>(::autofill_assistant::_WaitForDomProto_Result_default_instance_);
}
inline const ::autofill_assistant::WaitForDomProto_Result& ProcessedActionProto::wait_for_dom_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.wait_for_dom_result)
  return _internal_wait_for_dom_result();
}
inline ::autofill_assistant::WaitForDomProto_Result* ProcessedActionProto::unsafe_arena_release_wait_for_dom_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.wait_for_dom_result)
  if (_internal_has_wait_for_dom_result()) {
    clear_has_result_data();
    ::autofill_assistant::WaitForDomProto_Result* temp = result_data_.wait_for_dom_result_;
    result_data_.wait_for_dom_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_wait_for_dom_result(::autofill_assistant::WaitForDomProto_Result* wait_for_dom_result) {
  clear_result_data();
  if (wait_for_dom_result) {
    set_has_wait_for_dom_result();
    result_data_.wait_for_dom_result_ = wait_for_dom_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.wait_for_dom_result)
}
inline ::autofill_assistant::WaitForDomProto_Result* ProcessedActionProto::_internal_mutable_wait_for_dom_result() {
  if (!_internal_has_wait_for_dom_result()) {
    clear_result_data();
    set_has_wait_for_dom_result();
    result_data_.wait_for_dom_result_ = CreateMaybeMessage< ::autofill_assistant::WaitForDomProto_Result >(GetArenaForAllocation());
  }
  return result_data_.wait_for_dom_result_;
}
inline ::autofill_assistant::WaitForDomProto_Result* ProcessedActionProto::mutable_wait_for_dom_result() {
  ::autofill_assistant::WaitForDomProto_Result* _msg = _internal_mutable_wait_for_dom_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.wait_for_dom_result)
  return _msg;
}

// .autofill_assistant.FormProto.Result form_result = 21;
inline bool ProcessedActionProto::_internal_has_form_result() const {
  return result_data_case() == kFormResult;
}
inline bool ProcessedActionProto::has_form_result() const {
  return _internal_has_form_result();
}
inline void ProcessedActionProto::set_has_form_result() {
  _oneof_case_[0] = kFormResult;
}
inline void ProcessedActionProto::clear_form_result() {
  if (_internal_has_form_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.form_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::FormProto_Result* ProcessedActionProto::release_form_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.form_result)
  if (_internal_has_form_result()) {
    clear_has_result_data();
    ::autofill_assistant::FormProto_Result* temp = result_data_.form_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.form_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::FormProto_Result& ProcessedActionProto::_internal_form_result() const {
  return _internal_has_form_result()
      ? *result_data_.form_result_
      : reinterpret_cast< ::autofill_assistant::FormProto_Result&>(::autofill_assistant::_FormProto_Result_default_instance_);
}
inline const ::autofill_assistant::FormProto_Result& ProcessedActionProto::form_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.form_result)
  return _internal_form_result();
}
inline ::autofill_assistant::FormProto_Result* ProcessedActionProto::unsafe_arena_release_form_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.form_result)
  if (_internal_has_form_result()) {
    clear_has_result_data();
    ::autofill_assistant::FormProto_Result* temp = result_data_.form_result_;
    result_data_.form_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_form_result(::autofill_assistant::FormProto_Result* form_result) {
  clear_result_data();
  if (form_result) {
    set_has_form_result();
    result_data_.form_result_ = form_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.form_result)
}
inline ::autofill_assistant::FormProto_Result* ProcessedActionProto::_internal_mutable_form_result() {
  if (!_internal_has_form_result()) {
    clear_result_data();
    set_has_form_result();
    result_data_.form_result_ = CreateMaybeMessage< ::autofill_assistant::FormProto_Result >(GetArenaForAllocation());
  }
  return result_data_.form_result_;
}
inline ::autofill_assistant::FormProto_Result* ProcessedActionProto::mutable_form_result() {
  ::autofill_assistant::FormProto_Result* _msg = _internal_mutable_form_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.form_result)
  return _msg;
}

// .autofill_assistant.WaitForDocumentProto.Result wait_for_document_result = 25;
inline bool ProcessedActionProto::_internal_has_wait_for_document_result() const {
  return result_data_case() == kWaitForDocumentResult;
}
inline bool ProcessedActionProto::has_wait_for_document_result() const {
  return _internal_has_wait_for_document_result();
}
inline void ProcessedActionProto::set_has_wait_for_document_result() {
  _oneof_case_[0] = kWaitForDocumentResult;
}
inline void ProcessedActionProto::clear_wait_for_document_result() {
  if (_internal_has_wait_for_document_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.wait_for_document_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::WaitForDocumentProto_Result* ProcessedActionProto::release_wait_for_document_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.wait_for_document_result)
  if (_internal_has_wait_for_document_result()) {
    clear_has_result_data();
    ::autofill_assistant::WaitForDocumentProto_Result* temp = result_data_.wait_for_document_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.wait_for_document_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::WaitForDocumentProto_Result& ProcessedActionProto::_internal_wait_for_document_result() const {
  return _internal_has_wait_for_document_result()
      ? *result_data_.wait_for_document_result_
      : reinterpret_cast< ::autofill_assistant::WaitForDocumentProto_Result&>(::autofill_assistant::_WaitForDocumentProto_Result_default_instance_);
}
inline const ::autofill_assistant::WaitForDocumentProto_Result& ProcessedActionProto::wait_for_document_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.wait_for_document_result)
  return _internal_wait_for_document_result();
}
inline ::autofill_assistant::WaitForDocumentProto_Result* ProcessedActionProto::unsafe_arena_release_wait_for_document_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.wait_for_document_result)
  if (_internal_has_wait_for_document_result()) {
    clear_has_result_data();
    ::autofill_assistant::WaitForDocumentProto_Result* temp = result_data_.wait_for_document_result_;
    result_data_.wait_for_document_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_wait_for_document_result(::autofill_assistant::WaitForDocumentProto_Result* wait_for_document_result) {
  clear_result_data();
  if (wait_for_document_result) {
    set_has_wait_for_document_result();
    result_data_.wait_for_document_result_ = wait_for_document_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.wait_for_document_result)
}
inline ::autofill_assistant::WaitForDocumentProto_Result* ProcessedActionProto::_internal_mutable_wait_for_document_result() {
  if (!_internal_has_wait_for_document_result()) {
    clear_result_data();
    set_has_wait_for_document_result();
    result_data_.wait_for_document_result_ = CreateMaybeMessage< ::autofill_assistant::WaitForDocumentProto_Result >(GetArenaForAllocation());
  }
  return result_data_.wait_for_document_result_;
}
inline ::autofill_assistant::WaitForDocumentProto_Result* ProcessedActionProto::mutable_wait_for_document_result() {
  ::autofill_assistant::WaitForDocumentProto_Result* _msg = _internal_mutable_wait_for_document_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.wait_for_document_result)
  return _msg;
}

// .autofill_assistant.ShowGenericUiProto.Result show_generic_ui_result = 28;
inline bool ProcessedActionProto::_internal_has_show_generic_ui_result() const {
  return result_data_case() == kShowGenericUiResult;
}
inline bool ProcessedActionProto::has_show_generic_ui_result() const {
  return _internal_has_show_generic_ui_result();
}
inline void ProcessedActionProto::set_has_show_generic_ui_result() {
  _oneof_case_[0] = kShowGenericUiResult;
}
inline void ProcessedActionProto::clear_show_generic_ui_result() {
  if (_internal_has_show_generic_ui_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.show_generic_ui_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::ShowGenericUiProto_Result* ProcessedActionProto::release_show_generic_ui_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.show_generic_ui_result)
  if (_internal_has_show_generic_ui_result()) {
    clear_has_result_data();
    ::autofill_assistant::ShowGenericUiProto_Result* temp = result_data_.show_generic_ui_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.show_generic_ui_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShowGenericUiProto_Result& ProcessedActionProto::_internal_show_generic_ui_result() const {
  return _internal_has_show_generic_ui_result()
      ? *result_data_.show_generic_ui_result_
      : reinterpret_cast< ::autofill_assistant::ShowGenericUiProto_Result&>(::autofill_assistant::_ShowGenericUiProto_Result_default_instance_);
}
inline const ::autofill_assistant::ShowGenericUiProto_Result& ProcessedActionProto::show_generic_ui_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.show_generic_ui_result)
  return _internal_show_generic_ui_result();
}
inline ::autofill_assistant::ShowGenericUiProto_Result* ProcessedActionProto::unsafe_arena_release_show_generic_ui_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.show_generic_ui_result)
  if (_internal_has_show_generic_ui_result()) {
    clear_has_result_data();
    ::autofill_assistant::ShowGenericUiProto_Result* temp = result_data_.show_generic_ui_result_;
    result_data_.show_generic_ui_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_show_generic_ui_result(::autofill_assistant::ShowGenericUiProto_Result* show_generic_ui_result) {
  clear_result_data();
  if (show_generic_ui_result) {
    set_has_show_generic_ui_result();
    result_data_.show_generic_ui_result_ = show_generic_ui_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.show_generic_ui_result)
}
inline ::autofill_assistant::ShowGenericUiProto_Result* ProcessedActionProto::_internal_mutable_show_generic_ui_result() {
  if (!_internal_has_show_generic_ui_result()) {
    clear_result_data();
    set_has_show_generic_ui_result();
    result_data_.show_generic_ui_result_ = CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto_Result >(GetArenaForAllocation());
  }
  return result_data_.show_generic_ui_result_;
}
inline ::autofill_assistant::ShowGenericUiProto_Result* ProcessedActionProto::mutable_show_generic_ui_result() {
  ::autofill_assistant::ShowGenericUiProto_Result* _msg = _internal_mutable_show_generic_ui_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.show_generic_ui_result)
  return _msg;
}

// .autofill_assistant.GetElementStatusProto.Result get_element_status_result = 31;
inline bool ProcessedActionProto::_internal_has_get_element_status_result() const {
  return result_data_case() == kGetElementStatusResult;
}
inline bool ProcessedActionProto::has_get_element_status_result() const {
  return _internal_has_get_element_status_result();
}
inline void ProcessedActionProto::set_has_get_element_status_result() {
  _oneof_case_[0] = kGetElementStatusResult;
}
inline void ProcessedActionProto::clear_get_element_status_result() {
  if (_internal_has_get_element_status_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.get_element_status_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::GetElementStatusProto_Result* ProcessedActionProto::release_get_element_status_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.get_element_status_result)
  if (_internal_has_get_element_status_result()) {
    clear_has_result_data();
    ::autofill_assistant::GetElementStatusProto_Result* temp = result_data_.get_element_status_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.get_element_status_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::GetElementStatusProto_Result& ProcessedActionProto::_internal_get_element_status_result() const {
  return _internal_has_get_element_status_result()
      ? *result_data_.get_element_status_result_
      : reinterpret_cast< ::autofill_assistant::GetElementStatusProto_Result&>(::autofill_assistant::_GetElementStatusProto_Result_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto_Result& ProcessedActionProto::get_element_status_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.get_element_status_result)
  return _internal_get_element_status_result();
}
inline ::autofill_assistant::GetElementStatusProto_Result* ProcessedActionProto::unsafe_arena_release_get_element_status_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.get_element_status_result)
  if (_internal_has_get_element_status_result()) {
    clear_has_result_data();
    ::autofill_assistant::GetElementStatusProto_Result* temp = result_data_.get_element_status_result_;
    result_data_.get_element_status_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_get_element_status_result(::autofill_assistant::GetElementStatusProto_Result* get_element_status_result) {
  clear_result_data();
  if (get_element_status_result) {
    set_has_get_element_status_result();
    result_data_.get_element_status_result_ = get_element_status_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.get_element_status_result)
}
inline ::autofill_assistant::GetElementStatusProto_Result* ProcessedActionProto::_internal_mutable_get_element_status_result() {
  if (!_internal_has_get_element_status_result()) {
    clear_result_data();
    set_has_get_element_status_result();
    result_data_.get_element_status_result_ = CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_Result >(GetArenaForAllocation());
  }
  return result_data_.get_element_status_result_;
}
inline ::autofill_assistant::GetElementStatusProto_Result* ProcessedActionProto::mutable_get_element_status_result() {
  ::autofill_assistant::GetElementStatusProto_Result* _msg = _internal_mutable_get_element_status_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.get_element_status_result)
  return _msg;
}

// .autofill_assistant.UploadDomProto.Result upload_dom_result = 33;
inline bool ProcessedActionProto::_internal_has_upload_dom_result() const {
  return result_data_case() == kUploadDomResult;
}
inline bool ProcessedActionProto::has_upload_dom_result() const {
  return _internal_has_upload_dom_result();
}
inline void ProcessedActionProto::set_has_upload_dom_result() {
  _oneof_case_[0] = kUploadDomResult;
}
inline void ProcessedActionProto::clear_upload_dom_result() {
  if (_internal_has_upload_dom_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.upload_dom_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::UploadDomProto_Result* ProcessedActionProto::release_upload_dom_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.upload_dom_result)
  if (_internal_has_upload_dom_result()) {
    clear_has_result_data();
    ::autofill_assistant::UploadDomProto_Result* temp = result_data_.upload_dom_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.upload_dom_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::UploadDomProto_Result& ProcessedActionProto::_internal_upload_dom_result() const {
  return _internal_has_upload_dom_result()
      ? *result_data_.upload_dom_result_
      : reinterpret_cast< ::autofill_assistant::UploadDomProto_Result&>(::autofill_assistant::_UploadDomProto_Result_default_instance_);
}
inline const ::autofill_assistant::UploadDomProto_Result& ProcessedActionProto::upload_dom_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.upload_dom_result)
  return _internal_upload_dom_result();
}
inline ::autofill_assistant::UploadDomProto_Result* ProcessedActionProto::unsafe_arena_release_upload_dom_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.upload_dom_result)
  if (_internal_has_upload_dom_result()) {
    clear_has_result_data();
    ::autofill_assistant::UploadDomProto_Result* temp = result_data_.upload_dom_result_;
    result_data_.upload_dom_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_upload_dom_result(::autofill_assistant::UploadDomProto_Result* upload_dom_result) {
  clear_result_data();
  if (upload_dom_result) {
    set_has_upload_dom_result();
    result_data_.upload_dom_result_ = upload_dom_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.upload_dom_result)
}
inline ::autofill_assistant::UploadDomProto_Result* ProcessedActionProto::_internal_mutable_upload_dom_result() {
  if (!_internal_has_upload_dom_result()) {
    clear_result_data();
    set_has_upload_dom_result();
    result_data_.upload_dom_result_ = CreateMaybeMessage< ::autofill_assistant::UploadDomProto_Result >(GetArenaForAllocation());
  }
  return result_data_.upload_dom_result_;
}
inline ::autofill_assistant::UploadDomProto_Result* ProcessedActionProto::mutable_upload_dom_result() {
  ::autofill_assistant::UploadDomProto_Result* _msg = _internal_mutable_upload_dom_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.upload_dom_result)
  return _msg;
}

// .autofill_assistant.CheckOptionElementProto.Result check_option_element_result = 35;
inline bool ProcessedActionProto::_internal_has_check_option_element_result() const {
  return result_data_case() == kCheckOptionElementResult;
}
inline bool ProcessedActionProto::has_check_option_element_result() const {
  return _internal_has_check_option_element_result();
}
inline void ProcessedActionProto::set_has_check_option_element_result() {
  _oneof_case_[0] = kCheckOptionElementResult;
}
inline ::autofill_assistant::CheckOptionElementProto_Result* ProcessedActionProto::release_check_option_element_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.check_option_element_result)
  if (_internal_has_check_option_element_result()) {
    clear_has_result_data();
    ::autofill_assistant::CheckOptionElementProto_Result* temp = result_data_.check_option_element_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.check_option_element_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CheckOptionElementProto_Result& ProcessedActionProto::_internal_check_option_element_result() const {
  return _internal_has_check_option_element_result()
      ? *result_data_.check_option_element_result_
      : reinterpret_cast< ::autofill_assistant::CheckOptionElementProto_Result&>(::autofill_assistant::_CheckOptionElementProto_Result_default_instance_);
}
inline const ::autofill_assistant::CheckOptionElementProto_Result& ProcessedActionProto::check_option_element_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.check_option_element_result)
  return _internal_check_option_element_result();
}
inline ::autofill_assistant::CheckOptionElementProto_Result* ProcessedActionProto::unsafe_arena_release_check_option_element_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.check_option_element_result)
  if (_internal_has_check_option_element_result()) {
    clear_has_result_data();
    ::autofill_assistant::CheckOptionElementProto_Result* temp = result_data_.check_option_element_result_;
    result_data_.check_option_element_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_check_option_element_result(::autofill_assistant::CheckOptionElementProto_Result* check_option_element_result) {
  clear_result_data();
  if (check_option_element_result) {
    set_has_check_option_element_result();
    result_data_.check_option_element_result_ = check_option_element_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.check_option_element_result)
}
inline ::autofill_assistant::CheckOptionElementProto_Result* ProcessedActionProto::_internal_mutable_check_option_element_result() {
  if (!_internal_has_check_option_element_result()) {
    clear_result_data();
    set_has_check_option_element_result();
    result_data_.check_option_element_result_ = CreateMaybeMessage< ::autofill_assistant::CheckOptionElementProto_Result >(GetArenaForAllocation());
  }
  return result_data_.check_option_element_result_;
}
inline ::autofill_assistant::CheckOptionElementProto_Result* ProcessedActionProto::mutable_check_option_element_result() {
  ::autofill_assistant::CheckOptionElementProto_Result* _msg = _internal_mutable_check_option_element_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.check_option_element_result)
  return _msg;
}

// .autofill_assistant.SendKeystrokeEventsProto.Result send_key_stroke_events_result = 36;
inline bool ProcessedActionProto::_internal_has_send_key_stroke_events_result() const {
  return result_data_case() == kSendKeyStrokeEventsResult;
}
inline bool ProcessedActionProto::has_send_key_stroke_events_result() const {
  return _internal_has_send_key_stroke_events_result();
}
inline void ProcessedActionProto::set_has_send_key_stroke_events_result() {
  _oneof_case_[0] = kSendKeyStrokeEventsResult;
}
inline ::autofill_assistant::SendKeystrokeEventsProto_Result* ProcessedActionProto::release_send_key_stroke_events_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.send_key_stroke_events_result)
  if (_internal_has_send_key_stroke_events_result()) {
    clear_has_result_data();
    ::autofill_assistant::SendKeystrokeEventsProto_Result* temp = result_data_.send_key_stroke_events_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.send_key_stroke_events_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SendKeystrokeEventsProto_Result& ProcessedActionProto::_internal_send_key_stroke_events_result() const {
  return _internal_has_send_key_stroke_events_result()
      ? *result_data_.send_key_stroke_events_result_
      : reinterpret_cast< ::autofill_assistant::SendKeystrokeEventsProto_Result&>(::autofill_assistant::_SendKeystrokeEventsProto_Result_default_instance_);
}
inline const ::autofill_assistant::SendKeystrokeEventsProto_Result& ProcessedActionProto::send_key_stroke_events_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.send_key_stroke_events_result)
  return _internal_send_key_stroke_events_result();
}
inline ::autofill_assistant::SendKeystrokeEventsProto_Result* ProcessedActionProto::unsafe_arena_release_send_key_stroke_events_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.send_key_stroke_events_result)
  if (_internal_has_send_key_stroke_events_result()) {
    clear_has_result_data();
    ::autofill_assistant::SendKeystrokeEventsProto_Result* temp = result_data_.send_key_stroke_events_result_;
    result_data_.send_key_stroke_events_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_send_key_stroke_events_result(::autofill_assistant::SendKeystrokeEventsProto_Result* send_key_stroke_events_result) {
  clear_result_data();
  if (send_key_stroke_events_result) {
    set_has_send_key_stroke_events_result();
    result_data_.send_key_stroke_events_result_ = send_key_stroke_events_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.send_key_stroke_events_result)
}
inline ::autofill_assistant::SendKeystrokeEventsProto_Result* ProcessedActionProto::_internal_mutable_send_key_stroke_events_result() {
  if (!_internal_has_send_key_stroke_events_result()) {
    clear_result_data();
    set_has_send_key_stroke_events_result();
    result_data_.send_key_stroke_events_result_ = CreateMaybeMessage< ::autofill_assistant::SendKeystrokeEventsProto_Result >(GetArenaForAllocation());
  }
  return result_data_.send_key_stroke_events_result_;
}
inline ::autofill_assistant::SendKeystrokeEventsProto_Result* ProcessedActionProto::mutable_send_key_stroke_events_result() {
  ::autofill_assistant::SendKeystrokeEventsProto_Result* _msg = _internal_mutable_send_key_stroke_events_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.send_key_stroke_events_result)
  return _msg;
}

// .autofill_assistant.JsFlowProto.Result js_flow_result = 37;
inline bool ProcessedActionProto::_internal_has_js_flow_result() const {
  return result_data_case() == kJsFlowResult;
}
inline bool ProcessedActionProto::has_js_flow_result() const {
  return _internal_has_js_flow_result();
}
inline void ProcessedActionProto::set_has_js_flow_result() {
  _oneof_case_[0] = kJsFlowResult;
}
inline void ProcessedActionProto::clear_js_flow_result() {
  if (_internal_has_js_flow_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.js_flow_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::JsFlowProto_Result* ProcessedActionProto::release_js_flow_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.js_flow_result)
  if (_internal_has_js_flow_result()) {
    clear_has_result_data();
    ::autofill_assistant::JsFlowProto_Result* temp = result_data_.js_flow_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.js_flow_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::JsFlowProto_Result& ProcessedActionProto::_internal_js_flow_result() const {
  return _internal_has_js_flow_result()
      ? *result_data_.js_flow_result_
      : reinterpret_cast< ::autofill_assistant::JsFlowProto_Result&>(::autofill_assistant::_JsFlowProto_Result_default_instance_);
}
inline const ::autofill_assistant::JsFlowProto_Result& ProcessedActionProto::js_flow_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.js_flow_result)
  return _internal_js_flow_result();
}
inline ::autofill_assistant::JsFlowProto_Result* ProcessedActionProto::unsafe_arena_release_js_flow_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.js_flow_result)
  if (_internal_has_js_flow_result()) {
    clear_has_result_data();
    ::autofill_assistant::JsFlowProto_Result* temp = result_data_.js_flow_result_;
    result_data_.js_flow_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_js_flow_result(::autofill_assistant::JsFlowProto_Result* js_flow_result) {
  clear_result_data();
  if (js_flow_result) {
    set_has_js_flow_result();
    result_data_.js_flow_result_ = js_flow_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.js_flow_result)
}
inline ::autofill_assistant::JsFlowProto_Result* ProcessedActionProto::_internal_mutable_js_flow_result() {
  if (!_internal_has_js_flow_result()) {
    clear_result_data();
    set_has_js_flow_result();
    result_data_.js_flow_result_ = CreateMaybeMessage< ::autofill_assistant::JsFlowProto_Result >(GetArenaForAllocation());
  }
  return result_data_.js_flow_result_;
}
inline ::autofill_assistant::JsFlowProto_Result* ProcessedActionProto::mutable_js_flow_result() {
  ::autofill_assistant::JsFlowProto_Result* _msg = _internal_mutable_js_flow_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.js_flow_result)
  return _msg;
}

// .autofill_assistant.SaveSubmittedPasswordProto.Result save_submitted_password_result = 38;
inline bool ProcessedActionProto::_internal_has_save_submitted_password_result() const {
  return result_data_case() == kSaveSubmittedPasswordResult;
}
inline bool ProcessedActionProto::has_save_submitted_password_result() const {
  return _internal_has_save_submitted_password_result();
}
inline void ProcessedActionProto::set_has_save_submitted_password_result() {
  _oneof_case_[0] = kSaveSubmittedPasswordResult;
}
inline void ProcessedActionProto::clear_save_submitted_password_result() {
  if (_internal_has_save_submitted_password_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.save_submitted_password_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::SaveSubmittedPasswordProto_Result* ProcessedActionProto::release_save_submitted_password_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.save_submitted_password_result)
  if (_internal_has_save_submitted_password_result()) {
    clear_has_result_data();
    ::autofill_assistant::SaveSubmittedPasswordProto_Result* temp = result_data_.save_submitted_password_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.save_submitted_password_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SaveSubmittedPasswordProto_Result& ProcessedActionProto::_internal_save_submitted_password_result() const {
  return _internal_has_save_submitted_password_result()
      ? *result_data_.save_submitted_password_result_
      : reinterpret_cast< ::autofill_assistant::SaveSubmittedPasswordProto_Result&>(::autofill_assistant::_SaveSubmittedPasswordProto_Result_default_instance_);
}
inline const ::autofill_assistant::SaveSubmittedPasswordProto_Result& ProcessedActionProto::save_submitted_password_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.save_submitted_password_result)
  return _internal_save_submitted_password_result();
}
inline ::autofill_assistant::SaveSubmittedPasswordProto_Result* ProcessedActionProto::unsafe_arena_release_save_submitted_password_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.save_submitted_password_result)
  if (_internal_has_save_submitted_password_result()) {
    clear_has_result_data();
    ::autofill_assistant::SaveSubmittedPasswordProto_Result* temp = result_data_.save_submitted_password_result_;
    result_data_.save_submitted_password_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_save_submitted_password_result(::autofill_assistant::SaveSubmittedPasswordProto_Result* save_submitted_password_result) {
  clear_result_data();
  if (save_submitted_password_result) {
    set_has_save_submitted_password_result();
    result_data_.save_submitted_password_result_ = save_submitted_password_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.save_submitted_password_result)
}
inline ::autofill_assistant::SaveSubmittedPasswordProto_Result* ProcessedActionProto::_internal_mutable_save_submitted_password_result() {
  if (!_internal_has_save_submitted_password_result()) {
    clear_result_data();
    set_has_save_submitted_password_result();
    result_data_.save_submitted_password_result_ = CreateMaybeMessage< ::autofill_assistant::SaveSubmittedPasswordProto_Result >(GetArenaForAllocation());
  }
  return result_data_.save_submitted_password_result_;
}
inline ::autofill_assistant::SaveSubmittedPasswordProto_Result* ProcessedActionProto::mutable_save_submitted_password_result() {
  ::autofill_assistant::SaveSubmittedPasswordProto_Result* _msg = _internal_mutable_save_submitted_password_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.save_submitted_password_result)
  return _msg;
}

// .autofill_assistant.ExternalActionProto.Result external_action_result = 39;
inline bool ProcessedActionProto::_internal_has_external_action_result() const {
  return result_data_case() == kExternalActionResult;
}
inline bool ProcessedActionProto::has_external_action_result() const {
  return _internal_has_external_action_result();
}
inline void ProcessedActionProto::set_has_external_action_result() {
  _oneof_case_[0] = kExternalActionResult;
}
inline void ProcessedActionProto::clear_external_action_result() {
  if (_internal_has_external_action_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.external_action_result_;
    }
    clear_has_result_data();
  }
}
inline ::autofill_assistant::ExternalActionProto_Result* ProcessedActionProto::release_external_action_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.external_action_result)
  if (_internal_has_external_action_result()) {
    clear_has_result_data();
    ::autofill_assistant::ExternalActionProto_Result* temp = result_data_.external_action_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_data_.external_action_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ExternalActionProto_Result& ProcessedActionProto::_internal_external_action_result() const {
  return _internal_has_external_action_result()
      ? *result_data_.external_action_result_
      : reinterpret_cast< ::autofill_assistant::ExternalActionProto_Result&>(::autofill_assistant::_ExternalActionProto_Result_default_instance_);
}
inline const ::autofill_assistant::ExternalActionProto_Result& ProcessedActionProto::external_action_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.external_action_result)
  return _internal_external_action_result();
}
inline ::autofill_assistant::ExternalActionProto_Result* ProcessedActionProto::unsafe_arena_release_external_action_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ProcessedActionProto.external_action_result)
  if (_internal_has_external_action_result()) {
    clear_has_result_data();
    ::autofill_assistant::ExternalActionProto_Result* temp = result_data_.external_action_result_;
    result_data_.external_action_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_external_action_result(::autofill_assistant::ExternalActionProto_Result* external_action_result) {
  clear_result_data();
  if (external_action_result) {
    set_has_external_action_result();
    result_data_.external_action_result_ = external_action_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.external_action_result)
}
inline ::autofill_assistant::ExternalActionProto_Result* ProcessedActionProto::_internal_mutable_external_action_result() {
  if (!_internal_has_external_action_result()) {
    clear_result_data();
    set_has_external_action_result();
    result_data_.external_action_result_ = CreateMaybeMessage< ::autofill_assistant::ExternalActionProto_Result >(GetArenaForAllocation());
  }
  return result_data_.external_action_result_;
}
inline ::autofill_assistant::ExternalActionProto_Result* ProcessedActionProto::mutable_external_action_result() {
  ::autofill_assistant::ExternalActionProto_Result* _msg = _internal_mutable_external_action_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.external_action_result)
  return _msg;
}

// optional .autofill_assistant.NavigationInfoProto navigation_info = 20;
inline bool ProcessedActionProto::_internal_has_navigation_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || navigation_info_ != nullptr);
  return value;
}
inline bool ProcessedActionProto::has_navigation_info() const {
  return _internal_has_navigation_info();
}
inline void ProcessedActionProto::clear_navigation_info() {
  if (navigation_info_ != nullptr) navigation_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::NavigationInfoProto& ProcessedActionProto::_internal_navigation_info() const {
  const ::autofill_assistant::NavigationInfoProto* p = navigation_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::NavigationInfoProto&>(
      ::autofill_assistant::_NavigationInfoProto_default_instance_);
}
inline const ::autofill_assistant::NavigationInfoProto& ProcessedActionProto::navigation_info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.navigation_info)
  return _internal_navigation_info();
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_navigation_info(
    ::autofill_assistant::NavigationInfoProto* navigation_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(navigation_info_);
  }
  navigation_info_ = navigation_info;
  if (navigation_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.navigation_info)
}
inline ::autofill_assistant::NavigationInfoProto* ProcessedActionProto::release_navigation_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::NavigationInfoProto* temp = navigation_info_;
  navigation_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::NavigationInfoProto* ProcessedActionProto::unsafe_arena_release_navigation_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.navigation_info)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::NavigationInfoProto* temp = navigation_info_;
  navigation_info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::NavigationInfoProto* ProcessedActionProto::_internal_mutable_navigation_info() {
  _has_bits_[0] |= 0x00000004u;
  if (navigation_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::NavigationInfoProto>(GetArenaForAllocation());
    navigation_info_ = p;
  }
  return navigation_info_;
}
inline ::autofill_assistant::NavigationInfoProto* ProcessedActionProto::mutable_navigation_info() {
  ::autofill_assistant::NavigationInfoProto* _msg = _internal_mutable_navigation_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.navigation_info)
  return _msg;
}
inline void ProcessedActionProto::set_allocated_navigation_info(::autofill_assistant::NavigationInfoProto* navigation_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete navigation_info_;
  }
  if (navigation_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(navigation_info);
    if (message_arena != submessage_arena) {
      navigation_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navigation_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  navigation_info_ = navigation_info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.navigation_info)
}

// optional int64 run_time_ms = 23;
inline bool ProcessedActionProto::_internal_has_run_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ProcessedActionProto::has_run_time_ms() const {
  return _internal_has_run_time_ms();
}
inline void ProcessedActionProto::clear_run_time_ms() {
  run_time_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t ProcessedActionProto::_internal_run_time_ms() const {
  return run_time_ms_;
}
inline int64_t ProcessedActionProto::run_time_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.run_time_ms)
  return _internal_run_time_ms();
}
inline void ProcessedActionProto::_internal_set_run_time_ms(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  run_time_ms_ = value;
}
inline void ProcessedActionProto::set_run_time_ms(int64_t value) {
  _internal_set_run_time_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ProcessedActionProto.run_time_ms)
}

// optional .autofill_assistant.ActionTimingStats timing_stats = 32;
inline bool ProcessedActionProto::_internal_has_timing_stats() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || timing_stats_ != nullptr);
  return value;
}
inline bool ProcessedActionProto::has_timing_stats() const {
  return _internal_has_timing_stats();
}
inline void ProcessedActionProto::clear_timing_stats() {
  if (timing_stats_ != nullptr) timing_stats_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::ActionTimingStats& ProcessedActionProto::_internal_timing_stats() const {
  const ::autofill_assistant::ActionTimingStats* p = timing_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ActionTimingStats&>(
      ::autofill_assistant::_ActionTimingStats_default_instance_);
}
inline const ::autofill_assistant::ActionTimingStats& ProcessedActionProto::timing_stats() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.timing_stats)
  return _internal_timing_stats();
}
inline void ProcessedActionProto::unsafe_arena_set_allocated_timing_stats(
    ::autofill_assistant::ActionTimingStats* timing_stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timing_stats_);
  }
  timing_stats_ = timing_stats;
  if (timing_stats) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionProto.timing_stats)
}
inline ::autofill_assistant::ActionTimingStats* ProcessedActionProto::release_timing_stats() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ActionTimingStats* temp = timing_stats_;
  timing_stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ActionTimingStats* ProcessedActionProto::unsafe_arena_release_timing_stats() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionProto.timing_stats)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ActionTimingStats* temp = timing_stats_;
  timing_stats_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ActionTimingStats* ProcessedActionProto::_internal_mutable_timing_stats() {
  _has_bits_[0] |= 0x00000008u;
  if (timing_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ActionTimingStats>(GetArenaForAllocation());
    timing_stats_ = p;
  }
  return timing_stats_;
}
inline ::autofill_assistant::ActionTimingStats* ProcessedActionProto::mutable_timing_stats() {
  ::autofill_assistant::ActionTimingStats* _msg = _internal_mutable_timing_stats();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionProto.timing_stats)
  return _msg;
}
inline void ProcessedActionProto::set_allocated_timing_stats(::autofill_assistant::ActionTimingStats* timing_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timing_stats_;
  }
  if (timing_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timing_stats);
    if (message_arena != submessage_arena) {
      timing_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing_stats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  timing_stats_ = timing_stats;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.timing_stats)
}

// optional .autofill_assistant.SlowWarningStatus slow_warning_status = 34;
inline bool ProcessedActionProto::_internal_has_slow_warning_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ProcessedActionProto::has_slow_warning_status() const {
  return _internal_has_slow_warning_status();
}
inline void ProcessedActionProto::clear_slow_warning_status() {
  slow_warning_status_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::autofill_assistant::SlowWarningStatus ProcessedActionProto::_internal_slow_warning_status() const {
  return static_cast< ::autofill_assistant::SlowWarningStatus >(slow_warning_status_);
}
inline ::autofill_assistant::SlowWarningStatus ProcessedActionProto::slow_warning_status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionProto.slow_warning_status)
  return _internal_slow_warning_status();
}
inline void ProcessedActionProto::_internal_set_slow_warning_status(::autofill_assistant::SlowWarningStatus value) {
  assert(::autofill_assistant::SlowWarningStatus_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  slow_warning_status_ = value;
}
inline void ProcessedActionProto::set_slow_warning_status(::autofill_assistant::SlowWarningStatus value) {
  _internal_set_slow_warning_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ProcessedActionProto.slow_warning_status)
}

inline bool ProcessedActionProto::has_result_data() const {
  return result_data_case() != RESULT_DATA_NOT_SET;
}
inline void ProcessedActionProto::clear_has_result_data() {
  _oneof_case_[0] = RESULT_DATA_NOT_SET;
}
inline ProcessedActionProto::ResultDataCase ProcessedActionProto::result_data_case() const {
  return ProcessedActionProto::ResultDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessedActionStatusDetailsProto

// optional .autofill_assistant.UnexpectedErrorInfoProto unexpected_error_info = 1;
inline bool ProcessedActionStatusDetailsProto::_internal_has_unexpected_error_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || unexpected_error_info_ != nullptr);
  return value;
}
inline bool ProcessedActionStatusDetailsProto::has_unexpected_error_info() const {
  return _internal_has_unexpected_error_info();
}
inline void ProcessedActionStatusDetailsProto::clear_unexpected_error_info() {
  if (unexpected_error_info_ != nullptr) unexpected_error_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::UnexpectedErrorInfoProto& ProcessedActionStatusDetailsProto::_internal_unexpected_error_info() const {
  const ::autofill_assistant::UnexpectedErrorInfoProto* p = unexpected_error_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::UnexpectedErrorInfoProto&>(
      ::autofill_assistant::_UnexpectedErrorInfoProto_default_instance_);
}
inline const ::autofill_assistant::UnexpectedErrorInfoProto& ProcessedActionStatusDetailsProto::unexpected_error_info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionStatusDetailsProto.unexpected_error_info)
  return _internal_unexpected_error_info();
}
inline void ProcessedActionStatusDetailsProto::unsafe_arena_set_allocated_unexpected_error_info(
    ::autofill_assistant::UnexpectedErrorInfoProto* unexpected_error_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unexpected_error_info_);
  }
  unexpected_error_info_ = unexpected_error_info;
  if (unexpected_error_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionStatusDetailsProto.unexpected_error_info)
}
inline ::autofill_assistant::UnexpectedErrorInfoProto* ProcessedActionStatusDetailsProto::release_unexpected_error_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::UnexpectedErrorInfoProto* temp = unexpected_error_info_;
  unexpected_error_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::UnexpectedErrorInfoProto* ProcessedActionStatusDetailsProto::unsafe_arena_release_unexpected_error_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionStatusDetailsProto.unexpected_error_info)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::UnexpectedErrorInfoProto* temp = unexpected_error_info_;
  unexpected_error_info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::UnexpectedErrorInfoProto* ProcessedActionStatusDetailsProto::_internal_mutable_unexpected_error_info() {
  _has_bits_[0] |= 0x00000001u;
  if (unexpected_error_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::UnexpectedErrorInfoProto>(GetArenaForAllocation());
    unexpected_error_info_ = p;
  }
  return unexpected_error_info_;
}
inline ::autofill_assistant::UnexpectedErrorInfoProto* ProcessedActionStatusDetailsProto::mutable_unexpected_error_info() {
  ::autofill_assistant::UnexpectedErrorInfoProto* _msg = _internal_mutable_unexpected_error_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionStatusDetailsProto.unexpected_error_info)
  return _msg;
}
inline void ProcessedActionStatusDetailsProto::set_allocated_unexpected_error_info(::autofill_assistant::UnexpectedErrorInfoProto* unexpected_error_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unexpected_error_info_;
  }
  if (unexpected_error_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unexpected_error_info);
    if (message_arena != submessage_arena) {
      unexpected_error_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unexpected_error_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unexpected_error_info_ = unexpected_error_info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionStatusDetailsProto.unexpected_error_info)
}

// optional .autofill_assistant.ProcessedActionStatusProto original_status = 2;
inline bool ProcessedActionStatusDetailsProto::_internal_has_original_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProcessedActionStatusDetailsProto::has_original_status() const {
  return _internal_has_original_status();
}
inline void ProcessedActionStatusDetailsProto::clear_original_status() {
  original_status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::ProcessedActionStatusProto ProcessedActionStatusDetailsProto::_internal_original_status() const {
  return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(original_status_);
}
inline ::autofill_assistant::ProcessedActionStatusProto ProcessedActionStatusDetailsProto::original_status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionStatusDetailsProto.original_status)
  return _internal_original_status();
}
inline void ProcessedActionStatusDetailsProto::_internal_set_original_status(::autofill_assistant::ProcessedActionStatusProto value) {
  assert(::autofill_assistant::ProcessedActionStatusProto_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  original_status_ = value;
}
inline void ProcessedActionStatusDetailsProto::set_original_status(::autofill_assistant::ProcessedActionStatusProto value) {
  _internal_set_original_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ProcessedActionStatusDetailsProto.original_status)
}

// optional .autofill_assistant.AutofillErrorInfoProto autofill_error_info = 3;
inline bool ProcessedActionStatusDetailsProto::_internal_has_autofill_error_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || autofill_error_info_ != nullptr);
  return value;
}
inline bool ProcessedActionStatusDetailsProto::has_autofill_error_info() const {
  return _internal_has_autofill_error_info();
}
inline void ProcessedActionStatusDetailsProto::clear_autofill_error_info() {
  if (autofill_error_info_ != nullptr) autofill_error_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::AutofillErrorInfoProto& ProcessedActionStatusDetailsProto::_internal_autofill_error_info() const {
  const ::autofill_assistant::AutofillErrorInfoProto* p = autofill_error_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::AutofillErrorInfoProto&>(
      ::autofill_assistant::_AutofillErrorInfoProto_default_instance_);
}
inline const ::autofill_assistant::AutofillErrorInfoProto& ProcessedActionStatusDetailsProto::autofill_error_info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionStatusDetailsProto.autofill_error_info)
  return _internal_autofill_error_info();
}
inline void ProcessedActionStatusDetailsProto::unsafe_arena_set_allocated_autofill_error_info(
    ::autofill_assistant::AutofillErrorInfoProto* autofill_error_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(autofill_error_info_);
  }
  autofill_error_info_ = autofill_error_info;
  if (autofill_error_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionStatusDetailsProto.autofill_error_info)
}
inline ::autofill_assistant::AutofillErrorInfoProto* ProcessedActionStatusDetailsProto::release_autofill_error_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillErrorInfoProto* temp = autofill_error_info_;
  autofill_error_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::AutofillErrorInfoProto* ProcessedActionStatusDetailsProto::unsafe_arena_release_autofill_error_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionStatusDetailsProto.autofill_error_info)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillErrorInfoProto* temp = autofill_error_info_;
  autofill_error_info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::AutofillErrorInfoProto* ProcessedActionStatusDetailsProto::_internal_mutable_autofill_error_info() {
  _has_bits_[0] |= 0x00000002u;
  if (autofill_error_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::AutofillErrorInfoProto>(GetArenaForAllocation());
    autofill_error_info_ = p;
  }
  return autofill_error_info_;
}
inline ::autofill_assistant::AutofillErrorInfoProto* ProcessedActionStatusDetailsProto::mutable_autofill_error_info() {
  ::autofill_assistant::AutofillErrorInfoProto* _msg = _internal_mutable_autofill_error_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionStatusDetailsProto.autofill_error_info)
  return _msg;
}
inline void ProcessedActionStatusDetailsProto::set_allocated_autofill_error_info(::autofill_assistant::AutofillErrorInfoProto* autofill_error_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete autofill_error_info_;
  }
  if (autofill_error_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(autofill_error_info);
    if (message_arena != submessage_arena) {
      autofill_error_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autofill_error_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  autofill_error_info_ = autofill_error_info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionStatusDetailsProto.autofill_error_info)
}

// optional .autofill_assistant.WebControllerErrorInfoProto web_controller_error_info = 5;
inline bool ProcessedActionStatusDetailsProto::_internal_has_web_controller_error_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || web_controller_error_info_ != nullptr);
  return value;
}
inline bool ProcessedActionStatusDetailsProto::has_web_controller_error_info() const {
  return _internal_has_web_controller_error_info();
}
inline void ProcessedActionStatusDetailsProto::clear_web_controller_error_info() {
  if (web_controller_error_info_ != nullptr) web_controller_error_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::WebControllerErrorInfoProto& ProcessedActionStatusDetailsProto::_internal_web_controller_error_info() const {
  const ::autofill_assistant::WebControllerErrorInfoProto* p = web_controller_error_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::WebControllerErrorInfoProto&>(
      ::autofill_assistant::_WebControllerErrorInfoProto_default_instance_);
}
inline const ::autofill_assistant::WebControllerErrorInfoProto& ProcessedActionStatusDetailsProto::web_controller_error_info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionStatusDetailsProto.web_controller_error_info)
  return _internal_web_controller_error_info();
}
inline void ProcessedActionStatusDetailsProto::unsafe_arena_set_allocated_web_controller_error_info(
    ::autofill_assistant::WebControllerErrorInfoProto* web_controller_error_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_controller_error_info_);
  }
  web_controller_error_info_ = web_controller_error_info;
  if (web_controller_error_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ProcessedActionStatusDetailsProto.web_controller_error_info)
}
inline ::autofill_assistant::WebControllerErrorInfoProto* ProcessedActionStatusDetailsProto::release_web_controller_error_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::WebControllerErrorInfoProto* temp = web_controller_error_info_;
  web_controller_error_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::WebControllerErrorInfoProto* ProcessedActionStatusDetailsProto::unsafe_arena_release_web_controller_error_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProcessedActionStatusDetailsProto.web_controller_error_info)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::WebControllerErrorInfoProto* temp = web_controller_error_info_;
  web_controller_error_info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::WebControllerErrorInfoProto* ProcessedActionStatusDetailsProto::_internal_mutable_web_controller_error_info() {
  _has_bits_[0] |= 0x00000004u;
  if (web_controller_error_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::WebControllerErrorInfoProto>(GetArenaForAllocation());
    web_controller_error_info_ = p;
  }
  return web_controller_error_info_;
}
inline ::autofill_assistant::WebControllerErrorInfoProto* ProcessedActionStatusDetailsProto::mutable_web_controller_error_info() {
  ::autofill_assistant::WebControllerErrorInfoProto* _msg = _internal_mutable_web_controller_error_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionStatusDetailsProto.web_controller_error_info)
  return _msg;
}
inline void ProcessedActionStatusDetailsProto::set_allocated_web_controller_error_info(::autofill_assistant::WebControllerErrorInfoProto* web_controller_error_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete web_controller_error_info_;
  }
  if (web_controller_error_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(web_controller_error_info);
    if (message_arena != submessage_arena) {
      web_controller_error_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_controller_error_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  web_controller_error_info_ = web_controller_error_info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionStatusDetailsProto.web_controller_error_info)
}

// repeated .autofill_assistant.ElementFinderInfoProto element_finder_info = 6;
inline int ProcessedActionStatusDetailsProto::_internal_element_finder_info_size() const {
  return element_finder_info_.size();
}
inline int ProcessedActionStatusDetailsProto::element_finder_info_size() const {
  return _internal_element_finder_info_size();
}
inline void ProcessedActionStatusDetailsProto::clear_element_finder_info() {
  element_finder_info_.Clear();
}
inline ::autofill_assistant::ElementFinderInfoProto* ProcessedActionStatusDetailsProto::mutable_element_finder_info(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProcessedActionStatusDetailsProto.element_finder_info)
  return element_finder_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto >*
ProcessedActionStatusDetailsProto::mutable_element_finder_info() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ProcessedActionStatusDetailsProto.element_finder_info)
  return &element_finder_info_;
}
inline const ::autofill_assistant::ElementFinderInfoProto& ProcessedActionStatusDetailsProto::_internal_element_finder_info(int index) const {
  return element_finder_info_.Get(index);
}
inline const ::autofill_assistant::ElementFinderInfoProto& ProcessedActionStatusDetailsProto::element_finder_info(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProcessedActionStatusDetailsProto.element_finder_info)
  return _internal_element_finder_info(index);
}
inline ::autofill_assistant::ElementFinderInfoProto* ProcessedActionStatusDetailsProto::_internal_add_element_finder_info() {
  return element_finder_info_.Add();
}
inline ::autofill_assistant::ElementFinderInfoProto* ProcessedActionStatusDetailsProto::add_element_finder_info() {
  ::autofill_assistant::ElementFinderInfoProto* _add = _internal_add_element_finder_info();
  // @@protoc_insertion_point(field_add:autofill_assistant.ProcessedActionStatusDetailsProto.element_finder_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto >&
ProcessedActionStatusDetailsProto::element_finder_info() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ProcessedActionStatusDetailsProto.element_finder_info)
  return element_finder_info_;
}

// -------------------------------------------------------------------

// NavigationInfoProto

// optional bool started = 1;
inline bool NavigationInfoProto::_internal_has_started() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NavigationInfoProto::has_started() const {
  return _internal_has_started();
}
inline void NavigationInfoProto::clear_started() {
  started_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool NavigationInfoProto::_internal_started() const {
  return started_;
}
inline bool NavigationInfoProto::started() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigationInfoProto.started)
  return _internal_started();
}
inline void NavigationInfoProto::_internal_set_started(bool value) {
  _has_bits_[0] |= 0x00000001u;
  started_ = value;
}
inline void NavigationInfoProto::set_started(bool value) {
  _internal_set_started(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigationInfoProto.started)
}

// optional bool ended = 2;
inline bool NavigationInfoProto::_internal_has_ended() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NavigationInfoProto::has_ended() const {
  return _internal_has_ended();
}
inline void NavigationInfoProto::clear_ended() {
  ended_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool NavigationInfoProto::_internal_ended() const {
  return ended_;
}
inline bool NavigationInfoProto::ended() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigationInfoProto.ended)
  return _internal_ended();
}
inline void NavigationInfoProto::_internal_set_ended(bool value) {
  _has_bits_[0] |= 0x00000002u;
  ended_ = value;
}
inline void NavigationInfoProto::set_ended(bool value) {
  _internal_set_ended(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigationInfoProto.ended)
}

// optional bool has_error = 3;
inline bool NavigationInfoProto::_internal_has_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NavigationInfoProto::has_has_error() const {
  return _internal_has_has_error();
}
inline void NavigationInfoProto::clear_has_error() {
  has_error_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool NavigationInfoProto::_internal_has_error() const {
  return has_error_;
}
inline bool NavigationInfoProto::has_error() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigationInfoProto.has_error)
  return _internal_has_error();
}
inline void NavigationInfoProto::_internal_set_has_error(bool value) {
  _has_bits_[0] |= 0x00000004u;
  has_error_ = value;
}
inline void NavigationInfoProto::set_has_error(bool value) {
  _internal_set_has_error(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigationInfoProto.has_error)
}

// optional bool unexpected = 4;
inline bool NavigationInfoProto::_internal_has_unexpected() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NavigationInfoProto::has_unexpected() const {
  return _internal_has_unexpected();
}
inline void NavigationInfoProto::clear_unexpected() {
  unexpected_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool NavigationInfoProto::_internal_unexpected() const {
  return unexpected_;
}
inline bool NavigationInfoProto::unexpected() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigationInfoProto.unexpected)
  return _internal_unexpected();
}
inline void NavigationInfoProto::_internal_set_unexpected(bool value) {
  _has_bits_[0] |= 0x00000008u;
  unexpected_ = value;
}
inline void NavigationInfoProto::set_unexpected(bool value) {
  _internal_set_unexpected(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigationInfoProto.unexpected)
}

// -------------------------------------------------------------------

// UnexpectedErrorInfoProto

// optional string source_file = 1;
inline bool UnexpectedErrorInfoProto::_internal_has_source_file() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnexpectedErrorInfoProto::has_source_file() const {
  return _internal_has_source_file();
}
inline void UnexpectedErrorInfoProto::clear_source_file() {
  source_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnexpectedErrorInfoProto::source_file() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.source_file)
  return _internal_source_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnexpectedErrorInfoProto::set_source_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 source_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.source_file)
}
inline std::string* UnexpectedErrorInfoProto::mutable_source_file() {
  std::string* _s = _internal_mutable_source_file();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UnexpectedErrorInfoProto.source_file)
  return _s;
}
inline const std::string& UnexpectedErrorInfoProto::_internal_source_file() const {
  return source_file_.Get();
}
inline void UnexpectedErrorInfoProto::_internal_set_source_file(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  source_file_.Set(value, GetArenaForAllocation());
}
inline std::string* UnexpectedErrorInfoProto::_internal_mutable_source_file() {
  _has_bits_[0] |= 0x00000001u;
  return source_file_.Mutable(GetArenaForAllocation());
}
inline std::string* UnexpectedErrorInfoProto::release_source_file() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UnexpectedErrorInfoProto.source_file)
  if (!_internal_has_source_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = source_file_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_file_.IsDefault()) {
    source_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnexpectedErrorInfoProto::set_allocated_source_file(std::string* source_file) {
  if (source_file != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  source_file_.SetAllocated(source_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_file_.IsDefault()) {
    source_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UnexpectedErrorInfoProto.source_file)
}

// optional int32 source_line_number = 2;
inline bool UnexpectedErrorInfoProto::_internal_has_source_line_number() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UnexpectedErrorInfoProto::has_source_line_number() const {
  return _internal_has_source_line_number();
}
inline void UnexpectedErrorInfoProto::clear_source_line_number() {
  source_line_number_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t UnexpectedErrorInfoProto::_internal_source_line_number() const {
  return source_line_number_;
}
inline int32_t UnexpectedErrorInfoProto::source_line_number() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.source_line_number)
  return _internal_source_line_number();
}
inline void UnexpectedErrorInfoProto::_internal_set_source_line_number(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  source_line_number_ = value;
}
inline void UnexpectedErrorInfoProto::set_source_line_number(int32_t value) {
  _internal_set_source_line_number(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.source_line_number)
}

// optional string js_exception_classname = 3;
inline bool UnexpectedErrorInfoProto::_internal_has_js_exception_classname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnexpectedErrorInfoProto::has_js_exception_classname() const {
  return _internal_has_js_exception_classname();
}
inline void UnexpectedErrorInfoProto::clear_js_exception_classname() {
  js_exception_classname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UnexpectedErrorInfoProto::js_exception_classname() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.js_exception_classname)
  return _internal_js_exception_classname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnexpectedErrorInfoProto::set_js_exception_classname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 js_exception_classname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.js_exception_classname)
}
inline std::string* UnexpectedErrorInfoProto::mutable_js_exception_classname() {
  std::string* _s = _internal_mutable_js_exception_classname();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UnexpectedErrorInfoProto.js_exception_classname)
  return _s;
}
inline const std::string& UnexpectedErrorInfoProto::_internal_js_exception_classname() const {
  return js_exception_classname_.Get();
}
inline void UnexpectedErrorInfoProto::_internal_set_js_exception_classname(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  js_exception_classname_.Set(value, GetArenaForAllocation());
}
inline std::string* UnexpectedErrorInfoProto::_internal_mutable_js_exception_classname() {
  _has_bits_[0] |= 0x00000002u;
  return js_exception_classname_.Mutable(GetArenaForAllocation());
}
inline std::string* UnexpectedErrorInfoProto::release_js_exception_classname() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UnexpectedErrorInfoProto.js_exception_classname)
  if (!_internal_has_js_exception_classname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = js_exception_classname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_exception_classname_.IsDefault()) {
    js_exception_classname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnexpectedErrorInfoProto::set_allocated_js_exception_classname(std::string* js_exception_classname) {
  if (js_exception_classname != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  js_exception_classname_.SetAllocated(js_exception_classname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_exception_classname_.IsDefault()) {
    js_exception_classname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UnexpectedErrorInfoProto.js_exception_classname)
}

// repeated .autofill_assistant.UnexpectedErrorInfoProto.JsExceptionLocation js_exception_locations = 8 [packed = true];
inline int UnexpectedErrorInfoProto::_internal_js_exception_locations_size() const {
  return js_exception_locations_.size();
}
inline int UnexpectedErrorInfoProto::js_exception_locations_size() const {
  return _internal_js_exception_locations_size();
}
inline void UnexpectedErrorInfoProto::clear_js_exception_locations() {
  js_exception_locations_.Clear();
}
inline ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::_internal_js_exception_locations(int index) const {
  return static_cast< ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation >(js_exception_locations_.Get(index));
}
inline ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::js_exception_locations(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.js_exception_locations)
  return _internal_js_exception_locations(index);
}
inline void UnexpectedErrorInfoProto::set_js_exception_locations(int index, ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation value) {
  assert(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation_IsValid(value));
  js_exception_locations_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.js_exception_locations)
}
inline void UnexpectedErrorInfoProto::_internal_add_js_exception_locations(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation value) {
  assert(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation_IsValid(value));
  js_exception_locations_.Add(value);
}
inline void UnexpectedErrorInfoProto::add_js_exception_locations(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation value) {
  _internal_add_js_exception_locations(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.UnexpectedErrorInfoProto.js_exception_locations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UnexpectedErrorInfoProto::js_exception_locations() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UnexpectedErrorInfoProto.js_exception_locations)
  return js_exception_locations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UnexpectedErrorInfoProto::_internal_mutable_js_exception_locations() {
  return &js_exception_locations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UnexpectedErrorInfoProto::mutable_js_exception_locations() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UnexpectedErrorInfoProto.js_exception_locations)
  return _internal_mutable_js_exception_locations();
}

// repeated int32 js_exception_line_numbers = 4;
inline int UnexpectedErrorInfoProto::_internal_js_exception_line_numbers_size() const {
  return js_exception_line_numbers_.size();
}
inline int UnexpectedErrorInfoProto::js_exception_line_numbers_size() const {
  return _internal_js_exception_line_numbers_size();
}
inline void UnexpectedErrorInfoProto::clear_js_exception_line_numbers() {
  js_exception_line_numbers_.Clear();
}
inline int32_t UnexpectedErrorInfoProto::_internal_js_exception_line_numbers(int index) const {
  return js_exception_line_numbers_.Get(index);
}
inline int32_t UnexpectedErrorInfoProto::js_exception_line_numbers(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.js_exception_line_numbers)
  return _internal_js_exception_line_numbers(index);
}
inline void UnexpectedErrorInfoProto::set_js_exception_line_numbers(int index, int32_t value) {
  js_exception_line_numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.js_exception_line_numbers)
}
inline void UnexpectedErrorInfoProto::_internal_add_js_exception_line_numbers(int32_t value) {
  js_exception_line_numbers_.Add(value);
}
inline void UnexpectedErrorInfoProto::add_js_exception_line_numbers(int32_t value) {
  _internal_add_js_exception_line_numbers(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.UnexpectedErrorInfoProto.js_exception_line_numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UnexpectedErrorInfoProto::_internal_js_exception_line_numbers() const {
  return js_exception_line_numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UnexpectedErrorInfoProto::js_exception_line_numbers() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UnexpectedErrorInfoProto.js_exception_line_numbers)
  return _internal_js_exception_line_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UnexpectedErrorInfoProto::_internal_mutable_js_exception_line_numbers() {
  return &js_exception_line_numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UnexpectedErrorInfoProto::mutable_js_exception_line_numbers() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UnexpectedErrorInfoProto.js_exception_line_numbers)
  return _internal_mutable_js_exception_line_numbers();
}

// repeated int32 js_exception_column_numbers = 5;
inline int UnexpectedErrorInfoProto::_internal_js_exception_column_numbers_size() const {
  return js_exception_column_numbers_.size();
}
inline int UnexpectedErrorInfoProto::js_exception_column_numbers_size() const {
  return _internal_js_exception_column_numbers_size();
}
inline void UnexpectedErrorInfoProto::clear_js_exception_column_numbers() {
  js_exception_column_numbers_.Clear();
}
inline int32_t UnexpectedErrorInfoProto::_internal_js_exception_column_numbers(int index) const {
  return js_exception_column_numbers_.Get(index);
}
inline int32_t UnexpectedErrorInfoProto::js_exception_column_numbers(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.js_exception_column_numbers)
  return _internal_js_exception_column_numbers(index);
}
inline void UnexpectedErrorInfoProto::set_js_exception_column_numbers(int index, int32_t value) {
  js_exception_column_numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.js_exception_column_numbers)
}
inline void UnexpectedErrorInfoProto::_internal_add_js_exception_column_numbers(int32_t value) {
  js_exception_column_numbers_.Add(value);
}
inline void UnexpectedErrorInfoProto::add_js_exception_column_numbers(int32_t value) {
  _internal_add_js_exception_column_numbers(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.UnexpectedErrorInfoProto.js_exception_column_numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UnexpectedErrorInfoProto::_internal_js_exception_column_numbers() const {
  return js_exception_column_numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UnexpectedErrorInfoProto::js_exception_column_numbers() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UnexpectedErrorInfoProto.js_exception_column_numbers)
  return _internal_js_exception_column_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UnexpectedErrorInfoProto::_internal_mutable_js_exception_column_numbers() {
  return &js_exception_column_numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UnexpectedErrorInfoProto::mutable_js_exception_column_numbers() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UnexpectedErrorInfoProto.js_exception_column_numbers)
  return _internal_mutable_js_exception_column_numbers();
}

// optional int32 devtools_error_code = 6;
inline bool UnexpectedErrorInfoProto::_internal_has_devtools_error_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UnexpectedErrorInfoProto::has_devtools_error_code() const {
  return _internal_has_devtools_error_code();
}
inline void UnexpectedErrorInfoProto::clear_devtools_error_code() {
  devtools_error_code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t UnexpectedErrorInfoProto::_internal_devtools_error_code() const {
  return devtools_error_code_;
}
inline int32_t UnexpectedErrorInfoProto::devtools_error_code() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_code)
  return _internal_devtools_error_code();
}
inline void UnexpectedErrorInfoProto::_internal_set_devtools_error_code(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  devtools_error_code_ = value;
}
inline void UnexpectedErrorInfoProto::set_devtools_error_code(int32_t value) {
  _internal_set_devtools_error_code(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_code)
}

// optional string devtools_error_message = 7;
inline bool UnexpectedErrorInfoProto::_internal_has_devtools_error_message() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnexpectedErrorInfoProto::has_devtools_error_message() const {
  return _internal_has_devtools_error_message();
}
inline void UnexpectedErrorInfoProto::clear_devtools_error_message() {
  devtools_error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UnexpectedErrorInfoProto::devtools_error_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_message)
  return _internal_devtools_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnexpectedErrorInfoProto::set_devtools_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 devtools_error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_message)
}
inline std::string* UnexpectedErrorInfoProto::mutable_devtools_error_message() {
  std::string* _s = _internal_mutable_devtools_error_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_message)
  return _s;
}
inline const std::string& UnexpectedErrorInfoProto::_internal_devtools_error_message() const {
  return devtools_error_message_.Get();
}
inline void UnexpectedErrorInfoProto::_internal_set_devtools_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  devtools_error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* UnexpectedErrorInfoProto::_internal_mutable_devtools_error_message() {
  _has_bits_[0] |= 0x00000004u;
  return devtools_error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* UnexpectedErrorInfoProto::release_devtools_error_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_message)
  if (!_internal_has_devtools_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = devtools_error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (devtools_error_message_.IsDefault()) {
    devtools_error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnexpectedErrorInfoProto::set_allocated_devtools_error_message(std::string* devtools_error_message) {
  if (devtools_error_message != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  devtools_error_message_.SetAllocated(devtools_error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (devtools_error_message_.IsDefault()) {
    devtools_error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UnexpectedErrorInfoProto.devtools_error_message)
}

// -------------------------------------------------------------------

// AutofillErrorInfoProto_AutofillFieldError

// optional .autofill_assistant.SelectorProto field = 1;
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_has_field() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || field_ != nullptr);
  return value;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::has_field() const {
  return _internal_has_field();
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::SelectorProto& AutofillErrorInfoProto_AutofillFieldError::_internal_field() const {
  const ::autofill_assistant::SelectorProto* p = field_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& AutofillErrorInfoProto_AutofillFieldError::field() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.field)
  return _internal_field();
}
inline void AutofillErrorInfoProto_AutofillFieldError::unsafe_arena_set_allocated_field(
    ::autofill_assistant::SelectorProto* field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_);
  }
  field_ = field;
  if (field) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.field)
}
inline ::autofill_assistant::SelectorProto* AutofillErrorInfoProto_AutofillFieldError::release_field() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = field_;
  field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* AutofillErrorInfoProto_AutofillFieldError::unsafe_arena_release_field() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.field)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* AutofillErrorInfoProto_AutofillFieldError::_internal_mutable_field() {
  _has_bits_[0] |= 0x00000002u;
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    field_ = p;
  }
  return field_;
}
inline ::autofill_assistant::SelectorProto* AutofillErrorInfoProto_AutofillFieldError::mutable_field() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.field)
  return _msg;
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_allocated_field(::autofill_assistant::SelectorProto* field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(field);
    if (message_arena != submessage_arena) {
      field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.field)
}

// optional string value_expression = 5;
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_has_value_expression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::has_value_expression() const {
  return _internal_has_value_expression();
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_value_expression() {
  value_expression_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillErrorInfoProto_AutofillFieldError::value_expression() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.value_expression)
  return _internal_value_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillErrorInfoProto_AutofillFieldError::set_value_expression(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_expression_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.value_expression)
}
inline std::string* AutofillErrorInfoProto_AutofillFieldError::mutable_value_expression() {
  std::string* _s = _internal_mutable_value_expression();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.value_expression)
  return _s;
}
inline const std::string& AutofillErrorInfoProto_AutofillFieldError::_internal_value_expression() const {
  return value_expression_.Get();
}
inline void AutofillErrorInfoProto_AutofillFieldError::_internal_set_value_expression(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_expression_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillErrorInfoProto_AutofillFieldError::_internal_mutable_value_expression() {
  _has_bits_[0] |= 0x00000001u;
  return value_expression_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillErrorInfoProto_AutofillFieldError::release_value_expression() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.value_expression)
  if (!_internal_has_value_expression()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_expression_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_expression_.IsDefault()) {
    value_expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_allocated_value_expression(std::string* value_expression) {
  if (value_expression != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_expression_.SetAllocated(value_expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_expression_.IsDefault()) {
    value_expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.value_expression)
}

// bool no_fallback_value = 3;
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_has_no_fallback_value() const {
  return error_type_case() == kNoFallbackValue;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::has_no_fallback_value() const {
  return _internal_has_no_fallback_value();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_has_no_fallback_value() {
  _oneof_case_[0] = kNoFallbackValue;
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_no_fallback_value() {
  if (_internal_has_no_fallback_value()) {
    error_type_.no_fallback_value_ = false;
    clear_has_error_type();
  }
}
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_no_fallback_value() const {
  if (_internal_has_no_fallback_value()) {
    return error_type_.no_fallback_value_;
  }
  return false;
}
inline void AutofillErrorInfoProto_AutofillFieldError::_internal_set_no_fallback_value(bool value) {
  if (!_internal_has_no_fallback_value()) {
    clear_error_type();
    set_has_no_fallback_value();
  }
  error_type_.no_fallback_value_ = value;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::no_fallback_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.no_fallback_value)
  return _internal_no_fallback_value();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_no_fallback_value(bool value) {
  _internal_set_no_fallback_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.no_fallback_value)
}

// .autofill_assistant.ProcessedActionStatusProto status = 4;
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_has_status() const {
  return error_type_case() == kStatus;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::has_status() const {
  return _internal_has_status();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_status() {
  if (_internal_has_status()) {
    error_type_.status_ = 0;
    clear_has_error_type();
  }
}
inline ::autofill_assistant::ProcessedActionStatusProto AutofillErrorInfoProto_AutofillFieldError::_internal_status() const {
  if (_internal_has_status()) {
    return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(error_type_.status_);
  }
  return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(0);
}
inline ::autofill_assistant::ProcessedActionStatusProto AutofillErrorInfoProto_AutofillFieldError::status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.status)
  return _internal_status();
}
inline void AutofillErrorInfoProto_AutofillFieldError::_internal_set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  assert(::autofill_assistant::ProcessedActionStatusProto_IsValid(value));
  if (!_internal_has_status()) {
    clear_error_type();
    set_has_status();
  }
  error_type_.status_ = value;
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.status)
}

// bool empty_after_fallback = 6;
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_has_empty_after_fallback() const {
  return error_type_case() == kEmptyAfterFallback;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::has_empty_after_fallback() const {
  return _internal_has_empty_after_fallback();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_has_empty_after_fallback() {
  _oneof_case_[0] = kEmptyAfterFallback;
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_empty_after_fallback() {
  if (_internal_has_empty_after_fallback()) {
    error_type_.empty_after_fallback_ = false;
    clear_has_error_type();
  }
}
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_empty_after_fallback() const {
  if (_internal_has_empty_after_fallback()) {
    return error_type_.empty_after_fallback_;
  }
  return false;
}
inline void AutofillErrorInfoProto_AutofillFieldError::_internal_set_empty_after_fallback(bool value) {
  if (!_internal_has_empty_after_fallback()) {
    clear_error_type();
    set_has_empty_after_fallback();
  }
  error_type_.empty_after_fallback_ = value;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::empty_after_fallback() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.empty_after_fallback)
  return _internal_empty_after_fallback();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_empty_after_fallback(bool value) {
  _internal_set_empty_after_fallback(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.empty_after_fallback)
}

// bool filled_after_clear = 7;
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_has_filled_after_clear() const {
  return error_type_case() == kFilledAfterClear;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::has_filled_after_clear() const {
  return _internal_has_filled_after_clear();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_has_filled_after_clear() {
  _oneof_case_[0] = kFilledAfterClear;
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_filled_after_clear() {
  if (_internal_has_filled_after_clear()) {
    error_type_.filled_after_clear_ = false;
    clear_has_error_type();
  }
}
inline bool AutofillErrorInfoProto_AutofillFieldError::_internal_filled_after_clear() const {
  if (_internal_has_filled_after_clear()) {
    return error_type_.filled_after_clear_;
  }
  return false;
}
inline void AutofillErrorInfoProto_AutofillFieldError::_internal_set_filled_after_clear(bool value) {
  if (!_internal_has_filled_after_clear()) {
    clear_error_type();
    set_has_filled_after_clear();
  }
  error_type_.filled_after_clear_ = value;
}
inline bool AutofillErrorInfoProto_AutofillFieldError::filled_after_clear() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.filled_after_clear)
  return _internal_filled_after_clear();
}
inline void AutofillErrorInfoProto_AutofillFieldError::set_filled_after_clear(bool value) {
  _internal_set_filled_after_clear(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError.filled_after_clear)
}

inline bool AutofillErrorInfoProto_AutofillFieldError::has_error_type() const {
  return error_type_case() != ERROR_TYPE_NOT_SET;
}
inline void AutofillErrorInfoProto_AutofillFieldError::clear_has_error_type() {
  _oneof_case_[0] = ERROR_TYPE_NOT_SET;
}
inline AutofillErrorInfoProto_AutofillFieldError::ErrorTypeCase AutofillErrorInfoProto_AutofillFieldError::error_type_case() const {
  return AutofillErrorInfoProto_AutofillFieldError::ErrorTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AutofillErrorInfoProto

// optional string client_memory_address_key_names = 1;
inline bool AutofillErrorInfoProto::_internal_has_client_memory_address_key_names() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillErrorInfoProto::has_client_memory_address_key_names() const {
  return _internal_has_client_memory_address_key_names();
}
inline void AutofillErrorInfoProto::clear_client_memory_address_key_names() {
  client_memory_address_key_names_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillErrorInfoProto::client_memory_address_key_names() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.client_memory_address_key_names)
  return _internal_client_memory_address_key_names();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillErrorInfoProto::set_client_memory_address_key_names(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_memory_address_key_names_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.client_memory_address_key_names)
}
inline std::string* AutofillErrorInfoProto::mutable_client_memory_address_key_names() {
  std::string* _s = _internal_mutable_client_memory_address_key_names();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillErrorInfoProto.client_memory_address_key_names)
  return _s;
}
inline const std::string& AutofillErrorInfoProto::_internal_client_memory_address_key_names() const {
  return client_memory_address_key_names_.Get();
}
inline void AutofillErrorInfoProto::_internal_set_client_memory_address_key_names(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_memory_address_key_names_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillErrorInfoProto::_internal_mutable_client_memory_address_key_names() {
  _has_bits_[0] |= 0x00000001u;
  return client_memory_address_key_names_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillErrorInfoProto::release_client_memory_address_key_names() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillErrorInfoProto.client_memory_address_key_names)
  if (!_internal_has_client_memory_address_key_names()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = client_memory_address_key_names_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_memory_address_key_names_.IsDefault()) {
    client_memory_address_key_names_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillErrorInfoProto::set_allocated_client_memory_address_key_names(std::string* client_memory_address_key_names) {
  if (client_memory_address_key_names != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_memory_address_key_names_.SetAllocated(client_memory_address_key_names, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_memory_address_key_names_.IsDefault()) {
    client_memory_address_key_names_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillErrorInfoProto.client_memory_address_key_names)
}

// optional string address_key_requested = 2;
inline bool AutofillErrorInfoProto::_internal_has_address_key_requested() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillErrorInfoProto::has_address_key_requested() const {
  return _internal_has_address_key_requested();
}
inline void AutofillErrorInfoProto::clear_address_key_requested() {
  address_key_requested_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillErrorInfoProto::address_key_requested() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.address_key_requested)
  return _internal_address_key_requested();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillErrorInfoProto::set_address_key_requested(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 address_key_requested_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.address_key_requested)
}
inline std::string* AutofillErrorInfoProto::mutable_address_key_requested() {
  std::string* _s = _internal_mutable_address_key_requested();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillErrorInfoProto.address_key_requested)
  return _s;
}
inline const std::string& AutofillErrorInfoProto::_internal_address_key_requested() const {
  return address_key_requested_.Get();
}
inline void AutofillErrorInfoProto::_internal_set_address_key_requested(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  address_key_requested_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillErrorInfoProto::_internal_mutable_address_key_requested() {
  _has_bits_[0] |= 0x00000002u;
  return address_key_requested_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillErrorInfoProto::release_address_key_requested() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillErrorInfoProto.address_key_requested)
  if (!_internal_has_address_key_requested()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = address_key_requested_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_key_requested_.IsDefault()) {
    address_key_requested_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillErrorInfoProto::set_allocated_address_key_requested(std::string* address_key_requested) {
  if (address_key_requested != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  address_key_requested_.SetAllocated(address_key_requested, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_key_requested_.IsDefault()) {
    address_key_requested_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillErrorInfoProto.address_key_requested)
}

// optional bool address_pointee_was_null = 3;
inline bool AutofillErrorInfoProto::_internal_has_address_pointee_was_null() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutofillErrorInfoProto::has_address_pointee_was_null() const {
  return _internal_has_address_pointee_was_null();
}
inline void AutofillErrorInfoProto::clear_address_pointee_was_null() {
  address_pointee_was_null_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool AutofillErrorInfoProto::_internal_address_pointee_was_null() const {
  return address_pointee_was_null_;
}
inline bool AutofillErrorInfoProto::address_pointee_was_null() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.address_pointee_was_null)
  return _internal_address_pointee_was_null();
}
inline void AutofillErrorInfoProto::_internal_set_address_pointee_was_null(bool value) {
  _has_bits_[0] |= 0x00000004u;
  address_pointee_was_null_ = value;
}
inline void AutofillErrorInfoProto::set_address_pointee_was_null(bool value) {
  _internal_set_address_pointee_was_null(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.address_pointee_was_null)
}

// optional .autofill_assistant.ProcessedActionStatusProto autofill_error_status = 4;
inline bool AutofillErrorInfoProto::_internal_has_autofill_error_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutofillErrorInfoProto::has_autofill_error_status() const {
  return _internal_has_autofill_error_status();
}
inline void AutofillErrorInfoProto::clear_autofill_error_status() {
  autofill_error_status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::ProcessedActionStatusProto AutofillErrorInfoProto::_internal_autofill_error_status() const {
  return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(autofill_error_status_);
}
inline ::autofill_assistant::ProcessedActionStatusProto AutofillErrorInfoProto::autofill_error_status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.autofill_error_status)
  return _internal_autofill_error_status();
}
inline void AutofillErrorInfoProto::_internal_set_autofill_error_status(::autofill_assistant::ProcessedActionStatusProto value) {
  assert(::autofill_assistant::ProcessedActionStatusProto_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  autofill_error_status_ = value;
}
inline void AutofillErrorInfoProto::set_autofill_error_status(::autofill_assistant::ProcessedActionStatusProto value) {
  _internal_set_autofill_error_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.autofill_error_status)
}

// repeated .autofill_assistant.AutofillErrorInfoProto.AutofillFieldError autofill_field_error = 5;
inline int AutofillErrorInfoProto::_internal_autofill_field_error_size() const {
  return autofill_field_error_.size();
}
inline int AutofillErrorInfoProto::autofill_field_error_size() const {
  return _internal_autofill_field_error_size();
}
inline void AutofillErrorInfoProto::clear_autofill_field_error() {
  autofill_field_error_.Clear();
}
inline ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* AutofillErrorInfoProto::mutable_autofill_field_error(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillErrorInfoProto.autofill_field_error)
  return autofill_field_error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError >*
AutofillErrorInfoProto::mutable_autofill_field_error() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.AutofillErrorInfoProto.autofill_field_error)
  return &autofill_field_error_;
}
inline const ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError& AutofillErrorInfoProto::_internal_autofill_field_error(int index) const {
  return autofill_field_error_.Get(index);
}
inline const ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError& AutofillErrorInfoProto::autofill_field_error(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.autofill_field_error)
  return _internal_autofill_field_error(index);
}
inline ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* AutofillErrorInfoProto::_internal_add_autofill_field_error() {
  return autofill_field_error_.Add();
}
inline ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* AutofillErrorInfoProto::add_autofill_field_error() {
  ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError* _add = _internal_add_autofill_field_error();
  // @@protoc_insertion_point(field_add:autofill_assistant.AutofillErrorInfoProto.autofill_field_error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError >&
AutofillErrorInfoProto::autofill_field_error() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.AutofillErrorInfoProto.autofill_field_error)
  return autofill_field_error_;
}

// optional .autofill_assistant.AutofillErrorInfoProto.GetFullCardFailureType get_full_card_failure_type = 6;
inline bool AutofillErrorInfoProto::_internal_has_get_full_card_failure_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AutofillErrorInfoProto::has_get_full_card_failure_type() const {
  return _internal_has_get_full_card_failure_type();
}
inline void AutofillErrorInfoProto::clear_get_full_card_failure_type() {
  get_full_card_failure_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::_internal_get_full_card_failure_type() const {
  return static_cast< ::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType >(get_full_card_failure_type_);
}
inline ::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::get_full_card_failure_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillErrorInfoProto.get_full_card_failure_type)
  return _internal_get_full_card_failure_type();
}
inline void AutofillErrorInfoProto::_internal_set_get_full_card_failure_type(::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType value) {
  assert(::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  get_full_card_failure_type_ = value;
}
inline void AutofillErrorInfoProto::set_get_full_card_failure_type(::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType value) {
  _internal_set_get_full_card_failure_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillErrorInfoProto.get_full_card_failure_type)
}

// -------------------------------------------------------------------

// WebControllerErrorInfoProto

// optional .autofill_assistant.WebControllerErrorInfoProto.WebAction failed_web_action = 1;
inline bool WebControllerErrorInfoProto::_internal_has_failed_web_action() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WebControllerErrorInfoProto::has_failed_web_action() const {
  return _internal_has_failed_web_action();
}
inline void WebControllerErrorInfoProto::clear_failed_web_action() {
  failed_web_action_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::_internal_failed_web_action() const {
  return static_cast< ::autofill_assistant::WebControllerErrorInfoProto_WebAction >(failed_web_action_);
}
inline ::autofill_assistant::WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::failed_web_action() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WebControllerErrorInfoProto.failed_web_action)
  return _internal_failed_web_action();
}
inline void WebControllerErrorInfoProto::_internal_set_failed_web_action(::autofill_assistant::WebControllerErrorInfoProto_WebAction value) {
  assert(::autofill_assistant::WebControllerErrorInfoProto_WebAction_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  failed_web_action_ = value;
}
inline void WebControllerErrorInfoProto::set_failed_web_action(::autofill_assistant::WebControllerErrorInfoProto_WebAction value) {
  _internal_set_failed_web_action(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WebControllerErrorInfoProto.failed_web_action)
}

// -------------------------------------------------------------------

// ElementFinderInfoProto_PredictedElement

// optional .autofill_assistant.SelectorProto.SemanticFilter semantic_filter = 4;
inline bool ElementFinderInfoProto_PredictedElement::_internal_has_semantic_filter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || semantic_filter_ != nullptr);
  return value;
}
inline bool ElementFinderInfoProto_PredictedElement::has_semantic_filter() const {
  return _internal_has_semantic_filter();
}
inline void ElementFinderInfoProto_PredictedElement::clear_semantic_filter() {
  if (semantic_filter_ != nullptr) semantic_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto_SemanticFilter& ElementFinderInfoProto_PredictedElement::_internal_semantic_filter() const {
  const ::autofill_assistant::SelectorProto_SemanticFilter* p = semantic_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto_SemanticFilter&>(
      ::autofill_assistant::_SelectorProto_SemanticFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_SemanticFilter& ElementFinderInfoProto_PredictedElement::semantic_filter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.PredictedElement.semantic_filter)
  return _internal_semantic_filter();
}
inline void ElementFinderInfoProto_PredictedElement::unsafe_arena_set_allocated_semantic_filter(
    ::autofill_assistant::SelectorProto_SemanticFilter* semantic_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(semantic_filter_);
  }
  semantic_filter_ = semantic_filter;
  if (semantic_filter) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementFinderInfoProto.PredictedElement.semantic_filter)
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* ElementFinderInfoProto_PredictedElement::release_semantic_filter() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto_SemanticFilter* temp = semantic_filter_;
  semantic_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* ElementFinderInfoProto_PredictedElement::unsafe_arena_release_semantic_filter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementFinderInfoProto.PredictedElement.semantic_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto_SemanticFilter* temp = semantic_filter_;
  semantic_filter_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* ElementFinderInfoProto_PredictedElement::_internal_mutable_semantic_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (semantic_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto_SemanticFilter>(GetArenaForAllocation());
    semantic_filter_ = p;
  }
  return semantic_filter_;
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* ElementFinderInfoProto_PredictedElement::mutable_semantic_filter() {
  ::autofill_assistant::SelectorProto_SemanticFilter* _msg = _internal_mutable_semantic_filter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementFinderInfoProto.PredictedElement.semantic_filter)
  return _msg;
}
inline void ElementFinderInfoProto_PredictedElement::set_allocated_semantic_filter(::autofill_assistant::SelectorProto_SemanticFilter* semantic_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete semantic_filter_;
  }
  if (semantic_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(semantic_filter);
    if (message_arena != submessage_arena) {
      semantic_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, semantic_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  semantic_filter_ = semantic_filter;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementFinderInfoProto.PredictedElement.semantic_filter)
}

// optional int32 backend_node_id = 3;
inline bool ElementFinderInfoProto_PredictedElement::_internal_has_backend_node_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ElementFinderInfoProto_PredictedElement::has_backend_node_id() const {
  return _internal_has_backend_node_id();
}
inline void ElementFinderInfoProto_PredictedElement::clear_backend_node_id() {
  backend_node_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ElementFinderInfoProto_PredictedElement::_internal_backend_node_id() const {
  return backend_node_id_;
}
inline int32_t ElementFinderInfoProto_PredictedElement::backend_node_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.PredictedElement.backend_node_id)
  return _internal_backend_node_id();
}
inline void ElementFinderInfoProto_PredictedElement::_internal_set_backend_node_id(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  backend_node_id_ = value;
}
inline void ElementFinderInfoProto_PredictedElement::set_backend_node_id(int32_t value) {
  _internal_set_backend_node_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.PredictedElement.backend_node_id)
}

// -------------------------------------------------------------------

// ElementFinderInfoProto_SemanticInferenceResult

// repeated .autofill_assistant.ElementFinderInfoProto.PredictedElement predicted_elements = 1;
inline int ElementFinderInfoProto_SemanticInferenceResult::_internal_predicted_elements_size() const {
  return predicted_elements_.size();
}
inline int ElementFinderInfoProto_SemanticInferenceResult::predicted_elements_size() const {
  return _internal_predicted_elements_size();
}
inline void ElementFinderInfoProto_SemanticInferenceResult::clear_predicted_elements() {
  predicted_elements_.Clear();
}
inline ::autofill_assistant::ElementFinderInfoProto_PredictedElement* ElementFinderInfoProto_SemanticInferenceResult::mutable_predicted_elements(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.predicted_elements)
  return predicted_elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto_PredictedElement >*
ElementFinderInfoProto_SemanticInferenceResult::mutable_predicted_elements() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.predicted_elements)
  return &predicted_elements_;
}
inline const ::autofill_assistant::ElementFinderInfoProto_PredictedElement& ElementFinderInfoProto_SemanticInferenceResult::_internal_predicted_elements(int index) const {
  return predicted_elements_.Get(index);
}
inline const ::autofill_assistant::ElementFinderInfoProto_PredictedElement& ElementFinderInfoProto_SemanticInferenceResult::predicted_elements(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.predicted_elements)
  return _internal_predicted_elements(index);
}
inline ::autofill_assistant::ElementFinderInfoProto_PredictedElement* ElementFinderInfoProto_SemanticInferenceResult::_internal_add_predicted_elements() {
  return predicted_elements_.Add();
}
inline ::autofill_assistant::ElementFinderInfoProto_PredictedElement* ElementFinderInfoProto_SemanticInferenceResult::add_predicted_elements() {
  ::autofill_assistant::ElementFinderInfoProto_PredictedElement* _add = _internal_add_predicted_elements();
  // @@protoc_insertion_point(field_add:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.predicted_elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementFinderInfoProto_PredictedElement >&
ElementFinderInfoProto_SemanticInferenceResult::predicted_elements() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.predicted_elements)
  return predicted_elements_;
}

// repeated .autofill_assistant.ElementFinderInfoProto.SemanticInferenceStatus status_per_frame = 2;
inline int ElementFinderInfoProto_SemanticInferenceResult::_internal_status_per_frame_size() const {
  return status_per_frame_.size();
}
inline int ElementFinderInfoProto_SemanticInferenceResult::status_per_frame_size() const {
  return _internal_status_per_frame_size();
}
inline void ElementFinderInfoProto_SemanticInferenceResult::clear_status_per_frame() {
  status_per_frame_.Clear();
}
inline ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto_SemanticInferenceResult::_internal_status_per_frame(int index) const {
  return static_cast< ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus >(status_per_frame_.Get(index));
}
inline ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto_SemanticInferenceResult::status_per_frame(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.status_per_frame)
  return _internal_status_per_frame(index);
}
inline void ElementFinderInfoProto_SemanticInferenceResult::set_status_per_frame(int index, ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus value) {
  assert(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus_IsValid(value));
  status_per_frame_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.status_per_frame)
}
inline void ElementFinderInfoProto_SemanticInferenceResult::_internal_add_status_per_frame(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus value) {
  assert(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus_IsValid(value));
  status_per_frame_.Add(value);
}
inline void ElementFinderInfoProto_SemanticInferenceResult::add_status_per_frame(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus value) {
  _internal_add_status_per_frame(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.status_per_frame)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ElementFinderInfoProto_SemanticInferenceResult::status_per_frame() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.status_per_frame)
  return status_per_frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ElementFinderInfoProto_SemanticInferenceResult::_internal_mutable_status_per_frame() {
  return &status_per_frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ElementFinderInfoProto_SemanticInferenceResult::mutable_status_per_frame() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult.status_per_frame)
  return _internal_mutable_status_per_frame();
}

// -------------------------------------------------------------------

// ElementFinderInfoProto

// optional int64 tracking_id = 1;
inline bool ElementFinderInfoProto::_internal_has_tracking_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ElementFinderInfoProto::has_tracking_id() const {
  return _internal_has_tracking_id();
}
inline void ElementFinderInfoProto::clear_tracking_id() {
  tracking_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ElementFinderInfoProto::_internal_tracking_id() const {
  return tracking_id_;
}
inline int64_t ElementFinderInfoProto::tracking_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.tracking_id)
  return _internal_tracking_id();
}
inline void ElementFinderInfoProto::_internal_set_tracking_id(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  tracking_id_ = value;
}
inline void ElementFinderInfoProto::set_tracking_id(int64_t value) {
  _internal_set_tracking_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.tracking_id)
}

// optional int32 failed_filter_index_range_start = 2;
inline bool ElementFinderInfoProto::_internal_has_failed_filter_index_range_start() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ElementFinderInfoProto::has_failed_filter_index_range_start() const {
  return _internal_has_failed_filter_index_range_start();
}
inline void ElementFinderInfoProto::clear_failed_filter_index_range_start() {
  failed_filter_index_range_start_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ElementFinderInfoProto::_internal_failed_filter_index_range_start() const {
  return failed_filter_index_range_start_;
}
inline int32_t ElementFinderInfoProto::failed_filter_index_range_start() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.failed_filter_index_range_start)
  return _internal_failed_filter_index_range_start();
}
inline void ElementFinderInfoProto::_internal_set_failed_filter_index_range_start(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  failed_filter_index_range_start_ = value;
}
inline void ElementFinderInfoProto::set_failed_filter_index_range_start(int32_t value) {
  _internal_set_failed_filter_index_range_start(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.failed_filter_index_range_start)
}

// optional int32 failed_filter_index_range_end = 3;
inline bool ElementFinderInfoProto::_internal_has_failed_filter_index_range_end() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ElementFinderInfoProto::has_failed_filter_index_range_end() const {
  return _internal_has_failed_filter_index_range_end();
}
inline void ElementFinderInfoProto::clear_failed_filter_index_range_end() {
  failed_filter_index_range_end_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ElementFinderInfoProto::_internal_failed_filter_index_range_end() const {
  return failed_filter_index_range_end_;
}
inline int32_t ElementFinderInfoProto::failed_filter_index_range_end() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.failed_filter_index_range_end)
  return _internal_failed_filter_index_range_end();
}
inline void ElementFinderInfoProto::_internal_set_failed_filter_index_range_end(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  failed_filter_index_range_end_ = value;
}
inline void ElementFinderInfoProto::set_failed_filter_index_range_end(int32_t value) {
  _internal_set_failed_filter_index_range_end(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.failed_filter_index_range_end)
}

// optional .autofill_assistant.ProcessedActionStatusProto status = 4;
inline bool ElementFinderInfoProto::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ElementFinderInfoProto::has_status() const {
  return _internal_has_status();
}
inline void ElementFinderInfoProto::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::autofill_assistant::ProcessedActionStatusProto ElementFinderInfoProto::_internal_status() const {
  return static_cast< ::autofill_assistant::ProcessedActionStatusProto >(status_);
}
inline ::autofill_assistant::ProcessedActionStatusProto ElementFinderInfoProto::status() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.status)
  return _internal_status();
}
inline void ElementFinderInfoProto::_internal_set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  assert(::autofill_assistant::ProcessedActionStatusProto_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void ElementFinderInfoProto::set_status(::autofill_assistant::ProcessedActionStatusProto value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.status)
}

// optional bool get_document_failed = 5;
inline bool ElementFinderInfoProto::_internal_has_get_document_failed() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ElementFinderInfoProto::has_get_document_failed() const {
  return _internal_has_get_document_failed();
}
inline void ElementFinderInfoProto::clear_get_document_failed() {
  get_document_failed_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ElementFinderInfoProto::_internal_get_document_failed() const {
  return get_document_failed_;
}
inline bool ElementFinderInfoProto::get_document_failed() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.get_document_failed)
  return _internal_get_document_failed();
}
inline void ElementFinderInfoProto::_internal_set_get_document_failed(bool value) {
  _has_bits_[0] |= 0x00000020u;
  get_document_failed_ = value;
}
inline void ElementFinderInfoProto::set_get_document_failed(bool value) {
  _internal_set_get_document_failed(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementFinderInfoProto.get_document_failed)
}

// optional .autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult semantic_inference_result = 6;
inline bool ElementFinderInfoProto::_internal_has_semantic_inference_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || semantic_inference_result_ != nullptr);
  return value;
}
inline bool ElementFinderInfoProto::has_semantic_inference_result() const {
  return _internal_has_semantic_inference_result();
}
inline void ElementFinderInfoProto::clear_semantic_inference_result() {
  if (semantic_inference_result_ != nullptr) semantic_inference_result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult& ElementFinderInfoProto::_internal_semantic_inference_result() const {
  const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* p = semantic_inference_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult&>(
      ::autofill_assistant::_ElementFinderInfoProto_SemanticInferenceResult_default_instance_);
}
inline const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult& ElementFinderInfoProto::semantic_inference_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementFinderInfoProto.semantic_inference_result)
  return _internal_semantic_inference_result();
}
inline void ElementFinderInfoProto::unsafe_arena_set_allocated_semantic_inference_result(
    ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* semantic_inference_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(semantic_inference_result_);
  }
  semantic_inference_result_ = semantic_inference_result;
  if (semantic_inference_result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementFinderInfoProto.semantic_inference_result)
}
inline ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* ElementFinderInfoProto::release_semantic_inference_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* temp = semantic_inference_result_;
  semantic_inference_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* ElementFinderInfoProto::unsafe_arena_release_semantic_inference_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementFinderInfoProto.semantic_inference_result)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* temp = semantic_inference_result_;
  semantic_inference_result_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* ElementFinderInfoProto::_internal_mutable_semantic_inference_result() {
  _has_bits_[0] |= 0x00000001u;
  if (semantic_inference_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult>(GetArenaForAllocation());
    semantic_inference_result_ = p;
  }
  return semantic_inference_result_;
}
inline ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* ElementFinderInfoProto::mutable_semantic_inference_result() {
  ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* _msg = _internal_mutable_semantic_inference_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementFinderInfoProto.semantic_inference_result)
  return _msg;
}
inline void ElementFinderInfoProto::set_allocated_semantic_inference_result(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult* semantic_inference_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete semantic_inference_result_;
  }
  if (semantic_inference_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(semantic_inference_result);
    if (message_arena != submessage_arena) {
      semantic_inference_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, semantic_inference_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  semantic_inference_result_ = semantic_inference_result;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementFinderInfoProto.semantic_inference_result)
}

// -------------------------------------------------------------------

// SelectorProto_Filter

// .autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;
inline bool SelectorProto_Filter::_internal_has_enter_frame() const {
  return filter_case() == kEnterFrame;
}
inline bool SelectorProto_Filter::has_enter_frame() const {
  return _internal_has_enter_frame();
}
inline void SelectorProto_Filter::set_has_enter_frame() {
  _oneof_case_[0] = kEnterFrame;
}
inline void SelectorProto_Filter::clear_enter_frame() {
  if (_internal_has_enter_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.enter_frame_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::release_enter_frame() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.enter_frame)
  if (_internal_has_enter_frame()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_EmptyFilter* temp = filter_.enter_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.enter_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_EmptyFilter& SelectorProto_Filter::_internal_enter_frame() const {
  return _internal_has_enter_frame()
      ? *filter_.enter_frame_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_EmptyFilter&>(::autofill_assistant::_SelectorProto_EmptyFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_EmptyFilter& SelectorProto_Filter::enter_frame() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.enter_frame)
  return _internal_enter_frame();
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::unsafe_arena_release_enter_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.enter_frame)
  if (_internal_has_enter_frame()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_EmptyFilter* temp = filter_.enter_frame_;
    filter_.enter_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_enter_frame(::autofill_assistant::SelectorProto_EmptyFilter* enter_frame) {
  clear_filter();
  if (enter_frame) {
    set_has_enter_frame();
    filter_.enter_frame_ = enter_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.enter_frame)
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::_internal_mutable_enter_frame() {
  if (!_internal_has_enter_frame()) {
    clear_filter();
    set_has_enter_frame();
    filter_.enter_frame_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_EmptyFilter >(GetArenaForAllocation());
  }
  return filter_.enter_frame_;
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::mutable_enter_frame() {
  ::autofill_assistant::SelectorProto_EmptyFilter* _msg = _internal_mutable_enter_frame();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.enter_frame)
  return _msg;
}

// string css_selector = 2;
inline bool SelectorProto_Filter::_internal_has_css_selector() const {
  return filter_case() == kCssSelector;
}
inline bool SelectorProto_Filter::has_css_selector() const {
  return _internal_has_css_selector();
}
inline void SelectorProto_Filter::set_has_css_selector() {
  _oneof_case_[0] = kCssSelector;
}
inline void SelectorProto_Filter::clear_css_selector() {
  if (_internal_has_css_selector()) {
    filter_.css_selector_.Destroy();
    clear_has_filter();
  }
}
inline const std::string& SelectorProto_Filter::css_selector() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.css_selector)
  return _internal_css_selector();
}
template <typename ArgT0, typename... ArgT>
inline void SelectorProto_Filter::set_css_selector(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_css_selector()) {
    clear_filter();
    set_has_css_selector();
    filter_.css_selector_.InitDefault();
  }
  filter_.css_selector_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.Filter.css_selector)
}
inline std::string* SelectorProto_Filter::mutable_css_selector() {
  std::string* _s = _internal_mutable_css_selector();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.css_selector)
  return _s;
}
inline const std::string& SelectorProto_Filter::_internal_css_selector() const {
  if (_internal_has_css_selector()) {
    return filter_.css_selector_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SelectorProto_Filter::_internal_set_css_selector(const std::string& value) {
  if (!_internal_has_css_selector()) {
    clear_filter();
    set_has_css_selector();
    filter_.css_selector_.InitDefault();
  }
  filter_.css_selector_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectorProto_Filter::_internal_mutable_css_selector() {
  if (!_internal_has_css_selector()) {
    clear_filter();
    set_has_css_selector();
    filter_.css_selector_.InitDefault();
  }
  return filter_.css_selector_.Mutable(      GetArenaForAllocation());
}
inline std::string* SelectorProto_Filter::release_css_selector() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.css_selector)
  if (_internal_has_css_selector()) {
    clear_has_filter();
    return filter_.css_selector_.Release();
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::set_allocated_css_selector(std::string* css_selector) {
  if (has_filter()) {
    clear_filter();
  }
  if (css_selector != nullptr) {
    set_has_css_selector();
    filter_.css_selector_.InitAllocated(css_selector, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.css_selector)
}

// .autofill_assistant.TextFilter inner_text = 3;
inline bool SelectorProto_Filter::_internal_has_inner_text() const {
  return filter_case() == kInnerText;
}
inline bool SelectorProto_Filter::has_inner_text() const {
  return _internal_has_inner_text();
}
inline void SelectorProto_Filter::set_has_inner_text() {
  _oneof_case_[0] = kInnerText;
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::release_inner_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.inner_text)
  if (_internal_has_inner_text()) {
    clear_has_filter();
    ::autofill_assistant::TextFilter* temp = filter_.inner_text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.inner_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextFilter& SelectorProto_Filter::_internal_inner_text() const {
  return _internal_has_inner_text()
      ? *filter_.inner_text_
      : reinterpret_cast< ::autofill_assistant::TextFilter&>(::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& SelectorProto_Filter::inner_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.inner_text)
  return _internal_inner_text();
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::unsafe_arena_release_inner_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.inner_text)
  if (_internal_has_inner_text()) {
    clear_has_filter();
    ::autofill_assistant::TextFilter* temp = filter_.inner_text_;
    filter_.inner_text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_inner_text(::autofill_assistant::TextFilter* inner_text) {
  clear_filter();
  if (inner_text) {
    set_has_inner_text();
    filter_.inner_text_ = inner_text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.inner_text)
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::_internal_mutable_inner_text() {
  if (!_internal_has_inner_text()) {
    clear_filter();
    set_has_inner_text();
    filter_.inner_text_ = CreateMaybeMessage< ::autofill_assistant::TextFilter >(GetArenaForAllocation());
  }
  return filter_.inner_text_;
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::mutable_inner_text() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_inner_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.inner_text)
  return _msg;
}

// .autofill_assistant.TextFilter value = 4;
inline bool SelectorProto_Filter::_internal_has_value() const {
  return filter_case() == kValue;
}
inline bool SelectorProto_Filter::has_value() const {
  return _internal_has_value();
}
inline void SelectorProto_Filter::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.value)
  if (_internal_has_value()) {
    clear_has_filter();
    ::autofill_assistant::TextFilter* temp = filter_.value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextFilter& SelectorProto_Filter::_internal_value() const {
  return _internal_has_value()
      ? *filter_.value_
      : reinterpret_cast< ::autofill_assistant::TextFilter&>(::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& SelectorProto_Filter::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.value)
  return _internal_value();
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.value)
  if (_internal_has_value()) {
    clear_has_filter();
    ::autofill_assistant::TextFilter* temp = filter_.value_;
    filter_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_value(::autofill_assistant::TextFilter* value) {
  clear_filter();
  if (value) {
    set_has_value();
    filter_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.value)
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_filter();
    set_has_value();
    filter_.value_ = CreateMaybeMessage< ::autofill_assistant::TextFilter >(GetArenaForAllocation());
  }
  return filter_.value_;
}
inline ::autofill_assistant::TextFilter* SelectorProto_Filter::mutable_value() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.value)
  return _msg;
}

// .autofill_assistant.PseudoType pseudo_type = 5;
inline bool SelectorProto_Filter::_internal_has_pseudo_type() const {
  return filter_case() == kPseudoType;
}
inline bool SelectorProto_Filter::has_pseudo_type() const {
  return _internal_has_pseudo_type();
}
inline void SelectorProto_Filter::set_has_pseudo_type() {
  _oneof_case_[0] = kPseudoType;
}
inline void SelectorProto_Filter::clear_pseudo_type() {
  if (_internal_has_pseudo_type()) {
    filter_.pseudo_type_ = 0;
    clear_has_filter();
  }
}
inline ::autofill_assistant::PseudoType SelectorProto_Filter::_internal_pseudo_type() const {
  if (_internal_has_pseudo_type()) {
    return static_cast< ::autofill_assistant::PseudoType >(filter_.pseudo_type_);
  }
  return static_cast< ::autofill_assistant::PseudoType >(0);
}
inline ::autofill_assistant::PseudoType SelectorProto_Filter::pseudo_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.pseudo_type)
  return _internal_pseudo_type();
}
inline void SelectorProto_Filter::_internal_set_pseudo_type(::autofill_assistant::PseudoType value) {
  assert(::autofill_assistant::PseudoType_IsValid(value));
  if (!_internal_has_pseudo_type()) {
    clear_filter();
    set_has_pseudo_type();
  }
  filter_.pseudo_type_ = value;
}
inline void SelectorProto_Filter::set_pseudo_type(::autofill_assistant::PseudoType value) {
  _internal_set_pseudo_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.Filter.pseudo_type)
}

// .autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;
inline bool SelectorProto_Filter::_internal_has_bounding_box() const {
  return filter_case() == kBoundingBox;
}
inline bool SelectorProto_Filter::has_bounding_box() const {
  return _internal_has_bounding_box();
}
inline void SelectorProto_Filter::set_has_bounding_box() {
  _oneof_case_[0] = kBoundingBox;
}
inline void SelectorProto_Filter::clear_bounding_box() {
  if (_internal_has_bounding_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.bounding_box_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_BoundingBoxFilter* SelectorProto_Filter::release_bounding_box() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.bounding_box)
  if (_internal_has_bounding_box()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_BoundingBoxFilter* temp = filter_.bounding_box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.bounding_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_BoundingBoxFilter& SelectorProto_Filter::_internal_bounding_box() const {
  return _internal_has_bounding_box()
      ? *filter_.bounding_box_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_BoundingBoxFilter&>(::autofill_assistant::_SelectorProto_BoundingBoxFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_BoundingBoxFilter& SelectorProto_Filter::bounding_box() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.bounding_box)
  return _internal_bounding_box();
}
inline ::autofill_assistant::SelectorProto_BoundingBoxFilter* SelectorProto_Filter::unsafe_arena_release_bounding_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.bounding_box)
  if (_internal_has_bounding_box()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_BoundingBoxFilter* temp = filter_.bounding_box_;
    filter_.bounding_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_bounding_box(::autofill_assistant::SelectorProto_BoundingBoxFilter* bounding_box) {
  clear_filter();
  if (bounding_box) {
    set_has_bounding_box();
    filter_.bounding_box_ = bounding_box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.bounding_box)
}
inline ::autofill_assistant::SelectorProto_BoundingBoxFilter* SelectorProto_Filter::_internal_mutable_bounding_box() {
  if (!_internal_has_bounding_box()) {
    clear_filter();
    set_has_bounding_box();
    filter_.bounding_box_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_BoundingBoxFilter >(GetArenaForAllocation());
  }
  return filter_.bounding_box_;
}
inline ::autofill_assistant::SelectorProto_BoundingBoxFilter* SelectorProto_Filter::mutable_bounding_box() {
  ::autofill_assistant::SelectorProto_BoundingBoxFilter* _msg = _internal_mutable_bounding_box();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.bounding_box)
  return _msg;
}

// .autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;
inline bool SelectorProto_Filter::_internal_has_nth_match() const {
  return filter_case() == kNthMatch;
}
inline bool SelectorProto_Filter::has_nth_match() const {
  return _internal_has_nth_match();
}
inline void SelectorProto_Filter::set_has_nth_match() {
  _oneof_case_[0] = kNthMatch;
}
inline void SelectorProto_Filter::clear_nth_match() {
  if (_internal_has_nth_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.nth_match_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_NthMatchFilter* SelectorProto_Filter::release_nth_match() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.nth_match)
  if (_internal_has_nth_match()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_NthMatchFilter* temp = filter_.nth_match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.nth_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_NthMatchFilter& SelectorProto_Filter::_internal_nth_match() const {
  return _internal_has_nth_match()
      ? *filter_.nth_match_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_NthMatchFilter&>(::autofill_assistant::_SelectorProto_NthMatchFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_NthMatchFilter& SelectorProto_Filter::nth_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.nth_match)
  return _internal_nth_match();
}
inline ::autofill_assistant::SelectorProto_NthMatchFilter* SelectorProto_Filter::unsafe_arena_release_nth_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.nth_match)
  if (_internal_has_nth_match()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_NthMatchFilter* temp = filter_.nth_match_;
    filter_.nth_match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_nth_match(::autofill_assistant::SelectorProto_NthMatchFilter* nth_match) {
  clear_filter();
  if (nth_match) {
    set_has_nth_match();
    filter_.nth_match_ = nth_match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.nth_match)
}
inline ::autofill_assistant::SelectorProto_NthMatchFilter* SelectorProto_Filter::_internal_mutable_nth_match() {
  if (!_internal_has_nth_match()) {
    clear_filter();
    set_has_nth_match();
    filter_.nth_match_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_NthMatchFilter >(GetArenaForAllocation());
  }
  return filter_.nth_match_;
}
inline ::autofill_assistant::SelectorProto_NthMatchFilter* SelectorProto_Filter::mutable_nth_match() {
  ::autofill_assistant::SelectorProto_NthMatchFilter* _msg = _internal_mutable_nth_match();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.nth_match)
  return _msg;
}

// .autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;
inline bool SelectorProto_Filter::_internal_has_pseudo_element_content() const {
  return filter_case() == kPseudoElementContent;
}
inline bool SelectorProto_Filter::has_pseudo_element_content() const {
  return _internal_has_pseudo_element_content();
}
inline void SelectorProto_Filter::set_has_pseudo_element_content() {
  _oneof_case_[0] = kPseudoElementContent;
}
inline void SelectorProto_Filter::clear_pseudo_element_content() {
  if (_internal_has_pseudo_element_content()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.pseudo_element_content_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_PseudoElementContent* SelectorProto_Filter::release_pseudo_element_content() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.pseudo_element_content)
  if (_internal_has_pseudo_element_content()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_PseudoElementContent* temp = filter_.pseudo_element_content_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.pseudo_element_content_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_PseudoElementContent& SelectorProto_Filter::_internal_pseudo_element_content() const {
  return _internal_has_pseudo_element_content()
      ? *filter_.pseudo_element_content_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_PseudoElementContent&>(::autofill_assistant::_SelectorProto_PseudoElementContent_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_PseudoElementContent& SelectorProto_Filter::pseudo_element_content() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.pseudo_element_content)
  return _internal_pseudo_element_content();
}
inline ::autofill_assistant::SelectorProto_PseudoElementContent* SelectorProto_Filter::unsafe_arena_release_pseudo_element_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.pseudo_element_content)
  if (_internal_has_pseudo_element_content()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_PseudoElementContent* temp = filter_.pseudo_element_content_;
    filter_.pseudo_element_content_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_pseudo_element_content(::autofill_assistant::SelectorProto_PseudoElementContent* pseudo_element_content) {
  clear_filter();
  if (pseudo_element_content) {
    set_has_pseudo_element_content();
    filter_.pseudo_element_content_ = pseudo_element_content;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.pseudo_element_content)
}
inline ::autofill_assistant::SelectorProto_PseudoElementContent* SelectorProto_Filter::_internal_mutable_pseudo_element_content() {
  if (!_internal_has_pseudo_element_content()) {
    clear_filter();
    set_has_pseudo_element_content();
    filter_.pseudo_element_content_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_PseudoElementContent >(GetArenaForAllocation());
  }
  return filter_.pseudo_element_content_;
}
inline ::autofill_assistant::SelectorProto_PseudoElementContent* SelectorProto_Filter::mutable_pseudo_element_content() {
  ::autofill_assistant::SelectorProto_PseudoElementContent* _msg = _internal_mutable_pseudo_element_content();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.pseudo_element_content)
  return _msg;
}

// .autofill_assistant.SelectorProto.EmptyFilter labelled = 9;
inline bool SelectorProto_Filter::_internal_has_labelled() const {
  return filter_case() == kLabelled;
}
inline bool SelectorProto_Filter::has_labelled() const {
  return _internal_has_labelled();
}
inline void SelectorProto_Filter::set_has_labelled() {
  _oneof_case_[0] = kLabelled;
}
inline void SelectorProto_Filter::clear_labelled() {
  if (_internal_has_labelled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.labelled_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::release_labelled() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.labelled)
  if (_internal_has_labelled()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_EmptyFilter* temp = filter_.labelled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.labelled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_EmptyFilter& SelectorProto_Filter::_internal_labelled() const {
  return _internal_has_labelled()
      ? *filter_.labelled_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_EmptyFilter&>(::autofill_assistant::_SelectorProto_EmptyFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_EmptyFilter& SelectorProto_Filter::labelled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.labelled)
  return _internal_labelled();
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::unsafe_arena_release_labelled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.labelled)
  if (_internal_has_labelled()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_EmptyFilter* temp = filter_.labelled_;
    filter_.labelled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_labelled(::autofill_assistant::SelectorProto_EmptyFilter* labelled) {
  clear_filter();
  if (labelled) {
    set_has_labelled();
    filter_.labelled_ = labelled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.labelled)
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::_internal_mutable_labelled() {
  if (!_internal_has_labelled()) {
    clear_filter();
    set_has_labelled();
    filter_.labelled_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_EmptyFilter >(GetArenaForAllocation());
  }
  return filter_.labelled_;
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::mutable_labelled() {
  ::autofill_assistant::SelectorProto_EmptyFilter* _msg = _internal_mutable_labelled();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.labelled)
  return _msg;
}

// string match_css_selector = 11;
inline bool SelectorProto_Filter::_internal_has_match_css_selector() const {
  return filter_case() == kMatchCssSelector;
}
inline bool SelectorProto_Filter::has_match_css_selector() const {
  return _internal_has_match_css_selector();
}
inline void SelectorProto_Filter::set_has_match_css_selector() {
  _oneof_case_[0] = kMatchCssSelector;
}
inline void SelectorProto_Filter::clear_match_css_selector() {
  if (_internal_has_match_css_selector()) {
    filter_.match_css_selector_.Destroy();
    clear_has_filter();
  }
}
inline const std::string& SelectorProto_Filter::match_css_selector() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.match_css_selector)
  return _internal_match_css_selector();
}
template <typename ArgT0, typename... ArgT>
inline void SelectorProto_Filter::set_match_css_selector(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_match_css_selector()) {
    clear_filter();
    set_has_match_css_selector();
    filter_.match_css_selector_.InitDefault();
  }
  filter_.match_css_selector_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.Filter.match_css_selector)
}
inline std::string* SelectorProto_Filter::mutable_match_css_selector() {
  std::string* _s = _internal_mutable_match_css_selector();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.match_css_selector)
  return _s;
}
inline const std::string& SelectorProto_Filter::_internal_match_css_selector() const {
  if (_internal_has_match_css_selector()) {
    return filter_.match_css_selector_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SelectorProto_Filter::_internal_set_match_css_selector(const std::string& value) {
  if (!_internal_has_match_css_selector()) {
    clear_filter();
    set_has_match_css_selector();
    filter_.match_css_selector_.InitDefault();
  }
  filter_.match_css_selector_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectorProto_Filter::_internal_mutable_match_css_selector() {
  if (!_internal_has_match_css_selector()) {
    clear_filter();
    set_has_match_css_selector();
    filter_.match_css_selector_.InitDefault();
  }
  return filter_.match_css_selector_.Mutable(      GetArenaForAllocation());
}
inline std::string* SelectorProto_Filter::release_match_css_selector() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.match_css_selector)
  if (_internal_has_match_css_selector()) {
    clear_has_filter();
    return filter_.match_css_selector_.Release();
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::set_allocated_match_css_selector(std::string* match_css_selector) {
  if (has_filter()) {
    clear_filter();
  }
  if (match_css_selector != nullptr) {
    set_has_match_css_selector();
    filter_.match_css_selector_.InitAllocated(match_css_selector, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.match_css_selector)
}

// .autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;
inline bool SelectorProto_Filter::_internal_has_css_style() const {
  return filter_case() == kCssStyle;
}
inline bool SelectorProto_Filter::has_css_style() const {
  return _internal_has_css_style();
}
inline void SelectorProto_Filter::set_has_css_style() {
  _oneof_case_[0] = kCssStyle;
}
inline void SelectorProto_Filter::clear_css_style() {
  if (_internal_has_css_style()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.css_style_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_CssStyleFilter* SelectorProto_Filter::release_css_style() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.css_style)
  if (_internal_has_css_style()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_CssStyleFilter* temp = filter_.css_style_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.css_style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_CssStyleFilter& SelectorProto_Filter::_internal_css_style() const {
  return _internal_has_css_style()
      ? *filter_.css_style_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_CssStyleFilter&>(::autofill_assistant::_SelectorProto_CssStyleFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_CssStyleFilter& SelectorProto_Filter::css_style() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.css_style)
  return _internal_css_style();
}
inline ::autofill_assistant::SelectorProto_CssStyleFilter* SelectorProto_Filter::unsafe_arena_release_css_style() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.css_style)
  if (_internal_has_css_style()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_CssStyleFilter* temp = filter_.css_style_;
    filter_.css_style_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_css_style(::autofill_assistant::SelectorProto_CssStyleFilter* css_style) {
  clear_filter();
  if (css_style) {
    set_has_css_style();
    filter_.css_style_ = css_style;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.css_style)
}
inline ::autofill_assistant::SelectorProto_CssStyleFilter* SelectorProto_Filter::_internal_mutable_css_style() {
  if (!_internal_has_css_style()) {
    clear_filter();
    set_has_css_style();
    filter_.css_style_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_CssStyleFilter >(GetArenaForAllocation());
  }
  return filter_.css_style_;
}
inline ::autofill_assistant::SelectorProto_CssStyleFilter* SelectorProto_Filter::mutable_css_style() {
  ::autofill_assistant::SelectorProto_CssStyleFilter* _msg = _internal_mutable_css_style();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.css_style)
  return _msg;
}

// .autofill_assistant.SelectorProto.OnTopFilter on_top = 13;
inline bool SelectorProto_Filter::_internal_has_on_top() const {
  return filter_case() == kOnTop;
}
inline bool SelectorProto_Filter::has_on_top() const {
  return _internal_has_on_top();
}
inline void SelectorProto_Filter::set_has_on_top() {
  _oneof_case_[0] = kOnTop;
}
inline void SelectorProto_Filter::clear_on_top() {
  if (_internal_has_on_top()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.on_top_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_OnTopFilter* SelectorProto_Filter::release_on_top() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.on_top)
  if (_internal_has_on_top()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_OnTopFilter* temp = filter_.on_top_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.on_top_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_OnTopFilter& SelectorProto_Filter::_internal_on_top() const {
  return _internal_has_on_top()
      ? *filter_.on_top_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_OnTopFilter&>(::autofill_assistant::_SelectorProto_OnTopFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_OnTopFilter& SelectorProto_Filter::on_top() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.on_top)
  return _internal_on_top();
}
inline ::autofill_assistant::SelectorProto_OnTopFilter* SelectorProto_Filter::unsafe_arena_release_on_top() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.on_top)
  if (_internal_has_on_top()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_OnTopFilter* temp = filter_.on_top_;
    filter_.on_top_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_on_top(::autofill_assistant::SelectorProto_OnTopFilter* on_top) {
  clear_filter();
  if (on_top) {
    set_has_on_top();
    filter_.on_top_ = on_top;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.on_top)
}
inline ::autofill_assistant::SelectorProto_OnTopFilter* SelectorProto_Filter::_internal_mutable_on_top() {
  if (!_internal_has_on_top()) {
    clear_filter();
    set_has_on_top();
    filter_.on_top_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_OnTopFilter >(GetArenaForAllocation());
  }
  return filter_.on_top_;
}
inline ::autofill_assistant::SelectorProto_OnTopFilter* SelectorProto_Filter::mutable_on_top() {
  ::autofill_assistant::SelectorProto_OnTopFilter* _msg = _internal_mutable_on_top();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.on_top)
  return _msg;
}

// .autofill_assistant.SelectorProto.PropertyFilter property = 14;
inline bool SelectorProto_Filter::_internal_has_property() const {
  return filter_case() == kProperty;
}
inline bool SelectorProto_Filter::has_property() const {
  return _internal_has_property();
}
inline void SelectorProto_Filter::set_has_property() {
  _oneof_case_[0] = kProperty;
}
inline void SelectorProto_Filter::clear_property() {
  if (_internal_has_property()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.property_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_PropertyFilter* SelectorProto_Filter::release_property() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.property)
  if (_internal_has_property()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_PropertyFilter* temp = filter_.property_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.property_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_PropertyFilter& SelectorProto_Filter::_internal_property() const {
  return _internal_has_property()
      ? *filter_.property_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_PropertyFilter&>(::autofill_assistant::_SelectorProto_PropertyFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_PropertyFilter& SelectorProto_Filter::property() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.property)
  return _internal_property();
}
inline ::autofill_assistant::SelectorProto_PropertyFilter* SelectorProto_Filter::unsafe_arena_release_property() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.property)
  if (_internal_has_property()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_PropertyFilter* temp = filter_.property_;
    filter_.property_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_property(::autofill_assistant::SelectorProto_PropertyFilter* property) {
  clear_filter();
  if (property) {
    set_has_property();
    filter_.property_ = property;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.property)
}
inline ::autofill_assistant::SelectorProto_PropertyFilter* SelectorProto_Filter::_internal_mutable_property() {
  if (!_internal_has_property()) {
    clear_filter();
    set_has_property();
    filter_.property_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_PropertyFilter >(GetArenaForAllocation());
  }
  return filter_.property_;
}
inline ::autofill_assistant::SelectorProto_PropertyFilter* SelectorProto_Filter::mutable_property() {
  ::autofill_assistant::SelectorProto_PropertyFilter* _msg = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.property)
  return _msg;
}

// .autofill_assistant.SelectorProto.EmptyFilter parent = 15;
inline bool SelectorProto_Filter::_internal_has_parent() const {
  return filter_case() == kParent;
}
inline bool SelectorProto_Filter::has_parent() const {
  return _internal_has_parent();
}
inline void SelectorProto_Filter::set_has_parent() {
  _oneof_case_[0] = kParent;
}
inline void SelectorProto_Filter::clear_parent() {
  if (_internal_has_parent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.parent_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::release_parent() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.parent)
  if (_internal_has_parent()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_EmptyFilter* temp = filter_.parent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.parent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_EmptyFilter& SelectorProto_Filter::_internal_parent() const {
  return _internal_has_parent()
      ? *filter_.parent_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_EmptyFilter&>(::autofill_assistant::_SelectorProto_EmptyFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_EmptyFilter& SelectorProto_Filter::parent() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.parent)
  return _internal_parent();
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.parent)
  if (_internal_has_parent()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_EmptyFilter* temp = filter_.parent_;
    filter_.parent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_parent(::autofill_assistant::SelectorProto_EmptyFilter* parent) {
  clear_filter();
  if (parent) {
    set_has_parent();
    filter_.parent_ = parent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.parent)
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::_internal_mutable_parent() {
  if (!_internal_has_parent()) {
    clear_filter();
    set_has_parent();
    filter_.parent_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_EmptyFilter >(GetArenaForAllocation());
  }
  return filter_.parent_;
}
inline ::autofill_assistant::SelectorProto_EmptyFilter* SelectorProto_Filter::mutable_parent() {
  ::autofill_assistant::SelectorProto_EmptyFilter* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.parent)
  return _msg;
}

// .autofill_assistant.SelectorProto.SemanticFilter semantic = 16;
inline bool SelectorProto_Filter::_internal_has_semantic() const {
  return filter_case() == kSemantic;
}
inline bool SelectorProto_Filter::has_semantic() const {
  return _internal_has_semantic();
}
inline void SelectorProto_Filter::set_has_semantic() {
  _oneof_case_[0] = kSemantic;
}
inline void SelectorProto_Filter::clear_semantic() {
  if (_internal_has_semantic()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.semantic_;
    }
    clear_has_filter();
  }
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* SelectorProto_Filter::release_semantic() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.Filter.semantic)
  if (_internal_has_semantic()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_SemanticFilter* temp = filter_.semantic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.semantic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto_SemanticFilter& SelectorProto_Filter::_internal_semantic() const {
  return _internal_has_semantic()
      ? *filter_.semantic_
      : reinterpret_cast< ::autofill_assistant::SelectorProto_SemanticFilter&>(::autofill_assistant::_SelectorProto_SemanticFilter_default_instance_);
}
inline const ::autofill_assistant::SelectorProto_SemanticFilter& SelectorProto_Filter::semantic() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.Filter.semantic)
  return _internal_semantic();
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* SelectorProto_Filter::unsafe_arena_release_semantic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.Filter.semantic)
  if (_internal_has_semantic()) {
    clear_has_filter();
    ::autofill_assistant::SelectorProto_SemanticFilter* temp = filter_.semantic_;
    filter_.semantic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_Filter::unsafe_arena_set_allocated_semantic(::autofill_assistant::SelectorProto_SemanticFilter* semantic) {
  clear_filter();
  if (semantic) {
    set_has_semantic();
    filter_.semantic_ = semantic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.Filter.semantic)
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* SelectorProto_Filter::_internal_mutable_semantic() {
  if (!_internal_has_semantic()) {
    clear_filter();
    set_has_semantic();
    filter_.semantic_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto_SemanticFilter >(GetArenaForAllocation());
  }
  return filter_.semantic_;
}
inline ::autofill_assistant::SelectorProto_SemanticFilter* SelectorProto_Filter::mutable_semantic() {
  ::autofill_assistant::SelectorProto_SemanticFilter* _msg = _internal_mutable_semantic();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.Filter.semantic)
  return _msg;
}

inline bool SelectorProto_Filter::has_filter() const {
  return filter_case() != FILTER_NOT_SET;
}
inline void SelectorProto_Filter::clear_has_filter() {
  _oneof_case_[0] = FILTER_NOT_SET;
}
inline SelectorProto_Filter::FilterCase SelectorProto_Filter::filter_case() const {
  return SelectorProto_Filter::FilterCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SelectorProto_PropertyFilter

// optional string property = 1;
inline bool SelectorProto_PropertyFilter::_internal_has_property() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto_PropertyFilter::has_property() const {
  return _internal_has_property();
}
inline void SelectorProto_PropertyFilter::clear_property() {
  property_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SelectorProto_PropertyFilter::property() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.PropertyFilter.property)
  return _internal_property();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectorProto_PropertyFilter::set_property(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 property_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.PropertyFilter.property)
}
inline std::string* SelectorProto_PropertyFilter::mutable_property() {
  std::string* _s = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.PropertyFilter.property)
  return _s;
}
inline const std::string& SelectorProto_PropertyFilter::_internal_property() const {
  return property_.Get();
}
inline void SelectorProto_PropertyFilter::_internal_set_property(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  property_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectorProto_PropertyFilter::_internal_mutable_property() {
  _has_bits_[0] |= 0x00000001u;
  return property_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectorProto_PropertyFilter::release_property() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.PropertyFilter.property)
  if (!_internal_has_property()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = property_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (property_.IsDefault()) {
    property_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectorProto_PropertyFilter::set_allocated_property(std::string* property) {
  if (property != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  property_.SetAllocated(property, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (property_.IsDefault()) {
    property_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.PropertyFilter.property)
}

// .autofill_assistant.TextFilter text_filter = 2;
inline bool SelectorProto_PropertyFilter::_internal_has_text_filter() const {
  return value_case() == kTextFilter;
}
inline bool SelectorProto_PropertyFilter::has_text_filter() const {
  return _internal_has_text_filter();
}
inline void SelectorProto_PropertyFilter::set_has_text_filter() {
  _oneof_case_[0] = kTextFilter;
}
inline ::autofill_assistant::TextFilter* SelectorProto_PropertyFilter::release_text_filter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.PropertyFilter.text_filter)
  if (_internal_has_text_filter()) {
    clear_has_value();
    ::autofill_assistant::TextFilter* temp = value_.text_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.text_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextFilter& SelectorProto_PropertyFilter::_internal_text_filter() const {
  return _internal_has_text_filter()
      ? *value_.text_filter_
      : reinterpret_cast< ::autofill_assistant::TextFilter&>(::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& SelectorProto_PropertyFilter::text_filter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.PropertyFilter.text_filter)
  return _internal_text_filter();
}
inline ::autofill_assistant::TextFilter* SelectorProto_PropertyFilter::unsafe_arena_release_text_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.PropertyFilter.text_filter)
  if (_internal_has_text_filter()) {
    clear_has_value();
    ::autofill_assistant::TextFilter* temp = value_.text_filter_;
    value_.text_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_PropertyFilter::unsafe_arena_set_allocated_text_filter(::autofill_assistant::TextFilter* text_filter) {
  clear_value();
  if (text_filter) {
    set_has_text_filter();
    value_.text_filter_ = text_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.PropertyFilter.text_filter)
}
inline ::autofill_assistant::TextFilter* SelectorProto_PropertyFilter::_internal_mutable_text_filter() {
  if (!_internal_has_text_filter()) {
    clear_value();
    set_has_text_filter();
    value_.text_filter_ = CreateMaybeMessage< ::autofill_assistant::TextFilter >(GetArenaForAllocation());
  }
  return value_.text_filter_;
}
inline ::autofill_assistant::TextFilter* SelectorProto_PropertyFilter::mutable_text_filter() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_text_filter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.PropertyFilter.text_filter)
  return _msg;
}

// .autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;
inline bool SelectorProto_PropertyFilter::_internal_has_autofill_value_regexp() const {
  return value_case() == kAutofillValueRegexp;
}
inline bool SelectorProto_PropertyFilter::has_autofill_value_regexp() const {
  return _internal_has_autofill_value_regexp();
}
inline void SelectorProto_PropertyFilter::set_has_autofill_value_regexp() {
  _oneof_case_[0] = kAutofillValueRegexp;
}
inline ::autofill_assistant::AutofillValueRegexp* SelectorProto_PropertyFilter::release_autofill_value_regexp() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.PropertyFilter.autofill_value_regexp)
  if (_internal_has_autofill_value_regexp()) {
    clear_has_value();
    ::autofill_assistant::AutofillValueRegexp* temp = value_.autofill_value_regexp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.autofill_value_regexp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::AutofillValueRegexp& SelectorProto_PropertyFilter::_internal_autofill_value_regexp() const {
  return _internal_has_autofill_value_regexp()
      ? *value_.autofill_value_regexp_
      : reinterpret_cast< ::autofill_assistant::AutofillValueRegexp&>(::autofill_assistant::_AutofillValueRegexp_default_instance_);
}
inline const ::autofill_assistant::AutofillValueRegexp& SelectorProto_PropertyFilter::autofill_value_regexp() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.PropertyFilter.autofill_value_regexp)
  return _internal_autofill_value_regexp();
}
inline ::autofill_assistant::AutofillValueRegexp* SelectorProto_PropertyFilter::unsafe_arena_release_autofill_value_regexp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectorProto.PropertyFilter.autofill_value_regexp)
  if (_internal_has_autofill_value_regexp()) {
    clear_has_value();
    ::autofill_assistant::AutofillValueRegexp* temp = value_.autofill_value_regexp_;
    value_.autofill_value_regexp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectorProto_PropertyFilter::unsafe_arena_set_allocated_autofill_value_regexp(::autofill_assistant::AutofillValueRegexp* autofill_value_regexp) {
  clear_value();
  if (autofill_value_regexp) {
    set_has_autofill_value_regexp();
    value_.autofill_value_regexp_ = autofill_value_regexp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.PropertyFilter.autofill_value_regexp)
}
inline ::autofill_assistant::AutofillValueRegexp* SelectorProto_PropertyFilter::_internal_mutable_autofill_value_regexp() {
  if (!_internal_has_autofill_value_regexp()) {
    clear_value();
    set_has_autofill_value_regexp();
    value_.autofill_value_regexp_ = CreateMaybeMessage< ::autofill_assistant::AutofillValueRegexp >(GetArenaForAllocation());
  }
  return value_.autofill_value_regexp_;
}
inline ::autofill_assistant::AutofillValueRegexp* SelectorProto_PropertyFilter::mutable_autofill_value_regexp() {
  ::autofill_assistant::AutofillValueRegexp* _msg = _internal_mutable_autofill_value_regexp();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.PropertyFilter.autofill_value_regexp)
  return _msg;
}

inline bool SelectorProto_PropertyFilter::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void SelectorProto_PropertyFilter::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline SelectorProto_PropertyFilter::ValueCase SelectorProto_PropertyFilter::value_case() const {
  return SelectorProto_PropertyFilter::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SelectorProto_PseudoElementContent

// optional .autofill_assistant.PseudoType pseudo_type = 1;
inline bool SelectorProto_PseudoElementContent::_internal_has_pseudo_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectorProto_PseudoElementContent::has_pseudo_type() const {
  return _internal_has_pseudo_type();
}
inline void SelectorProto_PseudoElementContent::clear_pseudo_type() {
  pseudo_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::PseudoType SelectorProto_PseudoElementContent::_internal_pseudo_type() const {
  return static_cast< ::autofill_assistant::PseudoType >(pseudo_type_);
}
inline ::autofill_assistant::PseudoType SelectorProto_PseudoElementContent::pseudo_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.PseudoElementContent.pseudo_type)
  return _internal_pseudo_type();
}
inline void SelectorProto_PseudoElementContent::_internal_set_pseudo_type(::autofill_assistant::PseudoType value) {
  assert(::autofill_assistant::PseudoType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  pseudo_type_ = value;
}
inline void SelectorProto_PseudoElementContent::set_pseudo_type(::autofill_assistant::PseudoType value) {
  _internal_set_pseudo_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.PseudoElementContent.pseudo_type)
}

// optional .autofill_assistant.TextFilter content = 2;
inline bool SelectorProto_PseudoElementContent::_internal_has_content() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || content_ != nullptr);
  return value;
}
inline bool SelectorProto_PseudoElementContent::has_content() const {
  return _internal_has_content();
}
inline const ::autofill_assistant::TextFilter& SelectorProto_PseudoElementContent::_internal_content() const {
  const ::autofill_assistant::TextFilter* p = content_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TextFilter&>(
      ::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& SelectorProto_PseudoElementContent::content() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.PseudoElementContent.content)
  return _internal_content();
}
inline void SelectorProto_PseudoElementContent::unsafe_arena_set_allocated_content(
    ::autofill_assistant::TextFilter* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_);
  }
  content_ = content;
  if (content) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.PseudoElementContent.content)
}
inline ::autofill_assistant::TextFilter* SelectorProto_PseudoElementContent::release_content() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::TextFilter* temp = content_;
  content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TextFilter* SelectorProto_PseudoElementContent::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.PseudoElementContent.content)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::TextFilter* temp = content_;
  content_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TextFilter* SelectorProto_PseudoElementContent::_internal_mutable_content() {
  _has_bits_[0] |= 0x00000001u;
  if (content_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TextFilter>(GetArenaForAllocation());
    content_ = p;
  }
  return content_;
}
inline ::autofill_assistant::TextFilter* SelectorProto_PseudoElementContent::mutable_content() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.PseudoElementContent.content)
  return _msg;
}
inline void SelectorProto_PseudoElementContent::set_allocated_content(::autofill_assistant::TextFilter* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_);
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content));
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_ = content;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.PseudoElementContent.content)
}

// -------------------------------------------------------------------

// SelectorProto_CssStyleFilter

// optional string property = 3;
inline bool SelectorProto_CssStyleFilter::_internal_has_property() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto_CssStyleFilter::has_property() const {
  return _internal_has_property();
}
inline void SelectorProto_CssStyleFilter::clear_property() {
  property_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SelectorProto_CssStyleFilter::property() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.CssStyleFilter.property)
  return _internal_property();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectorProto_CssStyleFilter::set_property(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 property_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.CssStyleFilter.property)
}
inline std::string* SelectorProto_CssStyleFilter::mutable_property() {
  std::string* _s = _internal_mutable_property();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.CssStyleFilter.property)
  return _s;
}
inline const std::string& SelectorProto_CssStyleFilter::_internal_property() const {
  return property_.Get();
}
inline void SelectorProto_CssStyleFilter::_internal_set_property(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  property_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectorProto_CssStyleFilter::_internal_mutable_property() {
  _has_bits_[0] |= 0x00000001u;
  return property_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectorProto_CssStyleFilter::release_property() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.CssStyleFilter.property)
  if (!_internal_has_property()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = property_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (property_.IsDefault()) {
    property_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectorProto_CssStyleFilter::set_allocated_property(std::string* property) {
  if (property != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  property_.SetAllocated(property, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (property_.IsDefault()) {
    property_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.CssStyleFilter.property)
}

// optional string pseudo_element = 4;
inline bool SelectorProto_CssStyleFilter::_internal_has_pseudo_element() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectorProto_CssStyleFilter::has_pseudo_element() const {
  return _internal_has_pseudo_element();
}
inline void SelectorProto_CssStyleFilter::clear_pseudo_element() {
  pseudo_element_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SelectorProto_CssStyleFilter::pseudo_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.CssStyleFilter.pseudo_element)
  return _internal_pseudo_element();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectorProto_CssStyleFilter::set_pseudo_element(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 pseudo_element_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.CssStyleFilter.pseudo_element)
}
inline std::string* SelectorProto_CssStyleFilter::mutable_pseudo_element() {
  std::string* _s = _internal_mutable_pseudo_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.CssStyleFilter.pseudo_element)
  return _s;
}
inline const std::string& SelectorProto_CssStyleFilter::_internal_pseudo_element() const {
  return pseudo_element_.Get();
}
inline void SelectorProto_CssStyleFilter::_internal_set_pseudo_element(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pseudo_element_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectorProto_CssStyleFilter::_internal_mutable_pseudo_element() {
  _has_bits_[0] |= 0x00000002u;
  return pseudo_element_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectorProto_CssStyleFilter::release_pseudo_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.CssStyleFilter.pseudo_element)
  if (!_internal_has_pseudo_element()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = pseudo_element_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pseudo_element_.IsDefault()) {
    pseudo_element_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectorProto_CssStyleFilter::set_allocated_pseudo_element(std::string* pseudo_element) {
  if (pseudo_element != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pseudo_element_.SetAllocated(pseudo_element, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pseudo_element_.IsDefault()) {
    pseudo_element_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.CssStyleFilter.pseudo_element)
}

// optional bool should_match = 5 [default = true];
inline bool SelectorProto_CssStyleFilter::_internal_has_should_match() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SelectorProto_CssStyleFilter::has_should_match() const {
  return _internal_has_should_match();
}
inline void SelectorProto_CssStyleFilter::clear_should_match() {
  should_match_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool SelectorProto_CssStyleFilter::_internal_should_match() const {
  return should_match_;
}
inline bool SelectorProto_CssStyleFilter::should_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.CssStyleFilter.should_match)
  return _internal_should_match();
}
inline void SelectorProto_CssStyleFilter::_internal_set_should_match(bool value) {
  _has_bits_[0] |= 0x00000008u;
  should_match_ = value;
}
inline void SelectorProto_CssStyleFilter::set_should_match(bool value) {
  _internal_set_should_match(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.CssStyleFilter.should_match)
}

// optional .autofill_assistant.TextFilter value = 6;
inline bool SelectorProto_CssStyleFilter::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool SelectorProto_CssStyleFilter::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::TextFilter& SelectorProto_CssStyleFilter::_internal_value() const {
  const ::autofill_assistant::TextFilter* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TextFilter&>(
      ::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& SelectorProto_CssStyleFilter::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.CssStyleFilter.value)
  return _internal_value();
}
inline void SelectorProto_CssStyleFilter::unsafe_arena_set_allocated_value(
    ::autofill_assistant::TextFilter* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectorProto.CssStyleFilter.value)
}
inline ::autofill_assistant::TextFilter* SelectorProto_CssStyleFilter::release_value() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::TextFilter* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TextFilter* SelectorProto_CssStyleFilter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectorProto.CssStyleFilter.value)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::TextFilter* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TextFilter* SelectorProto_CssStyleFilter::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000004u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TextFilter>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::TextFilter* SelectorProto_CssStyleFilter::mutable_value() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.CssStyleFilter.value)
  return _msg;
}
inline void SelectorProto_CssStyleFilter::set_allocated_value(::autofill_assistant::TextFilter* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.CssStyleFilter.value)
}

// -------------------------------------------------------------------

// SelectorProto_BoundingBoxFilter

// optional bool require_nonempty = 1;
inline bool SelectorProto_BoundingBoxFilter::_internal_has_require_nonempty() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto_BoundingBoxFilter::has_require_nonempty() const {
  return _internal_has_require_nonempty();
}
inline void SelectorProto_BoundingBoxFilter::clear_require_nonempty() {
  require_nonempty_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SelectorProto_BoundingBoxFilter::_internal_require_nonempty() const {
  return require_nonempty_;
}
inline bool SelectorProto_BoundingBoxFilter::require_nonempty() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.BoundingBoxFilter.require_nonempty)
  return _internal_require_nonempty();
}
inline void SelectorProto_BoundingBoxFilter::_internal_set_require_nonempty(bool value) {
  _has_bits_[0] |= 0x00000001u;
  require_nonempty_ = value;
}
inline void SelectorProto_BoundingBoxFilter::set_require_nonempty(bool value) {
  _internal_set_require_nonempty(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.BoundingBoxFilter.require_nonempty)
}

// -------------------------------------------------------------------

// SelectorProto_OnTopFilter

// optional bool scroll_into_view_if_needed = 1 [default = true];
inline bool SelectorProto_OnTopFilter::_internal_has_scroll_into_view_if_needed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectorProto_OnTopFilter::has_scroll_into_view_if_needed() const {
  return _internal_has_scroll_into_view_if_needed();
}
inline void SelectorProto_OnTopFilter::clear_scroll_into_view_if_needed() {
  scroll_into_view_if_needed_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SelectorProto_OnTopFilter::_internal_scroll_into_view_if_needed() const {
  return scroll_into_view_if_needed_;
}
inline bool SelectorProto_OnTopFilter::scroll_into_view_if_needed() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.OnTopFilter.scroll_into_view_if_needed)
  return _internal_scroll_into_view_if_needed();
}
inline void SelectorProto_OnTopFilter::_internal_set_scroll_into_view_if_needed(bool value) {
  _has_bits_[0] |= 0x00000002u;
  scroll_into_view_if_needed_ = value;
}
inline void SelectorProto_OnTopFilter::set_scroll_into_view_if_needed(bool value) {
  _internal_set_scroll_into_view_if_needed(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.OnTopFilter.scroll_into_view_if_needed)
}

// optional bool accept_element_if_not_in_view = 2;
inline bool SelectorProto_OnTopFilter::_internal_has_accept_element_if_not_in_view() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto_OnTopFilter::has_accept_element_if_not_in_view() const {
  return _internal_has_accept_element_if_not_in_view();
}
inline void SelectorProto_OnTopFilter::clear_accept_element_if_not_in_view() {
  accept_element_if_not_in_view_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SelectorProto_OnTopFilter::_internal_accept_element_if_not_in_view() const {
  return accept_element_if_not_in_view_;
}
inline bool SelectorProto_OnTopFilter::accept_element_if_not_in_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.OnTopFilter.accept_element_if_not_in_view)
  return _internal_accept_element_if_not_in_view();
}
inline void SelectorProto_OnTopFilter::_internal_set_accept_element_if_not_in_view(bool value) {
  _has_bits_[0] |= 0x00000001u;
  accept_element_if_not_in_view_ = value;
}
inline void SelectorProto_OnTopFilter::set_accept_element_if_not_in_view(bool value) {
  _internal_set_accept_element_if_not_in_view(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.OnTopFilter.accept_element_if_not_in_view)
}

// -------------------------------------------------------------------

// SelectorProto_EmptyFilter

// -------------------------------------------------------------------

// SelectorProto_NthMatchFilter

// optional int32 index = 1;
inline bool SelectorProto_NthMatchFilter::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto_NthMatchFilter::has_index() const {
  return _internal_has_index();
}
inline void SelectorProto_NthMatchFilter::clear_index() {
  index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SelectorProto_NthMatchFilter::_internal_index() const {
  return index_;
}
inline int32_t SelectorProto_NthMatchFilter::index() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.NthMatchFilter.index)
  return _internal_index();
}
inline void SelectorProto_NthMatchFilter::_internal_set_index(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  index_ = value;
}
inline void SelectorProto_NthMatchFilter::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.NthMatchFilter.index)
}

// -------------------------------------------------------------------

// SelectorProto_SemanticFilter

// optional int32 objective = 1;
inline bool SelectorProto_SemanticFilter::_internal_has_objective() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto_SemanticFilter::has_objective() const {
  return _internal_has_objective();
}
inline void SelectorProto_SemanticFilter::clear_objective() {
  objective_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SelectorProto_SemanticFilter::_internal_objective() const {
  return objective_;
}
inline int32_t SelectorProto_SemanticFilter::objective() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.SemanticFilter.objective)
  return _internal_objective();
}
inline void SelectorProto_SemanticFilter::_internal_set_objective(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  objective_ = value;
}
inline void SelectorProto_SemanticFilter::set_objective(int32_t value) {
  _internal_set_objective(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.SemanticFilter.objective)
}

// optional int32 role = 2;
inline bool SelectorProto_SemanticFilter::_internal_has_role() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectorProto_SemanticFilter::has_role() const {
  return _internal_has_role();
}
inline void SelectorProto_SemanticFilter::clear_role() {
  role_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SelectorProto_SemanticFilter::_internal_role() const {
  return role_;
}
inline int32_t SelectorProto_SemanticFilter::role() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.SemanticFilter.role)
  return _internal_role();
}
inline void SelectorProto_SemanticFilter::_internal_set_role(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  role_ = value;
}
inline void SelectorProto_SemanticFilter::set_role(int32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.SemanticFilter.role)
}

// optional int32 model_timeout_ms = 3 [default = 5000];
inline bool SelectorProto_SemanticFilter::_internal_has_model_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SelectorProto_SemanticFilter::has_model_timeout_ms() const {
  return _internal_has_model_timeout_ms();
}
inline void SelectorProto_SemanticFilter::clear_model_timeout_ms() {
  model_timeout_ms_ = 5000;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t SelectorProto_SemanticFilter::_internal_model_timeout_ms() const {
  return model_timeout_ms_;
}
inline int32_t SelectorProto_SemanticFilter::model_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.SemanticFilter.model_timeout_ms)
  return _internal_model_timeout_ms();
}
inline void SelectorProto_SemanticFilter::_internal_set_model_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  model_timeout_ms_ = value;
}
inline void SelectorProto_SemanticFilter::set_model_timeout_ms(int32_t value) {
  _internal_set_model_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.SemanticFilter.model_timeout_ms)
}

// optional bool ignore_objective = 4;
inline bool SelectorProto_SemanticFilter::_internal_has_ignore_objective() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SelectorProto_SemanticFilter::has_ignore_objective() const {
  return _internal_has_ignore_objective();
}
inline void SelectorProto_SemanticFilter::clear_ignore_objective() {
  ignore_objective_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SelectorProto_SemanticFilter::_internal_ignore_objective() const {
  return ignore_objective_;
}
inline bool SelectorProto_SemanticFilter::ignore_objective() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.SemanticFilter.ignore_objective)
  return _internal_ignore_objective();
}
inline void SelectorProto_SemanticFilter::_internal_set_ignore_objective(bool value) {
  _has_bits_[0] |= 0x00000004u;
  ignore_objective_ = value;
}
inline void SelectorProto_SemanticFilter::set_ignore_objective(bool value) {
  _internal_set_ignore_objective(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.SemanticFilter.ignore_objective)
}

// -------------------------------------------------------------------

// SelectorProto

// repeated .autofill_assistant.SelectorProto.Filter filters = 9;
inline int SelectorProto::_internal_filters_size() const {
  return filters_.size();
}
inline int SelectorProto::filters_size() const {
  return _internal_filters_size();
}
inline void SelectorProto::clear_filters() {
  filters_.Clear();
}
inline ::autofill_assistant::SelectorProto_Filter* SelectorProto::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectorProto.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto_Filter >*
SelectorProto::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SelectorProto.filters)
  return &filters_;
}
inline const ::autofill_assistant::SelectorProto_Filter& SelectorProto::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::autofill_assistant::SelectorProto_Filter& SelectorProto::filters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.filters)
  return _internal_filters(index);
}
inline ::autofill_assistant::SelectorProto_Filter* SelectorProto::_internal_add_filters() {
  return filters_.Add();
}
inline ::autofill_assistant::SelectorProto_Filter* SelectorProto::add_filters() {
  ::autofill_assistant::SelectorProto_Filter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:autofill_assistant.SelectorProto.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto_Filter >&
SelectorProto::filters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SelectorProto.filters)
  return filters_;
}

// optional int64 tracking_id = 10;
inline bool SelectorProto::_internal_has_tracking_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectorProto::has_tracking_id() const {
  return _internal_has_tracking_id();
}
inline void SelectorProto::clear_tracking_id() {
  tracking_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t SelectorProto::_internal_tracking_id() const {
  return tracking_id_;
}
inline int64_t SelectorProto::tracking_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectorProto.tracking_id)
  return _internal_tracking_id();
}
inline void SelectorProto::_internal_set_tracking_id(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  tracking_id_ = value;
}
inline void SelectorProto::set_tracking_id(int64_t value) {
  _internal_set_tracking_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectorProto.tracking_id)
}

// -------------------------------------------------------------------

// SelectOptionProto

// optional .autofill_assistant.SelectorProto element = 2;
inline bool SelectOptionProto::_internal_has_element() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || element_ != nullptr);
  return value;
}
inline bool SelectOptionProto::has_element() const {
  return _internal_has_element();
}
inline void SelectOptionProto::clear_element() {
  if (element_ != nullptr) element_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& SelectOptionProto::_internal_element() const {
  const ::autofill_assistant::SelectorProto* p = element_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& SelectOptionProto::element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionProto.element)
  return _internal_element();
}
inline void SelectOptionProto::unsafe_arena_set_allocated_element(
    ::autofill_assistant::SelectorProto* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_);
  }
  element_ = element;
  if (element) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectOptionProto.element)
}
inline ::autofill_assistant::SelectorProto* SelectOptionProto::release_element() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* SelectOptionProto::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectOptionProto.element)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* SelectOptionProto::_internal_mutable_element() {
  _has_bits_[0] |= 0x00000001u;
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    element_ = p;
  }
  return element_;
}
inline ::autofill_assistant::SelectorProto* SelectOptionProto::mutable_element() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectOptionProto.element)
  return _msg;
}
inline void SelectOptionProto::set_allocated_element(::autofill_assistant::SelectorProto* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectOptionProto.element)
}

// .autofill_assistant.TextFilter text_filter_value = 7;
inline bool SelectOptionProto::_internal_has_text_filter_value() const {
  return value_case() == kTextFilterValue;
}
inline bool SelectOptionProto::has_text_filter_value() const {
  return _internal_has_text_filter_value();
}
inline void SelectOptionProto::set_has_text_filter_value() {
  _oneof_case_[0] = kTextFilterValue;
}
inline ::autofill_assistant::TextFilter* SelectOptionProto::release_text_filter_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectOptionProto.text_filter_value)
  if (_internal_has_text_filter_value()) {
    clear_has_value();
    ::autofill_assistant::TextFilter* temp = value_.text_filter_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.text_filter_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextFilter& SelectOptionProto::_internal_text_filter_value() const {
  return _internal_has_text_filter_value()
      ? *value_.text_filter_value_
      : reinterpret_cast< ::autofill_assistant::TextFilter&>(::autofill_assistant::_TextFilter_default_instance_);
}
inline const ::autofill_assistant::TextFilter& SelectOptionProto::text_filter_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionProto.text_filter_value)
  return _internal_text_filter_value();
}
inline ::autofill_assistant::TextFilter* SelectOptionProto::unsafe_arena_release_text_filter_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectOptionProto.text_filter_value)
  if (_internal_has_text_filter_value()) {
    clear_has_value();
    ::autofill_assistant::TextFilter* temp = value_.text_filter_value_;
    value_.text_filter_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectOptionProto::unsafe_arena_set_allocated_text_filter_value(::autofill_assistant::TextFilter* text_filter_value) {
  clear_value();
  if (text_filter_value) {
    set_has_text_filter_value();
    value_.text_filter_value_ = text_filter_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectOptionProto.text_filter_value)
}
inline ::autofill_assistant::TextFilter* SelectOptionProto::_internal_mutable_text_filter_value() {
  if (!_internal_has_text_filter_value()) {
    clear_value();
    set_has_text_filter_value();
    value_.text_filter_value_ = CreateMaybeMessage< ::autofill_assistant::TextFilter >(GetArenaForAllocation());
  }
  return value_.text_filter_value_;
}
inline ::autofill_assistant::TextFilter* SelectOptionProto::mutable_text_filter_value() {
  ::autofill_assistant::TextFilter* _msg = _internal_mutable_text_filter_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectOptionProto.text_filter_value)
  return _msg;
}

// .autofill_assistant.AutofillValueRegexp autofill_regexp_value = 8;
inline bool SelectOptionProto::_internal_has_autofill_regexp_value() const {
  return value_case() == kAutofillRegexpValue;
}
inline bool SelectOptionProto::has_autofill_regexp_value() const {
  return _internal_has_autofill_regexp_value();
}
inline void SelectOptionProto::set_has_autofill_regexp_value() {
  _oneof_case_[0] = kAutofillRegexpValue;
}
inline ::autofill_assistant::AutofillValueRegexp* SelectOptionProto::release_autofill_regexp_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectOptionProto.autofill_regexp_value)
  if (_internal_has_autofill_regexp_value()) {
    clear_has_value();
    ::autofill_assistant::AutofillValueRegexp* temp = value_.autofill_regexp_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.autofill_regexp_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::AutofillValueRegexp& SelectOptionProto::_internal_autofill_regexp_value() const {
  return _internal_has_autofill_regexp_value()
      ? *value_.autofill_regexp_value_
      : reinterpret_cast< ::autofill_assistant::AutofillValueRegexp&>(::autofill_assistant::_AutofillValueRegexp_default_instance_);
}
inline const ::autofill_assistant::AutofillValueRegexp& SelectOptionProto::autofill_regexp_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionProto.autofill_regexp_value)
  return _internal_autofill_regexp_value();
}
inline ::autofill_assistant::AutofillValueRegexp* SelectOptionProto::unsafe_arena_release_autofill_regexp_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.SelectOptionProto.autofill_regexp_value)
  if (_internal_has_autofill_regexp_value()) {
    clear_has_value();
    ::autofill_assistant::AutofillValueRegexp* temp = value_.autofill_regexp_value_;
    value_.autofill_regexp_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectOptionProto::unsafe_arena_set_allocated_autofill_regexp_value(::autofill_assistant::AutofillValueRegexp* autofill_regexp_value) {
  clear_value();
  if (autofill_regexp_value) {
    set_has_autofill_regexp_value();
    value_.autofill_regexp_value_ = autofill_regexp_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectOptionProto.autofill_regexp_value)
}
inline ::autofill_assistant::AutofillValueRegexp* SelectOptionProto::_internal_mutable_autofill_regexp_value() {
  if (!_internal_has_autofill_regexp_value()) {
    clear_value();
    set_has_autofill_regexp_value();
    value_.autofill_regexp_value_ = CreateMaybeMessage< ::autofill_assistant::AutofillValueRegexp >(GetArenaForAllocation());
  }
  return value_.autofill_regexp_value_;
}
inline ::autofill_assistant::AutofillValueRegexp* SelectOptionProto::mutable_autofill_regexp_value() {
  ::autofill_assistant::AutofillValueRegexp* _msg = _internal_mutable_autofill_regexp_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectOptionProto.autofill_regexp_value)
  return _msg;
}

// optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 6;
inline bool SelectOptionProto::_internal_has_option_comparison_attribute() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectOptionProto::has_option_comparison_attribute() const {
  return _internal_has_option_comparison_attribute();
}
inline void SelectOptionProto::clear_option_comparison_attribute() {
  option_comparison_attribute_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute SelectOptionProto::_internal_option_comparison_attribute() const {
  return static_cast< ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute >(option_comparison_attribute_);
}
inline ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute SelectOptionProto::option_comparison_attribute() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionProto.option_comparison_attribute)
  return _internal_option_comparison_attribute();
}
inline void SelectOptionProto::_internal_set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value) {
  assert(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  option_comparison_attribute_ = value;
}
inline void SelectOptionProto::set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value) {
  _internal_set_option_comparison_attribute(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectOptionProto.option_comparison_attribute)
}

// optional bool strict = 9;
inline bool SelectOptionProto::_internal_has_strict() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SelectOptionProto::has_strict() const {
  return _internal_has_strict();
}
inline void SelectOptionProto::clear_strict() {
  strict_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SelectOptionProto::_internal_strict() const {
  return strict_;
}
inline bool SelectOptionProto::strict() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionProto.strict)
  return _internal_strict();
}
inline void SelectOptionProto::_internal_set_strict(bool value) {
  _has_bits_[0] |= 0x00000004u;
  strict_ = value;
}
inline void SelectOptionProto::set_strict(bool value) {
  _internal_set_strict(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectOptionProto.strict)
}

inline bool SelectOptionProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void SelectOptionProto::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline SelectOptionProto::ValueCase SelectOptionProto::value_case() const {
  return SelectOptionProto::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateClientSettingsProto

// optional .autofill_assistant.ClientSettingsProto client_settings = 1;
inline bool UpdateClientSettingsProto::_internal_has_client_settings() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_settings_ != nullptr);
  return value;
}
inline bool UpdateClientSettingsProto::has_client_settings() const {
  return _internal_has_client_settings();
}
inline void UpdateClientSettingsProto::clear_client_settings() {
  if (client_settings_ != nullptr) client_settings_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientSettingsProto& UpdateClientSettingsProto::_internal_client_settings() const {
  const ::autofill_assistant::ClientSettingsProto* p = client_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientSettingsProto&>(
      ::autofill_assistant::_ClientSettingsProto_default_instance_);
}
inline const ::autofill_assistant::ClientSettingsProto& UpdateClientSettingsProto::client_settings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UpdateClientSettingsProto.client_settings)
  return _internal_client_settings();
}
inline void UpdateClientSettingsProto::unsafe_arena_set_allocated_client_settings(
    ::autofill_assistant::ClientSettingsProto* client_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_settings_);
  }
  client_settings_ = client_settings;
  if (client_settings) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UpdateClientSettingsProto.client_settings)
}
inline ::autofill_assistant::ClientSettingsProto* UpdateClientSettingsProto::release_client_settings() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientSettingsProto* temp = client_settings_;
  client_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto* UpdateClientSettingsProto::unsafe_arena_release_client_settings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UpdateClientSettingsProto.client_settings)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientSettingsProto* temp = client_settings_;
  client_settings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientSettingsProto* UpdateClientSettingsProto::_internal_mutable_client_settings() {
  _has_bits_[0] |= 0x00000001u;
  if (client_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientSettingsProto>(GetArenaForAllocation());
    client_settings_ = p;
  }
  return client_settings_;
}
inline ::autofill_assistant::ClientSettingsProto* UpdateClientSettingsProto::mutable_client_settings() {
  ::autofill_assistant::ClientSettingsProto* _msg = _internal_mutable_client_settings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UpdateClientSettingsProto.client_settings)
  return _msg;
}
inline void UpdateClientSettingsProto::set_allocated_client_settings(::autofill_assistant::ClientSettingsProto* client_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_settings_;
  }
  if (client_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_settings);
    if (message_arena != submessage_arena) {
      client_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_settings_ = client_settings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UpdateClientSettingsProto.client_settings)
}

// -------------------------------------------------------------------

// PromptQrCodeScanProto_CameraScanUiStrings

// optional string title_text = 1;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_title_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_title_text() const {
  return _internal_has_title_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_title_text() {
  title_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::title_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.title_text)
  return _internal_title_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_title_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.title_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_title_text() {
  std::string* _s = _internal_mutable_title_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.title_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_title_text() const {
  return title_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_title_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_title_text() {
  _has_bits_[0] |= 0x00000001u;
  return title_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_title_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.title_text)
  if (!_internal_has_title_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_text_.IsDefault()) {
    title_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_title_text(std::string* title_text) {
  if (title_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_text_.SetAllocated(title_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_text_.IsDefault()) {
    title_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.title_text)
}

// optional string permission_text = 2;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_permission_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_permission_text() const {
  return _internal_has_permission_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_permission_text() {
  permission_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::permission_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_text)
  return _internal_permission_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_permission_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 permission_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_permission_text() {
  std::string* _s = _internal_mutable_permission_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_permission_text() const {
  return permission_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_permission_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  permission_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_permission_text() {
  _has_bits_[0] |= 0x00000002u;
  return permission_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_permission_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_text)
  if (!_internal_has_permission_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = permission_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_text_.IsDefault()) {
    permission_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_permission_text(std::string* permission_text) {
  if (permission_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  permission_text_.SetAllocated(permission_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_text_.IsDefault()) {
    permission_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_text)
}

// optional string permission_button_text = 3;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_permission_button_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_permission_button_text() const {
  return _internal_has_permission_button_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_permission_button_text() {
  permission_button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::permission_button_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_button_text)
  return _internal_permission_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_permission_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 permission_button_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_button_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_permission_button_text() {
  std::string* _s = _internal_mutable_permission_button_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_button_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_permission_button_text() const {
  return permission_button_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_permission_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  permission_button_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_permission_button_text() {
  _has_bits_[0] |= 0x00000004u;
  return permission_button_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_permission_button_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_button_text)
  if (!_internal_has_permission_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = permission_button_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_button_text_.IsDefault()) {
    permission_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_permission_button_text(std::string* permission_button_text) {
  if (permission_button_text != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  permission_button_text_.SetAllocated(permission_button_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_button_text_.IsDefault()) {
    permission_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.permission_button_text)
}

// optional string open_settings_text = 4;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_open_settings_text() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_open_settings_text() const {
  return _internal_has_open_settings_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_open_settings_text() {
  open_settings_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::open_settings_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_text)
  return _internal_open_settings_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_open_settings_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 open_settings_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_open_settings_text() {
  std::string* _s = _internal_mutable_open_settings_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_open_settings_text() const {
  return open_settings_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_open_settings_text(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  open_settings_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_open_settings_text() {
  _has_bits_[0] |= 0x00000008u;
  return open_settings_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_open_settings_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_text)
  if (!_internal_has_open_settings_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = open_settings_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_text_.IsDefault()) {
    open_settings_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_open_settings_text(std::string* open_settings_text) {
  if (open_settings_text != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  open_settings_text_.SetAllocated(open_settings_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_text_.IsDefault()) {
    open_settings_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_text)
}

// optional string open_settings_button_text = 5;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_open_settings_button_text() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_open_settings_button_text() const {
  return _internal_has_open_settings_button_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_open_settings_button_text() {
  open_settings_button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::open_settings_button_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_button_text)
  return _internal_open_settings_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_open_settings_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 open_settings_button_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_button_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_open_settings_button_text() {
  std::string* _s = _internal_mutable_open_settings_button_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_button_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_open_settings_button_text() const {
  return open_settings_button_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_open_settings_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  open_settings_button_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_open_settings_button_text() {
  _has_bits_[0] |= 0x00000010u;
  return open_settings_button_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_open_settings_button_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_button_text)
  if (!_internal_has_open_settings_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = open_settings_button_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_button_text_.IsDefault()) {
    open_settings_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_open_settings_button_text(std::string* open_settings_button_text) {
  if (open_settings_button_text != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  open_settings_button_text_.SetAllocated(open_settings_button_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_button_text_.IsDefault()) {
    open_settings_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.open_settings_button_text)
}

// optional string camera_preview_instruction_text = 6;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_camera_preview_instruction_text() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_camera_preview_instruction_text() const {
  return _internal_has_camera_preview_instruction_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_camera_preview_instruction_text() {
  camera_preview_instruction_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::camera_preview_instruction_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_instruction_text)
  return _internal_camera_preview_instruction_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_camera_preview_instruction_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 camera_preview_instruction_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_instruction_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_camera_preview_instruction_text() {
  std::string* _s = _internal_mutable_camera_preview_instruction_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_instruction_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_camera_preview_instruction_text() const {
  return camera_preview_instruction_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_camera_preview_instruction_text(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  camera_preview_instruction_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_camera_preview_instruction_text() {
  _has_bits_[0] |= 0x00000020u;
  return camera_preview_instruction_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_camera_preview_instruction_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_instruction_text)
  if (!_internal_has_camera_preview_instruction_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = camera_preview_instruction_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_preview_instruction_text_.IsDefault()) {
    camera_preview_instruction_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_camera_preview_instruction_text(std::string* camera_preview_instruction_text) {
  if (camera_preview_instruction_text != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  camera_preview_instruction_text_.SetAllocated(camera_preview_instruction_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_preview_instruction_text_.IsDefault()) {
    camera_preview_instruction_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_instruction_text)
}

// optional string camera_preview_security_text = 7;
inline bool PromptQrCodeScanProto_CameraScanUiStrings::_internal_has_camera_preview_security_text() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_CameraScanUiStrings::has_camera_preview_security_text() const {
  return _internal_has_camera_preview_security_text();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::clear_camera_preview_security_text() {
  camera_preview_security_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::camera_preview_security_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_security_text)
  return _internal_camera_preview_security_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_CameraScanUiStrings::set_camera_preview_security_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 camera_preview_security_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_security_text)
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::mutable_camera_preview_security_text() {
  std::string* _s = _internal_mutable_camera_preview_security_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_security_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_CameraScanUiStrings::_internal_camera_preview_security_text() const {
  return camera_preview_security_text_.Get();
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::_internal_set_camera_preview_security_text(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  camera_preview_security_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::_internal_mutable_camera_preview_security_text() {
  _has_bits_[0] |= 0x00000040u;
  return camera_preview_security_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_CameraScanUiStrings::release_camera_preview_security_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_security_text)
  if (!_internal_has_camera_preview_security_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = camera_preview_security_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_preview_security_text_.IsDefault()) {
    camera_preview_security_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_CameraScanUiStrings::set_allocated_camera_preview_security_text(std::string* camera_preview_security_text) {
  if (camera_preview_security_text != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  camera_preview_security_text_.SetAllocated(camera_preview_security_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (camera_preview_security_text_.IsDefault()) {
    camera_preview_security_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings.camera_preview_security_text)
}

// -------------------------------------------------------------------

// PromptQrCodeScanProto_ImagePickerUiStrings

// optional string title_text = 1;
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::_internal_has_title_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::has_title_text() const {
  return _internal_has_title_text();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::clear_title_text() {
  title_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::title_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.title_text)
  return _internal_title_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_ImagePickerUiStrings::set_title_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.title_text)
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::mutable_title_text() {
  std::string* _s = _internal_mutable_title_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.title_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::_internal_title_text() const {
  return title_text_.Get();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::_internal_set_title_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::_internal_mutable_title_text() {
  _has_bits_[0] |= 0x00000001u;
  return title_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::release_title_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.title_text)
  if (!_internal_has_title_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_text_.IsDefault()) {
    title_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::set_allocated_title_text(std::string* title_text) {
  if (title_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_text_.SetAllocated(title_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_text_.IsDefault()) {
    title_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.title_text)
}

// optional string permission_text = 2;
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::_internal_has_permission_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::has_permission_text() const {
  return _internal_has_permission_text();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::clear_permission_text() {
  permission_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::permission_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_text)
  return _internal_permission_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_ImagePickerUiStrings::set_permission_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 permission_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_text)
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::mutable_permission_text() {
  std::string* _s = _internal_mutable_permission_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::_internal_permission_text() const {
  return permission_text_.Get();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::_internal_set_permission_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  permission_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::_internal_mutable_permission_text() {
  _has_bits_[0] |= 0x00000002u;
  return permission_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::release_permission_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_text)
  if (!_internal_has_permission_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = permission_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_text_.IsDefault()) {
    permission_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::set_allocated_permission_text(std::string* permission_text) {
  if (permission_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  permission_text_.SetAllocated(permission_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_text_.IsDefault()) {
    permission_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_text)
}

// optional string permission_button_text = 3;
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::_internal_has_permission_button_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::has_permission_button_text() const {
  return _internal_has_permission_button_text();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::clear_permission_button_text() {
  permission_button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::permission_button_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_button_text)
  return _internal_permission_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_ImagePickerUiStrings::set_permission_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 permission_button_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_button_text)
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::mutable_permission_button_text() {
  std::string* _s = _internal_mutable_permission_button_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_button_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::_internal_permission_button_text() const {
  return permission_button_text_.Get();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::_internal_set_permission_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  permission_button_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::_internal_mutable_permission_button_text() {
  _has_bits_[0] |= 0x00000004u;
  return permission_button_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::release_permission_button_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_button_text)
  if (!_internal_has_permission_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = permission_button_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_button_text_.IsDefault()) {
    permission_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::set_allocated_permission_button_text(std::string* permission_button_text) {
  if (permission_button_text != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  permission_button_text_.SetAllocated(permission_button_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (permission_button_text_.IsDefault()) {
    permission_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.permission_button_text)
}

// optional string open_settings_text = 4;
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::_internal_has_open_settings_text() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::has_open_settings_text() const {
  return _internal_has_open_settings_text();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::clear_open_settings_text() {
  open_settings_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::open_settings_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_text)
  return _internal_open_settings_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_ImagePickerUiStrings::set_open_settings_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 open_settings_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_text)
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::mutable_open_settings_text() {
  std::string* _s = _internal_mutable_open_settings_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::_internal_open_settings_text() const {
  return open_settings_text_.Get();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::_internal_set_open_settings_text(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  open_settings_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::_internal_mutable_open_settings_text() {
  _has_bits_[0] |= 0x00000008u;
  return open_settings_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::release_open_settings_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_text)
  if (!_internal_has_open_settings_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = open_settings_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_text_.IsDefault()) {
    open_settings_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::set_allocated_open_settings_text(std::string* open_settings_text) {
  if (open_settings_text != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  open_settings_text_.SetAllocated(open_settings_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_text_.IsDefault()) {
    open_settings_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_text)
}

// optional string open_settings_button_text = 5;
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::_internal_has_open_settings_button_text() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto_ImagePickerUiStrings::has_open_settings_button_text() const {
  return _internal_has_open_settings_button_text();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::clear_open_settings_button_text() {
  open_settings_button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::open_settings_button_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_button_text)
  return _internal_open_settings_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto_ImagePickerUiStrings::set_open_settings_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 open_settings_button_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_button_text)
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::mutable_open_settings_button_text() {
  std::string* _s = _internal_mutable_open_settings_button_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_button_text)
  return _s;
}
inline const std::string& PromptQrCodeScanProto_ImagePickerUiStrings::_internal_open_settings_button_text() const {
  return open_settings_button_text_.Get();
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::_internal_set_open_settings_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  open_settings_button_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::_internal_mutable_open_settings_button_text() {
  _has_bits_[0] |= 0x00000010u;
  return open_settings_button_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto_ImagePickerUiStrings::release_open_settings_button_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_button_text)
  if (!_internal_has_open_settings_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = open_settings_button_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_button_text_.IsDefault()) {
    open_settings_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto_ImagePickerUiStrings::set_allocated_open_settings_button_text(std::string* open_settings_button_text) {
  if (open_settings_button_text != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  open_settings_button_text_.SetAllocated(open_settings_button_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_settings_button_text_.IsDefault()) {
    open_settings_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings.open_settings_button_text)
}

// -------------------------------------------------------------------

// PromptQrCodeScanProto

// optional bool use_gallery = 1;
inline bool PromptQrCodeScanProto::_internal_has_use_gallery() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto::has_use_gallery() const {
  return _internal_has_use_gallery();
}
inline void PromptQrCodeScanProto::clear_use_gallery() {
  use_gallery_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PromptQrCodeScanProto::_internal_use_gallery() const {
  return use_gallery_;
}
inline bool PromptQrCodeScanProto::use_gallery() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.use_gallery)
  return _internal_use_gallery();
}
inline void PromptQrCodeScanProto::_internal_set_use_gallery(bool value) {
  _has_bits_[0] |= 0x00000008u;
  use_gallery_ = value;
}
inline void PromptQrCodeScanProto::set_use_gallery(bool value) {
  _internal_set_use_gallery(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.use_gallery)
}

// optional string output_client_memory_key = 2;
inline bool PromptQrCodeScanProto::_internal_has_output_client_memory_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptQrCodeScanProto::has_output_client_memory_key() const {
  return _internal_has_output_client_memory_key();
}
inline void PromptQrCodeScanProto::clear_output_client_memory_key() {
  output_client_memory_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromptQrCodeScanProto::output_client_memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.output_client_memory_key)
  return _internal_output_client_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptQrCodeScanProto::set_output_client_memory_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 output_client_memory_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptQrCodeScanProto.output_client_memory_key)
}
inline std::string* PromptQrCodeScanProto::mutable_output_client_memory_key() {
  std::string* _s = _internal_mutable_output_client_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.output_client_memory_key)
  return _s;
}
inline const std::string& PromptQrCodeScanProto::_internal_output_client_memory_key() const {
  return output_client_memory_key_.Get();
}
inline void PromptQrCodeScanProto::_internal_set_output_client_memory_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  output_client_memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto::_internal_mutable_output_client_memory_key() {
  _has_bits_[0] |= 0x00000001u;
  return output_client_memory_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptQrCodeScanProto::release_output_client_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.output_client_memory_key)
  if (!_internal_has_output_client_memory_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = output_client_memory_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (output_client_memory_key_.IsDefault()) {
    output_client_memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptQrCodeScanProto::set_allocated_output_client_memory_key(std::string* output_client_memory_key) {
  if (output_client_memory_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  output_client_memory_key_.SetAllocated(output_client_memory_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (output_client_memory_key_.IsDefault()) {
    output_client_memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.output_client_memory_key)
}

// optional .autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings camera_scan_ui_strings = 3;
inline bool PromptQrCodeScanProto::_internal_has_camera_scan_ui_strings() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || camera_scan_ui_strings_ != nullptr);
  return value;
}
inline bool PromptQrCodeScanProto::has_camera_scan_ui_strings() const {
  return _internal_has_camera_scan_ui_strings();
}
inline void PromptQrCodeScanProto::clear_camera_scan_ui_strings() {
  if (camera_scan_ui_strings_ != nullptr) camera_scan_ui_strings_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings& PromptQrCodeScanProto::_internal_camera_scan_ui_strings() const {
  const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* p = camera_scan_ui_strings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings&>(
      ::autofill_assistant::_PromptQrCodeScanProto_CameraScanUiStrings_default_instance_);
}
inline const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings& PromptQrCodeScanProto::camera_scan_ui_strings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.camera_scan_ui_strings)
  return _internal_camera_scan_ui_strings();
}
inline void PromptQrCodeScanProto::unsafe_arena_set_allocated_camera_scan_ui_strings(
    ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* camera_scan_ui_strings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_scan_ui_strings_);
  }
  camera_scan_ui_strings_ = camera_scan_ui_strings;
  if (camera_scan_ui_strings) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.PromptQrCodeScanProto.camera_scan_ui_strings)
}
inline ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* PromptQrCodeScanProto::release_camera_scan_ui_strings() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* temp = camera_scan_ui_strings_;
  camera_scan_ui_strings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* PromptQrCodeScanProto::unsafe_arena_release_camera_scan_ui_strings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.camera_scan_ui_strings)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* temp = camera_scan_ui_strings_;
  camera_scan_ui_strings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* PromptQrCodeScanProto::_internal_mutable_camera_scan_ui_strings() {
  _has_bits_[0] |= 0x00000002u;
  if (camera_scan_ui_strings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings>(GetArenaForAllocation());
    camera_scan_ui_strings_ = p;
  }
  return camera_scan_ui_strings_;
}
inline ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* PromptQrCodeScanProto::mutable_camera_scan_ui_strings() {
  ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* _msg = _internal_mutable_camera_scan_ui_strings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.camera_scan_ui_strings)
  return _msg;
}
inline void PromptQrCodeScanProto::set_allocated_camera_scan_ui_strings(::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings* camera_scan_ui_strings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete camera_scan_ui_strings_;
  }
  if (camera_scan_ui_strings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_scan_ui_strings);
    if (message_arena != submessage_arena) {
      camera_scan_ui_strings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_scan_ui_strings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  camera_scan_ui_strings_ = camera_scan_ui_strings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.camera_scan_ui_strings)
}

// optional .autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings image_picker_ui_strings = 4;
inline bool PromptQrCodeScanProto::_internal_has_image_picker_ui_strings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || image_picker_ui_strings_ != nullptr);
  return value;
}
inline bool PromptQrCodeScanProto::has_image_picker_ui_strings() const {
  return _internal_has_image_picker_ui_strings();
}
inline void PromptQrCodeScanProto::clear_image_picker_ui_strings() {
  if (image_picker_ui_strings_ != nullptr) image_picker_ui_strings_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings& PromptQrCodeScanProto::_internal_image_picker_ui_strings() const {
  const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* p = image_picker_ui_strings_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings&>(
      ::autofill_assistant::_PromptQrCodeScanProto_ImagePickerUiStrings_default_instance_);
}
inline const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings& PromptQrCodeScanProto::image_picker_ui_strings() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptQrCodeScanProto.image_picker_ui_strings)
  return _internal_image_picker_ui_strings();
}
inline void PromptQrCodeScanProto::unsafe_arena_set_allocated_image_picker_ui_strings(
    ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* image_picker_ui_strings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_picker_ui_strings_);
  }
  image_picker_ui_strings_ = image_picker_ui_strings;
  if (image_picker_ui_strings) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.PromptQrCodeScanProto.image_picker_ui_strings)
}
inline ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* PromptQrCodeScanProto::release_image_picker_ui_strings() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* temp = image_picker_ui_strings_;
  image_picker_ui_strings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* PromptQrCodeScanProto::unsafe_arena_release_image_picker_ui_strings() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptQrCodeScanProto.image_picker_ui_strings)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* temp = image_picker_ui_strings_;
  image_picker_ui_strings_ = nullptr;
  return temp;
}
inline ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* PromptQrCodeScanProto::_internal_mutable_image_picker_ui_strings() {
  _has_bits_[0] |= 0x00000004u;
  if (image_picker_ui_strings_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings>(GetArenaForAllocation());
    image_picker_ui_strings_ = p;
  }
  return image_picker_ui_strings_;
}
inline ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* PromptQrCodeScanProto::mutable_image_picker_ui_strings() {
  ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* _msg = _internal_mutable_image_picker_ui_strings();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptQrCodeScanProto.image_picker_ui_strings)
  return _msg;
}
inline void PromptQrCodeScanProto::set_allocated_image_picker_ui_strings(::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings* image_picker_ui_strings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_picker_ui_strings_;
  }
  if (image_picker_ui_strings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_picker_ui_strings);
    if (message_arena != submessage_arena) {
      image_picker_ui_strings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_picker_ui_strings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  image_picker_ui_strings_ = image_picker_ui_strings;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptQrCodeScanProto.image_picker_ui_strings)
}

// -------------------------------------------------------------------

// TellProto_TextToSpeech

// optional string tts_message = 1;
inline bool TellProto_TextToSpeech::_internal_has_tts_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TellProto_TextToSpeech::has_tts_message() const {
  return _internal_has_tts_message();
}
inline void TellProto_TextToSpeech::clear_tts_message() {
  tts_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TellProto_TextToSpeech::tts_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TellProto.TextToSpeech.tts_message)
  return _internal_tts_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TellProto_TextToSpeech::set_tts_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tts_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TellProto.TextToSpeech.tts_message)
}
inline std::string* TellProto_TextToSpeech::mutable_tts_message() {
  std::string* _s = _internal_mutable_tts_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TellProto.TextToSpeech.tts_message)
  return _s;
}
inline const std::string& TellProto_TextToSpeech::_internal_tts_message() const {
  return tts_message_.Get();
}
inline void TellProto_TextToSpeech::_internal_set_tts_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tts_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TellProto_TextToSpeech::_internal_mutable_tts_message() {
  _has_bits_[0] |= 0x00000001u;
  return tts_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TellProto_TextToSpeech::release_tts_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TellProto.TextToSpeech.tts_message)
  if (!_internal_has_tts_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tts_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tts_message_.IsDefault()) {
    tts_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TellProto_TextToSpeech::set_allocated_tts_message(std::string* tts_message) {
  if (tts_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tts_message_.SetAllocated(tts_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tts_message_.IsDefault()) {
    tts_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TellProto.TextToSpeech.tts_message)
}

// optional bool play_now = 2;
inline bool TellProto_TextToSpeech::_internal_has_play_now() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TellProto_TextToSpeech::has_play_now() const {
  return _internal_has_play_now();
}
inline void TellProto_TextToSpeech::clear_play_now() {
  play_now_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TellProto_TextToSpeech::_internal_play_now() const {
  return play_now_;
}
inline bool TellProto_TextToSpeech::play_now() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TellProto.TextToSpeech.play_now)
  return _internal_play_now();
}
inline void TellProto_TextToSpeech::_internal_set_play_now(bool value) {
  _has_bits_[0] |= 0x00000002u;
  play_now_ = value;
}
inline void TellProto_TextToSpeech::set_play_now(bool value) {
  _internal_set_play_now(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TellProto.TextToSpeech.play_now)
}

// -------------------------------------------------------------------

// TellProto

// optional string message = 1;
inline bool TellProto::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TellProto::has_message() const {
  return _internal_has_message();
}
inline void TellProto::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TellProto::message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TellProto.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TellProto::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TellProto.message)
}
inline std::string* TellProto::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TellProto.message)
  return _s;
}
inline const std::string& TellProto::_internal_message() const {
  return message_.Get();
}
inline void TellProto::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(value, GetArenaForAllocation());
}
inline std::string* TellProto::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(GetArenaForAllocation());
}
inline std::string* TellProto::release_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TellProto.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TellProto::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TellProto.message)
}

// optional bool needs_ui = 2 [default = true];
inline bool TellProto::_internal_has_needs_ui() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TellProto::has_needs_ui() const {
  return _internal_has_needs_ui();
}
inline void TellProto::clear_needs_ui() {
  needs_ui_ = true;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TellProto::_internal_needs_ui() const {
  return needs_ui_;
}
inline bool TellProto::needs_ui() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TellProto.needs_ui)
  return _internal_needs_ui();
}
inline void TellProto::_internal_set_needs_ui(bool value) {
  _has_bits_[0] |= 0x00000004u;
  needs_ui_ = value;
}
inline void TellProto::set_needs_ui(bool value) {
  _internal_set_needs_ui(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TellProto.needs_ui)
}

// optional .autofill_assistant.TellProto.TextToSpeech text_to_speech = 3;
inline bool TellProto::_internal_has_text_to_speech() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || text_to_speech_ != nullptr);
  return value;
}
inline bool TellProto::has_text_to_speech() const {
  return _internal_has_text_to_speech();
}
inline void TellProto::clear_text_to_speech() {
  if (text_to_speech_ != nullptr) text_to_speech_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::TellProto_TextToSpeech& TellProto::_internal_text_to_speech() const {
  const ::autofill_assistant::TellProto_TextToSpeech* p = text_to_speech_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TellProto_TextToSpeech&>(
      ::autofill_assistant::_TellProto_TextToSpeech_default_instance_);
}
inline const ::autofill_assistant::TellProto_TextToSpeech& TellProto::text_to_speech() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TellProto.text_to_speech)
  return _internal_text_to_speech();
}
inline void TellProto::unsafe_arena_set_allocated_text_to_speech(
    ::autofill_assistant::TellProto_TextToSpeech* text_to_speech) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_to_speech_);
  }
  text_to_speech_ = text_to_speech;
  if (text_to_speech) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.TellProto.text_to_speech)
}
inline ::autofill_assistant::TellProto_TextToSpeech* TellProto::release_text_to_speech() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TellProto_TextToSpeech* temp = text_to_speech_;
  text_to_speech_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TellProto_TextToSpeech* TellProto::unsafe_arena_release_text_to_speech() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TellProto.text_to_speech)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TellProto_TextToSpeech* temp = text_to_speech_;
  text_to_speech_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TellProto_TextToSpeech* TellProto::_internal_mutable_text_to_speech() {
  _has_bits_[0] |= 0x00000002u;
  if (text_to_speech_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TellProto_TextToSpeech>(GetArenaForAllocation());
    text_to_speech_ = p;
  }
  return text_to_speech_;
}
inline ::autofill_assistant::TellProto_TextToSpeech* TellProto::mutable_text_to_speech() {
  ::autofill_assistant::TellProto_TextToSpeech* _msg = _internal_mutable_text_to_speech();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TellProto.text_to_speech)
  return _msg;
}
inline void TellProto::set_allocated_text_to_speech(::autofill_assistant::TellProto_TextToSpeech* text_to_speech) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_to_speech_;
  }
  if (text_to_speech) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_to_speech);
    if (message_arena != submessage_arena) {
      text_to_speech = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_to_speech, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_to_speech_ = text_to_speech;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TellProto.text_to_speech)
}

// -------------------------------------------------------------------

// ShowCastProto_TopPadding

// int32 pixels = 1;
inline bool ShowCastProto_TopPadding::_internal_has_pixels() const {
  return top_padding_case() == kPixels;
}
inline bool ShowCastProto_TopPadding::has_pixels() const {
  return _internal_has_pixels();
}
inline void ShowCastProto_TopPadding::set_has_pixels() {
  _oneof_case_[0] = kPixels;
}
inline void ShowCastProto_TopPadding::clear_pixels() {
  if (_internal_has_pixels()) {
    top_padding_.pixels_ = 0;
    clear_has_top_padding();
  }
}
inline int32_t ShowCastProto_TopPadding::_internal_pixels() const {
  if (_internal_has_pixels()) {
    return top_padding_.pixels_;
  }
  return 0;
}
inline void ShowCastProto_TopPadding::_internal_set_pixels(int32_t value) {
  if (!_internal_has_pixels()) {
    clear_top_padding();
    set_has_pixels();
  }
  top_padding_.pixels_ = value;
}
inline int32_t ShowCastProto_TopPadding::pixels() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.TopPadding.pixels)
  return _internal_pixels();
}
inline void ShowCastProto_TopPadding::set_pixels(int32_t value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowCastProto.TopPadding.pixels)
}

// float ratio = 2;
inline bool ShowCastProto_TopPadding::_internal_has_ratio() const {
  return top_padding_case() == kRatio;
}
inline bool ShowCastProto_TopPadding::has_ratio() const {
  return _internal_has_ratio();
}
inline void ShowCastProto_TopPadding::set_has_ratio() {
  _oneof_case_[0] = kRatio;
}
inline void ShowCastProto_TopPadding::clear_ratio() {
  if (_internal_has_ratio()) {
    top_padding_.ratio_ = 0;
    clear_has_top_padding();
  }
}
inline float ShowCastProto_TopPadding::_internal_ratio() const {
  if (_internal_has_ratio()) {
    return top_padding_.ratio_;
  }
  return 0;
}
inline void ShowCastProto_TopPadding::_internal_set_ratio(float value) {
  if (!_internal_has_ratio()) {
    clear_top_padding();
    set_has_ratio();
  }
  top_padding_.ratio_ = value;
}
inline float ShowCastProto_TopPadding::ratio() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.TopPadding.ratio)
  return _internal_ratio();
}
inline void ShowCastProto_TopPadding::set_ratio(float value) {
  _internal_set_ratio(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowCastProto.TopPadding.ratio)
}

inline bool ShowCastProto_TopPadding::has_top_padding() const {
  return top_padding_case() != TOP_PADDING_NOT_SET;
}
inline void ShowCastProto_TopPadding::clear_has_top_padding() {
  _oneof_case_[0] = TOP_PADDING_NOT_SET;
}
inline ShowCastProto_TopPadding::TopPaddingCase ShowCastProto_TopPadding::top_padding_case() const {
  return ShowCastProto_TopPadding::TopPaddingCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShowCastProto

// optional .autofill_assistant.SelectorProto element_to_present = 1;
inline bool ShowCastProto::_internal_has_element_to_present() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || element_to_present_ != nullptr);
  return value;
}
inline bool ShowCastProto::has_element_to_present() const {
  return _internal_has_element_to_present();
}
inline void ShowCastProto::clear_element_to_present() {
  if (element_to_present_ != nullptr) element_to_present_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& ShowCastProto::_internal_element_to_present() const {
  const ::autofill_assistant::SelectorProto* p = element_to_present_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& ShowCastProto::element_to_present() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.element_to_present)
  return _internal_element_to_present();
}
inline void ShowCastProto::unsafe_arena_set_allocated_element_to_present(
    ::autofill_assistant::SelectorProto* element_to_present) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_to_present_);
  }
  element_to_present_ = element_to_present;
  if (element_to_present) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowCastProto.element_to_present)
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::release_element_to_present() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = element_to_present_;
  element_to_present_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::unsafe_arena_release_element_to_present() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCastProto.element_to_present)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = element_to_present_;
  element_to_present_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::_internal_mutable_element_to_present() {
  _has_bits_[0] |= 0x00000001u;
  if (element_to_present_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    element_to_present_ = p;
  }
  return element_to_present_;
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::mutable_element_to_present() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_element_to_present();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCastProto.element_to_present)
  return _msg;
}
inline void ShowCastProto::set_allocated_element_to_present(::autofill_assistant::SelectorProto* element_to_present) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_to_present_;
  }
  if (element_to_present) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element_to_present);
    if (message_arena != submessage_arena) {
      element_to_present = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element_to_present, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  element_to_present_ = element_to_present;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCastProto.element_to_present)
}

// optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;
inline bool ShowCastProto::_internal_has_touchable_element_area() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || touchable_element_area_ != nullptr);
  return value;
}
inline bool ShowCastProto::has_touchable_element_area() const {
  return _internal_has_touchable_element_area();
}
inline void ShowCastProto::clear_touchable_element_area() {
  if (touchable_element_area_ != nullptr) touchable_element_area_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ElementAreaProto& ShowCastProto::_internal_touchable_element_area() const {
  const ::autofill_assistant::ElementAreaProto* p = touchable_element_area_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementAreaProto&>(
      ::autofill_assistant::_ElementAreaProto_default_instance_);
}
inline const ::autofill_assistant::ElementAreaProto& ShowCastProto::touchable_element_area() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.touchable_element_area)
  return _internal_touchable_element_area();
}
inline void ShowCastProto::unsafe_arena_set_allocated_touchable_element_area(
    ::autofill_assistant::ElementAreaProto* touchable_element_area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(touchable_element_area_);
  }
  touchable_element_area_ = touchable_element_area;
  if (touchable_element_area) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowCastProto.touchable_element_area)
}
inline ::autofill_assistant::ElementAreaProto* ShowCastProto::release_touchable_element_area() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ElementAreaProto* temp = touchable_element_area_;
  touchable_element_area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementAreaProto* ShowCastProto::unsafe_arena_release_touchable_element_area() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCastProto.touchable_element_area)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ElementAreaProto* temp = touchable_element_area_;
  touchable_element_area_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementAreaProto* ShowCastProto::_internal_mutable_touchable_element_area() {
  _has_bits_[0] |= 0x00000002u;
  if (touchable_element_area_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementAreaProto>(GetArenaForAllocation());
    touchable_element_area_ = p;
  }
  return touchable_element_area_;
}
inline ::autofill_assistant::ElementAreaProto* ShowCastProto::mutable_touchable_element_area() {
  ::autofill_assistant::ElementAreaProto* _msg = _internal_mutable_touchable_element_area();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCastProto.touchable_element_area)
  return _msg;
}
inline void ShowCastProto::set_allocated_touchable_element_area(::autofill_assistant::ElementAreaProto* touchable_element_area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete touchable_element_area_;
  }
  if (touchable_element_area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(touchable_element_area);
    if (message_arena != submessage_arena) {
      touchable_element_area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, touchable_element_area, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  touchable_element_area_ = touchable_element_area;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCastProto.touchable_element_area)
}

// optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;
inline bool ShowCastProto::_internal_has_top_padding() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || top_padding_ != nullptr);
  return value;
}
inline bool ShowCastProto::has_top_padding() const {
  return _internal_has_top_padding();
}
inline void ShowCastProto::clear_top_padding() {
  if (top_padding_ != nullptr) top_padding_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ShowCastProto_TopPadding& ShowCastProto::_internal_top_padding() const {
  const ::autofill_assistant::ShowCastProto_TopPadding* p = top_padding_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ShowCastProto_TopPadding&>(
      ::autofill_assistant::_ShowCastProto_TopPadding_default_instance_);
}
inline const ::autofill_assistant::ShowCastProto_TopPadding& ShowCastProto::top_padding() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.top_padding)
  return _internal_top_padding();
}
inline void ShowCastProto::unsafe_arena_set_allocated_top_padding(
    ::autofill_assistant::ShowCastProto_TopPadding* top_padding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_padding_);
  }
  top_padding_ = top_padding;
  if (top_padding) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowCastProto.top_padding)
}
inline ::autofill_assistant::ShowCastProto_TopPadding* ShowCastProto::release_top_padding() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ShowCastProto_TopPadding* temp = top_padding_;
  top_padding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ShowCastProto_TopPadding* ShowCastProto::unsafe_arena_release_top_padding() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCastProto.top_padding)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ShowCastProto_TopPadding* temp = top_padding_;
  top_padding_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ShowCastProto_TopPadding* ShowCastProto::_internal_mutable_top_padding() {
  _has_bits_[0] |= 0x00000004u;
  if (top_padding_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ShowCastProto_TopPadding>(GetArenaForAllocation());
    top_padding_ = p;
  }
  return top_padding_;
}
inline ::autofill_assistant::ShowCastProto_TopPadding* ShowCastProto::mutable_top_padding() {
  ::autofill_assistant::ShowCastProto_TopPadding* _msg = _internal_mutable_top_padding();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCastProto.top_padding)
  return _msg;
}
inline void ShowCastProto::set_allocated_top_padding(::autofill_assistant::ShowCastProto_TopPadding* top_padding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete top_padding_;
  }
  if (top_padding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(top_padding);
    if (message_arena != submessage_arena) {
      top_padding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top_padding, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  top_padding_ = top_padding;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCastProto.top_padding)
}

// optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;
inline bool ShowCastProto::_internal_has_wait_for_stable_element() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShowCastProto::has_wait_for_stable_element() const {
  return _internal_has_wait_for_stable_element();
}
inline void ShowCastProto::clear_wait_for_stable_element() {
  wait_for_stable_element_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::autofill_assistant::OptionalStep ShowCastProto::_internal_wait_for_stable_element() const {
  return static_cast< ::autofill_assistant::OptionalStep >(wait_for_stable_element_);
}
inline ::autofill_assistant::OptionalStep ShowCastProto::wait_for_stable_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.wait_for_stable_element)
  return _internal_wait_for_stable_element();
}
inline void ShowCastProto::_internal_set_wait_for_stable_element(::autofill_assistant::OptionalStep value) {
  assert(::autofill_assistant::OptionalStep_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  wait_for_stable_element_ = value;
}
inline void ShowCastProto::set_wait_for_stable_element(::autofill_assistant::OptionalStep value) {
  _internal_set_wait_for_stable_element(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowCastProto.wait_for_stable_element)
}

// optional int32 stable_check_max_rounds = 10 [default = 50];
inline bool ShowCastProto::_internal_has_stable_check_max_rounds() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShowCastProto::has_stable_check_max_rounds() const {
  return _internal_has_stable_check_max_rounds();
}
inline void ShowCastProto::clear_stable_check_max_rounds() {
  stable_check_max_rounds_ = 50;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ShowCastProto::_internal_stable_check_max_rounds() const {
  return stable_check_max_rounds_;
}
inline int32_t ShowCastProto::stable_check_max_rounds() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.stable_check_max_rounds)
  return _internal_stable_check_max_rounds();
}
inline void ShowCastProto::_internal_set_stable_check_max_rounds(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  stable_check_max_rounds_ = value;
}
inline void ShowCastProto::set_stable_check_max_rounds(int32_t value) {
  _internal_set_stable_check_max_rounds(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowCastProto.stable_check_max_rounds)
}

// optional int32 stable_check_interval_ms = 11 [default = 200];
inline bool ShowCastProto::_internal_has_stable_check_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShowCastProto::has_stable_check_interval_ms() const {
  return _internal_has_stable_check_interval_ms();
}
inline void ShowCastProto::clear_stable_check_interval_ms() {
  stable_check_interval_ms_ = 200;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ShowCastProto::_internal_stable_check_interval_ms() const {
  return stable_check_interval_ms_;
}
inline int32_t ShowCastProto::stable_check_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.stable_check_interval_ms)
  return _internal_stable_check_interval_ms();
}
inline void ShowCastProto::_internal_set_stable_check_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  stable_check_interval_ms_ = value;
}
inline void ShowCastProto::set_stable_check_interval_ms(int32_t value) {
  _internal_set_stable_check_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowCastProto.stable_check_interval_ms)
}

// optional .autofill_assistant.SelectorProto container = 12;
inline bool ShowCastProto::_internal_has_container() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || container_ != nullptr);
  return value;
}
inline bool ShowCastProto::has_container() const {
  return _internal_has_container();
}
inline void ShowCastProto::clear_container() {
  if (container_ != nullptr) container_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::SelectorProto& ShowCastProto::_internal_container() const {
  const ::autofill_assistant::SelectorProto* p = container_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& ShowCastProto::container() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowCastProto.container)
  return _internal_container();
}
inline void ShowCastProto::unsafe_arena_set_allocated_container(
    ::autofill_assistant::SelectorProto* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container_);
  }
  container_ = container;
  if (container) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowCastProto.container)
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::release_container() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::SelectorProto* temp = container_;
  container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowCastProto.container)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::SelectorProto* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::_internal_mutable_container() {
  _has_bits_[0] |= 0x00000008u;
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    container_ = p;
  }
  return container_;
}
inline ::autofill_assistant::SelectorProto* ShowCastProto::mutable_container() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowCastProto.container)
  return _msg;
}
inline void ShowCastProto::set_allocated_container(::autofill_assistant::SelectorProto* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(container);
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowCastProto.container)
}

// -------------------------------------------------------------------

// SetTouchableAreaProto

// optional .autofill_assistant.ElementAreaProto element_area = 1;
inline bool SetTouchableAreaProto::_internal_has_element_area() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || element_area_ != nullptr);
  return value;
}
inline bool SetTouchableAreaProto::has_element_area() const {
  return _internal_has_element_area();
}
inline void SetTouchableAreaProto::clear_element_area() {
  if (element_area_ != nullptr) element_area_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ElementAreaProto& SetTouchableAreaProto::_internal_element_area() const {
  const ::autofill_assistant::ElementAreaProto* p = element_area_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementAreaProto&>(
      ::autofill_assistant::_ElementAreaProto_default_instance_);
}
inline const ::autofill_assistant::ElementAreaProto& SetTouchableAreaProto::element_area() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetTouchableAreaProto.element_area)
  return _internal_element_area();
}
inline void SetTouchableAreaProto::unsafe_arena_set_allocated_element_area(
    ::autofill_assistant::ElementAreaProto* element_area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_area_);
  }
  element_area_ = element_area;
  if (element_area) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetTouchableAreaProto.element_area)
}
inline ::autofill_assistant::ElementAreaProto* SetTouchableAreaProto::release_element_area() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementAreaProto* temp = element_area_;
  element_area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementAreaProto* SetTouchableAreaProto::unsafe_arena_release_element_area() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetTouchableAreaProto.element_area)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementAreaProto* temp = element_area_;
  element_area_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementAreaProto* SetTouchableAreaProto::_internal_mutable_element_area() {
  _has_bits_[0] |= 0x00000001u;
  if (element_area_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementAreaProto>(GetArenaForAllocation());
    element_area_ = p;
  }
  return element_area_;
}
inline ::autofill_assistant::ElementAreaProto* SetTouchableAreaProto::mutable_element_area() {
  ::autofill_assistant::ElementAreaProto* _msg = _internal_mutable_element_area();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetTouchableAreaProto.element_area)
  return _msg;
}
inline void SetTouchableAreaProto::set_allocated_element_area(::autofill_assistant::ElementAreaProto* element_area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_area_;
  }
  if (element_area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element_area);
    if (message_arena != submessage_arena) {
      element_area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element_area, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  element_area_ = element_area;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetTouchableAreaProto.element_area)
}

// -------------------------------------------------------------------

// ElementAreaProto_Rectangle

// repeated .autofill_assistant.SelectorProto elements = 1;
inline int ElementAreaProto_Rectangle::_internal_elements_size() const {
  return elements_.size();
}
inline int ElementAreaProto_Rectangle::elements_size() const {
  return _internal_elements_size();
}
inline void ElementAreaProto_Rectangle::clear_elements() {
  elements_.Clear();
}
inline ::autofill_assistant::SelectorProto* ElementAreaProto_Rectangle::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementAreaProto.Rectangle.elements)
  return elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto >*
ElementAreaProto_Rectangle::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ElementAreaProto.Rectangle.elements)
  return &elements_;
}
inline const ::autofill_assistant::SelectorProto& ElementAreaProto_Rectangle::_internal_elements(int index) const {
  return elements_.Get(index);
}
inline const ::autofill_assistant::SelectorProto& ElementAreaProto_Rectangle::elements(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementAreaProto.Rectangle.elements)
  return _internal_elements(index);
}
inline ::autofill_assistant::SelectorProto* ElementAreaProto_Rectangle::_internal_add_elements() {
  return elements_.Add();
}
inline ::autofill_assistant::SelectorProto* ElementAreaProto_Rectangle::add_elements() {
  ::autofill_assistant::SelectorProto* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:autofill_assistant.ElementAreaProto.Rectangle.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectorProto >&
ElementAreaProto_Rectangle::elements() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ElementAreaProto.Rectangle.elements)
  return elements_;
}

// optional bool full_width = 2;
inline bool ElementAreaProto_Rectangle::_internal_has_full_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElementAreaProto_Rectangle::has_full_width() const {
  return _internal_has_full_width();
}
inline void ElementAreaProto_Rectangle::clear_full_width() {
  full_width_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ElementAreaProto_Rectangle::_internal_full_width() const {
  return full_width_;
}
inline bool ElementAreaProto_Rectangle::full_width() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementAreaProto.Rectangle.full_width)
  return _internal_full_width();
}
inline void ElementAreaProto_Rectangle::_internal_set_full_width(bool value) {
  _has_bits_[0] |= 0x00000001u;
  full_width_ = value;
}
inline void ElementAreaProto_Rectangle::set_full_width(bool value) {
  _internal_set_full_width(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementAreaProto.Rectangle.full_width)
}

// -------------------------------------------------------------------

// ElementAreaProto

// repeated .autofill_assistant.ElementAreaProto.Rectangle touchable = 1;
inline int ElementAreaProto::_internal_touchable_size() const {
  return touchable_.size();
}
inline int ElementAreaProto::touchable_size() const {
  return _internal_touchable_size();
}
inline void ElementAreaProto::clear_touchable() {
  touchable_.Clear();
}
inline ::autofill_assistant::ElementAreaProto_Rectangle* ElementAreaProto::mutable_touchable(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementAreaProto.touchable)
  return touchable_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >*
ElementAreaProto::mutable_touchable() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ElementAreaProto.touchable)
  return &touchable_;
}
inline const ::autofill_assistant::ElementAreaProto_Rectangle& ElementAreaProto::_internal_touchable(int index) const {
  return touchable_.Get(index);
}
inline const ::autofill_assistant::ElementAreaProto_Rectangle& ElementAreaProto::touchable(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementAreaProto.touchable)
  return _internal_touchable(index);
}
inline ::autofill_assistant::ElementAreaProto_Rectangle* ElementAreaProto::_internal_add_touchable() {
  return touchable_.Add();
}
inline ::autofill_assistant::ElementAreaProto_Rectangle* ElementAreaProto::add_touchable() {
  ::autofill_assistant::ElementAreaProto_Rectangle* _add = _internal_add_touchable();
  // @@protoc_insertion_point(field_add:autofill_assistant.ElementAreaProto.touchable)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >&
ElementAreaProto::touchable() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ElementAreaProto.touchable)
  return touchable_;
}

// repeated .autofill_assistant.ElementAreaProto.Rectangle restricted = 2;
inline int ElementAreaProto::_internal_restricted_size() const {
  return restricted_.size();
}
inline int ElementAreaProto::restricted_size() const {
  return _internal_restricted_size();
}
inline void ElementAreaProto::clear_restricted() {
  restricted_.Clear();
}
inline ::autofill_assistant::ElementAreaProto_Rectangle* ElementAreaProto::mutable_restricted(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementAreaProto.restricted)
  return restricted_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >*
ElementAreaProto::mutable_restricted() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ElementAreaProto.restricted)
  return &restricted_;
}
inline const ::autofill_assistant::ElementAreaProto_Rectangle& ElementAreaProto::_internal_restricted(int index) const {
  return restricted_.Get(index);
}
inline const ::autofill_assistant::ElementAreaProto_Rectangle& ElementAreaProto::restricted(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementAreaProto.restricted)
  return _internal_restricted(index);
}
inline ::autofill_assistant::ElementAreaProto_Rectangle* ElementAreaProto::_internal_add_restricted() {
  return restricted_.Add();
}
inline ::autofill_assistant::ElementAreaProto_Rectangle* ElementAreaProto::add_restricted() {
  ::autofill_assistant::ElementAreaProto_Rectangle* _add = _internal_add_restricted();
  // @@protoc_insertion_point(field_add:autofill_assistant.ElementAreaProto.restricted)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementAreaProto_Rectangle >&
ElementAreaProto::restricted() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ElementAreaProto.restricted)
  return restricted_;
}

// -------------------------------------------------------------------

// RequiredFieldProto

// optional .autofill_assistant.ValueExpression value_expression = 12;
inline bool RequiredFieldProto::_internal_has_value_expression() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || value_expression_ != nullptr);
  return value;
}
inline bool RequiredFieldProto::has_value_expression() const {
  return _internal_has_value_expression();
}
inline const ::autofill_assistant::ValueExpression& RequiredFieldProto::_internal_value_expression() const {
  const ::autofill_assistant::ValueExpression* p = value_expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueExpression&>(
      ::autofill_assistant::_ValueExpression_default_instance_);
}
inline const ::autofill_assistant::ValueExpression& RequiredFieldProto::value_expression() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.value_expression)
  return _internal_value_expression();
}
inline void RequiredFieldProto::unsafe_arena_set_allocated_value_expression(
    ::autofill_assistant::ValueExpression* value_expression) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_);
  }
  value_expression_ = value_expression;
  if (value_expression) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.RequiredFieldProto.value_expression)
}
inline ::autofill_assistant::ValueExpression* RequiredFieldProto::release_value_expression() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueExpression* RequiredFieldProto::unsafe_arena_release_value_expression() {
  // @@protoc_insertion_point(field_release:autofill_assistant.RequiredFieldProto.value_expression)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ValueExpression* temp = value_expression_;
  value_expression_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueExpression* RequiredFieldProto::_internal_mutable_value_expression() {
  _has_bits_[0] |= 0x00000004u;
  if (value_expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueExpression>(GetArenaForAllocation());
    value_expression_ = p;
  }
  return value_expression_;
}
inline ::autofill_assistant::ValueExpression* RequiredFieldProto::mutable_value_expression() {
  ::autofill_assistant::ValueExpression* _msg = _internal_mutable_value_expression();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.RequiredFieldProto.value_expression)
  return _msg;
}
inline void RequiredFieldProto::set_allocated_value_expression(::autofill_assistant::ValueExpression* value_expression) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression_);
  }
  if (value_expression) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_expression));
    if (message_arena != submessage_arena) {
      value_expression = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value_expression, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  value_expression_ = value_expression;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.RequiredFieldProto.value_expression)
}

// optional .autofill_assistant.SelectorProto element = 2;
inline bool RequiredFieldProto::_internal_has_element() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || element_ != nullptr);
  return value;
}
inline bool RequiredFieldProto::has_element() const {
  return _internal_has_element();
}
inline void RequiredFieldProto::clear_element() {
  if (element_ != nullptr) element_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& RequiredFieldProto::_internal_element() const {
  const ::autofill_assistant::SelectorProto* p = element_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& RequiredFieldProto::element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.element)
  return _internal_element();
}
inline void RequiredFieldProto::unsafe_arena_set_allocated_element(
    ::autofill_assistant::SelectorProto* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_);
  }
  element_ = element;
  if (element) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.RequiredFieldProto.element)
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::release_element() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.RequiredFieldProto.element)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::_internal_mutable_element() {
  _has_bits_[0] |= 0x00000001u;
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    element_ = p;
  }
  return element_;
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::mutable_element() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.RequiredFieldProto.element)
  return _msg;
}
inline void RequiredFieldProto::set_allocated_element(::autofill_assistant::SelectorProto* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.RequiredFieldProto.element)
}

// optional .autofill_assistant.KeyboardValueFillStrategy fill_strategy = 7;
inline bool RequiredFieldProto::_internal_has_fill_strategy() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_fill_strategy() const {
  return _internal_has_fill_strategy();
}
inline void RequiredFieldProto::clear_fill_strategy() {
  fill_strategy_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::autofill_assistant::KeyboardValueFillStrategy RequiredFieldProto::_internal_fill_strategy() const {
  return static_cast< ::autofill_assistant::KeyboardValueFillStrategy >(fill_strategy_);
}
inline ::autofill_assistant::KeyboardValueFillStrategy RequiredFieldProto::fill_strategy() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.fill_strategy)
  return _internal_fill_strategy();
}
inline void RequiredFieldProto::_internal_set_fill_strategy(::autofill_assistant::KeyboardValueFillStrategy value) {
  assert(::autofill_assistant::KeyboardValueFillStrategy_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  fill_strategy_ = value;
}
inline void RequiredFieldProto::set_fill_strategy(::autofill_assistant::KeyboardValueFillStrategy value) {
  _internal_set_fill_strategy(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.fill_strategy)
}

// optional int32 delay_in_millisecond = 4 [default = 20];
inline bool RequiredFieldProto::_internal_has_delay_in_millisecond() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_delay_in_millisecond() const {
  return _internal_has_delay_in_millisecond();
}
inline void RequiredFieldProto::clear_delay_in_millisecond() {
  delay_in_millisecond_ = 20;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t RequiredFieldProto::_internal_delay_in_millisecond() const {
  return delay_in_millisecond_;
}
inline int32_t RequiredFieldProto::delay_in_millisecond() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.delay_in_millisecond)
  return _internal_delay_in_millisecond();
}
inline void RequiredFieldProto::_internal_set_delay_in_millisecond(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  delay_in_millisecond_ = value;
}
inline void RequiredFieldProto::set_delay_in_millisecond(int32_t value) {
  _internal_set_delay_in_millisecond(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.delay_in_millisecond)
}

// optional .autofill_assistant.DropdownSelectStrategy select_strategy = 8;
inline bool RequiredFieldProto::_internal_has_select_strategy() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_select_strategy() const {
  return _internal_has_select_strategy();
}
inline void RequiredFieldProto::clear_select_strategy() {
  select_strategy_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::autofill_assistant::DropdownSelectStrategy RequiredFieldProto::_internal_select_strategy() const {
  return static_cast< ::autofill_assistant::DropdownSelectStrategy >(select_strategy_);
}
inline ::autofill_assistant::DropdownSelectStrategy RequiredFieldProto::select_strategy() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.select_strategy)
  return _internal_select_strategy();
}
inline void RequiredFieldProto::_internal_set_select_strategy(::autofill_assistant::DropdownSelectStrategy value) {
  assert(::autofill_assistant::DropdownSelectStrategy_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  select_strategy_ = value;
}
inline void RequiredFieldProto::set_select_strategy(::autofill_assistant::DropdownSelectStrategy value) {
  _internal_set_select_strategy(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.select_strategy)
}

// optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 13;
inline bool RequiredFieldProto::_internal_has_option_comparison_attribute() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_option_comparison_attribute() const {
  return _internal_has_option_comparison_attribute();
}
inline void RequiredFieldProto::clear_option_comparison_attribute() {
  option_comparison_attribute_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute RequiredFieldProto::_internal_option_comparison_attribute() const {
  return static_cast< ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute >(option_comparison_attribute_);
}
inline ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute RequiredFieldProto::option_comparison_attribute() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.option_comparison_attribute)
  return _internal_option_comparison_attribute();
}
inline void RequiredFieldProto::_internal_set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value) {
  assert(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  option_comparison_attribute_ = value;
}
inline void RequiredFieldProto::set_option_comparison_attribute(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute value) {
  _internal_set_option_comparison_attribute(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.option_comparison_attribute)
}

// optional .autofill_assistant.ValueExpressionRegexp option_comparison_value_expression_re2 = 14;
inline bool RequiredFieldProto::_internal_has_option_comparison_value_expression_re2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || option_comparison_value_expression_re2_ != nullptr);
  return value;
}
inline bool RequiredFieldProto::has_option_comparison_value_expression_re2() const {
  return _internal_has_option_comparison_value_expression_re2();
}
inline const ::autofill_assistant::ValueExpressionRegexp& RequiredFieldProto::_internal_option_comparison_value_expression_re2() const {
  const ::autofill_assistant::ValueExpressionRegexp* p = option_comparison_value_expression_re2_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ValueExpressionRegexp&>(
      ::autofill_assistant::_ValueExpressionRegexp_default_instance_);
}
inline const ::autofill_assistant::ValueExpressionRegexp& RequiredFieldProto::option_comparison_value_expression_re2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.option_comparison_value_expression_re2)
  return _internal_option_comparison_value_expression_re2();
}
inline void RequiredFieldProto::unsafe_arena_set_allocated_option_comparison_value_expression_re2(
    ::autofill_assistant::ValueExpressionRegexp* option_comparison_value_expression_re2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(option_comparison_value_expression_re2_);
  }
  option_comparison_value_expression_re2_ = option_comparison_value_expression_re2;
  if (option_comparison_value_expression_re2) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.RequiredFieldProto.option_comparison_value_expression_re2)
}
inline ::autofill_assistant::ValueExpressionRegexp* RequiredFieldProto::release_option_comparison_value_expression_re2() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ValueExpressionRegexp* temp = option_comparison_value_expression_re2_;
  option_comparison_value_expression_re2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ValueExpressionRegexp* RequiredFieldProto::unsafe_arena_release_option_comparison_value_expression_re2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.RequiredFieldProto.option_comparison_value_expression_re2)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ValueExpressionRegexp* temp = option_comparison_value_expression_re2_;
  option_comparison_value_expression_re2_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ValueExpressionRegexp* RequiredFieldProto::_internal_mutable_option_comparison_value_expression_re2() {
  _has_bits_[0] |= 0x00000008u;
  if (option_comparison_value_expression_re2_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ValueExpressionRegexp>(GetArenaForAllocation());
    option_comparison_value_expression_re2_ = p;
  }
  return option_comparison_value_expression_re2_;
}
inline ::autofill_assistant::ValueExpressionRegexp* RequiredFieldProto::mutable_option_comparison_value_expression_re2() {
  ::autofill_assistant::ValueExpressionRegexp* _msg = _internal_mutable_option_comparison_value_expression_re2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.RequiredFieldProto.option_comparison_value_expression_re2)
  return _msg;
}
inline void RequiredFieldProto::set_allocated_option_comparison_value_expression_re2(::autofill_assistant::ValueExpressionRegexp* option_comparison_value_expression_re2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(option_comparison_value_expression_re2_);
  }
  if (option_comparison_value_expression_re2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(option_comparison_value_expression_re2));
    if (message_arena != submessage_arena) {
      option_comparison_value_expression_re2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, option_comparison_value_expression_re2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  option_comparison_value_expression_re2_ = option_comparison_value_expression_re2;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.RequiredFieldProto.option_comparison_value_expression_re2)
}

// optional bool forced = 5;
inline bool RequiredFieldProto::_internal_has_forced() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_forced() const {
  return _internal_has_forced();
}
inline void RequiredFieldProto::clear_forced() {
  forced_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool RequiredFieldProto::_internal_forced() const {
  return forced_;
}
inline bool RequiredFieldProto::forced() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.forced)
  return _internal_forced();
}
inline void RequiredFieldProto::_internal_set_forced(bool value) {
  _has_bits_[0] |= 0x00000040u;
  forced_ = value;
}
inline void RequiredFieldProto::set_forced(bool value) {
  _internal_set_forced(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.forced)
}

// optional bool is_optional = 11;
inline bool RequiredFieldProto::_internal_has_is_optional() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_is_optional() const {
  return _internal_has_is_optional();
}
inline void RequiredFieldProto::clear_is_optional() {
  is_optional_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool RequiredFieldProto::_internal_is_optional() const {
  return is_optional_;
}
inline bool RequiredFieldProto::is_optional() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.is_optional)
  return _internal_is_optional();
}
inline void RequiredFieldProto::_internal_set_is_optional(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_optional_ = value;
}
inline void RequiredFieldProto::set_is_optional(bool value) {
  _internal_set_is_optional(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.is_optional)
}

// optional .autofill_assistant.SelectorProto option_element_to_click = 9;
inline bool RequiredFieldProto::_internal_has_option_element_to_click() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || option_element_to_click_ != nullptr);
  return value;
}
inline bool RequiredFieldProto::has_option_element_to_click() const {
  return _internal_has_option_element_to_click();
}
inline void RequiredFieldProto::clear_option_element_to_click() {
  if (option_element_to_click_ != nullptr) option_element_to_click_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::SelectorProto& RequiredFieldProto::_internal_option_element_to_click() const {
  const ::autofill_assistant::SelectorProto* p = option_element_to_click_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& RequiredFieldProto::option_element_to_click() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.option_element_to_click)
  return _internal_option_element_to_click();
}
inline void RequiredFieldProto::unsafe_arena_set_allocated_option_element_to_click(
    ::autofill_assistant::SelectorProto* option_element_to_click) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(option_element_to_click_);
  }
  option_element_to_click_ = option_element_to_click;
  if (option_element_to_click) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.RequiredFieldProto.option_element_to_click)
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::release_option_element_to_click() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = option_element_to_click_;
  option_element_to_click_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::unsafe_arena_release_option_element_to_click() {
  // @@protoc_insertion_point(field_release:autofill_assistant.RequiredFieldProto.option_element_to_click)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = option_element_to_click_;
  option_element_to_click_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::_internal_mutable_option_element_to_click() {
  _has_bits_[0] |= 0x00000002u;
  if (option_element_to_click_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    option_element_to_click_ = p;
  }
  return option_element_to_click_;
}
inline ::autofill_assistant::SelectorProto* RequiredFieldProto::mutable_option_element_to_click() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_option_element_to_click();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.RequiredFieldProto.option_element_to_click)
  return _msg;
}
inline void RequiredFieldProto::set_allocated_option_element_to_click(::autofill_assistant::SelectorProto* option_element_to_click) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete option_element_to_click_;
  }
  if (option_element_to_click) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(option_element_to_click);
    if (message_arena != submessage_arena) {
      option_element_to_click = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, option_element_to_click, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  option_element_to_click_ = option_element_to_click;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.RequiredFieldProto.option_element_to_click)
}

// optional .autofill_assistant.ClickType click_type = 10;
inline bool RequiredFieldProto::_internal_has_click_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RequiredFieldProto::has_click_type() const {
  return _internal_has_click_type();
}
inline void RequiredFieldProto::clear_click_type() {
  click_type_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::autofill_assistant::ClickType RequiredFieldProto::_internal_click_type() const {
  return static_cast< ::autofill_assistant::ClickType >(click_type_);
}
inline ::autofill_assistant::ClickType RequiredFieldProto::click_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.RequiredFieldProto.click_type)
  return _internal_click_type();
}
inline void RequiredFieldProto::_internal_set_click_type(::autofill_assistant::ClickType value) {
  assert(::autofill_assistant::ClickType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  click_type_ = value;
}
inline void RequiredFieldProto::set_click_type(::autofill_assistant::ClickType value) {
  _internal_set_click_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.RequiredFieldProto.click_type)
}

// -------------------------------------------------------------------

// UseAddressProto

// string name = 1;
inline bool UseAddressProto::_internal_has_name() const {
  return address_source_case() == kName;
}
inline bool UseAddressProto::has_name() const {
  return _internal_has_name();
}
inline void UseAddressProto::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void UseAddressProto::clear_name() {
  if (_internal_has_name()) {
    address_source_.name_.Destroy();
    clear_has_address_source();
  }
}
inline const std::string& UseAddressProto::name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseAddressProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline void UseAddressProto::set_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_name()) {
    clear_address_source();
    set_has_name();
    address_source_.name_.InitDefault();
  }
  address_source_.name_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UseAddressProto.name)
}
inline std::string* UseAddressProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseAddressProto.name)
  return _s;
}
inline const std::string& UseAddressProto::_internal_name() const {
  if (_internal_has_name()) {
    return address_source_.name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UseAddressProto::_internal_set_name(const std::string& value) {
  if (!_internal_has_name()) {
    clear_address_source();
    set_has_name();
    address_source_.name_.InitDefault();
  }
  address_source_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UseAddressProto::_internal_mutable_name() {
  if (!_internal_has_name()) {
    clear_address_source();
    set_has_name();
    address_source_.name_.InitDefault();
  }
  return address_source_.name_.Mutable(      GetArenaForAllocation());
}
inline std::string* UseAddressProto::release_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UseAddressProto.name)
  if (_internal_has_name()) {
    clear_has_address_source();
    return address_source_.name_.Release();
  } else {
    return nullptr;
  }
}
inline void UseAddressProto::set_allocated_name(std::string* name) {
  if (has_address_source()) {
    clear_address_source();
  }
  if (name != nullptr) {
    set_has_name();
    address_source_.name_.InitAllocated(name, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UseAddressProto.name)
}

// string model_identifier = 9;
inline bool UseAddressProto::_internal_has_model_identifier() const {
  return address_source_case() == kModelIdentifier;
}
inline bool UseAddressProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void UseAddressProto::set_has_model_identifier() {
  _oneof_case_[0] = kModelIdentifier;
}
inline void UseAddressProto::clear_model_identifier() {
  if (_internal_has_model_identifier()) {
    address_source_.model_identifier_.Destroy();
    clear_has_address_source();
  }
}
inline const std::string& UseAddressProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseAddressProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline void UseAddressProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_model_identifier()) {
    clear_address_source();
    set_has_model_identifier();
    address_source_.model_identifier_.InitDefault();
  }
  address_source_.model_identifier_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UseAddressProto.model_identifier)
}
inline std::string* UseAddressProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseAddressProto.model_identifier)
  return _s;
}
inline const std::string& UseAddressProto::_internal_model_identifier() const {
  if (_internal_has_model_identifier()) {
    return address_source_.model_identifier_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UseAddressProto::_internal_set_model_identifier(const std::string& value) {
  if (!_internal_has_model_identifier()) {
    clear_address_source();
    set_has_model_identifier();
    address_source_.model_identifier_.InitDefault();
  }
  address_source_.model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* UseAddressProto::_internal_mutable_model_identifier() {
  if (!_internal_has_model_identifier()) {
    clear_address_source();
    set_has_model_identifier();
    address_source_.model_identifier_.InitDefault();
  }
  return address_source_.model_identifier_.Mutable(      GetArenaForAllocation());
}
inline std::string* UseAddressProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UseAddressProto.model_identifier)
  if (_internal_has_model_identifier()) {
    clear_has_address_source();
    return address_source_.model_identifier_.Release();
  } else {
    return nullptr;
  }
}
inline void UseAddressProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (has_address_source()) {
    clear_address_source();
  }
  if (model_identifier != nullptr) {
    set_has_model_identifier();
    address_source_.model_identifier_.InitAllocated(model_identifier, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UseAddressProto.model_identifier)
}

// optional .autofill_assistant.SelectorProto form_field_element = 4;
inline bool UseAddressProto::_internal_has_form_field_element() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || form_field_element_ != nullptr);
  return value;
}
inline bool UseAddressProto::has_form_field_element() const {
  return _internal_has_form_field_element();
}
inline void UseAddressProto::clear_form_field_element() {
  if (form_field_element_ != nullptr) form_field_element_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& UseAddressProto::_internal_form_field_element() const {
  const ::autofill_assistant::SelectorProto* p = form_field_element_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& UseAddressProto::form_field_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseAddressProto.form_field_element)
  return _internal_form_field_element();
}
inline void UseAddressProto::unsafe_arena_set_allocated_form_field_element(
    ::autofill_assistant::SelectorProto* form_field_element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(form_field_element_);
  }
  form_field_element_ = form_field_element;
  if (form_field_element) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UseAddressProto.form_field_element)
}
inline ::autofill_assistant::SelectorProto* UseAddressProto::release_form_field_element() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = form_field_element_;
  form_field_element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* UseAddressProto::unsafe_arena_release_form_field_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UseAddressProto.form_field_element)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = form_field_element_;
  form_field_element_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* UseAddressProto::_internal_mutable_form_field_element() {
  _has_bits_[0] |= 0x00000001u;
  if (form_field_element_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    form_field_element_ = p;
  }
  return form_field_element_;
}
inline ::autofill_assistant::SelectorProto* UseAddressProto::mutable_form_field_element() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_form_field_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseAddressProto.form_field_element)
  return _msg;
}
inline void UseAddressProto::set_allocated_form_field_element(::autofill_assistant::SelectorProto* form_field_element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete form_field_element_;
  }
  if (form_field_element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(form_field_element);
    if (message_arena != submessage_arena) {
      form_field_element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form_field_element, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  form_field_element_ = form_field_element;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UseAddressProto.form_field_element)
}

// repeated .autofill_assistant.RequiredFieldProto required_fields = 6;
inline int UseAddressProto::_internal_required_fields_size() const {
  return required_fields_.size();
}
inline int UseAddressProto::required_fields_size() const {
  return _internal_required_fields_size();
}
inline void UseAddressProto::clear_required_fields() {
  required_fields_.Clear();
}
inline ::autofill_assistant::RequiredFieldProto* UseAddressProto::mutable_required_fields(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseAddressProto.required_fields)
  return required_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >*
UseAddressProto::mutable_required_fields() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UseAddressProto.required_fields)
  return &required_fields_;
}
inline const ::autofill_assistant::RequiredFieldProto& UseAddressProto::_internal_required_fields(int index) const {
  return required_fields_.Get(index);
}
inline const ::autofill_assistant::RequiredFieldProto& UseAddressProto::required_fields(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseAddressProto.required_fields)
  return _internal_required_fields(index);
}
inline ::autofill_assistant::RequiredFieldProto* UseAddressProto::_internal_add_required_fields() {
  return required_fields_.Add();
}
inline ::autofill_assistant::RequiredFieldProto* UseAddressProto::add_required_fields() {
  ::autofill_assistant::RequiredFieldProto* _add = _internal_add_required_fields();
  // @@protoc_insertion_point(field_add:autofill_assistant.UseAddressProto.required_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >&
UseAddressProto::required_fields() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UseAddressProto.required_fields)
  return required_fields_;
}

// optional bool skip_autofill = 10;
inline bool UseAddressProto::_internal_has_skip_autofill() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UseAddressProto::has_skip_autofill() const {
  return _internal_has_skip_autofill();
}
inline void UseAddressProto::clear_skip_autofill() {
  skip_autofill_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UseAddressProto::_internal_skip_autofill() const {
  return skip_autofill_;
}
inline bool UseAddressProto::skip_autofill() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseAddressProto.skip_autofill)
  return _internal_skip_autofill();
}
inline void UseAddressProto::_internal_set_skip_autofill(bool value) {
  _has_bits_[0] |= 0x00000002u;
  skip_autofill_ = value;
}
inline void UseAddressProto::set_skip_autofill(bool value) {
  _internal_set_skip_autofill(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UseAddressProto.skip_autofill)
}

inline bool UseAddressProto::has_address_source() const {
  return address_source_case() != ADDRESS_SOURCE_NOT_SET;
}
inline void UseAddressProto::clear_has_address_source() {
  _oneof_case_[0] = ADDRESS_SOURCE_NOT_SET;
}
inline UseAddressProto::AddressSourceCase UseAddressProto::address_source_case() const {
  return UseAddressProto::AddressSourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UseCreditCardProto

// optional string model_identifier = 4;
inline bool UseCreditCardProto::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseCreditCardProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void UseCreditCardProto::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UseCreditCardProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseCreditCardProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UseCreditCardProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UseCreditCardProto.model_identifier)
}
inline std::string* UseCreditCardProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseCreditCardProto.model_identifier)
  return _s;
}
inline const std::string& UseCreditCardProto::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void UseCreditCardProto::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* UseCreditCardProto::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* UseCreditCardProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UseCreditCardProto.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UseCreditCardProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UseCreditCardProto.model_identifier)
}

// optional .autofill_assistant.SelectorProto form_field_element = 3;
inline bool UseCreditCardProto::_internal_has_form_field_element() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || form_field_element_ != nullptr);
  return value;
}
inline bool UseCreditCardProto::has_form_field_element() const {
  return _internal_has_form_field_element();
}
inline void UseCreditCardProto::clear_form_field_element() {
  if (form_field_element_ != nullptr) form_field_element_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::SelectorProto& UseCreditCardProto::_internal_form_field_element() const {
  const ::autofill_assistant::SelectorProto* p = form_field_element_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& UseCreditCardProto::form_field_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseCreditCardProto.form_field_element)
  return _internal_form_field_element();
}
inline void UseCreditCardProto::unsafe_arena_set_allocated_form_field_element(
    ::autofill_assistant::SelectorProto* form_field_element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(form_field_element_);
  }
  form_field_element_ = form_field_element;
  if (form_field_element) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UseCreditCardProto.form_field_element)
}
inline ::autofill_assistant::SelectorProto* UseCreditCardProto::release_form_field_element() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = form_field_element_;
  form_field_element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* UseCreditCardProto::unsafe_arena_release_form_field_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UseCreditCardProto.form_field_element)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = form_field_element_;
  form_field_element_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* UseCreditCardProto::_internal_mutable_form_field_element() {
  _has_bits_[0] |= 0x00000002u;
  if (form_field_element_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    form_field_element_ = p;
  }
  return form_field_element_;
}
inline ::autofill_assistant::SelectorProto* UseCreditCardProto::mutable_form_field_element() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_form_field_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseCreditCardProto.form_field_element)
  return _msg;
}
inline void UseCreditCardProto::set_allocated_form_field_element(::autofill_assistant::SelectorProto* form_field_element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete form_field_element_;
  }
  if (form_field_element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(form_field_element);
    if (message_arena != submessage_arena) {
      form_field_element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form_field_element, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  form_field_element_ = form_field_element;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UseCreditCardProto.form_field_element)
}

// repeated .autofill_assistant.RequiredFieldProto required_fields = 7;
inline int UseCreditCardProto::_internal_required_fields_size() const {
  return required_fields_.size();
}
inline int UseCreditCardProto::required_fields_size() const {
  return _internal_required_fields_size();
}
inline void UseCreditCardProto::clear_required_fields() {
  required_fields_.Clear();
}
inline ::autofill_assistant::RequiredFieldProto* UseCreditCardProto::mutable_required_fields(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UseCreditCardProto.required_fields)
  return required_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >*
UseCreditCardProto::mutable_required_fields() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UseCreditCardProto.required_fields)
  return &required_fields_;
}
inline const ::autofill_assistant::RequiredFieldProto& UseCreditCardProto::_internal_required_fields(int index) const {
  return required_fields_.Get(index);
}
inline const ::autofill_assistant::RequiredFieldProto& UseCreditCardProto::required_fields(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseCreditCardProto.required_fields)
  return _internal_required_fields(index);
}
inline ::autofill_assistant::RequiredFieldProto* UseCreditCardProto::_internal_add_required_fields() {
  return required_fields_.Add();
}
inline ::autofill_assistant::RequiredFieldProto* UseCreditCardProto::add_required_fields() {
  ::autofill_assistant::RequiredFieldProto* _add = _internal_add_required_fields();
  // @@protoc_insertion_point(field_add:autofill_assistant.UseCreditCardProto.required_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredFieldProto >&
UseCreditCardProto::required_fields() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UseCreditCardProto.required_fields)
  return required_fields_;
}

// optional bool skip_autofill = 8;
inline bool UseCreditCardProto::_internal_has_skip_autofill() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UseCreditCardProto::has_skip_autofill() const {
  return _internal_has_skip_autofill();
}
inline void UseCreditCardProto::clear_skip_autofill() {
  skip_autofill_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool UseCreditCardProto::_internal_skip_autofill() const {
  return skip_autofill_;
}
inline bool UseCreditCardProto::skip_autofill() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseCreditCardProto.skip_autofill)
  return _internal_skip_autofill();
}
inline void UseCreditCardProto::_internal_set_skip_autofill(bool value) {
  _has_bits_[0] |= 0x00000004u;
  skip_autofill_ = value;
}
inline void UseCreditCardProto::set_skip_autofill(bool value) {
  _internal_set_skip_autofill(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UseCreditCardProto.skip_autofill)
}

// optional bool skip_resolve = 9;
inline bool UseCreditCardProto::_internal_has_skip_resolve() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UseCreditCardProto::has_skip_resolve() const {
  return _internal_has_skip_resolve();
}
inline void UseCreditCardProto::clear_skip_resolve() {
  skip_resolve_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool UseCreditCardProto::_internal_skip_resolve() const {
  return skip_resolve_;
}
inline bool UseCreditCardProto::skip_resolve() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UseCreditCardProto.skip_resolve)
  return _internal_skip_resolve();
}
inline void UseCreditCardProto::_internal_set_skip_resolve(bool value) {
  _has_bits_[0] |= 0x00000008u;
  skip_resolve_ = value;
}
inline void UseCreditCardProto::set_skip_resolve(bool value) {
  _internal_set_skip_resolve(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UseCreditCardProto.skip_resolve)
}

// -------------------------------------------------------------------

// WaitForDomProto_Result

// repeated bytes matching_condition_payloads = 1;
inline int WaitForDomProto_Result::_internal_matching_condition_payloads_size() const {
  return matching_condition_payloads_.size();
}
inline int WaitForDomProto_Result::matching_condition_payloads_size() const {
  return _internal_matching_condition_payloads_size();
}
inline void WaitForDomProto_Result::clear_matching_condition_payloads() {
  matching_condition_payloads_.Clear();
}
inline std::string* WaitForDomProto_Result::add_matching_condition_payloads() {
  std::string* _s = _internal_add_matching_condition_payloads();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
  return _s;
}
inline const std::string& WaitForDomProto_Result::_internal_matching_condition_payloads(int index) const {
  return matching_condition_payloads_.Get(index);
}
inline const std::string& WaitForDomProto_Result::matching_condition_payloads(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
  return _internal_matching_condition_payloads(index);
}
inline std::string* WaitForDomProto_Result::mutable_matching_condition_payloads(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
  return matching_condition_payloads_.Mutable(index);
}
inline void WaitForDomProto_Result::set_matching_condition_payloads(int index, const std::string& value) {
  matching_condition_payloads_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline void WaitForDomProto_Result::set_matching_condition_payloads(int index, std::string&& value) {
  matching_condition_payloads_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline void WaitForDomProto_Result::set_matching_condition_payloads(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  matching_condition_payloads_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline void WaitForDomProto_Result::set_matching_condition_payloads(int index, const void* value, size_t size) {
  matching_condition_payloads_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline std::string* WaitForDomProto_Result::_internal_add_matching_condition_payloads() {
  return matching_condition_payloads_.Add();
}
inline void WaitForDomProto_Result::add_matching_condition_payloads(const std::string& value) {
  matching_condition_payloads_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline void WaitForDomProto_Result::add_matching_condition_payloads(std::string&& value) {
  matching_condition_payloads_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline void WaitForDomProto_Result::add_matching_condition_payloads(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  matching_condition_payloads_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline void WaitForDomProto_Result::add_matching_condition_payloads(const void* value, size_t size) {
  matching_condition_payloads_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WaitForDomProto_Result::matching_condition_payloads() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
  return matching_condition_payloads_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WaitForDomProto_Result::mutable_matching_condition_payloads() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.WaitForDomProto.Result.matching_condition_payloads)
  return &matching_condition_payloads_;
}

// repeated string matching_condition_tags = 2;
inline int WaitForDomProto_Result::_internal_matching_condition_tags_size() const {
  return matching_condition_tags_.size();
}
inline int WaitForDomProto_Result::matching_condition_tags_size() const {
  return _internal_matching_condition_tags_size();
}
inline void WaitForDomProto_Result::clear_matching_condition_tags() {
  matching_condition_tags_.Clear();
}
inline std::string* WaitForDomProto_Result::add_matching_condition_tags() {
  std::string* _s = _internal_add_matching_condition_tags();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
  return _s;
}
inline const std::string& WaitForDomProto_Result::_internal_matching_condition_tags(int index) const {
  return matching_condition_tags_.Get(index);
}
inline const std::string& WaitForDomProto_Result::matching_condition_tags(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
  return _internal_matching_condition_tags(index);
}
inline std::string* WaitForDomProto_Result::mutable_matching_condition_tags(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
  return matching_condition_tags_.Mutable(index);
}
inline void WaitForDomProto_Result::set_matching_condition_tags(int index, const std::string& value) {
  matching_condition_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline void WaitForDomProto_Result::set_matching_condition_tags(int index, std::string&& value) {
  matching_condition_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline void WaitForDomProto_Result::set_matching_condition_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  matching_condition_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline void WaitForDomProto_Result::set_matching_condition_tags(int index, const char* value, size_t size) {
  matching_condition_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline std::string* WaitForDomProto_Result::_internal_add_matching_condition_tags() {
  return matching_condition_tags_.Add();
}
inline void WaitForDomProto_Result::add_matching_condition_tags(const std::string& value) {
  matching_condition_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline void WaitForDomProto_Result::add_matching_condition_tags(std::string&& value) {
  matching_condition_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline void WaitForDomProto_Result::add_matching_condition_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  matching_condition_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline void WaitForDomProto_Result::add_matching_condition_tags(const char* value, size_t size) {
  matching_condition_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WaitForDomProto_Result::matching_condition_tags() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
  return matching_condition_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WaitForDomProto_Result::mutable_matching_condition_tags() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.WaitForDomProto.Result.matching_condition_tags)
  return &matching_condition_tags_;
}

// -------------------------------------------------------------------

// WaitForDomProto

// optional int32 timeout_ms = 1;
inline bool WaitForDomProto::_internal_has_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitForDomProto::has_timeout_ms() const {
  return _internal_has_timeout_ms();
}
inline void WaitForDomProto::clear_timeout_ms() {
  timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t WaitForDomProto::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline int32_t WaitForDomProto::timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDomProto.timeout_ms)
  return _internal_timeout_ms();
}
inline void WaitForDomProto::_internal_set_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timeout_ms_ = value;
}
inline void WaitForDomProto::set_timeout_ms(int32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDomProto.timeout_ms)
}

// optional .autofill_assistant.ElementConditionProto wait_condition = 9;
inline bool WaitForDomProto::_internal_has_wait_condition() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || wait_condition_ != nullptr);
  return value;
}
inline bool WaitForDomProto::has_wait_condition() const {
  return _internal_has_wait_condition();
}
inline void WaitForDomProto::clear_wait_condition() {
  if (wait_condition_ != nullptr) wait_condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ElementConditionProto& WaitForDomProto::_internal_wait_condition() const {
  const ::autofill_assistant::ElementConditionProto* p = wait_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementConditionProto&>(
      ::autofill_assistant::_ElementConditionProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionProto& WaitForDomProto::wait_condition() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDomProto.wait_condition)
  return _internal_wait_condition();
}
inline void WaitForDomProto::unsafe_arena_set_allocated_wait_condition(
    ::autofill_assistant::ElementConditionProto* wait_condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wait_condition_);
  }
  wait_condition_ = wait_condition;
  if (wait_condition) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.WaitForDomProto.wait_condition)
}
inline ::autofill_assistant::ElementConditionProto* WaitForDomProto::release_wait_condition() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementConditionProto* temp = wait_condition_;
  wait_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* WaitForDomProto::unsafe_arena_release_wait_condition() {
  // @@protoc_insertion_point(field_release:autofill_assistant.WaitForDomProto.wait_condition)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementConditionProto* temp = wait_condition_;
  wait_condition_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* WaitForDomProto::_internal_mutable_wait_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (wait_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(GetArenaForAllocation());
    wait_condition_ = p;
  }
  return wait_condition_;
}
inline ::autofill_assistant::ElementConditionProto* WaitForDomProto::mutable_wait_condition() {
  ::autofill_assistant::ElementConditionProto* _msg = _internal_mutable_wait_condition();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForDomProto.wait_condition)
  return _msg;
}
inline void WaitForDomProto::set_allocated_wait_condition(::autofill_assistant::ElementConditionProto* wait_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete wait_condition_;
  }
  if (wait_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_condition);
    if (message_arena != submessage_arena) {
      wait_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  wait_condition_ = wait_condition;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.WaitForDomProto.wait_condition)
}

// optional bool allow_interrupt = 3;
inline bool WaitForDomProto::_internal_has_allow_interrupt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WaitForDomProto::has_allow_interrupt() const {
  return _internal_has_allow_interrupt();
}
inline void WaitForDomProto::clear_allow_interrupt() {
  allow_interrupt_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool WaitForDomProto::_internal_allow_interrupt() const {
  return allow_interrupt_;
}
inline bool WaitForDomProto::allow_interrupt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDomProto.allow_interrupt)
  return _internal_allow_interrupt();
}
inline void WaitForDomProto::_internal_set_allow_interrupt(bool value) {
  _has_bits_[0] |= 0x00000004u;
  allow_interrupt_ = value;
}
inline void WaitForDomProto::set_allow_interrupt(bool value) {
  _internal_set_allow_interrupt(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDomProto.allow_interrupt)
}

// -------------------------------------------------------------------

// ElementConditionProto

// .autofill_assistant.ElementConditionsProto all_of = 1;
inline bool ElementConditionProto::_internal_has_all_of() const {
  return type_case() == kAllOf;
}
inline bool ElementConditionProto::has_all_of() const {
  return _internal_has_all_of();
}
inline void ElementConditionProto::set_has_all_of() {
  _oneof_case_[0] = kAllOf;
}
inline void ElementConditionProto::clear_all_of() {
  if (_internal_has_all_of()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.all_of_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::release_all_of() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.all_of)
  if (_internal_has_all_of()) {
    clear_has_type();
    ::autofill_assistant::ElementConditionsProto* temp = type_.all_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.all_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ElementConditionsProto& ElementConditionProto::_internal_all_of() const {
  return _internal_has_all_of()
      ? *type_.all_of_
      : reinterpret_cast< ::autofill_assistant::ElementConditionsProto&>(::autofill_assistant::_ElementConditionsProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionsProto& ElementConditionProto::all_of() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.all_of)
  return _internal_all_of();
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::unsafe_arena_release_all_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ElementConditionProto.all_of)
  if (_internal_has_all_of()) {
    clear_has_type();
    ::autofill_assistant::ElementConditionsProto* temp = type_.all_of_;
    type_.all_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ElementConditionProto::unsafe_arena_set_allocated_all_of(::autofill_assistant::ElementConditionsProto* all_of) {
  clear_type();
  if (all_of) {
    set_has_all_of();
    type_.all_of_ = all_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementConditionProto.all_of)
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::_internal_mutable_all_of() {
  if (!_internal_has_all_of()) {
    clear_type();
    set_has_all_of();
    type_.all_of_ = CreateMaybeMessage< ::autofill_assistant::ElementConditionsProto >(GetArenaForAllocation());
  }
  return type_.all_of_;
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::mutable_all_of() {
  ::autofill_assistant::ElementConditionsProto* _msg = _internal_mutable_all_of();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.all_of)
  return _msg;
}

// .autofill_assistant.ElementConditionsProto any_of = 2;
inline bool ElementConditionProto::_internal_has_any_of() const {
  return type_case() == kAnyOf;
}
inline bool ElementConditionProto::has_any_of() const {
  return _internal_has_any_of();
}
inline void ElementConditionProto::set_has_any_of() {
  _oneof_case_[0] = kAnyOf;
}
inline void ElementConditionProto::clear_any_of() {
  if (_internal_has_any_of()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.any_of_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::release_any_of() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.any_of)
  if (_internal_has_any_of()) {
    clear_has_type();
    ::autofill_assistant::ElementConditionsProto* temp = type_.any_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.any_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ElementConditionsProto& ElementConditionProto::_internal_any_of() const {
  return _internal_has_any_of()
      ? *type_.any_of_
      : reinterpret_cast< ::autofill_assistant::ElementConditionsProto&>(::autofill_assistant::_ElementConditionsProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionsProto& ElementConditionProto::any_of() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.any_of)
  return _internal_any_of();
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::unsafe_arena_release_any_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ElementConditionProto.any_of)
  if (_internal_has_any_of()) {
    clear_has_type();
    ::autofill_assistant::ElementConditionsProto* temp = type_.any_of_;
    type_.any_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ElementConditionProto::unsafe_arena_set_allocated_any_of(::autofill_assistant::ElementConditionsProto* any_of) {
  clear_type();
  if (any_of) {
    set_has_any_of();
    type_.any_of_ = any_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementConditionProto.any_of)
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::_internal_mutable_any_of() {
  if (!_internal_has_any_of()) {
    clear_type();
    set_has_any_of();
    type_.any_of_ = CreateMaybeMessage< ::autofill_assistant::ElementConditionsProto >(GetArenaForAllocation());
  }
  return type_.any_of_;
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::mutable_any_of() {
  ::autofill_assistant::ElementConditionsProto* _msg = _internal_mutable_any_of();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.any_of)
  return _msg;
}

// .autofill_assistant.ElementConditionsProto none_of = 3;
inline bool ElementConditionProto::_internal_has_none_of() const {
  return type_case() == kNoneOf;
}
inline bool ElementConditionProto::has_none_of() const {
  return _internal_has_none_of();
}
inline void ElementConditionProto::set_has_none_of() {
  _oneof_case_[0] = kNoneOf;
}
inline void ElementConditionProto::clear_none_of() {
  if (_internal_has_none_of()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.none_of_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::release_none_of() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.none_of)
  if (_internal_has_none_of()) {
    clear_has_type();
    ::autofill_assistant::ElementConditionsProto* temp = type_.none_of_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.none_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ElementConditionsProto& ElementConditionProto::_internal_none_of() const {
  return _internal_has_none_of()
      ? *type_.none_of_
      : reinterpret_cast< ::autofill_assistant::ElementConditionsProto&>(::autofill_assistant::_ElementConditionsProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionsProto& ElementConditionProto::none_of() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.none_of)
  return _internal_none_of();
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::unsafe_arena_release_none_of() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ElementConditionProto.none_of)
  if (_internal_has_none_of()) {
    clear_has_type();
    ::autofill_assistant::ElementConditionsProto* temp = type_.none_of_;
    type_.none_of_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ElementConditionProto::unsafe_arena_set_allocated_none_of(::autofill_assistant::ElementConditionsProto* none_of) {
  clear_type();
  if (none_of) {
    set_has_none_of();
    type_.none_of_ = none_of;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementConditionProto.none_of)
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::_internal_mutable_none_of() {
  if (!_internal_has_none_of()) {
    clear_type();
    set_has_none_of();
    type_.none_of_ = CreateMaybeMessage< ::autofill_assistant::ElementConditionsProto >(GetArenaForAllocation());
  }
  return type_.none_of_;
}
inline ::autofill_assistant::ElementConditionsProto* ElementConditionProto::mutable_none_of() {
  ::autofill_assistant::ElementConditionsProto* _msg = _internal_mutable_none_of();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.none_of)
  return _msg;
}

// .autofill_assistant.SelectorProto match = 4;
inline bool ElementConditionProto::_internal_has_match() const {
  return type_case() == kMatch;
}
inline bool ElementConditionProto::has_match() const {
  return _internal_has_match();
}
inline void ElementConditionProto::set_has_match() {
  _oneof_case_[0] = kMatch;
}
inline void ElementConditionProto::clear_match() {
  if (_internal_has_match()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.match_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::SelectorProto* ElementConditionProto::release_match() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.match)
  if (_internal_has_match()) {
    clear_has_type();
    ::autofill_assistant::SelectorProto* temp = type_.match_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto& ElementConditionProto::_internal_match() const {
  return _internal_has_match()
      ? *type_.match_
      : reinterpret_cast< ::autofill_assistant::SelectorProto&>(::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& ElementConditionProto::match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.match)
  return _internal_match();
}
inline ::autofill_assistant::SelectorProto* ElementConditionProto::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ElementConditionProto.match)
  if (_internal_has_match()) {
    clear_has_type();
    ::autofill_assistant::SelectorProto* temp = type_.match_;
    type_.match_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ElementConditionProto::unsafe_arena_set_allocated_match(::autofill_assistant::SelectorProto* match) {
  clear_type();
  if (match) {
    set_has_match();
    type_.match_ = match;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementConditionProto.match)
}
inline ::autofill_assistant::SelectorProto* ElementConditionProto::_internal_mutable_match() {
  if (!_internal_has_match()) {
    clear_type();
    set_has_match();
    type_.match_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto >(GetArenaForAllocation());
  }
  return type_.match_;
}
inline ::autofill_assistant::SelectorProto* ElementConditionProto::mutable_match() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.match)
  return _msg;
}

// optional bytes payload = 5;
inline bool ElementConditionProto::_internal_has_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElementConditionProto::has_payload() const {
  return _internal_has_payload();
}
inline void ElementConditionProto::clear_payload() {
  payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ElementConditionProto::payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ElementConditionProto::set_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementConditionProto.payload)
}
inline std::string* ElementConditionProto::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.payload)
  return _s;
}
inline const std::string& ElementConditionProto::_internal_payload() const {
  return payload_.Get();
}
inline void ElementConditionProto::_internal_set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ElementConditionProto::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000001u;
  return payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ElementConditionProto::release_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault()) {
    payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ElementConditionProto::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault()) {
    payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.payload)
}

// optional string tag = 8;
inline bool ElementConditionProto::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ElementConditionProto::has_tag() const {
  return _internal_has_tag();
}
inline void ElementConditionProto::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ElementConditionProto::tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ElementConditionProto::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementConditionProto.tag)
}
inline std::string* ElementConditionProto::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.tag)
  return _s;
}
inline const std::string& ElementConditionProto::_internal_tag() const {
  return tag_.Get();
}
inline void ElementConditionProto::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ElementConditionProto::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ElementConditionProto::release_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ElementConditionProto::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.tag)
}

// optional .autofill_assistant.ClientIdProto client_id = 6;
inline bool ElementConditionProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool ElementConditionProto::has_client_id() const {
  return _internal_has_client_id();
}
inline const ::autofill_assistant::ClientIdProto& ElementConditionProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& ElementConditionProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.client_id)
  return _internal_client_id();
}
inline void ElementConditionProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ElementConditionProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* ElementConditionProto::release_client_id() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ElementConditionProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ElementConditionProto.client_id)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ElementConditionProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000004u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* ElementConditionProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionProto.client_id)
  return _msg;
}
inline void ElementConditionProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id));
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.client_id)
}

// optional bool require_unique_element = 7;
inline bool ElementConditionProto::_internal_has_require_unique_element() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ElementConditionProto::has_require_unique_element() const {
  return _internal_has_require_unique_element();
}
inline void ElementConditionProto::clear_require_unique_element() {
  require_unique_element_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ElementConditionProto::_internal_require_unique_element() const {
  return require_unique_element_;
}
inline bool ElementConditionProto::require_unique_element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionProto.require_unique_element)
  return _internal_require_unique_element();
}
inline void ElementConditionProto::_internal_set_require_unique_element(bool value) {
  _has_bits_[0] |= 0x00000008u;
  require_unique_element_ = value;
}
inline void ElementConditionProto::set_require_unique_element(bool value) {
  _internal_set_require_unique_element(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ElementConditionProto.require_unique_element)
}

inline bool ElementConditionProto::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ElementConditionProto::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline ElementConditionProto::TypeCase ElementConditionProto::type_case() const {
  return ElementConditionProto::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ElementConditionsProto

// repeated .autofill_assistant.ElementConditionProto conditions = 1;
inline int ElementConditionsProto::_internal_conditions_size() const {
  return conditions_.size();
}
inline int ElementConditionsProto::conditions_size() const {
  return _internal_conditions_size();
}
inline void ElementConditionsProto::clear_conditions() {
  conditions_.Clear();
}
inline ::autofill_assistant::ElementConditionProto* ElementConditionsProto::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ElementConditionsProto.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementConditionProto >*
ElementConditionsProto::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ElementConditionsProto.conditions)
  return &conditions_;
}
inline const ::autofill_assistant::ElementConditionProto& ElementConditionsProto::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::autofill_assistant::ElementConditionProto& ElementConditionsProto::conditions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ElementConditionsProto.conditions)
  return _internal_conditions(index);
}
inline ::autofill_assistant::ElementConditionProto* ElementConditionsProto::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::autofill_assistant::ElementConditionProto* ElementConditionsProto::add_conditions() {
  ::autofill_assistant::ElementConditionProto* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:autofill_assistant.ElementConditionsProto.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ElementConditionProto >&
ElementConditionsProto::conditions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ElementConditionsProto.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// UploadDomProto_Result

// repeated string outer_htmls = 1;
inline int UploadDomProto_Result::_internal_outer_htmls_size() const {
  return outer_htmls_.size();
}
inline int UploadDomProto_Result::outer_htmls_size() const {
  return _internal_outer_htmls_size();
}
inline void UploadDomProto_Result::clear_outer_htmls() {
  outer_htmls_.Clear();
}
inline std::string* UploadDomProto_Result::add_outer_htmls() {
  std::string* _s = _internal_add_outer_htmls();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.UploadDomProto.Result.outer_htmls)
  return _s;
}
inline const std::string& UploadDomProto_Result::_internal_outer_htmls(int index) const {
  return outer_htmls_.Get(index);
}
inline const std::string& UploadDomProto_Result::outer_htmls(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UploadDomProto.Result.outer_htmls)
  return _internal_outer_htmls(index);
}
inline std::string* UploadDomProto_Result::mutable_outer_htmls(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UploadDomProto.Result.outer_htmls)
  return outer_htmls_.Mutable(index);
}
inline void UploadDomProto_Result::set_outer_htmls(int index, const std::string& value) {
  outer_htmls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline void UploadDomProto_Result::set_outer_htmls(int index, std::string&& value) {
  outer_htmls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline void UploadDomProto_Result::set_outer_htmls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outer_htmls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline void UploadDomProto_Result::set_outer_htmls(int index, const char* value, size_t size) {
  outer_htmls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline std::string* UploadDomProto_Result::_internal_add_outer_htmls() {
  return outer_htmls_.Add();
}
inline void UploadDomProto_Result::add_outer_htmls(const std::string& value) {
  outer_htmls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline void UploadDomProto_Result::add_outer_htmls(std::string&& value) {
  outer_htmls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline void UploadDomProto_Result::add_outer_htmls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  outer_htmls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline void UploadDomProto_Result::add_outer_htmls(const char* value, size_t size) {
  outer_htmls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.UploadDomProto.Result.outer_htmls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UploadDomProto_Result::outer_htmls() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.UploadDomProto.Result.outer_htmls)
  return outer_htmls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UploadDomProto_Result::mutable_outer_htmls() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.UploadDomProto.Result.outer_htmls)
  return &outer_htmls_;
}

// -------------------------------------------------------------------

// UploadDomProto

// optional .autofill_assistant.SelectorProto tree_root = 1;
inline bool UploadDomProto::_internal_has_tree_root() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || tree_root_ != nullptr);
  return value;
}
inline bool UploadDomProto::has_tree_root() const {
  return _internal_has_tree_root();
}
inline void UploadDomProto::clear_tree_root() {
  if (tree_root_ != nullptr) tree_root_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& UploadDomProto::_internal_tree_root() const {
  const ::autofill_assistant::SelectorProto* p = tree_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& UploadDomProto::tree_root() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UploadDomProto.tree_root)
  return _internal_tree_root();
}
inline void UploadDomProto::unsafe_arena_set_allocated_tree_root(
    ::autofill_assistant::SelectorProto* tree_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tree_root_);
  }
  tree_root_ = tree_root;
  if (tree_root) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UploadDomProto.tree_root)
}
inline ::autofill_assistant::SelectorProto* UploadDomProto::release_tree_root() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = tree_root_;
  tree_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* UploadDomProto::unsafe_arena_release_tree_root() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UploadDomProto.tree_root)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = tree_root_;
  tree_root_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* UploadDomProto::_internal_mutable_tree_root() {
  _has_bits_[0] |= 0x00000001u;
  if (tree_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    tree_root_ = p;
  }
  return tree_root_;
}
inline ::autofill_assistant::SelectorProto* UploadDomProto::mutable_tree_root() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_tree_root();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UploadDomProto.tree_root)
  return _msg;
}
inline void UploadDomProto::set_allocated_tree_root(::autofill_assistant::SelectorProto* tree_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tree_root_;
  }
  if (tree_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tree_root);
    if (message_arena != submessage_arena) {
      tree_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree_root, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tree_root_ = tree_root;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UploadDomProto.tree_root)
}

// optional bool can_match_multiple_elements = 2;
inline bool UploadDomProto::_internal_has_can_match_multiple_elements() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UploadDomProto::has_can_match_multiple_elements() const {
  return _internal_has_can_match_multiple_elements();
}
inline void UploadDomProto::clear_can_match_multiple_elements() {
  can_match_multiple_elements_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UploadDomProto::_internal_can_match_multiple_elements() const {
  return can_match_multiple_elements_;
}
inline bool UploadDomProto::can_match_multiple_elements() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UploadDomProto.can_match_multiple_elements)
  return _internal_can_match_multiple_elements();
}
inline void UploadDomProto::_internal_set_can_match_multiple_elements(bool value) {
  _has_bits_[0] |= 0x00000002u;
  can_match_multiple_elements_ = value;
}
inline void UploadDomProto::set_can_match_multiple_elements(bool value) {
  _internal_set_can_match_multiple_elements(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UploadDomProto.can_match_multiple_elements)
}

// optional bool include_all_inner_text = 3;
inline bool UploadDomProto::_internal_has_include_all_inner_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UploadDomProto::has_include_all_inner_text() const {
  return _internal_has_include_all_inner_text();
}
inline void UploadDomProto::clear_include_all_inner_text() {
  include_all_inner_text_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool UploadDomProto::_internal_include_all_inner_text() const {
  return include_all_inner_text_;
}
inline bool UploadDomProto::include_all_inner_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UploadDomProto.include_all_inner_text)
  return _internal_include_all_inner_text();
}
inline void UploadDomProto::_internal_set_include_all_inner_text(bool value) {
  _has_bits_[0] |= 0x00000004u;
  include_all_inner_text_ = value;
}
inline void UploadDomProto::set_include_all_inner_text(bool value) {
  _internal_set_include_all_inner_text(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UploadDomProto.include_all_inner_text)
}

// -------------------------------------------------------------------

// ShowProgressBarProto_StepProgressBarIcon

// optional .autofill_assistant.DrawableProto icon = 1;
inline bool ShowProgressBarProto_StepProgressBarIcon::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || icon_ != nullptr);
  return value;
}
inline bool ShowProgressBarProto_StepProgressBarIcon::has_icon() const {
  return _internal_has_icon();
}
inline const ::autofill_assistant::DrawableProto& ShowProgressBarProto_StepProgressBarIcon::_internal_icon() const {
  const ::autofill_assistant::DrawableProto* p = icon_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DrawableProto&>(
      ::autofill_assistant::_DrawableProto_default_instance_);
}
inline const ::autofill_assistant::DrawableProto& ShowProgressBarProto_StepProgressBarIcon::icon() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.icon)
  return _internal_icon();
}
inline void ShowProgressBarProto_StepProgressBarIcon::unsafe_arena_set_allocated_icon(
    ::autofill_assistant::DrawableProto* icon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(icon_);
  }
  icon_ = icon;
  if (icon) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.icon)
}
inline ::autofill_assistant::DrawableProto* ShowProgressBarProto_StepProgressBarIcon::release_icon() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::DrawableProto* temp = icon_;
  icon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DrawableProto* ShowProgressBarProto_StepProgressBarIcon::unsafe_arena_release_icon() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.icon)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::DrawableProto* temp = icon_;
  icon_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DrawableProto* ShowProgressBarProto_StepProgressBarIcon::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000002u;
  if (icon_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DrawableProto>(GetArenaForAllocation());
    icon_ = p;
  }
  return icon_;
}
inline ::autofill_assistant::DrawableProto* ShowProgressBarProto_StepProgressBarIcon::mutable_icon() {
  ::autofill_assistant::DrawableProto* _msg = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.icon)
  return _msg;
}
inline void ShowProgressBarProto_StepProgressBarIcon::set_allocated_icon(::autofill_assistant::DrawableProto* icon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(icon_);
  }
  if (icon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(icon));
    if (message_arena != submessage_arena) {
      icon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, icon, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  icon_ = icon;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.icon)
}

// optional string identifier = 2;
inline bool ShowProgressBarProto_StepProgressBarIcon::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowProgressBarProto_StepProgressBarIcon::has_identifier() const {
  return _internal_has_identifier();
}
inline void ShowProgressBarProto_StepProgressBarIcon::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowProgressBarProto_StepProgressBarIcon::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowProgressBarProto_StepProgressBarIcon::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.identifier)
}
inline std::string* ShowProgressBarProto_StepProgressBarIcon::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.identifier)
  return _s;
}
inline const std::string& ShowProgressBarProto_StepProgressBarIcon::_internal_identifier() const {
  return identifier_.Get();
}
inline void ShowProgressBarProto_StepProgressBarIcon::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowProgressBarProto_StepProgressBarIcon::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowProgressBarProto_StepProgressBarIcon::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowProgressBarProto_StepProgressBarIcon::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon.identifier)
}

// -------------------------------------------------------------------

// ShowProgressBarProto_StepProgressBarConfiguration

// repeated .autofill_assistant.ShowProgressBarProto.StepProgressBarIcon annotated_step_icons = 3;
inline int ShowProgressBarProto_StepProgressBarConfiguration::_internal_annotated_step_icons_size() const {
  return annotated_step_icons_.size();
}
inline int ShowProgressBarProto_StepProgressBarConfiguration::annotated_step_icons_size() const {
  return _internal_annotated_step_icons_size();
}
inline void ShowProgressBarProto_StepProgressBarConfiguration::clear_annotated_step_icons() {
  annotated_step_icons_.Clear();
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* ShowProgressBarProto_StepProgressBarConfiguration::mutable_annotated_step_icons(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration.annotated_step_icons)
  return annotated_step_icons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon >*
ShowProgressBarProto_StepProgressBarConfiguration::mutable_annotated_step_icons() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration.annotated_step_icons)
  return &annotated_step_icons_;
}
inline const ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon& ShowProgressBarProto_StepProgressBarConfiguration::_internal_annotated_step_icons(int index) const {
  return annotated_step_icons_.Get(index);
}
inline const ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon& ShowProgressBarProto_StepProgressBarConfiguration::annotated_step_icons(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration.annotated_step_icons)
  return _internal_annotated_step_icons(index);
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* ShowProgressBarProto_StepProgressBarConfiguration::_internal_add_annotated_step_icons() {
  return annotated_step_icons_.Add();
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* ShowProgressBarProto_StepProgressBarConfiguration::add_annotated_step_icons() {
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon* _add = _internal_add_annotated_step_icons();
  // @@protoc_insertion_point(field_add:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration.annotated_step_icons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon >&
ShowProgressBarProto_StepProgressBarConfiguration::annotated_step_icons() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration.annotated_step_icons)
  return annotated_step_icons_;
}

// -------------------------------------------------------------------

// ShowProgressBarProto

// int32 active_step = 8;
inline bool ShowProgressBarProto::_internal_has_active_step() const {
  return progress_indicator_case() == kActiveStep;
}
inline bool ShowProgressBarProto::has_active_step() const {
  return _internal_has_active_step();
}
inline void ShowProgressBarProto::set_has_active_step() {
  _oneof_case_[0] = kActiveStep;
}
inline void ShowProgressBarProto::clear_active_step() {
  if (_internal_has_active_step()) {
    progress_indicator_.active_step_ = 0;
    clear_has_progress_indicator();
  }
}
inline int32_t ShowProgressBarProto::_internal_active_step() const {
  if (_internal_has_active_step()) {
    return progress_indicator_.active_step_;
  }
  return 0;
}
inline void ShowProgressBarProto::_internal_set_active_step(int32_t value) {
  if (!_internal_has_active_step()) {
    clear_progress_indicator();
    set_has_active_step();
  }
  progress_indicator_.active_step_ = value;
}
inline int32_t ShowProgressBarProto::active_step() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.active_step)
  return _internal_active_step();
}
inline void ShowProgressBarProto::set_active_step(int32_t value) {
  _internal_set_active_step(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowProgressBarProto.active_step)
}

// string active_step_identifier = 11;
inline bool ShowProgressBarProto::_internal_has_active_step_identifier() const {
  return progress_indicator_case() == kActiveStepIdentifier;
}
inline bool ShowProgressBarProto::has_active_step_identifier() const {
  return _internal_has_active_step_identifier();
}
inline void ShowProgressBarProto::set_has_active_step_identifier() {
  _oneof_case_[0] = kActiveStepIdentifier;
}
inline void ShowProgressBarProto::clear_active_step_identifier() {
  if (_internal_has_active_step_identifier()) {
    progress_indicator_.active_step_identifier_.Destroy();
    clear_has_progress_indicator();
  }
}
inline const std::string& ShowProgressBarProto::active_step_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.active_step_identifier)
  return _internal_active_step_identifier();
}
template <typename ArgT0, typename... ArgT>
inline void ShowProgressBarProto::set_active_step_identifier(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_active_step_identifier()) {
    clear_progress_indicator();
    set_has_active_step_identifier();
    progress_indicator_.active_step_identifier_.InitDefault();
  }
  progress_indicator_.active_step_identifier_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowProgressBarProto.active_step_identifier)
}
inline std::string* ShowProgressBarProto::mutable_active_step_identifier() {
  std::string* _s = _internal_mutable_active_step_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowProgressBarProto.active_step_identifier)
  return _s;
}
inline const std::string& ShowProgressBarProto::_internal_active_step_identifier() const {
  if (_internal_has_active_step_identifier()) {
    return progress_indicator_.active_step_identifier_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ShowProgressBarProto::_internal_set_active_step_identifier(const std::string& value) {
  if (!_internal_has_active_step_identifier()) {
    clear_progress_indicator();
    set_has_active_step_identifier();
    progress_indicator_.active_step_identifier_.InitDefault();
  }
  progress_indicator_.active_step_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowProgressBarProto::_internal_mutable_active_step_identifier() {
  if (!_internal_has_active_step_identifier()) {
    clear_progress_indicator();
    set_has_active_step_identifier();
    progress_indicator_.active_step_identifier_.InitDefault();
  }
  return progress_indicator_.active_step_identifier_.Mutable(      GetArenaForAllocation());
}
inline std::string* ShowProgressBarProto::release_active_step_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowProgressBarProto.active_step_identifier)
  if (_internal_has_active_step_identifier()) {
    clear_has_progress_indicator();
    return progress_indicator_.active_step_identifier_.Release();
  } else {
    return nullptr;
  }
}
inline void ShowProgressBarProto::set_allocated_active_step_identifier(std::string* active_step_identifier) {
  if (has_progress_indicator()) {
    clear_progress_indicator();
  }
  if (active_step_identifier != nullptr) {
    set_has_active_step_identifier();
    progress_indicator_.active_step_identifier_.InitAllocated(active_step_identifier, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowProgressBarProto.active_step_identifier)
}

// bool complete_progress = 12;
inline bool ShowProgressBarProto::_internal_has_complete_progress() const {
  return progress_indicator_case() == kCompleteProgress;
}
inline bool ShowProgressBarProto::has_complete_progress() const {
  return _internal_has_complete_progress();
}
inline void ShowProgressBarProto::set_has_complete_progress() {
  _oneof_case_[0] = kCompleteProgress;
}
inline void ShowProgressBarProto::clear_complete_progress() {
  if (_internal_has_complete_progress()) {
    progress_indicator_.complete_progress_ = false;
    clear_has_progress_indicator();
  }
}
inline bool ShowProgressBarProto::_internal_complete_progress() const {
  if (_internal_has_complete_progress()) {
    return progress_indicator_.complete_progress_;
  }
  return false;
}
inline void ShowProgressBarProto::_internal_set_complete_progress(bool value) {
  if (!_internal_has_complete_progress()) {
    clear_progress_indicator();
    set_has_complete_progress();
  }
  progress_indicator_.complete_progress_ = value;
}
inline bool ShowProgressBarProto::complete_progress() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.complete_progress)
  return _internal_complete_progress();
}
inline void ShowProgressBarProto::set_complete_progress(bool value) {
  _internal_set_complete_progress(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowProgressBarProto.complete_progress)
}

// optional bool error_state = 10;
inline bool ShowProgressBarProto::_internal_has_error_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowProgressBarProto::has_error_state() const {
  return _internal_has_error_state();
}
inline void ShowProgressBarProto::clear_error_state() {
  error_state_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ShowProgressBarProto::_internal_error_state() const {
  return error_state_;
}
inline bool ShowProgressBarProto::error_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.error_state)
  return _internal_error_state();
}
inline void ShowProgressBarProto::_internal_set_error_state(bool value) {
  _has_bits_[0] |= 0x00000002u;
  error_state_ = value;
}
inline void ShowProgressBarProto::set_error_state(bool value) {
  _internal_set_error_state(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowProgressBarProto.error_state)
}

// optional bool hide = 7;
inline bool ShowProgressBarProto::_internal_has_hide() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShowProgressBarProto::has_hide() const {
  return _internal_has_hide();
}
inline void ShowProgressBarProto::clear_hide() {
  hide_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ShowProgressBarProto::_internal_hide() const {
  return hide_;
}
inline bool ShowProgressBarProto::hide() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.hide)
  return _internal_hide();
}
inline void ShowProgressBarProto::_internal_set_hide(bool value) {
  _has_bits_[0] |= 0x00000004u;
  hide_ = value;
}
inline void ShowProgressBarProto::set_hide(bool value) {
  _internal_set_hide(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowProgressBarProto.hide)
}

// optional .autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration step_progress_bar_configuration = 9;
inline bool ShowProgressBarProto::_internal_has_step_progress_bar_configuration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || step_progress_bar_configuration_ != nullptr);
  return value;
}
inline bool ShowProgressBarProto::has_step_progress_bar_configuration() const {
  return _internal_has_step_progress_bar_configuration();
}
inline void ShowProgressBarProto::clear_step_progress_bar_configuration() {
  if (step_progress_bar_configuration_ != nullptr) step_progress_bar_configuration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration& ShowProgressBarProto::_internal_step_progress_bar_configuration() const {
  const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* p = step_progress_bar_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration&>(
      ::autofill_assistant::_ShowProgressBarProto_StepProgressBarConfiguration_default_instance_);
}
inline const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration& ShowProgressBarProto::step_progress_bar_configuration() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowProgressBarProto.step_progress_bar_configuration)
  return _internal_step_progress_bar_configuration();
}
inline void ShowProgressBarProto::unsafe_arena_set_allocated_step_progress_bar_configuration(
    ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* step_progress_bar_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_progress_bar_configuration_);
  }
  step_progress_bar_configuration_ = step_progress_bar_configuration;
  if (step_progress_bar_configuration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowProgressBarProto.step_progress_bar_configuration)
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* ShowProgressBarProto::release_step_progress_bar_configuration() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* temp = step_progress_bar_configuration_;
  step_progress_bar_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* ShowProgressBarProto::unsafe_arena_release_step_progress_bar_configuration() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowProgressBarProto.step_progress_bar_configuration)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* temp = step_progress_bar_configuration_;
  step_progress_bar_configuration_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* ShowProgressBarProto::_internal_mutable_step_progress_bar_configuration() {
  _has_bits_[0] |= 0x00000001u;
  if (step_progress_bar_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration>(GetArenaForAllocation());
    step_progress_bar_configuration_ = p;
  }
  return step_progress_bar_configuration_;
}
inline ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* ShowProgressBarProto::mutable_step_progress_bar_configuration() {
  ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* _msg = _internal_mutable_step_progress_bar_configuration();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowProgressBarProto.step_progress_bar_configuration)
  return _msg;
}
inline void ShowProgressBarProto::set_allocated_step_progress_bar_configuration(::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration* step_progress_bar_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete step_progress_bar_configuration_;
  }
  if (step_progress_bar_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(step_progress_bar_configuration);
    if (message_arena != submessage_arena) {
      step_progress_bar_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_progress_bar_configuration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  step_progress_bar_configuration_ = step_progress_bar_configuration;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowProgressBarProto.step_progress_bar_configuration)
}

inline bool ShowProgressBarProto::has_progress_indicator() const {
  return progress_indicator_case() != PROGRESS_INDICATOR_NOT_SET;
}
inline void ShowProgressBarProto::clear_has_progress_indicator() {
  _oneof_case_[0] = PROGRESS_INDICATOR_NOT_SET;
}
inline ShowProgressBarProto::ProgressIndicatorCase ShowProgressBarProto::progress_indicator_case() const {
  return ShowProgressBarProto::ProgressIndicatorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NavigateProto

// string url = 1;
inline bool NavigateProto::_internal_has_url() const {
  return value_case() == kUrl;
}
inline bool NavigateProto::has_url() const {
  return _internal_has_url();
}
inline void NavigateProto::set_has_url() {
  _oneof_case_[0] = kUrl;
}
inline void NavigateProto::clear_url() {
  if (_internal_has_url()) {
    value_.url_.Destroy();
    clear_has_value();
  }
}
inline const std::string& NavigateProto::url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigateProto.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline void NavigateProto::set_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_url()) {
    clear_value();
    set_has_url();
    value_.url_.InitDefault();
  }
  value_.url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigateProto.url)
}
inline std::string* NavigateProto::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.NavigateProto.url)
  return _s;
}
inline const std::string& NavigateProto::_internal_url() const {
  if (_internal_has_url()) {
    return value_.url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void NavigateProto::_internal_set_url(const std::string& value) {
  if (!_internal_has_url()) {
    clear_value();
    set_has_url();
    value_.url_.InitDefault();
  }
  value_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigateProto::_internal_mutable_url() {
  if (!_internal_has_url()) {
    clear_value();
    set_has_url();
    value_.url_.InitDefault();
  }
  return value_.url_.Mutable(      GetArenaForAllocation());
}
inline std::string* NavigateProto::release_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.NavigateProto.url)
  if (_internal_has_url()) {
    clear_has_value();
    return value_.url_.Release();
  } else {
    return nullptr;
  }
}
inline void NavigateProto::set_allocated_url(std::string* url) {
  if (has_value()) {
    clear_value();
  }
  if (url != nullptr) {
    set_has_url();
    value_.url_.InitAllocated(url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.NavigateProto.url)
}

// bool go_backward = 2;
inline bool NavigateProto::_internal_has_go_backward() const {
  return value_case() == kGoBackward;
}
inline bool NavigateProto::has_go_backward() const {
  return _internal_has_go_backward();
}
inline void NavigateProto::set_has_go_backward() {
  _oneof_case_[0] = kGoBackward;
}
inline void NavigateProto::clear_go_backward() {
  if (_internal_has_go_backward()) {
    value_.go_backward_ = false;
    clear_has_value();
  }
}
inline bool NavigateProto::_internal_go_backward() const {
  if (_internal_has_go_backward()) {
    return value_.go_backward_;
  }
  return false;
}
inline void NavigateProto::_internal_set_go_backward(bool value) {
  if (!_internal_has_go_backward()) {
    clear_value();
    set_has_go_backward();
  }
  value_.go_backward_ = value;
}
inline bool NavigateProto::go_backward() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigateProto.go_backward)
  return _internal_go_backward();
}
inline void NavigateProto::set_go_backward(bool value) {
  _internal_set_go_backward(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigateProto.go_backward)
}

// bool go_forward = 3;
inline bool NavigateProto::_internal_has_go_forward() const {
  return value_case() == kGoForward;
}
inline bool NavigateProto::has_go_forward() const {
  return _internal_has_go_forward();
}
inline void NavigateProto::set_has_go_forward() {
  _oneof_case_[0] = kGoForward;
}
inline void NavigateProto::clear_go_forward() {
  if (_internal_has_go_forward()) {
    value_.go_forward_ = false;
    clear_has_value();
  }
}
inline bool NavigateProto::_internal_go_forward() const {
  if (_internal_has_go_forward()) {
    return value_.go_forward_;
  }
  return false;
}
inline void NavigateProto::_internal_set_go_forward(bool value) {
  if (!_internal_has_go_forward()) {
    clear_value();
    set_has_go_forward();
  }
  value_.go_forward_ = value;
}
inline bool NavigateProto::go_forward() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.NavigateProto.go_forward)
  return _internal_go_forward();
}
inline void NavigateProto::set_go_forward(bool value) {
  _internal_set_go_forward(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.NavigateProto.go_forward)
}

inline bool NavigateProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void NavigateProto::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline NavigateProto::ValueCase NavigateProto::value_case() const {
  return NavigateProto::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExpectNavigationProto

// -------------------------------------------------------------------

// WaitForNavigationProto

// optional int32 timeout_ms = 1;
inline bool WaitForNavigationProto::_internal_has_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WaitForNavigationProto::has_timeout_ms() const {
  return _internal_has_timeout_ms();
}
inline void WaitForNavigationProto::clear_timeout_ms() {
  timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t WaitForNavigationProto::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline int32_t WaitForNavigationProto::timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForNavigationProto.timeout_ms)
  return _internal_timeout_ms();
}
inline void WaitForNavigationProto::_internal_set_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  timeout_ms_ = value;
}
inline void WaitForNavigationProto::set_timeout_ms(int32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForNavigationProto.timeout_ms)
}

// -------------------------------------------------------------------

// WaitForDocumentProto_Result

// optional .autofill_assistant.DocumentReadyState start_ready_state = 1;
inline bool WaitForDocumentProto_Result::_internal_has_start_ready_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WaitForDocumentProto_Result::has_start_ready_state() const {
  return _internal_has_start_ready_state();
}
inline void WaitForDocumentProto_Result::clear_start_ready_state() {
  start_ready_state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::DocumentReadyState WaitForDocumentProto_Result::_internal_start_ready_state() const {
  return static_cast< ::autofill_assistant::DocumentReadyState >(start_ready_state_);
}
inline ::autofill_assistant::DocumentReadyState WaitForDocumentProto_Result::start_ready_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentProto.Result.start_ready_state)
  return _internal_start_ready_state();
}
inline void WaitForDocumentProto_Result::_internal_set_start_ready_state(::autofill_assistant::DocumentReadyState value) {
  assert(::autofill_assistant::DocumentReadyState_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  start_ready_state_ = value;
}
inline void WaitForDocumentProto_Result::set_start_ready_state(::autofill_assistant::DocumentReadyState value) {
  _internal_set_start_ready_state(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDocumentProto.Result.start_ready_state)
}

// optional .autofill_assistant.DocumentReadyState end_ready_state = 2;
inline bool WaitForDocumentProto_Result::_internal_has_end_ready_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitForDocumentProto_Result::has_end_ready_state() const {
  return _internal_has_end_ready_state();
}
inline void WaitForDocumentProto_Result::clear_end_ready_state() {
  end_ready_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::DocumentReadyState WaitForDocumentProto_Result::_internal_end_ready_state() const {
  return static_cast< ::autofill_assistant::DocumentReadyState >(end_ready_state_);
}
inline ::autofill_assistant::DocumentReadyState WaitForDocumentProto_Result::end_ready_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentProto.Result.end_ready_state)
  return _internal_end_ready_state();
}
inline void WaitForDocumentProto_Result::_internal_set_end_ready_state(::autofill_assistant::DocumentReadyState value) {
  assert(::autofill_assistant::DocumentReadyState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  end_ready_state_ = value;
}
inline void WaitForDocumentProto_Result::set_end_ready_state(::autofill_assistant::DocumentReadyState value) {
  _internal_set_end_ready_state(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDocumentProto.Result.end_ready_state)
}

// -------------------------------------------------------------------

// WaitForDocumentProto

// optional int32 timeout_ms = 1 [default = 5000];
inline bool WaitForDocumentProto::_internal_has_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitForDocumentProto::has_timeout_ms() const {
  return _internal_has_timeout_ms();
}
inline void WaitForDocumentProto::clear_timeout_ms() {
  timeout_ms_ = 5000;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t WaitForDocumentProto::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline int32_t WaitForDocumentProto::timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentProto.timeout_ms)
  return _internal_timeout_ms();
}
inline void WaitForDocumentProto::_internal_set_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timeout_ms_ = value;
}
inline void WaitForDocumentProto::set_timeout_ms(int32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDocumentProto.timeout_ms)
}

// optional .autofill_assistant.SelectorProto frame = 2;
inline bool WaitForDocumentProto::_internal_has_frame() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || frame_ != nullptr);
  return value;
}
inline bool WaitForDocumentProto::has_frame() const {
  return _internal_has_frame();
}
inline void WaitForDocumentProto::clear_frame() {
  if (frame_ != nullptr) frame_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::SelectorProto& WaitForDocumentProto::_internal_frame() const {
  const ::autofill_assistant::SelectorProto* p = frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& WaitForDocumentProto::frame() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentProto.frame)
  return _internal_frame();
}
inline void WaitForDocumentProto::unsafe_arena_set_allocated_frame(
    ::autofill_assistant::SelectorProto* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_);
  }
  frame_ = frame;
  if (frame) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.WaitForDocumentProto.frame)
}
inline ::autofill_assistant::SelectorProto* WaitForDocumentProto::release_frame() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = frame_;
  frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* WaitForDocumentProto::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:autofill_assistant.WaitForDocumentProto.frame)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::SelectorProto* temp = frame_;
  frame_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* WaitForDocumentProto::_internal_mutable_frame() {
  _has_bits_[0] |= 0x00000001u;
  if (frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    frame_ = p;
  }
  return frame_;
}
inline ::autofill_assistant::SelectorProto* WaitForDocumentProto::mutable_frame() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForDocumentProto.frame)
  return _msg;
}
inline void WaitForDocumentProto::set_allocated_frame(::autofill_assistant::SelectorProto* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.WaitForDocumentProto.frame)
}

// optional .autofill_assistant.DocumentReadyState min_ready_state = 3 [default = DOCUMENT_INTERACTIVE];
inline bool WaitForDocumentProto::_internal_has_min_ready_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WaitForDocumentProto::has_min_ready_state() const {
  return _internal_has_min_ready_state();
}
inline void WaitForDocumentProto::clear_min_ready_state() {
  min_ready_state_ = 4;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::DocumentReadyState WaitForDocumentProto::_internal_min_ready_state() const {
  return static_cast< ::autofill_assistant::DocumentReadyState >(min_ready_state_);
}
inline ::autofill_assistant::DocumentReadyState WaitForDocumentProto::min_ready_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentProto.min_ready_state)
  return _internal_min_ready_state();
}
inline void WaitForDocumentProto::_internal_set_min_ready_state(::autofill_assistant::DocumentReadyState value) {
  assert(::autofill_assistant::DocumentReadyState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  min_ready_state_ = value;
}
inline void WaitForDocumentProto::set_min_ready_state(::autofill_assistant::DocumentReadyState value) {
  _internal_set_min_ready_state(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDocumentProto.min_ready_state)
}

// -------------------------------------------------------------------

// ShowGenericUiProto_RequestUserData_AdditionalValue

// optional string source_identifier = 1;
inline bool ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_has_source_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowGenericUiProto_RequestUserData_AdditionalValue::has_source_identifier() const {
  return _internal_has_source_identifier();
}
inline void ShowGenericUiProto_RequestUserData_AdditionalValue::clear_source_identifier() {
  source_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowGenericUiProto_RequestUserData_AdditionalValue::source_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.source_identifier)
  return _internal_source_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowGenericUiProto_RequestUserData_AdditionalValue::set_source_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 source_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.source_identifier)
}
inline std::string* ShowGenericUiProto_RequestUserData_AdditionalValue::mutable_source_identifier() {
  std::string* _s = _internal_mutable_source_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.source_identifier)
  return _s;
}
inline const std::string& ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_source_identifier() const {
  return source_identifier_.Get();
}
inline void ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_set_source_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  source_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_mutable_source_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return source_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowGenericUiProto_RequestUserData_AdditionalValue::release_source_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.source_identifier)
  if (!_internal_has_source_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = source_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_identifier_.IsDefault()) {
    source_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowGenericUiProto_RequestUserData_AdditionalValue::set_allocated_source_identifier(std::string* source_identifier) {
  if (source_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  source_identifier_.SetAllocated(source_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_identifier_.IsDefault()) {
    source_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.source_identifier)
}

// optional string model_identifier = 2;
inline bool ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowGenericUiProto_RequestUserData_AdditionalValue::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void ShowGenericUiProto_RequestUserData_AdditionalValue::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShowGenericUiProto_RequestUserData_AdditionalValue::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowGenericUiProto_RequestUserData_AdditionalValue::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.model_identifier)
}
inline std::string* ShowGenericUiProto_RequestUserData_AdditionalValue::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.model_identifier)
  return _s;
}
inline const std::string& ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowGenericUiProto_RequestUserData_AdditionalValue::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowGenericUiProto_RequestUserData_AdditionalValue::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowGenericUiProto_RequestUserData_AdditionalValue::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue.model_identifier)
}

// -------------------------------------------------------------------

// ShowGenericUiProto_RequestUserData

// repeated .autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue additional_values = 1;
inline int ShowGenericUiProto_RequestUserData::_internal_additional_values_size() const {
  return additional_values_.size();
}
inline int ShowGenericUiProto_RequestUserData::additional_values_size() const {
  return _internal_additional_values_size();
}
inline void ShowGenericUiProto_RequestUserData::clear_additional_values() {
  additional_values_.Clear();
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* ShowGenericUiProto_RequestUserData::mutable_additional_values(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.RequestUserData.additional_values)
  return additional_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue >*
ShowGenericUiProto_RequestUserData::mutable_additional_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ShowGenericUiProto.RequestUserData.additional_values)
  return &additional_values_;
}
inline const ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue& ShowGenericUiProto_RequestUserData::_internal_additional_values(int index) const {
  return additional_values_.Get(index);
}
inline const ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue& ShowGenericUiProto_RequestUserData::additional_values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.RequestUserData.additional_values)
  return _internal_additional_values(index);
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* ShowGenericUiProto_RequestUserData::_internal_add_additional_values() {
  return additional_values_.Add();
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* ShowGenericUiProto_RequestUserData::add_additional_values() {
  ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue* _add = _internal_add_additional_values();
  // @@protoc_insertion_point(field_add:autofill_assistant.ShowGenericUiProto.RequestUserData.additional_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue >&
ShowGenericUiProto_RequestUserData::additional_values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ShowGenericUiProto.RequestUserData.additional_values)
  return additional_values_;
}

// -------------------------------------------------------------------

// ShowGenericUiProto_Result

// optional .autofill_assistant.ModelProto model = 1;
inline bool ShowGenericUiProto_Result::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || model_ != nullptr);
  return value;
}
inline bool ShowGenericUiProto_Result::has_model() const {
  return _internal_has_model();
}
inline const ::autofill_assistant::ModelProto& ShowGenericUiProto_Result::_internal_model() const {
  const ::autofill_assistant::ModelProto* p = model_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ModelProto&>(
      ::autofill_assistant::_ModelProto_default_instance_);
}
inline const ::autofill_assistant::ModelProto& ShowGenericUiProto_Result::model() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.Result.model)
  return _internal_model();
}
inline void ShowGenericUiProto_Result::unsafe_arena_set_allocated_model(
    ::autofill_assistant::ModelProto* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  model_ = model;
  if (model) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowGenericUiProto.Result.model)
}
inline ::autofill_assistant::ModelProto* ShowGenericUiProto_Result::release_model() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ModelProto* temp = model_;
  model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ModelProto* ShowGenericUiProto_Result::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.Result.model)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ModelProto* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ModelProto* ShowGenericUiProto_Result::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000001u;
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ModelProto>(GetArenaForAllocation());
    model_ = p;
  }
  return model_;
}
inline ::autofill_assistant::ModelProto* ShowGenericUiProto_Result::mutable_model() {
  ::autofill_assistant::ModelProto* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.Result.model)
  return _msg;
}
inline void ShowGenericUiProto_Result::set_allocated_model(::autofill_assistant::ModelProto* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model));
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.Result.model)
}

// optional bool navigation_ended = 2;
inline bool ShowGenericUiProto_Result::_internal_has_navigation_ended() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowGenericUiProto_Result::has_navigation_ended() const {
  return _internal_has_navigation_ended();
}
inline void ShowGenericUiProto_Result::clear_navigation_ended() {
  navigation_ended_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ShowGenericUiProto_Result::_internal_navigation_ended() const {
  return navigation_ended_;
}
inline bool ShowGenericUiProto_Result::navigation_ended() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.Result.navigation_ended)
  return _internal_navigation_ended();
}
inline void ShowGenericUiProto_Result::_internal_set_navigation_ended(bool value) {
  _has_bits_[0] |= 0x00000002u;
  navigation_ended_ = value;
}
inline void ShowGenericUiProto_Result::set_navigation_ended(bool value) {
  _internal_set_navigation_ended(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.Result.navigation_ended)
}

// -------------------------------------------------------------------

// ShowGenericUiProto_PeriodicElementChecks_ElementCheck

// optional .autofill_assistant.ElementConditionProto element_condition = 1;
inline bool ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_has_element_condition() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || element_condition_ != nullptr);
  return value;
}
inline bool ShowGenericUiProto_PeriodicElementChecks_ElementCheck::has_element_condition() const {
  return _internal_has_element_condition();
}
inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::clear_element_condition() {
  if (element_condition_ != nullptr) element_condition_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ElementConditionProto& ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_element_condition() const {
  const ::autofill_assistant::ElementConditionProto* p = element_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementConditionProto&>(
      ::autofill_assistant::_ElementConditionProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionProto& ShowGenericUiProto_PeriodicElementChecks_ElementCheck::element_condition() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.element_condition)
  return _internal_element_condition();
}
inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::unsafe_arena_set_allocated_element_condition(
    ::autofill_assistant::ElementConditionProto* element_condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_condition_);
  }
  element_condition_ = element_condition;
  if (element_condition) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.element_condition)
}
inline ::autofill_assistant::ElementConditionProto* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::release_element_condition() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ElementConditionProto* temp = element_condition_;
  element_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::unsafe_arena_release_element_condition() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.element_condition)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ElementConditionProto* temp = element_condition_;
  element_condition_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_mutable_element_condition() {
  _has_bits_[0] |= 0x00000002u;
  if (element_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(GetArenaForAllocation());
    element_condition_ = p;
  }
  return element_condition_;
}
inline ::autofill_assistant::ElementConditionProto* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::mutable_element_condition() {
  ::autofill_assistant::ElementConditionProto* _msg = _internal_mutable_element_condition();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.element_condition)
  return _msg;
}
inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::set_allocated_element_condition(::autofill_assistant::ElementConditionProto* element_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_condition_;
  }
  if (element_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element_condition);
    if (message_arena != submessage_arena) {
      element_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element_condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  element_condition_ = element_condition;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.element_condition)
}

// optional string model_identifier = 2;
inline bool ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowGenericUiProto_PeriodicElementChecks_ElementCheck::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowGenericUiProto_PeriodicElementChecks_ElementCheck::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.model_identifier)
}
inline std::string* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.model_identifier)
  return _s;
}
inline const std::string& ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck.model_identifier)
}

// -------------------------------------------------------------------

// ShowGenericUiProto_PeriodicElementChecks

// repeated .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck element_checks = 1;
inline int ShowGenericUiProto_PeriodicElementChecks::_internal_element_checks_size() const {
  return element_checks_.size();
}
inline int ShowGenericUiProto_PeriodicElementChecks::element_checks_size() const {
  return _internal_element_checks_size();
}
inline void ShowGenericUiProto_PeriodicElementChecks::clear_element_checks() {
  element_checks_.Clear();
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* ShowGenericUiProto_PeriodicElementChecks::mutable_element_checks(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.element_checks)
  return element_checks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck >*
ShowGenericUiProto_PeriodicElementChecks::mutable_element_checks() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.element_checks)
  return &element_checks_;
}
inline const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck& ShowGenericUiProto_PeriodicElementChecks::_internal_element_checks(int index) const {
  return element_checks_.Get(index);
}
inline const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck& ShowGenericUiProto_PeriodicElementChecks::element_checks(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.element_checks)
  return _internal_element_checks(index);
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* ShowGenericUiProto_PeriodicElementChecks::_internal_add_element_checks() {
  return element_checks_.Add();
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* ShowGenericUiProto_PeriodicElementChecks::add_element_checks() {
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck* _add = _internal_add_element_checks();
  // @@protoc_insertion_point(field_add:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.element_checks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck >&
ShowGenericUiProto_PeriodicElementChecks::element_checks() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.element_checks)
  return element_checks_;
}

// -------------------------------------------------------------------

// ShowGenericUiProto

// optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
inline bool ShowGenericUiProto::_internal_has_generic_user_interface() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || generic_user_interface_ != nullptr);
  return value;
}
inline bool ShowGenericUiProto::has_generic_user_interface() const {
  return _internal_has_generic_user_interface();
}
inline const ::autofill_assistant::GenericUserInterfaceProto& ShowGenericUiProto::_internal_generic_user_interface() const {
  const ::autofill_assistant::GenericUserInterfaceProto* p = generic_user_interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GenericUserInterfaceProto&>(
      ::autofill_assistant::_GenericUserInterfaceProto_default_instance_);
}
inline const ::autofill_assistant::GenericUserInterfaceProto& ShowGenericUiProto::generic_user_interface() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.generic_user_interface)
  return _internal_generic_user_interface();
}
inline void ShowGenericUiProto::unsafe_arena_set_allocated_generic_user_interface(
    ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_);
  }
  generic_user_interface_ = generic_user_interface;
  if (generic_user_interface) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowGenericUiProto.generic_user_interface)
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiProto::release_generic_user_interface() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_;
  generic_user_interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiProto::unsafe_arena_release_generic_user_interface() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.generic_user_interface)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_;
  generic_user_interface_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiProto::_internal_mutable_generic_user_interface() {
  _has_bits_[0] |= 0x00000001u;
  if (generic_user_interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(GetArenaForAllocation());
    generic_user_interface_ = p;
  }
  return generic_user_interface_;
}
inline ::autofill_assistant::GenericUserInterfaceProto* ShowGenericUiProto::mutable_generic_user_interface() {
  ::autofill_assistant::GenericUserInterfaceProto* _msg = _internal_mutable_generic_user_interface();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.generic_user_interface)
  return _msg;
}
inline void ShowGenericUiProto::set_allocated_generic_user_interface(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_);
  }
  if (generic_user_interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface));
    if (message_arena != submessage_arena) {
      generic_user_interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_user_interface, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  generic_user_interface_ = generic_user_interface;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.generic_user_interface)
}

// repeated string output_model_identifiers = 2;
inline int ShowGenericUiProto::_internal_output_model_identifiers_size() const {
  return output_model_identifiers_.size();
}
inline int ShowGenericUiProto::output_model_identifiers_size() const {
  return _internal_output_model_identifiers_size();
}
inline void ShowGenericUiProto::clear_output_model_identifiers() {
  output_model_identifiers_.Clear();
}
inline std::string* ShowGenericUiProto::add_output_model_identifiers() {
  std::string* _s = _internal_add_output_model_identifiers();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
  return _s;
}
inline const std::string& ShowGenericUiProto::_internal_output_model_identifiers(int index) const {
  return output_model_identifiers_.Get(index);
}
inline const std::string& ShowGenericUiProto::output_model_identifiers(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
  return _internal_output_model_identifiers(index);
}
inline std::string* ShowGenericUiProto::mutable_output_model_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
  return output_model_identifiers_.Mutable(index);
}
inline void ShowGenericUiProto::set_output_model_identifiers(int index, const std::string& value) {
  output_model_identifiers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline void ShowGenericUiProto::set_output_model_identifiers(int index, std::string&& value) {
  output_model_identifiers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline void ShowGenericUiProto::set_output_model_identifiers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_model_identifiers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline void ShowGenericUiProto::set_output_model_identifiers(int index, const char* value, size_t size) {
  output_model_identifiers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline std::string* ShowGenericUiProto::_internal_add_output_model_identifiers() {
  return output_model_identifiers_.Add();
}
inline void ShowGenericUiProto::add_output_model_identifiers(const std::string& value) {
  output_model_identifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline void ShowGenericUiProto::add_output_model_identifiers(std::string&& value) {
  output_model_identifiers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline void ShowGenericUiProto::add_output_model_identifiers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_model_identifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline void ShowGenericUiProto::add_output_model_identifiers(const char* value, size_t size) {
  output_model_identifiers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShowGenericUiProto::output_model_identifiers() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
  return output_model_identifiers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShowGenericUiProto::mutable_output_model_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ShowGenericUiProto.output_model_identifiers)
  return &output_model_identifiers_;
}

// optional .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks periodic_element_checks = 6;
inline bool ShowGenericUiProto::_internal_has_periodic_element_checks() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || periodic_element_checks_ != nullptr);
  return value;
}
inline bool ShowGenericUiProto::has_periodic_element_checks() const {
  return _internal_has_periodic_element_checks();
}
inline void ShowGenericUiProto::clear_periodic_element_checks() {
  if (periodic_element_checks_ != nullptr) periodic_element_checks_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks& ShowGenericUiProto::_internal_periodic_element_checks() const {
  const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* p = periodic_element_checks_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks&>(
      ::autofill_assistant::_ShowGenericUiProto_PeriodicElementChecks_default_instance_);
}
inline const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks& ShowGenericUiProto::periodic_element_checks() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.periodic_element_checks)
  return _internal_periodic_element_checks();
}
inline void ShowGenericUiProto::unsafe_arena_set_allocated_periodic_element_checks(
    ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* periodic_element_checks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(periodic_element_checks_);
  }
  periodic_element_checks_ = periodic_element_checks;
  if (periodic_element_checks) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowGenericUiProto.periodic_element_checks)
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* ShowGenericUiProto::release_periodic_element_checks() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* temp = periodic_element_checks_;
  periodic_element_checks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* ShowGenericUiProto::unsafe_arena_release_periodic_element_checks() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.periodic_element_checks)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* temp = periodic_element_checks_;
  periodic_element_checks_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* ShowGenericUiProto::_internal_mutable_periodic_element_checks() {
  _has_bits_[0] |= 0x00000002u;
  if (periodic_element_checks_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks>(GetArenaForAllocation());
    periodic_element_checks_ = p;
  }
  return periodic_element_checks_;
}
inline ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* ShowGenericUiProto::mutable_periodic_element_checks() {
  ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* _msg = _internal_mutable_periodic_element_checks();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.periodic_element_checks)
  return _msg;
}
inline void ShowGenericUiProto::set_allocated_periodic_element_checks(::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks* periodic_element_checks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete periodic_element_checks_;
  }
  if (periodic_element_checks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(periodic_element_checks);
    if (message_arena != submessage_arena) {
      periodic_element_checks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, periodic_element_checks, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  periodic_element_checks_ = periodic_element_checks;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.periodic_element_checks)
}

// optional bool end_on_navigation = 7;
inline bool ShowGenericUiProto::_internal_has_end_on_navigation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShowGenericUiProto::has_end_on_navigation() const {
  return _internal_has_end_on_navigation();
}
inline void ShowGenericUiProto::clear_end_on_navigation() {
  end_on_navigation_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ShowGenericUiProto::_internal_end_on_navigation() const {
  return end_on_navigation_;
}
inline bool ShowGenericUiProto::end_on_navigation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.end_on_navigation)
  return _internal_end_on_navigation();
}
inline void ShowGenericUiProto::_internal_set_end_on_navigation(bool value) {
  _has_bits_[0] |= 0x00000008u;
  end_on_navigation_ = value;
}
inline void ShowGenericUiProto::set_end_on_navigation(bool value) {
  _internal_set_end_on_navigation(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.end_on_navigation)
}

// optional bool allow_interrupt = 8;
inline bool ShowGenericUiProto::_internal_has_allow_interrupt() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShowGenericUiProto::has_allow_interrupt() const {
  return _internal_has_allow_interrupt();
}
inline void ShowGenericUiProto::clear_allow_interrupt() {
  allow_interrupt_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ShowGenericUiProto::_internal_allow_interrupt() const {
  return allow_interrupt_;
}
inline bool ShowGenericUiProto::allow_interrupt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.allow_interrupt)
  return _internal_allow_interrupt();
}
inline void ShowGenericUiProto::_internal_set_allow_interrupt(bool value) {
  _has_bits_[0] |= 0x00000010u;
  allow_interrupt_ = value;
}
inline void ShowGenericUiProto::set_allow_interrupt(bool value) {
  _internal_set_allow_interrupt(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowGenericUiProto.allow_interrupt)
}

// optional .autofill_assistant.ShowGenericUiProto.RequestUserData request_user_data = 9;
inline bool ShowGenericUiProto::_internal_has_request_user_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || request_user_data_ != nullptr);
  return value;
}
inline bool ShowGenericUiProto::has_request_user_data() const {
  return _internal_has_request_user_data();
}
inline void ShowGenericUiProto::clear_request_user_data() {
  if (request_user_data_ != nullptr) request_user_data_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ShowGenericUiProto_RequestUserData& ShowGenericUiProto::_internal_request_user_data() const {
  const ::autofill_assistant::ShowGenericUiProto_RequestUserData* p = request_user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ShowGenericUiProto_RequestUserData&>(
      ::autofill_assistant::_ShowGenericUiProto_RequestUserData_default_instance_);
}
inline const ::autofill_assistant::ShowGenericUiProto_RequestUserData& ShowGenericUiProto::request_user_data() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowGenericUiProto.request_user_data)
  return _internal_request_user_data();
}
inline void ShowGenericUiProto::unsafe_arena_set_allocated_request_user_data(
    ::autofill_assistant::ShowGenericUiProto_RequestUserData* request_user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_user_data_);
  }
  request_user_data_ = request_user_data;
  if (request_user_data) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowGenericUiProto.request_user_data)
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData* ShowGenericUiProto::release_request_user_data() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* temp = request_user_data_;
  request_user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData* ShowGenericUiProto::unsafe_arena_release_request_user_data() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowGenericUiProto.request_user_data)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* temp = request_user_data_;
  request_user_data_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData* ShowGenericUiProto::_internal_mutable_request_user_data() {
  _has_bits_[0] |= 0x00000004u;
  if (request_user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ShowGenericUiProto_RequestUserData>(GetArenaForAllocation());
    request_user_data_ = p;
  }
  return request_user_data_;
}
inline ::autofill_assistant::ShowGenericUiProto_RequestUserData* ShowGenericUiProto::mutable_request_user_data() {
  ::autofill_assistant::ShowGenericUiProto_RequestUserData* _msg = _internal_mutable_request_user_data();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowGenericUiProto.request_user_data)
  return _msg;
}
inline void ShowGenericUiProto::set_allocated_request_user_data(::autofill_assistant::ShowGenericUiProto_RequestUserData* request_user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_user_data_;
  }
  if (request_user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_user_data);
    if (message_arena != submessage_arena) {
      request_user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request_user_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  request_user_data_ = request_user_data;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowGenericUiProto.request_user_data)
}

// -------------------------------------------------------------------

// SetPersistentUiProto

// optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
inline bool SetPersistentUiProto::_internal_has_generic_user_interface() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || generic_user_interface_ != nullptr);
  return value;
}
inline bool SetPersistentUiProto::has_generic_user_interface() const {
  return _internal_has_generic_user_interface();
}
inline const ::autofill_assistant::GenericUserInterfaceProto& SetPersistentUiProto::_internal_generic_user_interface() const {
  const ::autofill_assistant::GenericUserInterfaceProto* p = generic_user_interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GenericUserInterfaceProto&>(
      ::autofill_assistant::_GenericUserInterfaceProto_default_instance_);
}
inline const ::autofill_assistant::GenericUserInterfaceProto& SetPersistentUiProto::generic_user_interface() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetPersistentUiProto.generic_user_interface)
  return _internal_generic_user_interface();
}
inline void SetPersistentUiProto::unsafe_arena_set_allocated_generic_user_interface(
    ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_);
  }
  generic_user_interface_ = generic_user_interface;
  if (generic_user_interface) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetPersistentUiProto.generic_user_interface)
}
inline ::autofill_assistant::GenericUserInterfaceProto* SetPersistentUiProto::release_generic_user_interface() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_;
  generic_user_interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* SetPersistentUiProto::unsafe_arena_release_generic_user_interface() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetPersistentUiProto.generic_user_interface)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_;
  generic_user_interface_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* SetPersistentUiProto::_internal_mutable_generic_user_interface() {
  _has_bits_[0] |= 0x00000001u;
  if (generic_user_interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(GetArenaForAllocation());
    generic_user_interface_ = p;
  }
  return generic_user_interface_;
}
inline ::autofill_assistant::GenericUserInterfaceProto* SetPersistentUiProto::mutable_generic_user_interface() {
  ::autofill_assistant::GenericUserInterfaceProto* _msg = _internal_mutable_generic_user_interface();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetPersistentUiProto.generic_user_interface)
  return _msg;
}
inline void SetPersistentUiProto::set_allocated_generic_user_interface(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_);
  }
  if (generic_user_interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface));
    if (message_arena != submessage_arena) {
      generic_user_interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_user_interface, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  generic_user_interface_ = generic_user_interface;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetPersistentUiProto.generic_user_interface)
}

// -------------------------------------------------------------------

// ClearPersistentUiProto

// -------------------------------------------------------------------

// PromptProto_Choice

// optional .autofill_assistant.ChipProto chip = 11;
inline bool PromptProto_Choice::_internal_has_chip() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || chip_ != nullptr);
  return value;
}
inline bool PromptProto_Choice::has_chip() const {
  return _internal_has_chip();
}
inline const ::autofill_assistant::ChipProto& PromptProto_Choice::_internal_chip() const {
  const ::autofill_assistant::ChipProto* p = chip_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ChipProto&>(
      ::autofill_assistant::_ChipProto_default_instance_);
}
inline const ::autofill_assistant::ChipProto& PromptProto_Choice::chip() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Choice.chip)
  return _internal_chip();
}
inline void PromptProto_Choice::unsafe_arena_set_allocated_chip(
    ::autofill_assistant::ChipProto* chip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  chip_ = chip;
  if (chip) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.PromptProto.Choice.chip)
}
inline ::autofill_assistant::ChipProto* PromptProto_Choice::release_chip() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ChipProto* PromptProto_Choice::unsafe_arena_release_chip() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Choice.chip)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ChipProto* PromptProto_Choice::_internal_mutable_chip() {
  _has_bits_[0] |= 0x00000004u;
  if (chip_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ChipProto>(GetArenaForAllocation());
    chip_ = p;
  }
  return chip_;
}
inline ::autofill_assistant::ChipProto* PromptProto_Choice::mutable_chip() {
  ::autofill_assistant::ChipProto* _msg = _internal_mutable_chip();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Choice.chip)
  return _msg;
}
inline void PromptProto_Choice::set_allocated_chip(::autofill_assistant::ChipProto* chip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  if (chip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip));
    if (message_arena != submessage_arena) {
      chip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  chip_ = chip;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Choice.chip)
}

// optional .autofill_assistant.ElementConditionProto auto_select_when = 15;
inline bool PromptProto_Choice::_internal_has_auto_select_when() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || auto_select_when_ != nullptr);
  return value;
}
inline bool PromptProto_Choice::has_auto_select_when() const {
  return _internal_has_auto_select_when();
}
inline void PromptProto_Choice::clear_auto_select_when() {
  if (auto_select_when_ != nullptr) auto_select_when_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::ElementConditionProto& PromptProto_Choice::_internal_auto_select_when() const {
  const ::autofill_assistant::ElementConditionProto* p = auto_select_when_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementConditionProto&>(
      ::autofill_assistant::_ElementConditionProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionProto& PromptProto_Choice::auto_select_when() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Choice.auto_select_when)
  return _internal_auto_select_when();
}
inline void PromptProto_Choice::unsafe_arena_set_allocated_auto_select_when(
    ::autofill_assistant::ElementConditionProto* auto_select_when) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auto_select_when_);
  }
  auto_select_when_ = auto_select_when;
  if (auto_select_when) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.PromptProto.Choice.auto_select_when)
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::release_auto_select_when() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ElementConditionProto* temp = auto_select_when_;
  auto_select_when_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::unsafe_arena_release_auto_select_when() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Choice.auto_select_when)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ElementConditionProto* temp = auto_select_when_;
  auto_select_when_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::_internal_mutable_auto_select_when() {
  _has_bits_[0] |= 0x00000008u;
  if (auto_select_when_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(GetArenaForAllocation());
    auto_select_when_ = p;
  }
  return auto_select_when_;
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::mutable_auto_select_when() {
  ::autofill_assistant::ElementConditionProto* _msg = _internal_mutable_auto_select_when();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Choice.auto_select_when)
  return _msg;
}
inline void PromptProto_Choice::set_allocated_auto_select_when(::autofill_assistant::ElementConditionProto* auto_select_when) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auto_select_when_;
  }
  if (auto_select_when) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_select_when);
    if (message_arena != submessage_arena) {
      auto_select_when = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_select_when, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  auto_select_when_ = auto_select_when;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Choice.auto_select_when)
}

// optional .autofill_assistant.ElementConditionProto show_only_when = 16;
inline bool PromptProto_Choice::_internal_has_show_only_when() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || show_only_when_ != nullptr);
  return value;
}
inline bool PromptProto_Choice::has_show_only_when() const {
  return _internal_has_show_only_when();
}
inline void PromptProto_Choice::clear_show_only_when() {
  if (show_only_when_ != nullptr) show_only_when_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill_assistant::ElementConditionProto& PromptProto_Choice::_internal_show_only_when() const {
  const ::autofill_assistant::ElementConditionProto* p = show_only_when_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementConditionProto&>(
      ::autofill_assistant::_ElementConditionProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionProto& PromptProto_Choice::show_only_when() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Choice.show_only_when)
  return _internal_show_only_when();
}
inline void PromptProto_Choice::unsafe_arena_set_allocated_show_only_when(
    ::autofill_assistant::ElementConditionProto* show_only_when) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(show_only_when_);
  }
  show_only_when_ = show_only_when;
  if (show_only_when) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.PromptProto.Choice.show_only_when)
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::release_show_only_when() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ElementConditionProto* temp = show_only_when_;
  show_only_when_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::unsafe_arena_release_show_only_when() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Choice.show_only_when)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::ElementConditionProto* temp = show_only_when_;
  show_only_when_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::_internal_mutable_show_only_when() {
  _has_bits_[0] |= 0x00000010u;
  if (show_only_when_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(GetArenaForAllocation());
    show_only_when_ = p;
  }
  return show_only_when_;
}
inline ::autofill_assistant::ElementConditionProto* PromptProto_Choice::mutable_show_only_when() {
  ::autofill_assistant::ElementConditionProto* _msg = _internal_mutable_show_only_when();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Choice.show_only_when)
  return _msg;
}
inline void PromptProto_Choice::set_allocated_show_only_when(::autofill_assistant::ElementConditionProto* show_only_when) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete show_only_when_;
  }
  if (show_only_when) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_only_when);
    if (message_arena != submessage_arena) {
      show_only_when = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_only_when, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  show_only_when_ = show_only_when;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Choice.show_only_when)
}

// optional bool allow_disabling = 9;
inline bool PromptProto_Choice::_internal_has_allow_disabling() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PromptProto_Choice::has_allow_disabling() const {
  return _internal_has_allow_disabling();
}
inline void PromptProto_Choice::clear_allow_disabling() {
  allow_disabling_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool PromptProto_Choice::_internal_allow_disabling() const {
  return allow_disabling_;
}
inline bool PromptProto_Choice::allow_disabling() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Choice.allow_disabling)
  return _internal_allow_disabling();
}
inline void PromptProto_Choice::_internal_set_allow_disabling(bool value) {
  _has_bits_[0] |= 0x00000020u;
  allow_disabling_ = value;
}
inline void PromptProto_Choice::set_allow_disabling(bool value) {
  _internal_set_allow_disabling(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.Choice.allow_disabling)
}

// optional bytes server_payload = 5;
inline bool PromptProto_Choice::_internal_has_server_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptProto_Choice::has_server_payload() const {
  return _internal_has_server_payload();
}
inline void PromptProto_Choice::clear_server_payload() {
  server_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromptProto_Choice::server_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Choice.server_payload)
  return _internal_server_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptProto_Choice::set_server_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.Choice.server_payload)
}
inline std::string* PromptProto_Choice::mutable_server_payload() {
  std::string* _s = _internal_mutable_server_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Choice.server_payload)
  return _s;
}
inline const std::string& PromptProto_Choice::_internal_server_payload() const {
  return server_payload_.Get();
}
inline void PromptProto_Choice::_internal_set_server_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptProto_Choice::_internal_mutable_server_payload() {
  _has_bits_[0] |= 0x00000001u;
  return server_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptProto_Choice::release_server_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Choice.server_payload)
  if (!_internal_has_server_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_payload_.IsDefault()) {
    server_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptProto_Choice::set_allocated_server_payload(std::string* server_payload) {
  if (server_payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_payload_.SetAllocated(server_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_payload_.IsDefault()) {
    server_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Choice.server_payload)
}

// optional string tag = 18;
inline bool PromptProto_Choice::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromptProto_Choice::has_tag() const {
  return _internal_has_tag();
}
inline void PromptProto_Choice::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PromptProto_Choice::tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Choice.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptProto_Choice::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.Choice.tag)
}
inline std::string* PromptProto_Choice::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Choice.tag)
  return _s;
}
inline const std::string& PromptProto_Choice::_internal_tag() const {
  return tag_.Get();
}
inline void PromptProto_Choice::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptProto_Choice::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptProto_Choice::release_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Choice.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptProto_Choice::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Choice.tag)
}

// -------------------------------------------------------------------

// PromptProto_Result

// optional bool navigation_ended = 2;
inline bool PromptProto_Result::_internal_has_navigation_ended() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PromptProto_Result::has_navigation_ended() const {
  return _internal_has_navigation_ended();
}
inline void PromptProto_Result::clear_navigation_ended() {
  navigation_ended_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PromptProto_Result::_internal_navigation_ended() const {
  return navigation_ended_;
}
inline bool PromptProto_Result::navigation_ended() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Result.navigation_ended)
  return _internal_navigation_ended();
}
inline void PromptProto_Result::_internal_set_navigation_ended(bool value) {
  _has_bits_[0] |= 0x00000004u;
  navigation_ended_ = value;
}
inline void PromptProto_Result::set_navigation_ended(bool value) {
  _internal_set_navigation_ended(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.Result.navigation_ended)
}

// optional bytes server_payload = 5;
inline bool PromptProto_Result::_internal_has_server_payload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptProto_Result::has_server_payload() const {
  return _internal_has_server_payload();
}
inline void PromptProto_Result::clear_server_payload() {
  server_payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromptProto_Result::server_payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Result.server_payload)
  return _internal_server_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptProto_Result::set_server_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.Result.server_payload)
}
inline std::string* PromptProto_Result::mutable_server_payload() {
  std::string* _s = _internal_mutable_server_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Result.server_payload)
  return _s;
}
inline const std::string& PromptProto_Result::_internal_server_payload() const {
  return server_payload_.Get();
}
inline void PromptProto_Result::_internal_set_server_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_payload_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptProto_Result::_internal_mutable_server_payload() {
  _has_bits_[0] |= 0x00000001u;
  return server_payload_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptProto_Result::release_server_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Result.server_payload)
  if (!_internal_has_server_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_payload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_payload_.IsDefault()) {
    server_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptProto_Result::set_allocated_server_payload(std::string* server_payload) {
  if (server_payload != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_payload_.SetAllocated(server_payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_payload_.IsDefault()) {
    server_payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Result.server_payload)
}

// optional string choice_tag = 6;
inline bool PromptProto_Result::_internal_has_choice_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromptProto_Result::has_choice_tag() const {
  return _internal_has_choice_tag();
}
inline void PromptProto_Result::clear_choice_tag() {
  choice_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PromptProto_Result::choice_tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.Result.choice_tag)
  return _internal_choice_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptProto_Result::set_choice_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 choice_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.Result.choice_tag)
}
inline std::string* PromptProto_Result::mutable_choice_tag() {
  std::string* _s = _internal_mutable_choice_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.Result.choice_tag)
  return _s;
}
inline const std::string& PromptProto_Result::_internal_choice_tag() const {
  return choice_tag_.Get();
}
inline void PromptProto_Result::_internal_set_choice_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  choice_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptProto_Result::_internal_mutable_choice_tag() {
  _has_bits_[0] |= 0x00000002u;
  return choice_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptProto_Result::release_choice_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.Result.choice_tag)
  if (!_internal_has_choice_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = choice_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (choice_tag_.IsDefault()) {
    choice_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptProto_Result::set_allocated_choice_tag(std::string* choice_tag) {
  if (choice_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  choice_tag_.SetAllocated(choice_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (choice_tag_.IsDefault()) {
    choice_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.Result.choice_tag)
}

// -------------------------------------------------------------------

// PromptProto

// optional string message = 1;
inline bool PromptProto::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromptProto::has_message() const {
  return _internal_has_message();
}
inline void PromptProto::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromptProto::message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromptProto::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.message)
}
inline std::string* PromptProto::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.message)
  return _s;
}
inline const std::string& PromptProto::_internal_message() const {
  return message_.Get();
}
inline void PromptProto::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(value, GetArenaForAllocation());
}
inline std::string* PromptProto::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(GetArenaForAllocation());
}
inline std::string* PromptProto::release_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PromptProto.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromptProto::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PromptProto.message)
}

// repeated .autofill_assistant.PromptProto.Choice choices = 4;
inline int PromptProto::_internal_choices_size() const {
  return choices_.size();
}
inline int PromptProto::choices_size() const {
  return _internal_choices_size();
}
inline void PromptProto::clear_choices() {
  choices_.Clear();
}
inline ::autofill_assistant::PromptProto_Choice* PromptProto::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.choices)
  return choices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PromptProto_Choice >*
PromptProto::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.PromptProto.choices)
  return &choices_;
}
inline const ::autofill_assistant::PromptProto_Choice& PromptProto::_internal_choices(int index) const {
  return choices_.Get(index);
}
inline const ::autofill_assistant::PromptProto_Choice& PromptProto::choices(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.choices)
  return _internal_choices(index);
}
inline ::autofill_assistant::PromptProto_Choice* PromptProto::_internal_add_choices() {
  return choices_.Add();
}
inline ::autofill_assistant::PromptProto_Choice* PromptProto::add_choices() {
  ::autofill_assistant::PromptProto_Choice* _add = _internal_add_choices();
  // @@protoc_insertion_point(field_add:autofill_assistant.PromptProto.choices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::PromptProto_Choice >&
PromptProto::choices() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.PromptProto.choices)
  return choices_;
}

// optional bool allow_interrupt = 5;
inline bool PromptProto::_internal_has_allow_interrupt() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromptProto::has_allow_interrupt() const {
  return _internal_has_allow_interrupt();
}
inline void PromptProto::clear_allow_interrupt() {
  allow_interrupt_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PromptProto::_internal_allow_interrupt() const {
  return allow_interrupt_;
}
inline bool PromptProto::allow_interrupt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.allow_interrupt)
  return _internal_allow_interrupt();
}
inline void PromptProto::_internal_set_allow_interrupt(bool value) {
  _has_bits_[0] |= 0x00000002u;
  allow_interrupt_ = value;
}
inline void PromptProto::set_allow_interrupt(bool value) {
  _internal_set_allow_interrupt(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.allow_interrupt)
}

// optional bool disable_force_expand_sheet = 6;
inline bool PromptProto::_internal_has_disable_force_expand_sheet() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PromptProto::has_disable_force_expand_sheet() const {
  return _internal_has_disable_force_expand_sheet();
}
inline void PromptProto::clear_disable_force_expand_sheet() {
  disable_force_expand_sheet_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PromptProto::_internal_disable_force_expand_sheet() const {
  return disable_force_expand_sheet_;
}
inline bool PromptProto::disable_force_expand_sheet() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.disable_force_expand_sheet)
  return _internal_disable_force_expand_sheet();
}
inline void PromptProto::_internal_set_disable_force_expand_sheet(bool value) {
  _has_bits_[0] |= 0x00000004u;
  disable_force_expand_sheet_ = value;
}
inline void PromptProto::set_disable_force_expand_sheet(bool value) {
  _internal_set_disable_force_expand_sheet(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.disable_force_expand_sheet)
}

// optional bool browse_mode = 7;
inline bool PromptProto::_internal_has_browse_mode() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PromptProto::has_browse_mode() const {
  return _internal_has_browse_mode();
}
inline void PromptProto::clear_browse_mode() {
  browse_mode_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PromptProto::_internal_browse_mode() const {
  return browse_mode_;
}
inline bool PromptProto::browse_mode() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.browse_mode)
  return _internal_browse_mode();
}
inline void PromptProto::_internal_set_browse_mode(bool value) {
  _has_bits_[0] |= 0x00000008u;
  browse_mode_ = value;
}
inline void PromptProto::set_browse_mode(bool value) {
  _internal_set_browse_mode(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.browse_mode)
}

// optional bool browse_mode_invisible = 10;
inline bool PromptProto::_internal_has_browse_mode_invisible() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PromptProto::has_browse_mode_invisible() const {
  return _internal_has_browse_mode_invisible();
}
inline void PromptProto::clear_browse_mode_invisible() {
  browse_mode_invisible_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PromptProto::_internal_browse_mode_invisible() const {
  return browse_mode_invisible_;
}
inline bool PromptProto::browse_mode_invisible() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.browse_mode_invisible)
  return _internal_browse_mode_invisible();
}
inline void PromptProto::_internal_set_browse_mode_invisible(bool value) {
  _has_bits_[0] |= 0x00000010u;
  browse_mode_invisible_ = value;
}
inline void PromptProto::set_browse_mode_invisible(bool value) {
  _internal_set_browse_mode_invisible(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.browse_mode_invisible)
}

// optional bool end_on_navigation = 8;
inline bool PromptProto::_internal_has_end_on_navigation() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PromptProto::has_end_on_navigation() const {
  return _internal_has_end_on_navigation();
}
inline void PromptProto::clear_end_on_navigation() {
  end_on_navigation_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool PromptProto::_internal_end_on_navigation() const {
  return end_on_navigation_;
}
inline bool PromptProto::end_on_navigation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.end_on_navigation)
  return _internal_end_on_navigation();
}
inline void PromptProto::_internal_set_end_on_navigation(bool value) {
  _has_bits_[0] |= 0x00000020u;
  end_on_navigation_ = value;
}
inline void PromptProto::set_end_on_navigation(bool value) {
  _internal_set_end_on_navigation(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.end_on_navigation)
}

// repeated string browse_domains_allowlist = 9;
inline int PromptProto::_internal_browse_domains_allowlist_size() const {
  return browse_domains_allowlist_.size();
}
inline int PromptProto::browse_domains_allowlist_size() const {
  return _internal_browse_domains_allowlist_size();
}
inline void PromptProto::clear_browse_domains_allowlist() {
  browse_domains_allowlist_.Clear();
}
inline std::string* PromptProto::add_browse_domains_allowlist() {
  std::string* _s = _internal_add_browse_domains_allowlist();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.PromptProto.browse_domains_allowlist)
  return _s;
}
inline const std::string& PromptProto::_internal_browse_domains_allowlist(int index) const {
  return browse_domains_allowlist_.Get(index);
}
inline const std::string& PromptProto::browse_domains_allowlist(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PromptProto.browse_domains_allowlist)
  return _internal_browse_domains_allowlist(index);
}
inline std::string* PromptProto::mutable_browse_domains_allowlist(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PromptProto.browse_domains_allowlist)
  return browse_domains_allowlist_.Mutable(index);
}
inline void PromptProto::set_browse_domains_allowlist(int index, const std::string& value) {
  browse_domains_allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline void PromptProto::set_browse_domains_allowlist(int index, std::string&& value) {
  browse_domains_allowlist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline void PromptProto::set_browse_domains_allowlist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  browse_domains_allowlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline void PromptProto::set_browse_domains_allowlist(int index, const char* value, size_t size) {
  browse_domains_allowlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline std::string* PromptProto::_internal_add_browse_domains_allowlist() {
  return browse_domains_allowlist_.Add();
}
inline void PromptProto::add_browse_domains_allowlist(const std::string& value) {
  browse_domains_allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline void PromptProto::add_browse_domains_allowlist(std::string&& value) {
  browse_domains_allowlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline void PromptProto::add_browse_domains_allowlist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  browse_domains_allowlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline void PromptProto::add_browse_domains_allowlist(const char* value, size_t size) {
  browse_domains_allowlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.PromptProto.browse_domains_allowlist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PromptProto::browse_domains_allowlist() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.PromptProto.browse_domains_allowlist)
  return browse_domains_allowlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PromptProto::mutable_browse_domains_allowlist() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.PromptProto.browse_domains_allowlist)
  return &browse_domains_allowlist_;
}

// -------------------------------------------------------------------

// ContactDetailsProto

// optional string contact_details_name = 1;
inline bool ContactDetailsProto::_internal_has_contact_details_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_contact_details_name() const {
  return _internal_has_contact_details_name();
}
inline void ContactDetailsProto::clear_contact_details_name() {
  contact_details_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContactDetailsProto::contact_details_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.contact_details_name)
  return _internal_contact_details_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactDetailsProto::set_contact_details_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contact_details_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.contact_details_name)
}
inline std::string* ContactDetailsProto::mutable_contact_details_name() {
  std::string* _s = _internal_mutable_contact_details_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ContactDetailsProto.contact_details_name)
  return _s;
}
inline const std::string& ContactDetailsProto::_internal_contact_details_name() const {
  return contact_details_name_.Get();
}
inline void ContactDetailsProto::_internal_set_contact_details_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contact_details_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactDetailsProto::_internal_mutable_contact_details_name() {
  _has_bits_[0] |= 0x00000001u;
  return contact_details_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactDetailsProto::release_contact_details_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ContactDetailsProto.contact_details_name)
  if (!_internal_has_contact_details_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contact_details_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contact_details_name_.IsDefault()) {
    contact_details_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactDetailsProto::set_allocated_contact_details_name(std::string* contact_details_name) {
  if (contact_details_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contact_details_name_.SetAllocated(contact_details_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contact_details_name_.IsDefault()) {
    contact_details_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ContactDetailsProto.contact_details_name)
}

// optional bool request_payer_name = 2;
inline bool ContactDetailsProto::_internal_has_request_payer_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_request_payer_name() const {
  return _internal_has_request_payer_name();
}
inline void ContactDetailsProto::clear_request_payer_name() {
  request_payer_name_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ContactDetailsProto::_internal_request_payer_name() const {
  return request_payer_name_;
}
inline bool ContactDetailsProto::request_payer_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.request_payer_name)
  return _internal_request_payer_name();
}
inline void ContactDetailsProto::_internal_set_request_payer_name(bool value) {
  _has_bits_[0] |= 0x00000008u;
  request_payer_name_ = value;
}
inline void ContactDetailsProto::set_request_payer_name(bool value) {
  _internal_set_request_payer_name(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.request_payer_name)
}

// optional bool request_payer_email = 3;
inline bool ContactDetailsProto::_internal_has_request_payer_email() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_request_payer_email() const {
  return _internal_has_request_payer_email();
}
inline void ContactDetailsProto::clear_request_payer_email() {
  request_payer_email_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ContactDetailsProto::_internal_request_payer_email() const {
  return request_payer_email_;
}
inline bool ContactDetailsProto::request_payer_email() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.request_payer_email)
  return _internal_request_payer_email();
}
inline void ContactDetailsProto::_internal_set_request_payer_email(bool value) {
  _has_bits_[0] |= 0x00000010u;
  request_payer_email_ = value;
}
inline void ContactDetailsProto::set_request_payer_email(bool value) {
  _internal_set_request_payer_email(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.request_payer_email)
}

// optional bool request_payer_phone = 4;
inline bool ContactDetailsProto::_internal_has_request_payer_phone() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_request_payer_phone() const {
  return _internal_has_request_payer_phone();
}
inline void ContactDetailsProto::clear_request_payer_phone() {
  request_payer_phone_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ContactDetailsProto::_internal_request_payer_phone() const {
  return request_payer_phone_;
}
inline bool ContactDetailsProto::request_payer_phone() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.request_payer_phone)
  return _internal_request_payer_phone();
}
inline void ContactDetailsProto::_internal_set_request_payer_phone(bool value) {
  _has_bits_[0] |= 0x00000020u;
  request_payer_phone_ = value;
}
inline void ContactDetailsProto::set_request_payer_phone(bool value) {
  _internal_set_request_payer_phone(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.request_payer_phone)
}

// repeated .autofill_assistant.ContactDetailsProto.AutofillContactField summary_fields = 5;
inline int ContactDetailsProto::_internal_summary_fields_size() const {
  return summary_fields_.size();
}
inline int ContactDetailsProto::summary_fields_size() const {
  return _internal_summary_fields_size();
}
inline void ContactDetailsProto::clear_summary_fields() {
  summary_fields_.Clear();
}
inline ::autofill_assistant::ContactDetailsProto_AutofillContactField ContactDetailsProto::_internal_summary_fields(int index) const {
  return static_cast< ::autofill_assistant::ContactDetailsProto_AutofillContactField >(summary_fields_.Get(index));
}
inline ::autofill_assistant::ContactDetailsProto_AutofillContactField ContactDetailsProto::summary_fields(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.summary_fields)
  return _internal_summary_fields(index);
}
inline void ContactDetailsProto::set_summary_fields(int index, ::autofill_assistant::ContactDetailsProto_AutofillContactField value) {
  assert(::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid(value));
  summary_fields_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.summary_fields)
}
inline void ContactDetailsProto::_internal_add_summary_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value) {
  assert(::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid(value));
  summary_fields_.Add(value);
}
inline void ContactDetailsProto::add_summary_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value) {
  _internal_add_summary_fields(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.ContactDetailsProto.summary_fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ContactDetailsProto::summary_fields() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ContactDetailsProto.summary_fields)
  return summary_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ContactDetailsProto::_internal_mutable_summary_fields() {
  return &summary_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ContactDetailsProto::mutable_summary_fields() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ContactDetailsProto.summary_fields)
  return _internal_mutable_summary_fields();
}

// optional int32 max_number_summary_lines = 6;
inline bool ContactDetailsProto::_internal_has_max_number_summary_lines() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_max_number_summary_lines() const {
  return _internal_has_max_number_summary_lines();
}
inline void ContactDetailsProto::clear_max_number_summary_lines() {
  max_number_summary_lines_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ContactDetailsProto::_internal_max_number_summary_lines() const {
  return max_number_summary_lines_;
}
inline int32_t ContactDetailsProto::max_number_summary_lines() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.max_number_summary_lines)
  return _internal_max_number_summary_lines();
}
inline void ContactDetailsProto::_internal_set_max_number_summary_lines(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  max_number_summary_lines_ = value;
}
inline void ContactDetailsProto::set_max_number_summary_lines(int32_t value) {
  _internal_set_max_number_summary_lines(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.max_number_summary_lines)
}

// repeated .autofill_assistant.ContactDetailsProto.AutofillContactField full_fields = 7;
inline int ContactDetailsProto::_internal_full_fields_size() const {
  return full_fields_.size();
}
inline int ContactDetailsProto::full_fields_size() const {
  return _internal_full_fields_size();
}
inline void ContactDetailsProto::clear_full_fields() {
  full_fields_.Clear();
}
inline ::autofill_assistant::ContactDetailsProto_AutofillContactField ContactDetailsProto::_internal_full_fields(int index) const {
  return static_cast< ::autofill_assistant::ContactDetailsProto_AutofillContactField >(full_fields_.Get(index));
}
inline ::autofill_assistant::ContactDetailsProto_AutofillContactField ContactDetailsProto::full_fields(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.full_fields)
  return _internal_full_fields(index);
}
inline void ContactDetailsProto::set_full_fields(int index, ::autofill_assistant::ContactDetailsProto_AutofillContactField value) {
  assert(::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid(value));
  full_fields_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.full_fields)
}
inline void ContactDetailsProto::_internal_add_full_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value) {
  assert(::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid(value));
  full_fields_.Add(value);
}
inline void ContactDetailsProto::add_full_fields(::autofill_assistant::ContactDetailsProto_AutofillContactField value) {
  _internal_add_full_fields(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.ContactDetailsProto.full_fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ContactDetailsProto::full_fields() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ContactDetailsProto.full_fields)
  return full_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ContactDetailsProto::_internal_mutable_full_fields() {
  return &full_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ContactDetailsProto::mutable_full_fields() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ContactDetailsProto.full_fields)
  return _internal_mutable_full_fields();
}

// optional int32 max_number_full_lines = 8;
inline bool ContactDetailsProto::_internal_has_max_number_full_lines() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_max_number_full_lines() const {
  return _internal_has_max_number_full_lines();
}
inline void ContactDetailsProto::clear_max_number_full_lines() {
  max_number_full_lines_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ContactDetailsProto::_internal_max_number_full_lines() const {
  return max_number_full_lines_;
}
inline int32_t ContactDetailsProto::max_number_full_lines() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.max_number_full_lines)
  return _internal_max_number_full_lines();
}
inline void ContactDetailsProto::_internal_set_max_number_full_lines(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  max_number_full_lines_ = value;
}
inline void ContactDetailsProto::set_max_number_full_lines(int32_t value) {
  _internal_set_max_number_full_lines(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.max_number_full_lines)
}

// optional string contact_details_section_title = 9;
inline bool ContactDetailsProto::_internal_has_contact_details_section_title() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_contact_details_section_title() const {
  return _internal_has_contact_details_section_title();
}
inline void ContactDetailsProto::clear_contact_details_section_title() {
  contact_details_section_title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContactDetailsProto::contact_details_section_title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.contact_details_section_title)
  return _internal_contact_details_section_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactDetailsProto::set_contact_details_section_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 contact_details_section_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.contact_details_section_title)
}
inline std::string* ContactDetailsProto::mutable_contact_details_section_title() {
  std::string* _s = _internal_mutable_contact_details_section_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ContactDetailsProto.contact_details_section_title)
  return _s;
}
inline const std::string& ContactDetailsProto::_internal_contact_details_section_title() const {
  return contact_details_section_title_.Get();
}
inline void ContactDetailsProto::_internal_set_contact_details_section_title(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  contact_details_section_title_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactDetailsProto::_internal_mutable_contact_details_section_title() {
  _has_bits_[0] |= 0x00000002u;
  return contact_details_section_title_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactDetailsProto::release_contact_details_section_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ContactDetailsProto.contact_details_section_title)
  if (!_internal_has_contact_details_section_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = contact_details_section_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contact_details_section_title_.IsDefault()) {
    contact_details_section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactDetailsProto::set_allocated_contact_details_section_title(std::string* contact_details_section_title) {
  if (contact_details_section_title != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  contact_details_section_title_.SetAllocated(contact_details_section_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contact_details_section_title_.IsDefault()) {
    contact_details_section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ContactDetailsProto.contact_details_section_title)
}

// repeated .autofill_assistant.RequiredDataPiece required_data_piece = 10;
inline int ContactDetailsProto::_internal_required_data_piece_size() const {
  return required_data_piece_.size();
}
inline int ContactDetailsProto::required_data_piece_size() const {
  return _internal_required_data_piece_size();
}
inline ::autofill_assistant::RequiredDataPiece* ContactDetailsProto::mutable_required_data_piece(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ContactDetailsProto.required_data_piece)
  return required_data_piece_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
ContactDetailsProto::mutable_required_data_piece() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ContactDetailsProto.required_data_piece)
  return &required_data_piece_;
}
inline const ::autofill_assistant::RequiredDataPiece& ContactDetailsProto::_internal_required_data_piece(int index) const {
  return required_data_piece_.Get(index);
}
inline const ::autofill_assistant::RequiredDataPiece& ContactDetailsProto::required_data_piece(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.required_data_piece)
  return _internal_required_data_piece(index);
}
inline ::autofill_assistant::RequiredDataPiece* ContactDetailsProto::_internal_add_required_data_piece() {
  return required_data_piece_.Add();
}
inline ::autofill_assistant::RequiredDataPiece* ContactDetailsProto::add_required_data_piece() {
  ::autofill_assistant::RequiredDataPiece* _add = _internal_add_required_data_piece();
  // @@protoc_insertion_point(field_add:autofill_assistant.ContactDetailsProto.required_data_piece)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
ContactDetailsProto::required_data_piece() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ContactDetailsProto.required_data_piece)
  return required_data_piece_;
}

// optional bool separate_phone_number_section = 11;
inline bool ContactDetailsProto::_internal_has_separate_phone_number_section() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_separate_phone_number_section() const {
  return _internal_has_separate_phone_number_section();
}
inline void ContactDetailsProto::clear_separate_phone_number_section() {
  separate_phone_number_section_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ContactDetailsProto::_internal_separate_phone_number_section() const {
  return separate_phone_number_section_;
}
inline bool ContactDetailsProto::separate_phone_number_section() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.separate_phone_number_section)
  return _internal_separate_phone_number_section();
}
inline void ContactDetailsProto::_internal_set_separate_phone_number_section(bool value) {
  _has_bits_[0] |= 0x00000040u;
  separate_phone_number_section_ = value;
}
inline void ContactDetailsProto::set_separate_phone_number_section(bool value) {
  _internal_set_separate_phone_number_section(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.separate_phone_number_section)
}

// optional string phone_number_section_title = 12;
inline bool ContactDetailsProto::_internal_has_phone_number_section_title() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContactDetailsProto::has_phone_number_section_title() const {
  return _internal_has_phone_number_section_title();
}
inline void ContactDetailsProto::clear_phone_number_section_title() {
  phone_number_section_title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContactDetailsProto::phone_number_section_title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.phone_number_section_title)
  return _internal_phone_number_section_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContactDetailsProto::set_phone_number_section_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 phone_number_section_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ContactDetailsProto.phone_number_section_title)
}
inline std::string* ContactDetailsProto::mutable_phone_number_section_title() {
  std::string* _s = _internal_mutable_phone_number_section_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ContactDetailsProto.phone_number_section_title)
  return _s;
}
inline const std::string& ContactDetailsProto::_internal_phone_number_section_title() const {
  return phone_number_section_title_.Get();
}
inline void ContactDetailsProto::_internal_set_phone_number_section_title(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  phone_number_section_title_.Set(value, GetArenaForAllocation());
}
inline std::string* ContactDetailsProto::_internal_mutable_phone_number_section_title() {
  _has_bits_[0] |= 0x00000004u;
  return phone_number_section_title_.Mutable(GetArenaForAllocation());
}
inline std::string* ContactDetailsProto::release_phone_number_section_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ContactDetailsProto.phone_number_section_title)
  if (!_internal_has_phone_number_section_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = phone_number_section_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (phone_number_section_title_.IsDefault()) {
    phone_number_section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ContactDetailsProto::set_allocated_phone_number_section_title(std::string* phone_number_section_title) {
  if (phone_number_section_title != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  phone_number_section_title_.SetAllocated(phone_number_section_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (phone_number_section_title_.IsDefault()) {
    phone_number_section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ContactDetailsProto.phone_number_section_title)
}

// repeated .autofill_assistant.RequiredDataPiece phone_number_required_data_piece = 13;
inline int ContactDetailsProto::_internal_phone_number_required_data_piece_size() const {
  return phone_number_required_data_piece_.size();
}
inline int ContactDetailsProto::phone_number_required_data_piece_size() const {
  return _internal_phone_number_required_data_piece_size();
}
inline ::autofill_assistant::RequiredDataPiece* ContactDetailsProto::mutable_phone_number_required_data_piece(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ContactDetailsProto.phone_number_required_data_piece)
  return phone_number_required_data_piece_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
ContactDetailsProto::mutable_phone_number_required_data_piece() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ContactDetailsProto.phone_number_required_data_piece)
  return &phone_number_required_data_piece_;
}
inline const ::autofill_assistant::RequiredDataPiece& ContactDetailsProto::_internal_phone_number_required_data_piece(int index) const {
  return phone_number_required_data_piece_.Get(index);
}
inline const ::autofill_assistant::RequiredDataPiece& ContactDetailsProto::phone_number_required_data_piece(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ContactDetailsProto.phone_number_required_data_piece)
  return _internal_phone_number_required_data_piece(index);
}
inline ::autofill_assistant::RequiredDataPiece* ContactDetailsProto::_internal_add_phone_number_required_data_piece() {
  return phone_number_required_data_piece_.Add();
}
inline ::autofill_assistant::RequiredDataPiece* ContactDetailsProto::add_phone_number_required_data_piece() {
  ::autofill_assistant::RequiredDataPiece* _add = _internal_add_phone_number_required_data_piece();
  // @@protoc_insertion_point(field_add:autofill_assistant.ContactDetailsProto.phone_number_required_data_piece)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
ContactDetailsProto::phone_number_required_data_piece() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ContactDetailsProto.phone_number_required_data_piece)
  return phone_number_required_data_piece_;
}

// -------------------------------------------------------------------

// LoginDetailsProto_LoginOptionCustomProto

// optional string label = 1;
inline bool LoginDetailsProto_LoginOptionCustomProto::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginDetailsProto_LoginOptionCustomProto::has_label() const {
  return _internal_has_label();
}
inline void LoginDetailsProto_LoginOptionCustomProto::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginDetailsProto_LoginOptionCustomProto::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginDetailsProto_LoginOptionCustomProto::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto.label)
}
inline std::string* LoginDetailsProto_LoginOptionCustomProto::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto.label)
  return _s;
}
inline const std::string& LoginDetailsProto_LoginOptionCustomProto::_internal_label() const {
  return label_.Get();
}
inline void LoginDetailsProto_LoginOptionCustomProto::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionCustomProto::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionCustomProto::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginDetailsProto_LoginOptionCustomProto::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto.label)
}

// -------------------------------------------------------------------

// LoginDetailsProto_LoginOptionPasswordManagerProto

// -------------------------------------------------------------------

// LoginDetailsProto_LoginOptionProto

// optional .autofill_assistant.InfoPopupProto info_popup = 6;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_info_popup() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || info_popup_ != nullptr);
  return value;
}
inline bool LoginDetailsProto_LoginOptionProto::has_info_popup() const {
  return _internal_has_info_popup();
}
inline const ::autofill_assistant::InfoPopupProto& LoginDetailsProto_LoginOptionProto::_internal_info_popup() const {
  const ::autofill_assistant::InfoPopupProto* p = info_popup_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoPopupProto&>(
      ::autofill_assistant::_InfoPopupProto_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto& LoginDetailsProto_LoginOptionProto::info_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.info_popup)
  return _internal_info_popup();
}
inline void LoginDetailsProto_LoginOptionProto::unsafe_arena_set_allocated_info_popup(
    ::autofill_assistant::InfoPopupProto* info_popup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup_);
  }
  info_popup_ = info_popup;
  if (info_popup) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.info_popup)
}
inline ::autofill_assistant::InfoPopupProto* LoginDetailsProto_LoginOptionProto::release_info_popup() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::InfoPopupProto* temp = info_popup_;
  info_popup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoPopupProto* LoginDetailsProto_LoginOptionProto::unsafe_arena_release_info_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.info_popup)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::InfoPopupProto* temp = info_popup_;
  info_popup_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoPopupProto* LoginDetailsProto_LoginOptionProto::_internal_mutable_info_popup() {
  _has_bits_[0] |= 0x00000008u;
  if (info_popup_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoPopupProto>(GetArenaForAllocation());
    info_popup_ = p;
  }
  return info_popup_;
}
inline ::autofill_assistant::InfoPopupProto* LoginDetailsProto_LoginOptionProto::mutable_info_popup() {
  ::autofill_assistant::InfoPopupProto* _msg = _internal_mutable_info_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.info_popup)
  return _msg;
}
inline void LoginDetailsProto_LoginOptionProto::set_allocated_info_popup(::autofill_assistant::InfoPopupProto* info_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup_);
  }
  if (info_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup));
    if (message_arena != submessage_arena) {
      info_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info_popup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  info_popup_ = info_popup;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.info_popup)
}

// optional string sublabel = 7;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_sublabel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginDetailsProto_LoginOptionProto::has_sublabel() const {
  return _internal_has_sublabel();
}
inline void LoginDetailsProto_LoginOptionProto::clear_sublabel() {
  sublabel_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::sublabel() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel)
  return _internal_sublabel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginDetailsProto_LoginOptionProto::set_sublabel(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sublabel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel)
}
inline std::string* LoginDetailsProto_LoginOptionProto::mutable_sublabel() {
  std::string* _s = _internal_mutable_sublabel();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel)
  return _s;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::_internal_sublabel() const {
  return sublabel_.Get();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_sublabel(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sublabel_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::_internal_mutable_sublabel() {
  _has_bits_[0] |= 0x00000001u;
  return sublabel_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::release_sublabel() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel)
  if (!_internal_has_sublabel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sublabel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sublabel_.IsDefault()) {
    sublabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginDetailsProto_LoginOptionProto::set_allocated_sublabel(std::string* sublabel) {
  if (sublabel != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sublabel_.SetAllocated(sublabel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sublabel_.IsDefault()) {
    sublabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel)
}

// optional string sublabel_accessibility_hint = 8;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_sublabel_accessibility_hint() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginDetailsProto_LoginOptionProto::has_sublabel_accessibility_hint() const {
  return _internal_has_sublabel_accessibility_hint();
}
inline void LoginDetailsProto_LoginOptionProto::clear_sublabel_accessibility_hint() {
  sublabel_accessibility_hint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::sublabel_accessibility_hint() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel_accessibility_hint)
  return _internal_sublabel_accessibility_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginDetailsProto_LoginOptionProto::set_sublabel_accessibility_hint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sublabel_accessibility_hint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel_accessibility_hint)
}
inline std::string* LoginDetailsProto_LoginOptionProto::mutable_sublabel_accessibility_hint() {
  std::string* _s = _internal_mutable_sublabel_accessibility_hint();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel_accessibility_hint)
  return _s;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::_internal_sublabel_accessibility_hint() const {
  return sublabel_accessibility_hint_.Get();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_sublabel_accessibility_hint(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sublabel_accessibility_hint_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::_internal_mutable_sublabel_accessibility_hint() {
  _has_bits_[0] |= 0x00000002u;
  return sublabel_accessibility_hint_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::release_sublabel_accessibility_hint() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel_accessibility_hint)
  if (!_internal_has_sublabel_accessibility_hint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = sublabel_accessibility_hint_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sublabel_accessibility_hint_.IsDefault()) {
    sublabel_accessibility_hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginDetailsProto_LoginOptionProto::set_allocated_sublabel_accessibility_hint(std::string* sublabel_accessibility_hint) {
  if (sublabel_accessibility_hint != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sublabel_accessibility_hint_.SetAllocated(sublabel_accessibility_hint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sublabel_accessibility_hint_.IsDefault()) {
    sublabel_accessibility_hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.sublabel_accessibility_hint)
}

// optional string edit_button_content_description = 10;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_edit_button_content_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoginDetailsProto_LoginOptionProto::has_edit_button_content_description() const {
  return _internal_has_edit_button_content_description();
}
inline void LoginDetailsProto_LoginOptionProto::clear_edit_button_content_description() {
  edit_button_content_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::edit_button_content_description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.edit_button_content_description)
  return _internal_edit_button_content_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginDetailsProto_LoginOptionProto::set_edit_button_content_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 edit_button_content_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.edit_button_content_description)
}
inline std::string* LoginDetailsProto_LoginOptionProto::mutable_edit_button_content_description() {
  std::string* _s = _internal_mutable_edit_button_content_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.edit_button_content_description)
  return _s;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::_internal_edit_button_content_description() const {
  return edit_button_content_description_.Get();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_edit_button_content_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  edit_button_content_description_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::_internal_mutable_edit_button_content_description() {
  _has_bits_[0] |= 0x00000004u;
  return edit_button_content_description_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::release_edit_button_content_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.edit_button_content_description)
  if (!_internal_has_edit_button_content_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = edit_button_content_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (edit_button_content_description_.IsDefault()) {
    edit_button_content_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginDetailsProto_LoginOptionProto::set_allocated_edit_button_content_description(std::string* edit_button_content_description) {
  if (edit_button_content_description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  edit_button_content_description_.SetAllocated(edit_button_content_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (edit_button_content_description_.IsDefault()) {
    edit_button_content_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.edit_button_content_description)
}

// bytes payload = 1;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_payload() const {
  return payload_or_tag_case() == kPayload;
}
inline bool LoginDetailsProto_LoginOptionProto::has_payload() const {
  return _internal_has_payload();
}
inline void LoginDetailsProto_LoginOptionProto::set_has_payload() {
  _oneof_case_[0] = kPayload;
}
inline void LoginDetailsProto_LoginOptionProto::clear_payload() {
  if (_internal_has_payload()) {
    payload_or_tag_.payload_.Destroy();
    clear_has_payload_or_tag();
  }
}
inline const std::string& LoginDetailsProto_LoginOptionProto::payload() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline void LoginDetailsProto_LoginOptionProto::set_payload(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_payload()) {
    clear_payload_or_tag();
    set_has_payload();
    payload_or_tag_.payload_.InitDefault();
  }
  payload_or_tag_.payload_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.payload)
}
inline std::string* LoginDetailsProto_LoginOptionProto::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.payload)
  return _s;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::_internal_payload() const {
  if (_internal_has_payload()) {
    return payload_or_tag_.payload_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_payload(const std::string& value) {
  if (!_internal_has_payload()) {
    clear_payload_or_tag();
    set_has_payload();
    payload_or_tag_.payload_.InitDefault();
  }
  payload_or_tag_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::_internal_mutable_payload() {
  if (!_internal_has_payload()) {
    clear_payload_or_tag();
    set_has_payload();
    payload_or_tag_.payload_.InitDefault();
  }
  return payload_or_tag_.payload_.Mutable(      GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::release_payload() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.payload)
  if (_internal_has_payload()) {
    clear_has_payload_or_tag();
    return payload_or_tag_.payload_.Release();
  } else {
    return nullptr;
  }
}
inline void LoginDetailsProto_LoginOptionProto::set_allocated_payload(std::string* payload) {
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (payload != nullptr) {
    set_has_payload();
    payload_or_tag_.payload_.InitAllocated(payload, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.payload)
}

// string tag = 21;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_tag() const {
  return payload_or_tag_case() == kTag;
}
inline bool LoginDetailsProto_LoginOptionProto::has_tag() const {
  return _internal_has_tag();
}
inline void LoginDetailsProto_LoginOptionProto::set_has_tag() {
  _oneof_case_[0] = kTag;
}
inline void LoginDetailsProto_LoginOptionProto::clear_tag() {
  if (_internal_has_tag()) {
    payload_or_tag_.tag_.Destroy();
    clear_has_payload_or_tag();
  }
}
inline const std::string& LoginDetailsProto_LoginOptionProto::tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline void LoginDetailsProto_LoginOptionProto::set_tag(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tag()) {
    clear_payload_or_tag();
    set_has_tag();
    payload_or_tag_.tag_.InitDefault();
  }
  payload_or_tag_.tag_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.tag)
}
inline std::string* LoginDetailsProto_LoginOptionProto::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.tag)
  return _s;
}
inline const std::string& LoginDetailsProto_LoginOptionProto::_internal_tag() const {
  if (_internal_has_tag()) {
    return payload_or_tag_.tag_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_tag(const std::string& value) {
  if (!_internal_has_tag()) {
    clear_payload_or_tag();
    set_has_tag();
    payload_or_tag_.tag_.InitDefault();
  }
  payload_or_tag_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::_internal_mutable_tag() {
  if (!_internal_has_tag()) {
    clear_payload_or_tag();
    set_has_tag();
    payload_or_tag_.tag_.InitDefault();
  }
  return payload_or_tag_.tag_.Mutable(      GetArenaForAllocation());
}
inline std::string* LoginDetailsProto_LoginOptionProto::release_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.tag)
  if (_internal_has_tag()) {
    clear_has_payload_or_tag();
    return payload_or_tag_.tag_.Release();
  } else {
    return nullptr;
  }
}
inline void LoginDetailsProto_LoginOptionProto::set_allocated_tag(std::string* tag) {
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (tag != nullptr) {
    set_has_tag();
    payload_or_tag_.tag_.InitAllocated(tag, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.tag)
}

// optional bool choose_automatically_if_no_stored_login = 2;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_choose_automatically_if_no_stored_login() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoginDetailsProto_LoginOptionProto::has_choose_automatically_if_no_stored_login() const {
  return _internal_has_choose_automatically_if_no_stored_login();
}
inline void LoginDetailsProto_LoginOptionProto::clear_choose_automatically_if_no_stored_login() {
  choose_automatically_if_no_stored_login_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool LoginDetailsProto_LoginOptionProto::_internal_choose_automatically_if_no_stored_login() const {
  return choose_automatically_if_no_stored_login_;
}
inline bool LoginDetailsProto_LoginOptionProto::choose_automatically_if_no_stored_login() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.choose_automatically_if_no_stored_login)
  return _internal_choose_automatically_if_no_stored_login();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_choose_automatically_if_no_stored_login(bool value) {
  _has_bits_[0] |= 0x00000010u;
  choose_automatically_if_no_stored_login_ = value;
}
inline void LoginDetailsProto_LoginOptionProto::set_choose_automatically_if_no_stored_login(bool value) {
  _internal_set_choose_automatically_if_no_stored_login(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.choose_automatically_if_no_stored_login)
}

// optional int32 preselection_priority = 3;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_preselection_priority() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoginDetailsProto_LoginOptionProto::has_preselection_priority() const {
  return _internal_has_preselection_priority();
}
inline void LoginDetailsProto_LoginOptionProto::clear_preselection_priority() {
  preselection_priority_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t LoginDetailsProto_LoginOptionProto::_internal_preselection_priority() const {
  return preselection_priority_;
}
inline int32_t LoginDetailsProto_LoginOptionProto::preselection_priority() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.preselection_priority)
  return _internal_preselection_priority();
}
inline void LoginDetailsProto_LoginOptionProto::_internal_set_preselection_priority(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  preselection_priority_ = value;
}
inline void LoginDetailsProto_LoginOptionProto::set_preselection_priority(int32_t value) {
  _internal_set_preselection_priority(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.LoginOptionProto.preselection_priority)
}

// .autofill_assistant.LoginDetailsProto.LoginOptionCustomProto custom = 4;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_custom() const {
  return type_case() == kCustom;
}
inline bool LoginDetailsProto_LoginOptionProto::has_custom() const {
  return _internal_has_custom();
}
inline void LoginDetailsProto_LoginOptionProto::set_has_custom() {
  _oneof_case_[1] = kCustom;
}
inline void LoginDetailsProto_LoginOptionProto::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.custom_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* LoginDetailsProto_LoginOptionProto::release_custom() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.custom)
  if (_internal_has_custom()) {
    clear_has_type();
    ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* temp = type_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto& LoginDetailsProto_LoginOptionProto::_internal_custom() const {
  return _internal_has_custom()
      ? *type_.custom_
      : reinterpret_cast< ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto&>(::autofill_assistant::_LoginDetailsProto_LoginOptionCustomProto_default_instance_);
}
inline const ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto& LoginDetailsProto_LoginOptionProto::custom() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.custom)
  return _internal_custom();
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* LoginDetailsProto_LoginOptionProto::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.custom)
  if (_internal_has_custom()) {
    clear_has_type();
    ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* temp = type_.custom_;
    type_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginDetailsProto_LoginOptionProto::unsafe_arena_set_allocated_custom(::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* custom) {
  clear_type();
  if (custom) {
    set_has_custom();
    type_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.custom)
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* LoginDetailsProto_LoginOptionProto::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_type();
    set_has_custom();
    type_.custom_ = CreateMaybeMessage< ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto >(GetArenaForAllocation());
  }
  return type_.custom_;
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* LoginDetailsProto_LoginOptionProto::mutable_custom() {
  ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* _msg = _internal_mutable_custom();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.custom)
  return _msg;
}

// .autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto password_manager = 5;
inline bool LoginDetailsProto_LoginOptionProto::_internal_has_password_manager() const {
  return type_case() == kPasswordManager;
}
inline bool LoginDetailsProto_LoginOptionProto::has_password_manager() const {
  return _internal_has_password_manager();
}
inline void LoginDetailsProto_LoginOptionProto::set_has_password_manager() {
  _oneof_case_[1] = kPasswordManager;
}
inline void LoginDetailsProto_LoginOptionProto::clear_password_manager() {
  if (_internal_has_password_manager()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.password_manager_;
    }
    clear_has_type();
  }
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* LoginDetailsProto_LoginOptionProto::release_password_manager() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.password_manager)
  if (_internal_has_password_manager()) {
    clear_has_type();
    ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* temp = type_.password_manager_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.password_manager_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto& LoginDetailsProto_LoginOptionProto::_internal_password_manager() const {
  return _internal_has_password_manager()
      ? *type_.password_manager_
      : reinterpret_cast< ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto&>(::autofill_assistant::_LoginDetailsProto_LoginOptionPasswordManagerProto_default_instance_);
}
inline const ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto& LoginDetailsProto_LoginOptionProto::password_manager() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.LoginOptionProto.password_manager)
  return _internal_password_manager();
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* LoginDetailsProto_LoginOptionProto::unsafe_arena_release_password_manager() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.LoginDetailsProto.LoginOptionProto.password_manager)
  if (_internal_has_password_manager()) {
    clear_has_type();
    ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* temp = type_.password_manager_;
    type_.password_manager_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginDetailsProto_LoginOptionProto::unsafe_arena_set_allocated_password_manager(::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* password_manager) {
  clear_type();
  if (password_manager) {
    set_has_password_manager();
    type_.password_manager_ = password_manager;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.password_manager)
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* LoginDetailsProto_LoginOptionProto::_internal_mutable_password_manager() {
  if (!_internal_has_password_manager()) {
    clear_type();
    set_has_password_manager();
    type_.password_manager_ = CreateMaybeMessage< ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto >(GetArenaForAllocation());
  }
  return type_.password_manager_;
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* LoginDetailsProto_LoginOptionProto::mutable_password_manager() {
  ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* _msg = _internal_mutable_password_manager();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.LoginOptionProto.password_manager)
  return _msg;
}

inline bool LoginDetailsProto_LoginOptionProto::has_payload_or_tag() const {
  return payload_or_tag_case() != PAYLOAD_OR_TAG_NOT_SET;
}
inline void LoginDetailsProto_LoginOptionProto::clear_has_payload_or_tag() {
  _oneof_case_[0] = PAYLOAD_OR_TAG_NOT_SET;
}
inline bool LoginDetailsProto_LoginOptionProto::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void LoginDetailsProto_LoginOptionProto::clear_has_type() {
  _oneof_case_[1] = TYPE_NOT_SET;
}
inline LoginDetailsProto_LoginOptionProto::PayloadOrTagCase LoginDetailsProto_LoginOptionProto::payload_or_tag_case() const {
  return LoginDetailsProto_LoginOptionProto::PayloadOrTagCase(_oneof_case_[0]);
}
inline LoginDetailsProto_LoginOptionProto::TypeCase LoginDetailsProto_LoginOptionProto::type_case() const {
  return LoginDetailsProto_LoginOptionProto::TypeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// LoginDetailsProto

// optional string section_title = 1;
inline bool LoginDetailsProto::_internal_has_section_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginDetailsProto::has_section_title() const {
  return _internal_has_section_title();
}
inline void LoginDetailsProto::clear_section_title() {
  section_title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginDetailsProto::section_title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.section_title)
  return _internal_section_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginDetailsProto::set_section_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 section_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.LoginDetailsProto.section_title)
}
inline std::string* LoginDetailsProto::mutable_section_title() {
  std::string* _s = _internal_mutable_section_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.section_title)
  return _s;
}
inline const std::string& LoginDetailsProto::_internal_section_title() const {
  return section_title_.Get();
}
inline void LoginDetailsProto::_internal_set_section_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  section_title_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginDetailsProto::_internal_mutable_section_title() {
  _has_bits_[0] |= 0x00000001u;
  return section_title_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginDetailsProto::release_section_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.LoginDetailsProto.section_title)
  if (!_internal_has_section_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = section_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (section_title_.IsDefault()) {
    section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginDetailsProto::set_allocated_section_title(std::string* section_title) {
  if (section_title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  section_title_.SetAllocated(section_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (section_title_.IsDefault()) {
    section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.section_title)
}

// repeated .autofill_assistant.LoginDetailsProto.LoginOptionProto login_options = 2;
inline int LoginDetailsProto::_internal_login_options_size() const {
  return login_options_.size();
}
inline int LoginDetailsProto::login_options_size() const {
  return _internal_login_options_size();
}
inline void LoginDetailsProto::clear_login_options() {
  login_options_.Clear();
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionProto* LoginDetailsProto::mutable_login_options(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.LoginDetailsProto.login_options)
  return login_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginDetailsProto_LoginOptionProto >*
LoginDetailsProto::mutable_login_options() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.LoginDetailsProto.login_options)
  return &login_options_;
}
inline const ::autofill_assistant::LoginDetailsProto_LoginOptionProto& LoginDetailsProto::_internal_login_options(int index) const {
  return login_options_.Get(index);
}
inline const ::autofill_assistant::LoginDetailsProto_LoginOptionProto& LoginDetailsProto::login_options(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LoginDetailsProto.login_options)
  return _internal_login_options(index);
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionProto* LoginDetailsProto::_internal_add_login_options() {
  return login_options_.Add();
}
inline ::autofill_assistant::LoginDetailsProto_LoginOptionProto* LoginDetailsProto::add_login_options() {
  ::autofill_assistant::LoginDetailsProto_LoginOptionProto* _add = _internal_add_login_options();
  // @@protoc_insertion_point(field_add:autofill_assistant.LoginDetailsProto.login_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::LoginDetailsProto_LoginOptionProto >&
LoginDetailsProto::login_options() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.LoginDetailsProto.login_options)
  return login_options_;
}

// -------------------------------------------------------------------

// StaticTextSectionProto

// string text = 1;
inline bool StaticTextSectionProto::_internal_has_text() const {
  return value_case() == kText;
}
inline bool StaticTextSectionProto::has_text() const {
  return _internal_has_text();
}
inline void StaticTextSectionProto::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void StaticTextSectionProto::clear_text() {
  if (_internal_has_text()) {
    value_.text_.Destroy();
    clear_has_value();
  }
}
inline const std::string& StaticTextSectionProto::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.StaticTextSectionProto.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void StaticTextSectionProto::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_value();
    set_has_text();
    value_.text_.InitDefault();
  }
  value_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.StaticTextSectionProto.text)
}
inline std::string* StaticTextSectionProto::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.StaticTextSectionProto.text)
  return _s;
}
inline const std::string& StaticTextSectionProto::_internal_text() const {
  if (_internal_has_text()) {
    return value_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StaticTextSectionProto::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_value();
    set_has_text();
    value_.text_.InitDefault();
  }
  value_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* StaticTextSectionProto::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_value();
    set_has_text();
    value_.text_.InitDefault();
  }
  return value_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* StaticTextSectionProto::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.StaticTextSectionProto.text)
  if (_internal_has_text()) {
    clear_has_value();
    return value_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void StaticTextSectionProto::set_allocated_text(std::string* text) {
  if (has_value()) {
    clear_value();
  }
  if (text != nullptr) {
    set_has_text();
    value_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.StaticTextSectionProto.text)
}

// string client_memory_key = 2;
inline bool StaticTextSectionProto::_internal_has_client_memory_key() const {
  return value_case() == kClientMemoryKey;
}
inline bool StaticTextSectionProto::has_client_memory_key() const {
  return _internal_has_client_memory_key();
}
inline void StaticTextSectionProto::set_has_client_memory_key() {
  _oneof_case_[0] = kClientMemoryKey;
}
inline void StaticTextSectionProto::clear_client_memory_key() {
  if (_internal_has_client_memory_key()) {
    value_.client_memory_key_.Destroy();
    clear_has_value();
  }
}
inline const std::string& StaticTextSectionProto::client_memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.StaticTextSectionProto.client_memory_key)
  return _internal_client_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline void StaticTextSectionProto::set_client_memory_key(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_client_memory_key()) {
    clear_value();
    set_has_client_memory_key();
    value_.client_memory_key_.InitDefault();
  }
  value_.client_memory_key_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.StaticTextSectionProto.client_memory_key)
}
inline std::string* StaticTextSectionProto::mutable_client_memory_key() {
  std::string* _s = _internal_mutable_client_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.StaticTextSectionProto.client_memory_key)
  return _s;
}
inline const std::string& StaticTextSectionProto::_internal_client_memory_key() const {
  if (_internal_has_client_memory_key()) {
    return value_.client_memory_key_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StaticTextSectionProto::_internal_set_client_memory_key(const std::string& value) {
  if (!_internal_has_client_memory_key()) {
    clear_value();
    set_has_client_memory_key();
    value_.client_memory_key_.InitDefault();
  }
  value_.client_memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* StaticTextSectionProto::_internal_mutable_client_memory_key() {
  if (!_internal_has_client_memory_key()) {
    clear_value();
    set_has_client_memory_key();
    value_.client_memory_key_.InitDefault();
  }
  return value_.client_memory_key_.Mutable(      GetArenaForAllocation());
}
inline std::string* StaticTextSectionProto::release_client_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.StaticTextSectionProto.client_memory_key)
  if (_internal_has_client_memory_key()) {
    clear_has_value();
    return value_.client_memory_key_.Release();
  } else {
    return nullptr;
  }
}
inline void StaticTextSectionProto::set_allocated_client_memory_key(std::string* client_memory_key) {
  if (has_value()) {
    clear_value();
  }
  if (client_memory_key != nullptr) {
    set_has_client_memory_key();
    value_.client_memory_key_.InitAllocated(client_memory_key, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.StaticTextSectionProto.client_memory_key)
}

inline bool StaticTextSectionProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void StaticTextSectionProto::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline StaticTextSectionProto::ValueCase StaticTextSectionProto::value_case() const {
  return StaticTextSectionProto::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextInputProto

// optional string hint = 1;
inline bool TextInputProto::_internal_has_hint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextInputProto::has_hint() const {
  return _internal_has_hint();
}
inline void TextInputProto::clear_hint() {
  hint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextInputProto::hint() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputProto.hint)
  return _internal_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextInputProto::set_hint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputProto.hint)
}
inline std::string* TextInputProto::mutable_hint() {
  std::string* _s = _internal_mutable_hint();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextInputProto.hint)
  return _s;
}
inline const std::string& TextInputProto::_internal_hint() const {
  return hint_.Get();
}
inline void TextInputProto::_internal_set_hint(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hint_.Set(value, GetArenaForAllocation());
}
inline std::string* TextInputProto::_internal_mutable_hint() {
  _has_bits_[0] |= 0x00000001u;
  return hint_.Mutable(GetArenaForAllocation());
}
inline std::string* TextInputProto::release_hint() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextInputProto.hint)
  if (!_internal_has_hint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hint_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hint_.IsDefault()) {
    hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextInputProto::set_allocated_hint(std::string* hint) {
  if (hint != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hint_.SetAllocated(hint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hint_.IsDefault()) {
    hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextInputProto.hint)
}

// optional .autofill_assistant.TextInputProto.InputType input_type = 2;
inline bool TextInputProto::_internal_has_input_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TextInputProto::has_input_type() const {
  return _internal_has_input_type();
}
inline void TextInputProto::clear_input_type() {
  input_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::TextInputProto_InputType TextInputProto::_internal_input_type() const {
  return static_cast< ::autofill_assistant::TextInputProto_InputType >(input_type_);
}
inline ::autofill_assistant::TextInputProto_InputType TextInputProto::input_type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputProto.input_type)
  return _internal_input_type();
}
inline void TextInputProto::_internal_set_input_type(::autofill_assistant::TextInputProto_InputType value) {
  assert(::autofill_assistant::TextInputProto_InputType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  input_type_ = value;
}
inline void TextInputProto::set_input_type(::autofill_assistant::TextInputProto_InputType value) {
  _internal_set_input_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputProto.input_type)
}

// optional string client_memory_key = 3;
inline bool TextInputProto::_internal_has_client_memory_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TextInputProto::has_client_memory_key() const {
  return _internal_has_client_memory_key();
}
inline void TextInputProto::clear_client_memory_key() {
  client_memory_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TextInputProto::client_memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputProto.client_memory_key)
  return _internal_client_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextInputProto::set_client_memory_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 client_memory_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputProto.client_memory_key)
}
inline std::string* TextInputProto::mutable_client_memory_key() {
  std::string* _s = _internal_mutable_client_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextInputProto.client_memory_key)
  return _s;
}
inline const std::string& TextInputProto::_internal_client_memory_key() const {
  return client_memory_key_.Get();
}
inline void TextInputProto::_internal_set_client_memory_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  client_memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* TextInputProto::_internal_mutable_client_memory_key() {
  _has_bits_[0] |= 0x00000002u;
  return client_memory_key_.Mutable(GetArenaForAllocation());
}
inline std::string* TextInputProto::release_client_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextInputProto.client_memory_key)
  if (!_internal_has_client_memory_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = client_memory_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_memory_key_.IsDefault()) {
    client_memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextInputProto::set_allocated_client_memory_key(std::string* client_memory_key) {
  if (client_memory_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_memory_key_.SetAllocated(client_memory_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_memory_key_.IsDefault()) {
    client_memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextInputProto.client_memory_key)
}

// optional string value = 4;
inline bool TextInputProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TextInputProto::has_value() const {
  return _internal_has_value();
}
inline void TextInputProto::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TextInputProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputProto.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextInputProto::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputProto.value)
}
inline std::string* TextInputProto::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextInputProto.value)
  return _s;
}
inline const std::string& TextInputProto::_internal_value() const {
  return value_.Get();
}
inline void TextInputProto::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* TextInputProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000004u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* TextInputProto::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextInputProto.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextInputProto::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextInputProto.value)
}

// -------------------------------------------------------------------

// TextInputSectionProto

// repeated .autofill_assistant.TextInputProto input_fields = 1;
inline int TextInputSectionProto::_internal_input_fields_size() const {
  return input_fields_.size();
}
inline int TextInputSectionProto::input_fields_size() const {
  return _internal_input_fields_size();
}
inline void TextInputSectionProto::clear_input_fields() {
  input_fields_.Clear();
}
inline ::autofill_assistant::TextInputProto* TextInputSectionProto::mutable_input_fields(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextInputSectionProto.input_fields)
  return input_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TextInputProto >*
TextInputSectionProto::mutable_input_fields() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.TextInputSectionProto.input_fields)
  return &input_fields_;
}
inline const ::autofill_assistant::TextInputProto& TextInputSectionProto::_internal_input_fields(int index) const {
  return input_fields_.Get(index);
}
inline const ::autofill_assistant::TextInputProto& TextInputSectionProto::input_fields(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputSectionProto.input_fields)
  return _internal_input_fields(index);
}
inline ::autofill_assistant::TextInputProto* TextInputSectionProto::_internal_add_input_fields() {
  return input_fields_.Add();
}
inline ::autofill_assistant::TextInputProto* TextInputSectionProto::add_input_fields() {
  ::autofill_assistant::TextInputProto* _add = _internal_add_input_fields();
  // @@protoc_insertion_point(field_add:autofill_assistant.TextInputSectionProto.input_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::TextInputProto >&
TextInputSectionProto::input_fields() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.TextInputSectionProto.input_fields)
  return input_fields_;
}

// -------------------------------------------------------------------

// UserFormSectionProto

// optional string title = 1;
inline bool UserFormSectionProto::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserFormSectionProto::has_title() const {
  return _internal_has_title();
}
inline void UserFormSectionProto::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserFormSectionProto::title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserFormSectionProto.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserFormSectionProto::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.UserFormSectionProto.title)
}
inline std::string* UserFormSectionProto::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserFormSectionProto.title)
  return _s;
}
inline const std::string& UserFormSectionProto::_internal_title() const {
  return title_.Get();
}
inline void UserFormSectionProto::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* UserFormSectionProto::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* UserFormSectionProto::release_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserFormSectionProto.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserFormSectionProto::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserFormSectionProto.title)
}

// .autofill_assistant.StaticTextSectionProto static_text_section = 2;
inline bool UserFormSectionProto::_internal_has_static_text_section() const {
  return section_case() == kStaticTextSection;
}
inline bool UserFormSectionProto::has_static_text_section() const {
  return _internal_has_static_text_section();
}
inline void UserFormSectionProto::set_has_static_text_section() {
  _oneof_case_[0] = kStaticTextSection;
}
inline void UserFormSectionProto::clear_static_text_section() {
  if (_internal_has_static_text_section()) {
    if (GetArenaForAllocation() == nullptr) {
      delete section_.static_text_section_;
    }
    clear_has_section();
  }
}
inline ::autofill_assistant::StaticTextSectionProto* UserFormSectionProto::release_static_text_section() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserFormSectionProto.static_text_section)
  if (_internal_has_static_text_section()) {
    clear_has_section();
    ::autofill_assistant::StaticTextSectionProto* temp = section_.static_text_section_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    section_.static_text_section_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::StaticTextSectionProto& UserFormSectionProto::_internal_static_text_section() const {
  return _internal_has_static_text_section()
      ? *section_.static_text_section_
      : reinterpret_cast< ::autofill_assistant::StaticTextSectionProto&>(::autofill_assistant::_StaticTextSectionProto_default_instance_);
}
inline const ::autofill_assistant::StaticTextSectionProto& UserFormSectionProto::static_text_section() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserFormSectionProto.static_text_section)
  return _internal_static_text_section();
}
inline ::autofill_assistant::StaticTextSectionProto* UserFormSectionProto::unsafe_arena_release_static_text_section() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.UserFormSectionProto.static_text_section)
  if (_internal_has_static_text_section()) {
    clear_has_section();
    ::autofill_assistant::StaticTextSectionProto* temp = section_.static_text_section_;
    section_.static_text_section_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserFormSectionProto::unsafe_arena_set_allocated_static_text_section(::autofill_assistant::StaticTextSectionProto* static_text_section) {
  clear_section();
  if (static_text_section) {
    set_has_static_text_section();
    section_.static_text_section_ = static_text_section;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UserFormSectionProto.static_text_section)
}
inline ::autofill_assistant::StaticTextSectionProto* UserFormSectionProto::_internal_mutable_static_text_section() {
  if (!_internal_has_static_text_section()) {
    clear_section();
    set_has_static_text_section();
    section_.static_text_section_ = CreateMaybeMessage< ::autofill_assistant::StaticTextSectionProto >(GetArenaForAllocation());
  }
  return section_.static_text_section_;
}
inline ::autofill_assistant::StaticTextSectionProto* UserFormSectionProto::mutable_static_text_section() {
  ::autofill_assistant::StaticTextSectionProto* _msg = _internal_mutable_static_text_section();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserFormSectionProto.static_text_section)
  return _msg;
}

// .autofill_assistant.TextInputSectionProto text_input_section = 3;
inline bool UserFormSectionProto::_internal_has_text_input_section() const {
  return section_case() == kTextInputSection;
}
inline bool UserFormSectionProto::has_text_input_section() const {
  return _internal_has_text_input_section();
}
inline void UserFormSectionProto::set_has_text_input_section() {
  _oneof_case_[0] = kTextInputSection;
}
inline void UserFormSectionProto::clear_text_input_section() {
  if (_internal_has_text_input_section()) {
    if (GetArenaForAllocation() == nullptr) {
      delete section_.text_input_section_;
    }
    clear_has_section();
  }
}
inline ::autofill_assistant::TextInputSectionProto* UserFormSectionProto::release_text_input_section() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserFormSectionProto.text_input_section)
  if (_internal_has_text_input_section()) {
    clear_has_section();
    ::autofill_assistant::TextInputSectionProto* temp = section_.text_input_section_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    section_.text_input_section_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextInputSectionProto& UserFormSectionProto::_internal_text_input_section() const {
  return _internal_has_text_input_section()
      ? *section_.text_input_section_
      : reinterpret_cast< ::autofill_assistant::TextInputSectionProto&>(::autofill_assistant::_TextInputSectionProto_default_instance_);
}
inline const ::autofill_assistant::TextInputSectionProto& UserFormSectionProto::text_input_section() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserFormSectionProto.text_input_section)
  return _internal_text_input_section();
}
inline ::autofill_assistant::TextInputSectionProto* UserFormSectionProto::unsafe_arena_release_text_input_section() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.UserFormSectionProto.text_input_section)
  if (_internal_has_text_input_section()) {
    clear_has_section();
    ::autofill_assistant::TextInputSectionProto* temp = section_.text_input_section_;
    section_.text_input_section_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserFormSectionProto::unsafe_arena_set_allocated_text_input_section(::autofill_assistant::TextInputSectionProto* text_input_section) {
  clear_section();
  if (text_input_section) {
    set_has_text_input_section();
    section_.text_input_section_ = text_input_section;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UserFormSectionProto.text_input_section)
}
inline ::autofill_assistant::TextInputSectionProto* UserFormSectionProto::_internal_mutable_text_input_section() {
  if (!_internal_has_text_input_section()) {
    clear_section();
    set_has_text_input_section();
    section_.text_input_section_ = CreateMaybeMessage< ::autofill_assistant::TextInputSectionProto >(GetArenaForAllocation());
  }
  return section_.text_input_section_;
}
inline ::autofill_assistant::TextInputSectionProto* UserFormSectionProto::mutable_text_input_section() {
  ::autofill_assistant::TextInputSectionProto* _msg = _internal_mutable_text_input_section();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserFormSectionProto.text_input_section)
  return _msg;
}

// .autofill_assistant.PopupListSectionProto popup_list_section = 4;
inline bool UserFormSectionProto::_internal_has_popup_list_section() const {
  return section_case() == kPopupListSection;
}
inline bool UserFormSectionProto::has_popup_list_section() const {
  return _internal_has_popup_list_section();
}
inline void UserFormSectionProto::set_has_popup_list_section() {
  _oneof_case_[0] = kPopupListSection;
}
inline void UserFormSectionProto::clear_popup_list_section() {
  if (_internal_has_popup_list_section()) {
    if (GetArenaForAllocation() == nullptr) {
      delete section_.popup_list_section_;
    }
    clear_has_section();
  }
}
inline ::autofill_assistant::PopupListSectionProto* UserFormSectionProto::release_popup_list_section() {
  // @@protoc_insertion_point(field_release:autofill_assistant.UserFormSectionProto.popup_list_section)
  if (_internal_has_popup_list_section()) {
    clear_has_section();
    ::autofill_assistant::PopupListSectionProto* temp = section_.popup_list_section_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    section_.popup_list_section_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::PopupListSectionProto& UserFormSectionProto::_internal_popup_list_section() const {
  return _internal_has_popup_list_section()
      ? *section_.popup_list_section_
      : reinterpret_cast< ::autofill_assistant::PopupListSectionProto&>(::autofill_assistant::_PopupListSectionProto_default_instance_);
}
inline const ::autofill_assistant::PopupListSectionProto& UserFormSectionProto::popup_list_section() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserFormSectionProto.popup_list_section)
  return _internal_popup_list_section();
}
inline ::autofill_assistant::PopupListSectionProto* UserFormSectionProto::unsafe_arena_release_popup_list_section() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.UserFormSectionProto.popup_list_section)
  if (_internal_has_popup_list_section()) {
    clear_has_section();
    ::autofill_assistant::PopupListSectionProto* temp = section_.popup_list_section_;
    section_.popup_list_section_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserFormSectionProto::unsafe_arena_set_allocated_popup_list_section(::autofill_assistant::PopupListSectionProto* popup_list_section) {
  clear_section();
  if (popup_list_section) {
    set_has_popup_list_section();
    section_.popup_list_section_ = popup_list_section;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.UserFormSectionProto.popup_list_section)
}
inline ::autofill_assistant::PopupListSectionProto* UserFormSectionProto::_internal_mutable_popup_list_section() {
  if (!_internal_has_popup_list_section()) {
    clear_section();
    set_has_popup_list_section();
    section_.popup_list_section_ = CreateMaybeMessage< ::autofill_assistant::PopupListSectionProto >(GetArenaForAllocation());
  }
  return section_.popup_list_section_;
}
inline ::autofill_assistant::PopupListSectionProto* UserFormSectionProto::mutable_popup_list_section() {
  ::autofill_assistant::PopupListSectionProto* _msg = _internal_mutable_popup_list_section();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.UserFormSectionProto.popup_list_section)
  return _msg;
}

// optional bool send_result_to_backend = 5;
inline bool UserFormSectionProto::_internal_has_send_result_to_backend() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserFormSectionProto::has_send_result_to_backend() const {
  return _internal_has_send_result_to_backend();
}
inline void UserFormSectionProto::clear_send_result_to_backend() {
  send_result_to_backend_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool UserFormSectionProto::_internal_send_result_to_backend() const {
  return send_result_to_backend_;
}
inline bool UserFormSectionProto::send_result_to_backend() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.UserFormSectionProto.send_result_to_backend)
  return _internal_send_result_to_backend();
}
inline void UserFormSectionProto::_internal_set_send_result_to_backend(bool value) {
  _has_bits_[0] |= 0x00000002u;
  send_result_to_backend_ = value;
}
inline void UserFormSectionProto::set_send_result_to_backend(bool value) {
  _internal_set_send_result_to_backend(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.UserFormSectionProto.send_result_to_backend)
}

inline bool UserFormSectionProto::has_section() const {
  return section_case() != SECTION_NOT_SET;
}
inline void UserFormSectionProto::clear_has_section() {
  _oneof_case_[0] = SECTION_NOT_SET;
}
inline UserFormSectionProto::SectionCase UserFormSectionProto::section_case() const {
  return UserFormSectionProto::SectionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PopupListSectionProto

// optional string additional_value_key = 1;
inline bool PopupListSectionProto::_internal_has_additional_value_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PopupListSectionProto::has_additional_value_key() const {
  return _internal_has_additional_value_key();
}
inline void PopupListSectionProto::clear_additional_value_key() {
  additional_value_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PopupListSectionProto::additional_value_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupListSectionProto.additional_value_key)
  return _internal_additional_value_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PopupListSectionProto::set_additional_value_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 additional_value_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.additional_value_key)
}
inline std::string* PopupListSectionProto::mutable_additional_value_key() {
  std::string* _s = _internal_mutable_additional_value_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PopupListSectionProto.additional_value_key)
  return _s;
}
inline const std::string& PopupListSectionProto::_internal_additional_value_key() const {
  return additional_value_key_.Get();
}
inline void PopupListSectionProto::_internal_set_additional_value_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  additional_value_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PopupListSectionProto::_internal_mutable_additional_value_key() {
  _has_bits_[0] |= 0x00000001u;
  return additional_value_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PopupListSectionProto::release_additional_value_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PopupListSectionProto.additional_value_key)
  if (!_internal_has_additional_value_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = additional_value_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (additional_value_key_.IsDefault()) {
    additional_value_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PopupListSectionProto::set_allocated_additional_value_key(std::string* additional_value_key) {
  if (additional_value_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  additional_value_key_.SetAllocated(additional_value_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (additional_value_key_.IsDefault()) {
    additional_value_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PopupListSectionProto.additional_value_key)
}

// repeated string item_names = 2;
inline int PopupListSectionProto::_internal_item_names_size() const {
  return item_names_.size();
}
inline int PopupListSectionProto::item_names_size() const {
  return _internal_item_names_size();
}
inline void PopupListSectionProto::clear_item_names() {
  item_names_.Clear();
}
inline std::string* PopupListSectionProto::add_item_names() {
  std::string* _s = _internal_add_item_names();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.PopupListSectionProto.item_names)
  return _s;
}
inline const std::string& PopupListSectionProto::_internal_item_names(int index) const {
  return item_names_.Get(index);
}
inline const std::string& PopupListSectionProto::item_names(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupListSectionProto.item_names)
  return _internal_item_names(index);
}
inline std::string* PopupListSectionProto::mutable_item_names(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PopupListSectionProto.item_names)
  return item_names_.Mutable(index);
}
inline void PopupListSectionProto::set_item_names(int index, const std::string& value) {
  item_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.item_names)
}
inline void PopupListSectionProto::set_item_names(int index, std::string&& value) {
  item_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.item_names)
}
inline void PopupListSectionProto::set_item_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  item_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.PopupListSectionProto.item_names)
}
inline void PopupListSectionProto::set_item_names(int index, const char* value, size_t size) {
  item_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.PopupListSectionProto.item_names)
}
inline std::string* PopupListSectionProto::_internal_add_item_names() {
  return item_names_.Add();
}
inline void PopupListSectionProto::add_item_names(const std::string& value) {
  item_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.PopupListSectionProto.item_names)
}
inline void PopupListSectionProto::add_item_names(std::string&& value) {
  item_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.PopupListSectionProto.item_names)
}
inline void PopupListSectionProto::add_item_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  item_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.PopupListSectionProto.item_names)
}
inline void PopupListSectionProto::add_item_names(const char* value, size_t size) {
  item_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.PopupListSectionProto.item_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PopupListSectionProto::item_names() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.PopupListSectionProto.item_names)
  return item_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PopupListSectionProto::mutable_item_names() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.PopupListSectionProto.item_names)
  return &item_names_;
}

// repeated int32 initial_selection = 3;
inline int PopupListSectionProto::_internal_initial_selection_size() const {
  return initial_selection_.size();
}
inline int PopupListSectionProto::initial_selection_size() const {
  return _internal_initial_selection_size();
}
inline void PopupListSectionProto::clear_initial_selection() {
  initial_selection_.Clear();
}
inline int32_t PopupListSectionProto::_internal_initial_selection(int index) const {
  return initial_selection_.Get(index);
}
inline int32_t PopupListSectionProto::initial_selection(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupListSectionProto.initial_selection)
  return _internal_initial_selection(index);
}
inline void PopupListSectionProto::set_initial_selection(int index, int32_t value) {
  initial_selection_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.initial_selection)
}
inline void PopupListSectionProto::_internal_add_initial_selection(int32_t value) {
  initial_selection_.Add(value);
}
inline void PopupListSectionProto::add_initial_selection(int32_t value) {
  _internal_add_initial_selection(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.PopupListSectionProto.initial_selection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PopupListSectionProto::_internal_initial_selection() const {
  return initial_selection_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PopupListSectionProto::initial_selection() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.PopupListSectionProto.initial_selection)
  return _internal_initial_selection();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PopupListSectionProto::_internal_mutable_initial_selection() {
  return &initial_selection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PopupListSectionProto::mutable_initial_selection() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.PopupListSectionProto.initial_selection)
  return _internal_mutable_initial_selection();
}

// optional bool allow_multiselect = 4;
inline bool PopupListSectionProto::_internal_has_allow_multiselect() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PopupListSectionProto::has_allow_multiselect() const {
  return _internal_has_allow_multiselect();
}
inline void PopupListSectionProto::clear_allow_multiselect() {
  allow_multiselect_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PopupListSectionProto::_internal_allow_multiselect() const {
  return allow_multiselect_;
}
inline bool PopupListSectionProto::allow_multiselect() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupListSectionProto.allow_multiselect)
  return _internal_allow_multiselect();
}
inline void PopupListSectionProto::_internal_set_allow_multiselect(bool value) {
  _has_bits_[0] |= 0x00000004u;
  allow_multiselect_ = value;
}
inline void PopupListSectionProto::set_allow_multiselect(bool value) {
  _internal_set_allow_multiselect(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.allow_multiselect)
}

// optional bool selection_mandatory = 5 [default = true];
inline bool PopupListSectionProto::_internal_has_selection_mandatory() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PopupListSectionProto::has_selection_mandatory() const {
  return _internal_has_selection_mandatory();
}
inline void PopupListSectionProto::clear_selection_mandatory() {
  selection_mandatory_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PopupListSectionProto::_internal_selection_mandatory() const {
  return selection_mandatory_;
}
inline bool PopupListSectionProto::selection_mandatory() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupListSectionProto.selection_mandatory)
  return _internal_selection_mandatory();
}
inline void PopupListSectionProto::_internal_set_selection_mandatory(bool value) {
  _has_bits_[0] |= 0x00000008u;
  selection_mandatory_ = value;
}
inline void PopupListSectionProto::set_selection_mandatory(bool value) {
  _internal_set_selection_mandatory(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.selection_mandatory)
}

// optional string no_selection_error_message = 6;
inline bool PopupListSectionProto::_internal_has_no_selection_error_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PopupListSectionProto::has_no_selection_error_message() const {
  return _internal_has_no_selection_error_message();
}
inline void PopupListSectionProto::clear_no_selection_error_message() {
  no_selection_error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PopupListSectionProto::no_selection_error_message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupListSectionProto.no_selection_error_message)
  return _internal_no_selection_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PopupListSectionProto::set_no_selection_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 no_selection_error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupListSectionProto.no_selection_error_message)
}
inline std::string* PopupListSectionProto::mutable_no_selection_error_message() {
  std::string* _s = _internal_mutable_no_selection_error_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PopupListSectionProto.no_selection_error_message)
  return _s;
}
inline const std::string& PopupListSectionProto::_internal_no_selection_error_message() const {
  return no_selection_error_message_.Get();
}
inline void PopupListSectionProto::_internal_set_no_selection_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  no_selection_error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* PopupListSectionProto::_internal_mutable_no_selection_error_message() {
  _has_bits_[0] |= 0x00000002u;
  return no_selection_error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* PopupListSectionProto::release_no_selection_error_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PopupListSectionProto.no_selection_error_message)
  if (!_internal_has_no_selection_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = no_selection_error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (no_selection_error_message_.IsDefault()) {
    no_selection_error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PopupListSectionProto::set_allocated_no_selection_error_message(std::string* no_selection_error_message) {
  if (no_selection_error_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  no_selection_error_message_.SetAllocated(no_selection_error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (no_selection_error_message_.IsDefault()) {
    no_selection_error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PopupListSectionProto.no_selection_error_message)
}

// -------------------------------------------------------------------

// AutofillEntryProto

// optional string value = 1;
inline bool AutofillEntryProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillEntryProto::has_value() const {
  return _internal_has_value();
}
inline void AutofillEntryProto::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillEntryProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillEntryProto.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillEntryProto::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillEntryProto.value)
}
inline std::string* AutofillEntryProto::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.AutofillEntryProto.value)
  return _s;
}
inline const std::string& AutofillEntryProto::_internal_value() const {
  return value_.Get();
}
inline void AutofillEntryProto::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillEntryProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillEntryProto::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.AutofillEntryProto.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillEntryProto::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillEntryProto.value)
}

// optional bool raw = 2;
inline bool AutofillEntryProto::_internal_has_raw() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillEntryProto::has_raw() const {
  return _internal_has_raw();
}
inline void AutofillEntryProto::clear_raw() {
  raw_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AutofillEntryProto::_internal_raw() const {
  return raw_;
}
inline bool AutofillEntryProto::raw() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.AutofillEntryProto.raw)
  return _internal_raw();
}
inline void AutofillEntryProto::_internal_set_raw(bool value) {
  _has_bits_[0] |= 0x00000002u;
  raw_ = value;
}
inline void AutofillEntryProto::set_raw(bool value) {
  _internal_set_raw(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.AutofillEntryProto.raw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProfileProto

// map<int32, .autofill_assistant.AutofillEntryProto> values = 2;
inline int ProfileProto::_internal_values_size() const {
  return values_.size();
}
inline int ProfileProto::values_size() const {
  return _internal_values_size();
}
inline void ProfileProto::clear_values() {
  values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
ProfileProto::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
ProfileProto::values() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.ProfileProto.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
ProfileProto::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
ProfileProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.ProfileProto.values)
  return _internal_mutable_values();
}

// optional string identifier = 3;
inline bool ProfileProto::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProfileProto::has_identifier() const {
  return _internal_has_identifier();
}
inline void ProfileProto::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProfileProto::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProfileProto.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileProto::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ProfileProto.identifier)
}
inline std::string* ProfileProto::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProfileProto.identifier)
  return _s;
}
inline const std::string& ProfileProto::_internal_identifier() const {
  return identifier_.Get();
}
inline void ProfileProto::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileProto::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileProto::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProfileProto.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProfileProto::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProfileProto.identifier)
}

// optional bytes edit_token = 4;
inline bool ProfileProto::_internal_has_edit_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProfileProto::has_edit_token() const {
  return _internal_has_edit_token();
}
inline void ProfileProto::clear_edit_token() {
  edit_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProfileProto::edit_token() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ProfileProto.edit_token)
  return _internal_edit_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileProto::set_edit_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 edit_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ProfileProto.edit_token)
}
inline std::string* ProfileProto::mutable_edit_token() {
  std::string* _s = _internal_mutable_edit_token();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ProfileProto.edit_token)
  return _s;
}
inline const std::string& ProfileProto::_internal_edit_token() const {
  return edit_token_.Get();
}
inline void ProfileProto::_internal_set_edit_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  edit_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ProfileProto::_internal_mutable_edit_token() {
  _has_bits_[0] |= 0x00000002u;
  return edit_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ProfileProto::release_edit_token() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ProfileProto.edit_token)
  if (!_internal_has_edit_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = edit_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (edit_token_.IsDefault()) {
    edit_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProfileProto::set_allocated_edit_token(std::string* edit_token) {
  if (edit_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  edit_token_.SetAllocated(edit_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (edit_token_.IsDefault()) {
    edit_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProfileProto.edit_token)
}

// -------------------------------------------------------------------

// PhoneNumberProto

// optional string identifier = 1;
inline bool PhoneNumberProto::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhoneNumberProto::has_identifier() const {
  return _internal_has_identifier();
}
inline void PhoneNumberProto::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneNumberProto::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PhoneNumberProto.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhoneNumberProto::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PhoneNumberProto.identifier)
}
inline std::string* PhoneNumberProto::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PhoneNumberProto.identifier)
  return _s;
}
inline const std::string& PhoneNumberProto::_internal_identifier() const {
  return identifier_.Get();
}
inline void PhoneNumberProto::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneNumberProto::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneNumberProto::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PhoneNumberProto.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PhoneNumberProto::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PhoneNumberProto.identifier)
}

// optional .autofill_assistant.AutofillEntryProto value = 2;
inline bool PhoneNumberProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool PhoneNumberProto::has_value() const {
  return _internal_has_value();
}
inline void PhoneNumberProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::AutofillEntryProto& PhoneNumberProto::_internal_value() const {
  const ::autofill_assistant::AutofillEntryProto* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::AutofillEntryProto&>(
      ::autofill_assistant::_AutofillEntryProto_default_instance_);
}
inline const ::autofill_assistant::AutofillEntryProto& PhoneNumberProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PhoneNumberProto.value)
  return _internal_value();
}
inline void PhoneNumberProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::AutofillEntryProto* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.PhoneNumberProto.value)
}
inline ::autofill_assistant::AutofillEntryProto* PhoneNumberProto::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillEntryProto* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::AutofillEntryProto* PhoneNumberProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PhoneNumberProto.value)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::AutofillEntryProto* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::AutofillEntryProto* PhoneNumberProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::AutofillEntryProto>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::AutofillEntryProto* PhoneNumberProto::mutable_value() {
  ::autofill_assistant::AutofillEntryProto* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PhoneNumberProto.value)
  return _msg;
}
inline void PhoneNumberProto::set_allocated_value(::autofill_assistant::AutofillEntryProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PhoneNumberProto.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PaymentInstrumentProto

// map<int32, .autofill_assistant.AutofillEntryProto> card_values = 2;
inline int PaymentInstrumentProto::_internal_card_values_size() const {
  return card_values_.size();
}
inline int PaymentInstrumentProto::card_values_size() const {
  return _internal_card_values_size();
}
inline void PaymentInstrumentProto::clear_card_values() {
  card_values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
PaymentInstrumentProto::_internal_card_values() const {
  return card_values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
PaymentInstrumentProto::card_values() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.PaymentInstrumentProto.card_values)
  return _internal_card_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
PaymentInstrumentProto::_internal_mutable_card_values() {
  return card_values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
PaymentInstrumentProto::mutable_card_values() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.PaymentInstrumentProto.card_values)
  return _internal_mutable_card_values();
}

// optional int64 instrument_id = 7;
inline bool PaymentInstrumentProto::_internal_has_instrument_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PaymentInstrumentProto::has_instrument_id() const {
  return _internal_has_instrument_id();
}
inline void PaymentInstrumentProto::clear_instrument_id() {
  instrument_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t PaymentInstrumentProto::_internal_instrument_id() const {
  return instrument_id_;
}
inline int64_t PaymentInstrumentProto::instrument_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PaymentInstrumentProto.instrument_id)
  return _internal_instrument_id();
}
inline void PaymentInstrumentProto::_internal_set_instrument_id(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  instrument_id_ = value;
}
inline void PaymentInstrumentProto::set_instrument_id(int64_t value) {
  _internal_set_instrument_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.PaymentInstrumentProto.instrument_id)
}

// optional string network = 5;
inline bool PaymentInstrumentProto::_internal_has_network() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentInstrumentProto::has_network() const {
  return _internal_has_network();
}
inline void PaymentInstrumentProto::clear_network() {
  network_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaymentInstrumentProto::network() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PaymentInstrumentProto.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentInstrumentProto::set_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PaymentInstrumentProto.network)
}
inline std::string* PaymentInstrumentProto::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PaymentInstrumentProto.network)
  return _s;
}
inline const std::string& PaymentInstrumentProto::_internal_network() const {
  return network_.Get();
}
inline void PaymentInstrumentProto::_internal_set_network(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  network_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::_internal_mutable_network() {
  _has_bits_[0] |= 0x00000002u;
  return network_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::release_network() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PaymentInstrumentProto.network)
  if (!_internal_has_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = network_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault()) {
    network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentInstrumentProto::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_.IsDefault()) {
    network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PaymentInstrumentProto.network)
}

// optional string last_four_digits = 6;
inline bool PaymentInstrumentProto::_internal_has_last_four_digits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaymentInstrumentProto::has_last_four_digits() const {
  return _internal_has_last_four_digits();
}
inline void PaymentInstrumentProto::clear_last_four_digits() {
  last_four_digits_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PaymentInstrumentProto::last_four_digits() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PaymentInstrumentProto.last_four_digits)
  return _internal_last_four_digits();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentInstrumentProto::set_last_four_digits(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 last_four_digits_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PaymentInstrumentProto.last_four_digits)
}
inline std::string* PaymentInstrumentProto::mutable_last_four_digits() {
  std::string* _s = _internal_mutable_last_four_digits();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PaymentInstrumentProto.last_four_digits)
  return _s;
}
inline const std::string& PaymentInstrumentProto::_internal_last_four_digits() const {
  return last_four_digits_.Get();
}
inline void PaymentInstrumentProto::_internal_set_last_four_digits(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  last_four_digits_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::_internal_mutable_last_four_digits() {
  _has_bits_[0] |= 0x00000004u;
  return last_four_digits_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::release_last_four_digits() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PaymentInstrumentProto.last_four_digits)
  if (!_internal_has_last_four_digits()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = last_four_digits_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_four_digits_.IsDefault()) {
    last_four_digits_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentInstrumentProto::set_allocated_last_four_digits(std::string* last_four_digits) {
  if (last_four_digits != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  last_four_digits_.SetAllocated(last_four_digits, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_four_digits_.IsDefault()) {
    last_four_digits_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PaymentInstrumentProto.last_four_digits)
}

// map<int32, .autofill_assistant.AutofillEntryProto> address_values = 3;
inline int PaymentInstrumentProto::_internal_address_values_size() const {
  return address_values_.size();
}
inline int PaymentInstrumentProto::address_values_size() const {
  return _internal_address_values_size();
}
inline void PaymentInstrumentProto::clear_address_values() {
  address_values_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
PaymentInstrumentProto::_internal_address_values() const {
  return address_values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >&
PaymentInstrumentProto::address_values() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.PaymentInstrumentProto.address_values)
  return _internal_address_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
PaymentInstrumentProto::_internal_mutable_address_values() {
  return address_values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >*
PaymentInstrumentProto::mutable_address_values() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.PaymentInstrumentProto.address_values)
  return _internal_mutable_address_values();
}

// optional string identifier = 4;
inline bool PaymentInstrumentProto::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentInstrumentProto::has_identifier() const {
  return _internal_has_identifier();
}
inline void PaymentInstrumentProto::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentInstrumentProto::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PaymentInstrumentProto.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentInstrumentProto::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PaymentInstrumentProto.identifier)
}
inline std::string* PaymentInstrumentProto::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PaymentInstrumentProto.identifier)
  return _s;
}
inline const std::string& PaymentInstrumentProto::_internal_identifier() const {
  return identifier_.Get();
}
inline void PaymentInstrumentProto::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PaymentInstrumentProto.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentInstrumentProto::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PaymentInstrumentProto.identifier)
}

// optional bytes edit_token = 8;
inline bool PaymentInstrumentProto::_internal_has_edit_token() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PaymentInstrumentProto::has_edit_token() const {
  return _internal_has_edit_token();
}
inline void PaymentInstrumentProto::clear_edit_token() {
  edit_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PaymentInstrumentProto::edit_token() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PaymentInstrumentProto.edit_token)
  return _internal_edit_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentInstrumentProto::set_edit_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 edit_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PaymentInstrumentProto.edit_token)
}
inline std::string* PaymentInstrumentProto::mutable_edit_token() {
  std::string* _s = _internal_mutable_edit_token();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PaymentInstrumentProto.edit_token)
  return _s;
}
inline const std::string& PaymentInstrumentProto::_internal_edit_token() const {
  return edit_token_.Get();
}
inline void PaymentInstrumentProto::_internal_set_edit_token(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  edit_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::_internal_mutable_edit_token() {
  _has_bits_[0] |= 0x00000008u;
  return edit_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentInstrumentProto::release_edit_token() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PaymentInstrumentProto.edit_token)
  if (!_internal_has_edit_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = edit_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (edit_token_.IsDefault()) {
    edit_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentInstrumentProto::set_allocated_edit_token(std::string* edit_token) {
  if (edit_token != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  edit_token_.SetAllocated(edit_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (edit_token_.IsDefault()) {
    edit_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PaymentInstrumentProto.edit_token)
}

// -------------------------------------------------------------------

// DataOriginNoticeProto

// optional string link_text = 1;
inline bool DataOriginNoticeProto::_internal_has_link_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataOriginNoticeProto::has_link_text() const {
  return _internal_has_link_text();
}
inline void DataOriginNoticeProto::clear_link_text() {
  link_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataOriginNoticeProto::link_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DataOriginNoticeProto.link_text)
  return _internal_link_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataOriginNoticeProto::set_link_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 link_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DataOriginNoticeProto.link_text)
}
inline std::string* DataOriginNoticeProto::mutable_link_text() {
  std::string* _s = _internal_mutable_link_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DataOriginNoticeProto.link_text)
  return _s;
}
inline const std::string& DataOriginNoticeProto::_internal_link_text() const {
  return link_text_.Get();
}
inline void DataOriginNoticeProto::_internal_set_link_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  link_text_.Set(value, GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::_internal_mutable_link_text() {
  _has_bits_[0] |= 0x00000001u;
  return link_text_.Mutable(GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::release_link_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DataOriginNoticeProto.link_text)
  if (!_internal_has_link_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = link_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_text_.IsDefault()) {
    link_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataOriginNoticeProto::set_allocated_link_text(std::string* link_text) {
  if (link_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  link_text_.SetAllocated(link_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_text_.IsDefault()) {
    link_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DataOriginNoticeProto.link_text)
}

// optional string dialog_title = 2;
inline bool DataOriginNoticeProto::_internal_has_dialog_title() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataOriginNoticeProto::has_dialog_title() const {
  return _internal_has_dialog_title();
}
inline void DataOriginNoticeProto::clear_dialog_title() {
  dialog_title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataOriginNoticeProto::dialog_title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DataOriginNoticeProto.dialog_title)
  return _internal_dialog_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataOriginNoticeProto::set_dialog_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 dialog_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DataOriginNoticeProto.dialog_title)
}
inline std::string* DataOriginNoticeProto::mutable_dialog_title() {
  std::string* _s = _internal_mutable_dialog_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DataOriginNoticeProto.dialog_title)
  return _s;
}
inline const std::string& DataOriginNoticeProto::_internal_dialog_title() const {
  return dialog_title_.Get();
}
inline void DataOriginNoticeProto::_internal_set_dialog_title(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  dialog_title_.Set(value, GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::_internal_mutable_dialog_title() {
  _has_bits_[0] |= 0x00000002u;
  return dialog_title_.Mutable(GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::release_dialog_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DataOriginNoticeProto.dialog_title)
  if (!_internal_has_dialog_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = dialog_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dialog_title_.IsDefault()) {
    dialog_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataOriginNoticeProto::set_allocated_dialog_title(std::string* dialog_title) {
  if (dialog_title != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dialog_title_.SetAllocated(dialog_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dialog_title_.IsDefault()) {
    dialog_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DataOriginNoticeProto.dialog_title)
}

// optional string dialog_text = 3;
inline bool DataOriginNoticeProto::_internal_has_dialog_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataOriginNoticeProto::has_dialog_text() const {
  return _internal_has_dialog_text();
}
inline void DataOriginNoticeProto::clear_dialog_text() {
  dialog_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataOriginNoticeProto::dialog_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DataOriginNoticeProto.dialog_text)
  return _internal_dialog_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataOriginNoticeProto::set_dialog_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 dialog_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DataOriginNoticeProto.dialog_text)
}
inline std::string* DataOriginNoticeProto::mutable_dialog_text() {
  std::string* _s = _internal_mutable_dialog_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DataOriginNoticeProto.dialog_text)
  return _s;
}
inline const std::string& DataOriginNoticeProto::_internal_dialog_text() const {
  return dialog_text_.Get();
}
inline void DataOriginNoticeProto::_internal_set_dialog_text(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  dialog_text_.Set(value, GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::_internal_mutable_dialog_text() {
  _has_bits_[0] |= 0x00000004u;
  return dialog_text_.Mutable(GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::release_dialog_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DataOriginNoticeProto.dialog_text)
  if (!_internal_has_dialog_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = dialog_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dialog_text_.IsDefault()) {
    dialog_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataOriginNoticeProto::set_allocated_dialog_text(std::string* dialog_text) {
  if (dialog_text != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  dialog_text_.SetAllocated(dialog_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dialog_text_.IsDefault()) {
    dialog_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DataOriginNoticeProto.dialog_text)
}

// optional string dialog_button_text = 4;
inline bool DataOriginNoticeProto::_internal_has_dialog_button_text() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataOriginNoticeProto::has_dialog_button_text() const {
  return _internal_has_dialog_button_text();
}
inline void DataOriginNoticeProto::clear_dialog_button_text() {
  dialog_button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataOriginNoticeProto::dialog_button_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DataOriginNoticeProto.dialog_button_text)
  return _internal_dialog_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataOriginNoticeProto::set_dialog_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 dialog_button_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DataOriginNoticeProto.dialog_button_text)
}
inline std::string* DataOriginNoticeProto::mutable_dialog_button_text() {
  std::string* _s = _internal_mutable_dialog_button_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DataOriginNoticeProto.dialog_button_text)
  return _s;
}
inline const std::string& DataOriginNoticeProto::_internal_dialog_button_text() const {
  return dialog_button_text_.Get();
}
inline void DataOriginNoticeProto::_internal_set_dialog_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  dialog_button_text_.Set(value, GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::_internal_mutable_dialog_button_text() {
  _has_bits_[0] |= 0x00000008u;
  return dialog_button_text_.Mutable(GetArenaForAllocation());
}
inline std::string* DataOriginNoticeProto::release_dialog_button_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DataOriginNoticeProto.dialog_button_text)
  if (!_internal_has_dialog_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = dialog_button_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dialog_button_text_.IsDefault()) {
    dialog_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataOriginNoticeProto::set_allocated_dialog_button_text(std::string* dialog_button_text) {
  if (dialog_button_text != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dialog_button_text_.SetAllocated(dialog_button_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dialog_button_text_.IsDefault()) {
    dialog_button_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DataOriginNoticeProto.dialog_button_text)
}

// -------------------------------------------------------------------

// CollectUserDataProto_DataSource

// optional bool allow_fallback = 1 [default = true];
inline bool CollectUserDataProto_DataSource::_internal_has_allow_fallback() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CollectUserDataProto_DataSource::has_allow_fallback() const {
  return _internal_has_allow_fallback();
}
inline void CollectUserDataProto_DataSource::clear_allow_fallback() {
  allow_fallback_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CollectUserDataProto_DataSource::_internal_allow_fallback() const {
  return allow_fallback_;
}
inline bool CollectUserDataProto_DataSource::allow_fallback() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.DataSource.allow_fallback)
  return _internal_allow_fallback();
}
inline void CollectUserDataProto_DataSource::_internal_set_allow_fallback(bool value) {
  _has_bits_[0] |= 0x00000001u;
  allow_fallback_ = value;
}
inline void CollectUserDataProto_DataSource::set_allow_fallback(bool value) {
  _internal_set_allow_fallback(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.DataSource.allow_fallback)
}

// -------------------------------------------------------------------

// CollectUserDataProto

// optional string prompt = 1;
inline bool CollectUserDataProto::_internal_has_prompt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_prompt() const {
  return _internal_has_prompt();
}
inline void CollectUserDataProto::clear_prompt() {
  prompt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CollectUserDataProto::prompt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.prompt)
  return _internal_prompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_prompt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 prompt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.prompt)
}
inline std::string* CollectUserDataProto::mutable_prompt() {
  std::string* _s = _internal_mutable_prompt();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.prompt)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_prompt() const {
  return prompt_.Get();
}
inline void CollectUserDataProto::_internal_set_prompt(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prompt_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_prompt() {
  _has_bits_[0] |= 0x00000001u;
  return prompt_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_prompt() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.prompt)
  if (!_internal_has_prompt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = prompt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prompt_.IsDefault()) {
    prompt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_prompt(std::string* prompt) {
  if (prompt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prompt_.SetAllocated(prompt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prompt_.IsDefault()) {
    prompt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.prompt)
}

// optional string billing_address_name = 2;
inline bool CollectUserDataProto::_internal_has_billing_address_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_billing_address_name() const {
  return _internal_has_billing_address_name();
}
inline void CollectUserDataProto::clear_billing_address_name() {
  billing_address_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CollectUserDataProto::billing_address_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.billing_address_name)
  return _internal_billing_address_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_billing_address_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 billing_address_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.billing_address_name)
}
inline std::string* CollectUserDataProto::mutable_billing_address_name() {
  std::string* _s = _internal_mutable_billing_address_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.billing_address_name)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_billing_address_name() const {
  return billing_address_name_.Get();
}
inline void CollectUserDataProto::_internal_set_billing_address_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  billing_address_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_billing_address_name() {
  _has_bits_[0] |= 0x00000002u;
  return billing_address_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_billing_address_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.billing_address_name)
  if (!_internal_has_billing_address_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = billing_address_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (billing_address_name_.IsDefault()) {
    billing_address_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_billing_address_name(std::string* billing_address_name) {
  if (billing_address_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  billing_address_name_.SetAllocated(billing_address_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (billing_address_name_.IsDefault()) {
    billing_address_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.billing_address_name)
}

// optional string shipping_address_name = 3;
inline bool CollectUserDataProto::_internal_has_shipping_address_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_shipping_address_name() const {
  return _internal_has_shipping_address_name();
}
inline void CollectUserDataProto::clear_shipping_address_name() {
  shipping_address_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CollectUserDataProto::shipping_address_name() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.shipping_address_name)
  return _internal_shipping_address_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_shipping_address_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 shipping_address_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.shipping_address_name)
}
inline std::string* CollectUserDataProto::mutable_shipping_address_name() {
  std::string* _s = _internal_mutable_shipping_address_name();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.shipping_address_name)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_shipping_address_name() const {
  return shipping_address_name_.Get();
}
inline void CollectUserDataProto::_internal_set_shipping_address_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  shipping_address_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_shipping_address_name() {
  _has_bits_[0] |= 0x00000004u;
  return shipping_address_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_shipping_address_name() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.shipping_address_name)
  if (!_internal_has_shipping_address_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = shipping_address_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shipping_address_name_.IsDefault()) {
    shipping_address_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_shipping_address_name(std::string* shipping_address_name) {
  if (shipping_address_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  shipping_address_name_.SetAllocated(shipping_address_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shipping_address_name_.IsDefault()) {
    shipping_address_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.shipping_address_name)
}

// optional string shipping_address_section_title = 32;
inline bool CollectUserDataProto::_internal_has_shipping_address_section_title() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_shipping_address_section_title() const {
  return _internal_has_shipping_address_section_title();
}
inline void CollectUserDataProto::clear_shipping_address_section_title() {
  shipping_address_section_title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CollectUserDataProto::shipping_address_section_title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.shipping_address_section_title)
  return _internal_shipping_address_section_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_shipping_address_section_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 shipping_address_section_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.shipping_address_section_title)
}
inline std::string* CollectUserDataProto::mutable_shipping_address_section_title() {
  std::string* _s = _internal_mutable_shipping_address_section_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.shipping_address_section_title)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_shipping_address_section_title() const {
  return shipping_address_section_title_.Get();
}
inline void CollectUserDataProto::_internal_set_shipping_address_section_title(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  shipping_address_section_title_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_shipping_address_section_title() {
  _has_bits_[0] |= 0x00000200u;
  return shipping_address_section_title_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_shipping_address_section_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.shipping_address_section_title)
  if (!_internal_has_shipping_address_section_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = shipping_address_section_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shipping_address_section_title_.IsDefault()) {
    shipping_address_section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_shipping_address_section_title(std::string* shipping_address_section_title) {
  if (shipping_address_section_title != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  shipping_address_section_title_.SetAllocated(shipping_address_section_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shipping_address_section_title_.IsDefault()) {
    shipping_address_section_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.shipping_address_section_title)
}

// optional bool request_payment_method = 4;
inline bool CollectUserDataProto::_internal_has_request_payment_method() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_request_payment_method() const {
  return _internal_has_request_payment_method();
}
inline void CollectUserDataProto::clear_request_payment_method() {
  request_payment_method_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool CollectUserDataProto::_internal_request_payment_method() const {
  return request_payment_method_;
}
inline bool CollectUserDataProto::request_payment_method() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.request_payment_method)
  return _internal_request_payment_method();
}
inline void CollectUserDataProto::_internal_set_request_payment_method(bool value) {
  _has_bits_[0] |= 0x00040000u;
  request_payment_method_ = value;
}
inline void CollectUserDataProto::set_request_payment_method(bool value) {
  _internal_set_request_payment_method(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.request_payment_method)
}

// repeated string supported_basic_card_networks = 6;
inline int CollectUserDataProto::_internal_supported_basic_card_networks_size() const {
  return supported_basic_card_networks_.size();
}
inline int CollectUserDataProto::supported_basic_card_networks_size() const {
  return _internal_supported_basic_card_networks_size();
}
inline void CollectUserDataProto::clear_supported_basic_card_networks() {
  supported_basic_card_networks_.Clear();
}
inline std::string* CollectUserDataProto::add_supported_basic_card_networks() {
  std::string* _s = _internal_add_supported_basic_card_networks();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_supported_basic_card_networks(int index) const {
  return supported_basic_card_networks_.Get(index);
}
inline const std::string& CollectUserDataProto::supported_basic_card_networks(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
  return _internal_supported_basic_card_networks(index);
}
inline std::string* CollectUserDataProto::mutable_supported_basic_card_networks(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
  return supported_basic_card_networks_.Mutable(index);
}
inline void CollectUserDataProto::set_supported_basic_card_networks(int index, const std::string& value) {
  supported_basic_card_networks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline void CollectUserDataProto::set_supported_basic_card_networks(int index, std::string&& value) {
  supported_basic_card_networks_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline void CollectUserDataProto::set_supported_basic_card_networks(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_basic_card_networks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline void CollectUserDataProto::set_supported_basic_card_networks(int index, const char* value, size_t size) {
  supported_basic_card_networks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline std::string* CollectUserDataProto::_internal_add_supported_basic_card_networks() {
  return supported_basic_card_networks_.Add();
}
inline void CollectUserDataProto::add_supported_basic_card_networks(const std::string& value) {
  supported_basic_card_networks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline void CollectUserDataProto::add_supported_basic_card_networks(std::string&& value) {
  supported_basic_card_networks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline void CollectUserDataProto::add_supported_basic_card_networks(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_basic_card_networks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline void CollectUserDataProto::add_supported_basic_card_networks(const char* value, size_t size) {
  supported_basic_card_networks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CollectUserDataProto::supported_basic_card_networks() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
  return supported_basic_card_networks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CollectUserDataProto::mutable_supported_basic_card_networks() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.supported_basic_card_networks)
  return &supported_basic_card_networks_;
}

// optional .autofill_assistant.ContactDetailsProto contact_details = 5;
inline bool CollectUserDataProto::_internal_has_contact_details() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || contact_details_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_contact_details() const {
  return _internal_has_contact_details();
}
inline void CollectUserDataProto::clear_contact_details() {
  if (contact_details_ != nullptr) contact_details_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::autofill_assistant::ContactDetailsProto& CollectUserDataProto::_internal_contact_details() const {
  const ::autofill_assistant::ContactDetailsProto* p = contact_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ContactDetailsProto&>(
      ::autofill_assistant::_ContactDetailsProto_default_instance_);
}
inline const ::autofill_assistant::ContactDetailsProto& CollectUserDataProto::contact_details() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.contact_details)
  return _internal_contact_details();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_contact_details(
    ::autofill_assistant::ContactDetailsProto* contact_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(contact_details_);
  }
  contact_details_ = contact_details;
  if (contact_details) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.contact_details)
}
inline ::autofill_assistant::ContactDetailsProto* CollectUserDataProto::release_contact_details() {
  _has_bits_[0] &= ~0x00000400u;
  ::autofill_assistant::ContactDetailsProto* temp = contact_details_;
  contact_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ContactDetailsProto* CollectUserDataProto::unsafe_arena_release_contact_details() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.contact_details)
  _has_bits_[0] &= ~0x00000400u;
  ::autofill_assistant::ContactDetailsProto* temp = contact_details_;
  contact_details_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ContactDetailsProto* CollectUserDataProto::_internal_mutable_contact_details() {
  _has_bits_[0] |= 0x00000400u;
  if (contact_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ContactDetailsProto>(GetArenaForAllocation());
    contact_details_ = p;
  }
  return contact_details_;
}
inline ::autofill_assistant::ContactDetailsProto* CollectUserDataProto::mutable_contact_details() {
  ::autofill_assistant::ContactDetailsProto* _msg = _internal_mutable_contact_details();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.contact_details)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_contact_details(::autofill_assistant::ContactDetailsProto* contact_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete contact_details_;
  }
  if (contact_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contact_details);
    if (message_arena != submessage_arena) {
      contact_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contact_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  contact_details_ = contact_details;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.contact_details)
}

// optional .autofill_assistant.ChipProto confirm_chip = 33;
inline bool CollectUserDataProto::_internal_has_confirm_chip() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || confirm_chip_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_confirm_chip() const {
  return _internal_has_confirm_chip();
}
inline const ::autofill_assistant::ChipProto& CollectUserDataProto::_internal_confirm_chip() const {
  const ::autofill_assistant::ChipProto* p = confirm_chip_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ChipProto&>(
      ::autofill_assistant::_ChipProto_default_instance_);
}
inline const ::autofill_assistant::ChipProto& CollectUserDataProto::confirm_chip() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.confirm_chip)
  return _internal_confirm_chip();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_confirm_chip(
    ::autofill_assistant::ChipProto* confirm_chip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(confirm_chip_);
  }
  confirm_chip_ = confirm_chip;
  if (confirm_chip) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.confirm_chip)
}
inline ::autofill_assistant::ChipProto* CollectUserDataProto::release_confirm_chip() {
  _has_bits_[0] &= ~0x00004000u;
  ::autofill_assistant::ChipProto* temp = confirm_chip_;
  confirm_chip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ChipProto* CollectUserDataProto::unsafe_arena_release_confirm_chip() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.confirm_chip)
  _has_bits_[0] &= ~0x00004000u;
  ::autofill_assistant::ChipProto* temp = confirm_chip_;
  confirm_chip_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ChipProto* CollectUserDataProto::_internal_mutable_confirm_chip() {
  _has_bits_[0] |= 0x00004000u;
  if (confirm_chip_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ChipProto>(GetArenaForAllocation());
    confirm_chip_ = p;
  }
  return confirm_chip_;
}
inline ::autofill_assistant::ChipProto* CollectUserDataProto::mutable_confirm_chip() {
  ::autofill_assistant::ChipProto* _msg = _internal_mutable_confirm_chip();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.confirm_chip)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_confirm_chip(::autofill_assistant::ChipProto* confirm_chip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(confirm_chip_);
  }
  if (confirm_chip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(confirm_chip));
    if (message_arena != submessage_arena) {
      confirm_chip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, confirm_chip, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  confirm_chip_ = confirm_chip;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.confirm_chip)
}

// optional .autofill_assistant.CollectUserDataProto.TermsAndConditionsState terms_and_conditions_state = 8;
inline bool CollectUserDataProto::_internal_has_terms_and_conditions_state() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_terms_and_conditions_state() const {
  return _internal_has_terms_and_conditions_state();
}
inline void CollectUserDataProto::clear_terms_and_conditions_state() {
  terms_and_conditions_state_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::autofill_assistant::CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::_internal_terms_and_conditions_state() const {
  return static_cast< ::autofill_assistant::CollectUserDataProto_TermsAndConditionsState >(terms_and_conditions_state_);
}
inline ::autofill_assistant::CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::terms_and_conditions_state() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.terms_and_conditions_state)
  return _internal_terms_and_conditions_state();
}
inline void CollectUserDataProto::_internal_set_terms_and_conditions_state(::autofill_assistant::CollectUserDataProto_TermsAndConditionsState value) {
  assert(::autofill_assistant::CollectUserDataProto_TermsAndConditionsState_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  terms_and_conditions_state_ = value;
}
inline void CollectUserDataProto::set_terms_and_conditions_state(::autofill_assistant::CollectUserDataProto_TermsAndConditionsState value) {
  _internal_set_terms_and_conditions_state(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.terms_and_conditions_state)
}

// optional bool request_terms_and_conditions = 9 [default = true];
inline bool CollectUserDataProto::_internal_has_request_terms_and_conditions() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_request_terms_and_conditions() const {
  return _internal_has_request_terms_and_conditions();
}
inline void CollectUserDataProto::clear_request_terms_and_conditions() {
  request_terms_and_conditions_ = true;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool CollectUserDataProto::_internal_request_terms_and_conditions() const {
  return request_terms_and_conditions_;
}
inline bool CollectUserDataProto::request_terms_and_conditions() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.request_terms_and_conditions)
  return _internal_request_terms_and_conditions();
}
inline void CollectUserDataProto::_internal_set_request_terms_and_conditions(bool value) {
  _has_bits_[0] |= 0x00800000u;
  request_terms_and_conditions_ = value;
}
inline void CollectUserDataProto::set_request_terms_and_conditions(bool value) {
  _internal_set_request_terms_and_conditions(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.request_terms_and_conditions)
}

// optional bool show_terms_as_checkbox = 12;
inline bool CollectUserDataProto::_internal_has_show_terms_as_checkbox() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_show_terms_as_checkbox() const {
  return _internal_has_show_terms_as_checkbox();
}
inline void CollectUserDataProto::clear_show_terms_as_checkbox() {
  show_terms_as_checkbox_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool CollectUserDataProto::_internal_show_terms_as_checkbox() const {
  return show_terms_as_checkbox_;
}
inline bool CollectUserDataProto::show_terms_as_checkbox() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.show_terms_as_checkbox)
  return _internal_show_terms_as_checkbox();
}
inline void CollectUserDataProto::_internal_set_show_terms_as_checkbox(bool value) {
  _has_bits_[0] |= 0x00080000u;
  show_terms_as_checkbox_ = value;
}
inline void CollectUserDataProto::set_show_terms_as_checkbox(bool value) {
  _internal_set_show_terms_as_checkbox(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.show_terms_as_checkbox)
}

// optional string accept_terms_and_conditions_text = 13;
inline bool CollectUserDataProto::_internal_has_accept_terms_and_conditions_text() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_accept_terms_and_conditions_text() const {
  return _internal_has_accept_terms_and_conditions_text();
}
inline void CollectUserDataProto::clear_accept_terms_and_conditions_text() {
  accept_terms_and_conditions_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CollectUserDataProto::accept_terms_and_conditions_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.accept_terms_and_conditions_text)
  return _internal_accept_terms_and_conditions_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_accept_terms_and_conditions_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 accept_terms_and_conditions_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.accept_terms_and_conditions_text)
}
inline std::string* CollectUserDataProto::mutable_accept_terms_and_conditions_text() {
  std::string* _s = _internal_mutable_accept_terms_and_conditions_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.accept_terms_and_conditions_text)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_accept_terms_and_conditions_text() const {
  return accept_terms_and_conditions_text_.Get();
}
inline void CollectUserDataProto::_internal_set_accept_terms_and_conditions_text(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  accept_terms_and_conditions_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_accept_terms_and_conditions_text() {
  _has_bits_[0] |= 0x00000008u;
  return accept_terms_and_conditions_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_accept_terms_and_conditions_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.accept_terms_and_conditions_text)
  if (!_internal_has_accept_terms_and_conditions_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = accept_terms_and_conditions_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (accept_terms_and_conditions_text_.IsDefault()) {
    accept_terms_and_conditions_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_accept_terms_and_conditions_text(std::string* accept_terms_and_conditions_text) {
  if (accept_terms_and_conditions_text != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  accept_terms_and_conditions_text_.SetAllocated(accept_terms_and_conditions_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (accept_terms_and_conditions_text_.IsDefault()) {
    accept_terms_and_conditions_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.accept_terms_and_conditions_text)
}

// optional string terms_require_review_text = 20;
inline bool CollectUserDataProto::_internal_has_terms_require_review_text() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_terms_require_review_text() const {
  return _internal_has_terms_require_review_text();
}
inline void CollectUserDataProto::clear_terms_require_review_text() {
  terms_require_review_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CollectUserDataProto::terms_require_review_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.terms_require_review_text)
  return _internal_terms_require_review_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_terms_require_review_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 terms_require_review_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.terms_require_review_text)
}
inline std::string* CollectUserDataProto::mutable_terms_require_review_text() {
  std::string* _s = _internal_mutable_terms_require_review_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.terms_require_review_text)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_terms_require_review_text() const {
  return terms_require_review_text_.Get();
}
inline void CollectUserDataProto::_internal_set_terms_require_review_text(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  terms_require_review_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_terms_require_review_text() {
  _has_bits_[0] |= 0x00000010u;
  return terms_require_review_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_terms_require_review_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.terms_require_review_text)
  if (!_internal_has_terms_require_review_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = terms_require_review_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (terms_require_review_text_.IsDefault()) {
    terms_require_review_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_terms_require_review_text(std::string* terms_require_review_text) {
  if (terms_require_review_text != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  terms_require_review_text_.SetAllocated(terms_require_review_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (terms_require_review_text_.IsDefault()) {
    terms_require_review_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.terms_require_review_text)
}

// optional string privacy_notice_text = 21;
inline bool CollectUserDataProto::_internal_has_privacy_notice_text() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_privacy_notice_text() const {
  return _internal_has_privacy_notice_text();
}
inline void CollectUserDataProto::clear_privacy_notice_text() {
  privacy_notice_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CollectUserDataProto::privacy_notice_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.privacy_notice_text)
  return _internal_privacy_notice_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_privacy_notice_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 privacy_notice_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.privacy_notice_text)
}
inline std::string* CollectUserDataProto::mutable_privacy_notice_text() {
  std::string* _s = _internal_mutable_privacy_notice_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.privacy_notice_text)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_privacy_notice_text() const {
  return privacy_notice_text_.Get();
}
inline void CollectUserDataProto::_internal_set_privacy_notice_text(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  privacy_notice_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_privacy_notice_text() {
  _has_bits_[0] |= 0x00000020u;
  return privacy_notice_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_privacy_notice_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.privacy_notice_text)
  if (!_internal_has_privacy_notice_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = privacy_notice_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privacy_notice_text_.IsDefault()) {
    privacy_notice_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_privacy_notice_text(std::string* privacy_notice_text) {
  if (privacy_notice_text != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  privacy_notice_text_.SetAllocated(privacy_notice_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privacy_notice_text_.IsDefault()) {
    privacy_notice_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.privacy_notice_text)
}

// repeated .autofill_assistant.UserActionProto additional_actions = 11;
inline int CollectUserDataProto::_internal_additional_actions_size() const {
  return additional_actions_.size();
}
inline int CollectUserDataProto::additional_actions_size() const {
  return _internal_additional_actions_size();
}
inline ::autofill_assistant::UserActionProto* CollectUserDataProto::mutable_additional_actions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.additional_actions)
  return additional_actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >*
CollectUserDataProto::mutable_additional_actions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.additional_actions)
  return &additional_actions_;
}
inline const ::autofill_assistant::UserActionProto& CollectUserDataProto::_internal_additional_actions(int index) const {
  return additional_actions_.Get(index);
}
inline const ::autofill_assistant::UserActionProto& CollectUserDataProto::additional_actions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.additional_actions)
  return _internal_additional_actions(index);
}
inline ::autofill_assistant::UserActionProto* CollectUserDataProto::_internal_add_additional_actions() {
  return additional_actions_.Add();
}
inline ::autofill_assistant::UserActionProto* CollectUserDataProto::add_additional_actions() {
  ::autofill_assistant::UserActionProto* _add = _internal_add_additional_actions();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.additional_actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserActionProto >&
CollectUserDataProto::additional_actions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.additional_actions)
  return additional_actions_;
}

// optional string credit_card_expired_text = 23;
inline bool CollectUserDataProto::_internal_has_credit_card_expired_text() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_credit_card_expired_text() const {
  return _internal_has_credit_card_expired_text();
}
inline void CollectUserDataProto::clear_credit_card_expired_text() {
  credit_card_expired_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CollectUserDataProto::credit_card_expired_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.credit_card_expired_text)
  return _internal_credit_card_expired_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_credit_card_expired_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 credit_card_expired_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.credit_card_expired_text)
}
inline std::string* CollectUserDataProto::mutable_credit_card_expired_text() {
  std::string* _s = _internal_mutable_credit_card_expired_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.credit_card_expired_text)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_credit_card_expired_text() const {
  return credit_card_expired_text_.Get();
}
inline void CollectUserDataProto::_internal_set_credit_card_expired_text(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  credit_card_expired_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_credit_card_expired_text() {
  _has_bits_[0] |= 0x00000040u;
  return credit_card_expired_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_credit_card_expired_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.credit_card_expired_text)
  if (!_internal_has_credit_card_expired_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = credit_card_expired_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (credit_card_expired_text_.IsDefault()) {
    credit_card_expired_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_credit_card_expired_text(std::string* credit_card_expired_text) {
  if (credit_card_expired_text != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  credit_card_expired_text_.SetAllocated(credit_card_expired_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (credit_card_expired_text_.IsDefault()) {
    credit_card_expired_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.credit_card_expired_text)
}

// optional .autofill_assistant.LoginDetailsProto login_details = 16;
inline bool CollectUserDataProto::_internal_has_login_details() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || login_details_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_login_details() const {
  return _internal_has_login_details();
}
inline void CollectUserDataProto::clear_login_details() {
  if (login_details_ != nullptr) login_details_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::autofill_assistant::LoginDetailsProto& CollectUserDataProto::_internal_login_details() const {
  const ::autofill_assistant::LoginDetailsProto* p = login_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::LoginDetailsProto&>(
      ::autofill_assistant::_LoginDetailsProto_default_instance_);
}
inline const ::autofill_assistant::LoginDetailsProto& CollectUserDataProto::login_details() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.login_details)
  return _internal_login_details();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_login_details(
    ::autofill_assistant::LoginDetailsProto* login_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(login_details_);
  }
  login_details_ = login_details;
  if (login_details) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.login_details)
}
inline ::autofill_assistant::LoginDetailsProto* CollectUserDataProto::release_login_details() {
  _has_bits_[0] &= ~0x00000800u;
  ::autofill_assistant::LoginDetailsProto* temp = login_details_;
  login_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::LoginDetailsProto* CollectUserDataProto::unsafe_arena_release_login_details() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.login_details)
  _has_bits_[0] &= ~0x00000800u;
  ::autofill_assistant::LoginDetailsProto* temp = login_details_;
  login_details_ = nullptr;
  return temp;
}
inline ::autofill_assistant::LoginDetailsProto* CollectUserDataProto::_internal_mutable_login_details() {
  _has_bits_[0] |= 0x00000800u;
  if (login_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::LoginDetailsProto>(GetArenaForAllocation());
    login_details_ = p;
  }
  return login_details_;
}
inline ::autofill_assistant::LoginDetailsProto* CollectUserDataProto::mutable_login_details() {
  ::autofill_assistant::LoginDetailsProto* _msg = _internal_mutable_login_details();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.login_details)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_login_details(::autofill_assistant::LoginDetailsProto* login_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete login_details_;
  }
  if (login_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_details);
    if (message_arena != submessage_arena) {
      login_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  login_details_ = login_details;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.login_details)
}

// optional .autofill_assistant.DataOriginNoticeProto data_origin_notice = 39;
inline bool CollectUserDataProto::_internal_has_data_origin_notice() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || data_origin_notice_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_data_origin_notice() const {
  return _internal_has_data_origin_notice();
}
inline void CollectUserDataProto::clear_data_origin_notice() {
  if (data_origin_notice_ != nullptr) data_origin_notice_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::autofill_assistant::DataOriginNoticeProto& CollectUserDataProto::_internal_data_origin_notice() const {
  const ::autofill_assistant::DataOriginNoticeProto* p = data_origin_notice_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DataOriginNoticeProto&>(
      ::autofill_assistant::_DataOriginNoticeProto_default_instance_);
}
inline const ::autofill_assistant::DataOriginNoticeProto& CollectUserDataProto::data_origin_notice() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.data_origin_notice)
  return _internal_data_origin_notice();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_data_origin_notice(
    ::autofill_assistant::DataOriginNoticeProto* data_origin_notice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_origin_notice_);
  }
  data_origin_notice_ = data_origin_notice;
  if (data_origin_notice) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.data_origin_notice)
}
inline ::autofill_assistant::DataOriginNoticeProto* CollectUserDataProto::release_data_origin_notice() {
  _has_bits_[0] &= ~0x00010000u;
  ::autofill_assistant::DataOriginNoticeProto* temp = data_origin_notice_;
  data_origin_notice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DataOriginNoticeProto* CollectUserDataProto::unsafe_arena_release_data_origin_notice() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.data_origin_notice)
  _has_bits_[0] &= ~0x00010000u;
  ::autofill_assistant::DataOriginNoticeProto* temp = data_origin_notice_;
  data_origin_notice_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DataOriginNoticeProto* CollectUserDataProto::_internal_mutable_data_origin_notice() {
  _has_bits_[0] |= 0x00010000u;
  if (data_origin_notice_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DataOriginNoticeProto>(GetArenaForAllocation());
    data_origin_notice_ = p;
  }
  return data_origin_notice_;
}
inline ::autofill_assistant::DataOriginNoticeProto* CollectUserDataProto::mutable_data_origin_notice() {
  ::autofill_assistant::DataOriginNoticeProto* _msg = _internal_mutable_data_origin_notice();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.data_origin_notice)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_data_origin_notice(::autofill_assistant::DataOriginNoticeProto* data_origin_notice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_origin_notice_;
  }
  if (data_origin_notice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_origin_notice);
    if (message_arena != submessage_arena) {
      data_origin_notice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_origin_notice, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  data_origin_notice_ = data_origin_notice;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.data_origin_notice)
}

// repeated .autofill_assistant.UserFormSectionProto additional_prepended_sections = 18;
inline int CollectUserDataProto::_internal_additional_prepended_sections_size() const {
  return additional_prepended_sections_.size();
}
inline int CollectUserDataProto::additional_prepended_sections_size() const {
  return _internal_additional_prepended_sections_size();
}
inline void CollectUserDataProto::clear_additional_prepended_sections() {
  additional_prepended_sections_.Clear();
}
inline ::autofill_assistant::UserFormSectionProto* CollectUserDataProto::mutable_additional_prepended_sections(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.additional_prepended_sections)
  return additional_prepended_sections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >*
CollectUserDataProto::mutable_additional_prepended_sections() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.additional_prepended_sections)
  return &additional_prepended_sections_;
}
inline const ::autofill_assistant::UserFormSectionProto& CollectUserDataProto::_internal_additional_prepended_sections(int index) const {
  return additional_prepended_sections_.Get(index);
}
inline const ::autofill_assistant::UserFormSectionProto& CollectUserDataProto::additional_prepended_sections(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.additional_prepended_sections)
  return _internal_additional_prepended_sections(index);
}
inline ::autofill_assistant::UserFormSectionProto* CollectUserDataProto::_internal_add_additional_prepended_sections() {
  return additional_prepended_sections_.Add();
}
inline ::autofill_assistant::UserFormSectionProto* CollectUserDataProto::add_additional_prepended_sections() {
  ::autofill_assistant::UserFormSectionProto* _add = _internal_add_additional_prepended_sections();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.additional_prepended_sections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >&
CollectUserDataProto::additional_prepended_sections() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.additional_prepended_sections)
  return additional_prepended_sections_;
}

// repeated .autofill_assistant.UserFormSectionProto additional_appended_sections = 19;
inline int CollectUserDataProto::_internal_additional_appended_sections_size() const {
  return additional_appended_sections_.size();
}
inline int CollectUserDataProto::additional_appended_sections_size() const {
  return _internal_additional_appended_sections_size();
}
inline void CollectUserDataProto::clear_additional_appended_sections() {
  additional_appended_sections_.Clear();
}
inline ::autofill_assistant::UserFormSectionProto* CollectUserDataProto::mutable_additional_appended_sections(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.additional_appended_sections)
  return additional_appended_sections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >*
CollectUserDataProto::mutable_additional_appended_sections() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.additional_appended_sections)
  return &additional_appended_sections_;
}
inline const ::autofill_assistant::UserFormSectionProto& CollectUserDataProto::_internal_additional_appended_sections(int index) const {
  return additional_appended_sections_.Get(index);
}
inline const ::autofill_assistant::UserFormSectionProto& CollectUserDataProto::additional_appended_sections(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.additional_appended_sections)
  return _internal_additional_appended_sections(index);
}
inline ::autofill_assistant::UserFormSectionProto* CollectUserDataProto::_internal_add_additional_appended_sections() {
  return additional_appended_sections_.Add();
}
inline ::autofill_assistant::UserFormSectionProto* CollectUserDataProto::add_additional_appended_sections() {
  ::autofill_assistant::UserFormSectionProto* _add = _internal_add_additional_appended_sections();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.additional_appended_sections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::UserFormSectionProto >&
CollectUserDataProto::additional_appended_sections() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.additional_appended_sections)
  return additional_appended_sections_;
}

// optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_prepended = 22;
inline bool CollectUserDataProto::_internal_has_generic_user_interface_prepended() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || generic_user_interface_prepended_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_generic_user_interface_prepended() const {
  return _internal_has_generic_user_interface_prepended();
}
inline const ::autofill_assistant::GenericUserInterfaceProto& CollectUserDataProto::_internal_generic_user_interface_prepended() const {
  const ::autofill_assistant::GenericUserInterfaceProto* p = generic_user_interface_prepended_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GenericUserInterfaceProto&>(
      ::autofill_assistant::_GenericUserInterfaceProto_default_instance_);
}
inline const ::autofill_assistant::GenericUserInterfaceProto& CollectUserDataProto::generic_user_interface_prepended() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.generic_user_interface_prepended)
  return _internal_generic_user_interface_prepended();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_generic_user_interface_prepended(
    ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_prepended) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_prepended_);
  }
  generic_user_interface_prepended_ = generic_user_interface_prepended;
  if (generic_user_interface_prepended) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.generic_user_interface_prepended)
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::release_generic_user_interface_prepended() {
  _has_bits_[0] &= ~0x00001000u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_prepended_;
  generic_user_interface_prepended_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::unsafe_arena_release_generic_user_interface_prepended() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.generic_user_interface_prepended)
  _has_bits_[0] &= ~0x00001000u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_prepended_;
  generic_user_interface_prepended_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::_internal_mutable_generic_user_interface_prepended() {
  _has_bits_[0] |= 0x00001000u;
  if (generic_user_interface_prepended_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(GetArenaForAllocation());
    generic_user_interface_prepended_ = p;
  }
  return generic_user_interface_prepended_;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::mutable_generic_user_interface_prepended() {
  ::autofill_assistant::GenericUserInterfaceProto* _msg = _internal_mutable_generic_user_interface_prepended();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.generic_user_interface_prepended)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_generic_user_interface_prepended(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_prepended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_prepended_);
  }
  if (generic_user_interface_prepended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_prepended));
    if (message_arena != submessage_arena) {
      generic_user_interface_prepended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_user_interface_prepended, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  generic_user_interface_prepended_ = generic_user_interface_prepended;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.generic_user_interface_prepended)
}

// optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_appended = 25;
inline bool CollectUserDataProto::_internal_has_generic_user_interface_appended() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || generic_user_interface_appended_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_generic_user_interface_appended() const {
  return _internal_has_generic_user_interface_appended();
}
inline const ::autofill_assistant::GenericUserInterfaceProto& CollectUserDataProto::_internal_generic_user_interface_appended() const {
  const ::autofill_assistant::GenericUserInterfaceProto* p = generic_user_interface_appended_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GenericUserInterfaceProto&>(
      ::autofill_assistant::_GenericUserInterfaceProto_default_instance_);
}
inline const ::autofill_assistant::GenericUserInterfaceProto& CollectUserDataProto::generic_user_interface_appended() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.generic_user_interface_appended)
  return _internal_generic_user_interface_appended();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_generic_user_interface_appended(
    ::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_appended) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_appended_);
  }
  generic_user_interface_appended_ = generic_user_interface_appended;
  if (generic_user_interface_appended) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.generic_user_interface_appended)
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::release_generic_user_interface_appended() {
  _has_bits_[0] &= ~0x00002000u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_appended_;
  generic_user_interface_appended_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::unsafe_arena_release_generic_user_interface_appended() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.generic_user_interface_appended)
  _has_bits_[0] &= ~0x00002000u;
  ::autofill_assistant::GenericUserInterfaceProto* temp = generic_user_interface_appended_;
  generic_user_interface_appended_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::_internal_mutable_generic_user_interface_appended() {
  _has_bits_[0] |= 0x00002000u;
  if (generic_user_interface_appended_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GenericUserInterfaceProto>(GetArenaForAllocation());
    generic_user_interface_appended_ = p;
  }
  return generic_user_interface_appended_;
}
inline ::autofill_assistant::GenericUserInterfaceProto* CollectUserDataProto::mutable_generic_user_interface_appended() {
  ::autofill_assistant::GenericUserInterfaceProto* _msg = _internal_mutable_generic_user_interface_appended();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.generic_user_interface_appended)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_generic_user_interface_appended(::autofill_assistant::GenericUserInterfaceProto* generic_user_interface_appended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_appended_);
  }
  if (generic_user_interface_appended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_user_interface_appended));
    if (message_arena != submessage_arena) {
      generic_user_interface_appended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_user_interface_appended, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  generic_user_interface_appended_ = generic_user_interface_appended;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.generic_user_interface_appended)
}

// optional string info_section_text = 24;
inline bool CollectUserDataProto::_internal_has_info_section_text() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_info_section_text() const {
  return _internal_has_info_section_text();
}
inline void CollectUserDataProto::clear_info_section_text() {
  info_section_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CollectUserDataProto::info_section_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.info_section_text)
  return _internal_info_section_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_info_section_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 info_section_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.info_section_text)
}
inline std::string* CollectUserDataProto::mutable_info_section_text() {
  std::string* _s = _internal_mutable_info_section_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.info_section_text)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_info_section_text() const {
  return info_section_text_.Get();
}
inline void CollectUserDataProto::_internal_set_info_section_text(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  info_section_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_info_section_text() {
  _has_bits_[0] |= 0x00000080u;
  return info_section_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_info_section_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.info_section_text)
  if (!_internal_has_info_section_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = info_section_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_section_text_.IsDefault()) {
    info_section_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_info_section_text(std::string* info_section_text) {
  if (info_section_text != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  info_section_text_.SetAllocated(info_section_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_section_text_.IsDefault()) {
    info_section_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.info_section_text)
}

// optional bool info_section_text_center = 31;
inline bool CollectUserDataProto::_internal_has_info_section_text_center() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_info_section_text_center() const {
  return _internal_has_info_section_text_center();
}
inline void CollectUserDataProto::clear_info_section_text_center() {
  info_section_text_center_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool CollectUserDataProto::_internal_info_section_text_center() const {
  return info_section_text_center_;
}
inline bool CollectUserDataProto::info_section_text_center() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.info_section_text_center)
  return _internal_info_section_text_center();
}
inline void CollectUserDataProto::_internal_set_info_section_text_center(bool value) {
  _has_bits_[0] |= 0x00100000u;
  info_section_text_center_ = value;
}
inline void CollectUserDataProto::set_info_section_text_center(bool value) {
  _internal_set_info_section_text_center(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.info_section_text_center)
}

// optional string additional_model_identifier_to_check = 27;
inline bool CollectUserDataProto::_internal_has_additional_model_identifier_to_check() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_additional_model_identifier_to_check() const {
  return _internal_has_additional_model_identifier_to_check();
}
inline void CollectUserDataProto::clear_additional_model_identifier_to_check() {
  additional_model_identifier_to_check_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CollectUserDataProto::additional_model_identifier_to_check() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.additional_model_identifier_to_check)
  return _internal_additional_model_identifier_to_check();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectUserDataProto::set_additional_model_identifier_to_check(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 additional_model_identifier_to_check_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.additional_model_identifier_to_check)
}
inline std::string* CollectUserDataProto::mutable_additional_model_identifier_to_check() {
  std::string* _s = _internal_mutable_additional_model_identifier_to_check();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.additional_model_identifier_to_check)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_additional_model_identifier_to_check() const {
  return additional_model_identifier_to_check_.Get();
}
inline void CollectUserDataProto::_internal_set_additional_model_identifier_to_check(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  additional_model_identifier_to_check_.Set(value, GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::_internal_mutable_additional_model_identifier_to_check() {
  _has_bits_[0] |= 0x00000100u;
  return additional_model_identifier_to_check_.Mutable(GetArenaForAllocation());
}
inline std::string* CollectUserDataProto::release_additional_model_identifier_to_check() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.additional_model_identifier_to_check)
  if (!_internal_has_additional_model_identifier_to_check()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = additional_model_identifier_to_check_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (additional_model_identifier_to_check_.IsDefault()) {
    additional_model_identifier_to_check_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CollectUserDataProto::set_allocated_additional_model_identifier_to_check(std::string* additional_model_identifier_to_check) {
  if (additional_model_identifier_to_check != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  additional_model_identifier_to_check_.SetAllocated(additional_model_identifier_to_check, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (additional_model_identifier_to_check_.IsDefault()) {
    additional_model_identifier_to_check_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.additional_model_identifier_to_check)
}

// optional bool clear_previous_credit_card_selection = 28;
inline bool CollectUserDataProto::_internal_has_clear_previous_credit_card_selection() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_clear_previous_credit_card_selection() const {
  return _internal_has_clear_previous_credit_card_selection();
}
inline void CollectUserDataProto::clear_clear_previous_credit_card_selection() {
  clear_previous_credit_card_selection_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool CollectUserDataProto::_internal_clear_previous_credit_card_selection() const {
  return clear_previous_credit_card_selection_;
}
inline bool CollectUserDataProto::clear_previous_credit_card_selection() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.clear_previous_credit_card_selection)
  return _internal_clear_previous_credit_card_selection();
}
inline void CollectUserDataProto::_internal_set_clear_previous_credit_card_selection(bool value) {
  _has_bits_[0] |= 0x00200000u;
  clear_previous_credit_card_selection_ = value;
}
inline void CollectUserDataProto::set_clear_previous_credit_card_selection(bool value) {
  _internal_set_clear_previous_credit_card_selection(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.clear_previous_credit_card_selection)
}

// optional bool clear_previous_login_selection = 29;
inline bool CollectUserDataProto::_internal_has_clear_previous_login_selection() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CollectUserDataProto::has_clear_previous_login_selection() const {
  return _internal_has_clear_previous_login_selection();
}
inline void CollectUserDataProto::clear_clear_previous_login_selection() {
  clear_previous_login_selection_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool CollectUserDataProto::_internal_clear_previous_login_selection() const {
  return clear_previous_login_selection_;
}
inline bool CollectUserDataProto::clear_previous_login_selection() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.clear_previous_login_selection)
  return _internal_clear_previous_login_selection();
}
inline void CollectUserDataProto::_internal_set_clear_previous_login_selection(bool value) {
  _has_bits_[0] |= 0x00400000u;
  clear_previous_login_selection_ = value;
}
inline void CollectUserDataProto::set_clear_previous_login_selection(bool value) {
  _internal_set_clear_previous_login_selection(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.clear_previous_login_selection)
}

// repeated string clear_previous_profile_selection = 30;
inline int CollectUserDataProto::_internal_clear_previous_profile_selection_size() const {
  return clear_previous_profile_selection_.size();
}
inline int CollectUserDataProto::clear_previous_profile_selection_size() const {
  return _internal_clear_previous_profile_selection_size();
}
inline void CollectUserDataProto::clear_clear_previous_profile_selection() {
  clear_previous_profile_selection_.Clear();
}
inline std::string* CollectUserDataProto::add_clear_previous_profile_selection() {
  std::string* _s = _internal_add_clear_previous_profile_selection();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
  return _s;
}
inline const std::string& CollectUserDataProto::_internal_clear_previous_profile_selection(int index) const {
  return clear_previous_profile_selection_.Get(index);
}
inline const std::string& CollectUserDataProto::clear_previous_profile_selection(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
  return _internal_clear_previous_profile_selection(index);
}
inline std::string* CollectUserDataProto::mutable_clear_previous_profile_selection(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
  return clear_previous_profile_selection_.Mutable(index);
}
inline void CollectUserDataProto::set_clear_previous_profile_selection(int index, const std::string& value) {
  clear_previous_profile_selection_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline void CollectUserDataProto::set_clear_previous_profile_selection(int index, std::string&& value) {
  clear_previous_profile_selection_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline void CollectUserDataProto::set_clear_previous_profile_selection(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  clear_previous_profile_selection_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline void CollectUserDataProto::set_clear_previous_profile_selection(int index, const char* value, size_t size) {
  clear_previous_profile_selection_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline std::string* CollectUserDataProto::_internal_add_clear_previous_profile_selection() {
  return clear_previous_profile_selection_.Add();
}
inline void CollectUserDataProto::add_clear_previous_profile_selection(const std::string& value) {
  clear_previous_profile_selection_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline void CollectUserDataProto::add_clear_previous_profile_selection(std::string&& value) {
  clear_previous_profile_selection_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline void CollectUserDataProto::add_clear_previous_profile_selection(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  clear_previous_profile_selection_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline void CollectUserDataProto::add_clear_previous_profile_selection(const char* value, size_t size) {
  clear_previous_profile_selection_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CollectUserDataProto::clear_previous_profile_selection() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
  return clear_previous_profile_selection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CollectUserDataProto::mutable_clear_previous_profile_selection() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.clear_previous_profile_selection)
  return &clear_previous_profile_selection_;
}

// repeated .autofill_assistant.RequiredDataPiece required_shipping_address_data_piece = 34;
inline int CollectUserDataProto::_internal_required_shipping_address_data_piece_size() const {
  return required_shipping_address_data_piece_.size();
}
inline int CollectUserDataProto::required_shipping_address_data_piece_size() const {
  return _internal_required_shipping_address_data_piece_size();
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::mutable_required_shipping_address_data_piece(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.required_shipping_address_data_piece)
  return required_shipping_address_data_piece_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
CollectUserDataProto::mutable_required_shipping_address_data_piece() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.required_shipping_address_data_piece)
  return &required_shipping_address_data_piece_;
}
inline const ::autofill_assistant::RequiredDataPiece& CollectUserDataProto::_internal_required_shipping_address_data_piece(int index) const {
  return required_shipping_address_data_piece_.Get(index);
}
inline const ::autofill_assistant::RequiredDataPiece& CollectUserDataProto::required_shipping_address_data_piece(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.required_shipping_address_data_piece)
  return _internal_required_shipping_address_data_piece(index);
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::_internal_add_required_shipping_address_data_piece() {
  return required_shipping_address_data_piece_.Add();
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::add_required_shipping_address_data_piece() {
  ::autofill_assistant::RequiredDataPiece* _add = _internal_add_required_shipping_address_data_piece();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.required_shipping_address_data_piece)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
CollectUserDataProto::required_shipping_address_data_piece() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.required_shipping_address_data_piece)
  return required_shipping_address_data_piece_;
}

// repeated .autofill_assistant.RequiredDataPiece required_credit_card_data_piece = 35;
inline int CollectUserDataProto::_internal_required_credit_card_data_piece_size() const {
  return required_credit_card_data_piece_.size();
}
inline int CollectUserDataProto::required_credit_card_data_piece_size() const {
  return _internal_required_credit_card_data_piece_size();
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::mutable_required_credit_card_data_piece(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.required_credit_card_data_piece)
  return required_credit_card_data_piece_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
CollectUserDataProto::mutable_required_credit_card_data_piece() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.required_credit_card_data_piece)
  return &required_credit_card_data_piece_;
}
inline const ::autofill_assistant::RequiredDataPiece& CollectUserDataProto::_internal_required_credit_card_data_piece(int index) const {
  return required_credit_card_data_piece_.Get(index);
}
inline const ::autofill_assistant::RequiredDataPiece& CollectUserDataProto::required_credit_card_data_piece(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.required_credit_card_data_piece)
  return _internal_required_credit_card_data_piece(index);
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::_internal_add_required_credit_card_data_piece() {
  return required_credit_card_data_piece_.Add();
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::add_required_credit_card_data_piece() {
  ::autofill_assistant::RequiredDataPiece* _add = _internal_add_required_credit_card_data_piece();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.required_credit_card_data_piece)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
CollectUserDataProto::required_credit_card_data_piece() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.required_credit_card_data_piece)
  return required_credit_card_data_piece_;
}

// repeated .autofill_assistant.RequiredDataPiece required_billing_address_data_piece = 36;
inline int CollectUserDataProto::_internal_required_billing_address_data_piece_size() const {
  return required_billing_address_data_piece_.size();
}
inline int CollectUserDataProto::required_billing_address_data_piece_size() const {
  return _internal_required_billing_address_data_piece_size();
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::mutable_required_billing_address_data_piece(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.required_billing_address_data_piece)
  return required_billing_address_data_piece_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >*
CollectUserDataProto::mutable_required_billing_address_data_piece() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CollectUserDataProto.required_billing_address_data_piece)
  return &required_billing_address_data_piece_;
}
inline const ::autofill_assistant::RequiredDataPiece& CollectUserDataProto::_internal_required_billing_address_data_piece(int index) const {
  return required_billing_address_data_piece_.Get(index);
}
inline const ::autofill_assistant::RequiredDataPiece& CollectUserDataProto::required_billing_address_data_piece(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.required_billing_address_data_piece)
  return _internal_required_billing_address_data_piece(index);
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::_internal_add_required_billing_address_data_piece() {
  return required_billing_address_data_piece_.Add();
}
inline ::autofill_assistant::RequiredDataPiece* CollectUserDataProto::add_required_billing_address_data_piece() {
  ::autofill_assistant::RequiredDataPiece* _add = _internal_add_required_billing_address_data_piece();
  // @@protoc_insertion_point(field_add:autofill_assistant.CollectUserDataProto.required_billing_address_data_piece)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::RequiredDataPiece >&
CollectUserDataProto::required_billing_address_data_piece() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CollectUserDataProto.required_billing_address_data_piece)
  return required_billing_address_data_piece_;
}

// optional .autofill_assistant.CollectUserDataProto.DataSource data_source = 38;
inline bool CollectUserDataProto::_internal_has_data_source() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || data_source_ != nullptr);
  return value;
}
inline bool CollectUserDataProto::has_data_source() const {
  return _internal_has_data_source();
}
inline void CollectUserDataProto::clear_data_source() {
  if (data_source_ != nullptr) data_source_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::autofill_assistant::CollectUserDataProto_DataSource& CollectUserDataProto::_internal_data_source() const {
  const ::autofill_assistant::CollectUserDataProto_DataSource* p = data_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::CollectUserDataProto_DataSource&>(
      ::autofill_assistant::_CollectUserDataProto_DataSource_default_instance_);
}
inline const ::autofill_assistant::CollectUserDataProto_DataSource& CollectUserDataProto::data_source() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CollectUserDataProto.data_source)
  return _internal_data_source();
}
inline void CollectUserDataProto::unsafe_arena_set_allocated_data_source(
    ::autofill_assistant::CollectUserDataProto_DataSource* data_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source_);
  }
  data_source_ = data_source;
  if (data_source) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CollectUserDataProto.data_source)
}
inline ::autofill_assistant::CollectUserDataProto_DataSource* CollectUserDataProto::release_data_source() {
  _has_bits_[0] &= ~0x00008000u;
  ::autofill_assistant::CollectUserDataProto_DataSource* temp = data_source_;
  data_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::CollectUserDataProto_DataSource* CollectUserDataProto::unsafe_arena_release_data_source() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CollectUserDataProto.data_source)
  _has_bits_[0] &= ~0x00008000u;
  ::autofill_assistant::CollectUserDataProto_DataSource* temp = data_source_;
  data_source_ = nullptr;
  return temp;
}
inline ::autofill_assistant::CollectUserDataProto_DataSource* CollectUserDataProto::_internal_mutable_data_source() {
  _has_bits_[0] |= 0x00008000u;
  if (data_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::CollectUserDataProto_DataSource>(GetArenaForAllocation());
    data_source_ = p;
  }
  return data_source_;
}
inline ::autofill_assistant::CollectUserDataProto_DataSource* CollectUserDataProto::mutable_data_source() {
  ::autofill_assistant::CollectUserDataProto_DataSource* _msg = _internal_mutable_data_source();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CollectUserDataProto.data_source)
  return _msg;
}
inline void CollectUserDataProto::set_allocated_data_source(::autofill_assistant::CollectUserDataProto_DataSource* data_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_source_;
  }
  if (data_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_source);
    if (message_arena != submessage_arena) {
      data_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_source, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  data_source_ = data_source;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CollectUserDataProto.data_source)
}

// -------------------------------------------------------------------

// StopProto

// optional bool close_cct = 2;
inline bool StopProto::_internal_has_close_cct() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopProto::has_close_cct() const {
  return _internal_has_close_cct();
}
inline void StopProto::clear_close_cct() {
  close_cct_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool StopProto::_internal_close_cct() const {
  return close_cct_;
}
inline bool StopProto::close_cct() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.StopProto.close_cct)
  return _internal_close_cct();
}
inline void StopProto::_internal_set_close_cct(bool value) {
  _has_bits_[0] |= 0x00000001u;
  close_cct_ = value;
}
inline void StopProto::set_close_cct(bool value) {
  _internal_set_close_cct(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.StopProto.close_cct)
}

// optional bool show_feedback_chip = 3;
inline bool StopProto::_internal_has_show_feedback_chip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopProto::has_show_feedback_chip() const {
  return _internal_has_show_feedback_chip();
}
inline void StopProto::clear_show_feedback_chip() {
  show_feedback_chip_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StopProto::_internal_show_feedback_chip() const {
  return show_feedback_chip_;
}
inline bool StopProto::show_feedback_chip() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.StopProto.show_feedback_chip)
  return _internal_show_feedback_chip();
}
inline void StopProto::_internal_set_show_feedback_chip(bool value) {
  _has_bits_[0] |= 0x00000002u;
  show_feedback_chip_ = value;
}
inline void StopProto::set_show_feedback_chip(bool value) {
  _internal_set_show_feedback_chip(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.StopProto.show_feedback_chip)
}

// -------------------------------------------------------------------

// DetailsChangesProto

// optional bool user_approval_required = 1;
inline bool DetailsChangesProto::_internal_has_user_approval_required() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DetailsChangesProto::has_user_approval_required() const {
  return _internal_has_user_approval_required();
}
inline void DetailsChangesProto::clear_user_approval_required() {
  user_approval_required_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DetailsChangesProto::_internal_user_approval_required() const {
  return user_approval_required_;
}
inline bool DetailsChangesProto::user_approval_required() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsChangesProto.user_approval_required)
  return _internal_user_approval_required();
}
inline void DetailsChangesProto::_internal_set_user_approval_required(bool value) {
  _has_bits_[0] |= 0x00000001u;
  user_approval_required_ = value;
}
inline void DetailsChangesProto::set_user_approval_required(bool value) {
  _internal_set_user_approval_required(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsChangesProto.user_approval_required)
}

// optional bool highlight_title = 2;
inline bool DetailsChangesProto::_internal_has_highlight_title() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DetailsChangesProto::has_highlight_title() const {
  return _internal_has_highlight_title();
}
inline void DetailsChangesProto::clear_highlight_title() {
  highlight_title_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DetailsChangesProto::_internal_highlight_title() const {
  return highlight_title_;
}
inline bool DetailsChangesProto::highlight_title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsChangesProto.highlight_title)
  return _internal_highlight_title();
}
inline void DetailsChangesProto::_internal_set_highlight_title(bool value) {
  _has_bits_[0] |= 0x00000002u;
  highlight_title_ = value;
}
inline void DetailsChangesProto::set_highlight_title(bool value) {
  _internal_set_highlight_title(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsChangesProto.highlight_title)
}

// optional bool highlight_line1 = 3;
inline bool DetailsChangesProto::_internal_has_highlight_line1() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DetailsChangesProto::has_highlight_line1() const {
  return _internal_has_highlight_line1();
}
inline void DetailsChangesProto::clear_highlight_line1() {
  highlight_line1_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DetailsChangesProto::_internal_highlight_line1() const {
  return highlight_line1_;
}
inline bool DetailsChangesProto::highlight_line1() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsChangesProto.highlight_line1)
  return _internal_highlight_line1();
}
inline void DetailsChangesProto::_internal_set_highlight_line1(bool value) {
  _has_bits_[0] |= 0x00000004u;
  highlight_line1_ = value;
}
inline void DetailsChangesProto::set_highlight_line1(bool value) {
  _internal_set_highlight_line1(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsChangesProto.highlight_line1)
}

// optional bool highlight_line2 = 4;
inline bool DetailsChangesProto::_internal_has_highlight_line2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DetailsChangesProto::has_highlight_line2() const {
  return _internal_has_highlight_line2();
}
inline void DetailsChangesProto::clear_highlight_line2() {
  highlight_line2_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DetailsChangesProto::_internal_highlight_line2() const {
  return highlight_line2_;
}
inline bool DetailsChangesProto::highlight_line2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsChangesProto.highlight_line2)
  return _internal_highlight_line2();
}
inline void DetailsChangesProto::_internal_set_highlight_line2(bool value) {
  _has_bits_[0] |= 0x00000008u;
  highlight_line2_ = value;
}
inline void DetailsChangesProto::set_highlight_line2(bool value) {
  _internal_set_highlight_line2(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsChangesProto.highlight_line2)
}

// optional bool highlight_line3 = 5;
inline bool DetailsChangesProto::_internal_has_highlight_line3() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DetailsChangesProto::has_highlight_line3() const {
  return _internal_has_highlight_line3();
}
inline void DetailsChangesProto::clear_highlight_line3() {
  highlight_line3_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool DetailsChangesProto::_internal_highlight_line3() const {
  return highlight_line3_;
}
inline bool DetailsChangesProto::highlight_line3() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsChangesProto.highlight_line3)
  return _internal_highlight_line3();
}
inline void DetailsChangesProto::_internal_set_highlight_line3(bool value) {
  _has_bits_[0] |= 0x00000010u;
  highlight_line3_ = value;
}
inline void DetailsChangesProto::set_highlight_line3(bool value) {
  _internal_set_highlight_line3(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsChangesProto.highlight_line3)
}

// -------------------------------------------------------------------

// DetailsProto_ImageClickthroughData

// optional bool allow_clickthrough = 1;
inline bool DetailsProto_ImageClickthroughData::_internal_has_allow_clickthrough() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DetailsProto_ImageClickthroughData::has_allow_clickthrough() const {
  return _internal_has_allow_clickthrough();
}
inline void DetailsProto_ImageClickthroughData::clear_allow_clickthrough() {
  allow_clickthrough_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool DetailsProto_ImageClickthroughData::_internal_allow_clickthrough() const {
  return allow_clickthrough_;
}
inline bool DetailsProto_ImageClickthroughData::allow_clickthrough() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.ImageClickthroughData.allow_clickthrough)
  return _internal_allow_clickthrough();
}
inline void DetailsProto_ImageClickthroughData::_internal_set_allow_clickthrough(bool value) {
  _has_bits_[0] |= 0x00000010u;
  allow_clickthrough_ = value;
}
inline void DetailsProto_ImageClickthroughData::set_allow_clickthrough(bool value) {
  _internal_set_allow_clickthrough(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.ImageClickthroughData.allow_clickthrough)
}

// optional string description = 2;
inline bool DetailsProto_ImageClickthroughData::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DetailsProto_ImageClickthroughData::has_description() const {
  return _internal_has_description();
}
inline void DetailsProto_ImageClickthroughData::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DetailsProto_ImageClickthroughData::description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.ImageClickthroughData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto_ImageClickthroughData::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.ImageClickthroughData.description)
}
inline std::string* DetailsProto_ImageClickthroughData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.ImageClickthroughData.description)
  return _s;
}
inline const std::string& DetailsProto_ImageClickthroughData::_internal_description() const {
  return description_.Get();
}
inline void DetailsProto_ImageClickthroughData::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::release_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.ImageClickthroughData.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto_ImageClickthroughData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.ImageClickthroughData.description)
}

// optional string positive_text = 3;
inline bool DetailsProto_ImageClickthroughData::_internal_has_positive_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DetailsProto_ImageClickthroughData::has_positive_text() const {
  return _internal_has_positive_text();
}
inline void DetailsProto_ImageClickthroughData::clear_positive_text() {
  positive_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DetailsProto_ImageClickthroughData::positive_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.ImageClickthroughData.positive_text)
  return _internal_positive_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto_ImageClickthroughData::set_positive_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 positive_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.ImageClickthroughData.positive_text)
}
inline std::string* DetailsProto_ImageClickthroughData::mutable_positive_text() {
  std::string* _s = _internal_mutable_positive_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.ImageClickthroughData.positive_text)
  return _s;
}
inline const std::string& DetailsProto_ImageClickthroughData::_internal_positive_text() const {
  return positive_text_.Get();
}
inline void DetailsProto_ImageClickthroughData::_internal_set_positive_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  positive_text_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::_internal_mutable_positive_text() {
  _has_bits_[0] |= 0x00000002u;
  return positive_text_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::release_positive_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.ImageClickthroughData.positive_text)
  if (!_internal_has_positive_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = positive_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (positive_text_.IsDefault()) {
    positive_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto_ImageClickthroughData::set_allocated_positive_text(std::string* positive_text) {
  if (positive_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  positive_text_.SetAllocated(positive_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (positive_text_.IsDefault()) {
    positive_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.ImageClickthroughData.positive_text)
}

// optional string negative_text = 4;
inline bool DetailsProto_ImageClickthroughData::_internal_has_negative_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DetailsProto_ImageClickthroughData::has_negative_text() const {
  return _internal_has_negative_text();
}
inline void DetailsProto_ImageClickthroughData::clear_negative_text() {
  negative_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DetailsProto_ImageClickthroughData::negative_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.ImageClickthroughData.negative_text)
  return _internal_negative_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto_ImageClickthroughData::set_negative_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 negative_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.ImageClickthroughData.negative_text)
}
inline std::string* DetailsProto_ImageClickthroughData::mutable_negative_text() {
  std::string* _s = _internal_mutable_negative_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.ImageClickthroughData.negative_text)
  return _s;
}
inline const std::string& DetailsProto_ImageClickthroughData::_internal_negative_text() const {
  return negative_text_.Get();
}
inline void DetailsProto_ImageClickthroughData::_internal_set_negative_text(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  negative_text_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::_internal_mutable_negative_text() {
  _has_bits_[0] |= 0x00000004u;
  return negative_text_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::release_negative_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.ImageClickthroughData.negative_text)
  if (!_internal_has_negative_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = negative_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (negative_text_.IsDefault()) {
    negative_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto_ImageClickthroughData::set_allocated_negative_text(std::string* negative_text) {
  if (negative_text != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  negative_text_.SetAllocated(negative_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (negative_text_.IsDefault()) {
    negative_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.ImageClickthroughData.negative_text)
}

// optional string clickthrough_url = 5;
inline bool DetailsProto_ImageClickthroughData::_internal_has_clickthrough_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DetailsProto_ImageClickthroughData::has_clickthrough_url() const {
  return _internal_has_clickthrough_url();
}
inline void DetailsProto_ImageClickthroughData::clear_clickthrough_url() {
  clickthrough_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DetailsProto_ImageClickthroughData::clickthrough_url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.ImageClickthroughData.clickthrough_url)
  return _internal_clickthrough_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto_ImageClickthroughData::set_clickthrough_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 clickthrough_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.ImageClickthroughData.clickthrough_url)
}
inline std::string* DetailsProto_ImageClickthroughData::mutable_clickthrough_url() {
  std::string* _s = _internal_mutable_clickthrough_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.ImageClickthroughData.clickthrough_url)
  return _s;
}
inline const std::string& DetailsProto_ImageClickthroughData::_internal_clickthrough_url() const {
  return clickthrough_url_.Get();
}
inline void DetailsProto_ImageClickthroughData::_internal_set_clickthrough_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  clickthrough_url_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::_internal_mutable_clickthrough_url() {
  _has_bits_[0] |= 0x00000008u;
  return clickthrough_url_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto_ImageClickthroughData::release_clickthrough_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.ImageClickthroughData.clickthrough_url)
  if (!_internal_has_clickthrough_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = clickthrough_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clickthrough_url_.IsDefault()) {
    clickthrough_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto_ImageClickthroughData::set_allocated_clickthrough_url(std::string* clickthrough_url) {
  if (clickthrough_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  clickthrough_url_.SetAllocated(clickthrough_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clickthrough_url_.IsDefault()) {
    clickthrough_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.ImageClickthroughData.clickthrough_url)
}

// -------------------------------------------------------------------

// DetailsProto_PlaceholdersConfiguration

// optional bool show_image_placeholder = 1;
inline bool DetailsProto_PlaceholdersConfiguration::_internal_has_show_image_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DetailsProto_PlaceholdersConfiguration::has_show_image_placeholder() const {
  return _internal_has_show_image_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::clear_show_image_placeholder() {
  show_image_placeholder_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool DetailsProto_PlaceholdersConfiguration::_internal_show_image_placeholder() const {
  return show_image_placeholder_;
}
inline bool DetailsProto_PlaceholdersConfiguration::show_image_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_image_placeholder)
  return _internal_show_image_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::_internal_set_show_image_placeholder(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_image_placeholder_ = value;
}
inline void DetailsProto_PlaceholdersConfiguration::set_show_image_placeholder(bool value) {
  _internal_set_show_image_placeholder(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_image_placeholder)
}

// optional bool show_title_placeholder = 2;
inline bool DetailsProto_PlaceholdersConfiguration::_internal_has_show_title_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DetailsProto_PlaceholdersConfiguration::has_show_title_placeholder() const {
  return _internal_has_show_title_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::clear_show_title_placeholder() {
  show_title_placeholder_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DetailsProto_PlaceholdersConfiguration::_internal_show_title_placeholder() const {
  return show_title_placeholder_;
}
inline bool DetailsProto_PlaceholdersConfiguration::show_title_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_title_placeholder)
  return _internal_show_title_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::_internal_set_show_title_placeholder(bool value) {
  _has_bits_[0] |= 0x00000002u;
  show_title_placeholder_ = value;
}
inline void DetailsProto_PlaceholdersConfiguration::set_show_title_placeholder(bool value) {
  _internal_set_show_title_placeholder(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_title_placeholder)
}

// optional bool show_description_line_1_placeholder = 3;
inline bool DetailsProto_PlaceholdersConfiguration::_internal_has_show_description_line_1_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DetailsProto_PlaceholdersConfiguration::has_show_description_line_1_placeholder() const {
  return _internal_has_show_description_line_1_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::clear_show_description_line_1_placeholder() {
  show_description_line_1_placeholder_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DetailsProto_PlaceholdersConfiguration::_internal_show_description_line_1_placeholder() const {
  return show_description_line_1_placeholder_;
}
inline bool DetailsProto_PlaceholdersConfiguration::show_description_line_1_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_description_line_1_placeholder)
  return _internal_show_description_line_1_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::_internal_set_show_description_line_1_placeholder(bool value) {
  _has_bits_[0] |= 0x00000004u;
  show_description_line_1_placeholder_ = value;
}
inline void DetailsProto_PlaceholdersConfiguration::set_show_description_line_1_placeholder(bool value) {
  _internal_set_show_description_line_1_placeholder(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_description_line_1_placeholder)
}

// optional bool show_description_line_2_placeholder = 4;
inline bool DetailsProto_PlaceholdersConfiguration::_internal_has_show_description_line_2_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DetailsProto_PlaceholdersConfiguration::has_show_description_line_2_placeholder() const {
  return _internal_has_show_description_line_2_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::clear_show_description_line_2_placeholder() {
  show_description_line_2_placeholder_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DetailsProto_PlaceholdersConfiguration::_internal_show_description_line_2_placeholder() const {
  return show_description_line_2_placeholder_;
}
inline bool DetailsProto_PlaceholdersConfiguration::show_description_line_2_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_description_line_2_placeholder)
  return _internal_show_description_line_2_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::_internal_set_show_description_line_2_placeholder(bool value) {
  _has_bits_[0] |= 0x00000008u;
  show_description_line_2_placeholder_ = value;
}
inline void DetailsProto_PlaceholdersConfiguration::set_show_description_line_2_placeholder(bool value) {
  _internal_set_show_description_line_2_placeholder(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_description_line_2_placeholder)
}

// optional bool show_description_line_3_placeholder = 5;
inline bool DetailsProto_PlaceholdersConfiguration::_internal_has_show_description_line_3_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DetailsProto_PlaceholdersConfiguration::has_show_description_line_3_placeholder() const {
  return _internal_has_show_description_line_3_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::clear_show_description_line_3_placeholder() {
  show_description_line_3_placeholder_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool DetailsProto_PlaceholdersConfiguration::_internal_show_description_line_3_placeholder() const {
  return show_description_line_3_placeholder_;
}
inline bool DetailsProto_PlaceholdersConfiguration::show_description_line_3_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_description_line_3_placeholder)
  return _internal_show_description_line_3_placeholder();
}
inline void DetailsProto_PlaceholdersConfiguration::_internal_set_show_description_line_3_placeholder(bool value) {
  _has_bits_[0] |= 0x00000010u;
  show_description_line_3_placeholder_ = value;
}
inline void DetailsProto_PlaceholdersConfiguration::set_show_description_line_3_placeholder(bool value) {
  _internal_set_show_description_line_3_placeholder(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.PlaceholdersConfiguration.show_description_line_3_placeholder)
}

// -------------------------------------------------------------------

// DetailsProto

// optional string title = 1;
inline bool DetailsProto::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DetailsProto::has_title() const {
  return _internal_has_title();
}
inline void DetailsProto::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DetailsProto::title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.title)
}
inline std::string* DetailsProto::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.title)
  return _s;
}
inline const std::string& DetailsProto::_internal_title() const {
  return title_.Get();
}
inline void DetailsProto::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.title)
}

// optional string image_url = 2;
inline bool DetailsProto::_internal_has_image_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DetailsProto::has_image_url() const {
  return _internal_has_image_url();
}
inline void DetailsProto::clear_image_url() {
  image_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DetailsProto::image_url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_image_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 image_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.image_url)
}
inline std::string* DetailsProto::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.image_url)
  return _s;
}
inline const std::string& DetailsProto::_internal_image_url() const {
  return image_url_.Get();
}
inline void DetailsProto::_internal_set_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  image_url_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_image_url() {
  _has_bits_[0] |= 0x00000002u;
  return image_url_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_image_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.image_url)
  if (!_internal_has_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = image_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault()) {
    image_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_url_.SetAllocated(image_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault()) {
    image_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.image_url)
}

// optional string image_accessibility_hint = 14;
inline bool DetailsProto::_internal_has_image_accessibility_hint() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DetailsProto::has_image_accessibility_hint() const {
  return _internal_has_image_accessibility_hint();
}
inline void DetailsProto::clear_image_accessibility_hint() {
  image_accessibility_hint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& DetailsProto::image_accessibility_hint() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.image_accessibility_hint)
  return _internal_image_accessibility_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_image_accessibility_hint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 image_accessibility_hint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.image_accessibility_hint)
}
inline std::string* DetailsProto::mutable_image_accessibility_hint() {
  std::string* _s = _internal_mutable_image_accessibility_hint();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.image_accessibility_hint)
  return _s;
}
inline const std::string& DetailsProto::_internal_image_accessibility_hint() const {
  return image_accessibility_hint_.Get();
}
inline void DetailsProto::_internal_set_image_accessibility_hint(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  image_accessibility_hint_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_image_accessibility_hint() {
  _has_bits_[0] |= 0x00000100u;
  return image_accessibility_hint_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_image_accessibility_hint() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.image_accessibility_hint)
  if (!_internal_has_image_accessibility_hint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = image_accessibility_hint_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_accessibility_hint_.IsDefault()) {
    image_accessibility_hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_image_accessibility_hint(std::string* image_accessibility_hint) {
  if (image_accessibility_hint != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  image_accessibility_hint_.SetAllocated(image_accessibility_hint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_accessibility_hint_.IsDefault()) {
    image_accessibility_hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.image_accessibility_hint)
}

// optional .autofill_assistant.DetailsProto.ImageClickthroughData image_clickthrough_data = 12;
inline bool DetailsProto::_internal_has_image_clickthrough_data() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || image_clickthrough_data_ != nullptr);
  return value;
}
inline bool DetailsProto::has_image_clickthrough_data() const {
  return _internal_has_image_clickthrough_data();
}
inline void DetailsProto::clear_image_clickthrough_data() {
  if (image_clickthrough_data_ != nullptr) image_clickthrough_data_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::autofill_assistant::DetailsProto_ImageClickthroughData& DetailsProto::_internal_image_clickthrough_data() const {
  const ::autofill_assistant::DetailsProto_ImageClickthroughData* p = image_clickthrough_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DetailsProto_ImageClickthroughData&>(
      ::autofill_assistant::_DetailsProto_ImageClickthroughData_default_instance_);
}
inline const ::autofill_assistant::DetailsProto_ImageClickthroughData& DetailsProto::image_clickthrough_data() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.image_clickthrough_data)
  return _internal_image_clickthrough_data();
}
inline void DetailsProto::unsafe_arena_set_allocated_image_clickthrough_data(
    ::autofill_assistant::DetailsProto_ImageClickthroughData* image_clickthrough_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_clickthrough_data_);
  }
  image_clickthrough_data_ = image_clickthrough_data;
  if (image_clickthrough_data) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DetailsProto.image_clickthrough_data)
}
inline ::autofill_assistant::DetailsProto_ImageClickthroughData* DetailsProto::release_image_clickthrough_data() {
  _has_bits_[0] &= ~0x00000400u;
  ::autofill_assistant::DetailsProto_ImageClickthroughData* temp = image_clickthrough_data_;
  image_clickthrough_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DetailsProto_ImageClickthroughData* DetailsProto::unsafe_arena_release_image_clickthrough_data() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.image_clickthrough_data)
  _has_bits_[0] &= ~0x00000400u;
  ::autofill_assistant::DetailsProto_ImageClickthroughData* temp = image_clickthrough_data_;
  image_clickthrough_data_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DetailsProto_ImageClickthroughData* DetailsProto::_internal_mutable_image_clickthrough_data() {
  _has_bits_[0] |= 0x00000400u;
  if (image_clickthrough_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DetailsProto_ImageClickthroughData>(GetArenaForAllocation());
    image_clickthrough_data_ = p;
  }
  return image_clickthrough_data_;
}
inline ::autofill_assistant::DetailsProto_ImageClickthroughData* DetailsProto::mutable_image_clickthrough_data() {
  ::autofill_assistant::DetailsProto_ImageClickthroughData* _msg = _internal_mutable_image_clickthrough_data();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.image_clickthrough_data)
  return _msg;
}
inline void DetailsProto::set_allocated_image_clickthrough_data(::autofill_assistant::DetailsProto_ImageClickthroughData* image_clickthrough_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_clickthrough_data_;
  }
  if (image_clickthrough_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_clickthrough_data);
    if (message_arena != submessage_arena) {
      image_clickthrough_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_clickthrough_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  image_clickthrough_data_ = image_clickthrough_data;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.image_clickthrough_data)
}

// optional string total_price_label = 9;
inline bool DetailsProto::_internal_has_total_price_label() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DetailsProto::has_total_price_label() const {
  return _internal_has_total_price_label();
}
inline void DetailsProto::clear_total_price_label() {
  total_price_label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DetailsProto::total_price_label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.total_price_label)
  return _internal_total_price_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_total_price_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 total_price_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.total_price_label)
}
inline std::string* DetailsProto::mutable_total_price_label() {
  std::string* _s = _internal_mutable_total_price_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.total_price_label)
  return _s;
}
inline const std::string& DetailsProto::_internal_total_price_label() const {
  return total_price_label_.Get();
}
inline void DetailsProto::_internal_set_total_price_label(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  total_price_label_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_total_price_label() {
  _has_bits_[0] |= 0x00000040u;
  return total_price_label_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_total_price_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.total_price_label)
  if (!_internal_has_total_price_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = total_price_label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (total_price_label_.IsDefault()) {
    total_price_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_total_price_label(std::string* total_price_label) {
  if (total_price_label != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  total_price_label_.SetAllocated(total_price_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (total_price_label_.IsDefault()) {
    total_price_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.total_price_label)
}

// optional string total_price = 6;
inline bool DetailsProto::_internal_has_total_price() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DetailsProto::has_total_price() const {
  return _internal_has_total_price();
}
inline void DetailsProto::clear_total_price() {
  total_price_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DetailsProto::total_price() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.total_price)
  return _internal_total_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_total_price(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 total_price_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.total_price)
}
inline std::string* DetailsProto::mutable_total_price() {
  std::string* _s = _internal_mutable_total_price();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.total_price)
  return _s;
}
inline const std::string& DetailsProto::_internal_total_price() const {
  return total_price_.Get();
}
inline void DetailsProto::_internal_set_total_price(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  total_price_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_total_price() {
  _has_bits_[0] |= 0x00000008u;
  return total_price_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_total_price() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.total_price)
  if (!_internal_has_total_price()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = total_price_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (total_price_.IsDefault()) {
    total_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_total_price(std::string* total_price) {
  if (total_price != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  total_price_.SetAllocated(total_price, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (total_price_.IsDefault()) {
    total_price_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.total_price)
}

// optional string description_line_1 = 7;
inline bool DetailsProto::_internal_has_description_line_1() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DetailsProto::has_description_line_1() const {
  return _internal_has_description_line_1();
}
inline void DetailsProto::clear_description_line_1() {
  description_line_1_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DetailsProto::description_line_1() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.description_line_1)
  return _internal_description_line_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_description_line_1(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 description_line_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.description_line_1)
}
inline std::string* DetailsProto::mutable_description_line_1() {
  std::string* _s = _internal_mutable_description_line_1();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.description_line_1)
  return _s;
}
inline const std::string& DetailsProto::_internal_description_line_1() const {
  return description_line_1_.Get();
}
inline void DetailsProto::_internal_set_description_line_1(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  description_line_1_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_description_line_1() {
  _has_bits_[0] |= 0x00000010u;
  return description_line_1_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_description_line_1() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.description_line_1)
  if (!_internal_has_description_line_1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = description_line_1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_1_.IsDefault()) {
    description_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_description_line_1(std::string* description_line_1) {
  if (description_line_1 != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  description_line_1_.SetAllocated(description_line_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_1_.IsDefault()) {
    description_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.description_line_1)
}

// optional string description_line_2 = 8;
inline bool DetailsProto::_internal_has_description_line_2() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DetailsProto::has_description_line_2() const {
  return _internal_has_description_line_2();
}
inline void DetailsProto::clear_description_line_2() {
  description_line_2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DetailsProto::description_line_2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.description_line_2)
  return _internal_description_line_2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_description_line_2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 description_line_2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.description_line_2)
}
inline std::string* DetailsProto::mutable_description_line_2() {
  std::string* _s = _internal_mutable_description_line_2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.description_line_2)
  return _s;
}
inline const std::string& DetailsProto::_internal_description_line_2() const {
  return description_line_2_.Get();
}
inline void DetailsProto::_internal_set_description_line_2(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  description_line_2_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_description_line_2() {
  _has_bits_[0] |= 0x00000020u;
  return description_line_2_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_description_line_2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.description_line_2)
  if (!_internal_has_description_line_2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = description_line_2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_2_.IsDefault()) {
    description_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_description_line_2(std::string* description_line_2) {
  if (description_line_2 != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  description_line_2_.SetAllocated(description_line_2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_2_.IsDefault()) {
    description_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.description_line_2)
}

// optional string description_line_3 = 13;
inline bool DetailsProto::_internal_has_description_line_3() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DetailsProto::has_description_line_3() const {
  return _internal_has_description_line_3();
}
inline void DetailsProto::clear_description_line_3() {
  description_line_3_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DetailsProto::description_line_3() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.description_line_3)
  return _internal_description_line_3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_description_line_3(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 description_line_3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.description_line_3)
}
inline std::string* DetailsProto::mutable_description_line_3() {
  std::string* _s = _internal_mutable_description_line_3();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.description_line_3)
  return _s;
}
inline const std::string& DetailsProto::_internal_description_line_3() const {
  return description_line_3_.Get();
}
inline void DetailsProto::_internal_set_description_line_3(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  description_line_3_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_description_line_3() {
  _has_bits_[0] |= 0x00000080u;
  return description_line_3_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_description_line_3() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.description_line_3)
  if (!_internal_has_description_line_3()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = description_line_3_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_3_.IsDefault()) {
    description_line_3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_description_line_3(std::string* description_line_3) {
  if (description_line_3 != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  description_line_3_.SetAllocated(description_line_3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_3_.IsDefault()) {
    description_line_3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.description_line_3)
}

// optional .autofill_assistant.DateTimeProto datetime = 3;
inline bool DetailsProto::_internal_has_datetime() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || datetime_ != nullptr);
  return value;
}
inline bool DetailsProto::has_datetime() const {
  return _internal_has_datetime();
}
inline const ::autofill_assistant::DateTimeProto& DetailsProto::_internal_datetime() const {
  const ::autofill_assistant::DateTimeProto* p = datetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DateTimeProto&>(
      ::autofill_assistant::_DateTimeProto_default_instance_);
}
inline const ::autofill_assistant::DateTimeProto& DetailsProto::datetime() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.datetime)
  return _internal_datetime();
}
inline void DetailsProto::unsafe_arena_set_allocated_datetime(
    ::autofill_assistant::DateTimeProto* datetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datetime_);
  }
  datetime_ = datetime;
  if (datetime) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DetailsProto.datetime)
}
inline ::autofill_assistant::DateTimeProto* DetailsProto::release_datetime() {
  _has_bits_[0] &= ~0x00000200u;
  ::autofill_assistant::DateTimeProto* temp = datetime_;
  datetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DateTimeProto* DetailsProto::unsafe_arena_release_datetime() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.datetime)
  _has_bits_[0] &= ~0x00000200u;
  ::autofill_assistant::DateTimeProto* temp = datetime_;
  datetime_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DateTimeProto* DetailsProto::_internal_mutable_datetime() {
  _has_bits_[0] |= 0x00000200u;
  if (datetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DateTimeProto>(GetArenaForAllocation());
    datetime_ = p;
  }
  return datetime_;
}
inline ::autofill_assistant::DateTimeProto* DetailsProto::mutable_datetime() {
  ::autofill_assistant::DateTimeProto* _msg = _internal_mutable_datetime();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.datetime)
  return _msg;
}
inline void DetailsProto::set_allocated_datetime(::autofill_assistant::DateTimeProto* datetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(datetime_);
  }
  if (datetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datetime));
    if (message_arena != submessage_arena) {
      datetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datetime, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  datetime_ = datetime;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.datetime)
}

// optional string description = 4;
inline bool DetailsProto::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DetailsProto::has_description() const {
  return _internal_has_description();
}
inline void DetailsProto::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DetailsProto::description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetailsProto::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DetailsProto.description)
}
inline std::string* DetailsProto::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.description)
  return _s;
}
inline const std::string& DetailsProto::_internal_description() const {
  return description_.Get();
}
inline void DetailsProto::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* DetailsProto::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* DetailsProto::release_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DetailsProto::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.description)
}

// optional .autofill_assistant.DetailsProto.PlaceholdersConfiguration placeholders = 15;
inline bool DetailsProto::_internal_has_placeholders() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || placeholders_ != nullptr);
  return value;
}
inline bool DetailsProto::has_placeholders() const {
  return _internal_has_placeholders();
}
inline void DetailsProto::clear_placeholders() {
  if (placeholders_ != nullptr) placeholders_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration& DetailsProto::_internal_placeholders() const {
  const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* p = placeholders_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration&>(
      ::autofill_assistant::_DetailsProto_PlaceholdersConfiguration_default_instance_);
}
inline const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration& DetailsProto::placeholders() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DetailsProto.placeholders)
  return _internal_placeholders();
}
inline void DetailsProto::unsafe_arena_set_allocated_placeholders(
    ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* placeholders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placeholders_);
  }
  placeholders_ = placeholders;
  if (placeholders) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DetailsProto.placeholders)
}
inline ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* DetailsProto::release_placeholders() {
  _has_bits_[0] &= ~0x00000800u;
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* temp = placeholders_;
  placeholders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* DetailsProto::unsafe_arena_release_placeholders() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DetailsProto.placeholders)
  _has_bits_[0] &= ~0x00000800u;
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* temp = placeholders_;
  placeholders_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* DetailsProto::_internal_mutable_placeholders() {
  _has_bits_[0] |= 0x00000800u;
  if (placeholders_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DetailsProto_PlaceholdersConfiguration>(GetArenaForAllocation());
    placeholders_ = p;
  }
  return placeholders_;
}
inline ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* DetailsProto::mutable_placeholders() {
  ::autofill_assistant::DetailsProto_PlaceholdersConfiguration* _msg = _internal_mutable_placeholders();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DetailsProto.placeholders)
  return _msg;
}
inline void DetailsProto::set_allocated_placeholders(::autofill_assistant::DetailsProto_PlaceholdersConfiguration* placeholders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete placeholders_;
  }
  if (placeholders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(placeholders);
    if (message_arena != submessage_arena) {
      placeholders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placeholders, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  placeholders_ = placeholders;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DetailsProto.placeholders)
}

// -------------------------------------------------------------------

// ShowDetailsProto

// .autofill_assistant.DetailsProto details = 1;
inline bool ShowDetailsProto::_internal_has_details() const {
  return data_to_show_case() == kDetails;
}
inline bool ShowDetailsProto::has_details() const {
  return _internal_has_details();
}
inline void ShowDetailsProto::set_has_details() {
  _oneof_case_[0] = kDetails;
}
inline void ShowDetailsProto::clear_details() {
  if (_internal_has_details()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_to_show_.details_;
    }
    clear_has_data_to_show();
  }
}
inline ::autofill_assistant::DetailsProto* ShowDetailsProto::release_details() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowDetailsProto.details)
  if (_internal_has_details()) {
    clear_has_data_to_show();
    ::autofill_assistant::DetailsProto* temp = data_to_show_.details_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_to_show_.details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DetailsProto& ShowDetailsProto::_internal_details() const {
  return _internal_has_details()
      ? *data_to_show_.details_
      : reinterpret_cast< ::autofill_assistant::DetailsProto&>(::autofill_assistant::_DetailsProto_default_instance_);
}
inline const ::autofill_assistant::DetailsProto& ShowDetailsProto::details() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.details)
  return _internal_details();
}
inline ::autofill_assistant::DetailsProto* ShowDetailsProto::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ShowDetailsProto.details)
  if (_internal_has_details()) {
    clear_has_data_to_show();
    ::autofill_assistant::DetailsProto* temp = data_to_show_.details_;
    data_to_show_.details_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShowDetailsProto::unsafe_arena_set_allocated_details(::autofill_assistant::DetailsProto* details) {
  clear_data_to_show();
  if (details) {
    set_has_details();
    data_to_show_.details_ = details;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowDetailsProto.details)
}
inline ::autofill_assistant::DetailsProto* ShowDetailsProto::_internal_mutable_details() {
  if (!_internal_has_details()) {
    clear_data_to_show();
    set_has_details();
    data_to_show_.details_ = CreateMaybeMessage< ::autofill_assistant::DetailsProto >(GetArenaForAllocation());
  }
  return data_to_show_.details_;
}
inline ::autofill_assistant::DetailsProto* ShowDetailsProto::mutable_details() {
  ::autofill_assistant::DetailsProto* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowDetailsProto.details)
  return _msg;
}

// string contact_details = 3;
inline bool ShowDetailsProto::_internal_has_contact_details() const {
  return data_to_show_case() == kContactDetails;
}
inline bool ShowDetailsProto::has_contact_details() const {
  return _internal_has_contact_details();
}
inline void ShowDetailsProto::set_has_contact_details() {
  _oneof_case_[0] = kContactDetails;
}
inline void ShowDetailsProto::clear_contact_details() {
  if (_internal_has_contact_details()) {
    data_to_show_.contact_details_.Destroy();
    clear_has_data_to_show();
  }
}
inline const std::string& ShowDetailsProto::contact_details() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.contact_details)
  return _internal_contact_details();
}
template <typename ArgT0, typename... ArgT>
inline void ShowDetailsProto::set_contact_details(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_contact_details()) {
    clear_data_to_show();
    set_has_contact_details();
    data_to_show_.contact_details_.InitDefault();
  }
  data_to_show_.contact_details_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowDetailsProto.contact_details)
}
inline std::string* ShowDetailsProto::mutable_contact_details() {
  std::string* _s = _internal_mutable_contact_details();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowDetailsProto.contact_details)
  return _s;
}
inline const std::string& ShowDetailsProto::_internal_contact_details() const {
  if (_internal_has_contact_details()) {
    return data_to_show_.contact_details_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ShowDetailsProto::_internal_set_contact_details(const std::string& value) {
  if (!_internal_has_contact_details()) {
    clear_data_to_show();
    set_has_contact_details();
    data_to_show_.contact_details_.InitDefault();
  }
  data_to_show_.contact_details_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowDetailsProto::_internal_mutable_contact_details() {
  if (!_internal_has_contact_details()) {
    clear_data_to_show();
    set_has_contact_details();
    data_to_show_.contact_details_.InitDefault();
  }
  return data_to_show_.contact_details_.Mutable(      GetArenaForAllocation());
}
inline std::string* ShowDetailsProto::release_contact_details() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowDetailsProto.contact_details)
  if (_internal_has_contact_details()) {
    clear_has_data_to_show();
    return data_to_show_.contact_details_.Release();
  } else {
    return nullptr;
  }
}
inline void ShowDetailsProto::set_allocated_contact_details(std::string* contact_details) {
  if (has_data_to_show()) {
    clear_data_to_show();
  }
  if (contact_details != nullptr) {
    set_has_contact_details();
    data_to_show_.contact_details_.InitAllocated(contact_details, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowDetailsProto.contact_details)
}

// bool credit_card = 4;
inline bool ShowDetailsProto::_internal_has_credit_card() const {
  return data_to_show_case() == kCreditCard;
}
inline bool ShowDetailsProto::has_credit_card() const {
  return _internal_has_credit_card();
}
inline void ShowDetailsProto::set_has_credit_card() {
  _oneof_case_[0] = kCreditCard;
}
inline void ShowDetailsProto::clear_credit_card() {
  if (_internal_has_credit_card()) {
    data_to_show_.credit_card_ = false;
    clear_has_data_to_show();
  }
}
inline bool ShowDetailsProto::_internal_credit_card() const {
  if (_internal_has_credit_card()) {
    return data_to_show_.credit_card_;
  }
  return false;
}
inline void ShowDetailsProto::_internal_set_credit_card(bool value) {
  if (!_internal_has_credit_card()) {
    clear_data_to_show();
    set_has_credit_card();
  }
  data_to_show_.credit_card_ = value;
}
inline bool ShowDetailsProto::credit_card() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.credit_card)
  return _internal_credit_card();
}
inline void ShowDetailsProto::set_credit_card(bool value) {
  _internal_set_credit_card(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowDetailsProto.credit_card)
}

// string shipping_address = 5;
inline bool ShowDetailsProto::_internal_has_shipping_address() const {
  return data_to_show_case() == kShippingAddress;
}
inline bool ShowDetailsProto::has_shipping_address() const {
  return _internal_has_shipping_address();
}
inline void ShowDetailsProto::set_has_shipping_address() {
  _oneof_case_[0] = kShippingAddress;
}
inline void ShowDetailsProto::clear_shipping_address() {
  if (_internal_has_shipping_address()) {
    data_to_show_.shipping_address_.Destroy();
    clear_has_data_to_show();
  }
}
inline const std::string& ShowDetailsProto::shipping_address() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.shipping_address)
  return _internal_shipping_address();
}
template <typename ArgT0, typename... ArgT>
inline void ShowDetailsProto::set_shipping_address(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_shipping_address()) {
    clear_data_to_show();
    set_has_shipping_address();
    data_to_show_.shipping_address_.InitDefault();
  }
  data_to_show_.shipping_address_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowDetailsProto.shipping_address)
}
inline std::string* ShowDetailsProto::mutable_shipping_address() {
  std::string* _s = _internal_mutable_shipping_address();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowDetailsProto.shipping_address)
  return _s;
}
inline const std::string& ShowDetailsProto::_internal_shipping_address() const {
  if (_internal_has_shipping_address()) {
    return data_to_show_.shipping_address_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ShowDetailsProto::_internal_set_shipping_address(const std::string& value) {
  if (!_internal_has_shipping_address()) {
    clear_data_to_show();
    set_has_shipping_address();
    data_to_show_.shipping_address_.InitDefault();
  }
  data_to_show_.shipping_address_.Set(value, GetArenaForAllocation());
}
inline std::string* ShowDetailsProto::_internal_mutable_shipping_address() {
  if (!_internal_has_shipping_address()) {
    clear_data_to_show();
    set_has_shipping_address();
    data_to_show_.shipping_address_.InitDefault();
  }
  return data_to_show_.shipping_address_.Mutable(      GetArenaForAllocation());
}
inline std::string* ShowDetailsProto::release_shipping_address() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowDetailsProto.shipping_address)
  if (_internal_has_shipping_address()) {
    clear_has_data_to_show();
    return data_to_show_.shipping_address_.Release();
  } else {
    return nullptr;
  }
}
inline void ShowDetailsProto::set_allocated_shipping_address(std::string* shipping_address) {
  if (has_data_to_show()) {
    clear_data_to_show();
  }
  if (shipping_address != nullptr) {
    set_has_shipping_address();
    data_to_show_.shipping_address_.InitAllocated(shipping_address, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowDetailsProto.shipping_address)
}

// optional .autofill_assistant.DetailsChangesProto change_flags = 2;
inline bool ShowDetailsProto::_internal_has_change_flags() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || change_flags_ != nullptr);
  return value;
}
inline bool ShowDetailsProto::has_change_flags() const {
  return _internal_has_change_flags();
}
inline void ShowDetailsProto::clear_change_flags() {
  if (change_flags_ != nullptr) change_flags_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::DetailsChangesProto& ShowDetailsProto::_internal_change_flags() const {
  const ::autofill_assistant::DetailsChangesProto* p = change_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DetailsChangesProto&>(
      ::autofill_assistant::_DetailsChangesProto_default_instance_);
}
inline const ::autofill_assistant::DetailsChangesProto& ShowDetailsProto::change_flags() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.change_flags)
  return _internal_change_flags();
}
inline void ShowDetailsProto::unsafe_arena_set_allocated_change_flags(
    ::autofill_assistant::DetailsChangesProto* change_flags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(change_flags_);
  }
  change_flags_ = change_flags;
  if (change_flags) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowDetailsProto.change_flags)
}
inline ::autofill_assistant::DetailsChangesProto* ShowDetailsProto::release_change_flags() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::DetailsChangesProto* temp = change_flags_;
  change_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DetailsChangesProto* ShowDetailsProto::unsafe_arena_release_change_flags() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowDetailsProto.change_flags)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::DetailsChangesProto* temp = change_flags_;
  change_flags_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DetailsChangesProto* ShowDetailsProto::_internal_mutable_change_flags() {
  _has_bits_[0] |= 0x00000001u;
  if (change_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DetailsChangesProto>(GetArenaForAllocation());
    change_flags_ = p;
  }
  return change_flags_;
}
inline ::autofill_assistant::DetailsChangesProto* ShowDetailsProto::mutable_change_flags() {
  ::autofill_assistant::DetailsChangesProto* _msg = _internal_mutable_change_flags();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowDetailsProto.change_flags)
  return _msg;
}
inline void ShowDetailsProto::set_allocated_change_flags(::autofill_assistant::DetailsChangesProto* change_flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete change_flags_;
  }
  if (change_flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(change_flags);
    if (message_arena != submessage_arena) {
      change_flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_flags, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  change_flags_ = change_flags;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowDetailsProto.change_flags)
}

// optional bool append = 6;
inline bool ShowDetailsProto::_internal_has_append() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowDetailsProto::has_append() const {
  return _internal_has_append();
}
inline void ShowDetailsProto::clear_append() {
  append_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ShowDetailsProto::_internal_append() const {
  return append_;
}
inline bool ShowDetailsProto::append() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.append)
  return _internal_append();
}
inline void ShowDetailsProto::_internal_set_append(bool value) {
  _has_bits_[0] |= 0x00000002u;
  append_ = value;
}
inline void ShowDetailsProto::set_append(bool value) {
  _internal_set_append(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowDetailsProto.append)
}

// optional int32 delay_ms = 7;
inline bool ShowDetailsProto::_internal_has_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShowDetailsProto::has_delay_ms() const {
  return _internal_has_delay_ms();
}
inline void ShowDetailsProto::clear_delay_ms() {
  delay_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ShowDetailsProto::_internal_delay_ms() const {
  return delay_ms_;
}
inline int32_t ShowDetailsProto::delay_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowDetailsProto.delay_ms)
  return _internal_delay_ms();
}
inline void ShowDetailsProto::_internal_set_delay_ms(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  delay_ms_ = value;
}
inline void ShowDetailsProto::set_delay_ms(int32_t value) {
  _internal_set_delay_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ShowDetailsProto.delay_ms)
}

inline bool ShowDetailsProto::has_data_to_show() const {
  return data_to_show_case() != DATA_TO_SHOW_NOT_SET;
}
inline void ShowDetailsProto::clear_has_data_to_show() {
  _oneof_case_[0] = DATA_TO_SHOW_NOT_SET;
}
inline ShowDetailsProto::DataToShowCase ShowDetailsProto::data_to_show_case() const {
  return ShowDetailsProto::DataToShowCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GeneratePasswordForFormFieldProto

// optional .autofill_assistant.SelectorProto element = 1;
inline bool GeneratePasswordForFormFieldProto::_internal_has_element() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || element_ != nullptr);
  return value;
}
inline bool GeneratePasswordForFormFieldProto::has_element() const {
  return _internal_has_element();
}
inline void GeneratePasswordForFormFieldProto::clear_element() {
  if (element_ != nullptr) element_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::SelectorProto& GeneratePasswordForFormFieldProto::_internal_element() const {
  const ::autofill_assistant::SelectorProto* p = element_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& GeneratePasswordForFormFieldProto::element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GeneratePasswordForFormFieldProto.element)
  return _internal_element();
}
inline void GeneratePasswordForFormFieldProto::unsafe_arena_set_allocated_element(
    ::autofill_assistant::SelectorProto* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_);
  }
  element_ = element;
  if (element) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GeneratePasswordForFormFieldProto.element)
}
inline ::autofill_assistant::SelectorProto* GeneratePasswordForFormFieldProto::release_element() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* GeneratePasswordForFormFieldProto::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GeneratePasswordForFormFieldProto.element)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* GeneratePasswordForFormFieldProto::_internal_mutable_element() {
  _has_bits_[0] |= 0x00000002u;
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    element_ = p;
  }
  return element_;
}
inline ::autofill_assistant::SelectorProto* GeneratePasswordForFormFieldProto::mutable_element() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GeneratePasswordForFormFieldProto.element)
  return _msg;
}
inline void GeneratePasswordForFormFieldProto::set_allocated_element(::autofill_assistant::SelectorProto* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GeneratePasswordForFormFieldProto.element)
}

// optional string memory_key = 2;
inline bool GeneratePasswordForFormFieldProto::_internal_has_memory_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GeneratePasswordForFormFieldProto::has_memory_key() const {
  return _internal_has_memory_key();
}
inline void GeneratePasswordForFormFieldProto::clear_memory_key() {
  memory_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GeneratePasswordForFormFieldProto::memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GeneratePasswordForFormFieldProto.memory_key)
  return _internal_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GeneratePasswordForFormFieldProto::set_memory_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 memory_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GeneratePasswordForFormFieldProto.memory_key)
}
inline std::string* GeneratePasswordForFormFieldProto::mutable_memory_key() {
  std::string* _s = _internal_mutable_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GeneratePasswordForFormFieldProto.memory_key)
  return _s;
}
inline const std::string& GeneratePasswordForFormFieldProto::_internal_memory_key() const {
  return memory_key_.Get();
}
inline void GeneratePasswordForFormFieldProto::_internal_set_memory_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* GeneratePasswordForFormFieldProto::_internal_mutable_memory_key() {
  _has_bits_[0] |= 0x00000001u;
  return memory_key_.Mutable(GetArenaForAllocation());
}
inline std::string* GeneratePasswordForFormFieldProto::release_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GeneratePasswordForFormFieldProto.memory_key)
  if (!_internal_has_memory_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = memory_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GeneratePasswordForFormFieldProto::set_allocated_memory_key(std::string* memory_key) {
  if (memory_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_key_.SetAllocated(memory_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GeneratePasswordForFormFieldProto.memory_key)
}

// -------------------------------------------------------------------

// PresaveGeneratedPasswordProto

// optional string memory_key = 1;
inline bool PresaveGeneratedPasswordProto::_internal_has_memory_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PresaveGeneratedPasswordProto::has_memory_key() const {
  return _internal_has_memory_key();
}
inline void PresaveGeneratedPasswordProto::clear_memory_key() {
  memory_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PresaveGeneratedPasswordProto::memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PresaveGeneratedPasswordProto.memory_key)
  return _internal_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PresaveGeneratedPasswordProto::set_memory_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 memory_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PresaveGeneratedPasswordProto.memory_key)
}
inline std::string* PresaveGeneratedPasswordProto::mutable_memory_key() {
  std::string* _s = _internal_mutable_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PresaveGeneratedPasswordProto.memory_key)
  return _s;
}
inline const std::string& PresaveGeneratedPasswordProto::_internal_memory_key() const {
  return memory_key_.Get();
}
inline void PresaveGeneratedPasswordProto::_internal_set_memory_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PresaveGeneratedPasswordProto::_internal_mutable_memory_key() {
  _has_bits_[0] |= 0x00000001u;
  return memory_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PresaveGeneratedPasswordProto::release_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PresaveGeneratedPasswordProto.memory_key)
  if (!_internal_has_memory_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = memory_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PresaveGeneratedPasswordProto::set_allocated_memory_key(std::string* memory_key) {
  if (memory_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_key_.SetAllocated(memory_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PresaveGeneratedPasswordProto.memory_key)
}

// -------------------------------------------------------------------

// SaveGeneratedPasswordProto

// optional string memory_key = 1;
inline bool SaveGeneratedPasswordProto::_internal_has_memory_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveGeneratedPasswordProto::has_memory_key() const {
  return _internal_has_memory_key();
}
inline void SaveGeneratedPasswordProto::clear_memory_key() {
  memory_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveGeneratedPasswordProto::memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SaveGeneratedPasswordProto.memory_key)
  return _internal_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveGeneratedPasswordProto::set_memory_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 memory_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SaveGeneratedPasswordProto.memory_key)
}
inline std::string* SaveGeneratedPasswordProto::mutable_memory_key() {
  std::string* _s = _internal_mutable_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SaveGeneratedPasswordProto.memory_key)
  return _s;
}
inline const std::string& SaveGeneratedPasswordProto::_internal_memory_key() const {
  return memory_key_.Get();
}
inline void SaveGeneratedPasswordProto::_internal_set_memory_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveGeneratedPasswordProto::_internal_mutable_memory_key() {
  _has_bits_[0] |= 0x00000001u;
  return memory_key_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveGeneratedPasswordProto::release_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SaveGeneratedPasswordProto.memory_key)
  if (!_internal_has_memory_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = memory_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SaveGeneratedPasswordProto::set_allocated_memory_key(std::string* memory_key) {
  if (memory_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_key_.SetAllocated(memory_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SaveGeneratedPasswordProto.memory_key)
}

// -------------------------------------------------------------------

// DeleteSelectedPasswordProto

// -------------------------------------------------------------------

// EditSelectedPasswordProto

// optional string memory_key = 1;
inline bool EditSelectedPasswordProto::_internal_has_memory_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EditSelectedPasswordProto::has_memory_key() const {
  return _internal_has_memory_key();
}
inline void EditSelectedPasswordProto::clear_memory_key() {
  memory_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EditSelectedPasswordProto::memory_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.EditSelectedPasswordProto.memory_key)
  return _internal_memory_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditSelectedPasswordProto::set_memory_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 memory_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.EditSelectedPasswordProto.memory_key)
}
inline std::string* EditSelectedPasswordProto::mutable_memory_key() {
  std::string* _s = _internal_mutable_memory_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.EditSelectedPasswordProto.memory_key)
  return _s;
}
inline const std::string& EditSelectedPasswordProto::_internal_memory_key() const {
  return memory_key_.Get();
}
inline void EditSelectedPasswordProto::_internal_set_memory_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memory_key_.Set(value, GetArenaForAllocation());
}
inline std::string* EditSelectedPasswordProto::_internal_mutable_memory_key() {
  _has_bits_[0] |= 0x00000001u;
  return memory_key_.Mutable(GetArenaForAllocation());
}
inline std::string* EditSelectedPasswordProto::release_memory_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.EditSelectedPasswordProto.memory_key)
  if (!_internal_has_memory_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = memory_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditSelectedPasswordProto::set_allocated_memory_key(std::string* memory_key) {
  if (memory_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_key_.SetAllocated(memory_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memory_key_.IsDefault()) {
    memory_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EditSelectedPasswordProto.memory_key)
}

// -------------------------------------------------------------------

// ResetPendingCredentialsProto

// -------------------------------------------------------------------

// SaveSubmittedPasswordProto_Result

// optional bool used_same_password = 1;
inline bool SaveSubmittedPasswordProto_Result::_internal_has_used_same_password() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveSubmittedPasswordProto_Result::has_used_same_password() const {
  return _internal_has_used_same_password();
}
inline void SaveSubmittedPasswordProto_Result::clear_used_same_password() {
  used_same_password_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SaveSubmittedPasswordProto_Result::_internal_used_same_password() const {
  return used_same_password_;
}
inline bool SaveSubmittedPasswordProto_Result::used_same_password() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SaveSubmittedPasswordProto.Result.used_same_password)
  return _internal_used_same_password();
}
inline void SaveSubmittedPasswordProto_Result::_internal_set_used_same_password(bool value) {
  _has_bits_[0] |= 0x00000001u;
  used_same_password_ = value;
}
inline void SaveSubmittedPasswordProto_Result::set_used_same_password(bool value) {
  _internal_set_used_same_password(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SaveSubmittedPasswordProto.Result.used_same_password)
}

// optional bool used_leaked_credential = 2;
inline bool SaveSubmittedPasswordProto_Result::_internal_has_used_leaked_credential() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SaveSubmittedPasswordProto_Result::has_used_leaked_credential() const {
  return _internal_has_used_leaked_credential();
}
inline void SaveSubmittedPasswordProto_Result::clear_used_leaked_credential() {
  used_leaked_credential_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SaveSubmittedPasswordProto_Result::_internal_used_leaked_credential() const {
  return used_leaked_credential_;
}
inline bool SaveSubmittedPasswordProto_Result::used_leaked_credential() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SaveSubmittedPasswordProto.Result.used_leaked_credential)
  return _internal_used_leaked_credential();
}
inline void SaveSubmittedPasswordProto_Result::_internal_set_used_leaked_credential(bool value) {
  _has_bits_[0] |= 0x00000002u;
  used_leaked_credential_ = value;
}
inline void SaveSubmittedPasswordProto_Result::set_used_leaked_credential(bool value) {
  _internal_set_used_leaked_credential(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SaveSubmittedPasswordProto.Result.used_leaked_credential)
}

// -------------------------------------------------------------------

// SaveSubmittedPasswordProto

// optional int32 leak_detection_timeout_ms = 1;
inline bool SaveSubmittedPasswordProto::_internal_has_leak_detection_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveSubmittedPasswordProto::has_leak_detection_timeout_ms() const {
  return _internal_has_leak_detection_timeout_ms();
}
inline void SaveSubmittedPasswordProto::clear_leak_detection_timeout_ms() {
  leak_detection_timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SaveSubmittedPasswordProto::_internal_leak_detection_timeout_ms() const {
  return leak_detection_timeout_ms_;
}
inline int32_t SaveSubmittedPasswordProto::leak_detection_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SaveSubmittedPasswordProto.leak_detection_timeout_ms)
  return _internal_leak_detection_timeout_ms();
}
inline void SaveSubmittedPasswordProto::_internal_set_leak_detection_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  leak_detection_timeout_ms_ = value;
}
inline void SaveSubmittedPasswordProto::set_leak_detection_timeout_ms(int32_t value) {
  _internal_set_leak_detection_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SaveSubmittedPasswordProto.leak_detection_timeout_ms)
}

// -------------------------------------------------------------------

// RegisterPasswordResetRequestProto

// -------------------------------------------------------------------

// ConfigureUiStateProto

// optional .autofill_assistant.ConfigureUiStateProto.OverlayBehavior overlay_behavior = 1;
inline bool ConfigureUiStateProto::_internal_has_overlay_behavior() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigureUiStateProto::has_overlay_behavior() const {
  return _internal_has_overlay_behavior();
}
inline void ConfigureUiStateProto::clear_overlay_behavior() {
  overlay_behavior_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto::_internal_overlay_behavior() const {
  return static_cast< ::autofill_assistant::ConfigureUiStateProto_OverlayBehavior >(overlay_behavior_);
}
inline ::autofill_assistant::ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto::overlay_behavior() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ConfigureUiStateProto.overlay_behavior)
  return _internal_overlay_behavior();
}
inline void ConfigureUiStateProto::_internal_set_overlay_behavior(::autofill_assistant::ConfigureUiStateProto_OverlayBehavior value) {
  assert(::autofill_assistant::ConfigureUiStateProto_OverlayBehavior_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  overlay_behavior_ = value;
}
inline void ConfigureUiStateProto::set_overlay_behavior(::autofill_assistant::ConfigureUiStateProto_OverlayBehavior value) {
  _internal_set_overlay_behavior(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ConfigureUiStateProto.overlay_behavior)
}

// -------------------------------------------------------------------

// SetAttributeProto

// optional .autofill_assistant.SelectorProto element = 1;
inline bool SetAttributeProto::_internal_has_element() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || element_ != nullptr);
  return value;
}
inline bool SetAttributeProto::has_element() const {
  return _internal_has_element();
}
inline void SetAttributeProto::clear_element() {
  if (element_ != nullptr) element_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::SelectorProto& SetAttributeProto::_internal_element() const {
  const ::autofill_assistant::SelectorProto* p = element_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::SelectorProto&>(
      ::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& SetAttributeProto::element() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetAttributeProto.element)
  return _internal_element();
}
inline void SetAttributeProto::unsafe_arena_set_allocated_element(
    ::autofill_assistant::SelectorProto* element) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_);
  }
  element_ = element;
  if (element) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetAttributeProto.element)
}
inline ::autofill_assistant::SelectorProto* SetAttributeProto::release_element() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::SelectorProto* SetAttributeProto::unsafe_arena_release_element() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetAttributeProto.element)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::SelectorProto* temp = element_;
  element_ = nullptr;
  return temp;
}
inline ::autofill_assistant::SelectorProto* SetAttributeProto::_internal_mutable_element() {
  _has_bits_[0] |= 0x00000002u;
  if (element_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::SelectorProto>(GetArenaForAllocation());
    element_ = p;
  }
  return element_;
}
inline ::autofill_assistant::SelectorProto* SetAttributeProto::mutable_element() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_element();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetAttributeProto.element)
  return _msg;
}
inline void SetAttributeProto::set_allocated_element(::autofill_assistant::SelectorProto* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_;
  }
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  element_ = element;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetAttributeProto.element)
}

// repeated string attribute = 2;
inline int SetAttributeProto::_internal_attribute_size() const {
  return attribute_.size();
}
inline int SetAttributeProto::attribute_size() const {
  return _internal_attribute_size();
}
inline void SetAttributeProto::clear_attribute() {
  attribute_.Clear();
}
inline std::string* SetAttributeProto::add_attribute() {
  std::string* _s = _internal_add_attribute();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.SetAttributeProto.attribute)
  return _s;
}
inline const std::string& SetAttributeProto::_internal_attribute(int index) const {
  return attribute_.Get(index);
}
inline const std::string& SetAttributeProto::attribute(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetAttributeProto.attribute)
  return _internal_attribute(index);
}
inline std::string* SetAttributeProto::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetAttributeProto.attribute)
  return attribute_.Mutable(index);
}
inline void SetAttributeProto::set_attribute(int index, const std::string& value) {
  attribute_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SetAttributeProto.attribute)
}
inline void SetAttributeProto::set_attribute(int index, std::string&& value) {
  attribute_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.SetAttributeProto.attribute)
}
inline void SetAttributeProto::set_attribute(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attribute_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.SetAttributeProto.attribute)
}
inline void SetAttributeProto::set_attribute(int index, const char* value, size_t size) {
  attribute_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.SetAttributeProto.attribute)
}
inline std::string* SetAttributeProto::_internal_add_attribute() {
  return attribute_.Add();
}
inline void SetAttributeProto::add_attribute(const std::string& value) {
  attribute_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.SetAttributeProto.attribute)
}
inline void SetAttributeProto::add_attribute(std::string&& value) {
  attribute_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.SetAttributeProto.attribute)
}
inline void SetAttributeProto::add_attribute(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attribute_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.SetAttributeProto.attribute)
}
inline void SetAttributeProto::add_attribute(const char* value, size_t size) {
  attribute_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.SetAttributeProto.attribute)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetAttributeProto::attribute() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SetAttributeProto.attribute)
  return attribute_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetAttributeProto::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SetAttributeProto.attribute)
  return &attribute_;
}

// optional string value = 3;
inline bool SetAttributeProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetAttributeProto::has_value() const {
  return _internal_has_value();
}
inline void SetAttributeProto::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetAttributeProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetAttributeProto.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAttributeProto::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SetAttributeProto.value)
}
inline std::string* SetAttributeProto::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetAttributeProto.value)
  return _s;
}
inline const std::string& SetAttributeProto::_internal_value() const {
  return value_.Get();
}
inline void SetAttributeProto::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetAttributeProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* SetAttributeProto::release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetAttributeProto.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetAttributeProto::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetAttributeProto.value)
}

// -------------------------------------------------------------------

// InfoBoxProto

// string image_path = 1;
inline bool InfoBoxProto::_internal_has_image_path() const {
  return image_case() == kImagePath;
}
inline bool InfoBoxProto::has_image_path() const {
  return _internal_has_image_path();
}
inline void InfoBoxProto::set_has_image_path() {
  _oneof_case_[0] = kImagePath;
}
inline void InfoBoxProto::clear_image_path() {
  if (_internal_has_image_path()) {
    image_.image_path_.Destroy();
    clear_has_image();
  }
}
inline const std::string& InfoBoxProto::image_path() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoBoxProto.image_path)
  return _internal_image_path();
}
template <typename ArgT0, typename... ArgT>
inline void InfoBoxProto::set_image_path(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image_path()) {
    clear_image();
    set_has_image_path();
    image_.image_path_.InitDefault();
  }
  image_.image_path_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InfoBoxProto.image_path)
}
inline std::string* InfoBoxProto::mutable_image_path() {
  std::string* _s = _internal_mutable_image_path();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoBoxProto.image_path)
  return _s;
}
inline const std::string& InfoBoxProto::_internal_image_path() const {
  if (_internal_has_image_path()) {
    return image_.image_path_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InfoBoxProto::_internal_set_image_path(const std::string& value) {
  if (!_internal_has_image_path()) {
    clear_image();
    set_has_image_path();
    image_.image_path_.InitDefault();
  }
  image_.image_path_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoBoxProto::_internal_mutable_image_path() {
  if (!_internal_has_image_path()) {
    clear_image();
    set_has_image_path();
    image_.image_path_.InitDefault();
  }
  return image_.image_path_.Mutable(      GetArenaForAllocation());
}
inline std::string* InfoBoxProto::release_image_path() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoBoxProto.image_path)
  if (_internal_has_image_path()) {
    clear_has_image();
    return image_.image_path_.Release();
  } else {
    return nullptr;
  }
}
inline void InfoBoxProto::set_allocated_image_path(std::string* image_path) {
  if (has_image()) {
    clear_image();
  }
  if (image_path != nullptr) {
    set_has_image_path();
    image_.image_path_.InitAllocated(image_path, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoBoxProto.image_path)
}

// .autofill_assistant.DrawableProto drawable = 4;
inline bool InfoBoxProto::_internal_has_drawable() const {
  return image_case() == kDrawable;
}
inline bool InfoBoxProto::has_drawable() const {
  return _internal_has_drawable();
}
inline void InfoBoxProto::set_has_drawable() {
  _oneof_case_[0] = kDrawable;
}
inline ::autofill_assistant::DrawableProto* InfoBoxProto::release_drawable() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoBoxProto.drawable)
  if (_internal_has_drawable()) {
    clear_has_image();
    ::autofill_assistant::DrawableProto* temp = image_.drawable_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_.drawable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DrawableProto& InfoBoxProto::_internal_drawable() const {
  return _internal_has_drawable()
      ? *image_.drawable_
      : reinterpret_cast< ::autofill_assistant::DrawableProto&>(::autofill_assistant::_DrawableProto_default_instance_);
}
inline const ::autofill_assistant::DrawableProto& InfoBoxProto::drawable() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoBoxProto.drawable)
  return _internal_drawable();
}
inline ::autofill_assistant::DrawableProto* InfoBoxProto::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.InfoBoxProto.drawable)
  if (_internal_has_drawable()) {
    clear_has_image();
    ::autofill_assistant::DrawableProto* temp = image_.drawable_;
    image_.drawable_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InfoBoxProto::unsafe_arena_set_allocated_drawable(::autofill_assistant::DrawableProto* drawable) {
  clear_image();
  if (drawable) {
    set_has_drawable();
    image_.drawable_ = drawable;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InfoBoxProto.drawable)
}
inline ::autofill_assistant::DrawableProto* InfoBoxProto::_internal_mutable_drawable() {
  if (!_internal_has_drawable()) {
    clear_image();
    set_has_drawable();
    image_.drawable_ = CreateMaybeMessage< ::autofill_assistant::DrawableProto >(GetArenaForAllocation());
  }
  return image_.drawable_;
}
inline ::autofill_assistant::DrawableProto* InfoBoxProto::mutable_drawable() {
  ::autofill_assistant::DrawableProto* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoBoxProto.drawable)
  return _msg;
}

// optional string explanation = 2;
inline bool InfoBoxProto::_internal_has_explanation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InfoBoxProto::has_explanation() const {
  return _internal_has_explanation();
}
inline void InfoBoxProto::clear_explanation() {
  explanation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InfoBoxProto::explanation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoBoxProto.explanation)
  return _internal_explanation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoBoxProto::set_explanation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 explanation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InfoBoxProto.explanation)
}
inline std::string* InfoBoxProto::mutable_explanation() {
  std::string* _s = _internal_mutable_explanation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoBoxProto.explanation)
  return _s;
}
inline const std::string& InfoBoxProto::_internal_explanation() const {
  return explanation_.Get();
}
inline void InfoBoxProto::_internal_set_explanation(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  explanation_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoBoxProto::_internal_mutable_explanation() {
  _has_bits_[0] |= 0x00000001u;
  return explanation_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoBoxProto::release_explanation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoBoxProto.explanation)
  if (!_internal_has_explanation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = explanation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (explanation_.IsDefault()) {
    explanation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InfoBoxProto::set_allocated_explanation(std::string* explanation) {
  if (explanation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  explanation_.SetAllocated(explanation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (explanation_.IsDefault()) {
    explanation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoBoxProto.explanation)
}

inline bool InfoBoxProto::has_image() const {
  return image_case() != IMAGE_NOT_SET;
}
inline void InfoBoxProto::clear_has_image() {
  _oneof_case_[0] = IMAGE_NOT_SET;
}
inline InfoBoxProto::ImageCase InfoBoxProto::image_case() const {
  return InfoBoxProto::ImageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShowInfoBoxProto

// optional .autofill_assistant.InfoBoxProto info_box = 1;
inline bool ShowInfoBoxProto::_internal_has_info_box() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_box_ != nullptr);
  return value;
}
inline bool ShowInfoBoxProto::has_info_box() const {
  return _internal_has_info_box();
}
inline void ShowInfoBoxProto::clear_info_box() {
  if (info_box_ != nullptr) info_box_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::InfoBoxProto& ShowInfoBoxProto::_internal_info_box() const {
  const ::autofill_assistant::InfoBoxProto* p = info_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoBoxProto&>(
      ::autofill_assistant::_InfoBoxProto_default_instance_);
}
inline const ::autofill_assistant::InfoBoxProto& ShowInfoBoxProto::info_box() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowInfoBoxProto.info_box)
  return _internal_info_box();
}
inline void ShowInfoBoxProto::unsafe_arena_set_allocated_info_box(
    ::autofill_assistant::InfoBoxProto* info_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_box_);
  }
  info_box_ = info_box;
  if (info_box) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowInfoBoxProto.info_box)
}
inline ::autofill_assistant::InfoBoxProto* ShowInfoBoxProto::release_info_box() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::InfoBoxProto* temp = info_box_;
  info_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoBoxProto* ShowInfoBoxProto::unsafe_arena_release_info_box() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowInfoBoxProto.info_box)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::InfoBoxProto* temp = info_box_;
  info_box_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoBoxProto* ShowInfoBoxProto::_internal_mutable_info_box() {
  _has_bits_[0] |= 0x00000001u;
  if (info_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoBoxProto>(GetArenaForAllocation());
    info_box_ = p;
  }
  return info_box_;
}
inline ::autofill_assistant::InfoBoxProto* ShowInfoBoxProto::mutable_info_box() {
  ::autofill_assistant::InfoBoxProto* _msg = _internal_mutable_info_box();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowInfoBoxProto.info_box)
  return _msg;
}
inline void ShowInfoBoxProto::set_allocated_info_box(::autofill_assistant::InfoBoxProto* info_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_box_;
  }
  if (info_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info_box);
    if (message_arena != submessage_arena) {
      info_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info_box, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_box_ = info_box;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowInfoBoxProto.info_box)
}

// -------------------------------------------------------------------

// ConfigureBottomSheetProto

// optional .autofill_assistant.ConfigureBottomSheetProto.ViewportResizing viewport_resizing = 1;
inline bool ConfigureBottomSheetProto::_internal_has_viewport_resizing() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigureBottomSheetProto::has_viewport_resizing() const {
  return _internal_has_viewport_resizing();
}
inline void ConfigureBottomSheetProto::clear_viewport_resizing() {
  viewport_resizing_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::_internal_viewport_resizing() const {
  return static_cast< ::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing >(viewport_resizing_);
}
inline ::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::viewport_resizing() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ConfigureBottomSheetProto.viewport_resizing)
  return _internal_viewport_resizing();
}
inline void ConfigureBottomSheetProto::_internal_set_viewport_resizing(::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing value) {
  assert(::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  viewport_resizing_ = value;
}
inline void ConfigureBottomSheetProto::set_viewport_resizing(::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing value) {
  _internal_set_viewport_resizing(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ConfigureBottomSheetProto.viewport_resizing)
}

// optional .autofill_assistant.ConfigureBottomSheetProto.PeekMode peek_mode = 2;
inline bool ConfigureBottomSheetProto::_internal_has_peek_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigureBottomSheetProto::has_peek_mode() const {
  return _internal_has_peek_mode();
}
inline void ConfigureBottomSheetProto::clear_peek_mode() {
  peek_mode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill_assistant::ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::_internal_peek_mode() const {
  return static_cast< ::autofill_assistant::ConfigureBottomSheetProto_PeekMode >(peek_mode_);
}
inline ::autofill_assistant::ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::peek_mode() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ConfigureBottomSheetProto.peek_mode)
  return _internal_peek_mode();
}
inline void ConfigureBottomSheetProto::_internal_set_peek_mode(::autofill_assistant::ConfigureBottomSheetProto_PeekMode value) {
  assert(::autofill_assistant::ConfigureBottomSheetProto_PeekMode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  peek_mode_ = value;
}
inline void ConfigureBottomSheetProto::set_peek_mode(::autofill_assistant::ConfigureBottomSheetProto_PeekMode value) {
  _internal_set_peek_mode(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ConfigureBottomSheetProto.peek_mode)
}

// optional int32 resize_timeout_ms = 3;
inline bool ConfigureBottomSheetProto::_internal_has_resize_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigureBottomSheetProto::has_resize_timeout_ms() const {
  return _internal_has_resize_timeout_ms();
}
inline void ConfigureBottomSheetProto::clear_resize_timeout_ms() {
  resize_timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ConfigureBottomSheetProto::_internal_resize_timeout_ms() const {
  return resize_timeout_ms_;
}
inline int32_t ConfigureBottomSheetProto::resize_timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ConfigureBottomSheetProto.resize_timeout_ms)
  return _internal_resize_timeout_ms();
}
inline void ConfigureBottomSheetProto::_internal_set_resize_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  resize_timeout_ms_ = value;
}
inline void ConfigureBottomSheetProto::set_resize_timeout_ms(int32_t value) {
  _internal_set_resize_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ConfigureBottomSheetProto.resize_timeout_ms)
}

// bool expand = 4;
inline bool ConfigureBottomSheetProto::_internal_has_expand() const {
  return apply_state_case() == kExpand;
}
inline bool ConfigureBottomSheetProto::has_expand() const {
  return _internal_has_expand();
}
inline void ConfigureBottomSheetProto::set_has_expand() {
  _oneof_case_[0] = kExpand;
}
inline void ConfigureBottomSheetProto::clear_expand() {
  if (_internal_has_expand()) {
    apply_state_.expand_ = false;
    clear_has_apply_state();
  }
}
inline bool ConfigureBottomSheetProto::_internal_expand() const {
  if (_internal_has_expand()) {
    return apply_state_.expand_;
  }
  return false;
}
inline void ConfigureBottomSheetProto::_internal_set_expand(bool value) {
  if (!_internal_has_expand()) {
    clear_apply_state();
    set_has_expand();
  }
  apply_state_.expand_ = value;
}
inline bool ConfigureBottomSheetProto::expand() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ConfigureBottomSheetProto.expand)
  return _internal_expand();
}
inline void ConfigureBottomSheetProto::set_expand(bool value) {
  _internal_set_expand(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ConfigureBottomSheetProto.expand)
}

// bool collapse = 5;
inline bool ConfigureBottomSheetProto::_internal_has_collapse() const {
  return apply_state_case() == kCollapse;
}
inline bool ConfigureBottomSheetProto::has_collapse() const {
  return _internal_has_collapse();
}
inline void ConfigureBottomSheetProto::set_has_collapse() {
  _oneof_case_[0] = kCollapse;
}
inline void ConfigureBottomSheetProto::clear_collapse() {
  if (_internal_has_collapse()) {
    apply_state_.collapse_ = false;
    clear_has_apply_state();
  }
}
inline bool ConfigureBottomSheetProto::_internal_collapse() const {
  if (_internal_has_collapse()) {
    return apply_state_.collapse_;
  }
  return false;
}
inline void ConfigureBottomSheetProto::_internal_set_collapse(bool value) {
  if (!_internal_has_collapse()) {
    clear_apply_state();
    set_has_collapse();
  }
  apply_state_.collapse_ = value;
}
inline bool ConfigureBottomSheetProto::collapse() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ConfigureBottomSheetProto.collapse)
  return _internal_collapse();
}
inline void ConfigureBottomSheetProto::set_collapse(bool value) {
  _internal_set_collapse(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ConfigureBottomSheetProto.collapse)
}

inline bool ConfigureBottomSheetProto::has_apply_state() const {
  return apply_state_case() != APPLY_STATE_NOT_SET;
}
inline void ConfigureBottomSheetProto::clear_has_apply_state() {
  _oneof_case_[0] = APPLY_STATE_NOT_SET;
}
inline ConfigureBottomSheetProto::ApplyStateCase ConfigureBottomSheetProto::apply_state_case() const {
  return ConfigureBottomSheetProto::ApplyStateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShowFormProto

// optional .autofill_assistant.FormProto form = 1;
inline bool ShowFormProto::_internal_has_form() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || form_ != nullptr);
  return value;
}
inline bool ShowFormProto::has_form() const {
  return _internal_has_form();
}
inline void ShowFormProto::clear_form() {
  if (form_ != nullptr) form_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::FormProto& ShowFormProto::_internal_form() const {
  const ::autofill_assistant::FormProto* p = form_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::FormProto&>(
      ::autofill_assistant::_FormProto_default_instance_);
}
inline const ::autofill_assistant::FormProto& ShowFormProto::form() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowFormProto.form)
  return _internal_form();
}
inline void ShowFormProto::unsafe_arena_set_allocated_form(
    ::autofill_assistant::FormProto* form) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(form_);
  }
  form_ = form;
  if (form) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowFormProto.form)
}
inline ::autofill_assistant::FormProto* ShowFormProto::release_form() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::FormProto* temp = form_;
  form_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::FormProto* ShowFormProto::unsafe_arena_release_form() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowFormProto.form)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::FormProto* temp = form_;
  form_ = nullptr;
  return temp;
}
inline ::autofill_assistant::FormProto* ShowFormProto::_internal_mutable_form() {
  _has_bits_[0] |= 0x00000001u;
  if (form_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::FormProto>(GetArenaForAllocation());
    form_ = p;
  }
  return form_;
}
inline ::autofill_assistant::FormProto* ShowFormProto::mutable_form() {
  ::autofill_assistant::FormProto* _msg = _internal_mutable_form();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowFormProto.form)
  return _msg;
}
inline void ShowFormProto::set_allocated_form(::autofill_assistant::FormProto* form) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete form_;
  }
  if (form) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(form);
    if (message_arena != submessage_arena) {
      form = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  form_ = form;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowFormProto.form)
}

// optional .autofill_assistant.ChipProto chip = 2;
inline bool ShowFormProto::_internal_has_chip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || chip_ != nullptr);
  return value;
}
inline bool ShowFormProto::has_chip() const {
  return _internal_has_chip();
}
inline const ::autofill_assistant::ChipProto& ShowFormProto::_internal_chip() const {
  const ::autofill_assistant::ChipProto* p = chip_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ChipProto&>(
      ::autofill_assistant::_ChipProto_default_instance_);
}
inline const ::autofill_assistant::ChipProto& ShowFormProto::chip() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShowFormProto.chip)
  return _internal_chip();
}
inline void ShowFormProto::unsafe_arena_set_allocated_chip(
    ::autofill_assistant::ChipProto* chip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  chip_ = chip;
  if (chip) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShowFormProto.chip)
}
inline ::autofill_assistant::ChipProto* ShowFormProto::release_chip() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ChipProto* ShowFormProto::unsafe_arena_release_chip() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShowFormProto.chip)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ChipProto* temp = chip_;
  chip_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ChipProto* ShowFormProto::_internal_mutable_chip() {
  _has_bits_[0] |= 0x00000002u;
  if (chip_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ChipProto>(GetArenaForAllocation());
    chip_ = p;
  }
  return chip_;
}
inline ::autofill_assistant::ChipProto* ShowFormProto::mutable_chip() {
  ::autofill_assistant::ChipProto* _msg = _internal_mutable_chip();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShowFormProto.chip)
  return _msg;
}
inline void ShowFormProto::set_allocated_chip(::autofill_assistant::ChipProto* chip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip_);
  }
  if (chip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chip));
    if (message_arena != submessage_arena) {
      chip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  chip_ = chip;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowFormProto.chip)
}

// -------------------------------------------------------------------

// FormProto_Result

// repeated .autofill_assistant.FormInputProto.Result input_results = 1;
inline int FormProto_Result::_internal_input_results_size() const {
  return input_results_.size();
}
inline int FormProto_Result::input_results_size() const {
  return _internal_input_results_size();
}
inline void FormProto_Result::clear_input_results() {
  input_results_.Clear();
}
inline ::autofill_assistant::FormInputProto_Result* FormProto_Result::mutable_input_results(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormProto.Result.input_results)
  return input_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto_Result >*
FormProto_Result::mutable_input_results() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.FormProto.Result.input_results)
  return &input_results_;
}
inline const ::autofill_assistant::FormInputProto_Result& FormProto_Result::_internal_input_results(int index) const {
  return input_results_.Get(index);
}
inline const ::autofill_assistant::FormInputProto_Result& FormProto_Result::input_results(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormProto.Result.input_results)
  return _internal_input_results(index);
}
inline ::autofill_assistant::FormInputProto_Result* FormProto_Result::_internal_add_input_results() {
  return input_results_.Add();
}
inline ::autofill_assistant::FormInputProto_Result* FormProto_Result::add_input_results() {
  ::autofill_assistant::FormInputProto_Result* _add = _internal_add_input_results();
  // @@protoc_insertion_point(field_add:autofill_assistant.FormProto.Result.input_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto_Result >&
FormProto_Result::input_results() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.FormProto.Result.input_results)
  return input_results_;
}

// optional int32 link = 2;
inline bool FormProto_Result::_internal_has_link() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FormProto_Result::has_link() const {
  return _internal_has_link();
}
inline void FormProto_Result::clear_link() {
  link_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t FormProto_Result::_internal_link() const {
  return link_;
}
inline int32_t FormProto_Result::link() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormProto.Result.link)
  return _internal_link();
}
inline void FormProto_Result::_internal_set_link(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  link_ = value;
}
inline void FormProto_Result::set_link(int32_t value) {
  _internal_set_link(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.FormProto.Result.link)
}

// -------------------------------------------------------------------

// FormProto

// repeated .autofill_assistant.FormInputProto inputs = 1;
inline int FormProto::_internal_inputs_size() const {
  return inputs_.size();
}
inline int FormProto::inputs_size() const {
  return _internal_inputs_size();
}
inline void FormProto::clear_inputs() {
  inputs_.Clear();
}
inline ::autofill_assistant::FormInputProto* FormProto::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormProto.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto >*
FormProto::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.FormProto.inputs)
  return &inputs_;
}
inline const ::autofill_assistant::FormInputProto& FormProto::_internal_inputs(int index) const {
  return inputs_.Get(index);
}
inline const ::autofill_assistant::FormInputProto& FormProto::inputs(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormProto.inputs)
  return _internal_inputs(index);
}
inline ::autofill_assistant::FormInputProto* FormProto::_internal_add_inputs() {
  return inputs_.Add();
}
inline ::autofill_assistant::FormInputProto* FormProto::add_inputs() {
  ::autofill_assistant::FormInputProto* _add = _internal_add_inputs();
  // @@protoc_insertion_point(field_add:autofill_assistant.FormProto.inputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::FormInputProto >&
FormProto::inputs() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.FormProto.inputs)
  return inputs_;
}

// optional string info_label = 2;
inline bool FormProto::_internal_has_info_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FormProto::has_info_label() const {
  return _internal_has_info_label();
}
inline void FormProto::clear_info_label() {
  info_label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FormProto::info_label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormProto.info_label)
  return _internal_info_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FormProto::set_info_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 info_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.FormProto.info_label)
}
inline std::string* FormProto::mutable_info_label() {
  std::string* _s = _internal_mutable_info_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormProto.info_label)
  return _s;
}
inline const std::string& FormProto::_internal_info_label() const {
  return info_label_.Get();
}
inline void FormProto::_internal_set_info_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  info_label_.Set(value, GetArenaForAllocation());
}
inline std::string* FormProto::_internal_mutable_info_label() {
  _has_bits_[0] |= 0x00000001u;
  return info_label_.Mutable(GetArenaForAllocation());
}
inline std::string* FormProto::release_info_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FormProto.info_label)
  if (!_internal_has_info_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = info_label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_label_.IsDefault()) {
    info_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FormProto::set_allocated_info_label(std::string* info_label) {
  if (info_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_label_.SetAllocated(info_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_label_.IsDefault()) {
    info_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FormProto.info_label)
}

// optional .autofill_assistant.InfoPopupProto info_popup = 3;
inline bool FormProto::_internal_has_info_popup() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || info_popup_ != nullptr);
  return value;
}
inline bool FormProto::has_info_popup() const {
  return _internal_has_info_popup();
}
inline const ::autofill_assistant::InfoPopupProto& FormProto::_internal_info_popup() const {
  const ::autofill_assistant::InfoPopupProto* p = info_popup_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoPopupProto&>(
      ::autofill_assistant::_InfoPopupProto_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto& FormProto::info_popup() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormProto.info_popup)
  return _internal_info_popup();
}
inline void FormProto::unsafe_arena_set_allocated_info_popup(
    ::autofill_assistant::InfoPopupProto* info_popup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup_);
  }
  info_popup_ = info_popup;
  if (info_popup) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FormProto.info_popup)
}
inline ::autofill_assistant::InfoPopupProto* FormProto::release_info_popup() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::InfoPopupProto* temp = info_popup_;
  info_popup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoPopupProto* FormProto::unsafe_arena_release_info_popup() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FormProto.info_popup)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::InfoPopupProto* temp = info_popup_;
  info_popup_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoPopupProto* FormProto::_internal_mutable_info_popup() {
  _has_bits_[0] |= 0x00000002u;
  if (info_popup_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoPopupProto>(GetArenaForAllocation());
    info_popup_ = p;
  }
  return info_popup_;
}
inline ::autofill_assistant::InfoPopupProto* FormProto::mutable_info_popup() {
  ::autofill_assistant::InfoPopupProto* _msg = _internal_mutable_info_popup();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormProto.info_popup)
  return _msg;
}
inline void FormProto::set_allocated_info_popup(::autofill_assistant::InfoPopupProto* info_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup_);
  }
  if (info_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_popup));
    if (message_arena != submessage_arena) {
      info_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info_popup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  info_popup_ = info_popup;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FormProto.info_popup)
}

// -------------------------------------------------------------------

// FormInputProto_Result

// .autofill_assistant.CounterInputProto.Result counter = 1;
inline bool FormInputProto_Result::_internal_has_counter() const {
  return input_type_case() == kCounter;
}
inline bool FormInputProto_Result::has_counter() const {
  return _internal_has_counter();
}
inline void FormInputProto_Result::set_has_counter() {
  _oneof_case_[0] = kCounter;
}
inline void FormInputProto_Result::clear_counter() {
  if (_internal_has_counter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete input_type_.counter_;
    }
    clear_has_input_type();
  }
}
inline ::autofill_assistant::CounterInputProto_Result* FormInputProto_Result::release_counter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FormInputProto.Result.counter)
  if (_internal_has_counter()) {
    clear_has_input_type();
    ::autofill_assistant::CounterInputProto_Result* temp = input_type_.counter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    input_type_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CounterInputProto_Result& FormInputProto_Result::_internal_counter() const {
  return _internal_has_counter()
      ? *input_type_.counter_
      : reinterpret_cast< ::autofill_assistant::CounterInputProto_Result&>(::autofill_assistant::_CounterInputProto_Result_default_instance_);
}
inline const ::autofill_assistant::CounterInputProto_Result& FormInputProto_Result::counter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormInputProto.Result.counter)
  return _internal_counter();
}
inline ::autofill_assistant::CounterInputProto_Result* FormInputProto_Result::unsafe_arena_release_counter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.FormInputProto.Result.counter)
  if (_internal_has_counter()) {
    clear_has_input_type();
    ::autofill_assistant::CounterInputProto_Result* temp = input_type_.counter_;
    input_type_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FormInputProto_Result::unsafe_arena_set_allocated_counter(::autofill_assistant::CounterInputProto_Result* counter) {
  clear_input_type();
  if (counter) {
    set_has_counter();
    input_type_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FormInputProto.Result.counter)
}
inline ::autofill_assistant::CounterInputProto_Result* FormInputProto_Result::_internal_mutable_counter() {
  if (!_internal_has_counter()) {
    clear_input_type();
    set_has_counter();
    input_type_.counter_ = CreateMaybeMessage< ::autofill_assistant::CounterInputProto_Result >(GetArenaForAllocation());
  }
  return input_type_.counter_;
}
inline ::autofill_assistant::CounterInputProto_Result* FormInputProto_Result::mutable_counter() {
  ::autofill_assistant::CounterInputProto_Result* _msg = _internal_mutable_counter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormInputProto.Result.counter)
  return _msg;
}

// .autofill_assistant.SelectionInputProto.Result selection = 2;
inline bool FormInputProto_Result::_internal_has_selection() const {
  return input_type_case() == kSelection;
}
inline bool FormInputProto_Result::has_selection() const {
  return _internal_has_selection();
}
inline void FormInputProto_Result::set_has_selection() {
  _oneof_case_[0] = kSelection;
}
inline void FormInputProto_Result::clear_selection() {
  if (_internal_has_selection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete input_type_.selection_;
    }
    clear_has_input_type();
  }
}
inline ::autofill_assistant::SelectionInputProto_Result* FormInputProto_Result::release_selection() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FormInputProto.Result.selection)
  if (_internal_has_selection()) {
    clear_has_input_type();
    ::autofill_assistant::SelectionInputProto_Result* temp = input_type_.selection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    input_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectionInputProto_Result& FormInputProto_Result::_internal_selection() const {
  return _internal_has_selection()
      ? *input_type_.selection_
      : reinterpret_cast< ::autofill_assistant::SelectionInputProto_Result&>(::autofill_assistant::_SelectionInputProto_Result_default_instance_);
}
inline const ::autofill_assistant::SelectionInputProto_Result& FormInputProto_Result::selection() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormInputProto.Result.selection)
  return _internal_selection();
}
inline ::autofill_assistant::SelectionInputProto_Result* FormInputProto_Result::unsafe_arena_release_selection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.FormInputProto.Result.selection)
  if (_internal_has_selection()) {
    clear_has_input_type();
    ::autofill_assistant::SelectionInputProto_Result* temp = input_type_.selection_;
    input_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FormInputProto_Result::unsafe_arena_set_allocated_selection(::autofill_assistant::SelectionInputProto_Result* selection) {
  clear_input_type();
  if (selection) {
    set_has_selection();
    input_type_.selection_ = selection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FormInputProto.Result.selection)
}
inline ::autofill_assistant::SelectionInputProto_Result* FormInputProto_Result::_internal_mutable_selection() {
  if (!_internal_has_selection()) {
    clear_input_type();
    set_has_selection();
    input_type_.selection_ = CreateMaybeMessage< ::autofill_assistant::SelectionInputProto_Result >(GetArenaForAllocation());
  }
  return input_type_.selection_;
}
inline ::autofill_assistant::SelectionInputProto_Result* FormInputProto_Result::mutable_selection() {
  ::autofill_assistant::SelectionInputProto_Result* _msg = _internal_mutable_selection();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormInputProto.Result.selection)
  return _msg;
}

inline bool FormInputProto_Result::has_input_type() const {
  return input_type_case() != INPUT_TYPE_NOT_SET;
}
inline void FormInputProto_Result::clear_has_input_type() {
  _oneof_case_[0] = INPUT_TYPE_NOT_SET;
}
inline FormInputProto_Result::InputTypeCase FormInputProto_Result::input_type_case() const {
  return FormInputProto_Result::InputTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FormInputProto

// .autofill_assistant.CounterInputProto counter = 1;
inline bool FormInputProto::_internal_has_counter() const {
  return input_type_case() == kCounter;
}
inline bool FormInputProto::has_counter() const {
  return _internal_has_counter();
}
inline void FormInputProto::set_has_counter() {
  _oneof_case_[0] = kCounter;
}
inline void FormInputProto::clear_counter() {
  if (_internal_has_counter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete input_type_.counter_;
    }
    clear_has_input_type();
  }
}
inline ::autofill_assistant::CounterInputProto* FormInputProto::release_counter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FormInputProto.counter)
  if (_internal_has_counter()) {
    clear_has_input_type();
    ::autofill_assistant::CounterInputProto* temp = input_type_.counter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    input_type_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CounterInputProto& FormInputProto::_internal_counter() const {
  return _internal_has_counter()
      ? *input_type_.counter_
      : reinterpret_cast< ::autofill_assistant::CounterInputProto&>(::autofill_assistant::_CounterInputProto_default_instance_);
}
inline const ::autofill_assistant::CounterInputProto& FormInputProto::counter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormInputProto.counter)
  return _internal_counter();
}
inline ::autofill_assistant::CounterInputProto* FormInputProto::unsafe_arena_release_counter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.FormInputProto.counter)
  if (_internal_has_counter()) {
    clear_has_input_type();
    ::autofill_assistant::CounterInputProto* temp = input_type_.counter_;
    input_type_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FormInputProto::unsafe_arena_set_allocated_counter(::autofill_assistant::CounterInputProto* counter) {
  clear_input_type();
  if (counter) {
    set_has_counter();
    input_type_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FormInputProto.counter)
}
inline ::autofill_assistant::CounterInputProto* FormInputProto::_internal_mutable_counter() {
  if (!_internal_has_counter()) {
    clear_input_type();
    set_has_counter();
    input_type_.counter_ = CreateMaybeMessage< ::autofill_assistant::CounterInputProto >(GetArenaForAllocation());
  }
  return input_type_.counter_;
}
inline ::autofill_assistant::CounterInputProto* FormInputProto::mutable_counter() {
  ::autofill_assistant::CounterInputProto* _msg = _internal_mutable_counter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormInputProto.counter)
  return _msg;
}

// .autofill_assistant.SelectionInputProto selection = 2;
inline bool FormInputProto::_internal_has_selection() const {
  return input_type_case() == kSelection;
}
inline bool FormInputProto::has_selection() const {
  return _internal_has_selection();
}
inline void FormInputProto::set_has_selection() {
  _oneof_case_[0] = kSelection;
}
inline void FormInputProto::clear_selection() {
  if (_internal_has_selection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete input_type_.selection_;
    }
    clear_has_input_type();
  }
}
inline ::autofill_assistant::SelectionInputProto* FormInputProto::release_selection() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FormInputProto.selection)
  if (_internal_has_selection()) {
    clear_has_input_type();
    ::autofill_assistant::SelectionInputProto* temp = input_type_.selection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    input_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectionInputProto& FormInputProto::_internal_selection() const {
  return _internal_has_selection()
      ? *input_type_.selection_
      : reinterpret_cast< ::autofill_assistant::SelectionInputProto&>(::autofill_assistant::_SelectionInputProto_default_instance_);
}
inline const ::autofill_assistant::SelectionInputProto& FormInputProto::selection() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FormInputProto.selection)
  return _internal_selection();
}
inline ::autofill_assistant::SelectionInputProto* FormInputProto::unsafe_arena_release_selection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.FormInputProto.selection)
  if (_internal_has_selection()) {
    clear_has_input_type();
    ::autofill_assistant::SelectionInputProto* temp = input_type_.selection_;
    input_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FormInputProto::unsafe_arena_set_allocated_selection(::autofill_assistant::SelectionInputProto* selection) {
  clear_input_type();
  if (selection) {
    set_has_selection();
    input_type_.selection_ = selection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FormInputProto.selection)
}
inline ::autofill_assistant::SelectionInputProto* FormInputProto::_internal_mutable_selection() {
  if (!_internal_has_selection()) {
    clear_input_type();
    set_has_selection();
    input_type_.selection_ = CreateMaybeMessage< ::autofill_assistant::SelectionInputProto >(GetArenaForAllocation());
  }
  return input_type_.selection_;
}
inline ::autofill_assistant::SelectionInputProto* FormInputProto::mutable_selection() {
  ::autofill_assistant::SelectionInputProto* _msg = _internal_mutable_selection();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FormInputProto.selection)
  return _msg;
}

inline bool FormInputProto::has_input_type() const {
  return input_type_case() != INPUT_TYPE_NOT_SET;
}
inline void FormInputProto::clear_has_input_type() {
  _oneof_case_[0] = INPUT_TYPE_NOT_SET;
}
inline FormInputProto::InputTypeCase FormInputProto::input_type_case() const {
  return FormInputProto::InputTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CounterInputProto_Counter

// optional string label = 1;
inline bool CounterInputProto_Counter::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_label() const {
  return _internal_has_label();
}
inline void CounterInputProto_Counter::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CounterInputProto_Counter::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CounterInputProto_Counter::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.label)
}
inline std::string* CounterInputProto_Counter::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.Counter.label)
  return _s;
}
inline const std::string& CounterInputProto_Counter::_internal_label() const {
  return label_.Get();
}
inline void CounterInputProto_Counter::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* CounterInputProto_Counter::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* CounterInputProto_Counter::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.Counter.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CounterInputProto_Counter::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.Counter.label)
}

// optional string description_line_1 = 5;
inline bool CounterInputProto_Counter::_internal_has_description_line_1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_description_line_1() const {
  return _internal_has_description_line_1();
}
inline void CounterInputProto_Counter::clear_description_line_1() {
  description_line_1_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CounterInputProto_Counter::description_line_1() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.description_line_1)
  return _internal_description_line_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CounterInputProto_Counter::set_description_line_1(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_line_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.description_line_1)
}
inline std::string* CounterInputProto_Counter::mutable_description_line_1() {
  std::string* _s = _internal_mutable_description_line_1();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.Counter.description_line_1)
  return _s;
}
inline const std::string& CounterInputProto_Counter::_internal_description_line_1() const {
  return description_line_1_.Get();
}
inline void CounterInputProto_Counter::_internal_set_description_line_1(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_line_1_.Set(value, GetArenaForAllocation());
}
inline std::string* CounterInputProto_Counter::_internal_mutable_description_line_1() {
  _has_bits_[0] |= 0x00000002u;
  return description_line_1_.Mutable(GetArenaForAllocation());
}
inline std::string* CounterInputProto_Counter::release_description_line_1() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.Counter.description_line_1)
  if (!_internal_has_description_line_1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_line_1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_1_.IsDefault()) {
    description_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CounterInputProto_Counter::set_allocated_description_line_1(std::string* description_line_1) {
  if (description_line_1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_line_1_.SetAllocated(description_line_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_1_.IsDefault()) {
    description_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.Counter.description_line_1)
}

// optional string description_line_2 = 8;
inline bool CounterInputProto_Counter::_internal_has_description_line_2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_description_line_2() const {
  return _internal_has_description_line_2();
}
inline void CounterInputProto_Counter::clear_description_line_2() {
  description_line_2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CounterInputProto_Counter::description_line_2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.description_line_2)
  return _internal_description_line_2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CounterInputProto_Counter::set_description_line_2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 description_line_2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.description_line_2)
}
inline std::string* CounterInputProto_Counter::mutable_description_line_2() {
  std::string* _s = _internal_mutable_description_line_2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.Counter.description_line_2)
  return _s;
}
inline const std::string& CounterInputProto_Counter::_internal_description_line_2() const {
  return description_line_2_.Get();
}
inline void CounterInputProto_Counter::_internal_set_description_line_2(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_line_2_.Set(value, GetArenaForAllocation());
}
inline std::string* CounterInputProto_Counter::_internal_mutable_description_line_2() {
  _has_bits_[0] |= 0x00000004u;
  return description_line_2_.Mutable(GetArenaForAllocation());
}
inline std::string* CounterInputProto_Counter::release_description_line_2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.Counter.description_line_2)
  if (!_internal_has_description_line_2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = description_line_2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_2_.IsDefault()) {
    description_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CounterInputProto_Counter::set_allocated_description_line_2(std::string* description_line_2) {
  if (description_line_2 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_line_2_.SetAllocated(description_line_2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_2_.IsDefault()) {
    description_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.Counter.description_line_2)
}

// repeated int32 allowed_values = 6;
inline int CounterInputProto_Counter::_internal_allowed_values_size() const {
  return allowed_values_.size();
}
inline int CounterInputProto_Counter::allowed_values_size() const {
  return _internal_allowed_values_size();
}
inline void CounterInputProto_Counter::clear_allowed_values() {
  allowed_values_.Clear();
}
inline int32_t CounterInputProto_Counter::_internal_allowed_values(int index) const {
  return allowed_values_.Get(index);
}
inline int32_t CounterInputProto_Counter::allowed_values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.allowed_values)
  return _internal_allowed_values(index);
}
inline void CounterInputProto_Counter::set_allowed_values(int index, int32_t value) {
  allowed_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.allowed_values)
}
inline void CounterInputProto_Counter::_internal_add_allowed_values(int32_t value) {
  allowed_values_.Add(value);
}
inline void CounterInputProto_Counter::add_allowed_values(int32_t value) {
  _internal_add_allowed_values(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.CounterInputProto.Counter.allowed_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CounterInputProto_Counter::_internal_allowed_values() const {
  return allowed_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CounterInputProto_Counter::allowed_values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CounterInputProto.Counter.allowed_values)
  return _internal_allowed_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CounterInputProto_Counter::_internal_mutable_allowed_values() {
  return &allowed_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CounterInputProto_Counter::mutable_allowed_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CounterInputProto.Counter.allowed_values)
  return _internal_mutable_allowed_values();
}

// optional int32 min_value = 2 [default = -2147483648];
inline bool CounterInputProto_Counter::_internal_has_min_value() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_min_value() const {
  return _internal_has_min_value();
}
inline void CounterInputProto_Counter::clear_min_value() {
  min_value_ = -2147483647 - 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t CounterInputProto_Counter::_internal_min_value() const {
  return min_value_;
}
inline int32_t CounterInputProto_Counter::min_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.min_value)
  return _internal_min_value();
}
inline void CounterInputProto_Counter::_internal_set_min_value(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  min_value_ = value;
}
inline void CounterInputProto_Counter::set_min_value(int32_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.min_value)
}

// optional int32 max_value = 3 [default = 2147483647];
inline bool CounterInputProto_Counter::_internal_has_max_value() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_max_value() const {
  return _internal_has_max_value();
}
inline void CounterInputProto_Counter::clear_max_value() {
  max_value_ = 2147483647;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t CounterInputProto_Counter::_internal_max_value() const {
  return max_value_;
}
inline int32_t CounterInputProto_Counter::max_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.max_value)
  return _internal_max_value();
}
inline void CounterInputProto_Counter::_internal_set_max_value(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  max_value_ = value;
}
inline void CounterInputProto_Counter::set_max_value(int32_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.max_value)
}

// optional int32 initial_value = 4 [default = 0];
inline bool CounterInputProto_Counter::_internal_has_initial_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_initial_value() const {
  return _internal_has_initial_value();
}
inline void CounterInputProto_Counter::clear_initial_value() {
  initial_value_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CounterInputProto_Counter::_internal_initial_value() const {
  return initial_value_;
}
inline int32_t CounterInputProto_Counter::initial_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.initial_value)
  return _internal_initial_value();
}
inline void CounterInputProto_Counter::_internal_set_initial_value(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  initial_value_ = value;
}
inline void CounterInputProto_Counter::set_initial_value(int32_t value) {
  _internal_set_initial_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.initial_value)
}

// optional int32 size = 9 [default = 1];
inline bool CounterInputProto_Counter::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CounterInputProto_Counter::has_size() const {
  return _internal_has_size();
}
inline void CounterInputProto_Counter::clear_size() {
  size_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CounterInputProto_Counter::_internal_size() const {
  return size_;
}
inline int32_t CounterInputProto_Counter::size() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Counter.size)
  return _internal_size();
}
inline void CounterInputProto_Counter::_internal_set_size(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  size_ = value;
}
inline void CounterInputProto_Counter::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Counter.size)
}

// -------------------------------------------------------------------

// CounterInputProto_Result

// repeated int32 values = 1;
inline int CounterInputProto_Result::_internal_values_size() const {
  return values_.size();
}
inline int CounterInputProto_Result::values_size() const {
  return _internal_values_size();
}
inline void CounterInputProto_Result::clear_values() {
  values_.Clear();
}
inline int32_t CounterInputProto_Result::_internal_values(int index) const {
  return values_.Get(index);
}
inline int32_t CounterInputProto_Result::values(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.Result.values)
  return _internal_values(index);
}
inline void CounterInputProto_Result::set_values(int index, int32_t value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.Result.values)
}
inline void CounterInputProto_Result::_internal_add_values(int32_t value) {
  values_.Add(value);
}
inline void CounterInputProto_Result::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.CounterInputProto.Result.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CounterInputProto_Result::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CounterInputProto_Result::values() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CounterInputProto.Result.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CounterInputProto_Result::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CounterInputProto_Result::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CounterInputProto.Result.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// CounterInputProto_ValidationRule_BooleanRule

// repeated .autofill_assistant.CounterInputProto.ValidationRule sub_rules = 1;
inline int CounterInputProto_ValidationRule_BooleanRule::_internal_sub_rules_size() const {
  return sub_rules_.size();
}
inline int CounterInputProto_ValidationRule_BooleanRule::sub_rules_size() const {
  return _internal_sub_rules_size();
}
inline void CounterInputProto_ValidationRule_BooleanRule::clear_sub_rules() {
  sub_rules_.Clear();
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto_ValidationRule_BooleanRule::mutable_sub_rules(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.sub_rules)
  return sub_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_ValidationRule >*
CounterInputProto_ValidationRule_BooleanRule::mutable_sub_rules() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.sub_rules)
  return &sub_rules_;
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule& CounterInputProto_ValidationRule_BooleanRule::_internal_sub_rules(int index) const {
  return sub_rules_.Get(index);
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule& CounterInputProto_ValidationRule_BooleanRule::sub_rules(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.sub_rules)
  return _internal_sub_rules(index);
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto_ValidationRule_BooleanRule::_internal_add_sub_rules() {
  return sub_rules_.Add();
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto_ValidationRule_BooleanRule::add_sub_rules() {
  ::autofill_assistant::CounterInputProto_ValidationRule* _add = _internal_add_sub_rules();
  // @@protoc_insertion_point(field_add:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.sub_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_ValidationRule >&
CounterInputProto_ValidationRule_BooleanRule::sub_rules() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.sub_rules)
  return sub_rules_;
}

// optional int32 min_satisfied_rules = 2 [default = 0];
inline bool CounterInputProto_ValidationRule_BooleanRule::_internal_has_min_satisfied_rules() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_BooleanRule::has_min_satisfied_rules() const {
  return _internal_has_min_satisfied_rules();
}
inline void CounterInputProto_ValidationRule_BooleanRule::clear_min_satisfied_rules() {
  min_satisfied_rules_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CounterInputProto_ValidationRule_BooleanRule::_internal_min_satisfied_rules() const {
  return min_satisfied_rules_;
}
inline int32_t CounterInputProto_ValidationRule_BooleanRule::min_satisfied_rules() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.min_satisfied_rules)
  return _internal_min_satisfied_rules();
}
inline void CounterInputProto_ValidationRule_BooleanRule::_internal_set_min_satisfied_rules(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  min_satisfied_rules_ = value;
}
inline void CounterInputProto_ValidationRule_BooleanRule::set_min_satisfied_rules(int32_t value) {
  _internal_set_min_satisfied_rules(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.min_satisfied_rules)
}

// optional int32 max_satisfied_rules = 3 [default = 2147483647];
inline bool CounterInputProto_ValidationRule_BooleanRule::_internal_has_max_satisfied_rules() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_BooleanRule::has_max_satisfied_rules() const {
  return _internal_has_max_satisfied_rules();
}
inline void CounterInputProto_ValidationRule_BooleanRule::clear_max_satisfied_rules() {
  max_satisfied_rules_ = 2147483647;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CounterInputProto_ValidationRule_BooleanRule::_internal_max_satisfied_rules() const {
  return max_satisfied_rules_;
}
inline int32_t CounterInputProto_ValidationRule_BooleanRule::max_satisfied_rules() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.max_satisfied_rules)
  return _internal_max_satisfied_rules();
}
inline void CounterInputProto_ValidationRule_BooleanRule::_internal_set_max_satisfied_rules(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  max_satisfied_rules_ = value;
}
inline void CounterInputProto_ValidationRule_BooleanRule::set_max_satisfied_rules(int32_t value) {
  _internal_set_max_satisfied_rules(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule.max_satisfied_rules)
}

// -------------------------------------------------------------------

// CounterInputProto_ValidationRule_CounterRule

// optional int32 counter_index = 1;
inline bool CounterInputProto_ValidationRule_CounterRule::_internal_has_counter_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_CounterRule::has_counter_index() const {
  return _internal_has_counter_index();
}
inline void CounterInputProto_ValidationRule_CounterRule::clear_counter_index() {
  counter_index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CounterInputProto_ValidationRule_CounterRule::_internal_counter_index() const {
  return counter_index_;
}
inline int32_t CounterInputProto_ValidationRule_CounterRule::counter_index() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.CounterRule.counter_index)
  return _internal_counter_index();
}
inline void CounterInputProto_ValidationRule_CounterRule::_internal_set_counter_index(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  counter_index_ = value;
}
inline void CounterInputProto_ValidationRule_CounterRule::set_counter_index(int32_t value) {
  _internal_set_counter_index(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.CounterRule.counter_index)
}

// optional int32 min_value = 2 [default = -2147483648];
inline bool CounterInputProto_ValidationRule_CounterRule::_internal_has_min_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_CounterRule::has_min_value() const {
  return _internal_has_min_value();
}
inline void CounterInputProto_ValidationRule_CounterRule::clear_min_value() {
  min_value_ = -2147483647 - 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CounterInputProto_ValidationRule_CounterRule::_internal_min_value() const {
  return min_value_;
}
inline int32_t CounterInputProto_ValidationRule_CounterRule::min_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.CounterRule.min_value)
  return _internal_min_value();
}
inline void CounterInputProto_ValidationRule_CounterRule::_internal_set_min_value(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  min_value_ = value;
}
inline void CounterInputProto_ValidationRule_CounterRule::set_min_value(int32_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.CounterRule.min_value)
}

// optional int32 max_value = 3 [default = 2147483647];
inline bool CounterInputProto_ValidationRule_CounterRule::_internal_has_max_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_CounterRule::has_max_value() const {
  return _internal_has_max_value();
}
inline void CounterInputProto_ValidationRule_CounterRule::clear_max_value() {
  max_value_ = 2147483647;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CounterInputProto_ValidationRule_CounterRule::_internal_max_value() const {
  return max_value_;
}
inline int32_t CounterInputProto_ValidationRule_CounterRule::max_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.CounterRule.max_value)
  return _internal_max_value();
}
inline void CounterInputProto_ValidationRule_CounterRule::_internal_set_max_value(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  max_value_ = value;
}
inline void CounterInputProto_ValidationRule_CounterRule::set_max_value(int32_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.CounterRule.max_value)
}

// -------------------------------------------------------------------

// CounterInputProto_ValidationRule_CountersSumRule

// optional int64 min_value = 1 [default = -9223372036854775808];
inline bool CounterInputProto_ValidationRule_CountersSumRule::_internal_has_min_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_CountersSumRule::has_min_value() const {
  return _internal_has_min_value();
}
inline void CounterInputProto_ValidationRule_CountersSumRule::clear_min_value() {
  min_value_ = int64_t{-9223372036854775807} - 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t CounterInputProto_ValidationRule_CountersSumRule::_internal_min_value() const {
  return min_value_;
}
inline int64_t CounterInputProto_ValidationRule_CountersSumRule::min_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule.min_value)
  return _internal_min_value();
}
inline void CounterInputProto_ValidationRule_CountersSumRule::_internal_set_min_value(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  min_value_ = value;
}
inline void CounterInputProto_ValidationRule_CountersSumRule::set_min_value(int64_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule.min_value)
}

// optional int64 max_value = 2 [default = 9223372036854775807];
inline bool CounterInputProto_ValidationRule_CountersSumRule::_internal_has_max_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CounterInputProto_ValidationRule_CountersSumRule::has_max_value() const {
  return _internal_has_max_value();
}
inline void CounterInputProto_ValidationRule_CountersSumRule::clear_max_value() {
  max_value_ = int64_t{9223372036854775807};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t CounterInputProto_ValidationRule_CountersSumRule::_internal_max_value() const {
  return max_value_;
}
inline int64_t CounterInputProto_ValidationRule_CountersSumRule::max_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule.max_value)
  return _internal_max_value();
}
inline void CounterInputProto_ValidationRule_CountersSumRule::_internal_set_max_value(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  max_value_ = value;
}
inline void CounterInputProto_ValidationRule_CountersSumRule::set_max_value(int64_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule.max_value)
}

// -------------------------------------------------------------------

// CounterInputProto_ValidationRule

// .autofill_assistant.CounterInputProto.ValidationRule.BooleanRule boolean = 1;
inline bool CounterInputProto_ValidationRule::_internal_has_boolean() const {
  return rule_type_case() == kBoolean;
}
inline bool CounterInputProto_ValidationRule::has_boolean() const {
  return _internal_has_boolean();
}
inline void CounterInputProto_ValidationRule::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void CounterInputProto_ValidationRule::clear_boolean() {
  if (_internal_has_boolean()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rule_type_.boolean_;
    }
    clear_has_rule_type();
  }
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* CounterInputProto_ValidationRule::release_boolean() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.ValidationRule.boolean)
  if (_internal_has_boolean()) {
    clear_has_rule_type();
    ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* temp = rule_type_.boolean_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_type_.boolean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule& CounterInputProto_ValidationRule::_internal_boolean() const {
  return _internal_has_boolean()
      ? *rule_type_.boolean_
      : reinterpret_cast< ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule&>(::autofill_assistant::_CounterInputProto_ValidationRule_BooleanRule_default_instance_);
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule& CounterInputProto_ValidationRule::boolean() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.boolean)
  return _internal_boolean();
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* CounterInputProto_ValidationRule::unsafe_arena_release_boolean() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CounterInputProto.ValidationRule.boolean)
  if (_internal_has_boolean()) {
    clear_has_rule_type();
    ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* temp = rule_type_.boolean_;
    rule_type_.boolean_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CounterInputProto_ValidationRule::unsafe_arena_set_allocated_boolean(::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* boolean) {
  clear_rule_type();
  if (boolean) {
    set_has_boolean();
    rule_type_.boolean_ = boolean;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CounterInputProto.ValidationRule.boolean)
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* CounterInputProto_ValidationRule::_internal_mutable_boolean() {
  if (!_internal_has_boolean()) {
    clear_rule_type();
    set_has_boolean();
    rule_type_.boolean_ = CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule >(GetArenaForAllocation());
  }
  return rule_type_.boolean_;
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* CounterInputProto_ValidationRule::mutable_boolean() {
  ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* _msg = _internal_mutable_boolean();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.ValidationRule.boolean)
  return _msg;
}

// .autofill_assistant.CounterInputProto.ValidationRule.CounterRule counter = 2;
inline bool CounterInputProto_ValidationRule::_internal_has_counter() const {
  return rule_type_case() == kCounter;
}
inline bool CounterInputProto_ValidationRule::has_counter() const {
  return _internal_has_counter();
}
inline void CounterInputProto_ValidationRule::set_has_counter() {
  _oneof_case_[0] = kCounter;
}
inline void CounterInputProto_ValidationRule::clear_counter() {
  if (_internal_has_counter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rule_type_.counter_;
    }
    clear_has_rule_type();
  }
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* CounterInputProto_ValidationRule::release_counter() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.ValidationRule.counter)
  if (_internal_has_counter()) {
    clear_has_rule_type();
    ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* temp = rule_type_.counter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_type_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule& CounterInputProto_ValidationRule::_internal_counter() const {
  return _internal_has_counter()
      ? *rule_type_.counter_
      : reinterpret_cast< ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule&>(::autofill_assistant::_CounterInputProto_ValidationRule_CounterRule_default_instance_);
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule& CounterInputProto_ValidationRule::counter() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.counter)
  return _internal_counter();
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* CounterInputProto_ValidationRule::unsafe_arena_release_counter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CounterInputProto.ValidationRule.counter)
  if (_internal_has_counter()) {
    clear_has_rule_type();
    ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* temp = rule_type_.counter_;
    rule_type_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CounterInputProto_ValidationRule::unsafe_arena_set_allocated_counter(::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* counter) {
  clear_rule_type();
  if (counter) {
    set_has_counter();
    rule_type_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CounterInputProto.ValidationRule.counter)
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* CounterInputProto_ValidationRule::_internal_mutable_counter() {
  if (!_internal_has_counter()) {
    clear_rule_type();
    set_has_counter();
    rule_type_.counter_ = CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule >(GetArenaForAllocation());
  }
  return rule_type_.counter_;
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* CounterInputProto_ValidationRule::mutable_counter() {
  ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* _msg = _internal_mutable_counter();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.ValidationRule.counter)
  return _msg;
}

// .autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule counters_sum = 3;
inline bool CounterInputProto_ValidationRule::_internal_has_counters_sum() const {
  return rule_type_case() == kCountersSum;
}
inline bool CounterInputProto_ValidationRule::has_counters_sum() const {
  return _internal_has_counters_sum();
}
inline void CounterInputProto_ValidationRule::set_has_counters_sum() {
  _oneof_case_[0] = kCountersSum;
}
inline void CounterInputProto_ValidationRule::clear_counters_sum() {
  if (_internal_has_counters_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rule_type_.counters_sum_;
    }
    clear_has_rule_type();
  }
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* CounterInputProto_ValidationRule::release_counters_sum() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.ValidationRule.counters_sum)
  if (_internal_has_counters_sum()) {
    clear_has_rule_type();
    ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* temp = rule_type_.counters_sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_type_.counters_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule& CounterInputProto_ValidationRule::_internal_counters_sum() const {
  return _internal_has_counters_sum()
      ? *rule_type_.counters_sum_
      : reinterpret_cast< ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule&>(::autofill_assistant::_CounterInputProto_ValidationRule_CountersSumRule_default_instance_);
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule& CounterInputProto_ValidationRule::counters_sum() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.ValidationRule.counters_sum)
  return _internal_counters_sum();
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* CounterInputProto_ValidationRule::unsafe_arena_release_counters_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.CounterInputProto.ValidationRule.counters_sum)
  if (_internal_has_counters_sum()) {
    clear_has_rule_type();
    ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* temp = rule_type_.counters_sum_;
    rule_type_.counters_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CounterInputProto_ValidationRule::unsafe_arena_set_allocated_counters_sum(::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* counters_sum) {
  clear_rule_type();
  if (counters_sum) {
    set_has_counters_sum();
    rule_type_.counters_sum_ = counters_sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CounterInputProto.ValidationRule.counters_sum)
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* CounterInputProto_ValidationRule::_internal_mutable_counters_sum() {
  if (!_internal_has_counters_sum()) {
    clear_rule_type();
    set_has_counters_sum();
    rule_type_.counters_sum_ = CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule >(GetArenaForAllocation());
  }
  return rule_type_.counters_sum_;
}
inline ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* CounterInputProto_ValidationRule::mutable_counters_sum() {
  ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* _msg = _internal_mutable_counters_sum();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.ValidationRule.counters_sum)
  return _msg;
}

inline bool CounterInputProto_ValidationRule::has_rule_type() const {
  return rule_type_case() != RULE_TYPE_NOT_SET;
}
inline void CounterInputProto_ValidationRule::clear_has_rule_type() {
  _oneof_case_[0] = RULE_TYPE_NOT_SET;
}
inline CounterInputProto_ValidationRule::RuleTypeCase CounterInputProto_ValidationRule::rule_type_case() const {
  return CounterInputProto_ValidationRule::RuleTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CounterInputProto

// optional string label = 1;
inline bool CounterInputProto::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CounterInputProto::has_label() const {
  return _internal_has_label();
}
inline void CounterInputProto::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CounterInputProto::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CounterInputProto::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.label)
}
inline std::string* CounterInputProto::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.label)
  return _s;
}
inline const std::string& CounterInputProto::_internal_label() const {
  return label_.Get();
}
inline void CounterInputProto::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* CounterInputProto::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* CounterInputProto::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CounterInputProto::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.label)
}

// repeated .autofill_assistant.CounterInputProto.Counter counters = 2;
inline int CounterInputProto::_internal_counters_size() const {
  return counters_.size();
}
inline int CounterInputProto::counters_size() const {
  return _internal_counters_size();
}
inline void CounterInputProto::clear_counters() {
  counters_.Clear();
}
inline ::autofill_assistant::CounterInputProto_Counter* CounterInputProto::mutable_counters(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.counters)
  return counters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_Counter >*
CounterInputProto::mutable_counters() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CounterInputProto.counters)
  return &counters_;
}
inline const ::autofill_assistant::CounterInputProto_Counter& CounterInputProto::_internal_counters(int index) const {
  return counters_.Get(index);
}
inline const ::autofill_assistant::CounterInputProto_Counter& CounterInputProto::counters(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.counters)
  return _internal_counters(index);
}
inline ::autofill_assistant::CounterInputProto_Counter* CounterInputProto::_internal_add_counters() {
  return counters_.Add();
}
inline ::autofill_assistant::CounterInputProto_Counter* CounterInputProto::add_counters() {
  ::autofill_assistant::CounterInputProto_Counter* _add = _internal_add_counters();
  // @@protoc_insertion_point(field_add:autofill_assistant.CounterInputProto.counters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::CounterInputProto_Counter >&
CounterInputProto::counters() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CounterInputProto.counters)
  return counters_;
}

// optional int32 minimized_count = 3 [default = 2147483647];
inline bool CounterInputProto::_internal_has_minimized_count() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CounterInputProto::has_minimized_count() const {
  return _internal_has_minimized_count();
}
inline void CounterInputProto::clear_minimized_count() {
  minimized_count_ = 2147483647;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CounterInputProto::_internal_minimized_count() const {
  return minimized_count_;
}
inline int32_t CounterInputProto::minimized_count() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.minimized_count)
  return _internal_minimized_count();
}
inline void CounterInputProto::_internal_set_minimized_count(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  minimized_count_ = value;
}
inline void CounterInputProto::set_minimized_count(int32_t value) {
  _internal_set_minimized_count(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.minimized_count)
}

// optional string expand_text = 4;
inline bool CounterInputProto::_internal_has_expand_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CounterInputProto::has_expand_text() const {
  return _internal_has_expand_text();
}
inline void CounterInputProto::clear_expand_text() {
  expand_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CounterInputProto::expand_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.expand_text)
  return _internal_expand_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CounterInputProto::set_expand_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 expand_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.expand_text)
}
inline std::string* CounterInputProto::mutable_expand_text() {
  std::string* _s = _internal_mutable_expand_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.expand_text)
  return _s;
}
inline const std::string& CounterInputProto::_internal_expand_text() const {
  return expand_text_.Get();
}
inline void CounterInputProto::_internal_set_expand_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  expand_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CounterInputProto::_internal_mutable_expand_text() {
  _has_bits_[0] |= 0x00000002u;
  return expand_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CounterInputProto::release_expand_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.expand_text)
  if (!_internal_has_expand_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = expand_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (expand_text_.IsDefault()) {
    expand_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CounterInputProto::set_allocated_expand_text(std::string* expand_text) {
  if (expand_text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  expand_text_.SetAllocated(expand_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (expand_text_.IsDefault()) {
    expand_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.expand_text)
}

// optional string minimize_text = 5;
inline bool CounterInputProto::_internal_has_minimize_text() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CounterInputProto::has_minimize_text() const {
  return _internal_has_minimize_text();
}
inline void CounterInputProto::clear_minimize_text() {
  minimize_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CounterInputProto::minimize_text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.minimize_text)
  return _internal_minimize_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CounterInputProto::set_minimize_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 minimize_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.minimize_text)
}
inline std::string* CounterInputProto::mutable_minimize_text() {
  std::string* _s = _internal_mutable_minimize_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.minimize_text)
  return _s;
}
inline const std::string& CounterInputProto::_internal_minimize_text() const {
  return minimize_text_.Get();
}
inline void CounterInputProto::_internal_set_minimize_text(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  minimize_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CounterInputProto::_internal_mutable_minimize_text() {
  _has_bits_[0] |= 0x00000004u;
  return minimize_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CounterInputProto::release_minimize_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.minimize_text)
  if (!_internal_has_minimize_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = minimize_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (minimize_text_.IsDefault()) {
    minimize_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CounterInputProto::set_allocated_minimize_text(std::string* minimize_text) {
  if (minimize_text != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  minimize_text_.SetAllocated(minimize_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (minimize_text_.IsDefault()) {
    minimize_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.minimize_text)
}

// optional .autofill_assistant.CounterInputProto.ValidationRule validation_rule = 6;
inline bool CounterInputProto::_internal_has_validation_rule() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || validation_rule_ != nullptr);
  return value;
}
inline bool CounterInputProto::has_validation_rule() const {
  return _internal_has_validation_rule();
}
inline void CounterInputProto::clear_validation_rule() {
  if (validation_rule_ != nullptr) validation_rule_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule& CounterInputProto::_internal_validation_rule() const {
  const ::autofill_assistant::CounterInputProto_ValidationRule* p = validation_rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::CounterInputProto_ValidationRule&>(
      ::autofill_assistant::_CounterInputProto_ValidationRule_default_instance_);
}
inline const ::autofill_assistant::CounterInputProto_ValidationRule& CounterInputProto::validation_rule() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.validation_rule)
  return _internal_validation_rule();
}
inline void CounterInputProto::unsafe_arena_set_allocated_validation_rule(
    ::autofill_assistant::CounterInputProto_ValidationRule* validation_rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(validation_rule_);
  }
  validation_rule_ = validation_rule;
  if (validation_rule) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CounterInputProto.validation_rule)
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto::release_validation_rule() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::CounterInputProto_ValidationRule* temp = validation_rule_;
  validation_rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto::unsafe_arena_release_validation_rule() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CounterInputProto.validation_rule)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::CounterInputProto_ValidationRule* temp = validation_rule_;
  validation_rule_ = nullptr;
  return temp;
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto::_internal_mutable_validation_rule() {
  _has_bits_[0] |= 0x00000008u;
  if (validation_rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::CounterInputProto_ValidationRule>(GetArenaForAllocation());
    validation_rule_ = p;
  }
  return validation_rule_;
}
inline ::autofill_assistant::CounterInputProto_ValidationRule* CounterInputProto::mutable_validation_rule() {
  ::autofill_assistant::CounterInputProto_ValidationRule* _msg = _internal_mutable_validation_rule();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CounterInputProto.validation_rule)
  return _msg;
}
inline void CounterInputProto::set_allocated_validation_rule(::autofill_assistant::CounterInputProto_ValidationRule* validation_rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete validation_rule_;
  }
  if (validation_rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(validation_rule);
    if (message_arena != submessage_arena) {
      validation_rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validation_rule, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  validation_rule_ = validation_rule;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.validation_rule)
}

// optional int64 min_counters_sum = 7 [default = -9223372036854775808];
inline bool CounterInputProto::_internal_has_min_counters_sum() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CounterInputProto::has_min_counters_sum() const {
  return _internal_has_min_counters_sum();
}
inline void CounterInputProto::clear_min_counters_sum() {
  min_counters_sum_ = int64_t{-9223372036854775807} - 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t CounterInputProto::_internal_min_counters_sum() const {
  return min_counters_sum_;
}
inline int64_t CounterInputProto::min_counters_sum() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.min_counters_sum)
  return _internal_min_counters_sum();
}
inline void CounterInputProto::_internal_set_min_counters_sum(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  min_counters_sum_ = value;
}
inline void CounterInputProto::set_min_counters_sum(int64_t value) {
  _internal_set_min_counters_sum(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.min_counters_sum)
}

// optional int64 max_counters_sum = 8 [default = 9223372036854775807];
inline bool CounterInputProto::_internal_has_max_counters_sum() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CounterInputProto::has_max_counters_sum() const {
  return _internal_has_max_counters_sum();
}
inline void CounterInputProto::clear_max_counters_sum() {
  max_counters_sum_ = int64_t{9223372036854775807};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t CounterInputProto::_internal_max_counters_sum() const {
  return max_counters_sum_;
}
inline int64_t CounterInputProto::max_counters_sum() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CounterInputProto.max_counters_sum)
  return _internal_max_counters_sum();
}
inline void CounterInputProto::_internal_set_max_counters_sum(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  max_counters_sum_ = value;
}
inline void CounterInputProto::set_max_counters_sum(int64_t value) {
  _internal_set_max_counters_sum(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CounterInputProto.max_counters_sum)
}

// -------------------------------------------------------------------

// SelectionInputProto_Choice

// optional string label = 1;
inline bool SelectionInputProto_Choice::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectionInputProto_Choice::has_label() const {
  return _internal_has_label();
}
inline void SelectionInputProto_Choice::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SelectionInputProto_Choice::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.Choice.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectionInputProto_Choice::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.Choice.label)
}
inline std::string* SelectionInputProto_Choice::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectionInputProto.Choice.label)
  return _s;
}
inline const std::string& SelectionInputProto_Choice::_internal_label() const {
  return label_.Get();
}
inline void SelectionInputProto_Choice::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectionInputProto_Choice::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectionInputProto_Choice::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectionInputProto.Choice.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectionInputProto_Choice::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectionInputProto.Choice.label)
}

// optional string description_line_1 = 3;
inline bool SelectionInputProto_Choice::_internal_has_description_line_1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectionInputProto_Choice::has_description_line_1() const {
  return _internal_has_description_line_1();
}
inline void SelectionInputProto_Choice::clear_description_line_1() {
  description_line_1_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SelectionInputProto_Choice::description_line_1() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.Choice.description_line_1)
  return _internal_description_line_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectionInputProto_Choice::set_description_line_1(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_line_1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.Choice.description_line_1)
}
inline std::string* SelectionInputProto_Choice::mutable_description_line_1() {
  std::string* _s = _internal_mutable_description_line_1();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectionInputProto.Choice.description_line_1)
  return _s;
}
inline const std::string& SelectionInputProto_Choice::_internal_description_line_1() const {
  return description_line_1_.Get();
}
inline void SelectionInputProto_Choice::_internal_set_description_line_1(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_line_1_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectionInputProto_Choice::_internal_mutable_description_line_1() {
  _has_bits_[0] |= 0x00000002u;
  return description_line_1_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectionInputProto_Choice::release_description_line_1() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectionInputProto.Choice.description_line_1)
  if (!_internal_has_description_line_1()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_line_1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_1_.IsDefault()) {
    description_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectionInputProto_Choice::set_allocated_description_line_1(std::string* description_line_1) {
  if (description_line_1 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_line_1_.SetAllocated(description_line_1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_1_.IsDefault()) {
    description_line_1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectionInputProto.Choice.description_line_1)
}

// optional string description_line_2 = 4;
inline bool SelectionInputProto_Choice::_internal_has_description_line_2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SelectionInputProto_Choice::has_description_line_2() const {
  return _internal_has_description_line_2();
}
inline void SelectionInputProto_Choice::clear_description_line_2() {
  description_line_2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SelectionInputProto_Choice::description_line_2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.Choice.description_line_2)
  return _internal_description_line_2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectionInputProto_Choice::set_description_line_2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 description_line_2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.Choice.description_line_2)
}
inline std::string* SelectionInputProto_Choice::mutable_description_line_2() {
  std::string* _s = _internal_mutable_description_line_2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectionInputProto.Choice.description_line_2)
  return _s;
}
inline const std::string& SelectionInputProto_Choice::_internal_description_line_2() const {
  return description_line_2_.Get();
}
inline void SelectionInputProto_Choice::_internal_set_description_line_2(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_line_2_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectionInputProto_Choice::_internal_mutable_description_line_2() {
  _has_bits_[0] |= 0x00000004u;
  return description_line_2_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectionInputProto_Choice::release_description_line_2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectionInputProto.Choice.description_line_2)
  if (!_internal_has_description_line_2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = description_line_2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_2_.IsDefault()) {
    description_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectionInputProto_Choice::set_allocated_description_line_2(std::string* description_line_2) {
  if (description_line_2 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_line_2_.SetAllocated(description_line_2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_line_2_.IsDefault()) {
    description_line_2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectionInputProto.Choice.description_line_2)
}

// optional bool selected = 2 [default = false];
inline bool SelectionInputProto_Choice::_internal_has_selected() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SelectionInputProto_Choice::has_selected() const {
  return _internal_has_selected();
}
inline void SelectionInputProto_Choice::clear_selected() {
  selected_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool SelectionInputProto_Choice::_internal_selected() const {
  return selected_;
}
inline bool SelectionInputProto_Choice::selected() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.Choice.selected)
  return _internal_selected();
}
inline void SelectionInputProto_Choice::_internal_set_selected(bool value) {
  _has_bits_[0] |= 0x00000008u;
  selected_ = value;
}
inline void SelectionInputProto_Choice::set_selected(bool value) {
  _internal_set_selected(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.Choice.selected)
}

// -------------------------------------------------------------------

// SelectionInputProto_Result

// repeated bool selected = 1;
inline int SelectionInputProto_Result::_internal_selected_size() const {
  return selected_.size();
}
inline int SelectionInputProto_Result::selected_size() const {
  return _internal_selected_size();
}
inline void SelectionInputProto_Result::clear_selected() {
  selected_.Clear();
}
inline bool SelectionInputProto_Result::_internal_selected(int index) const {
  return selected_.Get(index);
}
inline bool SelectionInputProto_Result::selected(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.Result.selected)
  return _internal_selected(index);
}
inline void SelectionInputProto_Result::set_selected(int index, bool value) {
  selected_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.Result.selected)
}
inline void SelectionInputProto_Result::_internal_add_selected(bool value) {
  selected_.Add(value);
}
inline void SelectionInputProto_Result::add_selected(bool value) {
  _internal_add_selected(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.SelectionInputProto.Result.selected)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SelectionInputProto_Result::_internal_selected() const {
  return selected_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SelectionInputProto_Result::selected() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SelectionInputProto.Result.selected)
  return _internal_selected();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SelectionInputProto_Result::_internal_mutable_selected() {
  return &selected_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SelectionInputProto_Result::mutable_selected() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SelectionInputProto.Result.selected)
  return _internal_mutable_selected();
}

// -------------------------------------------------------------------

// SelectionInputProto

// optional string label = 1;
inline bool SelectionInputProto::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectionInputProto::has_label() const {
  return _internal_has_label();
}
inline void SelectionInputProto::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SelectionInputProto::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectionInputProto::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.label)
}
inline std::string* SelectionInputProto::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectionInputProto.label)
  return _s;
}
inline const std::string& SelectionInputProto::_internal_label() const {
  return label_.Get();
}
inline void SelectionInputProto::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectionInputProto::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectionInputProto::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectionInputProto.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectionInputProto::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectionInputProto.label)
}

// repeated .autofill_assistant.SelectionInputProto.Choice choices = 2;
inline int SelectionInputProto::_internal_choices_size() const {
  return choices_.size();
}
inline int SelectionInputProto::choices_size() const {
  return _internal_choices_size();
}
inline void SelectionInputProto::clear_choices() {
  choices_.Clear();
}
inline ::autofill_assistant::SelectionInputProto_Choice* SelectionInputProto::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectionInputProto.choices)
  return choices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectionInputProto_Choice >*
SelectionInputProto::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SelectionInputProto.choices)
  return &choices_;
}
inline const ::autofill_assistant::SelectionInputProto_Choice& SelectionInputProto::_internal_choices(int index) const {
  return choices_.Get(index);
}
inline const ::autofill_assistant::SelectionInputProto_Choice& SelectionInputProto::choices(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.choices)
  return _internal_choices(index);
}
inline ::autofill_assistant::SelectionInputProto_Choice* SelectionInputProto::_internal_add_choices() {
  return choices_.Add();
}
inline ::autofill_assistant::SelectionInputProto_Choice* SelectionInputProto::add_choices() {
  ::autofill_assistant::SelectionInputProto_Choice* _add = _internal_add_choices();
  // @@protoc_insertion_point(field_add:autofill_assistant.SelectionInputProto.choices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::SelectionInputProto_Choice >&
SelectionInputProto::choices() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SelectionInputProto.choices)
  return choices_;
}

// optional bool allow_multiple = 3 [default = false];
inline bool SelectionInputProto::_internal_has_allow_multiple() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectionInputProto::has_allow_multiple() const {
  return _internal_has_allow_multiple();
}
inline void SelectionInputProto::clear_allow_multiple() {
  allow_multiple_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SelectionInputProto::_internal_allow_multiple() const {
  return allow_multiple_;
}
inline bool SelectionInputProto::allow_multiple() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.allow_multiple)
  return _internal_allow_multiple();
}
inline void SelectionInputProto::_internal_set_allow_multiple(bool value) {
  _has_bits_[0] |= 0x00000002u;
  allow_multiple_ = value;
}
inline void SelectionInputProto::set_allow_multiple(bool value) {
  _internal_set_allow_multiple(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.allow_multiple)
}

// optional int32 min_selected_choices = 4 [default = 1];
inline bool SelectionInputProto::_internal_has_min_selected_choices() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SelectionInputProto::has_min_selected_choices() const {
  return _internal_has_min_selected_choices();
}
inline void SelectionInputProto::clear_min_selected_choices() {
  min_selected_choices_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t SelectionInputProto::_internal_min_selected_choices() const {
  return min_selected_choices_;
}
inline int32_t SelectionInputProto::min_selected_choices() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectionInputProto.min_selected_choices)
  return _internal_min_selected_choices();
}
inline void SelectionInputProto::_internal_set_min_selected_choices(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  min_selected_choices_ = value;
}
inline void SelectionInputProto::set_min_selected_choices(int32_t value) {
  _internal_set_min_selected_choices(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SelectionInputProto.min_selected_choices)
}

// -------------------------------------------------------------------

// PopupMessageProto

// optional string message = 1;
inline bool PopupMessageProto::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PopupMessageProto::has_message() const {
  return _internal_has_message();
}
inline void PopupMessageProto::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PopupMessageProto::message() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.PopupMessageProto.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PopupMessageProto::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.PopupMessageProto.message)
}
inline std::string* PopupMessageProto::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.PopupMessageProto.message)
  return _s;
}
inline const std::string& PopupMessageProto::_internal_message() const {
  return message_.Get();
}
inline void PopupMessageProto::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(value, GetArenaForAllocation());
}
inline std::string* PopupMessageProto::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(GetArenaForAllocation());
}
inline std::string* PopupMessageProto::release_message() {
  // @@protoc_insertion_point(field_release:autofill_assistant.PopupMessageProto.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PopupMessageProto::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.PopupMessageProto.message)
}

// -------------------------------------------------------------------

// GetElementStatusProto_Result

// optional bool not_empty = 1;
inline bool GetElementStatusProto_Result::_internal_has_not_empty() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetElementStatusProto_Result::has_not_empty() const {
  return _internal_has_not_empty();
}
inline void GetElementStatusProto_Result::clear_not_empty() {
  not_empty_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool GetElementStatusProto_Result::_internal_not_empty() const {
  return not_empty_;
}
inline bool GetElementStatusProto_Result::not_empty() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.Result.not_empty)
  return _internal_not_empty();
}
inline void GetElementStatusProto_Result::_internal_set_not_empty(bool value) {
  _has_bits_[0] |= 0x00000001u;
  not_empty_ = value;
}
inline void GetElementStatusProto_Result::set_not_empty(bool value) {
  _internal_set_not_empty(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.Result.not_empty)
}

// optional bool match_success = 2;
inline bool GetElementStatusProto_Result::_internal_has_match_success() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetElementStatusProto_Result::has_match_success() const {
  return _internal_has_match_success();
}
inline void GetElementStatusProto_Result::clear_match_success() {
  match_success_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GetElementStatusProto_Result::_internal_match_success() const {
  return match_success_;
}
inline bool GetElementStatusProto_Result::match_success() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.Result.match_success)
  return _internal_match_success();
}
inline void GetElementStatusProto_Result::_internal_set_match_success(bool value) {
  _has_bits_[0] |= 0x00000002u;
  match_success_ = value;
}
inline void GetElementStatusProto_Result::set_match_success(bool value) {
  _internal_set_match_success(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.Result.match_success)
}

// optional bool expected_empty_match = 4;
inline bool GetElementStatusProto_Result::_internal_has_expected_empty_match() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetElementStatusProto_Result::has_expected_empty_match() const {
  return _internal_has_expected_empty_match();
}
inline void GetElementStatusProto_Result::clear_expected_empty_match() {
  expected_empty_match_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetElementStatusProto_Result::_internal_expected_empty_match() const {
  return expected_empty_match_;
}
inline bool GetElementStatusProto_Result::expected_empty_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.Result.expected_empty_match)
  return _internal_expected_empty_match();
}
inline void GetElementStatusProto_Result::_internal_set_expected_empty_match(bool value) {
  _has_bits_[0] |= 0x00000004u;
  expected_empty_match_ = value;
}
inline void GetElementStatusProto_Result::set_expected_empty_match(bool value) {
  _internal_set_expected_empty_match(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.Result.expected_empty_match)
}

// repeated .autofill_assistant.GetElementStatusProto.ComparisonReport reports = 3;
inline int GetElementStatusProto_Result::_internal_reports_size() const {
  return reports_.size();
}
inline int GetElementStatusProto_Result::reports_size() const {
  return _internal_reports_size();
}
inline void GetElementStatusProto_Result::clear_reports() {
  reports_.Clear();
}
inline ::autofill_assistant::GetElementStatusProto_ComparisonReport* GetElementStatusProto_Result::mutable_reports(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.Result.reports)
  return reports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetElementStatusProto_ComparisonReport >*
GetElementStatusProto_Result::mutable_reports() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.GetElementStatusProto.Result.reports)
  return &reports_;
}
inline const ::autofill_assistant::GetElementStatusProto_ComparisonReport& GetElementStatusProto_Result::_internal_reports(int index) const {
  return reports_.Get(index);
}
inline const ::autofill_assistant::GetElementStatusProto_ComparisonReport& GetElementStatusProto_Result::reports(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.Result.reports)
  return _internal_reports(index);
}
inline ::autofill_assistant::GetElementStatusProto_ComparisonReport* GetElementStatusProto_Result::_internal_add_reports() {
  return reports_.Add();
}
inline ::autofill_assistant::GetElementStatusProto_ComparisonReport* GetElementStatusProto_Result::add_reports() {
  ::autofill_assistant::GetElementStatusProto_ComparisonReport* _add = _internal_add_reports();
  // @@protoc_insertion_point(field_add:autofill_assistant.GetElementStatusProto.Result.reports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::GetElementStatusProto_ComparisonReport >&
GetElementStatusProto_Result::reports() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.GetElementStatusProto.Result.reports)
  return reports_;
}

// -------------------------------------------------------------------

// GetElementStatusProto_MatchOptions

// optional bool case_sensitive = 1;
inline bool GetElementStatusProto_MatchOptions::_internal_has_case_sensitive() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetElementStatusProto_MatchOptions::has_case_sensitive() const {
  return _internal_has_case_sensitive();
}
inline void GetElementStatusProto_MatchOptions::clear_case_sensitive() {
  case_sensitive_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GetElementStatusProto_MatchOptions::_internal_case_sensitive() const {
  return case_sensitive_;
}
inline bool GetElementStatusProto_MatchOptions::case_sensitive() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchOptions.case_sensitive)
  return _internal_case_sensitive();
}
inline void GetElementStatusProto_MatchOptions::_internal_set_case_sensitive(bool value) {
  _has_bits_[0] |= 0x00000002u;
  case_sensitive_ = value;
}
inline void GetElementStatusProto_MatchOptions::set_case_sensitive(bool value) {
  _internal_set_case_sensitive(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchOptions.case_sensitive)
}

// optional bool remove_space = 2;
inline bool GetElementStatusProto_MatchOptions::_internal_has_remove_space() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetElementStatusProto_MatchOptions::has_remove_space() const {
  return _internal_has_remove_space();
}
inline void GetElementStatusProto_MatchOptions::clear_remove_space() {
  remove_space_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetElementStatusProto_MatchOptions::_internal_remove_space() const {
  return remove_space_;
}
inline bool GetElementStatusProto_MatchOptions::remove_space() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchOptions.remove_space)
  return _internal_remove_space();
}
inline void GetElementStatusProto_MatchOptions::_internal_set_remove_space(bool value) {
  _has_bits_[0] |= 0x00000004u;
  remove_space_ = value;
}
inline void GetElementStatusProto_MatchOptions::set_remove_space(bool value) {
  _internal_set_remove_space(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchOptions.remove_space)
}

// optional string find_and_remove_re2 = 3;
inline bool GetElementStatusProto_MatchOptions::_internal_has_find_and_remove_re2() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetElementStatusProto_MatchOptions::has_find_and_remove_re2() const {
  return _internal_has_find_and_remove_re2();
}
inline void GetElementStatusProto_MatchOptions::clear_find_and_remove_re2() {
  find_and_remove_re2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetElementStatusProto_MatchOptions::find_and_remove_re2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchOptions.find_and_remove_re2)
  return _internal_find_and_remove_re2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetElementStatusProto_MatchOptions::set_find_and_remove_re2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 find_and_remove_re2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchOptions.find_and_remove_re2)
}
inline std::string* GetElementStatusProto_MatchOptions::mutable_find_and_remove_re2() {
  std::string* _s = _internal_mutable_find_and_remove_re2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.MatchOptions.find_and_remove_re2)
  return _s;
}
inline const std::string& GetElementStatusProto_MatchOptions::_internal_find_and_remove_re2() const {
  return find_and_remove_re2_.Get();
}
inline void GetElementStatusProto_MatchOptions::_internal_set_find_and_remove_re2(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  find_and_remove_re2_.Set(value, GetArenaForAllocation());
}
inline std::string* GetElementStatusProto_MatchOptions::_internal_mutable_find_and_remove_re2() {
  _has_bits_[0] |= 0x00000001u;
  return find_and_remove_re2_.Mutable(GetArenaForAllocation());
}
inline std::string* GetElementStatusProto_MatchOptions::release_find_and_remove_re2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.MatchOptions.find_and_remove_re2)
  if (!_internal_has_find_and_remove_re2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = find_and_remove_re2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (find_and_remove_re2_.IsDefault()) {
    find_and_remove_re2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetElementStatusProto_MatchOptions::set_allocated_find_and_remove_re2(std::string* find_and_remove_re2) {
  if (find_and_remove_re2 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  find_and_remove_re2_.SetAllocated(find_and_remove_re2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (find_and_remove_re2_.IsDefault()) {
    find_and_remove_re2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.MatchOptions.find_and_remove_re2)
}

// -------------------------------------------------------------------

// GetElementStatusProto_MatchExpectation

// optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
inline bool GetElementStatusProto_MatchExpectation::_internal_has_match_options() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || match_options_ != nullptr);
  return value;
}
inline bool GetElementStatusProto_MatchExpectation::has_match_options() const {
  return _internal_has_match_options();
}
inline void GetElementStatusProto_MatchExpectation::clear_match_options() {
  if (match_options_ != nullptr) match_options_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::GetElementStatusProto_MatchOptions& GetElementStatusProto_MatchExpectation::_internal_match_options() const {
  const ::autofill_assistant::GetElementStatusProto_MatchOptions* p = match_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetElementStatusProto_MatchOptions&>(
      ::autofill_assistant::_GetElementStatusProto_MatchOptions_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto_MatchOptions& GetElementStatusProto_MatchExpectation::match_options() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchExpectation.match_options)
  return _internal_match_options();
}
inline void GetElementStatusProto_MatchExpectation::unsafe_arena_set_allocated_match_options(
    ::autofill_assistant::GetElementStatusProto_MatchOptions* match_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_options_);
  }
  match_options_ = match_options;
  if (match_options) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.MatchExpectation.match_options)
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_MatchExpectation::release_match_options() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* temp = match_options_;
  match_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_MatchExpectation::unsafe_arena_release_match_options() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.MatchExpectation.match_options)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* temp = match_options_;
  match_options_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_MatchExpectation::_internal_mutable_match_options() {
  _has_bits_[0] |= 0x00000001u;
  if (match_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_MatchOptions>(GetArenaForAllocation());
    match_options_ = p;
  }
  return match_options_;
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_MatchExpectation::mutable_match_options() {
  ::autofill_assistant::GetElementStatusProto_MatchOptions* _msg = _internal_mutable_match_options();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.MatchExpectation.match_options)
  return _msg;
}
inline void GetElementStatusProto_MatchExpectation::set_allocated_match_options(::autofill_assistant::GetElementStatusProto_MatchOptions* match_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_options_;
  }
  if (match_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(match_options);
    if (message_arena != submessage_arena) {
      match_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  match_options_ = match_options;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.MatchExpectation.match_options)
}

// bool full_match = 2;
inline bool GetElementStatusProto_MatchExpectation::_internal_has_full_match() const {
  return match_level_case() == kFullMatch;
}
inline bool GetElementStatusProto_MatchExpectation::has_full_match() const {
  return _internal_has_full_match();
}
inline void GetElementStatusProto_MatchExpectation::set_has_full_match() {
  _oneof_case_[0] = kFullMatch;
}
inline void GetElementStatusProto_MatchExpectation::clear_full_match() {
  if (_internal_has_full_match()) {
    match_level_.full_match_ = false;
    clear_has_match_level();
  }
}
inline bool GetElementStatusProto_MatchExpectation::_internal_full_match() const {
  if (_internal_has_full_match()) {
    return match_level_.full_match_;
  }
  return false;
}
inline void GetElementStatusProto_MatchExpectation::_internal_set_full_match(bool value) {
  if (!_internal_has_full_match()) {
    clear_match_level();
    set_has_full_match();
  }
  match_level_.full_match_ = value;
}
inline bool GetElementStatusProto_MatchExpectation::full_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchExpectation.full_match)
  return _internal_full_match();
}
inline void GetElementStatusProto_MatchExpectation::set_full_match(bool value) {
  _internal_set_full_match(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchExpectation.full_match)
}

// bool contains = 3;
inline bool GetElementStatusProto_MatchExpectation::_internal_has_contains() const {
  return match_level_case() == kContains;
}
inline bool GetElementStatusProto_MatchExpectation::has_contains() const {
  return _internal_has_contains();
}
inline void GetElementStatusProto_MatchExpectation::set_has_contains() {
  _oneof_case_[0] = kContains;
}
inline void GetElementStatusProto_MatchExpectation::clear_contains() {
  if (_internal_has_contains()) {
    match_level_.contains_ = false;
    clear_has_match_level();
  }
}
inline bool GetElementStatusProto_MatchExpectation::_internal_contains() const {
  if (_internal_has_contains()) {
    return match_level_.contains_;
  }
  return false;
}
inline void GetElementStatusProto_MatchExpectation::_internal_set_contains(bool value) {
  if (!_internal_has_contains()) {
    clear_match_level();
    set_has_contains();
  }
  match_level_.contains_ = value;
}
inline bool GetElementStatusProto_MatchExpectation::contains() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchExpectation.contains)
  return _internal_contains();
}
inline void GetElementStatusProto_MatchExpectation::set_contains(bool value) {
  _internal_set_contains(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchExpectation.contains)
}

// bool starts_with = 4;
inline bool GetElementStatusProto_MatchExpectation::_internal_has_starts_with() const {
  return match_level_case() == kStartsWith;
}
inline bool GetElementStatusProto_MatchExpectation::has_starts_with() const {
  return _internal_has_starts_with();
}
inline void GetElementStatusProto_MatchExpectation::set_has_starts_with() {
  _oneof_case_[0] = kStartsWith;
}
inline void GetElementStatusProto_MatchExpectation::clear_starts_with() {
  if (_internal_has_starts_with()) {
    match_level_.starts_with_ = false;
    clear_has_match_level();
  }
}
inline bool GetElementStatusProto_MatchExpectation::_internal_starts_with() const {
  if (_internal_has_starts_with()) {
    return match_level_.starts_with_;
  }
  return false;
}
inline void GetElementStatusProto_MatchExpectation::_internal_set_starts_with(bool value) {
  if (!_internal_has_starts_with()) {
    clear_match_level();
    set_has_starts_with();
  }
  match_level_.starts_with_ = value;
}
inline bool GetElementStatusProto_MatchExpectation::starts_with() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchExpectation.starts_with)
  return _internal_starts_with();
}
inline void GetElementStatusProto_MatchExpectation::set_starts_with(bool value) {
  _internal_set_starts_with(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchExpectation.starts_with)
}

// bool ends_with = 5;
inline bool GetElementStatusProto_MatchExpectation::_internal_has_ends_with() const {
  return match_level_case() == kEndsWith;
}
inline bool GetElementStatusProto_MatchExpectation::has_ends_with() const {
  return _internal_has_ends_with();
}
inline void GetElementStatusProto_MatchExpectation::set_has_ends_with() {
  _oneof_case_[0] = kEndsWith;
}
inline void GetElementStatusProto_MatchExpectation::clear_ends_with() {
  if (_internal_has_ends_with()) {
    match_level_.ends_with_ = false;
    clear_has_match_level();
  }
}
inline bool GetElementStatusProto_MatchExpectation::_internal_ends_with() const {
  if (_internal_has_ends_with()) {
    return match_level_.ends_with_;
  }
  return false;
}
inline void GetElementStatusProto_MatchExpectation::_internal_set_ends_with(bool value) {
  if (!_internal_has_ends_with()) {
    clear_match_level();
    set_has_ends_with();
  }
  match_level_.ends_with_ = value;
}
inline bool GetElementStatusProto_MatchExpectation::ends_with() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.MatchExpectation.ends_with)
  return _internal_ends_with();
}
inline void GetElementStatusProto_MatchExpectation::set_ends_with(bool value) {
  _internal_set_ends_with(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.MatchExpectation.ends_with)
}

inline bool GetElementStatusProto_MatchExpectation::has_match_level() const {
  return match_level_case() != MATCH_LEVEL_NOT_SET;
}
inline void GetElementStatusProto_MatchExpectation::clear_has_match_level() {
  _oneof_case_[0] = MATCH_LEVEL_NOT_SET;
}
inline GetElementStatusProto_MatchExpectation::MatchLevelCase GetElementStatusProto_MatchExpectation::match_level_case() const {
  return GetElementStatusProto_MatchExpectation::MatchLevelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetElementStatusProto_TextMatch

// string re2 = 4;
inline bool GetElementStatusProto_TextMatch::_internal_has_re2() const {
  return value_source_case() == kRe2;
}
inline bool GetElementStatusProto_TextMatch::has_re2() const {
  return _internal_has_re2();
}
inline void GetElementStatusProto_TextMatch::set_has_re2() {
  _oneof_case_[0] = kRe2;
}
inline void GetElementStatusProto_TextMatch::clear_re2() {
  if (_internal_has_re2()) {
    value_source_.re2_.Destroy();
    clear_has_value_source();
  }
}
inline const std::string& GetElementStatusProto_TextMatch::re2() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.TextMatch.re2)
  return _internal_re2();
}
template <typename ArgT0, typename... ArgT>
inline void GetElementStatusProto_TextMatch::set_re2(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_re2()) {
    clear_value_source();
    set_has_re2();
    value_source_.re2_.InitDefault();
  }
  value_source_.re2_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.TextMatch.re2)
}
inline std::string* GetElementStatusProto_TextMatch::mutable_re2() {
  std::string* _s = _internal_mutable_re2();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.TextMatch.re2)
  return _s;
}
inline const std::string& GetElementStatusProto_TextMatch::_internal_re2() const {
  if (_internal_has_re2()) {
    return value_source_.re2_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetElementStatusProto_TextMatch::_internal_set_re2(const std::string& value) {
  if (!_internal_has_re2()) {
    clear_value_source();
    set_has_re2();
    value_source_.re2_.InitDefault();
  }
  value_source_.re2_.Set(value, GetArenaForAllocation());
}
inline std::string* GetElementStatusProto_TextMatch::_internal_mutable_re2() {
  if (!_internal_has_re2()) {
    clear_value_source();
    set_has_re2();
    value_source_.re2_.InitDefault();
  }
  return value_source_.re2_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetElementStatusProto_TextMatch::release_re2() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.TextMatch.re2)
  if (_internal_has_re2()) {
    clear_has_value_source();
    return value_source_.re2_.Release();
  } else {
    return nullptr;
  }
}
inline void GetElementStatusProto_TextMatch::set_allocated_re2(std::string* re2) {
  if (has_value_source()) {
    clear_value_source();
  }
  if (re2 != nullptr) {
    set_has_re2();
    value_source_.re2_.InitAllocated(re2, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.TextMatch.re2)
}

// .autofill_assistant.TextValue text_value = 5;
inline bool GetElementStatusProto_TextMatch::_internal_has_text_value() const {
  return value_source_case() == kTextValue;
}
inline bool GetElementStatusProto_TextMatch::has_text_value() const {
  return _internal_has_text_value();
}
inline void GetElementStatusProto_TextMatch::set_has_text_value() {
  _oneof_case_[0] = kTextValue;
}
inline ::autofill_assistant::TextValue* GetElementStatusProto_TextMatch::release_text_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.TextMatch.text_value)
  if (_internal_has_text_value()) {
    clear_has_value_source();
    ::autofill_assistant::TextValue* temp = value_source_.text_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_source_.text_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextValue& GetElementStatusProto_TextMatch::_internal_text_value() const {
  return _internal_has_text_value()
      ? *value_source_.text_value_
      : reinterpret_cast< ::autofill_assistant::TextValue&>(::autofill_assistant::_TextValue_default_instance_);
}
inline const ::autofill_assistant::TextValue& GetElementStatusProto_TextMatch::text_value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.TextMatch.text_value)
  return _internal_text_value();
}
inline ::autofill_assistant::TextValue* GetElementStatusProto_TextMatch::unsafe_arena_release_text_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.GetElementStatusProto.TextMatch.text_value)
  if (_internal_has_text_value()) {
    clear_has_value_source();
    ::autofill_assistant::TextValue* temp = value_source_.text_value_;
    value_source_.text_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetElementStatusProto_TextMatch::unsafe_arena_set_allocated_text_value(::autofill_assistant::TextValue* text_value) {
  clear_value_source();
  if (text_value) {
    set_has_text_value();
    value_source_.text_value_ = text_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.TextMatch.text_value)
}
inline ::autofill_assistant::TextValue* GetElementStatusProto_TextMatch::_internal_mutable_text_value() {
  if (!_internal_has_text_value()) {
    clear_value_source();
    set_has_text_value();
    value_source_.text_value_ = CreateMaybeMessage< ::autofill_assistant::TextValue >(GetArenaForAllocation());
  }
  return value_source_.text_value_;
}
inline ::autofill_assistant::TextValue* GetElementStatusProto_TextMatch::mutable_text_value() {
  ::autofill_assistant::TextValue* _msg = _internal_mutable_text_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.TextMatch.text_value)
  return _msg;
}

// optional .autofill_assistant.GetElementStatusProto.MatchExpectation match_expectation = 3;
inline bool GetElementStatusProto_TextMatch::_internal_has_match_expectation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || match_expectation_ != nullptr);
  return value;
}
inline bool GetElementStatusProto_TextMatch::has_match_expectation() const {
  return _internal_has_match_expectation();
}
inline void GetElementStatusProto_TextMatch::clear_match_expectation() {
  if (match_expectation_ != nullptr) match_expectation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::GetElementStatusProto_MatchExpectation& GetElementStatusProto_TextMatch::_internal_match_expectation() const {
  const ::autofill_assistant::GetElementStatusProto_MatchExpectation* p = match_expectation_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetElementStatusProto_MatchExpectation&>(
      ::autofill_assistant::_GetElementStatusProto_MatchExpectation_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto_MatchExpectation& GetElementStatusProto_TextMatch::match_expectation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.TextMatch.match_expectation)
  return _internal_match_expectation();
}
inline void GetElementStatusProto_TextMatch::unsafe_arena_set_allocated_match_expectation(
    ::autofill_assistant::GetElementStatusProto_MatchExpectation* match_expectation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_expectation_);
  }
  match_expectation_ = match_expectation;
  if (match_expectation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.TextMatch.match_expectation)
}
inline ::autofill_assistant::GetElementStatusProto_MatchExpectation* GetElementStatusProto_TextMatch::release_match_expectation() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* temp = match_expectation_;
  match_expectation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_MatchExpectation* GetElementStatusProto_TextMatch::unsafe_arena_release_match_expectation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.TextMatch.match_expectation)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* temp = match_expectation_;
  match_expectation_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_MatchExpectation* GetElementStatusProto_TextMatch::_internal_mutable_match_expectation() {
  _has_bits_[0] |= 0x00000001u;
  if (match_expectation_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_MatchExpectation>(GetArenaForAllocation());
    match_expectation_ = p;
  }
  return match_expectation_;
}
inline ::autofill_assistant::GetElementStatusProto_MatchExpectation* GetElementStatusProto_TextMatch::mutable_match_expectation() {
  ::autofill_assistant::GetElementStatusProto_MatchExpectation* _msg = _internal_mutable_match_expectation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.TextMatch.match_expectation)
  return _msg;
}
inline void GetElementStatusProto_TextMatch::set_allocated_match_expectation(::autofill_assistant::GetElementStatusProto_MatchExpectation* match_expectation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_expectation_;
  }
  if (match_expectation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(match_expectation);
    if (message_arena != submessage_arena) {
      match_expectation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match_expectation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  match_expectation_ = match_expectation;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.TextMatch.match_expectation)
}

inline bool GetElementStatusProto_TextMatch::has_value_source() const {
  return value_source_case() != VALUE_SOURCE_NOT_SET;
}
inline void GetElementStatusProto_TextMatch::clear_has_value_source() {
  _oneof_case_[0] = VALUE_SOURCE_NOT_SET;
}
inline GetElementStatusProto_TextMatch::ValueSourceCase GetElementStatusProto_TextMatch::value_source_case() const {
  return GetElementStatusProto_TextMatch::ValueSourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetElementStatusProto_ValueMatch

// optional .autofill_assistant.GetElementStatusProto.TextMatch text_match = 1;
inline bool GetElementStatusProto_ValueMatch::_internal_has_text_match() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || text_match_ != nullptr);
  return value;
}
inline bool GetElementStatusProto_ValueMatch::has_text_match() const {
  return _internal_has_text_match();
}
inline void GetElementStatusProto_ValueMatch::clear_text_match() {
  if (text_match_ != nullptr) text_match_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::GetElementStatusProto_TextMatch& GetElementStatusProto_ValueMatch::_internal_text_match() const {
  const ::autofill_assistant::GetElementStatusProto_TextMatch* p = text_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetElementStatusProto_TextMatch&>(
      ::autofill_assistant::_GetElementStatusProto_TextMatch_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto_TextMatch& GetElementStatusProto_ValueMatch::text_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ValueMatch.text_match)
  return _internal_text_match();
}
inline void GetElementStatusProto_ValueMatch::unsafe_arena_set_allocated_text_match(
    ::autofill_assistant::GetElementStatusProto_TextMatch* text_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_match_);
  }
  text_match_ = text_match;
  if (text_match) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.ValueMatch.text_match)
}
inline ::autofill_assistant::GetElementStatusProto_TextMatch* GetElementStatusProto_ValueMatch::release_text_match() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_TextMatch* temp = text_match_;
  text_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_TextMatch* GetElementStatusProto_ValueMatch::unsafe_arena_release_text_match() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.ValueMatch.text_match)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_TextMatch* temp = text_match_;
  text_match_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_TextMatch* GetElementStatusProto_ValueMatch::_internal_mutable_text_match() {
  _has_bits_[0] |= 0x00000001u;
  if (text_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_TextMatch>(GetArenaForAllocation());
    text_match_ = p;
  }
  return text_match_;
}
inline ::autofill_assistant::GetElementStatusProto_TextMatch* GetElementStatusProto_ValueMatch::mutable_text_match() {
  ::autofill_assistant::GetElementStatusProto_TextMatch* _msg = _internal_mutable_text_match();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.ValueMatch.text_match)
  return _msg;
}
inline void GetElementStatusProto_ValueMatch::set_allocated_text_match(::autofill_assistant::GetElementStatusProto_TextMatch* text_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_match_;
  }
  if (text_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_match);
    if (message_arena != submessage_arena) {
      text_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_match, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_match_ = text_match;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.ValueMatch.text_match)
}

// -------------------------------------------------------------------

// GetElementStatusProto_ComparisonReport

// optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_match_options() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || match_options_ != nullptr);
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_match_options() const {
  return _internal_has_match_options();
}
inline void GetElementStatusProto_ComparisonReport::clear_match_options() {
  if (match_options_ != nullptr) match_options_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::GetElementStatusProto_MatchOptions& GetElementStatusProto_ComparisonReport::_internal_match_options() const {
  const ::autofill_assistant::GetElementStatusProto_MatchOptions* p = match_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetElementStatusProto_MatchOptions&>(
      ::autofill_assistant::_GetElementStatusProto_MatchOptions_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto_MatchOptions& GetElementStatusProto_ComparisonReport::match_options() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.match_options)
  return _internal_match_options();
}
inline void GetElementStatusProto_ComparisonReport::unsafe_arena_set_allocated_match_options(
    ::autofill_assistant::GetElementStatusProto_MatchOptions* match_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_options_);
  }
  match_options_ = match_options;
  if (match_options) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.ComparisonReport.match_options)
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_ComparisonReport::release_match_options() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* temp = match_options_;
  match_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_ComparisonReport::unsafe_arena_release_match_options() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.ComparisonReport.match_options)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_MatchOptions* temp = match_options_;
  match_options_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_ComparisonReport::_internal_mutable_match_options() {
  _has_bits_[0] |= 0x00000001u;
  if (match_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_MatchOptions>(GetArenaForAllocation());
    match_options_ = p;
  }
  return match_options_;
}
inline ::autofill_assistant::GetElementStatusProto_MatchOptions* GetElementStatusProto_ComparisonReport::mutable_match_options() {
  ::autofill_assistant::GetElementStatusProto_MatchOptions* _msg = _internal_mutable_match_options();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.ComparisonReport.match_options)
  return _msg;
}
inline void GetElementStatusProto_ComparisonReport::set_allocated_match_options(::autofill_assistant::GetElementStatusProto_MatchOptions* match_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_options_;
  }
  if (match_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(match_options);
    if (message_arena != submessage_arena) {
      match_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  match_options_ = match_options;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.ComparisonReport.match_options)
}

// optional bool full_match = 2;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_full_match() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_full_match() const {
  return _internal_has_full_match();
}
inline void GetElementStatusProto_ComparisonReport::clear_full_match() {
  full_match_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GetElementStatusProto_ComparisonReport::_internal_full_match() const {
  return full_match_;
}
inline bool GetElementStatusProto_ComparisonReport::full_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.full_match)
  return _internal_full_match();
}
inline void GetElementStatusProto_ComparisonReport::_internal_set_full_match(bool value) {
  _has_bits_[0] |= 0x00000002u;
  full_match_ = value;
}
inline void GetElementStatusProto_ComparisonReport::set_full_match(bool value) {
  _internal_set_full_match(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.ComparisonReport.full_match)
}

// optional bool contains = 3;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_contains() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_contains() const {
  return _internal_has_contains();
}
inline void GetElementStatusProto_ComparisonReport::clear_contains() {
  contains_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetElementStatusProto_ComparisonReport::_internal_contains() const {
  return contains_;
}
inline bool GetElementStatusProto_ComparisonReport::contains() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.contains)
  return _internal_contains();
}
inline void GetElementStatusProto_ComparisonReport::_internal_set_contains(bool value) {
  _has_bits_[0] |= 0x00000004u;
  contains_ = value;
}
inline void GetElementStatusProto_ComparisonReport::set_contains(bool value) {
  _internal_set_contains(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.ComparisonReport.contains)
}

// optional bool starts_with = 4;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_starts_with() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_starts_with() const {
  return _internal_has_starts_with();
}
inline void GetElementStatusProto_ComparisonReport::clear_starts_with() {
  starts_with_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GetElementStatusProto_ComparisonReport::_internal_starts_with() const {
  return starts_with_;
}
inline bool GetElementStatusProto_ComparisonReport::starts_with() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.starts_with)
  return _internal_starts_with();
}
inline void GetElementStatusProto_ComparisonReport::_internal_set_starts_with(bool value) {
  _has_bits_[0] |= 0x00000008u;
  starts_with_ = value;
}
inline void GetElementStatusProto_ComparisonReport::set_starts_with(bool value) {
  _internal_set_starts_with(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.ComparisonReport.starts_with)
}

// optional bool ends_with = 5;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_ends_with() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_ends_with() const {
  return _internal_has_ends_with();
}
inline void GetElementStatusProto_ComparisonReport::clear_ends_with() {
  ends_with_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GetElementStatusProto_ComparisonReport::_internal_ends_with() const {
  return ends_with_;
}
inline bool GetElementStatusProto_ComparisonReport::ends_with() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.ends_with)
  return _internal_ends_with();
}
inline void GetElementStatusProto_ComparisonReport::_internal_set_ends_with(bool value) {
  _has_bits_[0] |= 0x00000010u;
  ends_with_ = value;
}
inline void GetElementStatusProto_ComparisonReport::set_ends_with(bool value) {
  _internal_set_ends_with(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.ComparisonReport.ends_with)
}

// optional bool empty = 6;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_empty() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_empty() const {
  return _internal_has_empty();
}
inline void GetElementStatusProto_ComparisonReport::clear_empty() {
  empty_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GetElementStatusProto_ComparisonReport::_internal_empty() const {
  return empty_;
}
inline bool GetElementStatusProto_ComparisonReport::empty() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.empty)
  return _internal_empty();
}
inline void GetElementStatusProto_ComparisonReport::_internal_set_empty(bool value) {
  _has_bits_[0] |= 0x00000020u;
  empty_ = value;
}
inline void GetElementStatusProto_ComparisonReport::set_empty(bool value) {
  _internal_set_empty(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.ComparisonReport.empty)
}

// optional bool expected_empty_match = 7;
inline bool GetElementStatusProto_ComparisonReport::_internal_has_expected_empty_match() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GetElementStatusProto_ComparisonReport::has_expected_empty_match() const {
  return _internal_has_expected_empty_match();
}
inline void GetElementStatusProto_ComparisonReport::clear_expected_empty_match() {
  expected_empty_match_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool GetElementStatusProto_ComparisonReport::_internal_expected_empty_match() const {
  return expected_empty_match_;
}
inline bool GetElementStatusProto_ComparisonReport::expected_empty_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.ComparisonReport.expected_empty_match)
  return _internal_expected_empty_match();
}
inline void GetElementStatusProto_ComparisonReport::_internal_set_expected_empty_match(bool value) {
  _has_bits_[0] |= 0x00000040u;
  expected_empty_match_ = value;
}
inline void GetElementStatusProto_ComparisonReport::set_expected_empty_match(bool value) {
  _internal_set_expected_empty_match(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.ComparisonReport.expected_empty_match)
}

// -------------------------------------------------------------------

// GetElementStatusProto

// .autofill_assistant.SelectorProto selector = 1;
inline bool GetElementStatusProto::_internal_has_selector() const {
  return element_case() == kSelector;
}
inline bool GetElementStatusProto::has_selector() const {
  return _internal_has_selector();
}
inline void GetElementStatusProto::set_has_selector() {
  _oneof_case_[0] = kSelector;
}
inline void GetElementStatusProto::clear_selector() {
  if (_internal_has_selector()) {
    if (GetArenaForAllocation() == nullptr) {
      delete element_.selector_;
    }
    clear_has_element();
  }
}
inline ::autofill_assistant::SelectorProto* GetElementStatusProto::release_selector() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.selector)
  if (_internal_has_selector()) {
    clear_has_element();
    ::autofill_assistant::SelectorProto* temp = element_.selector_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    element_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::SelectorProto& GetElementStatusProto::_internal_selector() const {
  return _internal_has_selector()
      ? *element_.selector_
      : reinterpret_cast< ::autofill_assistant::SelectorProto&>(::autofill_assistant::_SelectorProto_default_instance_);
}
inline const ::autofill_assistant::SelectorProto& GetElementStatusProto::selector() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.selector)
  return _internal_selector();
}
inline ::autofill_assistant::SelectorProto* GetElementStatusProto::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.GetElementStatusProto.selector)
  if (_internal_has_selector()) {
    clear_has_element();
    ::autofill_assistant::SelectorProto* temp = element_.selector_;
    element_.selector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetElementStatusProto::unsafe_arena_set_allocated_selector(::autofill_assistant::SelectorProto* selector) {
  clear_element();
  if (selector) {
    set_has_selector();
    element_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.selector)
}
inline ::autofill_assistant::SelectorProto* GetElementStatusProto::_internal_mutable_selector() {
  if (!_internal_has_selector()) {
    clear_element();
    set_has_selector();
    element_.selector_ = CreateMaybeMessage< ::autofill_assistant::SelectorProto >(GetArenaForAllocation());
  }
  return element_.selector_;
}
inline ::autofill_assistant::SelectorProto* GetElementStatusProto::mutable_selector() {
  ::autofill_assistant::SelectorProto* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.selector)
  return _msg;
}

// .autofill_assistant.ClientIdProto client_id = 5;
inline bool GetElementStatusProto::_internal_has_client_id() const {
  return element_case() == kClientId;
}
inline bool GetElementStatusProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void GetElementStatusProto::set_has_client_id() {
  _oneof_case_[0] = kClientId;
}
inline ::autofill_assistant::ClientIdProto* GetElementStatusProto::release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.client_id)
  if (_internal_has_client_id()) {
    clear_has_element();
    ::autofill_assistant::ClientIdProto* temp = element_.client_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    element_.client_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ClientIdProto& GetElementStatusProto::_internal_client_id() const {
  return _internal_has_client_id()
      ? *element_.client_id_
      : reinterpret_cast< ::autofill_assistant::ClientIdProto&>(::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& GetElementStatusProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.client_id)
  return _internal_client_id();
}
inline ::autofill_assistant::ClientIdProto* GetElementStatusProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.GetElementStatusProto.client_id)
  if (_internal_has_client_id()) {
    clear_has_element();
    ::autofill_assistant::ClientIdProto* temp = element_.client_id_;
    element_.client_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetElementStatusProto::unsafe_arena_set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  clear_element();
  if (client_id) {
    set_has_client_id();
    element_.client_id_ = client_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* GetElementStatusProto::_internal_mutable_client_id() {
  if (!_internal_has_client_id()) {
    clear_element();
    set_has_client_id();
    element_.client_id_ = CreateMaybeMessage< ::autofill_assistant::ClientIdProto >(GetArenaForAllocation());
  }
  return element_.client_id_;
}
inline ::autofill_assistant::ClientIdProto* GetElementStatusProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.client_id)
  return _msg;
}

// optional .autofill_assistant.GetElementStatusProto.ValueMatch expected_value_match = 2;
inline bool GetElementStatusProto::_internal_has_expected_value_match() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || expected_value_match_ != nullptr);
  return value;
}
inline bool GetElementStatusProto::has_expected_value_match() const {
  return _internal_has_expected_value_match();
}
inline void GetElementStatusProto::clear_expected_value_match() {
  if (expected_value_match_ != nullptr) expected_value_match_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::GetElementStatusProto_ValueMatch& GetElementStatusProto::_internal_expected_value_match() const {
  const ::autofill_assistant::GetElementStatusProto_ValueMatch* p = expected_value_match_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::GetElementStatusProto_ValueMatch&>(
      ::autofill_assistant::_GetElementStatusProto_ValueMatch_default_instance_);
}
inline const ::autofill_assistant::GetElementStatusProto_ValueMatch& GetElementStatusProto::expected_value_match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.expected_value_match)
  return _internal_expected_value_match();
}
inline void GetElementStatusProto::unsafe_arena_set_allocated_expected_value_match(
    ::autofill_assistant::GetElementStatusProto_ValueMatch* expected_value_match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expected_value_match_);
  }
  expected_value_match_ = expected_value_match;
  if (expected_value_match) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.GetElementStatusProto.expected_value_match)
}
inline ::autofill_assistant::GetElementStatusProto_ValueMatch* GetElementStatusProto::release_expected_value_match() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_ValueMatch* temp = expected_value_match_;
  expected_value_match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_ValueMatch* GetElementStatusProto::unsafe_arena_release_expected_value_match() {
  // @@protoc_insertion_point(field_release:autofill_assistant.GetElementStatusProto.expected_value_match)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::GetElementStatusProto_ValueMatch* temp = expected_value_match_;
  expected_value_match_ = nullptr;
  return temp;
}
inline ::autofill_assistant::GetElementStatusProto_ValueMatch* GetElementStatusProto::_internal_mutable_expected_value_match() {
  _has_bits_[0] |= 0x00000001u;
  if (expected_value_match_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::GetElementStatusProto_ValueMatch>(GetArenaForAllocation());
    expected_value_match_ = p;
  }
  return expected_value_match_;
}
inline ::autofill_assistant::GetElementStatusProto_ValueMatch* GetElementStatusProto::mutable_expected_value_match() {
  ::autofill_assistant::GetElementStatusProto_ValueMatch* _msg = _internal_mutable_expected_value_match();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.GetElementStatusProto.expected_value_match)
  return _msg;
}
inline void GetElementStatusProto::set_allocated_expected_value_match(::autofill_assistant::GetElementStatusProto_ValueMatch* expected_value_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete expected_value_match_;
  }
  if (expected_value_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expected_value_match);
    if (message_arena != submessage_arena) {
      expected_value_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expected_value_match, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expected_value_match_ = expected_value_match;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.expected_value_match)
}

// optional .autofill_assistant.GetElementStatusProto.ValueSource value_source = 4;
inline bool GetElementStatusProto::_internal_has_value_source() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetElementStatusProto::has_value_source() const {
  return _internal_has_value_source();
}
inline void GetElementStatusProto::clear_value_source() {
  value_source_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::GetElementStatusProto_ValueSource GetElementStatusProto::_internal_value_source() const {
  return static_cast< ::autofill_assistant::GetElementStatusProto_ValueSource >(value_source_);
}
inline ::autofill_assistant::GetElementStatusProto_ValueSource GetElementStatusProto::value_source() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.value_source)
  return _internal_value_source();
}
inline void GetElementStatusProto::_internal_set_value_source(::autofill_assistant::GetElementStatusProto_ValueSource value) {
  assert(::autofill_assistant::GetElementStatusProto_ValueSource_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  value_source_ = value;
}
inline void GetElementStatusProto::set_value_source(::autofill_assistant::GetElementStatusProto_ValueSource value) {
  _internal_set_value_source(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.value_source)
}

// optional bool mismatch_should_fail = 3;
inline bool GetElementStatusProto::_internal_has_mismatch_should_fail() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetElementStatusProto::has_mismatch_should_fail() const {
  return _internal_has_mismatch_should_fail();
}
inline void GetElementStatusProto::clear_mismatch_should_fail() {
  mismatch_should_fail_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GetElementStatusProto::_internal_mismatch_should_fail() const {
  return mismatch_should_fail_;
}
inline bool GetElementStatusProto::mismatch_should_fail() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.GetElementStatusProto.mismatch_should_fail)
  return _internal_mismatch_should_fail();
}
inline void GetElementStatusProto::_internal_set_mismatch_should_fail(bool value) {
  _has_bits_[0] |= 0x00000002u;
  mismatch_should_fail_ = value;
}
inline void GetElementStatusProto::set_mismatch_should_fail(bool value) {
  _internal_set_mismatch_should_fail(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.GetElementStatusProto.mismatch_should_fail)
}

inline bool GetElementStatusProto::has_element() const {
  return element_case() != ELEMENT_NOT_SET;
}
inline void GetElementStatusProto::clear_has_element() {
  _oneof_case_[0] = ELEMENT_NOT_SET;
}
inline GetElementStatusProto::ElementCase GetElementStatusProto::element_case() const {
  return GetElementStatusProto::ElementCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReleaseElementsProto

// repeated .autofill_assistant.ClientIdProto client_ids = 1;
inline int ReleaseElementsProto::_internal_client_ids_size() const {
  return client_ids_.size();
}
inline int ReleaseElementsProto::client_ids_size() const {
  return _internal_client_ids_size();
}
inline ::autofill_assistant::ClientIdProto* ReleaseElementsProto::mutable_client_ids(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ReleaseElementsProto.client_ids)
  return client_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientIdProto >*
ReleaseElementsProto::mutable_client_ids() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ReleaseElementsProto.client_ids)
  return &client_ids_;
}
inline const ::autofill_assistant::ClientIdProto& ReleaseElementsProto::_internal_client_ids(int index) const {
  return client_ids_.Get(index);
}
inline const ::autofill_assistant::ClientIdProto& ReleaseElementsProto::client_ids(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ReleaseElementsProto.client_ids)
  return _internal_client_ids(index);
}
inline ::autofill_assistant::ClientIdProto* ReleaseElementsProto::_internal_add_client_ids() {
  return client_ids_.Add();
}
inline ::autofill_assistant::ClientIdProto* ReleaseElementsProto::add_client_ids() {
  ::autofill_assistant::ClientIdProto* _add = _internal_add_client_ids();
  // @@protoc_insertion_point(field_add:autofill_assistant.ReleaseElementsProto.client_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ClientIdProto >&
ReleaseElementsProto::client_ids() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ReleaseElementsProto.client_ids)
  return client_ids_;
}

// -------------------------------------------------------------------

// DispatchJsEventProto

// -------------------------------------------------------------------

// JsFlowProto_Result

// optional string result_json = 1;
inline bool JsFlowProto_Result::_internal_has_result_json() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JsFlowProto_Result::has_result_json() const {
  return _internal_has_result_json();
}
inline void JsFlowProto_Result::clear_result_json() {
  result_json_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JsFlowProto_Result::result_json() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.JsFlowProto.Result.result_json)
  return _internal_result_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JsFlowProto_Result::set_result_json(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 result_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.JsFlowProto.Result.result_json)
}
inline std::string* JsFlowProto_Result::mutable_result_json() {
  std::string* _s = _internal_mutable_result_json();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.JsFlowProto.Result.result_json)
  return _s;
}
inline const std::string& JsFlowProto_Result::_internal_result_json() const {
  return result_json_.Get();
}
inline void JsFlowProto_Result::_internal_set_result_json(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  result_json_.Set(value, GetArenaForAllocation());
}
inline std::string* JsFlowProto_Result::_internal_mutable_result_json() {
  _has_bits_[0] |= 0x00000001u;
  return result_json_.Mutable(GetArenaForAllocation());
}
inline std::string* JsFlowProto_Result::release_result_json() {
  // @@protoc_insertion_point(field_release:autofill_assistant.JsFlowProto.Result.result_json)
  if (!_internal_has_result_json()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = result_json_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_json_.IsDefault()) {
    result_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JsFlowProto_Result::set_allocated_result_json(std::string* result_json) {
  if (result_json != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_json_.SetAllocated(result_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_json_.IsDefault()) {
    result_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.JsFlowProto.Result.result_json)
}

// -------------------------------------------------------------------

// JsFlowProto

// optional string js_flow = 1;
inline bool JsFlowProto::_internal_has_js_flow() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JsFlowProto::has_js_flow() const {
  return _internal_has_js_flow();
}
inline void JsFlowProto::clear_js_flow() {
  js_flow_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JsFlowProto::js_flow() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.JsFlowProto.js_flow)
  return _internal_js_flow();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JsFlowProto::set_js_flow(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 js_flow_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.JsFlowProto.js_flow)
}
inline std::string* JsFlowProto::mutable_js_flow() {
  std::string* _s = _internal_mutable_js_flow();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.JsFlowProto.js_flow)
  return _s;
}
inline const std::string& JsFlowProto::_internal_js_flow() const {
  return js_flow_.Get();
}
inline void JsFlowProto::_internal_set_js_flow(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  js_flow_.Set(value, GetArenaForAllocation());
}
inline std::string* JsFlowProto::_internal_mutable_js_flow() {
  _has_bits_[0] |= 0x00000001u;
  return js_flow_.Mutable(GetArenaForAllocation());
}
inline std::string* JsFlowProto::release_js_flow() {
  // @@protoc_insertion_point(field_release:autofill_assistant.JsFlowProto.js_flow)
  if (!_internal_has_js_flow()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = js_flow_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_flow_.IsDefault()) {
    js_flow_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JsFlowProto::set_allocated_js_flow(std::string* js_flow) {
  if (js_flow != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  js_flow_.SetAllocated(js_flow, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_flow_.IsDefault()) {
    js_flow_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.JsFlowProto.js_flow)
}

// -------------------------------------------------------------------

// ExternalActionProto_ExternalCondition

// optional int32 id = 1;
inline bool ExternalActionProto_ExternalCondition::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExternalActionProto_ExternalCondition::has_id() const {
  return _internal_has_id();
}
inline void ExternalActionProto_ExternalCondition::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ExternalActionProto_ExternalCondition::_internal_id() const {
  return id_;
}
inline int32_t ExternalActionProto_ExternalCondition::id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.ExternalCondition.id)
  return _internal_id();
}
inline void ExternalActionProto_ExternalCondition::_internal_set_id(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void ExternalActionProto_ExternalCondition::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ExternalActionProto.ExternalCondition.id)
}

// optional .autofill_assistant.ElementConditionProto element_condition = 2;
inline bool ExternalActionProto_ExternalCondition::_internal_has_element_condition() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || element_condition_ != nullptr);
  return value;
}
inline bool ExternalActionProto_ExternalCondition::has_element_condition() const {
  return _internal_has_element_condition();
}
inline void ExternalActionProto_ExternalCondition::clear_element_condition() {
  if (element_condition_ != nullptr) element_condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ElementConditionProto& ExternalActionProto_ExternalCondition::_internal_element_condition() const {
  const ::autofill_assistant::ElementConditionProto* p = element_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ElementConditionProto&>(
      ::autofill_assistant::_ElementConditionProto_default_instance_);
}
inline const ::autofill_assistant::ElementConditionProto& ExternalActionProto_ExternalCondition::element_condition() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.ExternalCondition.element_condition)
  return _internal_element_condition();
}
inline void ExternalActionProto_ExternalCondition::unsafe_arena_set_allocated_element_condition(
    ::autofill_assistant::ElementConditionProto* element_condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(element_condition_);
  }
  element_condition_ = element_condition;
  if (element_condition) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ExternalActionProto.ExternalCondition.element_condition)
}
inline ::autofill_assistant::ElementConditionProto* ExternalActionProto_ExternalCondition::release_element_condition() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementConditionProto* temp = element_condition_;
  element_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* ExternalActionProto_ExternalCondition::unsafe_arena_release_element_condition() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ExternalActionProto.ExternalCondition.element_condition)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ElementConditionProto* temp = element_condition_;
  element_condition_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ElementConditionProto* ExternalActionProto_ExternalCondition::_internal_mutable_element_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (element_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ElementConditionProto>(GetArenaForAllocation());
    element_condition_ = p;
  }
  return element_condition_;
}
inline ::autofill_assistant::ElementConditionProto* ExternalActionProto_ExternalCondition::mutable_element_condition() {
  ::autofill_assistant::ElementConditionProto* _msg = _internal_mutable_element_condition();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ExternalActionProto.ExternalCondition.element_condition)
  return _msg;
}
inline void ExternalActionProto_ExternalCondition::set_allocated_element_condition(::autofill_assistant::ElementConditionProto* element_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete element_condition_;
  }
  if (element_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element_condition);
    if (message_arena != submessage_arena) {
      element_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element_condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  element_condition_ = element_condition;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ExternalActionProto.ExternalCondition.element_condition)
}

// -------------------------------------------------------------------

// ExternalActionProto_Result

// optional .autofill_assistant.external.ResultInfo result_info = 1;
inline bool ExternalActionProto_Result::_internal_has_result_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || result_info_ != nullptr);
  return value;
}
inline bool ExternalActionProto_Result::has_result_info() const {
  return _internal_has_result_info();
}
inline const ::autofill_assistant::external::ResultInfo& ExternalActionProto_Result::_internal_result_info() const {
  const ::autofill_assistant::external::ResultInfo* p = result_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::external::ResultInfo&>(
      ::autofill_assistant::external::_ResultInfo_default_instance_);
}
inline const ::autofill_assistant::external::ResultInfo& ExternalActionProto_Result::result_info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.Result.result_info)
  return _internal_result_info();
}
inline void ExternalActionProto_Result::unsafe_arena_set_allocated_result_info(
    ::autofill_assistant::external::ResultInfo* result_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_info_);
  }
  result_info_ = result_info;
  if (result_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ExternalActionProto.Result.result_info)
}
inline ::autofill_assistant::external::ResultInfo* ExternalActionProto_Result::release_result_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ResultInfo* temp = result_info_;
  result_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::external::ResultInfo* ExternalActionProto_Result::unsafe_arena_release_result_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ExternalActionProto.Result.result_info)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ResultInfo* temp = result_info_;
  result_info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::external::ResultInfo* ExternalActionProto_Result::_internal_mutable_result_info() {
  _has_bits_[0] |= 0x00000001u;
  if (result_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::external::ResultInfo>(GetArenaForAllocation());
    result_info_ = p;
  }
  return result_info_;
}
inline ::autofill_assistant::external::ResultInfo* ExternalActionProto_Result::mutable_result_info() {
  ::autofill_assistant::external::ResultInfo* _msg = _internal_mutable_result_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ExternalActionProto.Result.result_info)
  return _msg;
}
inline void ExternalActionProto_Result::set_allocated_result_info(::autofill_assistant::external::ResultInfo* result_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_info_);
  }
  if (result_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_info));
    if (message_arena != submessage_arena) {
      result_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_info_ = result_info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ExternalActionProto.Result.result_info)
}

// -------------------------------------------------------------------

// ExternalActionProto

// optional .autofill_assistant.external.ActionInfo info = 1;
inline bool ExternalActionProto::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool ExternalActionProto::has_info() const {
  return _internal_has_info();
}
inline const ::autofill_assistant::external::ActionInfo& ExternalActionProto::_internal_info() const {
  const ::autofill_assistant::external::ActionInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::external::ActionInfo&>(
      ::autofill_assistant::external::_ActionInfo_default_instance_);
}
inline const ::autofill_assistant::external::ActionInfo& ExternalActionProto::info() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.info)
  return _internal_info();
}
inline void ExternalActionProto::unsafe_arena_set_allocated_info(
    ::autofill_assistant::external::ActionInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ExternalActionProto.info)
}
inline ::autofill_assistant::external::ActionInfo* ExternalActionProto::release_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ActionInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::external::ActionInfo* ExternalActionProto::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ExternalActionProto.info)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::external::ActionInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::autofill_assistant::external::ActionInfo* ExternalActionProto::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::external::ActionInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::autofill_assistant::external::ActionInfo* ExternalActionProto::mutable_info() {
  ::autofill_assistant::external::ActionInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ExternalActionProto.info)
  return _msg;
}
inline void ExternalActionProto::set_allocated_info(::autofill_assistant::external::ActionInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ExternalActionProto.info)
}

// optional bool show_touchable_area = 2;
inline bool ExternalActionProto::_internal_has_show_touchable_area() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExternalActionProto::has_show_touchable_area() const {
  return _internal_has_show_touchable_area();
}
inline void ExternalActionProto::clear_show_touchable_area() {
  show_touchable_area_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ExternalActionProto::_internal_show_touchable_area() const {
  return show_touchable_area_;
}
inline bool ExternalActionProto::show_touchable_area() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.show_touchable_area)
  return _internal_show_touchable_area();
}
inline void ExternalActionProto::_internal_set_show_touchable_area(bool value) {
  _has_bits_[0] |= 0x00000002u;
  show_touchable_area_ = value;
}
inline void ExternalActionProto::set_show_touchable_area(bool value) {
  _internal_set_show_touchable_area(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ExternalActionProto.show_touchable_area)
}

// optional bool allow_interrupt = 3;
inline bool ExternalActionProto::_internal_has_allow_interrupt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExternalActionProto::has_allow_interrupt() const {
  return _internal_has_allow_interrupt();
}
inline void ExternalActionProto::clear_allow_interrupt() {
  allow_interrupt_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ExternalActionProto::_internal_allow_interrupt() const {
  return allow_interrupt_;
}
inline bool ExternalActionProto::allow_interrupt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.allow_interrupt)
  return _internal_allow_interrupt();
}
inline void ExternalActionProto::_internal_set_allow_interrupt(bool value) {
  _has_bits_[0] |= 0x00000004u;
  allow_interrupt_ = value;
}
inline void ExternalActionProto::set_allow_interrupt(bool value) {
  _internal_set_allow_interrupt(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ExternalActionProto.allow_interrupt)
}

// repeated .autofill_assistant.ExternalActionProto.ExternalCondition conditions = 4;
inline int ExternalActionProto::_internal_conditions_size() const {
  return conditions_.size();
}
inline int ExternalActionProto::conditions_size() const {
  return _internal_conditions_size();
}
inline void ExternalActionProto::clear_conditions() {
  conditions_.Clear();
}
inline ::autofill_assistant::ExternalActionProto_ExternalCondition* ExternalActionProto::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ExternalActionProto.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ExternalActionProto_ExternalCondition >*
ExternalActionProto::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ExternalActionProto.conditions)
  return &conditions_;
}
inline const ::autofill_assistant::ExternalActionProto_ExternalCondition& ExternalActionProto::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::autofill_assistant::ExternalActionProto_ExternalCondition& ExternalActionProto::conditions(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExternalActionProto.conditions)
  return _internal_conditions(index);
}
inline ::autofill_assistant::ExternalActionProto_ExternalCondition* ExternalActionProto::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::autofill_assistant::ExternalActionProto_ExternalCondition* ExternalActionProto::add_conditions() {
  ::autofill_assistant::ExternalActionProto_ExternalCondition* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:autofill_assistant.ExternalActionProto.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ExternalActionProto_ExternalCondition >&
ExternalActionProto::conditions() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ExternalActionProto.conditions)
  return conditions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill_assistant

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill_assistant::ClientContextProto_AccountsMatchingStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ClientContextProto_SignedIntoChromeStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ClientContextProto_ScreenOrientation> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ClientContextProto_PlatformType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ClientSettingsProto_DisplayStringId> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::TriggerScriptProto_TriggerScriptAction> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::TriggerScriptProto_TriggerUIType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::WebControllerErrorInfoProto_WebAction> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::SelectOptionProto_OptionComparisonAttribute> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ContactDetailsProto_AutofillContactField> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::TextInputProto_InputType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::CollectUserDataProto_TermsAndConditionsState> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ConfigureUiStateProto_OverlayBehavior> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ConfigureBottomSheetProto_PeekMode> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::GetElementStatusProto_ValueSource> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::PolicyType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::SlowWarningStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::PseudoType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::OptionalStep> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::DocumentReadyState> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fservice_2eproto
