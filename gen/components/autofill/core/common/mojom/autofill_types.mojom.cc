// components/autofill/core/common/mojom/autofill_types.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "components/autofill/core/common/mojom/autofill_types.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/autofill/core/common/mojom/autofill_types.mojom-params-data.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom-shared-message-ids.h"

#include "components/autofill/core/common/mojom/autofill_types.mojom-import-headers.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom-test-utils.h"


#ifndef COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_JUMBO_H_
#endif



namespace autofill {
namespace mojom {
FrameToken::FrameToken()
    : token(),
      is_local() {}

FrameToken::FrameToken(
    const ::base::UnguessableToken& token_in,
    bool is_local_in)
    : token(std::move(token_in)),
      is_local(std::move(is_local_in)) {}

FrameToken::~FrameToken() = default;

void FrameToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "token"), this->token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_local"), this->is_local,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FrameToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FrameTokenWithPredecessor::FrameTokenWithPredecessor()
    : token(),
      predecessor() {}

FrameTokenWithPredecessor::FrameTokenWithPredecessor(
    FrameTokenPtr token_in,
    int32_t predecessor_in)
    : token(std::move(token_in)),
      predecessor(std::move(predecessor_in)) {}

FrameTokenWithPredecessor::~FrameTokenWithPredecessor() = default;

void FrameTokenWithPredecessor::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "token"), this->token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type FrameTokenPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "predecessor"), this->predecessor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FrameTokenWithPredecessor::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormRendererId::FormRendererId()
    : id() {}

FormRendererId::FormRendererId(
    uint64_t id_in)
    : id(std::move(id_in)) {}

FormRendererId::~FormRendererId() = default;

void FormRendererId::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FormRendererId::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FieldRendererId::FieldRendererId()
    : id() {}

FieldRendererId::FieldRendererId(
    uint64_t id_in)
    : id(std::move(id_in)) {}

FieldRendererId::~FieldRendererId() = default;

void FieldRendererId::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FieldRendererId::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SelectOption::SelectOption()
    : value(),
      content() {}

SelectOption::SelectOption(
    const ::std::u16string& value_in,
    const ::std::u16string& content_in)
    : value(std::move(value_in)),
      content(std::move(content_in)) {}

SelectOption::~SelectOption() = default;

void SelectOption::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "content"), this->content,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SelectOption::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SectionAutocomplete::SectionAutocomplete()
    : section(),
      html_field_mode() {}

SectionAutocomplete::SectionAutocomplete(
    const std::string& section_in,
    uint8_t html_field_mode_in)
    : section(std::move(section_in)),
      html_field_mode(std::move(html_field_mode_in)) {}

SectionAutocomplete::~SectionAutocomplete() = default;
size_t SectionAutocomplete::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->section);
  seed = mojo::internal::Hash(seed, this->html_field_mode);
  return seed;
}

void SectionAutocomplete::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "section"), this->section,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "html_field_mode"), this->html_field_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SectionAutocomplete::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SectionFieldIdentifier::SectionFieldIdentifier()
    : field_name(),
      local_frame_id(),
      field_renderer_id() {}

SectionFieldIdentifier::SectionFieldIdentifier(
    const std::string& field_name_in,
    uint64_t local_frame_id_in,
    ::autofill::FieldRendererId field_renderer_id_in)
    : field_name(std::move(field_name_in)),
      local_frame_id(std::move(local_frame_id_in)),
      field_renderer_id(std::move(field_renderer_id_in)) {}

SectionFieldIdentifier::~SectionFieldIdentifier() = default;

void SectionFieldIdentifier::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "field_name"), this->field_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "local_frame_id"), this->local_frame_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "field_renderer_id"), this->field_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SectionFieldIdentifier::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Section::Section()
    : field_type_group(),
      prefix() {}

Section::Section(
    uint8_t field_type_group_in,
    SectionPrefixPtr prefix_in)
    : field_type_group(std::move(field_type_group_in)),
      prefix(std::move(prefix_in)) {}

Section::~Section() = default;

void Section::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "field_type_group"), this->field_type_group,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint8_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "prefix"), this->prefix,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type SectionPrefixPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Section::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormFieldData::FormFieldData()
    : label(),
      name(),
      id_attribute(),
      name_attribute(),
      value(),
      form_control_type(),
      autocomplete_attribute(),
      placeholder(),
      css_classes(),
      aria_label(),
      aria_description(),
      unique_renderer_id(),
      host_form_id(),
      properties_mask(),
      form_control_ax_id(),
      max_length(),
      is_autofilled(),
      section(),
      check_status(),
      is_focusable(),
      is_visible(),
      should_autocomplete(),
      role(),
      text_direction(),
      is_enabled(),
      is_readonly(),
      user_input(),
      options(),
      label_source(),
      bounds(),
      datalist_values(),
      datalist_labels(),
      force_override() {}

FormFieldData::FormFieldData(
    const ::std::u16string& label_in,
    const ::std::u16string& name_in,
    const ::std::u16string& id_attribute_in,
    const ::std::u16string& name_attribute_in,
    const ::std::u16string& value_in,
    const std::string& form_control_type_in,
    const std::string& autocomplete_attribute_in,
    const ::std::u16string& placeholder_in,
    const ::std::u16string& css_classes_in,
    const ::std::u16string& aria_label_in,
    const ::std::u16string& aria_description_in,
    ::autofill::FieldRendererId unique_renderer_id_in,
    ::autofill::FormRendererId host_form_id_in,
    uint32_t properties_mask_in,
    int32_t form_control_ax_id_in,
    uint64_t max_length_in,
    bool is_autofilled_in,
    const ::autofill::Section& section_in,
    FormFieldData::CheckStatus check_status_in,
    bool is_focusable_in,
    bool is_visible_in,
    bool should_autocomplete_in,
    FormFieldData::RoleAttribute role_in,
    ::base::i18n::TextDirection text_direction_in,
    bool is_enabled_in,
    bool is_readonly_in,
    const ::std::u16string& user_input_in,
    std::vector<SelectOptionPtr> options_in,
    FormFieldData::LabelSource label_source_in,
    const ::gfx::RectF& bounds_in,
    std::vector<::std::u16string> datalist_values_in,
    std::vector<::std::u16string> datalist_labels_in,
    bool force_override_in)
    : label(std::move(label_in)),
      name(std::move(name_in)),
      id_attribute(std::move(id_attribute_in)),
      name_attribute(std::move(name_attribute_in)),
      value(std::move(value_in)),
      form_control_type(std::move(form_control_type_in)),
      autocomplete_attribute(std::move(autocomplete_attribute_in)),
      placeholder(std::move(placeholder_in)),
      css_classes(std::move(css_classes_in)),
      aria_label(std::move(aria_label_in)),
      aria_description(std::move(aria_description_in)),
      unique_renderer_id(std::move(unique_renderer_id_in)),
      host_form_id(std::move(host_form_id_in)),
      properties_mask(std::move(properties_mask_in)),
      form_control_ax_id(std::move(form_control_ax_id_in)),
      max_length(std::move(max_length_in)),
      is_autofilled(std::move(is_autofilled_in)),
      section(std::move(section_in)),
      check_status(std::move(check_status_in)),
      is_focusable(std::move(is_focusable_in)),
      is_visible(std::move(is_visible_in)),
      should_autocomplete(std::move(should_autocomplete_in)),
      role(std::move(role_in)),
      text_direction(std::move(text_direction_in)),
      is_enabled(std::move(is_enabled_in)),
      is_readonly(std::move(is_readonly_in)),
      user_input(std::move(user_input_in)),
      options(std::move(options_in)),
      label_source(std::move(label_source_in)),
      bounds(std::move(bounds_in)),
      datalist_values(std::move(datalist_values_in)),
      datalist_labels(std::move(datalist_labels_in)),
      force_override(std::move(force_override_in)) {}

FormFieldData::~FormFieldData() = default;

void FormFieldData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id_attribute"), this->id_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name_attribute"), this->name_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "form_control_type"), this->form_control_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "autocomplete_attribute"), this->autocomplete_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "placeholder"), this->placeholder,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "css_classes"), this->css_classes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aria_label"), this->aria_label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aria_description"), this->aria_description,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "unique_renderer_id"), this->unique_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "host_form_id"), this->host_form_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FormRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "properties_mask"), this->properties_mask,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "form_control_ax_id"), this->form_control_ax_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_length"), this->max_length,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_autofilled"), this->is_autofilled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "section"), this->section,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::autofill::Section&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "check_status"), this->check_status,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type FormFieldData::CheckStatus>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_focusable"), this->is_focusable,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_visible"), this->is_visible,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "should_autocomplete"), this->should_autocomplete,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "role"), this->role,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type FormFieldData::RoleAttribute>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "text_direction"), this->text_direction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::i18n::TextDirection>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_enabled"), this->is_enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_readonly"), this->is_readonly,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "user_input"), this->user_input,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "options"), this->options,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<SelectOptionPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "label_source"), this->label_source,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type FormFieldData::LabelSource>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bounds"), this->bounds,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::RectF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "datalist_values"), this->datalist_values,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::std::u16string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "datalist_labels"), this->datalist_labels,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::std::u16string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "force_override"), this->force_override,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FormFieldData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ButtonTitleInfo::ButtonTitleInfo()
    : title(),
      type() {}

ButtonTitleInfo::ButtonTitleInfo(
    const ::std::u16string& title_in,
    ButtonTitleType type_in)
    : title(std::move(title_in)),
      type(std::move(type_in)) {}

ButtonTitleInfo::~ButtonTitleInfo() = default;

void ButtonTitleInfo::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "title"), this->title,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ButtonTitleType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ButtonTitleInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormData::FormData()
    : id_attribute(),
      name_attribute(),
      name(),
      button_titles(),
      action(),
      is_action_empty(),
      is_form_tag(),
      unique_renderer_id(),
      child_frames(),
      submission_event(),
      fields(),
      username_predictions(),
      is_gaia_with_skip_save_password_form() {}

FormData::FormData(
    const ::std::u16string& id_attribute_in,
    const ::std::u16string& name_attribute_in,
    const ::std::u16string& name_in,
    std::vector<ButtonTitleInfoPtr> button_titles_in,
    const ::GURL& action_in,
    bool is_action_empty_in,
    bool is_form_tag_in,
    ::autofill::FormRendererId unique_renderer_id_in,
    std::vector<FrameTokenWithPredecessorPtr> child_frames_in,
    SubmissionIndicatorEvent submission_event_in,
    std::vector<::autofill::FormFieldData> fields_in,
    std::vector<::autofill::FieldRendererId> username_predictions_in,
    bool is_gaia_with_skip_save_password_form_in)
    : id_attribute(std::move(id_attribute_in)),
      name_attribute(std::move(name_attribute_in)),
      name(std::move(name_in)),
      button_titles(std::move(button_titles_in)),
      action(std::move(action_in)),
      is_action_empty(std::move(is_action_empty_in)),
      is_form_tag(std::move(is_form_tag_in)),
      unique_renderer_id(std::move(unique_renderer_id_in)),
      child_frames(std::move(child_frames_in)),
      submission_event(std::move(submission_event_in)),
      fields(std::move(fields_in)),
      username_predictions(std::move(username_predictions_in)),
      is_gaia_with_skip_save_password_form(std::move(is_gaia_with_skip_save_password_form_in)) {}

FormData::~FormData() = default;

void FormData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id_attribute"), this->id_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name_attribute"), this->name_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "button_titles"), this->button_titles,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<ButtonTitleInfoPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "action"), this->action,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_action_empty"), this->is_action_empty,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_form_tag"), this->is_form_tag,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "unique_renderer_id"), this->unique_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FormRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "child_frames"), this->child_frames,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<FrameTokenWithPredecessorPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "submission_event"), this->submission_event,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type SubmissionIndicatorEvent>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "fields"), this->fields,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::autofill::FormFieldData>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "username_predictions"), this->username_predictions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::autofill::FieldRendererId>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_gaia_with_skip_save_password_form"), this->is_gaia_with_skip_save_password_form,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FormData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormFieldDataPredictions::FormFieldDataPredictions()
    : host_form_signature(),
      signature(),
      heuristic_type(),
      server_type(),
      overall_type(),
      parseable_name(),
      section() {}

FormFieldDataPredictions::FormFieldDataPredictions(
    const std::string& host_form_signature_in,
    const std::string& signature_in,
    const std::string& heuristic_type_in,
    const std::string& server_type_in,
    const std::string& overall_type_in,
    const std::string& parseable_name_in,
    const std::string& section_in)
    : host_form_signature(std::move(host_form_signature_in)),
      signature(std::move(signature_in)),
      heuristic_type(std::move(heuristic_type_in)),
      server_type(std::move(server_type_in)),
      overall_type(std::move(overall_type_in)),
      parseable_name(std::move(parseable_name_in)),
      section(std::move(section_in)) {}

FormFieldDataPredictions::~FormFieldDataPredictions() = default;

void FormFieldDataPredictions::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "host_form_signature"), this->host_form_signature,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "signature"), this->signature,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "heuristic_type"), this->heuristic_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "server_type"), this->server_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "overall_type"), this->overall_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "parseable_name"), this->parseable_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "section"), this->section,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FormFieldDataPredictions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FormDataPredictions::FormDataPredictions()
    : data(),
      signature(),
      fields() {}

FormDataPredictions::FormDataPredictions(
    const ::autofill::FormData& data_in,
    const std::string& signature_in,
    std::vector<::autofill::FormFieldDataPredictions> fields_in)
    : data(std::move(data_in)),
      signature(std::move(signature_in)),
      fields(std::move(fields_in)) {}

FormDataPredictions::~FormDataPredictions() = default;

void FormDataPredictions::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::autofill::FormData&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "signature"), this->signature,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "fields"), this->fields,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::autofill::FormFieldDataPredictions>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FormDataPredictions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordAndMetadata::PasswordAndMetadata()
    : username(),
      password(),
      realm(),
      uses_account_store() {}

PasswordAndMetadata::PasswordAndMetadata(
    const ::std::u16string& username_in,
    const ::std::u16string& password_in,
    const std::string& realm_in,
    bool uses_account_store_in)
    : username(std::move(username_in)),
      password(std::move(password_in)),
      realm(std::move(realm_in)),
      uses_account_store(std::move(uses_account_store_in)) {}

PasswordAndMetadata::~PasswordAndMetadata() = default;

void PasswordAndMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "username"), this->username,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "password"), this->password,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "realm"), this->realm,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "uses_account_store"), this->uses_account_store,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PasswordAndMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordFormFillData::PasswordFormFillData()
    : form_renderer_id(),
      url(),
      action(),
      username_field(),
      password_field(),
      username_may_use_prefilled_placeholder(),
      preferred_realm(),
      uses_account_store(),
      additional_logins(),
      wait_for_username() {}

PasswordFormFillData::PasswordFormFillData(
    ::autofill::FormRendererId form_renderer_id_in,
    const ::GURL& url_in,
    const ::GURL& action_in,
    const ::autofill::FormFieldData& username_field_in,
    const ::autofill::FormFieldData& password_field_in,
    bool username_may_use_prefilled_placeholder_in,
    const std::string& preferred_realm_in,
    bool uses_account_store_in,
    std::vector<::autofill::PasswordAndMetadata> additional_logins_in,
    bool wait_for_username_in)
    : form_renderer_id(std::move(form_renderer_id_in)),
      url(std::move(url_in)),
      action(std::move(action_in)),
      username_field(std::move(username_field_in)),
      password_field(std::move(password_field_in)),
      username_may_use_prefilled_placeholder(std::move(username_may_use_prefilled_placeholder_in)),
      preferred_realm(std::move(preferred_realm_in)),
      uses_account_store(std::move(uses_account_store_in)),
      additional_logins(std::move(additional_logins_in)),
      wait_for_username(std::move(wait_for_username_in)) {}

PasswordFormFillData::~PasswordFormFillData() = default;

void PasswordFormFillData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "form_renderer_id"), this->form_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FormRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "action"), this->action,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "username_field"), this->username_field,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::autofill::FormFieldData&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "password_field"), this->password_field,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::autofill::FormFieldData&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "username_may_use_prefilled_placeholder"), this->username_may_use_prefilled_placeholder,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "preferred_realm"), this->preferred_realm,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "uses_account_store"), this->uses_account_store,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "additional_logins"), this->additional_logins,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::autofill::PasswordAndMetadata>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "wait_for_username"), this->wait_for_username,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PasswordFormFillData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordFormGenerationData::PasswordFormGenerationData()
    : new_password_renderer_id(),
      confirmation_password_renderer_id() {}

PasswordFormGenerationData::PasswordFormGenerationData(
    ::autofill::FieldRendererId new_password_renderer_id_in,
    ::autofill::FieldRendererId confirmation_password_renderer_id_in)
    : new_password_renderer_id(std::move(new_password_renderer_id_in)),
      confirmation_password_renderer_id(std::move(confirmation_password_renderer_id_in)) {}

PasswordFormGenerationData::~PasswordFormGenerationData() = default;

void PasswordFormGenerationData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "new_password_renderer_id"), this->new_password_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "confirmation_password_renderer_id"), this->confirmation_password_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PasswordFormGenerationData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PasswordGenerationUIData::PasswordGenerationUIData()
    : bounds(),
      max_length(),
      generation_element(),
      generation_element_id(),
      is_generation_element_password_type(),
      text_direction(),
      form_data() {}

PasswordGenerationUIData::PasswordGenerationUIData(
    const ::gfx::RectF& bounds_in,
    int32_t max_length_in,
    const ::std::u16string& generation_element_in,
    ::autofill::FieldRendererId generation_element_id_in,
    bool is_generation_element_password_type_in,
    ::base::i18n::TextDirection text_direction_in,
    const ::autofill::FormData& form_data_in)
    : bounds(std::move(bounds_in)),
      max_length(std::move(max_length_in)),
      generation_element(std::move(generation_element_in)),
      generation_element_id(std::move(generation_element_id_in)),
      is_generation_element_password_type(std::move(is_generation_element_password_type_in)),
      text_direction(std::move(text_direction_in)),
      form_data(std::move(form_data_in)) {}

PasswordGenerationUIData::~PasswordGenerationUIData() = default;

void PasswordGenerationUIData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bounds"), this->bounds,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::RectF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_length"), this->max_length,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "generation_element"), this->generation_element,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "generation_element_id"), this->generation_element_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_generation_element_password_type"), this->is_generation_element_password_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "text_direction"), this->text_direction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::i18n::TextDirection>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "form_data"), this->form_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::autofill::FormData&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PasswordGenerationUIData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ParsingResult::ParsingResult()
    : username_renderer_id(),
      password_renderer_id(),
      new_password_renderer_id(),
      confirm_password_renderer_id() {}

ParsingResult::ParsingResult(
    ::autofill::FieldRendererId username_renderer_id_in,
    ::autofill::FieldRendererId password_renderer_id_in,
    ::autofill::FieldRendererId new_password_renderer_id_in,
    ::autofill::FieldRendererId confirm_password_renderer_id_in)
    : username_renderer_id(std::move(username_renderer_id_in)),
      password_renderer_id(std::move(password_renderer_id_in)),
      new_password_renderer_id(std::move(new_password_renderer_id_in)),
      confirm_password_renderer_id(std::move(confirm_password_renderer_id_in)) {}

ParsingResult::~ParsingResult() = default;

void ParsingResult::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "username_renderer_id"), this->username_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "password_renderer_id"), this->password_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "new_password_renderer_id"), this->new_password_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "confirm_password_renderer_id"), this->confirm_password_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::autofill::FieldRendererId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ParsingResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
TouchToFillEligible::TouchToFillEligible()
    : eligible() {}

TouchToFillEligible::TouchToFillEligible(
    bool eligible_in)
    : eligible(std::move(eligible_in)) {}

TouchToFillEligible::~TouchToFillEligible() = default;

void TouchToFillEligible::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "eligible"), this->eligible,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool TouchToFillEligible::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SectionPrefix::SectionPrefix() : tag_(Tag::kDefaultPrefix) {
  data_.default_prefix = bool();
}

SectionPrefix::~SectionPrefix() {
  DestroyActive();
}


void SectionPrefix::set_default_prefix(
    bool default_prefix) {
  if (tag_ != Tag::kDefaultPrefix) {
    DestroyActive();
    tag_ = Tag::kDefaultPrefix;
  }
  data_.default_prefix = default_prefix;
}
void SectionPrefix::set_autocomplete_section_prefix(
    SectionAutocompletePtr autocomplete_section_prefix) {
  if (tag_ == Tag::kAutocompleteSectionPrefix) {
    *(data_.autocomplete_section_prefix) = std::move(autocomplete_section_prefix);
  } else {
    DestroyActive();
    tag_ = Tag::kAutocompleteSectionPrefix;
    data_.autocomplete_section_prefix = new SectionAutocompletePtr(
        std::move(autocomplete_section_prefix));
  }
}
void SectionPrefix::set_from_field_prefix(
    SectionFieldIdentifierPtr from_field_prefix) {
  if (tag_ == Tag::kFromFieldPrefix) {
    *(data_.from_field_prefix) = std::move(from_field_prefix);
  } else {
    DestroyActive();
    tag_ = Tag::kFromFieldPrefix;
    data_.from_field_prefix = new SectionFieldIdentifierPtr(
        std::move(from_field_prefix));
  }
}
void SectionPrefix::set_credit_card_prefix(
    bool credit_card_prefix) {
  if (tag_ != Tag::kCreditCardPrefix) {
    DestroyActive();
    tag_ = Tag::kCreditCardPrefix;
  }
  data_.credit_card_prefix = credit_card_prefix;
}

void SectionPrefix::DestroyActive() {
  switch (tag_) {

    case Tag::kDefaultPrefix:

      break;
    case Tag::kAutocompleteSectionPrefix:

      delete data_.autocomplete_section_prefix;
      break;
    case Tag::kFromFieldPrefix:

      delete data_.from_field_prefix;
      break;
    case Tag::kCreditCardPrefix:

      break;
  }
}

bool SectionPrefix::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}


}  // namespace mojom
}  // namespace autofill


namespace mojo {


// static
bool StructTraits<::autofill::mojom::FrameToken::DataView, ::autofill::mojom::FrameTokenPtr>::Read(
    ::autofill::mojom::FrameToken::DataView input,
    ::autofill::mojom::FrameTokenPtr* output) {
  bool success = true;
  ::autofill::mojom::FrameTokenPtr result(::autofill::mojom::FrameToken::New());
  
      if (success && !input.ReadToken(&result->token))
        success = false;
      if (success)
        result->is_local = input.is_local();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FrameTokenWithPredecessor::DataView, ::autofill::mojom::FrameTokenWithPredecessorPtr>::Read(
    ::autofill::mojom::FrameTokenWithPredecessor::DataView input,
    ::autofill::mojom::FrameTokenWithPredecessorPtr* output) {
  bool success = true;
  ::autofill::mojom::FrameTokenWithPredecessorPtr result(::autofill::mojom::FrameTokenWithPredecessor::New());
  
      if (success && !input.ReadToken(&result->token))
        success = false;
      if (success)
        result->predecessor = input.predecessor();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormRendererId::DataView, ::autofill::mojom::FormRendererIdPtr>::Read(
    ::autofill::mojom::FormRendererId::DataView input,
    ::autofill::mojom::FormRendererIdPtr* output) {
  bool success = true;
  ::autofill::mojom::FormRendererIdPtr result(::autofill::mojom::FormRendererId::New());
  
      if (success)
        result->id = input.id();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FieldRendererId::DataView, ::autofill::mojom::FieldRendererIdPtr>::Read(
    ::autofill::mojom::FieldRendererId::DataView input,
    ::autofill::mojom::FieldRendererIdPtr* output) {
  bool success = true;
  ::autofill::mojom::FieldRendererIdPtr result(::autofill::mojom::FieldRendererId::New());
  
      if (success)
        result->id = input.id();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::SelectOption::DataView, ::autofill::mojom::SelectOptionPtr>::Read(
    ::autofill::mojom::SelectOption::DataView input,
    ::autofill::mojom::SelectOptionPtr* output) {
  bool success = true;
  ::autofill::mojom::SelectOptionPtr result(::autofill::mojom::SelectOption::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
      if (success && !input.ReadContent(&result->content))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::SectionAutocomplete::DataView, ::autofill::mojom::SectionAutocompletePtr>::Read(
    ::autofill::mojom::SectionAutocomplete::DataView input,
    ::autofill::mojom::SectionAutocompletePtr* output) {
  bool success = true;
  ::autofill::mojom::SectionAutocompletePtr result(::autofill::mojom::SectionAutocomplete::New());
  
      if (success && !input.ReadSection(&result->section))
        success = false;
      if (success)
        result->html_field_mode = input.html_field_mode();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::SectionFieldIdentifier::DataView, ::autofill::mojom::SectionFieldIdentifierPtr>::Read(
    ::autofill::mojom::SectionFieldIdentifier::DataView input,
    ::autofill::mojom::SectionFieldIdentifierPtr* output) {
  bool success = true;
  ::autofill::mojom::SectionFieldIdentifierPtr result(::autofill::mojom::SectionFieldIdentifier::New());
  
      if (success && !input.ReadFieldName(&result->field_name))
        success = false;
      if (success)
        result->local_frame_id = input.local_frame_id();
      if (success && !input.ReadFieldRendererId(&result->field_renderer_id))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::Section::DataView, ::autofill::mojom::SectionPtr>::Read(
    ::autofill::mojom::Section::DataView input,
    ::autofill::mojom::SectionPtr* output) {
  bool success = true;
  ::autofill::mojom::SectionPtr result(::autofill::mojom::Section::New());
  
      if (success)
        result->field_type_group = input.field_type_group();
      if (success && !input.ReadPrefix(&result->prefix))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormFieldData::DataView, ::autofill::mojom::FormFieldDataPtr>::Read(
    ::autofill::mojom::FormFieldData::DataView input,
    ::autofill::mojom::FormFieldDataPtr* output) {
  bool success = true;
  ::autofill::mojom::FormFieldDataPtr result(::autofill::mojom::FormFieldData::New());
  
      if (success && !input.ReadLabel(&result->label))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadIdAttribute(&result->id_attribute))
        success = false;
      if (success && !input.ReadNameAttribute(&result->name_attribute))
        success = false;
      if (success && !input.ReadValue(&result->value))
        success = false;
      if (success && !input.ReadFormControlType(&result->form_control_type))
        success = false;
      if (success && !input.ReadAutocompleteAttribute(&result->autocomplete_attribute))
        success = false;
      if (success && !input.ReadPlaceholder(&result->placeholder))
        success = false;
      if (success && !input.ReadCssClasses(&result->css_classes))
        success = false;
      if (success && !input.ReadAriaLabel(&result->aria_label))
        success = false;
      if (success && !input.ReadAriaDescription(&result->aria_description))
        success = false;
      if (success && !input.ReadUniqueRendererId(&result->unique_renderer_id))
        success = false;
      if (success && !input.ReadHostFormId(&result->host_form_id))
        success = false;
      if (success)
        result->properties_mask = input.properties_mask();
      if (success)
        result->form_control_ax_id = input.form_control_ax_id();
      if (success)
        result->max_length = input.max_length();
      if (success)
        result->is_autofilled = input.is_autofilled();
      if (success && !input.ReadSection(&result->section))
        success = false;
      if (success && !input.ReadCheckStatus(&result->check_status))
        success = false;
      if (success)
        result->is_focusable = input.is_focusable();
      if (success)
        result->is_visible = input.is_visible();
      if (success)
        result->should_autocomplete = input.should_autocomplete();
      if (success && !input.ReadRole(&result->role))
        success = false;
      if (success && !input.ReadTextDirection(&result->text_direction))
        success = false;
      if (success)
        result->is_enabled = input.is_enabled();
      if (success)
        result->is_readonly = input.is_readonly();
      if (success && !input.ReadUserInput(&result->user_input))
        success = false;
      if (success && !input.ReadOptions(&result->options))
        success = false;
      if (success && !input.ReadLabelSource(&result->label_source))
        success = false;
      if (success && !input.ReadBounds(&result->bounds))
        success = false;
      if (success && !input.ReadDatalistValues(&result->datalist_values))
        success = false;
      if (success && !input.ReadDatalistLabels(&result->datalist_labels))
        success = false;
      if (success)
        result->force_override = input.force_override();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::ButtonTitleInfo::DataView, ::autofill::mojom::ButtonTitleInfoPtr>::Read(
    ::autofill::mojom::ButtonTitleInfo::DataView input,
    ::autofill::mojom::ButtonTitleInfoPtr* output) {
  bool success = true;
  ::autofill::mojom::ButtonTitleInfoPtr result(::autofill::mojom::ButtonTitleInfo::New());
  
      if (success && !input.ReadTitle(&result->title))
        success = false;
      if (success && !input.ReadType(&result->type))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormData::DataView, ::autofill::mojom::FormDataPtr>::Read(
    ::autofill::mojom::FormData::DataView input,
    ::autofill::mojom::FormDataPtr* output) {
  bool success = true;
  ::autofill::mojom::FormDataPtr result(::autofill::mojom::FormData::New());
  
      if (success && !input.ReadIdAttribute(&result->id_attribute))
        success = false;
      if (success && !input.ReadNameAttribute(&result->name_attribute))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadButtonTitles(&result->button_titles))
        success = false;
      if (success && !input.ReadAction(&result->action))
        success = false;
      if (success)
        result->is_action_empty = input.is_action_empty();
      if (success)
        result->is_form_tag = input.is_form_tag();
      if (success && !input.ReadUniqueRendererId(&result->unique_renderer_id))
        success = false;
      if (success && !input.ReadChildFrames(&result->child_frames))
        success = false;
      if (success && !input.ReadSubmissionEvent(&result->submission_event))
        success = false;
      if (success && !input.ReadFields(&result->fields))
        success = false;
      if (success && !input.ReadUsernamePredictions(&result->username_predictions))
        success = false;
      if (success)
        result->is_gaia_with_skip_save_password_form = input.is_gaia_with_skip_save_password_form();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormFieldDataPredictions::DataView, ::autofill::mojom::FormFieldDataPredictionsPtr>::Read(
    ::autofill::mojom::FormFieldDataPredictions::DataView input,
    ::autofill::mojom::FormFieldDataPredictionsPtr* output) {
  bool success = true;
  ::autofill::mojom::FormFieldDataPredictionsPtr result(::autofill::mojom::FormFieldDataPredictions::New());
  
      if (success && !input.ReadHostFormSignature(&result->host_form_signature))
        success = false;
      if (success && !input.ReadSignature(&result->signature))
        success = false;
      if (success && !input.ReadHeuristicType(&result->heuristic_type))
        success = false;
      if (success && !input.ReadServerType(&result->server_type))
        success = false;
      if (success && !input.ReadOverallType(&result->overall_type))
        success = false;
      if (success && !input.ReadParseableName(&result->parseable_name))
        success = false;
      if (success && !input.ReadSection(&result->section))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::FormDataPredictions::DataView, ::autofill::mojom::FormDataPredictionsPtr>::Read(
    ::autofill::mojom::FormDataPredictions::DataView input,
    ::autofill::mojom::FormDataPredictionsPtr* output) {
  bool success = true;
  ::autofill::mojom::FormDataPredictionsPtr result(::autofill::mojom::FormDataPredictions::New());
  
      if (success && !input.ReadData(&result->data))
        success = false;
      if (success && !input.ReadSignature(&result->signature))
        success = false;
      if (success && !input.ReadFields(&result->fields))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordAndMetadata::DataView, ::autofill::mojom::PasswordAndMetadataPtr>::Read(
    ::autofill::mojom::PasswordAndMetadata::DataView input,
    ::autofill::mojom::PasswordAndMetadataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordAndMetadataPtr result(::autofill::mojom::PasswordAndMetadata::New());
  
      if (success && !input.ReadUsername(&result->username))
        success = false;
      if (success && !input.ReadPassword(&result->password))
        success = false;
      if (success && !input.ReadRealm(&result->realm))
        success = false;
      if (success)
        result->uses_account_store = input.uses_account_store();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordFormFillData::DataView, ::autofill::mojom::PasswordFormFillDataPtr>::Read(
    ::autofill::mojom::PasswordFormFillData::DataView input,
    ::autofill::mojom::PasswordFormFillDataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordFormFillDataPtr result(::autofill::mojom::PasswordFormFillData::New());
  
      if (success && !input.ReadFormRendererId(&result->form_renderer_id))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadAction(&result->action))
        success = false;
      if (success && !input.ReadUsernameField(&result->username_field))
        success = false;
      if (success && !input.ReadPasswordField(&result->password_field))
        success = false;
      if (success)
        result->username_may_use_prefilled_placeholder = input.username_may_use_prefilled_placeholder();
      if (success && !input.ReadPreferredRealm(&result->preferred_realm))
        success = false;
      if (success)
        result->uses_account_store = input.uses_account_store();
      if (success && !input.ReadAdditionalLogins(&result->additional_logins))
        success = false;
      if (success)
        result->wait_for_username = input.wait_for_username();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordFormGenerationData::DataView, ::autofill::mojom::PasswordFormGenerationDataPtr>::Read(
    ::autofill::mojom::PasswordFormGenerationData::DataView input,
    ::autofill::mojom::PasswordFormGenerationDataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordFormGenerationDataPtr result(::autofill::mojom::PasswordFormGenerationData::New());
  
      if (success && !input.ReadNewPasswordRendererId(&result->new_password_renderer_id))
        success = false;
      if (success && !input.ReadConfirmationPasswordRendererId(&result->confirmation_password_renderer_id))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::PasswordGenerationUIData::DataView, ::autofill::mojom::PasswordGenerationUIDataPtr>::Read(
    ::autofill::mojom::PasswordGenerationUIData::DataView input,
    ::autofill::mojom::PasswordGenerationUIDataPtr* output) {
  bool success = true;
  ::autofill::mojom::PasswordGenerationUIDataPtr result(::autofill::mojom::PasswordGenerationUIData::New());
  
      if (success && !input.ReadBounds(&result->bounds))
        success = false;
      if (success)
        result->max_length = input.max_length();
      if (success && !input.ReadGenerationElement(&result->generation_element))
        success = false;
      if (success && !input.ReadGenerationElementId(&result->generation_element_id))
        success = false;
      if (success)
        result->is_generation_element_password_type = input.is_generation_element_password_type();
      if (success && !input.ReadTextDirection(&result->text_direction))
        success = false;
      if (success && !input.ReadFormData(&result->form_data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::ParsingResult::DataView, ::autofill::mojom::ParsingResultPtr>::Read(
    ::autofill::mojom::ParsingResult::DataView input,
    ::autofill::mojom::ParsingResultPtr* output) {
  bool success = true;
  ::autofill::mojom::ParsingResultPtr result(::autofill::mojom::ParsingResult::New());
  
      if (success && !input.ReadUsernameRendererId(&result->username_renderer_id))
        success = false;
      if (success && !input.ReadPasswordRendererId(&result->password_renderer_id))
        success = false;
      if (success && !input.ReadNewPasswordRendererId(&result->new_password_renderer_id))
        success = false;
      if (success && !input.ReadConfirmPasswordRendererId(&result->confirm_password_renderer_id))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::autofill::mojom::TouchToFillEligible::DataView, ::autofill::mojom::TouchToFillEligiblePtr>::Read(
    ::autofill::mojom::TouchToFillEligible::DataView input,
    ::autofill::mojom::TouchToFillEligiblePtr* output) {
  bool success = true;
  ::autofill::mojom::TouchToFillEligiblePtr result(::autofill::mojom::TouchToFillEligible::New());
  
      if (success)
        result->eligible = input.eligible();
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::autofill::mojom::SectionPrefix::DataView, ::autofill::mojom::SectionPrefixPtr>::Read(
    ::autofill::mojom::SectionPrefix::DataView input,
    ::autofill::mojom::SectionPrefixPtr* output) {
  using UnionType = ::autofill::mojom::SectionPrefix;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kDefaultPrefix: {
      *output = UnionType::NewDefaultPrefix(input.default_prefix());
      break;
    }
    case Tag::kAutocompleteSectionPrefix: {
      ::autofill::mojom::SectionAutocompletePtr result_autocomplete_section_prefix;
      if (!input.ReadAutocompleteSectionPrefix(&result_autocomplete_section_prefix))
        return false;

      *output = UnionType::NewAutocompleteSectionPrefix(
          std::move(result_autocomplete_section_prefix));
      break;
    }
    case Tag::kFromFieldPrefix: {
      ::autofill::mojom::SectionFieldIdentifierPtr result_from_field_prefix;
      if (!input.ReadFromFieldPrefix(&result_from_field_prefix))
        return false;

      *output = UnionType::NewFromFieldPrefix(
          std::move(result_from_field_prefix));
      break;
    }
    case Tag::kCreditCardPrefix: {
      *output = UnionType::NewCreditCardPrefix(input.credit_card_prefix());
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace autofill {
namespace mojom {




}  // namespace mojom
}  // namespace autofill


#if defined(__clang__)
#pragma clang diagnostic pop
#endif