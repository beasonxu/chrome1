// components/autofill/core/common/mojom/autofill_types.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_H_
#define COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/autofill/core/common/mojom/autofill_types.mojom-shared.h"
#include "components/autofill/core/common/mojom/autofill_types.mojom-forward.h"
#include "mojo/public/mojom/base/text_direction.mojom.h"
#include "mojo/public/mojom/base/time.mojom-forward.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "url/mojom/origin.mojom-forward.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>




#include "components/autofill/core/common/mojom/autofill_types_mojom_traits.h"




namespace autofill {
namespace mojom {







class  FormRendererId {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormRendererId, T>::value>;
  using DataView = FormRendererIdDataView;
  using Data_ = internal::FormRendererId_Data;

  template <typename... Args>
  static FormRendererIdPtr New(Args&&... args) {
    return FormRendererIdPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormRendererIdPtr From(const U& u) {
    return mojo::TypeConverter<FormRendererIdPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormRendererId>::Convert(*this);
  }


  FormRendererId();

  explicit FormRendererId(
      uint64_t id);


  ~FormRendererId();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormRendererIdPtr>
  FormRendererIdPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormRendererId::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FormRendererId::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormRendererId::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormRendererId::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormRendererId_UnserializedMessageContext<
            UserType, FormRendererId::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FormRendererId::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormRendererId::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormRendererId_UnserializedMessageContext<
            UserType, FormRendererId::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormRendererId::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormRendererId::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormRendererId::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormRendererId::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormRendererId::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FieldRendererId {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FieldRendererId, T>::value>;
  using DataView = FieldRendererIdDataView;
  using Data_ = internal::FieldRendererId_Data;

  template <typename... Args>
  static FieldRendererIdPtr New(Args&&... args) {
    return FieldRendererIdPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FieldRendererIdPtr From(const U& u) {
    return mojo::TypeConverter<FieldRendererIdPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FieldRendererId>::Convert(*this);
  }


  FieldRendererId();

  explicit FieldRendererId(
      uint64_t id);


  ~FieldRendererId();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FieldRendererIdPtr>
  FieldRendererIdPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FieldRendererId::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FieldRendererId::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FieldRendererId_UnserializedMessageContext<
            UserType, FieldRendererId::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FieldRendererId::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FieldRendererId::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FieldRendererId_UnserializedMessageContext<
            UserType, FieldRendererId::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FieldRendererId::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  SectionAutocomplete {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SectionAutocomplete, T>::value>;
  using DataView = SectionAutocompleteDataView;
  using Data_ = internal::SectionAutocomplete_Data;

  template <typename... Args>
  static SectionAutocompletePtr New(Args&&... args) {
    return SectionAutocompletePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SectionAutocompletePtr From(const U& u) {
    return mojo::TypeConverter<SectionAutocompletePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SectionAutocomplete>::Convert(*this);
  }


  SectionAutocomplete();

  SectionAutocomplete(
      const std::string& section,
      uint8_t html_field_mode);


  ~SectionAutocomplete();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SectionAutocompletePtr>
  SectionAutocompletePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SectionAutocomplete::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SectionAutocomplete::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SectionAutocomplete::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SectionAutocomplete::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SectionAutocomplete_UnserializedMessageContext<
            UserType, SectionAutocomplete::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SectionAutocomplete::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SectionAutocomplete::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SectionAutocomplete_UnserializedMessageContext<
            UserType, SectionAutocomplete::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SectionAutocomplete::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string section;
  
  uint8_t html_field_mode;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SectionAutocomplete::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SectionAutocomplete::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SectionAutocomplete::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SectionAutocomplete::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

















class  TouchToFillEligible {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<TouchToFillEligible, T>::value>;
  using DataView = TouchToFillEligibleDataView;
  using Data_ = internal::TouchToFillEligible_Data;

  template <typename... Args>
  static TouchToFillEligiblePtr New(Args&&... args) {
    return TouchToFillEligiblePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static TouchToFillEligiblePtr From(const U& u) {
    return mojo::TypeConverter<TouchToFillEligiblePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, TouchToFillEligible>::Convert(*this);
  }


  TouchToFillEligible();

  explicit TouchToFillEligible(
      bool eligible);


  ~TouchToFillEligible();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = TouchToFillEligiblePtr>
  TouchToFillEligiblePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, TouchToFillEligible::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, TouchToFillEligible::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        TouchToFillEligible::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        TouchToFillEligible::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::TouchToFillEligible_UnserializedMessageContext<
            UserType, TouchToFillEligible::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<TouchToFillEligible::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return TouchToFillEligible::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::TouchToFillEligible_UnserializedMessageContext<
            UserType, TouchToFillEligible::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<TouchToFillEligible::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool eligible;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchToFillEligible::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchToFillEligible::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, TouchToFillEligible::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, TouchToFillEligible::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  SectionPrefix {
 public:
  using DataView = SectionPrefixDataView;
  using Data_ = internal::SectionPrefix_Data;
  using Tag = Data_::SectionPrefix_Tag;

  template <typename... Args>
  static SectionPrefixPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |default_prefix|.
  static SectionPrefixPtr
  NewDefaultPrefix(
      bool default_prefix) {
    auto result = SectionPrefixPtr(absl::in_place);
    result->set_default_prefix(std::move(default_prefix));
    return result;
  }
  // Construct an instance holding |autocomplete_section_prefix|.
  static SectionPrefixPtr
  NewAutocompleteSectionPrefix(
      SectionAutocompletePtr autocomplete_section_prefix) {
    auto result = SectionPrefixPtr(absl::in_place);
    result->set_autocomplete_section_prefix(std::move(autocomplete_section_prefix));
    return result;
  }
  // Construct an instance holding |from_field_prefix|.
  static SectionPrefixPtr
  NewFromFieldPrefix(
      SectionFieldIdentifierPtr from_field_prefix) {
    auto result = SectionPrefixPtr(absl::in_place);
    result->set_from_field_prefix(std::move(from_field_prefix));
    return result;
  }
  // Construct an instance holding |credit_card_prefix|.
  static SectionPrefixPtr
  NewCreditCardPrefix(
      bool credit_card_prefix) {
    auto result = SectionPrefixPtr(absl::in_place);
    result->set_credit_card_prefix(std::move(credit_card_prefix));
    return result;
  }

  template <typename U>
  static SectionPrefixPtr From(const U& u) {
    return mojo::TypeConverter<SectionPrefixPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SectionPrefix>::Convert(*this);
  }

  SectionPrefix();
  ~SectionPrefix();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = SectionPrefixPtr>
  SectionPrefixPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, SectionPrefix>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, SectionPrefix>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_default_prefix() const { return tag_ == Tag::kDefaultPrefix; }

  
  bool get_default_prefix() const {
    CHECK(tag_ == Tag::kDefaultPrefix);
    return data_.default_prefix;
  }

  
  void set_default_prefix(
      bool default_prefix);
  
  bool is_autocomplete_section_prefix() const { return tag_ == Tag::kAutocompleteSectionPrefix; }

  
  SectionAutocompletePtr& get_autocomplete_section_prefix() const {
    CHECK(tag_ == Tag::kAutocompleteSectionPrefix);
    return *(data_.autocomplete_section_prefix);
  }

  
  void set_autocomplete_section_prefix(
      SectionAutocompletePtr autocomplete_section_prefix);
  
  bool is_from_field_prefix() const { return tag_ == Tag::kFromFieldPrefix; }

  
  SectionFieldIdentifierPtr& get_from_field_prefix() const {
    CHECK(tag_ == Tag::kFromFieldPrefix);
    return *(data_.from_field_prefix);
  }

  
  void set_from_field_prefix(
      SectionFieldIdentifierPtr from_field_prefix);
  
  bool is_credit_card_prefix() const { return tag_ == Tag::kCreditCardPrefix; }

  
  bool get_credit_card_prefix() const {
    CHECK(tag_ == Tag::kCreditCardPrefix);
    return data_.credit_card_prefix;
  }

  
  void set_credit_card_prefix(
      bool credit_card_prefix);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SectionPrefix::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<SectionPrefix::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    bool default_prefix;
    SectionAutocompletePtr* autocomplete_section_prefix;
    SectionFieldIdentifierPtr* from_field_prefix;
    bool credit_card_prefix;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class  FrameToken {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FrameToken, T>::value>;
  using DataView = FrameTokenDataView;
  using Data_ = internal::FrameToken_Data;

  template <typename... Args>
  static FrameTokenPtr New(Args&&... args) {
    return FrameTokenPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FrameTokenPtr From(const U& u) {
    return mojo::TypeConverter<FrameTokenPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FrameToken>::Convert(*this);
  }


  FrameToken();

  FrameToken(
      const ::base::UnguessableToken& token,
      bool is_local);


  ~FrameToken();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FrameTokenPtr>
  FrameTokenPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FrameToken::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FrameToken::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FrameToken::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FrameToken::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FrameToken_UnserializedMessageContext<
            UserType, FrameToken::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FrameToken::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FrameToken::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FrameToken_UnserializedMessageContext<
            UserType, FrameToken::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FrameToken::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::base::UnguessableToken token;
  
  bool is_local;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FrameToken::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FrameToken::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FrameToken::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FrameToken::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FrameTokenWithPredecessor {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FrameTokenWithPredecessor, T>::value>;
  using DataView = FrameTokenWithPredecessorDataView;
  using Data_ = internal::FrameTokenWithPredecessor_Data;

  template <typename... Args>
  static FrameTokenWithPredecessorPtr New(Args&&... args) {
    return FrameTokenWithPredecessorPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FrameTokenWithPredecessorPtr From(const U& u) {
    return mojo::TypeConverter<FrameTokenWithPredecessorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FrameTokenWithPredecessor>::Convert(*this);
  }


  FrameTokenWithPredecessor();

  FrameTokenWithPredecessor(
      FrameTokenPtr token,
      int32_t predecessor);

FrameTokenWithPredecessor(const FrameTokenWithPredecessor&) = delete;
FrameTokenWithPredecessor& operator=(const FrameTokenWithPredecessor&) = delete;

  ~FrameTokenWithPredecessor();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FrameTokenWithPredecessorPtr>
  FrameTokenWithPredecessorPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FrameTokenWithPredecessor::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FrameTokenWithPredecessor::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FrameTokenWithPredecessor_UnserializedMessageContext<
            UserType, FrameTokenWithPredecessor::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FrameTokenWithPredecessor::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FrameTokenWithPredecessor::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FrameTokenWithPredecessor_UnserializedMessageContext<
            UserType, FrameTokenWithPredecessor::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FrameTokenWithPredecessor::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  FrameTokenPtr token;
  
  int32_t predecessor;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class  SelectOption {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SelectOption, T>::value>;
  using DataView = SelectOptionDataView;
  using Data_ = internal::SelectOption_Data;

  template <typename... Args>
  static SelectOptionPtr New(Args&&... args) {
    return SelectOptionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SelectOptionPtr From(const U& u) {
    return mojo::TypeConverter<SelectOptionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SelectOption>::Convert(*this);
  }


  SelectOption();

  SelectOption(
      const ::std::u16string& value,
      const ::std::u16string& content);


  ~SelectOption();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SelectOptionPtr>
  SelectOptionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SelectOption::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SelectOption::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SelectOption::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SelectOption::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SelectOption_UnserializedMessageContext<
            UserType, SelectOption::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SelectOption::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SelectOption::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SelectOption_UnserializedMessageContext<
            UserType, SelectOption::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SelectOption::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::std::u16string value;
  
  ::std::u16string content;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SelectOption::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SelectOption::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SelectOption::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SelectOption::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  SectionFieldIdentifier {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SectionFieldIdentifier, T>::value>;
  using DataView = SectionFieldIdentifierDataView;
  using Data_ = internal::SectionFieldIdentifier_Data;

  template <typename... Args>
  static SectionFieldIdentifierPtr New(Args&&... args) {
    return SectionFieldIdentifierPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SectionFieldIdentifierPtr From(const U& u) {
    return mojo::TypeConverter<SectionFieldIdentifierPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SectionFieldIdentifier>::Convert(*this);
  }


  SectionFieldIdentifier();

  SectionFieldIdentifier(
      const std::string& field_name,
      uint64_t local_frame_id,
      ::autofill::FieldRendererId field_renderer_id);


  ~SectionFieldIdentifier();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SectionFieldIdentifierPtr>
  SectionFieldIdentifierPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SectionFieldIdentifier::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SectionFieldIdentifier::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SectionFieldIdentifier::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SectionFieldIdentifier::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SectionFieldIdentifier_UnserializedMessageContext<
            UserType, SectionFieldIdentifier::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SectionFieldIdentifier::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SectionFieldIdentifier::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SectionFieldIdentifier_UnserializedMessageContext<
            UserType, SectionFieldIdentifier::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SectionFieldIdentifier::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string field_name;
  
  uint64_t local_frame_id;
  
  ::autofill::FieldRendererId field_renderer_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SectionFieldIdentifier::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SectionFieldIdentifier::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SectionFieldIdentifier::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SectionFieldIdentifier::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Section {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Section, T>::value>;
  using DataView = SectionDataView;
  using Data_ = internal::Section_Data;

  template <typename... Args>
  static SectionPtr New(Args&&... args) {
    return SectionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SectionPtr From(const U& u) {
    return mojo::TypeConverter<SectionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Section>::Convert(*this);
  }


  Section();

  Section(
      uint8_t field_type_group,
      SectionPrefixPtr prefix);

Section(const Section&) = delete;
Section& operator=(const Section&) = delete;

  ~Section();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SectionPtr>
  SectionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Section::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Section::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Section::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Section::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Section_UnserializedMessageContext<
            UserType, Section::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Section::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Section::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Section_UnserializedMessageContext<
            UserType, Section::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Section::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint8_t field_type_group;
  
  SectionPrefixPtr prefix;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Section::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Section::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Section::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Section::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormFieldData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormFieldData, T>::value>;
  using DataView = FormFieldDataDataView;
  using Data_ = internal::FormFieldData_Data;
  using CheckStatus = FormFieldData_CheckStatus;
  using RoleAttribute = FormFieldData_RoleAttribute;
  using LabelSource = FormFieldData_LabelSource;

  template <typename... Args>
  static FormFieldDataPtr New(Args&&... args) {
    return FormFieldDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormFieldDataPtr From(const U& u) {
    return mojo::TypeConverter<FormFieldDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormFieldData>::Convert(*this);
  }


  FormFieldData();

  FormFieldData(
      const ::std::u16string& label,
      const ::std::u16string& name,
      const ::std::u16string& id_attribute,
      const ::std::u16string& name_attribute,
      const ::std::u16string& value,
      const std::string& form_control_type,
      const std::string& autocomplete_attribute,
      const ::std::u16string& placeholder,
      const ::std::u16string& css_classes,
      const ::std::u16string& aria_label,
      const ::std::u16string& aria_description,
      ::autofill::FieldRendererId unique_renderer_id,
      ::autofill::FormRendererId host_form_id,
      uint32_t properties_mask,
      int32_t form_control_ax_id,
      uint64_t max_length,
      bool is_autofilled,
      const ::autofill::Section& section,
      FormFieldData::CheckStatus check_status,
      bool is_focusable,
      bool is_visible,
      bool should_autocomplete,
      FormFieldData::RoleAttribute role,
      ::base::i18n::TextDirection text_direction,
      bool is_enabled,
      bool is_readonly,
      const ::std::u16string& user_input,
      std::vector<SelectOptionPtr> options,
      FormFieldData::LabelSource label_source,
      const ::gfx::RectF& bounds,
      std::vector<::std::u16string> datalist_values,
      std::vector<::std::u16string> datalist_labels,
      bool force_override);

FormFieldData(const FormFieldData&) = delete;
FormFieldData& operator=(const FormFieldData&) = delete;

  ~FormFieldData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormFieldDataPtr>
  FormFieldDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormFieldData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormFieldData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormFieldData_UnserializedMessageContext<
            UserType, FormFieldData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FormFieldData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormFieldData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormFieldData_UnserializedMessageContext<
            UserType, FormFieldData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormFieldData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::std::u16string label;
  
  ::std::u16string name;
  
  ::std::u16string id_attribute;
  
  ::std::u16string name_attribute;
  
  ::std::u16string value;
  
  std::string form_control_type;
  
  std::string autocomplete_attribute;
  
  ::std::u16string placeholder;
  
  ::std::u16string css_classes;
  
  ::std::u16string aria_label;
  
  ::std::u16string aria_description;
  
  ::autofill::FieldRendererId unique_renderer_id;
  
  ::autofill::FormRendererId host_form_id;
  
  uint32_t properties_mask;
  
  int32_t form_control_ax_id;
  
  uint64_t max_length;
  
  bool is_autofilled;
  
  ::autofill::Section section;
  
  FormFieldData::CheckStatus check_status;
  
  bool is_focusable;
  
  bool is_visible;
  
  bool should_autocomplete;
  
  FormFieldData::RoleAttribute role;
  
  ::base::i18n::TextDirection text_direction;
  
  bool is_enabled;
  
  bool is_readonly;
  
  ::std::u16string user_input;
  
  std::vector<SelectOptionPtr> options;
  
  FormFieldData::LabelSource label_source;
  
  ::gfx::RectF bounds;
  
  std::vector<::std::u16string> datalist_values;
  
  std::vector<::std::u16string> datalist_labels;
  
  bool force_override;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormFieldData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ButtonTitleInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ButtonTitleInfo, T>::value>;
  using DataView = ButtonTitleInfoDataView;
  using Data_ = internal::ButtonTitleInfo_Data;

  template <typename... Args>
  static ButtonTitleInfoPtr New(Args&&... args) {
    return ButtonTitleInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ButtonTitleInfoPtr From(const U& u) {
    return mojo::TypeConverter<ButtonTitleInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ButtonTitleInfo>::Convert(*this);
  }


  ButtonTitleInfo();

  ButtonTitleInfo(
      const ::std::u16string& title,
      ButtonTitleType type);


  ~ButtonTitleInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ButtonTitleInfoPtr>
  ButtonTitleInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ButtonTitleInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ButtonTitleInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ButtonTitleInfo_UnserializedMessageContext<
            UserType, ButtonTitleInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ButtonTitleInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ButtonTitleInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ButtonTitleInfo_UnserializedMessageContext<
            UserType, ButtonTitleInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ButtonTitleInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::std::u16string title;
  
  ButtonTitleType type;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormData, T>::value>;
  using DataView = FormDataDataView;
  using Data_ = internal::FormData_Data;

  template <typename... Args>
  static FormDataPtr New(Args&&... args) {
    return FormDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormDataPtr From(const U& u) {
    return mojo::TypeConverter<FormDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormData>::Convert(*this);
  }


  FormData();

  FormData(
      const ::std::u16string& id_attribute,
      const ::std::u16string& name_attribute,
      const ::std::u16string& name,
      std::vector<ButtonTitleInfoPtr> button_titles,
      const ::GURL& action,
      bool is_action_empty,
      bool is_form_tag,
      ::autofill::FormRendererId unique_renderer_id,
      std::vector<FrameTokenWithPredecessorPtr> child_frames,
      SubmissionIndicatorEvent submission_event,
      std::vector<::autofill::FormFieldData> fields,
      std::vector<::autofill::FieldRendererId> username_predictions,
      bool is_gaia_with_skip_save_password_form);

FormData(const FormData&) = delete;
FormData& operator=(const FormData&) = delete;

  ~FormData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormDataPtr>
  FormDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FormData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormData_UnserializedMessageContext<
            UserType, FormData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FormData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormData_UnserializedMessageContext<
            UserType, FormData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::std::u16string id_attribute;
  
  ::std::u16string name_attribute;
  
  ::std::u16string name;
  
  std::vector<ButtonTitleInfoPtr> button_titles;
  
  ::GURL action;
  
  bool is_action_empty;
  
  bool is_form_tag;
  
  ::autofill::FormRendererId unique_renderer_id;
  
  std::vector<FrameTokenWithPredecessorPtr> child_frames;
  
  SubmissionIndicatorEvent submission_event;
  
  std::vector<::autofill::FormFieldData> fields;
  
  std::vector<::autofill::FieldRendererId> username_predictions;
  
  bool is_gaia_with_skip_save_password_form;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormFieldDataPredictions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormFieldDataPredictions, T>::value>;
  using DataView = FormFieldDataPredictionsDataView;
  using Data_ = internal::FormFieldDataPredictions_Data;

  template <typename... Args>
  static FormFieldDataPredictionsPtr New(Args&&... args) {
    return FormFieldDataPredictionsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormFieldDataPredictionsPtr From(const U& u) {
    return mojo::TypeConverter<FormFieldDataPredictionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormFieldDataPredictions>::Convert(*this);
  }


  FormFieldDataPredictions();

  FormFieldDataPredictions(
      const std::string& host_form_signature,
      const std::string& signature,
      const std::string& heuristic_type,
      const std::string& server_type,
      const std::string& overall_type,
      const std::string& parseable_name,
      const std::string& section);


  ~FormFieldDataPredictions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormFieldDataPredictionsPtr>
  FormFieldDataPredictionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormFieldDataPredictions::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormFieldDataPredictions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormFieldDataPredictions_UnserializedMessageContext<
            UserType, FormFieldDataPredictions::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FormFieldDataPredictions::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormFieldDataPredictions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormFieldDataPredictions_UnserializedMessageContext<
            UserType, FormFieldDataPredictions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormFieldDataPredictions::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string host_form_signature;
  
  std::string signature;
  
  std::string heuristic_type;
  
  std::string server_type;
  
  std::string overall_type;
  
  std::string parseable_name;
  
  std::string section;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FormDataPredictions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FormDataPredictions, T>::value>;
  using DataView = FormDataPredictionsDataView;
  using Data_ = internal::FormDataPredictions_Data;

  template <typename... Args>
  static FormDataPredictionsPtr New(Args&&... args) {
    return FormDataPredictionsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FormDataPredictionsPtr From(const U& u) {
    return mojo::TypeConverter<FormDataPredictionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FormDataPredictions>::Convert(*this);
  }


  FormDataPredictions();

  FormDataPredictions(
      const ::autofill::FormData& data,
      const std::string& signature,
      std::vector<::autofill::FormFieldDataPredictions> fields);


  ~FormDataPredictions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FormDataPredictionsPtr>
  FormDataPredictionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FormDataPredictions::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FormDataPredictions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FormDataPredictions_UnserializedMessageContext<
            UserType, FormDataPredictions::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FormDataPredictions::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FormDataPredictions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FormDataPredictions_UnserializedMessageContext<
            UserType, FormDataPredictions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FormDataPredictions::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::autofill::FormData data;
  
  std::string signature;
  
  std::vector<::autofill::FormFieldDataPredictions> fields;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FormDataPredictions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordAndMetadata {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordAndMetadata, T>::value>;
  using DataView = PasswordAndMetadataDataView;
  using Data_ = internal::PasswordAndMetadata_Data;

  template <typename... Args>
  static PasswordAndMetadataPtr New(Args&&... args) {
    return PasswordAndMetadataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordAndMetadataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordAndMetadataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordAndMetadata>::Convert(*this);
  }


  PasswordAndMetadata();

  PasswordAndMetadata(
      const ::std::u16string& username,
      const ::std::u16string& password,
      const std::string& realm,
      bool uses_account_store);


  ~PasswordAndMetadata();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordAndMetadataPtr>
  PasswordAndMetadataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordAndMetadata::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordAndMetadata::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordAndMetadata_UnserializedMessageContext<
            UserType, PasswordAndMetadata::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PasswordAndMetadata::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordAndMetadata::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordAndMetadata_UnserializedMessageContext<
            UserType, PasswordAndMetadata::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordAndMetadata::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::std::u16string username;
  
  ::std::u16string password;
  
  std::string realm;
  
  bool uses_account_store;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordFormFillData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordFormFillData, T>::value>;
  using DataView = PasswordFormFillDataDataView;
  using Data_ = internal::PasswordFormFillData_Data;

  template <typename... Args>
  static PasswordFormFillDataPtr New(Args&&... args) {
    return PasswordFormFillDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordFormFillDataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordFormFillDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordFormFillData>::Convert(*this);
  }


  PasswordFormFillData();

  PasswordFormFillData(
      ::autofill::FormRendererId form_renderer_id,
      const ::GURL& url,
      const ::GURL& action,
      const ::autofill::FormFieldData& username_field,
      const ::autofill::FormFieldData& password_field,
      bool username_may_use_prefilled_placeholder,
      const std::string& preferred_realm,
      bool uses_account_store,
      std::vector<::autofill::PasswordAndMetadata> additional_logins,
      bool wait_for_username);


  ~PasswordFormFillData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordFormFillDataPtr>
  PasswordFormFillDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordFormFillData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordFormFillData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordFormFillData_UnserializedMessageContext<
            UserType, PasswordFormFillData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PasswordFormFillData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordFormFillData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordFormFillData_UnserializedMessageContext<
            UserType, PasswordFormFillData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordFormFillData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::autofill::FormRendererId form_renderer_id;
  
  ::GURL url;
  
  ::GURL action;
  
  ::autofill::FormFieldData username_field;
  
  ::autofill::FormFieldData password_field;
  
  bool username_may_use_prefilled_placeholder;
  
  std::string preferred_realm;
  
  bool uses_account_store;
  
  std::vector<::autofill::PasswordAndMetadata> additional_logins;
  
  bool wait_for_username;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordFormFillData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordFormGenerationData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordFormGenerationData, T>::value>;
  using DataView = PasswordFormGenerationDataDataView;
  using Data_ = internal::PasswordFormGenerationData_Data;

  template <typename... Args>
  static PasswordFormGenerationDataPtr New(Args&&... args) {
    return PasswordFormGenerationDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordFormGenerationDataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordFormGenerationDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordFormGenerationData>::Convert(*this);
  }


  PasswordFormGenerationData();

  PasswordFormGenerationData(
      ::autofill::FieldRendererId new_password_renderer_id,
      ::autofill::FieldRendererId confirmation_password_renderer_id);


  ~PasswordFormGenerationData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordFormGenerationDataPtr>
  PasswordFormGenerationDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordFormGenerationData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordFormGenerationData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordFormGenerationData_UnserializedMessageContext<
            UserType, PasswordFormGenerationData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PasswordFormGenerationData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordFormGenerationData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordFormGenerationData_UnserializedMessageContext<
            UserType, PasswordFormGenerationData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordFormGenerationData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::autofill::FieldRendererId new_password_renderer_id;
  
  ::autofill::FieldRendererId confirmation_password_renderer_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PasswordGenerationUIData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PasswordGenerationUIData, T>::value>;
  using DataView = PasswordGenerationUIDataDataView;
  using Data_ = internal::PasswordGenerationUIData_Data;

  template <typename... Args>
  static PasswordGenerationUIDataPtr New(Args&&... args) {
    return PasswordGenerationUIDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PasswordGenerationUIDataPtr From(const U& u) {
    return mojo::TypeConverter<PasswordGenerationUIDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PasswordGenerationUIData>::Convert(*this);
  }


  PasswordGenerationUIData();

  PasswordGenerationUIData(
      const ::gfx::RectF& bounds,
      int32_t max_length,
      const ::std::u16string& generation_element,
      ::autofill::FieldRendererId generation_element_id,
      bool is_generation_element_password_type,
      ::base::i18n::TextDirection text_direction,
      const ::autofill::FormData& form_data);


  ~PasswordGenerationUIData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PasswordGenerationUIDataPtr>
  PasswordGenerationUIDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PasswordGenerationUIData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PasswordGenerationUIData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PasswordGenerationUIData_UnserializedMessageContext<
            UserType, PasswordGenerationUIData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PasswordGenerationUIData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PasswordGenerationUIData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PasswordGenerationUIData_UnserializedMessageContext<
            UserType, PasswordGenerationUIData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PasswordGenerationUIData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::gfx::RectF bounds;
  
  int32_t max_length;
  
  ::std::u16string generation_element;
  
  ::autofill::FieldRendererId generation_element_id;
  
  bool is_generation_element_password_type;
  
  ::base::i18n::TextDirection text_direction;
  
  ::autofill::FormData form_data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ParsingResult {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ParsingResult, T>::value>;
  using DataView = ParsingResultDataView;
  using Data_ = internal::ParsingResult_Data;

  template <typename... Args>
  static ParsingResultPtr New(Args&&... args) {
    return ParsingResultPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ParsingResultPtr From(const U& u) {
    return mojo::TypeConverter<ParsingResultPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ParsingResult>::Convert(*this);
  }


  ParsingResult();

  ParsingResult(
      ::autofill::FieldRendererId username_renderer_id,
      ::autofill::FieldRendererId password_renderer_id,
      ::autofill::FieldRendererId new_password_renderer_id,
      ::autofill::FieldRendererId confirm_password_renderer_id);


  ~ParsingResult();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ParsingResultPtr>
  ParsingResultPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ParsingResult::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ParsingResult::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ParsingResult_UnserializedMessageContext<
            UserType, ParsingResult::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ParsingResult::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ParsingResult::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ParsingResult_UnserializedMessageContext<
            UserType, ParsingResult::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ParsingResult::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::autofill::FieldRendererId username_renderer_id;
  
  ::autofill::FieldRendererId password_renderer_id;
  
  ::autofill::FieldRendererId new_password_renderer_id;
  
  ::autofill::FieldRendererId confirm_password_renderer_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ParsingResult::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename UnionPtrType>
SectionPrefixPtr SectionPrefix::Clone() const {
  switch (tag_) {
    case Tag::kDefaultPrefix:
      return NewDefaultPrefix(
          mojo::Clone(data_.default_prefix));
    case Tag::kAutocompleteSectionPrefix:
      return NewAutocompleteSectionPrefix(
          mojo::Clone(*data_.autocomplete_section_prefix));
    case Tag::kFromFieldPrefix:
      return NewFromFieldPrefix(
          mojo::Clone(*data_.from_field_prefix));
    case Tag::kCreditCardPrefix:
      return NewCreditCardPrefix(
          mojo::Clone(data_.credit_card_prefix));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, SectionPrefix>::value>::type*>
bool SectionPrefix::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kDefaultPrefix:
      return mojo::Equals(data_.default_prefix, other.data_.default_prefix);
    case Tag::kAutocompleteSectionPrefix:
      return mojo::Equals(*(data_.autocomplete_section_prefix), *(other.data_.autocomplete_section_prefix));
    case Tag::kFromFieldPrefix:
      return mojo::Equals(*(data_.from_field_prefix), *(other.data_.from_field_prefix));
    case Tag::kCreditCardPrefix:
      return mojo::Equals(data_.credit_card_prefix, other.data_.credit_card_prefix);
  }

  return false;
}
template <typename StructPtrType>
FrameTokenPtr FrameToken::Clone() const {
  return New(
      mojo::Clone(token),
      mojo::Clone(is_local)
  );
}

template <typename T, FrameToken::EnableIfSame<T>*>
bool FrameToken::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->token, other_struct.token))
    return false;
  if (!mojo::Equals(this->is_local, other_struct.is_local))
    return false;
  return true;
}

template <typename T, FrameToken::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.token < rhs.token)
    return true;
  if (rhs.token < lhs.token)
    return false;
  if (lhs.is_local < rhs.is_local)
    return true;
  if (rhs.is_local < lhs.is_local)
    return false;
  return false;
}
template <typename StructPtrType>
FrameTokenWithPredecessorPtr FrameTokenWithPredecessor::Clone() const {
  return New(
      mojo::Clone(token),
      mojo::Clone(predecessor)
  );
}

template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>*>
bool FrameTokenWithPredecessor::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->token, other_struct.token))
    return false;
  if (!mojo::Equals(this->predecessor, other_struct.predecessor))
    return false;
  return true;
}

template <typename T, FrameTokenWithPredecessor::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.token < rhs.token)
    return true;
  if (rhs.token < lhs.token)
    return false;
  if (lhs.predecessor < rhs.predecessor)
    return true;
  if (rhs.predecessor < lhs.predecessor)
    return false;
  return false;
}
template <typename StructPtrType>
FormRendererIdPtr FormRendererId::Clone() const {
  return New(
      mojo::Clone(id)
  );
}

template <typename T, FormRendererId::EnableIfSame<T>*>
bool FormRendererId::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  return true;
}

template <typename T, FormRendererId::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  return false;
}
template <typename StructPtrType>
FieldRendererIdPtr FieldRendererId::Clone() const {
  return New(
      mojo::Clone(id)
  );
}

template <typename T, FieldRendererId::EnableIfSame<T>*>
bool FieldRendererId::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  return true;
}

template <typename T, FieldRendererId::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  return false;
}
template <typename StructPtrType>
SelectOptionPtr SelectOption::Clone() const {
  return New(
      mojo::Clone(value),
      mojo::Clone(content)
  );
}

template <typename T, SelectOption::EnableIfSame<T>*>
bool SelectOption::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  if (!mojo::Equals(this->content, other_struct.content))
    return false;
  return true;
}

template <typename T, SelectOption::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  if (lhs.content < rhs.content)
    return true;
  if (rhs.content < lhs.content)
    return false;
  return false;
}
template <typename StructPtrType>
SectionAutocompletePtr SectionAutocomplete::Clone() const {
  return New(
      mojo::Clone(section),
      mojo::Clone(html_field_mode)
  );
}

template <typename T, SectionAutocomplete::EnableIfSame<T>*>
bool SectionAutocomplete::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->section, other_struct.section))
    return false;
  if (!mojo::Equals(this->html_field_mode, other_struct.html_field_mode))
    return false;
  return true;
}

template <typename T, SectionAutocomplete::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.section < rhs.section)
    return true;
  if (rhs.section < lhs.section)
    return false;
  if (lhs.html_field_mode < rhs.html_field_mode)
    return true;
  if (rhs.html_field_mode < lhs.html_field_mode)
    return false;
  return false;
}
template <typename StructPtrType>
SectionFieldIdentifierPtr SectionFieldIdentifier::Clone() const {
  return New(
      mojo::Clone(field_name),
      mojo::Clone(local_frame_id),
      mojo::Clone(field_renderer_id)
  );
}

template <typename T, SectionFieldIdentifier::EnableIfSame<T>*>
bool SectionFieldIdentifier::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->field_name, other_struct.field_name))
    return false;
  if (!mojo::Equals(this->local_frame_id, other_struct.local_frame_id))
    return false;
  if (!mojo::Equals(this->field_renderer_id, other_struct.field_renderer_id))
    return false;
  return true;
}

template <typename T, SectionFieldIdentifier::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.field_name < rhs.field_name)
    return true;
  if (rhs.field_name < lhs.field_name)
    return false;
  if (lhs.local_frame_id < rhs.local_frame_id)
    return true;
  if (rhs.local_frame_id < lhs.local_frame_id)
    return false;
  if (lhs.field_renderer_id < rhs.field_renderer_id)
    return true;
  if (rhs.field_renderer_id < lhs.field_renderer_id)
    return false;
  return false;
}
template <typename StructPtrType>
SectionPtr Section::Clone() const {
  return New(
      mojo::Clone(field_type_group),
      mojo::Clone(prefix)
  );
}

template <typename T, Section::EnableIfSame<T>*>
bool Section::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->field_type_group, other_struct.field_type_group))
    return false;
  if (!mojo::Equals(this->prefix, other_struct.prefix))
    return false;
  return true;
}

template <typename T, Section::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.field_type_group < rhs.field_type_group)
    return true;
  if (rhs.field_type_group < lhs.field_type_group)
    return false;
  if (lhs.prefix < rhs.prefix)
    return true;
  if (rhs.prefix < lhs.prefix)
    return false;
  return false;
}
template <typename StructPtrType>
FormFieldDataPtr FormFieldData::Clone() const {
  return New(
      mojo::Clone(label),
      mojo::Clone(name),
      mojo::Clone(id_attribute),
      mojo::Clone(name_attribute),
      mojo::Clone(value),
      mojo::Clone(form_control_type),
      mojo::Clone(autocomplete_attribute),
      mojo::Clone(placeholder),
      mojo::Clone(css_classes),
      mojo::Clone(aria_label),
      mojo::Clone(aria_description),
      mojo::Clone(unique_renderer_id),
      mojo::Clone(host_form_id),
      mojo::Clone(properties_mask),
      mojo::Clone(form_control_ax_id),
      mojo::Clone(max_length),
      mojo::Clone(is_autofilled),
      mojo::Clone(section),
      mojo::Clone(check_status),
      mojo::Clone(is_focusable),
      mojo::Clone(is_visible),
      mojo::Clone(should_autocomplete),
      mojo::Clone(role),
      mojo::Clone(text_direction),
      mojo::Clone(is_enabled),
      mojo::Clone(is_readonly),
      mojo::Clone(user_input),
      mojo::Clone(options),
      mojo::Clone(label_source),
      mojo::Clone(bounds),
      mojo::Clone(datalist_values),
      mojo::Clone(datalist_labels),
      mojo::Clone(force_override)
  );
}

template <typename T, FormFieldData::EnableIfSame<T>*>
bool FormFieldData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->label, other_struct.label))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->id_attribute, other_struct.id_attribute))
    return false;
  if (!mojo::Equals(this->name_attribute, other_struct.name_attribute))
    return false;
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  if (!mojo::Equals(this->form_control_type, other_struct.form_control_type))
    return false;
  if (!mojo::Equals(this->autocomplete_attribute, other_struct.autocomplete_attribute))
    return false;
  if (!mojo::Equals(this->placeholder, other_struct.placeholder))
    return false;
  if (!mojo::Equals(this->css_classes, other_struct.css_classes))
    return false;
  if (!mojo::Equals(this->aria_label, other_struct.aria_label))
    return false;
  if (!mojo::Equals(this->aria_description, other_struct.aria_description))
    return false;
  if (!mojo::Equals(this->unique_renderer_id, other_struct.unique_renderer_id))
    return false;
  if (!mojo::Equals(this->host_form_id, other_struct.host_form_id))
    return false;
  if (!mojo::Equals(this->properties_mask, other_struct.properties_mask))
    return false;
  if (!mojo::Equals(this->form_control_ax_id, other_struct.form_control_ax_id))
    return false;
  if (!mojo::Equals(this->max_length, other_struct.max_length))
    return false;
  if (!mojo::Equals(this->is_autofilled, other_struct.is_autofilled))
    return false;
  if (!mojo::Equals(this->section, other_struct.section))
    return false;
  if (!mojo::Equals(this->check_status, other_struct.check_status))
    return false;
  if (!mojo::Equals(this->is_focusable, other_struct.is_focusable))
    return false;
  if (!mojo::Equals(this->is_visible, other_struct.is_visible))
    return false;
  if (!mojo::Equals(this->should_autocomplete, other_struct.should_autocomplete))
    return false;
  if (!mojo::Equals(this->role, other_struct.role))
    return false;
  if (!mojo::Equals(this->text_direction, other_struct.text_direction))
    return false;
  if (!mojo::Equals(this->is_enabled, other_struct.is_enabled))
    return false;
  if (!mojo::Equals(this->is_readonly, other_struct.is_readonly))
    return false;
  if (!mojo::Equals(this->user_input, other_struct.user_input))
    return false;
  if (!mojo::Equals(this->options, other_struct.options))
    return false;
  if (!mojo::Equals(this->label_source, other_struct.label_source))
    return false;
  if (!mojo::Equals(this->bounds, other_struct.bounds))
    return false;
  if (!mojo::Equals(this->datalist_values, other_struct.datalist_values))
    return false;
  if (!mojo::Equals(this->datalist_labels, other_struct.datalist_labels))
    return false;
  if (!mojo::Equals(this->force_override, other_struct.force_override))
    return false;
  return true;
}

template <typename T, FormFieldData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.label < rhs.label)
    return true;
  if (rhs.label < lhs.label)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.id_attribute < rhs.id_attribute)
    return true;
  if (rhs.id_attribute < lhs.id_attribute)
    return false;
  if (lhs.name_attribute < rhs.name_attribute)
    return true;
  if (rhs.name_attribute < lhs.name_attribute)
    return false;
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  if (lhs.form_control_type < rhs.form_control_type)
    return true;
  if (rhs.form_control_type < lhs.form_control_type)
    return false;
  if (lhs.autocomplete_attribute < rhs.autocomplete_attribute)
    return true;
  if (rhs.autocomplete_attribute < lhs.autocomplete_attribute)
    return false;
  if (lhs.placeholder < rhs.placeholder)
    return true;
  if (rhs.placeholder < lhs.placeholder)
    return false;
  if (lhs.css_classes < rhs.css_classes)
    return true;
  if (rhs.css_classes < lhs.css_classes)
    return false;
  if (lhs.aria_label < rhs.aria_label)
    return true;
  if (rhs.aria_label < lhs.aria_label)
    return false;
  if (lhs.aria_description < rhs.aria_description)
    return true;
  if (rhs.aria_description < lhs.aria_description)
    return false;
  if (lhs.unique_renderer_id < rhs.unique_renderer_id)
    return true;
  if (rhs.unique_renderer_id < lhs.unique_renderer_id)
    return false;
  if (lhs.host_form_id < rhs.host_form_id)
    return true;
  if (rhs.host_form_id < lhs.host_form_id)
    return false;
  if (lhs.properties_mask < rhs.properties_mask)
    return true;
  if (rhs.properties_mask < lhs.properties_mask)
    return false;
  if (lhs.form_control_ax_id < rhs.form_control_ax_id)
    return true;
  if (rhs.form_control_ax_id < lhs.form_control_ax_id)
    return false;
  if (lhs.max_length < rhs.max_length)
    return true;
  if (rhs.max_length < lhs.max_length)
    return false;
  if (lhs.is_autofilled < rhs.is_autofilled)
    return true;
  if (rhs.is_autofilled < lhs.is_autofilled)
    return false;
  if (lhs.section < rhs.section)
    return true;
  if (rhs.section < lhs.section)
    return false;
  if (lhs.check_status < rhs.check_status)
    return true;
  if (rhs.check_status < lhs.check_status)
    return false;
  if (lhs.is_focusable < rhs.is_focusable)
    return true;
  if (rhs.is_focusable < lhs.is_focusable)
    return false;
  if (lhs.is_visible < rhs.is_visible)
    return true;
  if (rhs.is_visible < lhs.is_visible)
    return false;
  if (lhs.should_autocomplete < rhs.should_autocomplete)
    return true;
  if (rhs.should_autocomplete < lhs.should_autocomplete)
    return false;
  if (lhs.role < rhs.role)
    return true;
  if (rhs.role < lhs.role)
    return false;
  if (lhs.text_direction < rhs.text_direction)
    return true;
  if (rhs.text_direction < lhs.text_direction)
    return false;
  if (lhs.is_enabled < rhs.is_enabled)
    return true;
  if (rhs.is_enabled < lhs.is_enabled)
    return false;
  if (lhs.is_readonly < rhs.is_readonly)
    return true;
  if (rhs.is_readonly < lhs.is_readonly)
    return false;
  if (lhs.user_input < rhs.user_input)
    return true;
  if (rhs.user_input < lhs.user_input)
    return false;
  if (lhs.options < rhs.options)
    return true;
  if (rhs.options < lhs.options)
    return false;
  if (lhs.label_source < rhs.label_source)
    return true;
  if (rhs.label_source < lhs.label_source)
    return false;
  if (lhs.bounds < rhs.bounds)
    return true;
  if (rhs.bounds < lhs.bounds)
    return false;
  if (lhs.datalist_values < rhs.datalist_values)
    return true;
  if (rhs.datalist_values < lhs.datalist_values)
    return false;
  if (lhs.datalist_labels < rhs.datalist_labels)
    return true;
  if (rhs.datalist_labels < lhs.datalist_labels)
    return false;
  if (lhs.force_override < rhs.force_override)
    return true;
  if (rhs.force_override < lhs.force_override)
    return false;
  return false;
}
template <typename StructPtrType>
ButtonTitleInfoPtr ButtonTitleInfo::Clone() const {
  return New(
      mojo::Clone(title),
      mojo::Clone(type)
  );
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>*>
bool ButtonTitleInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  return true;
}

template <typename T, ButtonTitleInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  return false;
}
template <typename StructPtrType>
FormDataPtr FormData::Clone() const {
  return New(
      mojo::Clone(id_attribute),
      mojo::Clone(name_attribute),
      mojo::Clone(name),
      mojo::Clone(button_titles),
      mojo::Clone(action),
      mojo::Clone(is_action_empty),
      mojo::Clone(is_form_tag),
      mojo::Clone(unique_renderer_id),
      mojo::Clone(child_frames),
      mojo::Clone(submission_event),
      mojo::Clone(fields),
      mojo::Clone(username_predictions),
      mojo::Clone(is_gaia_with_skip_save_password_form)
  );
}

template <typename T, FormData::EnableIfSame<T>*>
bool FormData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id_attribute, other_struct.id_attribute))
    return false;
  if (!mojo::Equals(this->name_attribute, other_struct.name_attribute))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->button_titles, other_struct.button_titles))
    return false;
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->is_action_empty, other_struct.is_action_empty))
    return false;
  if (!mojo::Equals(this->is_form_tag, other_struct.is_form_tag))
    return false;
  if (!mojo::Equals(this->unique_renderer_id, other_struct.unique_renderer_id))
    return false;
  if (!mojo::Equals(this->child_frames, other_struct.child_frames))
    return false;
  if (!mojo::Equals(this->submission_event, other_struct.submission_event))
    return false;
  if (!mojo::Equals(this->fields, other_struct.fields))
    return false;
  if (!mojo::Equals(this->username_predictions, other_struct.username_predictions))
    return false;
  if (!mojo::Equals(this->is_gaia_with_skip_save_password_form, other_struct.is_gaia_with_skip_save_password_form))
    return false;
  return true;
}

template <typename T, FormData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id_attribute < rhs.id_attribute)
    return true;
  if (rhs.id_attribute < lhs.id_attribute)
    return false;
  if (lhs.name_attribute < rhs.name_attribute)
    return true;
  if (rhs.name_attribute < lhs.name_attribute)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.button_titles < rhs.button_titles)
    return true;
  if (rhs.button_titles < lhs.button_titles)
    return false;
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.is_action_empty < rhs.is_action_empty)
    return true;
  if (rhs.is_action_empty < lhs.is_action_empty)
    return false;
  if (lhs.is_form_tag < rhs.is_form_tag)
    return true;
  if (rhs.is_form_tag < lhs.is_form_tag)
    return false;
  if (lhs.unique_renderer_id < rhs.unique_renderer_id)
    return true;
  if (rhs.unique_renderer_id < lhs.unique_renderer_id)
    return false;
  if (lhs.child_frames < rhs.child_frames)
    return true;
  if (rhs.child_frames < lhs.child_frames)
    return false;
  if (lhs.submission_event < rhs.submission_event)
    return true;
  if (rhs.submission_event < lhs.submission_event)
    return false;
  if (lhs.fields < rhs.fields)
    return true;
  if (rhs.fields < lhs.fields)
    return false;
  if (lhs.username_predictions < rhs.username_predictions)
    return true;
  if (rhs.username_predictions < lhs.username_predictions)
    return false;
  if (lhs.is_gaia_with_skip_save_password_form < rhs.is_gaia_with_skip_save_password_form)
    return true;
  if (rhs.is_gaia_with_skip_save_password_form < lhs.is_gaia_with_skip_save_password_form)
    return false;
  return false;
}
template <typename StructPtrType>
FormFieldDataPredictionsPtr FormFieldDataPredictions::Clone() const {
  return New(
      mojo::Clone(host_form_signature),
      mojo::Clone(signature),
      mojo::Clone(heuristic_type),
      mojo::Clone(server_type),
      mojo::Clone(overall_type),
      mojo::Clone(parseable_name),
      mojo::Clone(section)
  );
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>*>
bool FormFieldDataPredictions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->host_form_signature, other_struct.host_form_signature))
    return false;
  if (!mojo::Equals(this->signature, other_struct.signature))
    return false;
  if (!mojo::Equals(this->heuristic_type, other_struct.heuristic_type))
    return false;
  if (!mojo::Equals(this->server_type, other_struct.server_type))
    return false;
  if (!mojo::Equals(this->overall_type, other_struct.overall_type))
    return false;
  if (!mojo::Equals(this->parseable_name, other_struct.parseable_name))
    return false;
  if (!mojo::Equals(this->section, other_struct.section))
    return false;
  return true;
}

template <typename T, FormFieldDataPredictions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.host_form_signature < rhs.host_form_signature)
    return true;
  if (rhs.host_form_signature < lhs.host_form_signature)
    return false;
  if (lhs.signature < rhs.signature)
    return true;
  if (rhs.signature < lhs.signature)
    return false;
  if (lhs.heuristic_type < rhs.heuristic_type)
    return true;
  if (rhs.heuristic_type < lhs.heuristic_type)
    return false;
  if (lhs.server_type < rhs.server_type)
    return true;
  if (rhs.server_type < lhs.server_type)
    return false;
  if (lhs.overall_type < rhs.overall_type)
    return true;
  if (rhs.overall_type < lhs.overall_type)
    return false;
  if (lhs.parseable_name < rhs.parseable_name)
    return true;
  if (rhs.parseable_name < lhs.parseable_name)
    return false;
  if (lhs.section < rhs.section)
    return true;
  if (rhs.section < lhs.section)
    return false;
  return false;
}
template <typename StructPtrType>
FormDataPredictionsPtr FormDataPredictions::Clone() const {
  return New(
      mojo::Clone(data),
      mojo::Clone(signature),
      mojo::Clone(fields)
  );
}

template <typename T, FormDataPredictions::EnableIfSame<T>*>
bool FormDataPredictions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->signature, other_struct.signature))
    return false;
  if (!mojo::Equals(this->fields, other_struct.fields))
    return false;
  return true;
}

template <typename T, FormDataPredictions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.signature < rhs.signature)
    return true;
  if (rhs.signature < lhs.signature)
    return false;
  if (lhs.fields < rhs.fields)
    return true;
  if (rhs.fields < lhs.fields)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordAndMetadataPtr PasswordAndMetadata::Clone() const {
  return New(
      mojo::Clone(username),
      mojo::Clone(password),
      mojo::Clone(realm),
      mojo::Clone(uses_account_store)
  );
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>*>
bool PasswordAndMetadata::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->username, other_struct.username))
    return false;
  if (!mojo::Equals(this->password, other_struct.password))
    return false;
  if (!mojo::Equals(this->realm, other_struct.realm))
    return false;
  if (!mojo::Equals(this->uses_account_store, other_struct.uses_account_store))
    return false;
  return true;
}

template <typename T, PasswordAndMetadata::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.username < rhs.username)
    return true;
  if (rhs.username < lhs.username)
    return false;
  if (lhs.password < rhs.password)
    return true;
  if (rhs.password < lhs.password)
    return false;
  if (lhs.realm < rhs.realm)
    return true;
  if (rhs.realm < lhs.realm)
    return false;
  if (lhs.uses_account_store < rhs.uses_account_store)
    return true;
  if (rhs.uses_account_store < lhs.uses_account_store)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordFormFillDataPtr PasswordFormFillData::Clone() const {
  return New(
      mojo::Clone(form_renderer_id),
      mojo::Clone(url),
      mojo::Clone(action),
      mojo::Clone(username_field),
      mojo::Clone(password_field),
      mojo::Clone(username_may_use_prefilled_placeholder),
      mojo::Clone(preferred_realm),
      mojo::Clone(uses_account_store),
      mojo::Clone(additional_logins),
      mojo::Clone(wait_for_username)
  );
}

template <typename T, PasswordFormFillData::EnableIfSame<T>*>
bool PasswordFormFillData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->form_renderer_id, other_struct.form_renderer_id))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->username_field, other_struct.username_field))
    return false;
  if (!mojo::Equals(this->password_field, other_struct.password_field))
    return false;
  if (!mojo::Equals(this->username_may_use_prefilled_placeholder, other_struct.username_may_use_prefilled_placeholder))
    return false;
  if (!mojo::Equals(this->preferred_realm, other_struct.preferred_realm))
    return false;
  if (!mojo::Equals(this->uses_account_store, other_struct.uses_account_store))
    return false;
  if (!mojo::Equals(this->additional_logins, other_struct.additional_logins))
    return false;
  if (!mojo::Equals(this->wait_for_username, other_struct.wait_for_username))
    return false;
  return true;
}

template <typename T, PasswordFormFillData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.form_renderer_id < rhs.form_renderer_id)
    return true;
  if (rhs.form_renderer_id < lhs.form_renderer_id)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.username_field < rhs.username_field)
    return true;
  if (rhs.username_field < lhs.username_field)
    return false;
  if (lhs.password_field < rhs.password_field)
    return true;
  if (rhs.password_field < lhs.password_field)
    return false;
  if (lhs.username_may_use_prefilled_placeholder < rhs.username_may_use_prefilled_placeholder)
    return true;
  if (rhs.username_may_use_prefilled_placeholder < lhs.username_may_use_prefilled_placeholder)
    return false;
  if (lhs.preferred_realm < rhs.preferred_realm)
    return true;
  if (rhs.preferred_realm < lhs.preferred_realm)
    return false;
  if (lhs.uses_account_store < rhs.uses_account_store)
    return true;
  if (rhs.uses_account_store < lhs.uses_account_store)
    return false;
  if (lhs.additional_logins < rhs.additional_logins)
    return true;
  if (rhs.additional_logins < lhs.additional_logins)
    return false;
  if (lhs.wait_for_username < rhs.wait_for_username)
    return true;
  if (rhs.wait_for_username < lhs.wait_for_username)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordFormGenerationDataPtr PasswordFormGenerationData::Clone() const {
  return New(
      mojo::Clone(new_password_renderer_id),
      mojo::Clone(confirmation_password_renderer_id)
  );
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>*>
bool PasswordFormGenerationData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->new_password_renderer_id, other_struct.new_password_renderer_id))
    return false;
  if (!mojo::Equals(this->confirmation_password_renderer_id, other_struct.confirmation_password_renderer_id))
    return false;
  return true;
}

template <typename T, PasswordFormGenerationData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.new_password_renderer_id < rhs.new_password_renderer_id)
    return true;
  if (rhs.new_password_renderer_id < lhs.new_password_renderer_id)
    return false;
  if (lhs.confirmation_password_renderer_id < rhs.confirmation_password_renderer_id)
    return true;
  if (rhs.confirmation_password_renderer_id < lhs.confirmation_password_renderer_id)
    return false;
  return false;
}
template <typename StructPtrType>
PasswordGenerationUIDataPtr PasswordGenerationUIData::Clone() const {
  return New(
      mojo::Clone(bounds),
      mojo::Clone(max_length),
      mojo::Clone(generation_element),
      mojo::Clone(generation_element_id),
      mojo::Clone(is_generation_element_password_type),
      mojo::Clone(text_direction),
      mojo::Clone(form_data)
  );
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>*>
bool PasswordGenerationUIData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->bounds, other_struct.bounds))
    return false;
  if (!mojo::Equals(this->max_length, other_struct.max_length))
    return false;
  if (!mojo::Equals(this->generation_element, other_struct.generation_element))
    return false;
  if (!mojo::Equals(this->generation_element_id, other_struct.generation_element_id))
    return false;
  if (!mojo::Equals(this->is_generation_element_password_type, other_struct.is_generation_element_password_type))
    return false;
  if (!mojo::Equals(this->text_direction, other_struct.text_direction))
    return false;
  if (!mojo::Equals(this->form_data, other_struct.form_data))
    return false;
  return true;
}

template <typename T, PasswordGenerationUIData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.bounds < rhs.bounds)
    return true;
  if (rhs.bounds < lhs.bounds)
    return false;
  if (lhs.max_length < rhs.max_length)
    return true;
  if (rhs.max_length < lhs.max_length)
    return false;
  if (lhs.generation_element < rhs.generation_element)
    return true;
  if (rhs.generation_element < lhs.generation_element)
    return false;
  if (lhs.generation_element_id < rhs.generation_element_id)
    return true;
  if (rhs.generation_element_id < lhs.generation_element_id)
    return false;
  if (lhs.is_generation_element_password_type < rhs.is_generation_element_password_type)
    return true;
  if (rhs.is_generation_element_password_type < lhs.is_generation_element_password_type)
    return false;
  if (lhs.text_direction < rhs.text_direction)
    return true;
  if (rhs.text_direction < lhs.text_direction)
    return false;
  if (lhs.form_data < rhs.form_data)
    return true;
  if (rhs.form_data < lhs.form_data)
    return false;
  return false;
}
template <typename StructPtrType>
ParsingResultPtr ParsingResult::Clone() const {
  return New(
      mojo::Clone(username_renderer_id),
      mojo::Clone(password_renderer_id),
      mojo::Clone(new_password_renderer_id),
      mojo::Clone(confirm_password_renderer_id)
  );
}

template <typename T, ParsingResult::EnableIfSame<T>*>
bool ParsingResult::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->username_renderer_id, other_struct.username_renderer_id))
    return false;
  if (!mojo::Equals(this->password_renderer_id, other_struct.password_renderer_id))
    return false;
  if (!mojo::Equals(this->new_password_renderer_id, other_struct.new_password_renderer_id))
    return false;
  if (!mojo::Equals(this->confirm_password_renderer_id, other_struct.confirm_password_renderer_id))
    return false;
  return true;
}

template <typename T, ParsingResult::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.username_renderer_id < rhs.username_renderer_id)
    return true;
  if (rhs.username_renderer_id < lhs.username_renderer_id)
    return false;
  if (lhs.password_renderer_id < rhs.password_renderer_id)
    return true;
  if (rhs.password_renderer_id < lhs.password_renderer_id)
    return false;
  if (lhs.new_password_renderer_id < rhs.new_password_renderer_id)
    return true;
  if (rhs.new_password_renderer_id < lhs.new_password_renderer_id)
    return false;
  if (lhs.confirm_password_renderer_id < rhs.confirm_password_renderer_id)
    return true;
  if (rhs.confirm_password_renderer_id < lhs.confirm_password_renderer_id)
    return false;
  return false;
}
template <typename StructPtrType>
TouchToFillEligiblePtr TouchToFillEligible::Clone() const {
  return New(
      mojo::Clone(eligible)
  );
}

template <typename T, TouchToFillEligible::EnableIfSame<T>*>
bool TouchToFillEligible::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->eligible, other_struct.eligible))
    return false;
  return true;
}

template <typename T, TouchToFillEligible::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.eligible < rhs.eligible)
    return true;
  if (rhs.eligible < lhs.eligible)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace autofill

namespace mojo {


template <>
struct  StructTraits<::autofill::mojom::FrameToken::DataView,
                                         ::autofill::mojom::FrameTokenPtr> {
  static bool IsNull(const ::autofill::mojom::FrameTokenPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FrameTokenPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FrameToken::token)& token(
      const ::autofill::mojom::FrameTokenPtr& input) {
    return input->token;
  }

  static decltype(::autofill::mojom::FrameToken::is_local) is_local(
      const ::autofill::mojom::FrameTokenPtr& input) {
    return input->is_local;
  }

  static bool Read(::autofill::mojom::FrameToken::DataView input, ::autofill::mojom::FrameTokenPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FrameTokenWithPredecessor::DataView,
                                         ::autofill::mojom::FrameTokenWithPredecessorPtr> {
  static bool IsNull(const ::autofill::mojom::FrameTokenWithPredecessorPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FrameTokenWithPredecessorPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FrameTokenWithPredecessor::token)& token(
      const ::autofill::mojom::FrameTokenWithPredecessorPtr& input) {
    return input->token;
  }

  static decltype(::autofill::mojom::FrameTokenWithPredecessor::predecessor) predecessor(
      const ::autofill::mojom::FrameTokenWithPredecessorPtr& input) {
    return input->predecessor;
  }

  static bool Read(::autofill::mojom::FrameTokenWithPredecessor::DataView input, ::autofill::mojom::FrameTokenWithPredecessorPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormRendererId::DataView,
                                         ::autofill::mojom::FormRendererIdPtr> {
  static bool IsNull(const ::autofill::mojom::FormRendererIdPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormRendererIdPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::FormRendererId::id) id(
      const ::autofill::mojom::FormRendererIdPtr& input) {
    return input->id;
  }

  static bool Read(::autofill::mojom::FormRendererId::DataView input, ::autofill::mojom::FormRendererIdPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FieldRendererId::DataView,
                                         ::autofill::mojom::FieldRendererIdPtr> {
  static bool IsNull(const ::autofill::mojom::FieldRendererIdPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FieldRendererIdPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::FieldRendererId::id) id(
      const ::autofill::mojom::FieldRendererIdPtr& input) {
    return input->id;
  }

  static bool Read(::autofill::mojom::FieldRendererId::DataView input, ::autofill::mojom::FieldRendererIdPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::SelectOption::DataView,
                                         ::autofill::mojom::SelectOptionPtr> {
  static bool IsNull(const ::autofill::mojom::SelectOptionPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::SelectOptionPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::SelectOption::value)& value(
      const ::autofill::mojom::SelectOptionPtr& input) {
    return input->value;
  }

  static const decltype(::autofill::mojom::SelectOption::content)& content(
      const ::autofill::mojom::SelectOptionPtr& input) {
    return input->content;
  }

  static bool Read(::autofill::mojom::SelectOption::DataView input, ::autofill::mojom::SelectOptionPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::SectionAutocomplete::DataView,
                                         ::autofill::mojom::SectionAutocompletePtr> {
  static bool IsNull(const ::autofill::mojom::SectionAutocompletePtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::SectionAutocompletePtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::SectionAutocomplete::section)& section(
      const ::autofill::mojom::SectionAutocompletePtr& input) {
    return input->section;
  }

  static decltype(::autofill::mojom::SectionAutocomplete::html_field_mode) html_field_mode(
      const ::autofill::mojom::SectionAutocompletePtr& input) {
    return input->html_field_mode;
  }

  static bool Read(::autofill::mojom::SectionAutocomplete::DataView input, ::autofill::mojom::SectionAutocompletePtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::SectionFieldIdentifier::DataView,
                                         ::autofill::mojom::SectionFieldIdentifierPtr> {
  static bool IsNull(const ::autofill::mojom::SectionFieldIdentifierPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::SectionFieldIdentifierPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::SectionFieldIdentifier::field_name)& field_name(
      const ::autofill::mojom::SectionFieldIdentifierPtr& input) {
    return input->field_name;
  }

  static decltype(::autofill::mojom::SectionFieldIdentifier::local_frame_id) local_frame_id(
      const ::autofill::mojom::SectionFieldIdentifierPtr& input) {
    return input->local_frame_id;
  }

  static const decltype(::autofill::mojom::SectionFieldIdentifier::field_renderer_id)& field_renderer_id(
      const ::autofill::mojom::SectionFieldIdentifierPtr& input) {
    return input->field_renderer_id;
  }

  static bool Read(::autofill::mojom::SectionFieldIdentifier::DataView input, ::autofill::mojom::SectionFieldIdentifierPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::Section::DataView,
                                         ::autofill::mojom::SectionPtr> {
  static bool IsNull(const ::autofill::mojom::SectionPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::SectionPtr* output) { output->reset(); }

  static decltype(::autofill::mojom::Section::field_type_group) field_type_group(
      const ::autofill::mojom::SectionPtr& input) {
    return input->field_type_group;
  }

  static const decltype(::autofill::mojom::Section::prefix)& prefix(
      const ::autofill::mojom::SectionPtr& input) {
    return input->prefix;
  }

  static bool Read(::autofill::mojom::Section::DataView input, ::autofill::mojom::SectionPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormFieldData::DataView,
                                         ::autofill::mojom::FormFieldDataPtr> {
  static bool IsNull(const ::autofill::mojom::FormFieldDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormFieldDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormFieldData::label)& label(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->label;
  }

  static const decltype(::autofill::mojom::FormFieldData::name)& name(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->name;
  }

  static const decltype(::autofill::mojom::FormFieldData::id_attribute)& id_attribute(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->id_attribute;
  }

  static const decltype(::autofill::mojom::FormFieldData::name_attribute)& name_attribute(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->name_attribute;
  }

  static const decltype(::autofill::mojom::FormFieldData::value)& value(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->value;
  }

  static const decltype(::autofill::mojom::FormFieldData::form_control_type)& form_control_type(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->form_control_type;
  }

  static const decltype(::autofill::mojom::FormFieldData::autocomplete_attribute)& autocomplete_attribute(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->autocomplete_attribute;
  }

  static const decltype(::autofill::mojom::FormFieldData::placeholder)& placeholder(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->placeholder;
  }

  static const decltype(::autofill::mojom::FormFieldData::css_classes)& css_classes(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->css_classes;
  }

  static const decltype(::autofill::mojom::FormFieldData::aria_label)& aria_label(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->aria_label;
  }

  static const decltype(::autofill::mojom::FormFieldData::aria_description)& aria_description(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->aria_description;
  }

  static const decltype(::autofill::mojom::FormFieldData::unique_renderer_id)& unique_renderer_id(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->unique_renderer_id;
  }

  static const decltype(::autofill::mojom::FormFieldData::host_form_id)& host_form_id(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->host_form_id;
  }

  static decltype(::autofill::mojom::FormFieldData::properties_mask) properties_mask(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->properties_mask;
  }

  static decltype(::autofill::mojom::FormFieldData::form_control_ax_id) form_control_ax_id(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->form_control_ax_id;
  }

  static decltype(::autofill::mojom::FormFieldData::max_length) max_length(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->max_length;
  }

  static decltype(::autofill::mojom::FormFieldData::is_autofilled) is_autofilled(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_autofilled;
  }

  static const decltype(::autofill::mojom::FormFieldData::section)& section(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->section;
  }

  static decltype(::autofill::mojom::FormFieldData::check_status) check_status(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->check_status;
  }

  static decltype(::autofill::mojom::FormFieldData::is_focusable) is_focusable(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_focusable;
  }

  static decltype(::autofill::mojom::FormFieldData::is_visible) is_visible(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_visible;
  }

  static decltype(::autofill::mojom::FormFieldData::should_autocomplete) should_autocomplete(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->should_autocomplete;
  }

  static decltype(::autofill::mojom::FormFieldData::role) role(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->role;
  }

  static decltype(::autofill::mojom::FormFieldData::text_direction) text_direction(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->text_direction;
  }

  static decltype(::autofill::mojom::FormFieldData::is_enabled) is_enabled(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_enabled;
  }

  static decltype(::autofill::mojom::FormFieldData::is_readonly) is_readonly(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->is_readonly;
  }

  static const decltype(::autofill::mojom::FormFieldData::user_input)& user_input(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->user_input;
  }

  static const decltype(::autofill::mojom::FormFieldData::options)& options(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->options;
  }

  static decltype(::autofill::mojom::FormFieldData::label_source) label_source(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->label_source;
  }

  static const decltype(::autofill::mojom::FormFieldData::bounds)& bounds(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->bounds;
  }

  static const decltype(::autofill::mojom::FormFieldData::datalist_values)& datalist_values(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->datalist_values;
  }

  static const decltype(::autofill::mojom::FormFieldData::datalist_labels)& datalist_labels(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->datalist_labels;
  }

  static decltype(::autofill::mojom::FormFieldData::force_override) force_override(
      const ::autofill::mojom::FormFieldDataPtr& input) {
    return input->force_override;
  }

  static bool Read(::autofill::mojom::FormFieldData::DataView input, ::autofill::mojom::FormFieldDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::ButtonTitleInfo::DataView,
                                         ::autofill::mojom::ButtonTitleInfoPtr> {
  static bool IsNull(const ::autofill::mojom::ButtonTitleInfoPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::ButtonTitleInfoPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::ButtonTitleInfo::title)& title(
      const ::autofill::mojom::ButtonTitleInfoPtr& input) {
    return input->title;
  }

  static decltype(::autofill::mojom::ButtonTitleInfo::type) type(
      const ::autofill::mojom::ButtonTitleInfoPtr& input) {
    return input->type;
  }

  static bool Read(::autofill::mojom::ButtonTitleInfo::DataView input, ::autofill::mojom::ButtonTitleInfoPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormData::DataView,
                                         ::autofill::mojom::FormDataPtr> {
  static bool IsNull(const ::autofill::mojom::FormDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormData::id_attribute)& id_attribute(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->id_attribute;
  }

  static const decltype(::autofill::mojom::FormData::name_attribute)& name_attribute(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->name_attribute;
  }

  static const decltype(::autofill::mojom::FormData::name)& name(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->name;
  }

  static const decltype(::autofill::mojom::FormData::button_titles)& button_titles(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->button_titles;
  }

  static const decltype(::autofill::mojom::FormData::action)& action(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->action;
  }

  static decltype(::autofill::mojom::FormData::is_action_empty) is_action_empty(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_action_empty;
  }

  static decltype(::autofill::mojom::FormData::is_form_tag) is_form_tag(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_form_tag;
  }

  static const decltype(::autofill::mojom::FormData::unique_renderer_id)& unique_renderer_id(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->unique_renderer_id;
  }

  static const decltype(::autofill::mojom::FormData::child_frames)& child_frames(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->child_frames;
  }

  static decltype(::autofill::mojom::FormData::submission_event) submission_event(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->submission_event;
  }

  static const decltype(::autofill::mojom::FormData::fields)& fields(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->fields;
  }

  static const decltype(::autofill::mojom::FormData::username_predictions)& username_predictions(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->username_predictions;
  }

  static decltype(::autofill::mojom::FormData::is_gaia_with_skip_save_password_form) is_gaia_with_skip_save_password_form(
      const ::autofill::mojom::FormDataPtr& input) {
    return input->is_gaia_with_skip_save_password_form;
  }

  static bool Read(::autofill::mojom::FormData::DataView input, ::autofill::mojom::FormDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormFieldDataPredictions::DataView,
                                         ::autofill::mojom::FormFieldDataPredictionsPtr> {
  static bool IsNull(const ::autofill::mojom::FormFieldDataPredictionsPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormFieldDataPredictionsPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::host_form_signature)& host_form_signature(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->host_form_signature;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::signature)& signature(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->signature;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::heuristic_type)& heuristic_type(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->heuristic_type;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::server_type)& server_type(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->server_type;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::overall_type)& overall_type(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->overall_type;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::parseable_name)& parseable_name(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->parseable_name;
  }

  static const decltype(::autofill::mojom::FormFieldDataPredictions::section)& section(
      const ::autofill::mojom::FormFieldDataPredictionsPtr& input) {
    return input->section;
  }

  static bool Read(::autofill::mojom::FormFieldDataPredictions::DataView input, ::autofill::mojom::FormFieldDataPredictionsPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::FormDataPredictions::DataView,
                                         ::autofill::mojom::FormDataPredictionsPtr> {
  static bool IsNull(const ::autofill::mojom::FormDataPredictionsPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::FormDataPredictionsPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::FormDataPredictions::data)& data(
      const ::autofill::mojom::FormDataPredictionsPtr& input) {
    return input->data;
  }

  static const decltype(::autofill::mojom::FormDataPredictions::signature)& signature(
      const ::autofill::mojom::FormDataPredictionsPtr& input) {
    return input->signature;
  }

  static const decltype(::autofill::mojom::FormDataPredictions::fields)& fields(
      const ::autofill::mojom::FormDataPredictionsPtr& input) {
    return input->fields;
  }

  static bool Read(::autofill::mojom::FormDataPredictions::DataView input, ::autofill::mojom::FormDataPredictionsPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordAndMetadata::DataView,
                                         ::autofill::mojom::PasswordAndMetadataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordAndMetadataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordAndMetadataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::PasswordAndMetadata::username)& username(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->username;
  }

  static const decltype(::autofill::mojom::PasswordAndMetadata::password)& password(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->password;
  }

  static const decltype(::autofill::mojom::PasswordAndMetadata::realm)& realm(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->realm;
  }

  static decltype(::autofill::mojom::PasswordAndMetadata::uses_account_store) uses_account_store(
      const ::autofill::mojom::PasswordAndMetadataPtr& input) {
    return input->uses_account_store;
  }

  static bool Read(::autofill::mojom::PasswordAndMetadata::DataView input, ::autofill::mojom::PasswordAndMetadataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordFormFillData::DataView,
                                         ::autofill::mojom::PasswordFormFillDataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordFormFillDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordFormFillDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::PasswordFormFillData::form_renderer_id)& form_renderer_id(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->form_renderer_id;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::url)& url(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->url;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::action)& action(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->action;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::username_field)& username_field(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->username_field;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::password_field)& password_field(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->password_field;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::username_may_use_prefilled_placeholder) username_may_use_prefilled_placeholder(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->username_may_use_prefilled_placeholder;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::preferred_realm)& preferred_realm(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->preferred_realm;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::uses_account_store) uses_account_store(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->uses_account_store;
  }

  static const decltype(::autofill::mojom::PasswordFormFillData::additional_logins)& additional_logins(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->additional_logins;
  }

  static decltype(::autofill::mojom::PasswordFormFillData::wait_for_username) wait_for_username(
      const ::autofill::mojom::PasswordFormFillDataPtr& input) {
    return input->wait_for_username;
  }

  static bool Read(::autofill::mojom::PasswordFormFillData::DataView input, ::autofill::mojom::PasswordFormFillDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordFormGenerationData::DataView,
                                         ::autofill::mojom::PasswordFormGenerationDataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordFormGenerationDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordFormGenerationDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::PasswordFormGenerationData::new_password_renderer_id)& new_password_renderer_id(
      const ::autofill::mojom::PasswordFormGenerationDataPtr& input) {
    return input->new_password_renderer_id;
  }

  static const decltype(::autofill::mojom::PasswordFormGenerationData::confirmation_password_renderer_id)& confirmation_password_renderer_id(
      const ::autofill::mojom::PasswordFormGenerationDataPtr& input) {
    return input->confirmation_password_renderer_id;
  }

  static bool Read(::autofill::mojom::PasswordFormGenerationData::DataView input, ::autofill::mojom::PasswordFormGenerationDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::PasswordGenerationUIData::DataView,
                                         ::autofill::mojom::PasswordGenerationUIDataPtr> {
  static bool IsNull(const ::autofill::mojom::PasswordGenerationUIDataPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::PasswordGenerationUIDataPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::bounds)& bounds(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->bounds;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::max_length) max_length(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->max_length;
  }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::generation_element)& generation_element(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->generation_element;
  }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::generation_element_id)& generation_element_id(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->generation_element_id;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::is_generation_element_password_type) is_generation_element_password_type(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->is_generation_element_password_type;
  }

  static decltype(::autofill::mojom::PasswordGenerationUIData::text_direction) text_direction(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->text_direction;
  }

  static const decltype(::autofill::mojom::PasswordGenerationUIData::form_data)& form_data(
      const ::autofill::mojom::PasswordGenerationUIDataPtr& input) {
    return input->form_data;
  }

  static bool Read(::autofill::mojom::PasswordGenerationUIData::DataView input, ::autofill::mojom::PasswordGenerationUIDataPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::ParsingResult::DataView,
                                         ::autofill::mojom::ParsingResultPtr> {
  static bool IsNull(const ::autofill::mojom::ParsingResultPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::ParsingResultPtr* output) { output->reset(); }

  static const decltype(::autofill::mojom::ParsingResult::username_renderer_id)& username_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->username_renderer_id;
  }

  static const decltype(::autofill::mojom::ParsingResult::password_renderer_id)& password_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->password_renderer_id;
  }

  static const decltype(::autofill::mojom::ParsingResult::new_password_renderer_id)& new_password_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->new_password_renderer_id;
  }

  static const decltype(::autofill::mojom::ParsingResult::confirm_password_renderer_id)& confirm_password_renderer_id(
      const ::autofill::mojom::ParsingResultPtr& input) {
    return input->confirm_password_renderer_id;
  }

  static bool Read(::autofill::mojom::ParsingResult::DataView input, ::autofill::mojom::ParsingResultPtr* output);
};


template <>
struct  StructTraits<::autofill::mojom::TouchToFillEligible::DataView,
                                         ::autofill::mojom::TouchToFillEligiblePtr> {
  static bool IsNull(const ::autofill::mojom::TouchToFillEligiblePtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::TouchToFillEligiblePtr* output) { output->reset(); }

  static decltype(::autofill::mojom::TouchToFillEligible::eligible) eligible(
      const ::autofill::mojom::TouchToFillEligiblePtr& input) {
    return input->eligible;
  }

  static bool Read(::autofill::mojom::TouchToFillEligible::DataView input, ::autofill::mojom::TouchToFillEligiblePtr* output);
};


template <>
struct  UnionTraits<::autofill::mojom::SectionPrefix::DataView,
                                        ::autofill::mojom::SectionPrefixPtr> {
  static bool IsNull(const ::autofill::mojom::SectionPrefixPtr& input) { return !input; }
  static void SetToNull(::autofill::mojom::SectionPrefixPtr* output) { output->reset(); }

  static ::autofill::mojom::SectionPrefix::Tag GetTag(const ::autofill::mojom::SectionPrefixPtr& input) {
    return input->which();
  }

  static  bool default_prefix(const ::autofill::mojom::SectionPrefixPtr& input) {
    return input->get_default_prefix();
  }

  static const ::autofill::mojom::SectionAutocompletePtr& autocomplete_section_prefix(const ::autofill::mojom::SectionPrefixPtr& input) {
    return input->get_autocomplete_section_prefix();
  }

  static const ::autofill::mojom::SectionFieldIdentifierPtr& from_field_prefix(const ::autofill::mojom::SectionPrefixPtr& input) {
    return input->get_from_field_prefix();
  }

  static  bool credit_card_prefix(const ::autofill::mojom::SectionPrefixPtr& input) {
    return input->get_credit_card_prefix();
  }

  static bool Read(::autofill::mojom::SectionPrefix::DataView input, ::autofill::mojom::SectionPrefixPtr* output);
};

}  // namespace mojo

#endif  // COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_H_