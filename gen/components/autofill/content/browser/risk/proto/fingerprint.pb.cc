// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fingerprint.proto

#include "fingerprint.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill {
namespace risk {
PROTOBUF_CONSTEXPR Fingerprint_Dimension::Fingerprint_Dimension(
    ::_pbi::ConstantInitialized)
  : width_(0)
  , height_(0){}
struct Fingerprint_DimensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_DimensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_DimensionDefaultTypeInternal() {}
  union {
    Fingerprint_Dimension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_DimensionDefaultTypeInternal _Fingerprint_Dimension_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Plugin::Fingerprint_MachineCharacteristics_Plugin(
    ::_pbi::ConstantInitialized)
  : mime_type_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal() {}
  union {
    Fingerprint_MachineCharacteristics_Plugin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal _Fingerprint_MachineCharacteristics_Plugin_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Cpu::Fingerprint_MachineCharacteristics_Cpu(
    ::_pbi::ConstantInitialized)
  : vendor_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , brand_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal() {}
  union {
    Fingerprint_MachineCharacteristics_Cpu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal _Fingerprint_MachineCharacteristics_Cpu_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Graphics::Fingerprint_MachineCharacteristics_Graphics(
    ::_pbi::ConstantInitialized)
  : driver_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , driver_date_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , vendor_id_(0u)
  , device_id_(0u){}
struct Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal() {}
  union {
    Fingerprint_MachineCharacteristics_Graphics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_Graphics_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics::Fingerprint_MachineCharacteristics(
    ::_pbi::ConstantInitialized)
  : font_()
  , plugin_()
  , requested_language_()
  , partition_size_()
  , operating_system_build_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , browser_language_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , charset_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_agent_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , browser_build_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , screen_size_(nullptr)
  , unavailable_screen_size_(nullptr)
  , cpu_(nullptr)
  , graphics_card_(nullptr)
  , user_and_device_name_hash_(uint64_t{0u})
  , browser_install_time_hours_(int64_t{0})
  , utc_offset_ms_(int64_t{0})
  , screen_count_(0)
  , screen_color_depth_(0)
  , ram_(int64_t{0})
  , browser_feature_(0)
{}
struct Fingerprint_MachineCharacteristicsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristicsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_MachineCharacteristicsDefaultTypeInternal() {}
  union {
    Fingerprint_MachineCharacteristics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_TransientState::Fingerprint_TransientState(
    ::_pbi::ConstantInitialized)
  : inner_window_size_(nullptr)
  , outer_window_size_(nullptr){}
struct Fingerprint_TransientStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_TransientStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_TransientStateDefaultTypeInternal() {}
  union {
    Fingerprint_TransientState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_TransientStateDefaultTypeInternal _Fingerprint_TransientState_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_Performance::Fingerprint_Performance(
    ::_pbi::ConstantInitialized)
  : network_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bandwidth_(0)
  , metered_(false){}
struct Fingerprint_PerformanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_PerformanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_PerformanceDefaultTypeInternal() {}
  union {
    Fingerprint_Performance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_PerformanceDefaultTypeInternal _Fingerprint_Performance_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Vector::Fingerprint_UserCharacteristics_Vector(
    ::_pbi::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct Fingerprint_UserCharacteristics_VectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_VectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_UserCharacteristics_VectorDefaultTypeInternal() {}
  union {
    Fingerprint_UserCharacteristics_Vector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_UserCharacteristics_VectorDefaultTypeInternal _Fingerprint_UserCharacteristics_Vector_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Location::Fingerprint_UserCharacteristics_Location(
    ::_pbi::ConstantInitialized)
  : altitude_(0)
  , latitude_(0)
  , longitude_(0)
  , accuracy_(0)
  , time_in_ms_(int64_t{0}){}
struct Fingerprint_UserCharacteristics_LocationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_LocationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_UserCharacteristics_LocationDefaultTypeInternal() {}
  union {
    Fingerprint_UserCharacteristics_Location _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_UserCharacteristics_LocationDefaultTypeInternal _Fingerprint_UserCharacteristics_Location_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics::Fingerprint_UserCharacteristics(
    ::_pbi::ConstantInitialized)
  : device_orientation_(nullptr)
  , device_acceleration_(nullptr)
  , location_(nullptr)
  , force_(0)
  , touch_width_(0)
  , touch_height_(0)
  , touch_rotation_(0){}
struct Fingerprint_UserCharacteristicsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristicsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_UserCharacteristicsDefaultTypeInternal() {}
  union {
    Fingerprint_UserCharacteristics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_UserCharacteristicsDefaultTypeInternal _Fingerprint_UserCharacteristics_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_Metadata::Fingerprint_Metadata(
    ::_pbi::ConstantInitialized)
  : timestamp_ms_(int64_t{0})
  , obfuscated_gaia_id_(uint64_t{0u})
  , fingerprinter_version_(0){}
struct Fingerprint_MetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fingerprint_MetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fingerprint_MetadataDefaultTypeInternal() {}
  union {
    Fingerprint_Metadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MetadataDefaultTypeInternal _Fingerprint_Metadata_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint::Fingerprint(
    ::_pbi::ConstantInitialized)
  : machine_characteristics_(nullptr)
  , performance_(nullptr)
  , user_characteristics_(nullptr)
  , transient_state_(nullptr)
  , metadata_(nullptr){}
struct FingerprintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FingerprintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FingerprintDefaultTypeInternal() {}
  union {
    Fingerprint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
}  // namespace risk
}  // namespace autofill
namespace autofill {
namespace risk {
bool Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Fingerprint_MachineCharacteristics_BrowserFeature_strings[3] = {};

static const char Fingerprint_MachineCharacteristics_BrowserFeature_names[] =
  "DEPRECATED_FEATURE_AUTOCHECKOUT"
  "FEATURE_REQUEST_AUTOCOMPLETE"
  "FEATURE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Fingerprint_MachineCharacteristics_BrowserFeature_entries[] = {
  { {Fingerprint_MachineCharacteristics_BrowserFeature_names + 0, 31}, 1 },
  { {Fingerprint_MachineCharacteristics_BrowserFeature_names + 31, 28}, 2 },
  { {Fingerprint_MachineCharacteristics_BrowserFeature_names + 59, 15}, 0 },
};

static const int Fingerprint_MachineCharacteristics_BrowserFeature_entries_by_number[] = {
  2, // 0 -> FEATURE_UNKNOWN
  0, // 1 -> DEPRECATED_FEATURE_AUTOCHECKOUT
  1, // 2 -> FEATURE_REQUEST_AUTOCOMPLETE
};

const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(
    Fingerprint_MachineCharacteristics_BrowserFeature value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Fingerprint_MachineCharacteristics_BrowserFeature_entries,
          Fingerprint_MachineCharacteristics_BrowserFeature_entries_by_number,
          3, Fingerprint_MachineCharacteristics_BrowserFeature_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Fingerprint_MachineCharacteristics_BrowserFeature_entries,
      Fingerprint_MachineCharacteristics_BrowserFeature_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Fingerprint_MachineCharacteristics_BrowserFeature_strings[idx].get();
}
bool Fingerprint_MachineCharacteristics_BrowserFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fingerprint_MachineCharacteristics_BrowserFeature* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Fingerprint_MachineCharacteristics_BrowserFeature_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Fingerprint_MachineCharacteristics_BrowserFeature>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::FEATURE_UNKNOWN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::DEPRECATED_FEATURE_AUTOCHECKOUT;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::FEATURE_REQUEST_AUTOCOMPLETE;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::BrowserFeature_MIN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::BrowserFeature_MAX;
constexpr int Fingerprint_MachineCharacteristics::BrowserFeature_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Fingerprint_Dimension::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_Dimension>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Fingerprint_Dimension::Fingerprint_Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.Dimension)
}
Fingerprint_Dimension::Fingerprint_Dimension(const Fingerprint_Dimension& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.Dimension)
}

inline void Fingerprint_Dimension::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

Fingerprint_Dimension::~Fingerprint_Dimension() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.Dimension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_Dimension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_Dimension::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_Dimension::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.Dimension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_Dimension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_Dimension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.Dimension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.Dimension)
  return target;
}

size_t Fingerprint_Dimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.Dimension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 width = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_Dimension::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_Dimension*>(
      &from));
}

void Fingerprint_Dimension::MergeFrom(const Fingerprint_Dimension& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.Dimension)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_Dimension::CopyFrom(const Fingerprint_Dimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.Dimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_Dimension::IsInitialized() const {
  return true;
}

void Fingerprint_Dimension::InternalSwap(Fingerprint_Dimension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_Dimension, height_)
      + sizeof(Fingerprint_Dimension::height_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_Dimension, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

std::string Fingerprint_Dimension::GetTypeName() const {
  return "autofill.risk.Fingerprint.Dimension";
}


// ===================================================================

class Fingerprint_MachineCharacteristics_Plugin::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics_Plugin>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Fingerprint_MachineCharacteristics_Plugin::Fingerprint_MachineCharacteristics_Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  mime_type_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
}
Fingerprint_MachineCharacteristics_Plugin::Fingerprint_MachineCharacteristics_Plugin(const Fingerprint_MachineCharacteristics_Plugin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      mime_type_(from.mime_type_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
}

inline void Fingerprint_MachineCharacteristics_Plugin::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_MachineCharacteristics_Plugin::~Fingerprint_MachineCharacteristics_Plugin() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_MachineCharacteristics_Plugin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  description_.Destroy();
  version_.Destroy();
}

void Fingerprint_MachineCharacteristics_Plugin::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics_Plugin::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mime_type_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      version_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics_Plugin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string mime_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mime_type();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics_Plugin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // repeated string mime_type = 3;
  for (int i = 0, n = this->_internal_mime_type_size(); i < n; i++) {
    const auto& s = this->_internal_mime_type(i);
    target = stream->WriteString(3, s, target);
  }

  // optional string version = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  return target;
}

size_t Fingerprint_MachineCharacteristics_Plugin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string mime_type = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(mime_type_.size());
  for (int i = 0, n = mime_type_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      mime_type_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string description = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string version = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_MachineCharacteristics_Plugin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics_Plugin*>(
      &from));
}

void Fingerprint_MachineCharacteristics_Plugin::MergeFrom(const Fingerprint_MachineCharacteristics_Plugin& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mime_type_.MergeFrom(from.mime_type_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_version(from._internal_version());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics_Plugin::CopyFrom(const Fingerprint_MachineCharacteristics_Plugin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics_Plugin::IsInitialized() const {
  return true;
}

void Fingerprint_MachineCharacteristics_Plugin::InternalSwap(Fingerprint_MachineCharacteristics_Plugin* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  mime_type_.InternalSwap(&other->mime_type_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
}

std::string Fingerprint_MachineCharacteristics_Plugin::GetTypeName() const {
  return "autofill.risk.Fingerprint.MachineCharacteristics.Plugin";
}


// ===================================================================

class Fingerprint_MachineCharacteristics_Cpu::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics_Cpu>()._has_bits_);
  static void set_has_vendor_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brand(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Fingerprint_MachineCharacteristics_Cpu::Fingerprint_MachineCharacteristics_Cpu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
}
Fingerprint_MachineCharacteristics_Cpu::Fingerprint_MachineCharacteristics_Cpu(const Fingerprint_MachineCharacteristics_Cpu& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  vendor_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    vendor_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor_name()) {
    vendor_name_.Set(from._internal_vendor_name(), 
      GetArenaForAllocation());
  }
  brand_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    brand_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_brand()) {
    brand_.Set(from._internal_brand(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
}

inline void Fingerprint_MachineCharacteristics_Cpu::SharedCtor() {
vendor_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  vendor_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
brand_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  brand_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_MachineCharacteristics_Cpu::~Fingerprint_MachineCharacteristics_Cpu() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_MachineCharacteristics_Cpu::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  vendor_name_.Destroy();
  brand_.Destroy();
}

void Fingerprint_MachineCharacteristics_Cpu::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics_Cpu::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vendor_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      brand_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics_Cpu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string vendor_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_vendor_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string brand = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_brand();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics_Cpu::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string vendor_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_vendor_name(), target);
  }

  // optional string brand = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_brand(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  return target;
}

size_t Fingerprint_MachineCharacteristics_Cpu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string vendor_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor_name());
    }

    // optional string brand = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_brand());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_MachineCharacteristics_Cpu::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics_Cpu*>(
      &from));
}

void Fingerprint_MachineCharacteristics_Cpu::MergeFrom(const Fingerprint_MachineCharacteristics_Cpu& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_vendor_name(from._internal_vendor_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_brand(from._internal_brand());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics_Cpu::CopyFrom(const Fingerprint_MachineCharacteristics_Cpu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics_Cpu::IsInitialized() const {
  return true;
}

void Fingerprint_MachineCharacteristics_Cpu::InternalSwap(Fingerprint_MachineCharacteristics_Cpu* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &vendor_name_, lhs_arena,
      &other->vendor_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &brand_, lhs_arena,
      &other->brand_, rhs_arena
  );
}

std::string Fingerprint_MachineCharacteristics_Cpu::GetTypeName() const {
  return "autofill.risk.Fingerprint.MachineCharacteristics.Cpu";
}


// ===================================================================

class Fingerprint_MachineCharacteristics_Graphics::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics_Graphics>()._has_bits_);
  static void set_has_vendor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_driver_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_driver_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Fingerprint_MachineCharacteristics_Graphics::Fingerprint_MachineCharacteristics_Graphics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
}
Fingerprint_MachineCharacteristics_Graphics::Fingerprint_MachineCharacteristics_Graphics(const Fingerprint_MachineCharacteristics_Graphics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  driver_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    driver_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver_version()) {
    driver_version_.Set(from._internal_driver_version(), 
      GetArenaForAllocation());
  }
  driver_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    driver_date_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver_date()) {
    driver_date_.Set(from._internal_driver_date(), 
      GetArenaForAllocation());
  }
  ::memcpy(&vendor_id_, &from.vendor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_id_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(device_id_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
}

inline void Fingerprint_MachineCharacteristics_Graphics::SharedCtor() {
driver_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  driver_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
driver_date_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  driver_date_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&vendor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_id_) -
    reinterpret_cast<char*>(&vendor_id_)) + sizeof(device_id_));
}

Fingerprint_MachineCharacteristics_Graphics::~Fingerprint_MachineCharacteristics_Graphics() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_MachineCharacteristics_Graphics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  driver_version_.Destroy();
  driver_date_.Destroy();
}

void Fingerprint_MachineCharacteristics_Graphics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics_Graphics::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      driver_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      driver_date_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&vendor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_id_) -
        reinterpret_cast<char*>(&vendor_id_)) + sizeof(device_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics_Graphics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 vendor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_vendor_id(&has_bits);
          vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string driver_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_driver_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string driver_date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_driver_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics_Graphics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 vendor_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vendor_id(), target);
  }

  // optional uint32 device_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_device_id(), target);
  }

  // optional string driver_version = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_driver_version(), target);
  }

  // optional string driver_date = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_driver_date(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  return target;
}

size_t Fingerprint_MachineCharacteristics_Graphics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string driver_version = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_driver_version());
    }

    // optional string driver_date = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_driver_date());
    }

    // optional uint32 vendor_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vendor_id());
    }

    // optional uint32 device_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_MachineCharacteristics_Graphics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics_Graphics*>(
      &from));
}

void Fingerprint_MachineCharacteristics_Graphics::MergeFrom(const Fingerprint_MachineCharacteristics_Graphics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_driver_version(from._internal_driver_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_driver_date(from._internal_driver_date());
    }
    if (cached_has_bits & 0x00000004u) {
      vendor_id_ = from.vendor_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      device_id_ = from.device_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics_Graphics::CopyFrom(const Fingerprint_MachineCharacteristics_Graphics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics_Graphics::IsInitialized() const {
  return true;
}

void Fingerprint_MachineCharacteristics_Graphics::InternalSwap(Fingerprint_MachineCharacteristics_Graphics* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &driver_version_, lhs_arena,
      &other->driver_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &driver_date_, lhs_arena,
      &other->driver_date_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics_Graphics, device_id_)
      + sizeof(Fingerprint_MachineCharacteristics_Graphics::device_id_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics_Graphics, vendor_id_)>(
          reinterpret_cast<char*>(&vendor_id_),
          reinterpret_cast<char*>(&other->vendor_id_));
}

std::string Fingerprint_MachineCharacteristics_Graphics::GetTypeName() const {
  return "autofill.risk.Fingerprint.MachineCharacteristics.Graphics";
}


// ===================================================================

class Fingerprint_MachineCharacteristics::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics>()._has_bits_);
  static void set_has_user_and_device_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_operating_system_build(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_browser_install_time_hours(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_utc_offset_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_browser_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_charset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_screen_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::autofill::risk::Fingerprint_Dimension& screen_size(const Fingerprint_MachineCharacteristics* msg);
  static void set_has_screen_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_screen_color_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::autofill::risk::Fingerprint_Dimension& unavailable_screen_size(const Fingerprint_MachineCharacteristics* msg);
  static void set_has_unavailable_screen_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_user_agent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& cpu(const Fingerprint_MachineCharacteristics* msg);
  static void set_has_cpu(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ram(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& graphics_card(const Fingerprint_MachineCharacteristics* msg);
  static void set_has_graphics_card(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_browser_build(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_browser_feature(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::autofill::risk::Fingerprint_Dimension&
Fingerprint_MachineCharacteristics::_Internal::screen_size(const Fingerprint_MachineCharacteristics* msg) {
  return *msg->screen_size_;
}
const ::autofill::risk::Fingerprint_Dimension&
Fingerprint_MachineCharacteristics::_Internal::unavailable_screen_size(const Fingerprint_MachineCharacteristics* msg) {
  return *msg->unavailable_screen_size_;
}
const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu&
Fingerprint_MachineCharacteristics::_Internal::cpu(const Fingerprint_MachineCharacteristics* msg) {
  return *msg->cpu_;
}
const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics&
Fingerprint_MachineCharacteristics::_Internal::graphics_card(const Fingerprint_MachineCharacteristics* msg) {
  return *msg->graphics_card_;
}
Fingerprint_MachineCharacteristics::Fingerprint_MachineCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  font_(arena),
  plugin_(arena),
  requested_language_(arena),
  partition_size_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics)
}
Fingerprint_MachineCharacteristics::Fingerprint_MachineCharacteristics(const Fingerprint_MachineCharacteristics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      font_(from.font_),
      plugin_(from.plugin_),
      requested_language_(from.requested_language_),
      partition_size_(from.partition_size_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  operating_system_build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    operating_system_build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_operating_system_build()) {
    operating_system_build_.Set(from._internal_operating_system_build(), 
      GetArenaForAllocation());
  }
  browser_language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    browser_language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_language()) {
    browser_language_.Set(from._internal_browser_language(), 
      GetArenaForAllocation());
  }
  charset_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    charset_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_charset()) {
    charset_.Set(from._internal_charset(), 
      GetArenaForAllocation());
  }
  user_agent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_agent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_agent()) {
    user_agent_.Set(from._internal_user_agent(), 
      GetArenaForAllocation());
  }
  browser_build_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    browser_build_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_build()) {
    browser_build_.Set(from._internal_browser_build(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_screen_size()) {
    screen_size_ = new ::autofill::risk::Fingerprint_Dimension(*from.screen_size_);
  } else {
    screen_size_ = nullptr;
  }
  if (from._internal_has_unavailable_screen_size()) {
    unavailable_screen_size_ = new ::autofill::risk::Fingerprint_Dimension(*from.unavailable_screen_size_);
  } else {
    unavailable_screen_size_ = nullptr;
  }
  if (from._internal_has_cpu()) {
    cpu_ = new ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu(*from.cpu_);
  } else {
    cpu_ = nullptr;
  }
  if (from._internal_has_graphics_card()) {
    graphics_card_ = new ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics(*from.graphics_card_);
  } else {
    graphics_card_ = nullptr;
  }
  ::memcpy(&user_and_device_name_hash_, &from.user_and_device_name_hash_,
    static_cast<size_t>(reinterpret_cast<char*>(&browser_feature_) -
    reinterpret_cast<char*>(&user_and_device_name_hash_)) + sizeof(browser_feature_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics)
}

inline void Fingerprint_MachineCharacteristics::SharedCtor() {
operating_system_build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  operating_system_build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
browser_language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  browser_language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
charset_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  charset_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
browser_build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  browser_build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&screen_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&browser_feature_) -
    reinterpret_cast<char*>(&screen_size_)) + sizeof(browser_feature_));
}

Fingerprint_MachineCharacteristics::~Fingerprint_MachineCharacteristics() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_MachineCharacteristics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  operating_system_build_.Destroy();
  browser_language_.Destroy();
  charset_.Destroy();
  user_agent_.Destroy();
  browser_build_.Destroy();
  if (this != internal_default_instance()) delete screen_size_;
  if (this != internal_default_instance()) delete unavailable_screen_size_;
  if (this != internal_default_instance()) delete cpu_;
  if (this != internal_default_instance()) delete graphics_card_;
}

void Fingerprint_MachineCharacteristics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  font_.Clear();
  plugin_.Clear();
  requested_language_.Clear();
  partition_size_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      operating_system_build_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      browser_language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      charset_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      user_agent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      browser_build_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(screen_size_ != nullptr);
      screen_size_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(unavailable_screen_size_ != nullptr);
      unavailable_screen_size_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(cpu_ != nullptr);
      cpu_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(graphics_card_ != nullptr);
    graphics_card_->Clear();
  }
  if (cached_has_bits & 0x0000fe00u) {
    ::memset(&user_and_device_name_hash_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&browser_feature_) -
        reinterpret_cast<char*>(&user_and_device_name_hash_)) + sizeof(browser_feature_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 user_and_device_name_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_user_and_device_name_hash(&has_bits);
          user_and_device_name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string operating_system_build = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_operating_system_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 browser_install_time_hours = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_browser_install_time_hours(&has_bits);
          browser_install_time_hours_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string font = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_font();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_plugin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 utc_offset_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_utc_offset_ms(&has_bits);
          utc_offset_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string browser_language = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_browser_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string requested_language = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_requested_language();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string charset = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_charset();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 screen_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_screen_count(&has_bits);
          screen_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_screen_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 screen_color_depth = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_screen_color_depth(&has_bits);
          screen_color_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_unavailable_screen_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_agent = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_user_agent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 partition_size = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_partition_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<120>(ptr));
        } else if (static_cast<uint8_t>(tag) == 122) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_partition_size(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_cpu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ram = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_ram(&has_bits);
          ram_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_graphics_card(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string browser_build = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_browser_build();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(val))) {
            _internal_set_browser_feature(static_cast<::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 user_and_device_name_hash = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_user_and_device_name_hash(), target);
  }

  // optional string operating_system_build = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_operating_system_build(), target);
  }

  // optional int64 browser_install_time_hours = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_browser_install_time_hours(), target);
  }

  // repeated string font = 4;
  for (int i = 0, n = this->_internal_font_size(); i < n; i++) {
    const auto& s = this->_internal_font(i);
    target = stream->WriteString(4, s, target);
  }

  // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_plugin_size()); i < n; i++) {
    const auto& repfield = this->_internal_plugin(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int64 utc_offset_ms = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_utc_offset_ms(), target);
  }

  // optional string browser_language = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_browser_language(), target);
  }

  // repeated string requested_language = 8;
  for (int i = 0, n = this->_internal_requested_language_size(); i < n; i++) {
    const auto& s = this->_internal_requested_language(i);
    target = stream->WriteString(8, s, target);
  }

  // optional string charset = 9;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_charset(), target);
  }

  // optional int32 screen_count = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_screen_count(), target);
  }

  // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::screen_size(this),
        _Internal::screen_size(this).GetCachedSize(), target, stream);
  }

  // optional int32 screen_color_depth = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_screen_color_depth(), target);
  }

  // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::unavailable_screen_size(this),
        _Internal::unavailable_screen_size(this).GetCachedSize(), target, stream);
  }

  // optional string user_agent = 14;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_user_agent(), target);
  }

  // repeated int32 partition_size = 15;
  for (int i = 0, n = this->_internal_partition_size_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_partition_size(i), target);
  }

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::cpu(this),
        _Internal::cpu(this).GetCachedSize(), target, stream);
  }

  // optional int64 ram = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_ram(), target);
  }

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::graphics_card(this),
        _Internal::graphics_card(this).GetCachedSize(), target, stream);
  }

  // optional string browser_build = 19;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_browser_build(), target);
  }

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_browser_feature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics)
  return target;
}

size_t Fingerprint_MachineCharacteristics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string font = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(font_.size());
  for (int i = 0, n = font_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      font_.Get(i));
  }

  // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
  total_size += 1UL * this->_internal_plugin_size();
  for (const auto& msg : this->plugin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string requested_language = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(requested_language_.size());
  for (int i = 0, n = requested_language_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      requested_language_.Get(i));
  }

  // repeated int32 partition_size = 15;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->partition_size_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_partition_size_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string operating_system_build = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_operating_system_build());
    }

    // optional string browser_language = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_browser_language());
    }

    // optional string charset = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_charset());
    }

    // optional string user_agent = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_agent());
    }

    // optional string browser_build = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_browser_build());
    }

    // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *screen_size_);
    }

    // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *unavailable_screen_size_);
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cpu_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *graphics_card_);
    }

    // optional fixed64 user_and_device_name_hash = 1;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional int64 browser_install_time_hours = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_browser_install_time_hours());
    }

    // optional int64 utc_offset_ms = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_utc_offset_ms());
    }

    // optional int32 screen_count = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_screen_count());
    }

    // optional int32 screen_color_depth = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_screen_color_depth());
    }

    // optional int64 ram = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_ram());
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_browser_feature());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_MachineCharacteristics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics*>(
      &from));
}

void Fingerprint_MachineCharacteristics::MergeFrom(const Fingerprint_MachineCharacteristics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  font_.MergeFrom(from.font_);
  plugin_.MergeFrom(from.plugin_);
  requested_language_.MergeFrom(from.requested_language_);
  partition_size_.MergeFrom(from.partition_size_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_operating_system_build(from._internal_operating_system_build());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_browser_language(from._internal_browser_language());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_charset(from._internal_charset());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_user_agent(from._internal_user_agent());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_browser_build(from._internal_browser_build());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_screen_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_screen_size());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_unavailable_screen_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_unavailable_screen_size());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_cpu()->::autofill::risk::Fingerprint_MachineCharacteristics_Cpu::MergeFrom(from._internal_cpu());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_graphics_card()->::autofill::risk::Fingerprint_MachineCharacteristics_Graphics::MergeFrom(from._internal_graphics_card());
    }
    if (cached_has_bits & 0x00000200u) {
      user_and_device_name_hash_ = from.user_and_device_name_hash_;
    }
    if (cached_has_bits & 0x00000400u) {
      browser_install_time_hours_ = from.browser_install_time_hours_;
    }
    if (cached_has_bits & 0x00000800u) {
      utc_offset_ms_ = from.utc_offset_ms_;
    }
    if (cached_has_bits & 0x00001000u) {
      screen_count_ = from.screen_count_;
    }
    if (cached_has_bits & 0x00002000u) {
      screen_color_depth_ = from.screen_color_depth_;
    }
    if (cached_has_bits & 0x00004000u) {
      ram_ = from.ram_;
    }
    if (cached_has_bits & 0x00008000u) {
      browser_feature_ = from.browser_feature_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics::CopyFrom(const Fingerprint_MachineCharacteristics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics::IsInitialized() const {
  return true;
}

void Fingerprint_MachineCharacteristics::InternalSwap(Fingerprint_MachineCharacteristics* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  font_.InternalSwap(&other->font_);
  plugin_.InternalSwap(&other->plugin_);
  requested_language_.InternalSwap(&other->requested_language_);
  partition_size_.InternalSwap(&other->partition_size_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &operating_system_build_, lhs_arena,
      &other->operating_system_build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &browser_language_, lhs_arena,
      &other->browser_language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &charset_, lhs_arena,
      &other->charset_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_agent_, lhs_arena,
      &other->user_agent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &browser_build_, lhs_arena,
      &other->browser_build_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics, browser_feature_)
      + sizeof(Fingerprint_MachineCharacteristics::browser_feature_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics, screen_size_)>(
          reinterpret_cast<char*>(&screen_size_),
          reinterpret_cast<char*>(&other->screen_size_));
}

std::string Fingerprint_MachineCharacteristics::GetTypeName() const {
  return "autofill.risk.Fingerprint.MachineCharacteristics";
}


// ===================================================================

class Fingerprint_TransientState::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_TransientState>()._has_bits_);
  static const ::autofill::risk::Fingerprint_Dimension& inner_window_size(const Fingerprint_TransientState* msg);
  static void set_has_inner_window_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill::risk::Fingerprint_Dimension& outer_window_size(const Fingerprint_TransientState* msg);
  static void set_has_outer_window_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill::risk::Fingerprint_Dimension&
Fingerprint_TransientState::_Internal::inner_window_size(const Fingerprint_TransientState* msg) {
  return *msg->inner_window_size_;
}
const ::autofill::risk::Fingerprint_Dimension&
Fingerprint_TransientState::_Internal::outer_window_size(const Fingerprint_TransientState* msg) {
  return *msg->outer_window_size_;
}
Fingerprint_TransientState::Fingerprint_TransientState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.TransientState)
}
Fingerprint_TransientState::Fingerprint_TransientState(const Fingerprint_TransientState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_inner_window_size()) {
    inner_window_size_ = new ::autofill::risk::Fingerprint_Dimension(*from.inner_window_size_);
  } else {
    inner_window_size_ = nullptr;
  }
  if (from._internal_has_outer_window_size()) {
    outer_window_size_ = new ::autofill::risk::Fingerprint_Dimension(*from.outer_window_size_);
  } else {
    outer_window_size_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.TransientState)
}

inline void Fingerprint_TransientState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&inner_window_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&outer_window_size_) -
    reinterpret_cast<char*>(&inner_window_size_)) + sizeof(outer_window_size_));
}

Fingerprint_TransientState::~Fingerprint_TransientState() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.TransientState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_TransientState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete inner_window_size_;
  if (this != internal_default_instance()) delete outer_window_size_;
}

void Fingerprint_TransientState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_TransientState::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.TransientState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(inner_window_size_ != nullptr);
      inner_window_size_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(outer_window_size_ != nullptr);
      outer_window_size_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_TransientState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_inner_window_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_outer_window_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_TransientState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.TransientState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::inner_window_size(this),
        _Internal::inner_window_size(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::outer_window_size(this),
        _Internal::outer_window_size(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.TransientState)
  return target;
}

size_t Fingerprint_TransientState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.TransientState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *inner_window_size_);
    }

    // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *outer_window_size_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_TransientState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_TransientState*>(
      &from));
}

void Fingerprint_TransientState::MergeFrom(const Fingerprint_TransientState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.TransientState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_inner_window_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_inner_window_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_outer_window_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_outer_window_size());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_TransientState::CopyFrom(const Fingerprint_TransientState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.TransientState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_TransientState::IsInitialized() const {
  return true;
}

void Fingerprint_TransientState::InternalSwap(Fingerprint_TransientState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_TransientState, outer_window_size_)
      + sizeof(Fingerprint_TransientState::outer_window_size_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_TransientState, inner_window_size_)>(
          reinterpret_cast<char*>(&inner_window_size_),
          reinterpret_cast<char*>(&other->inner_window_size_));
}

std::string Fingerprint_TransientState::GetTypeName() const {
  return "autofill.risk.Fingerprint.TransientState";
}


// ===================================================================

class Fingerprint_Performance::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_Performance>()._has_bits_);
  static void set_has_bandwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_metered(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Fingerprint_Performance::Fingerprint_Performance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.Performance)
}
Fingerprint_Performance::Fingerprint_Performance(const Fingerprint_Performance& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  network_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_network_type()) {
    network_type_.Set(from._internal_network_type(), 
      GetArenaForAllocation());
  }
  ::memcpy(&bandwidth_, &from.bandwidth_,
    static_cast<size_t>(reinterpret_cast<char*>(&metered_) -
    reinterpret_cast<char*>(&bandwidth_)) + sizeof(metered_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.Performance)
}

inline void Fingerprint_Performance::SharedCtor() {
network_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bandwidth_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&metered_) -
    reinterpret_cast<char*>(&bandwidth_)) + sizeof(metered_));
}

Fingerprint_Performance::~Fingerprint_Performance() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.Performance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_Performance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  network_type_.Destroy();
}

void Fingerprint_Performance::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_Performance::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.Performance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    network_type_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&bandwidth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&metered_) -
        reinterpret_cast<char*>(&bandwidth_)) + sizeof(metered_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_Performance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float bandwidth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_bandwidth(&has_bits);
          bandwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool metered = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_metered(&has_bits);
          metered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string network_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_network_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_Performance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.Performance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float bandwidth = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_bandwidth(), target);
  }

  // optional bool metered = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_metered(), target);
  }

  // optional string network_type = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_network_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.Performance)
  return target;
}

size_t Fingerprint_Performance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.Performance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string network_type = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_network_type());
    }

    // optional float bandwidth = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional bool metered = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_Performance::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_Performance*>(
      &from));
}

void Fingerprint_Performance::MergeFrom(const Fingerprint_Performance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.Performance)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_network_type(from._internal_network_type());
    }
    if (cached_has_bits & 0x00000002u) {
      bandwidth_ = from.bandwidth_;
    }
    if (cached_has_bits & 0x00000004u) {
      metered_ = from.metered_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_Performance::CopyFrom(const Fingerprint_Performance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.Performance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_Performance::IsInitialized() const {
  return true;
}

void Fingerprint_Performance::InternalSwap(Fingerprint_Performance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &network_type_, lhs_arena,
      &other->network_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_Performance, metered_)
      + sizeof(Fingerprint_Performance::metered_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_Performance, bandwidth_)>(
          reinterpret_cast<char*>(&bandwidth_),
          reinterpret_cast<char*>(&other->bandwidth_));
}

std::string Fingerprint_Performance::GetTypeName() const {
  return "autofill.risk.Fingerprint.Performance";
}


// ===================================================================

class Fingerprint_UserCharacteristics_Vector::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_UserCharacteristics_Vector>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Fingerprint_UserCharacteristics_Vector::Fingerprint_UserCharacteristics_Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.UserCharacteristics.Vector)
}
Fingerprint_UserCharacteristics_Vector::Fingerprint_UserCharacteristics_Vector(const Fingerprint_UserCharacteristics_Vector& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.UserCharacteristics.Vector)
}

inline void Fingerprint_UserCharacteristics_Vector::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Fingerprint_UserCharacteristics_Vector::~Fingerprint_UserCharacteristics_Vector() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_UserCharacteristics_Vector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_UserCharacteristics_Vector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_UserCharacteristics_Vector::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_UserCharacteristics_Vector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_UserCharacteristics_Vector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // optional int32 z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  return target;
}

size_t Fingerprint_UserCharacteristics_Vector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

    // optional int32 z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_UserCharacteristics_Vector::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_UserCharacteristics_Vector*>(
      &from));
}

void Fingerprint_UserCharacteristics_Vector::MergeFrom(const Fingerprint_UserCharacteristics_Vector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_UserCharacteristics_Vector::CopyFrom(const Fingerprint_UserCharacteristics_Vector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_UserCharacteristics_Vector::IsInitialized() const {
  return true;
}

void Fingerprint_UserCharacteristics_Vector::InternalSwap(Fingerprint_UserCharacteristics_Vector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Vector, z_)
      + sizeof(Fingerprint_UserCharacteristics_Vector::z_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Vector, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

std::string Fingerprint_UserCharacteristics_Vector::GetTypeName() const {
  return "autofill.risk.Fingerprint.UserCharacteristics.Vector";
}


// ===================================================================

class Fingerprint_UserCharacteristics_Location::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_UserCharacteristics_Location>()._has_bits_);
  static void set_has_altitude(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_time_in_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Fingerprint_UserCharacteristics_Location::Fingerprint_UserCharacteristics_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.UserCharacteristics.Location)
}
Fingerprint_UserCharacteristics_Location::Fingerprint_UserCharacteristics_Location(const Fingerprint_UserCharacteristics_Location& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&altitude_, &from.altitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_in_ms_) -
    reinterpret_cast<char*>(&altitude_)) + sizeof(time_in_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.UserCharacteristics.Location)
}

inline void Fingerprint_UserCharacteristics_Location::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&altitude_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_in_ms_) -
    reinterpret_cast<char*>(&altitude_)) + sizeof(time_in_ms_));
}

Fingerprint_UserCharacteristics_Location::~Fingerprint_UserCharacteristics_Location() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.UserCharacteristics.Location)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_UserCharacteristics_Location::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_UserCharacteristics_Location::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_UserCharacteristics_Location::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&altitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_in_ms_) -
        reinterpret_cast<char*>(&altitude_)) + sizeof(time_in_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_UserCharacteristics_Location::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double altitude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_altitude(&has_bits);
          altitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double latitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_latitude(&has_bits);
          latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double longitude = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_longitude(&has_bits);
          longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double accuracy = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_accuracy(&has_bits);
          accuracy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 time_in_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_time_in_ms(&has_bits);
          time_in_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_UserCharacteristics_Location::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double altitude = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_altitude(), target);
  }

  // optional double latitude = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_latitude(), target);
  }

  // optional double longitude = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_longitude(), target);
  }

  // optional double accuracy = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_accuracy(), target);
  }

  // optional int64 time_in_ms = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_time_in_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.UserCharacteristics.Location)
  return target;
}

size_t Fingerprint_UserCharacteristics_Location::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional double altitude = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double latitude = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double longitude = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double accuracy = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional int64 time_in_ms = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_in_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_UserCharacteristics_Location::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_UserCharacteristics_Location*>(
      &from));
}

void Fingerprint_UserCharacteristics_Location::MergeFrom(const Fingerprint_UserCharacteristics_Location& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      altitude_ = from.altitude_;
    }
    if (cached_has_bits & 0x00000002u) {
      latitude_ = from.latitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      longitude_ = from.longitude_;
    }
    if (cached_has_bits & 0x00000008u) {
      accuracy_ = from.accuracy_;
    }
    if (cached_has_bits & 0x00000010u) {
      time_in_ms_ = from.time_in_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_UserCharacteristics_Location::CopyFrom(const Fingerprint_UserCharacteristics_Location& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_UserCharacteristics_Location::IsInitialized() const {
  return true;
}

void Fingerprint_UserCharacteristics_Location::InternalSwap(Fingerprint_UserCharacteristics_Location* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Location, time_in_ms_)
      + sizeof(Fingerprint_UserCharacteristics_Location::time_in_ms_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Location, altitude_)>(
          reinterpret_cast<char*>(&altitude_),
          reinterpret_cast<char*>(&other->altitude_));
}

std::string Fingerprint_UserCharacteristics_Location::GetTypeName() const {
  return "autofill.risk.Fingerprint.UserCharacteristics.Location";
}


// ===================================================================

class Fingerprint_UserCharacteristics::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_UserCharacteristics>()._has_bits_);
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_touch_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_touch_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_touch_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_orientation(const Fingerprint_UserCharacteristics* msg);
  static void set_has_device_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_acceleration(const Fingerprint_UserCharacteristics* msg);
  static void set_has_device_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill::risk::Fingerprint_UserCharacteristics_Location& location(const Fingerprint_UserCharacteristics* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill::risk::Fingerprint_UserCharacteristics_Vector&
Fingerprint_UserCharacteristics::_Internal::device_orientation(const Fingerprint_UserCharacteristics* msg) {
  return *msg->device_orientation_;
}
const ::autofill::risk::Fingerprint_UserCharacteristics_Vector&
Fingerprint_UserCharacteristics::_Internal::device_acceleration(const Fingerprint_UserCharacteristics* msg) {
  return *msg->device_acceleration_;
}
const ::autofill::risk::Fingerprint_UserCharacteristics_Location&
Fingerprint_UserCharacteristics::_Internal::location(const Fingerprint_UserCharacteristics* msg) {
  return *msg->location_;
}
Fingerprint_UserCharacteristics::Fingerprint_UserCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.UserCharacteristics)
}
Fingerprint_UserCharacteristics::Fingerprint_UserCharacteristics(const Fingerprint_UserCharacteristics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_device_orientation()) {
    device_orientation_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Vector(*from.device_orientation_);
  } else {
    device_orientation_ = nullptr;
  }
  if (from._internal_has_device_acceleration()) {
    device_acceleration_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Vector(*from.device_acceleration_);
  } else {
    device_acceleration_ = nullptr;
  }
  if (from._internal_has_location()) {
    location_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Location(*from.location_);
  } else {
    location_ = nullptr;
  }
  ::memcpy(&force_, &from.force_,
    static_cast<size_t>(reinterpret_cast<char*>(&touch_rotation_) -
    reinterpret_cast<char*>(&force_)) + sizeof(touch_rotation_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.UserCharacteristics)
}

inline void Fingerprint_UserCharacteristics::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_orientation_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&touch_rotation_) -
    reinterpret_cast<char*>(&device_orientation_)) + sizeof(touch_rotation_));
}

Fingerprint_UserCharacteristics::~Fingerprint_UserCharacteristics() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.UserCharacteristics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_UserCharacteristics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete device_orientation_;
  if (this != internal_default_instance()) delete device_acceleration_;
  if (this != internal_default_instance()) delete location_;
}

void Fingerprint_UserCharacteristics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_UserCharacteristics::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.UserCharacteristics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(device_orientation_ != nullptr);
      device_orientation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(device_acceleration_ != nullptr);
      device_acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(location_ != nullptr);
      location_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&force_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&touch_rotation_) -
        reinterpret_cast<char*>(&force_)) + sizeof(touch_rotation_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_UserCharacteristics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float force = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_force(&has_bits);
          force_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float touch_width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_touch_width(&has_bits);
          touch_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float touch_height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_touch_height(&has_bits);
          touch_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 touch_rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_touch_rotation(&has_bits);
          touch_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_orientation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_UserCharacteristics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.UserCharacteristics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float force = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_force(), target);
  }

  // optional float touch_width = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_touch_width(), target);
  }

  // optional float touch_height = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_touch_height(), target);
  }

  // optional int32 touch_rotation = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_touch_rotation(), target);
  }

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::device_orientation(this),
        _Internal::device_orientation(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::device_acceleration(this),
        _Internal::device_acceleration(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.UserCharacteristics)
  return target;
}

size_t Fingerprint_UserCharacteristics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.UserCharacteristics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_orientation_);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_acceleration_);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *location_);
    }

    // optional float force = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float touch_width = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float touch_height = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 touch_rotation = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_touch_rotation());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_UserCharacteristics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_UserCharacteristics*>(
      &from));
}

void Fingerprint_UserCharacteristics::MergeFrom(const Fingerprint_UserCharacteristics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.UserCharacteristics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_device_orientation()->::autofill::risk::Fingerprint_UserCharacteristics_Vector::MergeFrom(from._internal_device_orientation());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_device_acceleration()->::autofill::risk::Fingerprint_UserCharacteristics_Vector::MergeFrom(from._internal_device_acceleration());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_location()->::autofill::risk::Fingerprint_UserCharacteristics_Location::MergeFrom(from._internal_location());
    }
    if (cached_has_bits & 0x00000008u) {
      force_ = from.force_;
    }
    if (cached_has_bits & 0x00000010u) {
      touch_width_ = from.touch_width_;
    }
    if (cached_has_bits & 0x00000020u) {
      touch_height_ = from.touch_height_;
    }
    if (cached_has_bits & 0x00000040u) {
      touch_rotation_ = from.touch_rotation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_UserCharacteristics::CopyFrom(const Fingerprint_UserCharacteristics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.UserCharacteristics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_UserCharacteristics::IsInitialized() const {
  return true;
}

void Fingerprint_UserCharacteristics::InternalSwap(Fingerprint_UserCharacteristics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics, touch_rotation_)
      + sizeof(Fingerprint_UserCharacteristics::touch_rotation_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics, device_orientation_)>(
          reinterpret_cast<char*>(&device_orientation_),
          reinterpret_cast<char*>(&other->device_orientation_));
}

std::string Fingerprint_UserCharacteristics::GetTypeName() const {
  return "autofill.risk.Fingerprint.UserCharacteristics";
}


// ===================================================================

class Fingerprint_Metadata::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint_Metadata>()._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_obfuscated_gaia_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fingerprinter_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Fingerprint_Metadata::Fingerprint_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.Metadata)
}
Fingerprint_Metadata::Fingerprint_Metadata(const Fingerprint_Metadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&timestamp_ms_, &from.timestamp_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&fingerprinter_version_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(fingerprinter_version_));
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.Metadata)
}

inline void Fingerprint_Metadata::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fingerprinter_version_) -
    reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(fingerprinter_version_));
}

Fingerprint_Metadata::~Fingerprint_Metadata() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.Metadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint_Metadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_Metadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint_Metadata::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.Metadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fingerprinter_version_) -
        reinterpret_cast<char*>(&timestamp_ms_)) + sizeof(fingerprinter_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_Metadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_ms(&has_bits);
          timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 obfuscated_gaia_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_obfuscated_gaia_id(&has_bits);
          obfuscated_gaia_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fingerprinter_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fingerprinter_version(&has_bits);
          fingerprinter_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_Metadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.Metadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
  }

  // optional uint64 obfuscated_gaia_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_obfuscated_gaia_id(), target);
  }

  // optional int32 fingerprinter_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_fingerprinter_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.Metadata)
  return target;
}

size_t Fingerprint_Metadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.Metadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
    }

    // optional uint64 obfuscated_gaia_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_obfuscated_gaia_id());
    }

    // optional int32 fingerprinter_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_fingerprinter_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint_Metadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint_Metadata*>(
      &from));
}

void Fingerprint_Metadata::MergeFrom(const Fingerprint_Metadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.Metadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ms_ = from.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      obfuscated_gaia_id_ = from.obfuscated_gaia_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      fingerprinter_version_ = from.fingerprinter_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_Metadata::CopyFrom(const Fingerprint_Metadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.Metadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint_Metadata::IsInitialized() const {
  return true;
}

void Fingerprint_Metadata::InternalSwap(Fingerprint_Metadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint_Metadata, fingerprinter_version_)
      + sizeof(Fingerprint_Metadata::fingerprinter_version_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint_Metadata, timestamp_ms_)>(
          reinterpret_cast<char*>(&timestamp_ms_),
          reinterpret_cast<char*>(&other->timestamp_ms_));
}

std::string Fingerprint_Metadata::GetTypeName() const {
  return "autofill.risk.Fingerprint.Metadata";
}


// ===================================================================

class Fingerprint::_Internal {
 public:
  using HasBits = decltype(std::declval<Fingerprint>()._has_bits_);
  static const ::autofill::risk::Fingerprint_MachineCharacteristics& machine_characteristics(const Fingerprint* msg);
  static void set_has_machine_characteristics(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill::risk::Fingerprint_Performance& performance(const Fingerprint* msg);
  static void set_has_performance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill::risk::Fingerprint_UserCharacteristics& user_characteristics(const Fingerprint* msg);
  static void set_has_user_characteristics(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill::risk::Fingerprint_TransientState& transient_state(const Fingerprint* msg);
  static void set_has_transient_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill::risk::Fingerprint_Metadata& metadata(const Fingerprint* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::autofill::risk::Fingerprint_MachineCharacteristics&
Fingerprint::_Internal::machine_characteristics(const Fingerprint* msg) {
  return *msg->machine_characteristics_;
}
const ::autofill::risk::Fingerprint_Performance&
Fingerprint::_Internal::performance(const Fingerprint* msg) {
  return *msg->performance_;
}
const ::autofill::risk::Fingerprint_UserCharacteristics&
Fingerprint::_Internal::user_characteristics(const Fingerprint* msg) {
  return *msg->user_characteristics_;
}
const ::autofill::risk::Fingerprint_TransientState&
Fingerprint::_Internal::transient_state(const Fingerprint* msg) {
  return *msg->transient_state_;
}
const ::autofill::risk::Fingerprint_Metadata&
Fingerprint::_Internal::metadata(const Fingerprint* msg) {
  return *msg->metadata_;
}
Fingerprint::Fingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint)
}
Fingerprint::Fingerprint(const Fingerprint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_machine_characteristics()) {
    machine_characteristics_ = new ::autofill::risk::Fingerprint_MachineCharacteristics(*from.machine_characteristics_);
  } else {
    machine_characteristics_ = nullptr;
  }
  if (from._internal_has_performance()) {
    performance_ = new ::autofill::risk::Fingerprint_Performance(*from.performance_);
  } else {
    performance_ = nullptr;
  }
  if (from._internal_has_user_characteristics()) {
    user_characteristics_ = new ::autofill::risk::Fingerprint_UserCharacteristics(*from.user_characteristics_);
  } else {
    user_characteristics_ = nullptr;
  }
  if (from._internal_has_transient_state()) {
    transient_state_ = new ::autofill::risk::Fingerprint_TransientState(*from.transient_state_);
  } else {
    transient_state_ = nullptr;
  }
  if (from._internal_has_metadata()) {
    metadata_ = new ::autofill::risk::Fingerprint_Metadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint)
}

inline void Fingerprint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&machine_characteristics_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&metadata_) -
    reinterpret_cast<char*>(&machine_characteristics_)) + sizeof(metadata_));
}

Fingerprint::~Fingerprint() {
  // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Fingerprint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete machine_characteristics_;
  if (this != internal_default_instance()) delete performance_;
  if (this != internal_default_instance()) delete user_characteristics_;
  if (this != internal_default_instance()) delete transient_state_;
  if (this != internal_default_instance()) delete metadata_;
}

void Fingerprint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Fingerprint::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(machine_characteristics_ != nullptr);
      machine_characteristics_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(performance_ != nullptr);
      performance_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(user_characteristics_ != nullptr);
      user_characteristics_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(transient_state_ != nullptr);
      transient_state_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(metadata_ != nullptr);
      metadata_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_machine_characteristics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.Performance performance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_performance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_characteristics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_transient_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Fingerprint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::machine_characteristics(this),
        _Internal::machine_characteristics(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.Performance performance = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::performance(this),
        _Internal::performance(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::user_characteristics(this),
        _Internal::user_characteristics(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::transient_state(this),
        _Internal::transient_state(this).GetCachedSize(), target, stream);
  }

  // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint)
  return target;
}

size_t Fingerprint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *machine_characteristics_);
    }

    // optional .autofill.risk.Fingerprint.Performance performance = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *performance_);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_characteristics_);
    }

    // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transient_state_);
    }

    // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Fingerprint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Fingerprint*>(
      &from));
}

void Fingerprint::MergeFrom(const Fingerprint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_machine_characteristics()->::autofill::risk::Fingerprint_MachineCharacteristics::MergeFrom(from._internal_machine_characteristics());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_performance()->::autofill::risk::Fingerprint_Performance::MergeFrom(from._internal_performance());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_user_characteristics()->::autofill::risk::Fingerprint_UserCharacteristics::MergeFrom(from._internal_user_characteristics());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_transient_state()->::autofill::risk::Fingerprint_TransientState::MergeFrom(from._internal_transient_state());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_metadata()->::autofill::risk::Fingerprint_Metadata::MergeFrom(from._internal_metadata());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint::CopyFrom(const Fingerprint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fingerprint::IsInitialized() const {
  return true;
}

void Fingerprint::InternalSwap(Fingerprint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Fingerprint, metadata_)
      + sizeof(Fingerprint::metadata_)
      - PROTOBUF_FIELD_OFFSET(Fingerprint, machine_characteristics_)>(
          reinterpret_cast<char*>(&machine_characteristics_),
          reinterpret_cast<char*>(&other->machine_characteristics_));
}

std::string Fingerprint::GetTypeName() const {
  return "autofill.risk.Fingerprint";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace risk
}  // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_Dimension*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_Dimension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_Dimension >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_MachineCharacteristics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_MachineCharacteristics >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_TransientState*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_TransientState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_TransientState >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_Performance*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_Performance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_Performance >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_UserCharacteristics_Vector*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_UserCharacteristics_Vector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_UserCharacteristics_Vector >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_UserCharacteristics_Location*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_UserCharacteristics_Location >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_UserCharacteristics_Location >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_UserCharacteristics*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_UserCharacteristics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_UserCharacteristics >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_Metadata*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint_Metadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint_Metadata >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint*
Arena::CreateMaybeMessage< ::autofill::risk::Fingerprint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill::risk::Fingerprint >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
