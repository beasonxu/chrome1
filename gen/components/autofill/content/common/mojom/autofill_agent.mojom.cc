// components/autofill/content/common/mojom/autofill_agent.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "components/autofill/content/common/mojom/autofill_agent.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/autofill/content/common/mojom/autofill_agent.mojom-params-data.h"
#include "components/autofill/content/common/mojom/autofill_agent.mojom-shared-message-ids.h"

#include "components/autofill/content/common/mojom/autofill_agent.mojom-import-headers.h"
#include "components/autofill/content/common/mojom/autofill_agent.mojom-test-utils.h"


#ifndef COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_AGENT_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_AGENT_MOJOM_JUMBO_H_
#endif



namespace autofill {
namespace mojom {
const char AutofillAgent::Name_[] = "autofill.mojom.AutofillAgent";

AutofillAgent::IPCStableHashFunction AutofillAgent::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kAutofillAgent_TriggerReparse_Name: {
      return &AutofillAgent::TriggerReparse_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_FillOrPreviewForm_Name: {
      return &AutofillAgent::FillOrPreviewForm_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_FieldTypePredictionsAvailable_Name: {
      return &AutofillAgent::FieldTypePredictionsAvailable_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_ClearSection_Name: {
      return &AutofillAgent::ClearSection_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_ClearPreviewedForm_Name: {
      return &AutofillAgent::ClearPreviewedForm_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_FillFieldWithValue_Name: {
      return &AutofillAgent::FillFieldWithValue_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_PreviewFieldWithValue_Name: {
      return &AutofillAgent::PreviewFieldWithValue_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetSuggestionAvailability_Name: {
      return &AutofillAgent::SetSuggestionAvailability_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_AcceptDataListSuggestion_Name: {
      return &AutofillAgent::AcceptDataListSuggestion_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_FillPasswordSuggestion_Name: {
      return &AutofillAgent::FillPasswordSuggestion_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_PreviewPasswordSuggestion_Name: {
      return &AutofillAgent::PreviewPasswordSuggestion_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetUserGestureRequired_Name: {
      return &AutofillAgent::SetUserGestureRequired_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetSecureContextRequired_Name: {
      return &AutofillAgent::SetSecureContextRequired_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetFocusRequiresScroll_Name: {
      return &AutofillAgent::SetFocusRequiresScroll_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetQueryPasswordSuggestion_Name: {
      return &AutofillAgent::SetQueryPasswordSuggestion_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name: {
      return &AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetAssistantKeyboardSuppressState_Name: {
      return &AutofillAgent::SetAssistantKeyboardSuppressState_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_EnableHeavyFormDataScraping_Name: {
      return &AutofillAgent::EnableHeavyFormDataScraping_Sym::IPCStableHash;
    }
    case internal::kAutofillAgent_SetFieldsEligibleForManualFilling_Name: {
      return &AutofillAgent::SetFieldsEligibleForManualFilling_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* AutofillAgent::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kAutofillAgent_TriggerReparse_Name:
            return "Receive autofill::mojom::AutofillAgent::TriggerReparse";
      case internal::kAutofillAgent_FillOrPreviewForm_Name:
            return "Receive autofill::mojom::AutofillAgent::FillOrPreviewForm";
      case internal::kAutofillAgent_FieldTypePredictionsAvailable_Name:
            return "Receive autofill::mojom::AutofillAgent::FieldTypePredictionsAvailable";
      case internal::kAutofillAgent_ClearSection_Name:
            return "Receive autofill::mojom::AutofillAgent::ClearSection";
      case internal::kAutofillAgent_ClearPreviewedForm_Name:
            return "Receive autofill::mojom::AutofillAgent::ClearPreviewedForm";
      case internal::kAutofillAgent_FillFieldWithValue_Name:
            return "Receive autofill::mojom::AutofillAgent::FillFieldWithValue";
      case internal::kAutofillAgent_PreviewFieldWithValue_Name:
            return "Receive autofill::mojom::AutofillAgent::PreviewFieldWithValue";
      case internal::kAutofillAgent_SetSuggestionAvailability_Name:
            return "Receive autofill::mojom::AutofillAgent::SetSuggestionAvailability";
      case internal::kAutofillAgent_AcceptDataListSuggestion_Name:
            return "Receive autofill::mojom::AutofillAgent::AcceptDataListSuggestion";
      case internal::kAutofillAgent_FillPasswordSuggestion_Name:
            return "Receive autofill::mojom::AutofillAgent::FillPasswordSuggestion";
      case internal::kAutofillAgent_PreviewPasswordSuggestion_Name:
            return "Receive autofill::mojom::AutofillAgent::PreviewPasswordSuggestion";
      case internal::kAutofillAgent_SetUserGestureRequired_Name:
            return "Receive autofill::mojom::AutofillAgent::SetUserGestureRequired";
      case internal::kAutofillAgent_SetSecureContextRequired_Name:
            return "Receive autofill::mojom::AutofillAgent::SetSecureContextRequired";
      case internal::kAutofillAgent_SetFocusRequiresScroll_Name:
            return "Receive autofill::mojom::AutofillAgent::SetFocusRequiresScroll";
      case internal::kAutofillAgent_SetQueryPasswordSuggestion_Name:
            return "Receive autofill::mojom::AutofillAgent::SetQueryPasswordSuggestion";
      case internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name:
            return "Receive autofill::mojom::AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId";
      case internal::kAutofillAgent_SetAssistantKeyboardSuppressState_Name:
            return "Receive autofill::mojom::AutofillAgent::SetAssistantKeyboardSuppressState";
      case internal::kAutofillAgent_EnableHeavyFormDataScraping_Name:
            return "Receive autofill::mojom::AutofillAgent::EnableHeavyFormDataScraping";
      case internal::kAutofillAgent_SetFieldsEligibleForManualFilling_Name:
            return "Receive autofill::mojom::AutofillAgent::SetFieldsEligibleForManualFilling";
    }
  } else {
    switch (message.name()) {
      case internal::kAutofillAgent_TriggerReparse_Name:
            return "Receive reply autofill::mojom::AutofillAgent::TriggerReparse";
      case internal::kAutofillAgent_FillOrPreviewForm_Name:
            return "Receive reply autofill::mojom::AutofillAgent::FillOrPreviewForm";
      case internal::kAutofillAgent_FieldTypePredictionsAvailable_Name:
            return "Receive reply autofill::mojom::AutofillAgent::FieldTypePredictionsAvailable";
      case internal::kAutofillAgent_ClearSection_Name:
            return "Receive reply autofill::mojom::AutofillAgent::ClearSection";
      case internal::kAutofillAgent_ClearPreviewedForm_Name:
            return "Receive reply autofill::mojom::AutofillAgent::ClearPreviewedForm";
      case internal::kAutofillAgent_FillFieldWithValue_Name:
            return "Receive reply autofill::mojom::AutofillAgent::FillFieldWithValue";
      case internal::kAutofillAgent_PreviewFieldWithValue_Name:
            return "Receive reply autofill::mojom::AutofillAgent::PreviewFieldWithValue";
      case internal::kAutofillAgent_SetSuggestionAvailability_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetSuggestionAvailability";
      case internal::kAutofillAgent_AcceptDataListSuggestion_Name:
            return "Receive reply autofill::mojom::AutofillAgent::AcceptDataListSuggestion";
      case internal::kAutofillAgent_FillPasswordSuggestion_Name:
            return "Receive reply autofill::mojom::AutofillAgent::FillPasswordSuggestion";
      case internal::kAutofillAgent_PreviewPasswordSuggestion_Name:
            return "Receive reply autofill::mojom::AutofillAgent::PreviewPasswordSuggestion";
      case internal::kAutofillAgent_SetUserGestureRequired_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetUserGestureRequired";
      case internal::kAutofillAgent_SetSecureContextRequired_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetSecureContextRequired";
      case internal::kAutofillAgent_SetFocusRequiresScroll_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetFocusRequiresScroll";
      case internal::kAutofillAgent_SetQueryPasswordSuggestion_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetQueryPasswordSuggestion";
      case internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name:
            return "Receive reply autofill::mojom::AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId";
      case internal::kAutofillAgent_SetAssistantKeyboardSuppressState_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetAssistantKeyboardSuppressState";
      case internal::kAutofillAgent_EnableHeavyFormDataScraping_Name:
            return "Receive reply autofill::mojom::AutofillAgent::EnableHeavyFormDataScraping";
      case internal::kAutofillAgent_SetFieldsEligibleForManualFilling_Name:
            return "Receive reply autofill::mojom::AutofillAgent::SetFieldsEligibleForManualFilling";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t AutofillAgent::TriggerReparse_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::TriggerReparse");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::FillOrPreviewForm_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::FillOrPreviewForm");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::FieldTypePredictionsAvailable_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::FieldTypePredictionsAvailable");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::ClearSection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::ClearSection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::ClearPreviewedForm_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::ClearPreviewedForm");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::FillFieldWithValue_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::FillFieldWithValue");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::PreviewFieldWithValue_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::PreviewFieldWithValue");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetSuggestionAvailability_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetSuggestionAvailability");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::AcceptDataListSuggestion_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::AcceptDataListSuggestion");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::FillPasswordSuggestion_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::FillPasswordSuggestion");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::PreviewPasswordSuggestion_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::PreviewPasswordSuggestion");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetUserGestureRequired_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetUserGestureRequired");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetSecureContextRequired_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetSecureContextRequired");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetFocusRequiresScroll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetFocusRequiresScroll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetQueryPasswordSuggestion_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetQueryPasswordSuggestion");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetAssistantKeyboardSuppressState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetAssistantKeyboardSuppressState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::EnableHeavyFormDataScraping_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::EnableHeavyFormDataScraping");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillAgent::SetFieldsEligibleForManualFilling_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillAgent::SetFieldsEligibleForManualFilling");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback(
      AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeIdCallback callback
      ) : callback_(std::move(callback)) {
  }

  AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback(const AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback&) = delete;
  AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback& operator=(const AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeIdCallback callback_;
};

AutofillAgentProxy::AutofillAgentProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AutofillAgentProxy::TriggerReparse(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillAgent::TriggerReparse");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_TriggerReparse_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_TriggerReparse_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("TriggerReparse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::FillOrPreviewForm(
    int32_t in_query_id, const ::autofill::FormData& in_form, ::autofill::mojom::RendererFormDataAction in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::FillOrPreviewForm", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query_id"), in_query_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("action"), in_action,
                        "<value of type ::autofill::mojom::RendererFormDataAction>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_FillOrPreviewForm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_FillOrPreviewForm_Params_Data> params(
          message);
  params.Allocate();
  params->query_id = in_query_id;
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillAgent.FillOrPreviewForm request");
  mojo::internal::Serialize<::autofill::mojom::RendererFormDataAction>(
      in_action, &params->action);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("FillOrPreviewForm");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::FieldTypePredictionsAvailable(
    const std::vector<::autofill::FormDataPredictions>& in_forms) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::FieldTypePredictionsAvailable", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("forms"), in_forms,
                        "<value of type const std::vector<::autofill::FormDataPredictions>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_FieldTypePredictionsAvailable_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_FieldTypePredictionsAvailable_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->forms)::BaseType>
      forms_fragment(params.message());
  const mojo::internal::ContainerValidateParams forms_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataPredictionsDataView>>(
      in_forms, forms_fragment, &forms_validate_params);
  params->forms.Set(
      forms_fragment.is_null() ? nullptr : forms_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->forms.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null forms in AutofillAgent.FieldTypePredictionsAvailable request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("FieldTypePredictionsAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::ClearSection(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillAgent::ClearSection");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_ClearSection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_ClearSection_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("ClearSection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::ClearPreviewedForm(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillAgent::ClearPreviewedForm");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_ClearPreviewedForm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_ClearPreviewedForm_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("ClearPreviewedForm");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::FillFieldWithValue(
    ::autofill::FieldRendererId in_field, const ::std::u16string& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::FillFieldWithValue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_FillFieldWithValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_FillFieldWithValue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillAgent.FillFieldWithValue request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in AutofillAgent.FillFieldWithValue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("FillFieldWithValue");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::PreviewFieldWithValue(
    ::autofill::FieldRendererId in_field, const ::std::u16string& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::PreviewFieldWithValue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_PreviewFieldWithValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_PreviewFieldWithValue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillAgent.PreviewFieldWithValue request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in AutofillAgent.PreviewFieldWithValue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("PreviewFieldWithValue");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::SetSuggestionAvailability(
    ::autofill::FieldRendererId in_field, ::autofill::mojom::AutofillState in_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetSuggestionAvailability", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("type"), in_type,
                        "<value of type ::autofill::mojom::AutofillState>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetSuggestionAvailability_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetSuggestionAvailability_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillAgent.SetSuggestionAvailability request");
  mojo::internal::Serialize<::autofill::mojom::AutofillState>(
      in_type, &params->type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetSuggestionAvailability");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::AcceptDataListSuggestion(
    ::autofill::FieldRendererId in_field, const ::std::u16string& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::AcceptDataListSuggestion", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_AcceptDataListSuggestion_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_AcceptDataListSuggestion_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillAgent.AcceptDataListSuggestion request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in AutofillAgent.AcceptDataListSuggestion request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("AcceptDataListSuggestion");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::FillPasswordSuggestion(
    const ::std::u16string& in_username, const ::std::u16string& in_password) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::FillPasswordSuggestion", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("username"), in_username,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("password"), in_password,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_FillPasswordSuggestion_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_FillPasswordSuggestion_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->username)::BaseType> username_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_username, username_fragment);
  params->username.Set(
      username_fragment.is_null() ? nullptr : username_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->username.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null username in AutofillAgent.FillPasswordSuggestion request");
  mojo::internal::MessageFragment<
      typename decltype(params->password)::BaseType> password_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_password, password_fragment);
  params->password.Set(
      password_fragment.is_null() ? nullptr : password_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password in AutofillAgent.FillPasswordSuggestion request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("FillPasswordSuggestion");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::PreviewPasswordSuggestion(
    const ::std::u16string& in_username, const ::std::u16string& in_password) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::PreviewPasswordSuggestion", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("username"), in_username,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("password"), in_password,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_PreviewPasswordSuggestion_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_PreviewPasswordSuggestion_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->username)::BaseType> username_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_username, username_fragment);
  params->username.Set(
      username_fragment.is_null() ? nullptr : username_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->username.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null username in AutofillAgent.PreviewPasswordSuggestion request");
  mojo::internal::MessageFragment<
      typename decltype(params->password)::BaseType> password_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_password, password_fragment);
  params->password.Set(
      password_fragment.is_null() ? nullptr : password_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password in AutofillAgent.PreviewPasswordSuggestion request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("PreviewPasswordSuggestion");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::SetUserGestureRequired(
    bool in_required) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetUserGestureRequired", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("required"), in_required,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetUserGestureRequired_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetUserGestureRequired_Params_Data> params(
          message);
  params.Allocate();
  params->required = in_required;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetUserGestureRequired");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::SetSecureContextRequired(
    bool in_required) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetSecureContextRequired", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("required"), in_required,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetSecureContextRequired_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetSecureContextRequired_Params_Data> params(
          message);
  params.Allocate();
  params->required = in_required;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetSecureContextRequired");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::SetFocusRequiresScroll(
    bool in_require) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetFocusRequiresScroll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("require"), in_require,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetFocusRequiresScroll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetFocusRequiresScroll_Params_Data> params(
          message);
  params.Allocate();
  params->require = in_require;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetFocusRequiresScroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::SetQueryPasswordSuggestion(
    bool in_query) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetQueryPasswordSuggestion", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query"), in_query,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetQueryPasswordSuggestion_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetQueryPasswordSuggestion_Params_Data> params(
          message);
  params.Allocate();
  params->query = in_query;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetQueryPasswordSuggestion");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::GetElementFormAndFieldDataForDevToolsNodeId(
    int32_t in_backend_node_id, GetElementFormAndFieldDataForDevToolsNodeIdCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("backend_node_id"), in_backend_node_id,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Params_Data> params(
          message);
  params.Allocate();
  params->backend_node_id = in_backend_node_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("GetElementFormAndFieldDataForDevToolsNodeId");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void AutofillAgentProxy::SetAssistantKeyboardSuppressState(
    bool in_suppress) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetAssistantKeyboardSuppressState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("suppress"), in_suppress,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetAssistantKeyboardSuppressState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetAssistantKeyboardSuppressState_Params_Data> params(
          message);
  params.Allocate();
  params->suppress = in_suppress;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetAssistantKeyboardSuppressState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::EnableHeavyFormDataScraping(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillAgent::EnableHeavyFormDataScraping");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_EnableHeavyFormDataScraping_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_EnableHeavyFormDataScraping_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("EnableHeavyFormDataScraping");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillAgentProxy::SetFieldsEligibleForManualFilling(
    const std::vector<::autofill::FieldRendererId>& in_fields) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillAgent::SetFieldsEligibleForManualFilling", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("fields"), in_fields,
                        "<value of type const std::vector<::autofill::FieldRendererId>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_SetFieldsEligibleForManualFilling_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_SetFieldsEligibleForManualFilling_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->fields)::BaseType>
      fields_fragment(params.message());
  const mojo::internal::ContainerValidateParams fields_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FieldRendererIdDataView>>(
      in_fields, fields_fragment, &fields_validate_params);
  params->fields.Set(
      fields_fragment.is_null() ? nullptr : fields_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->fields.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null fields in AutofillAgent.SetFieldsEligibleForManualFilling request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("SetFieldsEligibleForManualFilling");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeIdCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder> proxy(
        new AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeIdCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field);
};

bool AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ResponseParams_Data* params =
      reinterpret_cast<
          internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::autofill::FormData p_form{};
  ::autofill::FormFieldData p_field{};
  AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadForm(&p_form))
    success = false;
  if (success && !input_data_view.ReadField(&p_field))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        AutofillAgent::Name_, 15, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_form), 
std::move(p_field));
  return true;
}

void AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder::Run(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply autofill::mojom::AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeId", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in ");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillAgent::Name_);
  message.set_method_name("GetElementFormAndFieldDataForDevToolsNodeId");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool AutofillAgentStubDispatch::Accept(
    AutofillAgent* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kAutofillAgent_TriggerReparse_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_TriggerReparse_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_TriggerReparse_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillAgent_TriggerReparse_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TriggerReparse();
      return true;
    }
    case internal::kAutofillAgent_FillOrPreviewForm_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_FillOrPreviewForm_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_FillOrPreviewForm_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_query_id{};
      ::autofill::FormData p_form{};
      ::autofill::mojom::RendererFormDataAction p_action{};
      AutofillAgent_FillOrPreviewForm_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_query_id = input_data_view.query_id();
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FillOrPreviewForm(
std::move(p_query_id), 
std::move(p_form), 
std::move(p_action));
      return true;
    }
    case internal::kAutofillAgent_FieldTypePredictionsAvailable_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_FieldTypePredictionsAvailable_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_FieldTypePredictionsAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::autofill::FormDataPredictions> p_forms{};
      AutofillAgent_FieldTypePredictionsAvailable_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForms(&p_forms))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FieldTypePredictionsAvailable(
std::move(p_forms));
      return true;
    }
    case internal::kAutofillAgent_ClearSection_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_ClearSection_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_ClearSection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillAgent_ClearSection_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearSection();
      return true;
    }
    case internal::kAutofillAgent_ClearPreviewedForm_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_ClearPreviewedForm_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_ClearPreviewedForm_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillAgent_ClearPreviewedForm_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearPreviewedForm();
      return true;
    }
    case internal::kAutofillAgent_FillFieldWithValue_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_FillFieldWithValue_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_FillFieldWithValue_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FieldRendererId p_field{};
      ::std::u16string p_value{};
      AutofillAgent_FillFieldWithValue_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FillFieldWithValue(
std::move(p_field), 
std::move(p_value));
      return true;
    }
    case internal::kAutofillAgent_PreviewFieldWithValue_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_PreviewFieldWithValue_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_PreviewFieldWithValue_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FieldRendererId p_field{};
      ::std::u16string p_value{};
      AutofillAgent_PreviewFieldWithValue_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PreviewFieldWithValue(
std::move(p_field), 
std::move(p_value));
      return true;
    }
    case internal::kAutofillAgent_SetSuggestionAvailability_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetSuggestionAvailability_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetSuggestionAvailability_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FieldRendererId p_field{};
      ::autofill::mojom::AutofillState p_type{};
      AutofillAgent_SetSuggestionAvailability_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSuggestionAvailability(
std::move(p_field), 
std::move(p_type));
      return true;
    }
    case internal::kAutofillAgent_AcceptDataListSuggestion_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_AcceptDataListSuggestion_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_AcceptDataListSuggestion_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FieldRendererId p_field{};
      ::std::u16string p_value{};
      AutofillAgent_AcceptDataListSuggestion_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AcceptDataListSuggestion(
std::move(p_field), 
std::move(p_value));
      return true;
    }
    case internal::kAutofillAgent_FillPasswordSuggestion_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_FillPasswordSuggestion_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_FillPasswordSuggestion_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_username{};
      ::std::u16string p_password{};
      AutofillAgent_FillPasswordSuggestion_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUsername(&p_username))
        success = false;
      if (success && !input_data_view.ReadPassword(&p_password))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FillPasswordSuggestion(
std::move(p_username), 
std::move(p_password));
      return true;
    }
    case internal::kAutofillAgent_PreviewPasswordSuggestion_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_PreviewPasswordSuggestion_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_PreviewPasswordSuggestion_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_username{};
      ::std::u16string p_password{};
      AutofillAgent_PreviewPasswordSuggestion_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUsername(&p_username))
        success = false;
      if (success && !input_data_view.ReadPassword(&p_password))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PreviewPasswordSuggestion(
std::move(p_username), 
std::move(p_password));
      return true;
    }
    case internal::kAutofillAgent_SetUserGestureRequired_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetUserGestureRequired_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetUserGestureRequired_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_required{};
      AutofillAgent_SetUserGestureRequired_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_required = input_data_view.required();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetUserGestureRequired(
std::move(p_required));
      return true;
    }
    case internal::kAutofillAgent_SetSecureContextRequired_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetSecureContextRequired_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetSecureContextRequired_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_required{};
      AutofillAgent_SetSecureContextRequired_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_required = input_data_view.required();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSecureContextRequired(
std::move(p_required));
      return true;
    }
    case internal::kAutofillAgent_SetFocusRequiresScroll_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetFocusRequiresScroll_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetFocusRequiresScroll_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_require{};
      AutofillAgent_SetFocusRequiresScroll_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_require = input_data_view.require();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFocusRequiresScroll(
std::move(p_require));
      return true;
    }
    case internal::kAutofillAgent_SetQueryPasswordSuggestion_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetQueryPasswordSuggestion_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetQueryPasswordSuggestion_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_query{};
      AutofillAgent_SetQueryPasswordSuggestion_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_query = input_data_view.query();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetQueryPasswordSuggestion(
std::move(p_query));
      return true;
    }
    case internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name: {
      break;
    }
    case internal::kAutofillAgent_SetAssistantKeyboardSuppressState_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetAssistantKeyboardSuppressState_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetAssistantKeyboardSuppressState_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_suppress{};
      AutofillAgent_SetAssistantKeyboardSuppressState_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_suppress = input_data_view.suppress();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetAssistantKeyboardSuppressState(
std::move(p_suppress));
      return true;
    }
    case internal::kAutofillAgent_EnableHeavyFormDataScraping_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_EnableHeavyFormDataScraping_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_EnableHeavyFormDataScraping_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillAgent_EnableHeavyFormDataScraping_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableHeavyFormDataScraping();
      return true;
    }
    case internal::kAutofillAgent_SetFieldsEligibleForManualFilling_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillAgent_SetFieldsEligibleForManualFilling_Params_Data* params =
          reinterpret_cast<internal::AutofillAgent_SetFieldsEligibleForManualFilling_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::autofill::FieldRendererId> p_fields{};
      AutofillAgent_SetFieldsEligibleForManualFilling_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFields(&p_fields))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFieldsEligibleForManualFilling(
std::move(p_fields));
      return true;
    }
  }
  return false;
}

// static
bool AutofillAgentStubDispatch::AcceptWithResponder(
    AutofillAgent* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kAutofillAgent_TriggerReparse_Name: {
      break;
    }
    case internal::kAutofillAgent_FillOrPreviewForm_Name: {
      break;
    }
    case internal::kAutofillAgent_FieldTypePredictionsAvailable_Name: {
      break;
    }
    case internal::kAutofillAgent_ClearSection_Name: {
      break;
    }
    case internal::kAutofillAgent_ClearPreviewedForm_Name: {
      break;
    }
    case internal::kAutofillAgent_FillFieldWithValue_Name: {
      break;
    }
    case internal::kAutofillAgent_PreviewFieldWithValue_Name: {
      break;
    }
    case internal::kAutofillAgent_SetSuggestionAvailability_Name: {
      break;
    }
    case internal::kAutofillAgent_AcceptDataListSuggestion_Name: {
      break;
    }
    case internal::kAutofillAgent_FillPasswordSuggestion_Name: {
      break;
    }
    case internal::kAutofillAgent_PreviewPasswordSuggestion_Name: {
      break;
    }
    case internal::kAutofillAgent_SetUserGestureRequired_Name: {
      break;
    }
    case internal::kAutofillAgent_SetSecureContextRequired_Name: {
      break;
    }
    case internal::kAutofillAgent_SetFocusRequiresScroll_Name: {
      break;
    }
    case internal::kAutofillAgent_SetQueryPasswordSuggestion_Name: {
      break;
    }
    case internal::kAutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Name: {

      internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Params_Data* params =
          reinterpret_cast<
              internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_backend_node_id{};
      AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_backend_node_id = input_data_view.backend_node_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillAgent::Name_, 15, false);
        return false;
      }
      AutofillAgent::GetElementFormAndFieldDataForDevToolsNodeIdCallback callback =
          AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetElementFormAndFieldDataForDevToolsNodeId(
std::move(p_backend_node_id), std::move(callback));
      return true;
    }
    case internal::kAutofillAgent_SetAssistantKeyboardSuppressState_Name: {
      break;
    }
    case internal::kAutofillAgent_EnableHeavyFormDataScraping_Name: {
      break;
    }
    case internal::kAutofillAgent_SetFieldsEligibleForManualFilling_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kAutofillAgentValidationInfo[] = {
    {&internal::AutofillAgent_TriggerReparse_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_FillOrPreviewForm_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_FieldTypePredictionsAvailable_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_ClearSection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_ClearPreviewedForm_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_FillFieldWithValue_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_PreviewFieldWithValue_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_SetSuggestionAvailability_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_AcceptDataListSuggestion_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_FillPasswordSuggestion_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_PreviewPasswordSuggestion_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_SetUserGestureRequired_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_SetSecureContextRequired_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_SetFocusRequiresScroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_SetQueryPasswordSuggestion_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_Params_Data::Validate,
     &internal::AutofillAgent_GetElementFormAndFieldDataForDevToolsNodeId_ResponseParams_Data::Validate},
    {&internal::AutofillAgent_SetAssistantKeyboardSuppressState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_EnableHeavyFormDataScraping_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillAgent_SetFieldsEligibleForManualFilling_Params_Data::Validate,
     nullptr /* no response */},
};

bool AutofillAgentRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::AutofillAgent::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kAutofillAgentValidationInfo);
}

bool AutofillAgentResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::AutofillAgent::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kAutofillAgentValidationInfo);
}
const char PasswordAutofillAgent::Name_[] = "autofill.mojom.PasswordAutofillAgent";

PasswordAutofillAgent::IPCStableHashFunction PasswordAutofillAgent::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPasswordAutofillAgent_FillPasswordForm_Name: {
      return &PasswordAutofillAgent::FillPasswordForm_Sym::IPCStableHash;
    }
    case internal::kPasswordAutofillAgent_InformNoSavedCredentials_Name: {
      return &PasswordAutofillAgent::InformNoSavedCredentials_Sym::IPCStableHash;
    }
    case internal::kPasswordAutofillAgent_FillIntoFocusedField_Name: {
      return &PasswordAutofillAgent::FillIntoFocusedField_Sym::IPCStableHash;
    }
    case internal::kPasswordAutofillAgent_SetLoggingState_Name: {
      return &PasswordAutofillAgent::SetLoggingState_Sym::IPCStableHash;
    }
    case internal::kPasswordAutofillAgent_TouchToFillClosed_Name: {
      return &PasswordAutofillAgent::TouchToFillClosed_Sym::IPCStableHash;
    }
    case internal::kPasswordAutofillAgent_TriggerFormSubmission_Name: {
      return &PasswordAutofillAgent::TriggerFormSubmission_Sym::IPCStableHash;
    }
    case internal::kPasswordAutofillAgent_AnnotateFieldsWithParsingResult_Name: {
      return &PasswordAutofillAgent::AnnotateFieldsWithParsingResult_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PasswordAutofillAgent::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPasswordAutofillAgent_FillPasswordForm_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::FillPasswordForm";
      case internal::kPasswordAutofillAgent_InformNoSavedCredentials_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::InformNoSavedCredentials";
      case internal::kPasswordAutofillAgent_FillIntoFocusedField_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::FillIntoFocusedField";
      case internal::kPasswordAutofillAgent_SetLoggingState_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::SetLoggingState";
      case internal::kPasswordAutofillAgent_TouchToFillClosed_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::TouchToFillClosed";
      case internal::kPasswordAutofillAgent_TriggerFormSubmission_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::TriggerFormSubmission";
      case internal::kPasswordAutofillAgent_AnnotateFieldsWithParsingResult_Name:
            return "Receive autofill::mojom::PasswordAutofillAgent::AnnotateFieldsWithParsingResult";
    }
  } else {
    switch (message.name()) {
      case internal::kPasswordAutofillAgent_FillPasswordForm_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::FillPasswordForm";
      case internal::kPasswordAutofillAgent_InformNoSavedCredentials_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::InformNoSavedCredentials";
      case internal::kPasswordAutofillAgent_FillIntoFocusedField_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::FillIntoFocusedField";
      case internal::kPasswordAutofillAgent_SetLoggingState_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::SetLoggingState";
      case internal::kPasswordAutofillAgent_TouchToFillClosed_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::TouchToFillClosed";
      case internal::kPasswordAutofillAgent_TriggerFormSubmission_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::TriggerFormSubmission";
      case internal::kPasswordAutofillAgent_AnnotateFieldsWithParsingResult_Name:
            return "Receive reply autofill::mojom::PasswordAutofillAgent::AnnotateFieldsWithParsingResult";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PasswordAutofillAgent::FillPasswordForm_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::FillPasswordForm");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordAutofillAgent::InformNoSavedCredentials_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::InformNoSavedCredentials");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordAutofillAgent::FillIntoFocusedField_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::FillIntoFocusedField");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordAutofillAgent::SetLoggingState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::SetLoggingState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordAutofillAgent::TouchToFillClosed_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::TouchToFillClosed");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordAutofillAgent::TriggerFormSubmission_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::TriggerFormSubmission");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordAutofillAgent::AnnotateFieldsWithParsingResult_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordAutofillAgent::AnnotateFieldsWithParsingResult");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

PasswordAutofillAgentProxy::PasswordAutofillAgentProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PasswordAutofillAgentProxy::FillPasswordForm(
    const ::autofill::PasswordFormFillData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordAutofillAgent::FillPasswordForm", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::PasswordFormFillData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_FillPasswordForm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_FillPasswordForm_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::PasswordFormFillDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordAutofillAgent.FillPasswordForm request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("FillPasswordForm");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordAutofillAgentProxy::InformNoSavedCredentials(
    bool in_should_show_popup_without_passwords) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordAutofillAgent::InformNoSavedCredentials", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("should_show_popup_without_passwords"), in_should_show_popup_without_passwords,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_InformNoSavedCredentials_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_InformNoSavedCredentials_Params_Data> params(
          message);
  params.Allocate();
  params->should_show_popup_without_passwords = in_should_show_popup_without_passwords;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("InformNoSavedCredentials");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordAutofillAgentProxy::FillIntoFocusedField(
    bool in_is_password, const ::std::u16string& in_credential) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordAutofillAgent::FillIntoFocusedField", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_password"), in_is_password,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("credential"), in_credential,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_FillIntoFocusedField_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_FillIntoFocusedField_Params_Data> params(
          message);
  params.Allocate();
  params->is_password = in_is_password;
  mojo::internal::MessageFragment<
      typename decltype(params->credential)::BaseType> credential_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_credential, credential_fragment);
  params->credential.Set(
      credential_fragment.is_null() ? nullptr : credential_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->credential.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null credential in PasswordAutofillAgent.FillIntoFocusedField request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("FillIntoFocusedField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordAutofillAgentProxy::SetLoggingState(
    bool in_active) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordAutofillAgent::SetLoggingState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("active"), in_active,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_SetLoggingState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_SetLoggingState_Params_Data> params(
          message);
  params.Allocate();
  params->active = in_active;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("SetLoggingState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordAutofillAgentProxy::TouchToFillClosed(
    bool in_show_virtual_keyboard) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordAutofillAgent::TouchToFillClosed", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("show_virtual_keyboard"), in_show_virtual_keyboard,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_TouchToFillClosed_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_TouchToFillClosed_Params_Data> params(
          message);
  params.Allocate();
  params->show_virtual_keyboard = in_show_virtual_keyboard;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("TouchToFillClosed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordAutofillAgentProxy::TriggerFormSubmission(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::PasswordAutofillAgent::TriggerFormSubmission");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_TriggerFormSubmission_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_TriggerFormSubmission_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("TriggerFormSubmission");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordAutofillAgentProxy::AnnotateFieldsWithParsingResult(
    const ::autofill::ParsingResult& in_parsing_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordAutofillAgent::AnnotateFieldsWithParsingResult", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("parsing_result"), in_parsing_result,
                        "<value of type const ::autofill::ParsingResult&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordAutofillAgent_AnnotateFieldsWithParsingResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordAutofillAgent_AnnotateFieldsWithParsingResult_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->parsing_result)::BaseType> parsing_result_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::ParsingResultDataView>(
      in_parsing_result, parsing_result_fragment);
  params->parsing_result.Set(
      parsing_result_fragment.is_null() ? nullptr : parsing_result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->parsing_result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null parsing_result in PasswordAutofillAgent.AnnotateFieldsWithParsingResult request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordAutofillAgent::Name_);
  message.set_method_name("AnnotateFieldsWithParsingResult");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PasswordAutofillAgentStubDispatch::Accept(
    PasswordAutofillAgent* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPasswordAutofillAgent_FillPasswordForm_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_FillPasswordForm_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_FillPasswordForm_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::PasswordFormFillData p_form_data{};
      PasswordAutofillAgent_FillPasswordForm_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FillPasswordForm(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordAutofillAgent_InformNoSavedCredentials_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_InformNoSavedCredentials_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_InformNoSavedCredentials_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_should_show_popup_without_passwords{};
      PasswordAutofillAgent_InformNoSavedCredentials_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_should_show_popup_without_passwords = input_data_view.should_show_popup_without_passwords();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->InformNoSavedCredentials(
std::move(p_should_show_popup_without_passwords));
      return true;
    }
    case internal::kPasswordAutofillAgent_FillIntoFocusedField_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_FillIntoFocusedField_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_FillIntoFocusedField_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_password{};
      ::std::u16string p_credential{};
      PasswordAutofillAgent_FillIntoFocusedField_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_password = input_data_view.is_password();
      if (success && !input_data_view.ReadCredential(&p_credential))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FillIntoFocusedField(
std::move(p_is_password), 
std::move(p_credential));
      return true;
    }
    case internal::kPasswordAutofillAgent_SetLoggingState_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_SetLoggingState_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_SetLoggingState_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_active{};
      PasswordAutofillAgent_SetLoggingState_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_active = input_data_view.active();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetLoggingState(
std::move(p_active));
      return true;
    }
    case internal::kPasswordAutofillAgent_TouchToFillClosed_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_TouchToFillClosed_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_TouchToFillClosed_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_show_virtual_keyboard{};
      PasswordAutofillAgent_TouchToFillClosed_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_show_virtual_keyboard = input_data_view.show_virtual_keyboard();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TouchToFillClosed(
std::move(p_show_virtual_keyboard));
      return true;
    }
    case internal::kPasswordAutofillAgent_TriggerFormSubmission_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_TriggerFormSubmission_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_TriggerFormSubmission_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PasswordAutofillAgent_TriggerFormSubmission_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TriggerFormSubmission();
      return true;
    }
    case internal::kPasswordAutofillAgent_AnnotateFieldsWithParsingResult_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordAutofillAgent_AnnotateFieldsWithParsingResult_Params_Data* params =
          reinterpret_cast<internal::PasswordAutofillAgent_AnnotateFieldsWithParsingResult_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::ParsingResult p_parsing_result{};
      PasswordAutofillAgent_AnnotateFieldsWithParsingResult_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParsingResult(&p_parsing_result))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordAutofillAgent::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AnnotateFieldsWithParsingResult(
std::move(p_parsing_result));
      return true;
    }
  }
  return false;
}

// static
bool PasswordAutofillAgentStubDispatch::AcceptWithResponder(
    PasswordAutofillAgent* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPasswordAutofillAgent_FillPasswordForm_Name: {
      break;
    }
    case internal::kPasswordAutofillAgent_InformNoSavedCredentials_Name: {
      break;
    }
    case internal::kPasswordAutofillAgent_FillIntoFocusedField_Name: {
      break;
    }
    case internal::kPasswordAutofillAgent_SetLoggingState_Name: {
      break;
    }
    case internal::kPasswordAutofillAgent_TouchToFillClosed_Name: {
      break;
    }
    case internal::kPasswordAutofillAgent_TriggerFormSubmission_Name: {
      break;
    }
    case internal::kPasswordAutofillAgent_AnnotateFieldsWithParsingResult_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPasswordAutofillAgentValidationInfo[] = {
    {&internal::PasswordAutofillAgent_FillPasswordForm_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordAutofillAgent_InformNoSavedCredentials_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordAutofillAgent_FillIntoFocusedField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordAutofillAgent_SetLoggingState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordAutofillAgent_TouchToFillClosed_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordAutofillAgent_TriggerFormSubmission_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordAutofillAgent_AnnotateFieldsWithParsingResult_Params_Data::Validate,
     nullptr /* no response */},
};

bool PasswordAutofillAgentRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordAutofillAgent::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPasswordAutofillAgentValidationInfo);
}

const char PasswordGenerationAgent::Name_[] = "autofill.mojom.PasswordGenerationAgent";

PasswordGenerationAgent::IPCStableHashFunction PasswordGenerationAgent::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPasswordGenerationAgent_GeneratedPasswordAccepted_Name: {
      return &PasswordGenerationAgent::GeneratedPasswordAccepted_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name: {
      return &PasswordGenerationAgent::TriggeredGeneratePassword_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationAgent_FoundFormEligibleForGeneration_Name: {
      return &PasswordGenerationAgent::FoundFormEligibleForGeneration_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PasswordGenerationAgent::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPasswordGenerationAgent_GeneratedPasswordAccepted_Name:
            return "Receive autofill::mojom::PasswordGenerationAgent::GeneratedPasswordAccepted";
      case internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name:
            return "Receive autofill::mojom::PasswordGenerationAgent::TriggeredGeneratePassword";
      case internal::kPasswordGenerationAgent_FoundFormEligibleForGeneration_Name:
            return "Receive autofill::mojom::PasswordGenerationAgent::FoundFormEligibleForGeneration";
    }
  } else {
    switch (message.name()) {
      case internal::kPasswordGenerationAgent_GeneratedPasswordAccepted_Name:
            return "Receive reply autofill::mojom::PasswordGenerationAgent::GeneratedPasswordAccepted";
      case internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name:
            return "Receive reply autofill::mojom::PasswordGenerationAgent::TriggeredGeneratePassword";
      case internal::kPasswordGenerationAgent_FoundFormEligibleForGeneration_Name:
            return "Receive reply autofill::mojom::PasswordGenerationAgent::FoundFormEligibleForGeneration";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PasswordGenerationAgent::GeneratedPasswordAccepted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationAgent::GeneratedPasswordAccepted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationAgent::TriggeredGeneratePassword_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationAgent::TriggeredGeneratePassword");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationAgent::FoundFormEligibleForGeneration_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationAgent::FoundFormEligibleForGeneration");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback(
      PasswordGenerationAgent::TriggeredGeneratePasswordCallback callback
      ) : callback_(std::move(callback)) {
  }

  PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback(const PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback&) = delete;
  PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback& operator=(const PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PasswordGenerationAgent::TriggeredGeneratePasswordCallback callback_;
};

PasswordGenerationAgentProxy::PasswordGenerationAgentProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PasswordGenerationAgentProxy::GeneratedPasswordAccepted(
    const ::std::u16string& in_generated_password) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordGenerationAgent::GeneratedPasswordAccepted", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("generated_password"), in_generated_password,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationAgent_GeneratedPasswordAccepted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationAgent_GeneratedPasswordAccepted_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->generated_password)::BaseType> generated_password_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_generated_password, generated_password_fragment);
  params->generated_password.Set(
      generated_password_fragment.is_null() ? nullptr : generated_password_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->generated_password.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null generated_password in PasswordGenerationAgent.GeneratedPasswordAccepted request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationAgent::Name_);
  message.set_method_name("GeneratedPasswordAccepted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationAgentProxy::TriggeredGeneratePassword(
    TriggeredGeneratePasswordCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::PasswordGenerationAgent::TriggeredGeneratePassword");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationAgent_TriggeredGeneratePassword_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationAgent::Name_);
  message.set_method_name("TriggeredGeneratePassword");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void PasswordGenerationAgentProxy::FoundFormEligibleForGeneration(
    const ::autofill::PasswordFormGenerationData& in_form) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordGenerationAgent::FoundFormEligibleForGeneration", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::PasswordFormGenerationData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationAgent_FoundFormEligibleForGeneration_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationAgent_FoundFormEligibleForGeneration_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::PasswordFormGenerationDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in PasswordGenerationAgent.FoundFormEligibleForGeneration request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationAgent::Name_);
  message.set_method_name("FoundFormEligibleForGeneration");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PasswordGenerationAgent::TriggeredGeneratePasswordCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder> proxy(
        new PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PasswordGenerationAgent::TriggeredGeneratePasswordCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<::autofill::password_generation::PasswordGenerationUIData>& in_data);
};

bool PasswordGenerationAgent_TriggeredGeneratePassword_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PasswordGenerationAgent_TriggeredGeneratePassword_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PasswordGenerationAgent_TriggeredGeneratePassword_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<::autofill::password_generation::PasswordGenerationUIData> p_data{};
  PasswordGenerationAgent_TriggeredGeneratePassword_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadData(&p_data))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PasswordGenerationAgent::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_data));
  return true;
}

void PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder::Run(
    const absl::optional<::autofill::password_generation::PasswordGenerationUIData>& in_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply autofill::mojom::PasswordGenerationAgent::TriggeredGeneratePassword", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type const absl::optional<::autofill::password_generation::PasswordGenerationUIData>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationAgent_TriggeredGeneratePassword_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType> data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::PasswordGenerationUIDataDataView>(
      in_data, data_fragment);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationAgent::Name_);
  message.set_method_name("TriggeredGeneratePassword");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PasswordGenerationAgentStubDispatch::Accept(
    PasswordGenerationAgent* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPasswordGenerationAgent_GeneratedPasswordAccepted_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationAgent_GeneratedPasswordAccepted_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationAgent_GeneratedPasswordAccepted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_generated_password{};
      PasswordGenerationAgent_GeneratedPasswordAccepted_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadGeneratedPassword(&p_generated_password))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationAgent::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GeneratedPasswordAccepted(
std::move(p_generated_password));
      return true;
    }
    case internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name: {
      break;
    }
    case internal::kPasswordGenerationAgent_FoundFormEligibleForGeneration_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationAgent_FoundFormEligibleForGeneration_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationAgent_FoundFormEligibleForGeneration_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::PasswordFormGenerationData p_form{};
      PasswordGenerationAgent_FoundFormEligibleForGeneration_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationAgent::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FoundFormEligibleForGeneration(
std::move(p_form));
      return true;
    }
  }
  return false;
}

// static
bool PasswordGenerationAgentStubDispatch::AcceptWithResponder(
    PasswordGenerationAgent* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPasswordGenerationAgent_GeneratedPasswordAccepted_Name: {
      break;
    }
    case internal::kPasswordGenerationAgent_TriggeredGeneratePassword_Name: {

      internal::PasswordGenerationAgent_TriggeredGeneratePassword_Params_Data* params =
          reinterpret_cast<
              internal::PasswordGenerationAgent_TriggeredGeneratePassword_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PasswordGenerationAgent_TriggeredGeneratePassword_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationAgent::Name_, 1, false);
        return false;
      }
      PasswordGenerationAgent::TriggeredGeneratePasswordCallback callback =
          PasswordGenerationAgent_TriggeredGeneratePassword_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TriggeredGeneratePassword(std::move(callback));
      return true;
    }
    case internal::kPasswordGenerationAgent_FoundFormEligibleForGeneration_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPasswordGenerationAgentValidationInfo[] = {
    {&internal::PasswordGenerationAgent_GeneratedPasswordAccepted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationAgent_TriggeredGeneratePassword_Params_Data::Validate,
     &internal::PasswordGenerationAgent_TriggeredGeneratePassword_ResponseParams_Data::Validate},
    {&internal::PasswordGenerationAgent_FoundFormEligibleForGeneration_Params_Data::Validate,
     nullptr /* no response */},
};

bool PasswordGenerationAgentRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordGenerationAgent::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPasswordGenerationAgentValidationInfo);
}

bool PasswordGenerationAgentResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordGenerationAgent::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kPasswordGenerationAgentValidationInfo);
}


}  // namespace mojom
}  // namespace autofill


namespace mojo {

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace autofill {
namespace mojom {


void AutofillAgentInterceptorForTesting::TriggerReparse() {
  GetForwardingInterface()->TriggerReparse();
}
void AutofillAgentInterceptorForTesting::FillOrPreviewForm(int32_t query_id, const ::autofill::FormData& form, ::autofill::mojom::RendererFormDataAction action) {
  GetForwardingInterface()->FillOrPreviewForm(std::move(query_id), std::move(form), std::move(action));
}
void AutofillAgentInterceptorForTesting::FieldTypePredictionsAvailable(const std::vector<::autofill::FormDataPredictions>& forms) {
  GetForwardingInterface()->FieldTypePredictionsAvailable(std::move(forms));
}
void AutofillAgentInterceptorForTesting::ClearSection() {
  GetForwardingInterface()->ClearSection();
}
void AutofillAgentInterceptorForTesting::ClearPreviewedForm() {
  GetForwardingInterface()->ClearPreviewedForm();
}
void AutofillAgentInterceptorForTesting::FillFieldWithValue(::autofill::FieldRendererId field, const ::std::u16string& value) {
  GetForwardingInterface()->FillFieldWithValue(std::move(field), std::move(value));
}
void AutofillAgentInterceptorForTesting::PreviewFieldWithValue(::autofill::FieldRendererId field, const ::std::u16string& value) {
  GetForwardingInterface()->PreviewFieldWithValue(std::move(field), std::move(value));
}
void AutofillAgentInterceptorForTesting::SetSuggestionAvailability(::autofill::FieldRendererId field, ::autofill::mojom::AutofillState type) {
  GetForwardingInterface()->SetSuggestionAvailability(std::move(field), std::move(type));
}
void AutofillAgentInterceptorForTesting::AcceptDataListSuggestion(::autofill::FieldRendererId field, const ::std::u16string& value) {
  GetForwardingInterface()->AcceptDataListSuggestion(std::move(field), std::move(value));
}
void AutofillAgentInterceptorForTesting::FillPasswordSuggestion(const ::std::u16string& username, const ::std::u16string& password) {
  GetForwardingInterface()->FillPasswordSuggestion(std::move(username), std::move(password));
}
void AutofillAgentInterceptorForTesting::PreviewPasswordSuggestion(const ::std::u16string& username, const ::std::u16string& password) {
  GetForwardingInterface()->PreviewPasswordSuggestion(std::move(username), std::move(password));
}
void AutofillAgentInterceptorForTesting::SetUserGestureRequired(bool required) {
  GetForwardingInterface()->SetUserGestureRequired(std::move(required));
}
void AutofillAgentInterceptorForTesting::SetSecureContextRequired(bool required) {
  GetForwardingInterface()->SetSecureContextRequired(std::move(required));
}
void AutofillAgentInterceptorForTesting::SetFocusRequiresScroll(bool require) {
  GetForwardingInterface()->SetFocusRequiresScroll(std::move(require));
}
void AutofillAgentInterceptorForTesting::SetQueryPasswordSuggestion(bool query) {
  GetForwardingInterface()->SetQueryPasswordSuggestion(std::move(query));
}
void AutofillAgentInterceptorForTesting::GetElementFormAndFieldDataForDevToolsNodeId(int32_t backend_node_id, GetElementFormAndFieldDataForDevToolsNodeIdCallback callback) {
  GetForwardingInterface()->GetElementFormAndFieldDataForDevToolsNodeId(std::move(backend_node_id), std::move(callback));
}
void AutofillAgentInterceptorForTesting::SetAssistantKeyboardSuppressState(bool suppress) {
  GetForwardingInterface()->SetAssistantKeyboardSuppressState(std::move(suppress));
}
void AutofillAgentInterceptorForTesting::EnableHeavyFormDataScraping() {
  GetForwardingInterface()->EnableHeavyFormDataScraping();
}
void AutofillAgentInterceptorForTesting::SetFieldsEligibleForManualFilling(const std::vector<::autofill::FieldRendererId>& fields) {
  GetForwardingInterface()->SetFieldsEligibleForManualFilling(std::move(fields));
}
AutofillAgentAsyncWaiter::AutofillAgentAsyncWaiter(
    AutofillAgent* proxy) : proxy_(proxy) {}

AutofillAgentAsyncWaiter::~AutofillAgentAsyncWaiter() = default;

void AutofillAgentAsyncWaiter::GetElementFormAndFieldDataForDevToolsNodeId(
    int32_t backend_node_id, ::autofill::FormData* out_form, ::autofill::FormFieldData* out_field) {
  base::RunLoop loop;
  proxy_->GetElementFormAndFieldDataForDevToolsNodeId(std::move(backend_node_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::autofill::FormData* out_form
,
             ::autofill::FormFieldData* out_field
,
             const ::autofill::FormData& form,
             const ::autofill::FormFieldData& field) {*out_form = std::move(form);*out_field = std::move(field);
            loop->Quit();
          },
          &loop,
          out_form,
          out_field));
  loop.Run();
}



void PasswordAutofillAgentInterceptorForTesting::FillPasswordForm(const ::autofill::PasswordFormFillData& form_data) {
  GetForwardingInterface()->FillPasswordForm(std::move(form_data));
}
void PasswordAutofillAgentInterceptorForTesting::InformNoSavedCredentials(bool should_show_popup_without_passwords) {
  GetForwardingInterface()->InformNoSavedCredentials(std::move(should_show_popup_without_passwords));
}
void PasswordAutofillAgentInterceptorForTesting::FillIntoFocusedField(bool is_password, const ::std::u16string& credential) {
  GetForwardingInterface()->FillIntoFocusedField(std::move(is_password), std::move(credential));
}
void PasswordAutofillAgentInterceptorForTesting::SetLoggingState(bool active) {
  GetForwardingInterface()->SetLoggingState(std::move(active));
}
void PasswordAutofillAgentInterceptorForTesting::TouchToFillClosed(bool show_virtual_keyboard) {
  GetForwardingInterface()->TouchToFillClosed(std::move(show_virtual_keyboard));
}
void PasswordAutofillAgentInterceptorForTesting::TriggerFormSubmission() {
  GetForwardingInterface()->TriggerFormSubmission();
}
void PasswordAutofillAgentInterceptorForTesting::AnnotateFieldsWithParsingResult(const ::autofill::ParsingResult& parsing_result) {
  GetForwardingInterface()->AnnotateFieldsWithParsingResult(std::move(parsing_result));
}
PasswordAutofillAgentAsyncWaiter::PasswordAutofillAgentAsyncWaiter(
    PasswordAutofillAgent* proxy) : proxy_(proxy) {}

PasswordAutofillAgentAsyncWaiter::~PasswordAutofillAgentAsyncWaiter() = default;




void PasswordGenerationAgentInterceptorForTesting::GeneratedPasswordAccepted(const ::std::u16string& generated_password) {
  GetForwardingInterface()->GeneratedPasswordAccepted(std::move(generated_password));
}
void PasswordGenerationAgentInterceptorForTesting::TriggeredGeneratePassword(TriggeredGeneratePasswordCallback callback) {
  GetForwardingInterface()->TriggeredGeneratePassword(std::move(callback));
}
void PasswordGenerationAgentInterceptorForTesting::FoundFormEligibleForGeneration(const ::autofill::PasswordFormGenerationData& form) {
  GetForwardingInterface()->FoundFormEligibleForGeneration(std::move(form));
}
PasswordGenerationAgentAsyncWaiter::PasswordGenerationAgentAsyncWaiter(
    PasswordGenerationAgent* proxy) : proxy_(proxy) {}

PasswordGenerationAgentAsyncWaiter::~PasswordGenerationAgentAsyncWaiter() = default;

void PasswordGenerationAgentAsyncWaiter::TriggeredGeneratePassword(
    absl::optional<::autofill::password_generation::PasswordGenerationUIData>* out_data) {
  base::RunLoop loop;
  proxy_->TriggeredGeneratePassword(
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<::autofill::password_generation::PasswordGenerationUIData>* out_data
,
             const absl::optional<::autofill::password_generation::PasswordGenerationUIData>& data) {*out_data = std::move(data);
            loop->Quit();
          },
          &loop,
          out_data));
  loop.Run();
}





}  // namespace mojom
}  // namespace autofill


#if defined(__clang__)
#pragma clang diagnostic pop
#endif