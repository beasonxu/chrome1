// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/segmentation_platform/public/proto/model_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "components/segmentation_platform/public/proto/aggregation.pb.h"
#include "components/segmentation_platform/public/proto/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto {
  static const uint32_t offsets[];
};
namespace segmentation_platform {
namespace proto {
class CustomInput;
struct CustomInputDefaultTypeInternal;
extern CustomInputDefaultTypeInternal _CustomInput_default_instance_;
class CustomInput_AdditionalArgsEntry_DoNotUse;
struct CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal;
extern CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal _CustomInput_AdditionalArgsEntry_DoNotUse_default_instance_;
class InputFeature;
struct InputFeatureDefaultTypeInternal;
extern InputFeatureDefaultTypeInternal _InputFeature_default_instance_;
class SegmentationModelMetadata;
struct SegmentationModelMetadataDefaultTypeInternal;
extern SegmentationModelMetadataDefaultTypeInternal _SegmentationModelMetadata_default_instance_;
class SegmentationModelMetadata_DiscreteMapping;
struct SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal;
extern SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal _SegmentationModelMetadata_DiscreteMapping_default_instance_;
class SegmentationModelMetadata_DiscreteMapping_Entry;
struct SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal;
extern SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal _SegmentationModelMetadata_DiscreteMapping_Entry_default_instance_;
class SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse;
struct SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal;
extern SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal _SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse_default_instance_;
class SignalFilterConfig;
struct SignalFilterConfigDefaultTypeInternal;
extern SignalFilterConfigDefaultTypeInternal _SignalFilterConfig_default_instance_;
class SignalFilterConfig_UkmEvent;
struct SignalFilterConfig_UkmEventDefaultTypeInternal;
extern SignalFilterConfig_UkmEventDefaultTypeInternal _SignalFilterConfig_UkmEvent_default_instance_;
class SqlFeature;
struct SqlFeatureDefaultTypeInternal;
extern SqlFeatureDefaultTypeInternal _SqlFeature_default_instance_;
class SqlFeature_BindValue;
struct SqlFeature_BindValueDefaultTypeInternal;
extern SqlFeature_BindValueDefaultTypeInternal _SqlFeature_BindValue_default_instance_;
class TrainingOutput;
struct TrainingOutputDefaultTypeInternal;
extern TrainingOutputDefaultTypeInternal _TrainingOutput_default_instance_;
class TrainingOutputs;
struct TrainingOutputsDefaultTypeInternal;
extern TrainingOutputsDefaultTypeInternal _TrainingOutputs_default_instance_;
class UMAFeature;
struct UMAFeatureDefaultTypeInternal;
extern UMAFeatureDefaultTypeInternal _UMAFeature_default_instance_;
class UMAOutput;
struct UMAOutputDefaultTypeInternal;
extern UMAOutputDefaultTypeInternal _UMAOutput_default_instance_;
class VersionInfo;
struct VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
}  // namespace proto
}  // namespace segmentation_platform
PROTOBUF_NAMESPACE_OPEN
template<> ::segmentation_platform::proto::CustomInput* Arena::CreateMaybeMessage<::segmentation_platform::proto::CustomInput>(Arena*);
template<> ::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse>(Arena*);
template<> ::segmentation_platform::proto::InputFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::InputFeature>(Arena*);
template<> ::segmentation_platform::proto::SegmentationModelMetadata* Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata>(Arena*);
template<> ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping* Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>(Arena*);
template<> ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>(Arena*);
template<> ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse* Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse>(Arena*);
template<> ::segmentation_platform::proto::SignalFilterConfig* Arena::CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig>(Arena*);
template<> ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* Arena::CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>(Arena*);
template<> ::segmentation_platform::proto::SqlFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::SqlFeature>(Arena*);
template<> ::segmentation_platform::proto::SqlFeature_BindValue* Arena::CreateMaybeMessage<::segmentation_platform::proto::SqlFeature_BindValue>(Arena*);
template<> ::segmentation_platform::proto::TrainingOutput* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutput>(Arena*);
template<> ::segmentation_platform::proto::TrainingOutputs* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs>(Arena*);
template<> ::segmentation_platform::proto::UMAFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::UMAFeature>(Arena*);
template<> ::segmentation_platform::proto::UMAOutput* Arena::CreateMaybeMessage<::segmentation_platform::proto::UMAOutput>(Arena*);
template<> ::segmentation_platform::proto::VersionInfo* Arena::CreateMaybeMessage<::segmentation_platform::proto::VersionInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace segmentation_platform {
namespace proto {

enum CustomInput_FillPolicy : int {
  CustomInput_FillPolicy_UNKNOWN_FILL_POLICY = 0,
  CustomInput_FillPolicy_FILL_PREDICTION_TIME = 1,
  CustomInput_FillPolicy_TIME_RANGE_BEFORE_PREDICTION = 2,
  CustomInput_FillPolicy_PRICE_TRACKING_HINTS = 3
};
bool CustomInput_FillPolicy_IsValid(int value);
constexpr CustomInput_FillPolicy CustomInput_FillPolicy_FillPolicy_MIN = CustomInput_FillPolicy_UNKNOWN_FILL_POLICY;
constexpr CustomInput_FillPolicy CustomInput_FillPolicy_FillPolicy_MAX = CustomInput_FillPolicy_PRICE_TRACKING_HINTS;
constexpr int CustomInput_FillPolicy_FillPolicy_ARRAYSIZE = CustomInput_FillPolicy_FillPolicy_MAX + 1;

const std::string& CustomInput_FillPolicy_Name(CustomInput_FillPolicy value);
template<typename T>
inline const std::string& CustomInput_FillPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CustomInput_FillPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CustomInput_FillPolicy_Name.");
  return CustomInput_FillPolicy_Name(static_cast<CustomInput_FillPolicy>(enum_t_value));
}
bool CustomInput_FillPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomInput_FillPolicy* value);
enum SqlFeature_BindValue_ParamType : int {
  SqlFeature_BindValue_ParamType_UNKNOWN = 0,
  SqlFeature_BindValue_ParamType_NULL_ = 1,
  SqlFeature_BindValue_ParamType_BOOL = 2,
  SqlFeature_BindValue_ParamType_INT = 3,
  SqlFeature_BindValue_ParamType_INT64 = 4,
  SqlFeature_BindValue_ParamType_DOUBLE = 5,
  SqlFeature_BindValue_ParamType_STRING = 6,
  SqlFeature_BindValue_ParamType_TIME = 7
};
bool SqlFeature_BindValue_ParamType_IsValid(int value);
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue_ParamType_ParamType_MIN = SqlFeature_BindValue_ParamType_UNKNOWN;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue_ParamType_ParamType_MAX = SqlFeature_BindValue_ParamType_TIME;
constexpr int SqlFeature_BindValue_ParamType_ParamType_ARRAYSIZE = SqlFeature_BindValue_ParamType_ParamType_MAX + 1;

const std::string& SqlFeature_BindValue_ParamType_Name(SqlFeature_BindValue_ParamType value);
template<typename T>
inline const std::string& SqlFeature_BindValue_ParamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SqlFeature_BindValue_ParamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SqlFeature_BindValue_ParamType_Name.");
  return SqlFeature_BindValue_ParamType_Name(static_cast<SqlFeature_BindValue_ParamType>(enum_t_value));
}
bool SqlFeature_BindValue_ParamType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqlFeature_BindValue_ParamType* value);
enum CurrentVersion : int {
  METADATA_VERSION = 1
};
bool CurrentVersion_IsValid(int value);
constexpr CurrentVersion CurrentVersion_MIN = METADATA_VERSION;
constexpr CurrentVersion CurrentVersion_MAX = METADATA_VERSION;
constexpr int CurrentVersion_ARRAYSIZE = CurrentVersion_MAX + 1;

const std::string& CurrentVersion_Name(CurrentVersion value);
template<typename T>
inline const std::string& CurrentVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CurrentVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CurrentVersion_Name.");
  return CurrentVersion_Name(static_cast<CurrentVersion>(enum_t_value));
}
bool CurrentVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrentVersion* value);
enum TimeUnit : int {
  UNKNOWN_TIME_UNIT = 0,
  YEAR = 1,
  MONTH = 2,
  WEEK = 3,
  DAY = 4,
  HOUR = 5,
  MINUTE = 6,
  SECOND = 7
};
bool TimeUnit_IsValid(int value);
constexpr TimeUnit TimeUnit_MIN = UNKNOWN_TIME_UNIT;
constexpr TimeUnit TimeUnit_MAX = SECOND;
constexpr int TimeUnit_ARRAYSIZE = TimeUnit_MAX + 1;

const std::string& TimeUnit_Name(TimeUnit value);
template<typename T>
inline const std::string& TimeUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeUnit_Name.");
  return TimeUnit_Name(static_cast<TimeUnit>(enum_t_value));
}
bool TimeUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeUnit* value);
// ===================================================================

class VersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.VersionInfo) */ {
 public:
  inline VersionInfo() : VersionInfo(nullptr) {}
  ~VersionInfo() override;
  explicit PROTOBUF_CONSTEXPR VersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionInfo(const VersionInfo& from);
  VersionInfo(VersionInfo&& from) noexcept
    : VersionInfo() {
    *this = ::std::move(from);
  }

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionInfo& operator=(VersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionInfo* internal_default_instance() {
    return reinterpret_cast<const VersionInfo*>(
               &_VersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VersionInfo& a, VersionInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VersionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VersionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.VersionInfo";
  }
  protected:
  explicit VersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataMinVersionFieldNumber = 1,
    kMetadataCurVersionFieldNumber = 2,
  };
  // optional int32 metadata_min_version = 1;
  bool has_metadata_min_version() const;
  private:
  bool _internal_has_metadata_min_version() const;
  public:
  void clear_metadata_min_version();
  int32_t metadata_min_version() const;
  void set_metadata_min_version(int32_t value);
  private:
  int32_t _internal_metadata_min_version() const;
  void _internal_set_metadata_min_version(int32_t value);
  public:

  // optional int32 metadata_cur_version = 2;
  bool has_metadata_cur_version() const;
  private:
  bool _internal_has_metadata_cur_version() const;
  public:
  void clear_metadata_cur_version();
  int32_t metadata_cur_version() const;
  void set_metadata_cur_version(int32_t value);
  private:
  int32_t _internal_metadata_cur_version() const;
  void _internal_set_metadata_cur_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.VersionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t metadata_min_version_;
  int32_t metadata_cur_version_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class UMAFeature final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.UMAFeature) */ {
 public:
  inline UMAFeature() : UMAFeature(nullptr) {}
  ~UMAFeature() override;
  explicit PROTOBUF_CONSTEXPR UMAFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UMAFeature(const UMAFeature& from);
  UMAFeature(UMAFeature&& from) noexcept
    : UMAFeature() {
    *this = ::std::move(from);
  }

  inline UMAFeature& operator=(const UMAFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMAFeature& operator=(UMAFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UMAFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMAFeature* internal_default_instance() {
    return reinterpret_cast<const UMAFeature*>(
               &_UMAFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UMAFeature& a, UMAFeature& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UMAFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMAFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMAFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMAFeature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UMAFeature& from);
  void MergeFrom(const UMAFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UMAFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.UMAFeature";
  }
  protected:
  explicit UMAFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnumIdsFieldNumber = 7,
    kNameFieldNumber = 2,
    kNameHashFieldNumber = 3,
    kTypeFieldNumber = 1,
    kAggregationFieldNumber = 6,
    kBucketCountFieldNumber = 4,
    kTensorLengthFieldNumber = 5,
  };
  // repeated int32 enum_ids = 7;
  int enum_ids_size() const;
  private:
  int _internal_enum_ids_size() const;
  public:
  void clear_enum_ids();
  private:
  int32_t _internal_enum_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_enum_ids() const;
  void _internal_add_enum_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_enum_ids();
  public:
  int32_t enum_ids(int index) const;
  void set_enum_ids(int index, int32_t value);
  void add_enum_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      enum_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_enum_ids();

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional fixed64 name_hash = 3;
  bool has_name_hash() const;
  private:
  bool _internal_has_name_hash() const;
  public:
  void clear_name_hash();
  uint64_t name_hash() const;
  void set_name_hash(uint64_t value);
  private:
  uint64_t _internal_name_hash() const;
  void _internal_set_name_hash(uint64_t value);
  public:

  // optional .segmentation_platform.proto.SignalType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::segmentation_platform::proto::SignalType type() const;
  void set_type(::segmentation_platform::proto::SignalType value);
  private:
  ::segmentation_platform::proto::SignalType _internal_type() const;
  void _internal_set_type(::segmentation_platform::proto::SignalType value);
  public:

  // optional .segmentation_platform.proto.Aggregation aggregation = 6;
  bool has_aggregation() const;
  private:
  bool _internal_has_aggregation() const;
  public:
  void clear_aggregation();
  ::segmentation_platform::proto::Aggregation aggregation() const;
  void set_aggregation(::segmentation_platform::proto::Aggregation value);
  private:
  ::segmentation_platform::proto::Aggregation _internal_aggregation() const;
  void _internal_set_aggregation(::segmentation_platform::proto::Aggregation value);
  public:

  // optional uint64 bucket_count = 4;
  bool has_bucket_count() const;
  private:
  bool _internal_has_bucket_count() const;
  public:
  void clear_bucket_count();
  uint64_t bucket_count() const;
  void set_bucket_count(uint64_t value);
  private:
  uint64_t _internal_bucket_count() const;
  void _internal_set_bucket_count(uint64_t value);
  public:

  // optional uint64 tensor_length = 5;
  bool has_tensor_length() const;
  private:
  bool _internal_has_tensor_length() const;
  public:
  void clear_tensor_length();
  uint64_t tensor_length() const;
  void set_tensor_length(uint64_t value);
  private:
  uint64_t _internal_tensor_length() const;
  void _internal_set_tensor_length(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.UMAFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > enum_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t name_hash_;
  int type_;
  int aggregation_;
  uint64_t bucket_count_;
  uint64_t tensor_length_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class CustomInput_AdditionalArgsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<CustomInput_AdditionalArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<CustomInput_AdditionalArgsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CustomInput_AdditionalArgsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CustomInput_AdditionalArgsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CustomInput_AdditionalArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CustomInput_AdditionalArgsEntry_DoNotUse& other);
  static const CustomInput_AdditionalArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CustomInput_AdditionalArgsEntry_DoNotUse*>(&_CustomInput_AdditionalArgsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};

// -------------------------------------------------------------------

class CustomInput final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.CustomInput) */ {
 public:
  inline CustomInput() : CustomInput(nullptr) {}
  ~CustomInput() override;
  explicit PROTOBUF_CONSTEXPR CustomInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomInput(const CustomInput& from);
  CustomInput(CustomInput&& from) noexcept
    : CustomInput() {
    *this = ::std::move(from);
  }

  inline CustomInput& operator=(const CustomInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomInput& operator=(CustomInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CustomInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomInput* internal_default_instance() {
    return reinterpret_cast<const CustomInput*>(
               &_CustomInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CustomInput& a, CustomInput& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CustomInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomInput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CustomInput& from);
  void MergeFrom(const CustomInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CustomInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.CustomInput";
  }
  protected:
  explicit CustomInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  typedef CustomInput_FillPolicy FillPolicy;
  static constexpr FillPolicy UNKNOWN_FILL_POLICY =
    CustomInput_FillPolicy_UNKNOWN_FILL_POLICY;
  static constexpr FillPolicy FILL_PREDICTION_TIME =
    CustomInput_FillPolicy_FILL_PREDICTION_TIME;
  static constexpr FillPolicy TIME_RANGE_BEFORE_PREDICTION =
    CustomInput_FillPolicy_TIME_RANGE_BEFORE_PREDICTION;
  static constexpr FillPolicy PRICE_TRACKING_HINTS =
    CustomInput_FillPolicy_PRICE_TRACKING_HINTS;
  static inline bool FillPolicy_IsValid(int value) {
    return CustomInput_FillPolicy_IsValid(value);
  }
  static constexpr FillPolicy FillPolicy_MIN =
    CustomInput_FillPolicy_FillPolicy_MIN;
  static constexpr FillPolicy FillPolicy_MAX =
    CustomInput_FillPolicy_FillPolicy_MAX;
  static constexpr int FillPolicy_ARRAYSIZE =
    CustomInput_FillPolicy_FillPolicy_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FillPolicy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FillPolicy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FillPolicy_Name.");
    return CustomInput_FillPolicy_Name(enum_t_value);
  }
  static inline bool FillPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FillPolicy* value) {
    return CustomInput_FillPolicy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultValueFieldNumber = 3,
    kAdditionalArgsFieldNumber = 4,
    kNameFieldNumber = 5,
    kTensorLengthFieldNumber = 1,
    kFillPolicyFieldNumber = 2,
  };
  // repeated float default_value = 3;
  int default_value_size() const;
  private:
  int _internal_default_value_size() const;
  public:
  void clear_default_value();
  private:
  float _internal_default_value(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_default_value() const;
  void _internal_add_default_value(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_default_value();
  public:
  float default_value(int index) const;
  void set_default_value(int index, float value);
  void add_default_value(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      default_value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_default_value();

  // map<string, string> additional_args = 4;
  int additional_args_size() const;
  private:
  int _internal_additional_args_size() const;
  public:
  void clear_additional_args();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additional_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additional_args();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additional_args() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additional_args();

  // optional string name = 5;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 tensor_length = 1;
  bool has_tensor_length() const;
  private:
  bool _internal_has_tensor_length() const;
  public:
  void clear_tensor_length();
  int32_t tensor_length() const;
  void set_tensor_length(int32_t value);
  private:
  int32_t _internal_tensor_length() const;
  void _internal_set_tensor_length(int32_t value);
  public:

  // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
  bool has_fill_policy() const;
  private:
  bool _internal_has_fill_policy() const;
  public:
  void clear_fill_policy();
  ::segmentation_platform::proto::CustomInput_FillPolicy fill_policy() const;
  void set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value);
  private:
  ::segmentation_platform::proto::CustomInput_FillPolicy _internal_fill_policy() const;
  void _internal_set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.CustomInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > default_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      CustomInput_AdditionalArgsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> additional_args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t tensor_length_;
  int fill_policy_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SignalFilterConfig_UkmEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SignalFilterConfig.UkmEvent) */ {
 public:
  inline SignalFilterConfig_UkmEvent() : SignalFilterConfig_UkmEvent(nullptr) {}
  ~SignalFilterConfig_UkmEvent() override;
  explicit PROTOBUF_CONSTEXPR SignalFilterConfig_UkmEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalFilterConfig_UkmEvent(const SignalFilterConfig_UkmEvent& from);
  SignalFilterConfig_UkmEvent(SignalFilterConfig_UkmEvent&& from) noexcept
    : SignalFilterConfig_UkmEvent() {
    *this = ::std::move(from);
  }

  inline SignalFilterConfig_UkmEvent& operator=(const SignalFilterConfig_UkmEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalFilterConfig_UkmEvent& operator=(SignalFilterConfig_UkmEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SignalFilterConfig_UkmEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalFilterConfig_UkmEvent* internal_default_instance() {
    return reinterpret_cast<const SignalFilterConfig_UkmEvent*>(
               &_SignalFilterConfig_UkmEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SignalFilterConfig_UkmEvent& a, SignalFilterConfig_UkmEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SignalFilterConfig_UkmEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalFilterConfig_UkmEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalFilterConfig_UkmEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalFilterConfig_UkmEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SignalFilterConfig_UkmEvent& from);
  void MergeFrom(const SignalFilterConfig_UkmEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignalFilterConfig_UkmEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SignalFilterConfig.UkmEvent";
  }
  protected:
  explicit SignalFilterConfig_UkmEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricHashFilterFieldNumber = 2,
    kEventHashFieldNumber = 1,
  };
  // repeated uint64 metric_hash_filter = 2;
  int metric_hash_filter_size() const;
  private:
  int _internal_metric_hash_filter_size() const;
  public:
  void clear_metric_hash_filter();
  private:
  uint64_t _internal_metric_hash_filter(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_metric_hash_filter() const;
  void _internal_add_metric_hash_filter(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_metric_hash_filter();
  public:
  uint64_t metric_hash_filter(int index) const;
  void set_metric_hash_filter(int index, uint64_t value);
  void add_metric_hash_filter(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      metric_hash_filter() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_metric_hash_filter();

  // optional uint64 event_hash = 1;
  bool has_event_hash() const;
  private:
  bool _internal_has_event_hash() const;
  public:
  void clear_event_hash();
  uint64_t event_hash() const;
  void set_event_hash(uint64_t value);
  private:
  uint64_t _internal_event_hash() const;
  void _internal_set_event_hash(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > metric_hash_filter_;
  uint64_t event_hash_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SignalFilterConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SignalFilterConfig) */ {
 public:
  inline SignalFilterConfig() : SignalFilterConfig(nullptr) {}
  ~SignalFilterConfig() override;
  explicit PROTOBUF_CONSTEXPR SignalFilterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalFilterConfig(const SignalFilterConfig& from);
  SignalFilterConfig(SignalFilterConfig&& from) noexcept
    : SignalFilterConfig() {
    *this = ::std::move(from);
  }

  inline SignalFilterConfig& operator=(const SignalFilterConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalFilterConfig& operator=(SignalFilterConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SignalFilterConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalFilterConfig* internal_default_instance() {
    return reinterpret_cast<const SignalFilterConfig*>(
               &_SignalFilterConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SignalFilterConfig& a, SignalFilterConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SignalFilterConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalFilterConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalFilterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalFilterConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SignalFilterConfig& from);
  void MergeFrom(const SignalFilterConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignalFilterConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SignalFilterConfig";
  }
  protected:
  explicit SignalFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SignalFilterConfig_UkmEvent UkmEvent;

  // accessors -------------------------------------------------------

  enum : int {
    kUkmEventsFieldNumber = 1,
  };
  // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
  int ukm_events_size() const;
  private:
  int _internal_ukm_events_size() const;
  public:
  void clear_ukm_events();
  ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* mutable_ukm_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent >*
      mutable_ukm_events();
  private:
  const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& _internal_ukm_events(int index) const;
  ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* _internal_add_ukm_events();
  public:
  const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& ukm_events(int index) const;
  ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* add_ukm_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent >&
      ukm_events() const;

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SignalFilterConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent > ukm_events_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SqlFeature_BindValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SqlFeature.BindValue) */ {
 public:
  inline SqlFeature_BindValue() : SqlFeature_BindValue(nullptr) {}
  ~SqlFeature_BindValue() override;
  explicit PROTOBUF_CONSTEXPR SqlFeature_BindValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqlFeature_BindValue(const SqlFeature_BindValue& from);
  SqlFeature_BindValue(SqlFeature_BindValue&& from) noexcept
    : SqlFeature_BindValue() {
    *this = ::std::move(from);
  }

  inline SqlFeature_BindValue& operator=(const SqlFeature_BindValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqlFeature_BindValue& operator=(SqlFeature_BindValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SqlFeature_BindValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqlFeature_BindValue* internal_default_instance() {
    return reinterpret_cast<const SqlFeature_BindValue*>(
               &_SqlFeature_BindValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SqlFeature_BindValue& a, SqlFeature_BindValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SqlFeature_BindValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqlFeature_BindValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SqlFeature_BindValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SqlFeature_BindValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SqlFeature_BindValue& from);
  void MergeFrom(const SqlFeature_BindValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SqlFeature_BindValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SqlFeature.BindValue";
  }
  protected:
  explicit SqlFeature_BindValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SqlFeature_BindValue_ParamType ParamType;
  static constexpr ParamType UNKNOWN =
    SqlFeature_BindValue_ParamType_UNKNOWN;
  static constexpr ParamType NULL_ =
    SqlFeature_BindValue_ParamType_NULL_;
  static constexpr ParamType BOOL =
    SqlFeature_BindValue_ParamType_BOOL;
  static constexpr ParamType INT =
    SqlFeature_BindValue_ParamType_INT;
  static constexpr ParamType INT64 =
    SqlFeature_BindValue_ParamType_INT64;
  static constexpr ParamType DOUBLE =
    SqlFeature_BindValue_ParamType_DOUBLE;
  static constexpr ParamType STRING =
    SqlFeature_BindValue_ParamType_STRING;
  static constexpr ParamType TIME =
    SqlFeature_BindValue_ParamType_TIME;
  static inline bool ParamType_IsValid(int value) {
    return SqlFeature_BindValue_ParamType_IsValid(value);
  }
  static constexpr ParamType ParamType_MIN =
    SqlFeature_BindValue_ParamType_ParamType_MIN;
  static constexpr ParamType ParamType_MAX =
    SqlFeature_BindValue_ParamType_ParamType_MAX;
  static constexpr int ParamType_ARRAYSIZE =
    SqlFeature_BindValue_ParamType_ParamType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ParamType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ParamType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ParamType_Name.");
    return SqlFeature_BindValue_ParamType_Name(enum_t_value);
  }
  static inline bool ParamType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ParamType* value) {
    return SqlFeature_BindValue_ParamType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBindFieldIndexFieldNumber = 1,
    kValueFieldNumber = 3,
    kParamTypeFieldNumber = 2,
  };
  // repeated int32 bind_field_index = 1;
  int bind_field_index_size() const;
  private:
  int _internal_bind_field_index_size() const;
  public:
  void clear_bind_field_index();
  private:
  int32_t _internal_bind_field_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_bind_field_index() const;
  void _internal_add_bind_field_index(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_bind_field_index();
  public:
  int32_t bind_field_index(int index) const;
  void set_bind_field_index(int index, int32_t value);
  void add_bind_field_index(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      bind_field_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_bind_field_index();

  // optional .segmentation_platform.proto.CustomInput value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::segmentation_platform::proto::CustomInput& value() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::CustomInput* release_value();
  ::segmentation_platform::proto::CustomInput* mutable_value();
  void set_allocated_value(::segmentation_platform::proto::CustomInput* value);
  private:
  const ::segmentation_platform::proto::CustomInput& _internal_value() const;
  ::segmentation_platform::proto::CustomInput* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::segmentation_platform::proto::CustomInput* value);
  ::segmentation_platform::proto::CustomInput* unsafe_arena_release_value();

  // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
  bool has_param_type() const;
  private:
  bool _internal_has_param_type() const;
  public:
  void clear_param_type();
  ::segmentation_platform::proto::SqlFeature_BindValue_ParamType param_type() const;
  void set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value);
  private:
  ::segmentation_platform::proto::SqlFeature_BindValue_ParamType _internal_param_type() const;
  void _internal_set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SqlFeature.BindValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > bind_field_index_;
  ::segmentation_platform::proto::CustomInput* value_;
  int param_type_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SqlFeature final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SqlFeature) */ {
 public:
  inline SqlFeature() : SqlFeature(nullptr) {}
  ~SqlFeature() override;
  explicit PROTOBUF_CONSTEXPR SqlFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqlFeature(const SqlFeature& from);
  SqlFeature(SqlFeature&& from) noexcept
    : SqlFeature() {
    *this = ::std::move(from);
  }

  inline SqlFeature& operator=(const SqlFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqlFeature& operator=(SqlFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SqlFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqlFeature* internal_default_instance() {
    return reinterpret_cast<const SqlFeature*>(
               &_SqlFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SqlFeature& a, SqlFeature& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SqlFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqlFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SqlFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SqlFeature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SqlFeature& from);
  void MergeFrom(const SqlFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SqlFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SqlFeature";
  }
  protected:
  explicit SqlFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SqlFeature_BindValue BindValue;

  // accessors -------------------------------------------------------

  enum : int {
    kBindValuesFieldNumber = 3,
    kSqlFieldNumber = 1,
    kNameFieldNumber = 4,
    kSignalFilterFieldNumber = 2,
  };
  // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
  int bind_values_size() const;
  private:
  int _internal_bind_values_size() const;
  public:
  void clear_bind_values();
  ::segmentation_platform::proto::SqlFeature_BindValue* mutable_bind_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SqlFeature_BindValue >*
      mutable_bind_values();
  private:
  const ::segmentation_platform::proto::SqlFeature_BindValue& _internal_bind_values(int index) const;
  ::segmentation_platform::proto::SqlFeature_BindValue* _internal_add_bind_values();
  public:
  const ::segmentation_platform::proto::SqlFeature_BindValue& bind_values(int index) const;
  ::segmentation_platform::proto::SqlFeature_BindValue* add_bind_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SqlFeature_BindValue >&
      bind_values() const;

  // optional string sql = 1;
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
  bool has_signal_filter() const;
  private:
  bool _internal_has_signal_filter() const;
  public:
  void clear_signal_filter();
  const ::segmentation_platform::proto::SignalFilterConfig& signal_filter() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::SignalFilterConfig* release_signal_filter();
  ::segmentation_platform::proto::SignalFilterConfig* mutable_signal_filter();
  void set_allocated_signal_filter(::segmentation_platform::proto::SignalFilterConfig* signal_filter);
  private:
  const ::segmentation_platform::proto::SignalFilterConfig& _internal_signal_filter() const;
  ::segmentation_platform::proto::SignalFilterConfig* _internal_mutable_signal_filter();
  public:
  void unsafe_arena_set_allocated_signal_filter(
      ::segmentation_platform::proto::SignalFilterConfig* signal_filter);
  ::segmentation_platform::proto::SignalFilterConfig* unsafe_arena_release_signal_filter();

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SqlFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SqlFeature_BindValue > bind_values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::segmentation_platform::proto::SignalFilterConfig* signal_filter_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class InputFeature final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.InputFeature) */ {
 public:
  inline InputFeature() : InputFeature(nullptr) {}
  ~InputFeature() override;
  explicit PROTOBUF_CONSTEXPR InputFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputFeature(const InputFeature& from);
  InputFeature(InputFeature&& from) noexcept
    : InputFeature() {
    *this = ::std::move(from);
  }

  inline InputFeature& operator=(const InputFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputFeature& operator=(InputFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InputFeature& default_instance() {
    return *internal_default_instance();
  }
  enum FeatureCase {
    kUmaFeature = 1,
    kCustomInput = 2,
    kSqlFeature = 3,
    FEATURE_NOT_SET = 0,
  };

  static inline const InputFeature* internal_default_instance() {
    return reinterpret_cast<const InputFeature*>(
               &_InputFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InputFeature& a, InputFeature& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InputFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputFeature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InputFeature& from);
  void MergeFrom(const InputFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.InputFeature";
  }
  protected:
  explicit InputFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUmaFeatureFieldNumber = 1,
    kCustomInputFieldNumber = 2,
    kSqlFeatureFieldNumber = 3,
  };
  // .segmentation_platform.proto.UMAFeature uma_feature = 1;
  bool has_uma_feature() const;
  private:
  bool _internal_has_uma_feature() const;
  public:
  void clear_uma_feature();
  const ::segmentation_platform::proto::UMAFeature& uma_feature() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAFeature* release_uma_feature();
  ::segmentation_platform::proto::UMAFeature* mutable_uma_feature();
  void set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature);
  private:
  const ::segmentation_platform::proto::UMAFeature& _internal_uma_feature() const;
  ::segmentation_platform::proto::UMAFeature* _internal_mutable_uma_feature();
  public:
  void unsafe_arena_set_allocated_uma_feature(
      ::segmentation_platform::proto::UMAFeature* uma_feature);
  ::segmentation_platform::proto::UMAFeature* unsafe_arena_release_uma_feature();

  // .segmentation_platform.proto.CustomInput custom_input = 2;
  bool has_custom_input() const;
  private:
  bool _internal_has_custom_input() const;
  public:
  void clear_custom_input();
  const ::segmentation_platform::proto::CustomInput& custom_input() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::CustomInput* release_custom_input();
  ::segmentation_platform::proto::CustomInput* mutable_custom_input();
  void set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input);
  private:
  const ::segmentation_platform::proto::CustomInput& _internal_custom_input() const;
  ::segmentation_platform::proto::CustomInput* _internal_mutable_custom_input();
  public:
  void unsafe_arena_set_allocated_custom_input(
      ::segmentation_platform::proto::CustomInput* custom_input);
  ::segmentation_platform::proto::CustomInput* unsafe_arena_release_custom_input();

  // .segmentation_platform.proto.SqlFeature sql_feature = 3;
  bool has_sql_feature() const;
  private:
  bool _internal_has_sql_feature() const;
  public:
  void clear_sql_feature();
  const ::segmentation_platform::proto::SqlFeature& sql_feature() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::SqlFeature* release_sql_feature();
  ::segmentation_platform::proto::SqlFeature* mutable_sql_feature();
  void set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature);
  private:
  const ::segmentation_platform::proto::SqlFeature& _internal_sql_feature() const;
  ::segmentation_platform::proto::SqlFeature* _internal_mutable_sql_feature();
  public:
  void unsafe_arena_set_allocated_sql_feature(
      ::segmentation_platform::proto::SqlFeature* sql_feature);
  ::segmentation_platform::proto::SqlFeature* unsafe_arena_release_sql_feature();

  void clear_Feature();
  FeatureCase Feature_case() const;
  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.InputFeature)
 private:
  class _Internal;
  void set_has_uma_feature();
  void set_has_custom_input();
  void set_has_sql_feature();

  inline bool has_Feature() const;
  inline void clear_has_Feature();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FeatureUnion {
    constexpr FeatureUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::segmentation_platform::proto::UMAFeature* uma_feature_;
    ::segmentation_platform::proto::CustomInput* custom_input_;
    ::segmentation_platform::proto::SqlFeature* sql_feature_;
  } Feature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class TrainingOutputs final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.TrainingOutputs) */ {
 public:
  inline TrainingOutputs() : TrainingOutputs(nullptr) {}
  ~TrainingOutputs() override;
  explicit PROTOBUF_CONSTEXPR TrainingOutputs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainingOutputs(const TrainingOutputs& from);
  TrainingOutputs(TrainingOutputs&& from) noexcept
    : TrainingOutputs() {
    *this = ::std::move(from);
  }

  inline TrainingOutputs& operator=(const TrainingOutputs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingOutputs& operator=(TrainingOutputs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TrainingOutputs& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrainingOutputs* internal_default_instance() {
    return reinterpret_cast<const TrainingOutputs*>(
               &_TrainingOutputs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrainingOutputs& a, TrainingOutputs& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TrainingOutputs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingOutputs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingOutputs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingOutputs>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TrainingOutputs& from);
  void MergeFrom(const TrainingOutputs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrainingOutputs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.TrainingOutputs";
  }
  protected:
  explicit TrainingOutputs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 1,
  };
  // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::segmentation_platform::proto::TrainingOutput* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::TrainingOutput >*
      mutable_outputs();
  private:
  const ::segmentation_platform::proto::TrainingOutput& _internal_outputs(int index) const;
  ::segmentation_platform::proto::TrainingOutput* _internal_add_outputs();
  public:
  const ::segmentation_platform::proto::TrainingOutput& outputs(int index) const;
  ::segmentation_platform::proto::TrainingOutput* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::TrainingOutput >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.TrainingOutputs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::TrainingOutput > outputs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class TrainingOutput final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.TrainingOutput) */ {
 public:
  inline TrainingOutput() : TrainingOutput(nullptr) {}
  ~TrainingOutput() override;
  explicit PROTOBUF_CONSTEXPR TrainingOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrainingOutput(const TrainingOutput& from);
  TrainingOutput(TrainingOutput&& from) noexcept
    : TrainingOutput() {
    *this = ::std::move(from);
  }

  inline TrainingOutput& operator=(const TrainingOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrainingOutput& operator=(TrainingOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TrainingOutput& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kUmaOutput = 1,
    OUTPUT_NOT_SET = 0,
  };

  static inline const TrainingOutput* internal_default_instance() {
    return reinterpret_cast<const TrainingOutput*>(
               &_TrainingOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TrainingOutput& a, TrainingOutput& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TrainingOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrainingOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrainingOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrainingOutput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TrainingOutput& from);
  void MergeFrom(const TrainingOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrainingOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.TrainingOutput";
  }
  protected:
  explicit TrainingOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUmaOutputFieldNumber = 1,
  };
  // .segmentation_platform.proto.UMAOutput uma_output = 1;
  bool has_uma_output() const;
  private:
  bool _internal_has_uma_output() const;
  public:
  void clear_uma_output();
  const ::segmentation_platform::proto::UMAOutput& uma_output() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAOutput* release_uma_output();
  ::segmentation_platform::proto::UMAOutput* mutable_uma_output();
  void set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output);
  private:
  const ::segmentation_platform::proto::UMAOutput& _internal_uma_output() const;
  ::segmentation_platform::proto::UMAOutput* _internal_mutable_uma_output();
  public:
  void unsafe_arena_set_allocated_uma_output(
      ::segmentation_platform::proto::UMAOutput* uma_output);
  ::segmentation_platform::proto::UMAOutput* unsafe_arena_release_uma_output();

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.TrainingOutput)
 private:
  class _Internal;
  void set_has_uma_output();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union OutputUnion {
    constexpr OutputUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::segmentation_platform::proto::UMAOutput* uma_output_;
  } output_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class UMAOutput final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.UMAOutput) */ {
 public:
  inline UMAOutput() : UMAOutput(nullptr) {}
  ~UMAOutput() override;
  explicit PROTOBUF_CONSTEXPR UMAOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UMAOutput(const UMAOutput& from);
  UMAOutput(UMAOutput&& from) noexcept
    : UMAOutput() {
    *this = ::std::move(from);
  }

  inline UMAOutput& operator=(const UMAOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline UMAOutput& operator=(UMAOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UMAOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const UMAOutput* internal_default_instance() {
    return reinterpret_cast<const UMAOutput*>(
               &_UMAOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UMAOutput& a, UMAOutput& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UMAOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UMAOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UMAOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UMAOutput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UMAOutput& from);
  void MergeFrom(const UMAOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UMAOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.UMAOutput";
  }
  protected:
  explicit UMAOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUmaFeatureFieldNumber = 1,
    kDurationFieldNumber = 2,
  };
  // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
  bool has_uma_feature() const;
  private:
  bool _internal_has_uma_feature() const;
  public:
  void clear_uma_feature();
  const ::segmentation_platform::proto::UMAFeature& uma_feature() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAFeature* release_uma_feature();
  ::segmentation_platform::proto::UMAFeature* mutable_uma_feature();
  void set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature);
  private:
  const ::segmentation_platform::proto::UMAFeature& _internal_uma_feature() const;
  ::segmentation_platform::proto::UMAFeature* _internal_mutable_uma_feature();
  public:
  void unsafe_arena_set_allocated_uma_feature(
      ::segmentation_platform::proto::UMAFeature* uma_feature);
  ::segmentation_platform::proto::UMAFeature* unsafe_arena_release_uma_feature();

  // optional uint64 duration = 2;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  uint64_t duration() const;
  void set_duration(uint64_t value);
  private:
  uint64_t _internal_duration() const;
  void _internal_set_duration(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.UMAOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::segmentation_platform::proto::UMAFeature* uma_feature_;
  uint64_t duration_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SegmentationModelMetadata_DiscreteMapping_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry) */ {
 public:
  inline SegmentationModelMetadata_DiscreteMapping_Entry() : SegmentationModelMetadata_DiscreteMapping_Entry(nullptr) {}
  ~SegmentationModelMetadata_DiscreteMapping_Entry() override;
  explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SegmentationModelMetadata_DiscreteMapping_Entry(const SegmentationModelMetadata_DiscreteMapping_Entry& from);
  SegmentationModelMetadata_DiscreteMapping_Entry(SegmentationModelMetadata_DiscreteMapping_Entry&& from) noexcept
    : SegmentationModelMetadata_DiscreteMapping_Entry() {
    *this = ::std::move(from);
  }

  inline SegmentationModelMetadata_DiscreteMapping_Entry& operator=(const SegmentationModelMetadata_DiscreteMapping_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentationModelMetadata_DiscreteMapping_Entry& operator=(SegmentationModelMetadata_DiscreteMapping_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SegmentationModelMetadata_DiscreteMapping_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentationModelMetadata_DiscreteMapping_Entry* internal_default_instance() {
    return reinterpret_cast<const SegmentationModelMetadata_DiscreteMapping_Entry*>(
               &_SegmentationModelMetadata_DiscreteMapping_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SegmentationModelMetadata_DiscreteMapping_Entry& a, SegmentationModelMetadata_DiscreteMapping_Entry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SegmentationModelMetadata_DiscreteMapping_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentationModelMetadata_DiscreteMapping_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentationModelMetadata_DiscreteMapping_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentationModelMetadata_DiscreteMapping_Entry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from);
  void MergeFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SegmentationModelMetadata_DiscreteMapping_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry";
  }
  protected:
  explicit SegmentationModelMetadata_DiscreteMapping_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRankFieldNumber = 2,
    kMinResultFieldNumber = 1,
  };
  // optional int64 rank = 2;
  bool has_rank() const;
  private:
  bool _internal_has_rank() const;
  public:
  void clear_rank();
  int64_t rank() const;
  void set_rank(int64_t value);
  private:
  int64_t _internal_rank() const;
  void _internal_set_rank(int64_t value);
  public:

  // optional float min_result = 1;
  bool has_min_result() const;
  private:
  bool _internal_has_min_result() const;
  public:
  void clear_min_result();
  float min_result() const;
  void set_min_result(float value);
  private:
  float _internal_min_result() const;
  void _internal_set_min_result(float value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t rank_;
  float min_result_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SegmentationModelMetadata_DiscreteMapping final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping) */ {
 public:
  inline SegmentationModelMetadata_DiscreteMapping() : SegmentationModelMetadata_DiscreteMapping(nullptr) {}
  ~SegmentationModelMetadata_DiscreteMapping() override;
  explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SegmentationModelMetadata_DiscreteMapping(const SegmentationModelMetadata_DiscreteMapping& from);
  SegmentationModelMetadata_DiscreteMapping(SegmentationModelMetadata_DiscreteMapping&& from) noexcept
    : SegmentationModelMetadata_DiscreteMapping() {
    *this = ::std::move(from);
  }

  inline SegmentationModelMetadata_DiscreteMapping& operator=(const SegmentationModelMetadata_DiscreteMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentationModelMetadata_DiscreteMapping& operator=(SegmentationModelMetadata_DiscreteMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SegmentationModelMetadata_DiscreteMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentationModelMetadata_DiscreteMapping* internal_default_instance() {
    return reinterpret_cast<const SegmentationModelMetadata_DiscreteMapping*>(
               &_SegmentationModelMetadata_DiscreteMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SegmentationModelMetadata_DiscreteMapping& a, SegmentationModelMetadata_DiscreteMapping& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SegmentationModelMetadata_DiscreteMapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentationModelMetadata_DiscreteMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentationModelMetadata_DiscreteMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentationModelMetadata_DiscreteMapping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SegmentationModelMetadata_DiscreteMapping& from);
  void MergeFrom(const SegmentationModelMetadata_DiscreteMapping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SegmentationModelMetadata_DiscreteMapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping";
  }
  protected:
  explicit SegmentationModelMetadata_DiscreteMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SegmentationModelMetadata_DiscreteMapping_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry >*
      mutable_entries();
  private:
  const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& _internal_entries(int index) const;
  ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* _internal_add_entries();
  public:
  const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& entries(int index) const;
  ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse, 
    std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse, 
    std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse& other);
  static const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse*>(&_SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};

// -------------------------------------------------------------------

class SegmentationModelMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SegmentationModelMetadata) */ {
 public:
  inline SegmentationModelMetadata() : SegmentationModelMetadata(nullptr) {}
  ~SegmentationModelMetadata() override;
  explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SegmentationModelMetadata(const SegmentationModelMetadata& from);
  SegmentationModelMetadata(SegmentationModelMetadata&& from) noexcept
    : SegmentationModelMetadata() {
    *this = ::std::move(from);
  }

  inline SegmentationModelMetadata& operator=(const SegmentationModelMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentationModelMetadata& operator=(SegmentationModelMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SegmentationModelMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentationModelMetadata* internal_default_instance() {
    return reinterpret_cast<const SegmentationModelMetadata*>(
               &_SegmentationModelMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SegmentationModelMetadata& a, SegmentationModelMetadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SegmentationModelMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentationModelMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentationModelMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentationModelMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SegmentationModelMetadata& from);
  void MergeFrom(const SegmentationModelMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SegmentationModelMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "segmentation_platform.proto.SegmentationModelMetadata";
  }
  protected:
  explicit SegmentationModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SegmentationModelMetadata_DiscreteMapping DiscreteMapping;

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 1,
    kDiscreteMappingsFieldNumber = 7,
    kInputFeaturesFieldNumber = 10,
    kDefaultDiscreteMappingFieldNumber = 8,
    kVersionInfoFieldNumber = 9,
    kTrainingOutputsFieldNumber = 11,
    kBucketDurationFieldNumber = 3,
    kSignalStorageLengthFieldNumber = 4,
    kMinSignalCollectionLengthFieldNumber = 5,
    kResultTimeToLiveFieldNumber = 6,
    kTimeUnitFieldNumber = 2,
  };
  // repeated .segmentation_platform.proto.UMAFeature features = 1;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  ::segmentation_platform::proto::UMAFeature* mutable_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::UMAFeature >*
      mutable_features();
  private:
  const ::segmentation_platform::proto::UMAFeature& _internal_features(int index) const;
  ::segmentation_platform::proto::UMAFeature* _internal_add_features();
  public:
  const ::segmentation_platform::proto::UMAFeature& features(int index) const;
  ::segmentation_platform::proto::UMAFeature* add_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::UMAFeature >&
      features() const;

  // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
  int discrete_mappings_size() const;
  private:
  int _internal_discrete_mappings_size() const;
  public:
  void clear_discrete_mappings();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >&
      _internal_discrete_mappings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >*
      _internal_mutable_discrete_mappings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >&
      discrete_mappings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >*
      mutable_discrete_mappings();

  // repeated .segmentation_platform.proto.InputFeature input_features = 10;
  int input_features_size() const;
  private:
  int _internal_input_features_size() const;
  public:
  void clear_input_features();
  ::segmentation_platform::proto::InputFeature* mutable_input_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::InputFeature >*
      mutable_input_features();
  private:
  const ::segmentation_platform::proto::InputFeature& _internal_input_features(int index) const;
  ::segmentation_platform::proto::InputFeature* _internal_add_input_features();
  public:
  const ::segmentation_platform::proto::InputFeature& input_features(int index) const;
  ::segmentation_platform::proto::InputFeature* add_input_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::InputFeature >&
      input_features() const;

  // optional string default_discrete_mapping = 8;
  bool has_default_discrete_mapping() const;
  private:
  bool _internal_has_default_discrete_mapping() const;
  public:
  void clear_default_discrete_mapping();
  const std::string& default_discrete_mapping() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_discrete_mapping(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_discrete_mapping();
  PROTOBUF_NODISCARD std::string* release_default_discrete_mapping();
  void set_allocated_default_discrete_mapping(std::string* default_discrete_mapping);
  private:
  const std::string& _internal_default_discrete_mapping() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_discrete_mapping(const std::string& value);
  std::string* _internal_mutable_default_discrete_mapping();
  public:

  // optional .segmentation_platform.proto.VersionInfo version_info = 9;
  bool has_version_info() const;
  private:
  bool _internal_has_version_info() const;
  public:
  void clear_version_info();
  const ::segmentation_platform::proto::VersionInfo& version_info() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::VersionInfo* release_version_info();
  ::segmentation_platform::proto::VersionInfo* mutable_version_info();
  void set_allocated_version_info(::segmentation_platform::proto::VersionInfo* version_info);
  private:
  const ::segmentation_platform::proto::VersionInfo& _internal_version_info() const;
  ::segmentation_platform::proto::VersionInfo* _internal_mutable_version_info();
  public:
  void unsafe_arena_set_allocated_version_info(
      ::segmentation_platform::proto::VersionInfo* version_info);
  ::segmentation_platform::proto::VersionInfo* unsafe_arena_release_version_info();

  // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
  bool has_training_outputs() const;
  private:
  bool _internal_has_training_outputs() const;
  public:
  void clear_training_outputs();
  const ::segmentation_platform::proto::TrainingOutputs& training_outputs() const;
  PROTOBUF_NODISCARD ::segmentation_platform::proto::TrainingOutputs* release_training_outputs();
  ::segmentation_platform::proto::TrainingOutputs* mutable_training_outputs();
  void set_allocated_training_outputs(::segmentation_platform::proto::TrainingOutputs* training_outputs);
  private:
  const ::segmentation_platform::proto::TrainingOutputs& _internal_training_outputs() const;
  ::segmentation_platform::proto::TrainingOutputs* _internal_mutable_training_outputs();
  public:
  void unsafe_arena_set_allocated_training_outputs(
      ::segmentation_platform::proto::TrainingOutputs* training_outputs);
  ::segmentation_platform::proto::TrainingOutputs* unsafe_arena_release_training_outputs();

  // optional uint64 bucket_duration = 3;
  bool has_bucket_duration() const;
  private:
  bool _internal_has_bucket_duration() const;
  public:
  void clear_bucket_duration();
  uint64_t bucket_duration() const;
  void set_bucket_duration(uint64_t value);
  private:
  uint64_t _internal_bucket_duration() const;
  void _internal_set_bucket_duration(uint64_t value);
  public:

  // optional int64 signal_storage_length = 4;
  bool has_signal_storage_length() const;
  private:
  bool _internal_has_signal_storage_length() const;
  public:
  void clear_signal_storage_length();
  int64_t signal_storage_length() const;
  void set_signal_storage_length(int64_t value);
  private:
  int64_t _internal_signal_storage_length() const;
  void _internal_set_signal_storage_length(int64_t value);
  public:

  // optional int64 min_signal_collection_length = 5;
  bool has_min_signal_collection_length() const;
  private:
  bool _internal_has_min_signal_collection_length() const;
  public:
  void clear_min_signal_collection_length();
  int64_t min_signal_collection_length() const;
  void set_min_signal_collection_length(int64_t value);
  private:
  int64_t _internal_min_signal_collection_length() const;
  void _internal_set_min_signal_collection_length(int64_t value);
  public:

  // optional int64 result_time_to_live = 6;
  bool has_result_time_to_live() const;
  private:
  bool _internal_has_result_time_to_live() const;
  public:
  void clear_result_time_to_live();
  int64_t result_time_to_live() const;
  void set_result_time_to_live(int64_t value);
  private:
  int64_t _internal_result_time_to_live() const;
  void _internal_set_result_time_to_live(int64_t value);
  public:

  // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
  bool has_time_unit() const;
  private:
  bool _internal_has_time_unit() const;
  public:
  void clear_time_unit();
  ::segmentation_platform::proto::TimeUnit time_unit() const;
  void set_time_unit(::segmentation_platform::proto::TimeUnit value);
  private:
  ::segmentation_platform::proto::TimeUnit _internal_time_unit() const;
  void _internal_set_time_unit(::segmentation_platform::proto::TimeUnit value);
  public:

  // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SegmentationModelMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::UMAFeature > features_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse,
      std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> discrete_mappings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::InputFeature > input_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_discrete_mapping_;
  ::segmentation_platform::proto::VersionInfo* version_info_;
  ::segmentation_platform::proto::TrainingOutputs* training_outputs_;
  uint64_t bucket_duration_;
  int64_t signal_storage_length_;
  int64_t min_signal_collection_length_;
  int64_t result_time_to_live_;
  int time_unit_;
  friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VersionInfo

// optional int32 metadata_min_version = 1;
inline bool VersionInfo::_internal_has_metadata_min_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VersionInfo::has_metadata_min_version() const {
  return _internal_has_metadata_min_version();
}
inline void VersionInfo::clear_metadata_min_version() {
  metadata_min_version_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t VersionInfo::_internal_metadata_min_version() const {
  return metadata_min_version_;
}
inline int32_t VersionInfo::metadata_min_version() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.VersionInfo.metadata_min_version)
  return _internal_metadata_min_version();
}
inline void VersionInfo::_internal_set_metadata_min_version(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  metadata_min_version_ = value;
}
inline void VersionInfo::set_metadata_min_version(int32_t value) {
  _internal_set_metadata_min_version(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.VersionInfo.metadata_min_version)
}

// optional int32 metadata_cur_version = 2;
inline bool VersionInfo::_internal_has_metadata_cur_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VersionInfo::has_metadata_cur_version() const {
  return _internal_has_metadata_cur_version();
}
inline void VersionInfo::clear_metadata_cur_version() {
  metadata_cur_version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t VersionInfo::_internal_metadata_cur_version() const {
  return metadata_cur_version_;
}
inline int32_t VersionInfo::metadata_cur_version() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.VersionInfo.metadata_cur_version)
  return _internal_metadata_cur_version();
}
inline void VersionInfo::_internal_set_metadata_cur_version(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  metadata_cur_version_ = value;
}
inline void VersionInfo::set_metadata_cur_version(int32_t value) {
  _internal_set_metadata_cur_version(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.VersionInfo.metadata_cur_version)
}

// -------------------------------------------------------------------

// UMAFeature

// optional .segmentation_platform.proto.SignalType type = 1;
inline bool UMAFeature::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UMAFeature::has_type() const {
  return _internal_has_type();
}
inline void UMAFeature::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::segmentation_platform::proto::SignalType UMAFeature::_internal_type() const {
  return static_cast< ::segmentation_platform::proto::SignalType >(type_);
}
inline ::segmentation_platform::proto::SignalType UMAFeature::type() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.type)
  return _internal_type();
}
inline void UMAFeature::_internal_set_type(::segmentation_platform::proto::SignalType value) {
  assert(::segmentation_platform::proto::SignalType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void UMAFeature::set_type(::segmentation_platform::proto::SignalType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.type)
}

// optional string name = 2;
inline bool UMAFeature::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UMAFeature::has_name() const {
  return _internal_has_name();
}
inline void UMAFeature::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UMAFeature::name() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UMAFeature::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.name)
}
inline std::string* UMAFeature::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.UMAFeature.name)
  return _s;
}
inline const std::string& UMAFeature::_internal_name() const {
  return name_.Get();
}
inline void UMAFeature::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* UMAFeature::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* UMAFeature::release_name() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.UMAFeature.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UMAFeature::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.UMAFeature.name)
}

// optional fixed64 name_hash = 3;
inline bool UMAFeature::_internal_has_name_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UMAFeature::has_name_hash() const {
  return _internal_has_name_hash();
}
inline void UMAFeature::clear_name_hash() {
  name_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UMAFeature::_internal_name_hash() const {
  return name_hash_;
}
inline uint64_t UMAFeature::name_hash() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.name_hash)
  return _internal_name_hash();
}
inline void UMAFeature::_internal_set_name_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  name_hash_ = value;
}
inline void UMAFeature::set_name_hash(uint64_t value) {
  _internal_set_name_hash(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.name_hash)
}

// optional uint64 bucket_count = 4;
inline bool UMAFeature::_internal_has_bucket_count() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UMAFeature::has_bucket_count() const {
  return _internal_has_bucket_count();
}
inline void UMAFeature::clear_bucket_count() {
  bucket_count_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t UMAFeature::_internal_bucket_count() const {
  return bucket_count_;
}
inline uint64_t UMAFeature::bucket_count() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.bucket_count)
  return _internal_bucket_count();
}
inline void UMAFeature::_internal_set_bucket_count(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  bucket_count_ = value;
}
inline void UMAFeature::set_bucket_count(uint64_t value) {
  _internal_set_bucket_count(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.bucket_count)
}

// optional uint64 tensor_length = 5;
inline bool UMAFeature::_internal_has_tensor_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UMAFeature::has_tensor_length() const {
  return _internal_has_tensor_length();
}
inline void UMAFeature::clear_tensor_length() {
  tensor_length_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t UMAFeature::_internal_tensor_length() const {
  return tensor_length_;
}
inline uint64_t UMAFeature::tensor_length() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.tensor_length)
  return _internal_tensor_length();
}
inline void UMAFeature::_internal_set_tensor_length(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  tensor_length_ = value;
}
inline void UMAFeature::set_tensor_length(uint64_t value) {
  _internal_set_tensor_length(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.tensor_length)
}

// optional .segmentation_platform.proto.Aggregation aggregation = 6;
inline bool UMAFeature::_internal_has_aggregation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UMAFeature::has_aggregation() const {
  return _internal_has_aggregation();
}
inline void UMAFeature::clear_aggregation() {
  aggregation_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::segmentation_platform::proto::Aggregation UMAFeature::_internal_aggregation() const {
  return static_cast< ::segmentation_platform::proto::Aggregation >(aggregation_);
}
inline ::segmentation_platform::proto::Aggregation UMAFeature::aggregation() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.aggregation)
  return _internal_aggregation();
}
inline void UMAFeature::_internal_set_aggregation(::segmentation_platform::proto::Aggregation value) {
  assert(::segmentation_platform::proto::Aggregation_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  aggregation_ = value;
}
inline void UMAFeature::set_aggregation(::segmentation_platform::proto::Aggregation value) {
  _internal_set_aggregation(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.aggregation)
}

// repeated int32 enum_ids = 7;
inline int UMAFeature::_internal_enum_ids_size() const {
  return enum_ids_.size();
}
inline int UMAFeature::enum_ids_size() const {
  return _internal_enum_ids_size();
}
inline void UMAFeature::clear_enum_ids() {
  enum_ids_.Clear();
}
inline int32_t UMAFeature::_internal_enum_ids(int index) const {
  return enum_ids_.Get(index);
}
inline int32_t UMAFeature::enum_ids(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.enum_ids)
  return _internal_enum_ids(index);
}
inline void UMAFeature::set_enum_ids(int index, int32_t value) {
  enum_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.enum_ids)
}
inline void UMAFeature::_internal_add_enum_ids(int32_t value) {
  enum_ids_.Add(value);
}
inline void UMAFeature::add_enum_ids(int32_t value) {
  _internal_add_enum_ids(value);
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.UMAFeature.enum_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UMAFeature::_internal_enum_ids() const {
  return enum_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
UMAFeature::enum_ids() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.UMAFeature.enum_ids)
  return _internal_enum_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UMAFeature::_internal_mutable_enum_ids() {
  return &enum_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
UMAFeature::mutable_enum_ids() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.UMAFeature.enum_ids)
  return _internal_mutable_enum_ids();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CustomInput

// optional int32 tensor_length = 1;
inline bool CustomInput::_internal_has_tensor_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomInput::has_tensor_length() const {
  return _internal_has_tensor_length();
}
inline void CustomInput::clear_tensor_length() {
  tensor_length_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CustomInput::_internal_tensor_length() const {
  return tensor_length_;
}
inline int32_t CustomInput::tensor_length() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.tensor_length)
  return _internal_tensor_length();
}
inline void CustomInput::_internal_set_tensor_length(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  tensor_length_ = value;
}
inline void CustomInput::set_tensor_length(int32_t value) {
  _internal_set_tensor_length(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.tensor_length)
}

// optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
inline bool CustomInput::_internal_has_fill_policy() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CustomInput::has_fill_policy() const {
  return _internal_has_fill_policy();
}
inline void CustomInput::clear_fill_policy() {
  fill_policy_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::segmentation_platform::proto::CustomInput_FillPolicy CustomInput::_internal_fill_policy() const {
  return static_cast< ::segmentation_platform::proto::CustomInput_FillPolicy >(fill_policy_);
}
inline ::segmentation_platform::proto::CustomInput_FillPolicy CustomInput::fill_policy() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.fill_policy)
  return _internal_fill_policy();
}
inline void CustomInput::_internal_set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value) {
  assert(::segmentation_platform::proto::CustomInput_FillPolicy_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  fill_policy_ = value;
}
inline void CustomInput::set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value) {
  _internal_set_fill_policy(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.fill_policy)
}

// repeated float default_value = 3;
inline int CustomInput::_internal_default_value_size() const {
  return default_value_.size();
}
inline int CustomInput::default_value_size() const {
  return _internal_default_value_size();
}
inline void CustomInput::clear_default_value() {
  default_value_.Clear();
}
inline float CustomInput::_internal_default_value(int index) const {
  return default_value_.Get(index);
}
inline float CustomInput::default_value(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.default_value)
  return _internal_default_value(index);
}
inline void CustomInput::set_default_value(int index, float value) {
  default_value_.Set(index, value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.default_value)
}
inline void CustomInput::_internal_add_default_value(float value) {
  default_value_.Add(value);
}
inline void CustomInput::add_default_value(float value) {
  _internal_add_default_value(value);
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.CustomInput.default_value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CustomInput::_internal_default_value() const {
  return default_value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
CustomInput::default_value() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.CustomInput.default_value)
  return _internal_default_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CustomInput::_internal_mutable_default_value() {
  return &default_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
CustomInput::mutable_default_value() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.CustomInput.default_value)
  return _internal_mutable_default_value();
}

// map<string, string> additional_args = 4;
inline int CustomInput::_internal_additional_args_size() const {
  return additional_args_.size();
}
inline int CustomInput::additional_args_size() const {
  return _internal_additional_args_size();
}
inline void CustomInput::clear_additional_args() {
  additional_args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CustomInput::_internal_additional_args() const {
  return additional_args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CustomInput::additional_args() const {
  // @@protoc_insertion_point(field_map:segmentation_platform.proto.CustomInput.additional_args)
  return _internal_additional_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CustomInput::_internal_mutable_additional_args() {
  return additional_args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CustomInput::mutable_additional_args() {
  // @@protoc_insertion_point(field_mutable_map:segmentation_platform.proto.CustomInput.additional_args)
  return _internal_mutable_additional_args();
}

// optional string name = 5;
inline bool CustomInput::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomInput::has_name() const {
  return _internal_has_name();
}
inline void CustomInput::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomInput::name() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomInput::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.name)
}
inline std::string* CustomInput::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.CustomInput.name)
  return _s;
}
inline const std::string& CustomInput::_internal_name() const {
  return name_.Get();
}
inline void CustomInput::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomInput::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomInput::release_name() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.CustomInput.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomInput::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.CustomInput.name)
}

// -------------------------------------------------------------------

// SignalFilterConfig_UkmEvent

// optional uint64 event_hash = 1;
inline bool SignalFilterConfig_UkmEvent::_internal_has_event_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignalFilterConfig_UkmEvent::has_event_hash() const {
  return _internal_has_event_hash();
}
inline void SignalFilterConfig_UkmEvent::clear_event_hash() {
  event_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SignalFilterConfig_UkmEvent::_internal_event_hash() const {
  return event_hash_;
}
inline uint64_t SignalFilterConfig_UkmEvent::event_hash() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SignalFilterConfig.UkmEvent.event_hash)
  return _internal_event_hash();
}
inline void SignalFilterConfig_UkmEvent::_internal_set_event_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  event_hash_ = value;
}
inline void SignalFilterConfig_UkmEvent::set_event_hash(uint64_t value) {
  _internal_set_event_hash(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SignalFilterConfig.UkmEvent.event_hash)
}

// repeated uint64 metric_hash_filter = 2;
inline int SignalFilterConfig_UkmEvent::_internal_metric_hash_filter_size() const {
  return metric_hash_filter_.size();
}
inline int SignalFilterConfig_UkmEvent::metric_hash_filter_size() const {
  return _internal_metric_hash_filter_size();
}
inline void SignalFilterConfig_UkmEvent::clear_metric_hash_filter() {
  metric_hash_filter_.Clear();
}
inline uint64_t SignalFilterConfig_UkmEvent::_internal_metric_hash_filter(int index) const {
  return metric_hash_filter_.Get(index);
}
inline uint64_t SignalFilterConfig_UkmEvent::metric_hash_filter(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
  return _internal_metric_hash_filter(index);
}
inline void SignalFilterConfig_UkmEvent::set_metric_hash_filter(int index, uint64_t value) {
  metric_hash_filter_.Set(index, value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
}
inline void SignalFilterConfig_UkmEvent::_internal_add_metric_hash_filter(uint64_t value) {
  metric_hash_filter_.Add(value);
}
inline void SignalFilterConfig_UkmEvent::add_metric_hash_filter(uint64_t value) {
  _internal_add_metric_hash_filter(value);
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SignalFilterConfig_UkmEvent::_internal_metric_hash_filter() const {
  return metric_hash_filter_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SignalFilterConfig_UkmEvent::metric_hash_filter() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
  return _internal_metric_hash_filter();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SignalFilterConfig_UkmEvent::_internal_mutable_metric_hash_filter() {
  return &metric_hash_filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SignalFilterConfig_UkmEvent::mutable_metric_hash_filter() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
  return _internal_mutable_metric_hash_filter();
}

// -------------------------------------------------------------------

// SignalFilterConfig

// repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
inline int SignalFilterConfig::_internal_ukm_events_size() const {
  return ukm_events_.size();
}
inline int SignalFilterConfig::ukm_events_size() const {
  return _internal_ukm_events_size();
}
inline void SignalFilterConfig::clear_ukm_events() {
  ukm_events_.Clear();
}
inline ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* SignalFilterConfig::mutable_ukm_events(int index) {
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SignalFilterConfig.ukm_events)
  return ukm_events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent >*
SignalFilterConfig::mutable_ukm_events() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SignalFilterConfig.ukm_events)
  return &ukm_events_;
}
inline const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& SignalFilterConfig::_internal_ukm_events(int index) const {
  return ukm_events_.Get(index);
}
inline const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& SignalFilterConfig::ukm_events(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SignalFilterConfig.ukm_events)
  return _internal_ukm_events(index);
}
inline ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* SignalFilterConfig::_internal_add_ukm_events() {
  return ukm_events_.Add();
}
inline ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* SignalFilterConfig::add_ukm_events() {
  ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* _add = _internal_add_ukm_events();
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SignalFilterConfig.ukm_events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent >&
SignalFilterConfig::ukm_events() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SignalFilterConfig.ukm_events)
  return ukm_events_;
}

// -------------------------------------------------------------------

// SqlFeature_BindValue

// repeated int32 bind_field_index = 1;
inline int SqlFeature_BindValue::_internal_bind_field_index_size() const {
  return bind_field_index_.size();
}
inline int SqlFeature_BindValue::bind_field_index_size() const {
  return _internal_bind_field_index_size();
}
inline void SqlFeature_BindValue::clear_bind_field_index() {
  bind_field_index_.Clear();
}
inline int32_t SqlFeature_BindValue::_internal_bind_field_index(int index) const {
  return bind_field_index_.Get(index);
}
inline int32_t SqlFeature_BindValue::bind_field_index(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
  return _internal_bind_field_index(index);
}
inline void SqlFeature_BindValue::set_bind_field_index(int index, int32_t value) {
  bind_field_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
}
inline void SqlFeature_BindValue::_internal_add_bind_field_index(int32_t value) {
  bind_field_index_.Add(value);
}
inline void SqlFeature_BindValue::add_bind_field_index(int32_t value) {
  _internal_add_bind_field_index(value);
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SqlFeature_BindValue::_internal_bind_field_index() const {
  return bind_field_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SqlFeature_BindValue::bind_field_index() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
  return _internal_bind_field_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SqlFeature_BindValue::_internal_mutable_bind_field_index() {
  return &bind_field_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SqlFeature_BindValue::mutable_bind_field_index() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
  return _internal_mutable_bind_field_index();
}

// optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
inline bool SqlFeature_BindValue::_internal_has_param_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SqlFeature_BindValue::has_param_type() const {
  return _internal_has_param_type();
}
inline void SqlFeature_BindValue::clear_param_type() {
  param_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::segmentation_platform::proto::SqlFeature_BindValue_ParamType SqlFeature_BindValue::_internal_param_type() const {
  return static_cast< ::segmentation_platform::proto::SqlFeature_BindValue_ParamType >(param_type_);
}
inline ::segmentation_platform::proto::SqlFeature_BindValue_ParamType SqlFeature_BindValue::param_type() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.BindValue.param_type)
  return _internal_param_type();
}
inline void SqlFeature_BindValue::_internal_set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value) {
  assert(::segmentation_platform::proto::SqlFeature_BindValue_ParamType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  param_type_ = value;
}
inline void SqlFeature_BindValue::set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value) {
  _internal_set_param_type(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.BindValue.param_type)
}

// optional .segmentation_platform.proto.CustomInput value = 3;
inline bool SqlFeature_BindValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool SqlFeature_BindValue::has_value() const {
  return _internal_has_value();
}
inline void SqlFeature_BindValue::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::segmentation_platform::proto::CustomInput& SqlFeature_BindValue::_internal_value() const {
  const ::segmentation_platform::proto::CustomInput* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::segmentation_platform::proto::CustomInput&>(
      ::segmentation_platform::proto::_CustomInput_default_instance_);
}
inline const ::segmentation_platform::proto::CustomInput& SqlFeature_BindValue::value() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.BindValue.value)
  return _internal_value();
}
inline void SqlFeature_BindValue::unsafe_arena_set_allocated_value(
    ::segmentation_platform::proto::CustomInput* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SqlFeature.BindValue.value)
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::release_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::segmentation_platform::proto::CustomInput* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.BindValue.value)
  _has_bits_[0] &= ~0x00000001u;
  ::segmentation_platform::proto::CustomInput* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::segmentation_platform::proto::CustomInput>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::mutable_value() {
  ::segmentation_platform::proto::CustomInput* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.BindValue.value)
  return _msg;
}
inline void SqlFeature_BindValue::set_allocated_value(::segmentation_platform::proto::CustomInput* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.BindValue.value)
}

// -------------------------------------------------------------------

// SqlFeature

// optional string sql = 1;
inline bool SqlFeature::_internal_has_sql() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SqlFeature::has_sql() const {
  return _internal_has_sql();
}
inline void SqlFeature::clear_sql() {
  sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SqlFeature::sql() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SqlFeature::set_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.sql)
}
inline std::string* SqlFeature::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.sql)
  return _s;
}
inline const std::string& SqlFeature::_internal_sql() const {
  return sql_.Get();
}
inline void SqlFeature::_internal_set_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sql_.Set(value, GetArenaForAllocation());
}
inline std::string* SqlFeature::_internal_mutable_sql() {
  _has_bits_[0] |= 0x00000001u;
  return sql_.Mutable(GetArenaForAllocation());
}
inline std::string* SqlFeature::release_sql() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.sql)
  if (!_internal_has_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sql_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sql_.IsDefault()) {
    sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SqlFeature::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sql_.IsDefault()) {
    sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.sql)
}

// optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
inline bool SqlFeature::_internal_has_signal_filter() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || signal_filter_ != nullptr);
  return value;
}
inline bool SqlFeature::has_signal_filter() const {
  return _internal_has_signal_filter();
}
inline void SqlFeature::clear_signal_filter() {
  if (signal_filter_ != nullptr) signal_filter_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::segmentation_platform::proto::SignalFilterConfig& SqlFeature::_internal_signal_filter() const {
  const ::segmentation_platform::proto::SignalFilterConfig* p = signal_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::segmentation_platform::proto::SignalFilterConfig&>(
      ::segmentation_platform::proto::_SignalFilterConfig_default_instance_);
}
inline const ::segmentation_platform::proto::SignalFilterConfig& SqlFeature::signal_filter() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.signal_filter)
  return _internal_signal_filter();
}
inline void SqlFeature::unsafe_arena_set_allocated_signal_filter(
    ::segmentation_platform::proto::SignalFilterConfig* signal_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_filter_);
  }
  signal_filter_ = signal_filter;
  if (signal_filter) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SqlFeature.signal_filter)
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::release_signal_filter() {
  _has_bits_[0] &= ~0x00000004u;
  ::segmentation_platform::proto::SignalFilterConfig* temp = signal_filter_;
  signal_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::unsafe_arena_release_signal_filter() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.signal_filter)
  _has_bits_[0] &= ~0x00000004u;
  ::segmentation_platform::proto::SignalFilterConfig* temp = signal_filter_;
  signal_filter_ = nullptr;
  return temp;
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::_internal_mutable_signal_filter() {
  _has_bits_[0] |= 0x00000004u;
  if (signal_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig>(GetArenaForAllocation());
    signal_filter_ = p;
  }
  return signal_filter_;
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::mutable_signal_filter() {
  ::segmentation_platform::proto::SignalFilterConfig* _msg = _internal_mutable_signal_filter();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.signal_filter)
  return _msg;
}
inline void SqlFeature::set_allocated_signal_filter(::segmentation_platform::proto::SignalFilterConfig* signal_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete signal_filter_;
  }
  if (signal_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal_filter);
    if (message_arena != submessage_arena) {
      signal_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signal_filter_ = signal_filter;
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.signal_filter)
}

// repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
inline int SqlFeature::_internal_bind_values_size() const {
  return bind_values_.size();
}
inline int SqlFeature::bind_values_size() const {
  return _internal_bind_values_size();
}
inline void SqlFeature::clear_bind_values() {
  bind_values_.Clear();
}
inline ::segmentation_platform::proto::SqlFeature_BindValue* SqlFeature::mutable_bind_values(int index) {
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.bind_values)
  return bind_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SqlFeature_BindValue >*
SqlFeature::mutable_bind_values() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SqlFeature.bind_values)
  return &bind_values_;
}
inline const ::segmentation_platform::proto::SqlFeature_BindValue& SqlFeature::_internal_bind_values(int index) const {
  return bind_values_.Get(index);
}
inline const ::segmentation_platform::proto::SqlFeature_BindValue& SqlFeature::bind_values(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.bind_values)
  return _internal_bind_values(index);
}
inline ::segmentation_platform::proto::SqlFeature_BindValue* SqlFeature::_internal_add_bind_values() {
  return bind_values_.Add();
}
inline ::segmentation_platform::proto::SqlFeature_BindValue* SqlFeature::add_bind_values() {
  ::segmentation_platform::proto::SqlFeature_BindValue* _add = _internal_add_bind_values();
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SqlFeature.bind_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SqlFeature_BindValue >&
SqlFeature::bind_values() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SqlFeature.bind_values)
  return bind_values_;
}

// optional string name = 4;
inline bool SqlFeature::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SqlFeature::has_name() const {
  return _internal_has_name();
}
inline void SqlFeature::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SqlFeature::name() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SqlFeature::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.name)
}
inline std::string* SqlFeature::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.name)
  return _s;
}
inline const std::string& SqlFeature::_internal_name() const {
  return name_.Get();
}
inline void SqlFeature::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* SqlFeature::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* SqlFeature::release_name() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SqlFeature::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.name)
}

// -------------------------------------------------------------------

// InputFeature

// .segmentation_platform.proto.UMAFeature uma_feature = 1;
inline bool InputFeature::_internal_has_uma_feature() const {
  return Feature_case() == kUmaFeature;
}
inline bool InputFeature::has_uma_feature() const {
  return _internal_has_uma_feature();
}
inline void InputFeature::set_has_uma_feature() {
  _oneof_case_[0] = kUmaFeature;
}
inline void InputFeature::clear_uma_feature() {
  if (_internal_has_uma_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Feature_.uma_feature_;
    }
    clear_has_Feature();
  }
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::release_uma_feature() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.InputFeature.uma_feature)
  if (_internal_has_uma_feature()) {
    clear_has_Feature();
    ::segmentation_platform::proto::UMAFeature* temp = Feature_.uma_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Feature_.uma_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::segmentation_platform::proto::UMAFeature& InputFeature::_internal_uma_feature() const {
  return _internal_has_uma_feature()
      ? *Feature_.uma_feature_
      : reinterpret_cast< ::segmentation_platform::proto::UMAFeature&>(::segmentation_platform::proto::_UMAFeature_default_instance_);
}
inline const ::segmentation_platform::proto::UMAFeature& InputFeature::uma_feature() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.InputFeature.uma_feature)
  return _internal_uma_feature();
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::unsafe_arena_release_uma_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.InputFeature.uma_feature)
  if (_internal_has_uma_feature()) {
    clear_has_Feature();
    ::segmentation_platform::proto::UMAFeature* temp = Feature_.uma_feature_;
    Feature_.uma_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputFeature::unsafe_arena_set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature) {
  clear_Feature();
  if (uma_feature) {
    set_has_uma_feature();
    Feature_.uma_feature_ = uma_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.InputFeature.uma_feature)
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::_internal_mutable_uma_feature() {
  if (!_internal_has_uma_feature()) {
    clear_Feature();
    set_has_uma_feature();
    Feature_.uma_feature_ = CreateMaybeMessage< ::segmentation_platform::proto::UMAFeature >(GetArenaForAllocation());
  }
  return Feature_.uma_feature_;
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::mutable_uma_feature() {
  ::segmentation_platform::proto::UMAFeature* _msg = _internal_mutable_uma_feature();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.InputFeature.uma_feature)
  return _msg;
}

// .segmentation_platform.proto.CustomInput custom_input = 2;
inline bool InputFeature::_internal_has_custom_input() const {
  return Feature_case() == kCustomInput;
}
inline bool InputFeature::has_custom_input() const {
  return _internal_has_custom_input();
}
inline void InputFeature::set_has_custom_input() {
  _oneof_case_[0] = kCustomInput;
}
inline void InputFeature::clear_custom_input() {
  if (_internal_has_custom_input()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Feature_.custom_input_;
    }
    clear_has_Feature();
  }
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::release_custom_input() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.InputFeature.custom_input)
  if (_internal_has_custom_input()) {
    clear_has_Feature();
    ::segmentation_platform::proto::CustomInput* temp = Feature_.custom_input_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Feature_.custom_input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::segmentation_platform::proto::CustomInput& InputFeature::_internal_custom_input() const {
  return _internal_has_custom_input()
      ? *Feature_.custom_input_
      : reinterpret_cast< ::segmentation_platform::proto::CustomInput&>(::segmentation_platform::proto::_CustomInput_default_instance_);
}
inline const ::segmentation_platform::proto::CustomInput& InputFeature::custom_input() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.InputFeature.custom_input)
  return _internal_custom_input();
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::unsafe_arena_release_custom_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.InputFeature.custom_input)
  if (_internal_has_custom_input()) {
    clear_has_Feature();
    ::segmentation_platform::proto::CustomInput* temp = Feature_.custom_input_;
    Feature_.custom_input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputFeature::unsafe_arena_set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input) {
  clear_Feature();
  if (custom_input) {
    set_has_custom_input();
    Feature_.custom_input_ = custom_input;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.InputFeature.custom_input)
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::_internal_mutable_custom_input() {
  if (!_internal_has_custom_input()) {
    clear_Feature();
    set_has_custom_input();
    Feature_.custom_input_ = CreateMaybeMessage< ::segmentation_platform::proto::CustomInput >(GetArenaForAllocation());
  }
  return Feature_.custom_input_;
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::mutable_custom_input() {
  ::segmentation_platform::proto::CustomInput* _msg = _internal_mutable_custom_input();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.InputFeature.custom_input)
  return _msg;
}

// .segmentation_platform.proto.SqlFeature sql_feature = 3;
inline bool InputFeature::_internal_has_sql_feature() const {
  return Feature_case() == kSqlFeature;
}
inline bool InputFeature::has_sql_feature() const {
  return _internal_has_sql_feature();
}
inline void InputFeature::set_has_sql_feature() {
  _oneof_case_[0] = kSqlFeature;
}
inline void InputFeature::clear_sql_feature() {
  if (_internal_has_sql_feature()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Feature_.sql_feature_;
    }
    clear_has_Feature();
  }
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::release_sql_feature() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.InputFeature.sql_feature)
  if (_internal_has_sql_feature()) {
    clear_has_Feature();
    ::segmentation_platform::proto::SqlFeature* temp = Feature_.sql_feature_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Feature_.sql_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::segmentation_platform::proto::SqlFeature& InputFeature::_internal_sql_feature() const {
  return _internal_has_sql_feature()
      ? *Feature_.sql_feature_
      : reinterpret_cast< ::segmentation_platform::proto::SqlFeature&>(::segmentation_platform::proto::_SqlFeature_default_instance_);
}
inline const ::segmentation_platform::proto::SqlFeature& InputFeature::sql_feature() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.InputFeature.sql_feature)
  return _internal_sql_feature();
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::unsafe_arena_release_sql_feature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.InputFeature.sql_feature)
  if (_internal_has_sql_feature()) {
    clear_has_Feature();
    ::segmentation_platform::proto::SqlFeature* temp = Feature_.sql_feature_;
    Feature_.sql_feature_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputFeature::unsafe_arena_set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature) {
  clear_Feature();
  if (sql_feature) {
    set_has_sql_feature();
    Feature_.sql_feature_ = sql_feature;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.InputFeature.sql_feature)
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::_internal_mutable_sql_feature() {
  if (!_internal_has_sql_feature()) {
    clear_Feature();
    set_has_sql_feature();
    Feature_.sql_feature_ = CreateMaybeMessage< ::segmentation_platform::proto::SqlFeature >(GetArenaForAllocation());
  }
  return Feature_.sql_feature_;
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::mutable_sql_feature() {
  ::segmentation_platform::proto::SqlFeature* _msg = _internal_mutable_sql_feature();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.InputFeature.sql_feature)
  return _msg;
}

inline bool InputFeature::has_Feature() const {
  return Feature_case() != FEATURE_NOT_SET;
}
inline void InputFeature::clear_has_Feature() {
  _oneof_case_[0] = FEATURE_NOT_SET;
}
inline InputFeature::FeatureCase InputFeature::Feature_case() const {
  return InputFeature::FeatureCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrainingOutputs

// repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
inline int TrainingOutputs::_internal_outputs_size() const {
  return outputs_.size();
}
inline int TrainingOutputs::outputs_size() const {
  return _internal_outputs_size();
}
inline void TrainingOutputs::clear_outputs() {
  outputs_.Clear();
}
inline ::segmentation_platform::proto::TrainingOutput* TrainingOutputs::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutputs.outputs)
  return outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::TrainingOutput >*
TrainingOutputs::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.TrainingOutputs.outputs)
  return &outputs_;
}
inline const ::segmentation_platform::proto::TrainingOutput& TrainingOutputs::_internal_outputs(int index) const {
  return outputs_.Get(index);
}
inline const ::segmentation_platform::proto::TrainingOutput& TrainingOutputs::outputs(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.outputs)
  return _internal_outputs(index);
}
inline ::segmentation_platform::proto::TrainingOutput* TrainingOutputs::_internal_add_outputs() {
  return outputs_.Add();
}
inline ::segmentation_platform::proto::TrainingOutput* TrainingOutputs::add_outputs() {
  ::segmentation_platform::proto::TrainingOutput* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.TrainingOutputs.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::TrainingOutput >&
TrainingOutputs::outputs() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.TrainingOutputs.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// TrainingOutput

// .segmentation_platform.proto.UMAOutput uma_output = 1;
inline bool TrainingOutput::_internal_has_uma_output() const {
  return output_case() == kUmaOutput;
}
inline bool TrainingOutput::has_uma_output() const {
  return _internal_has_uma_output();
}
inline void TrainingOutput::set_has_uma_output() {
  _oneof_case_[0] = kUmaOutput;
}
inline void TrainingOutput::clear_uma_output() {
  if (_internal_has_uma_output()) {
    if (GetArenaForAllocation() == nullptr) {
      delete output_.uma_output_;
    }
    clear_has_output();
  }
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::release_uma_output() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.TrainingOutput.uma_output)
  if (_internal_has_uma_output()) {
    clear_has_output();
    ::segmentation_platform::proto::UMAOutput* temp = output_.uma_output_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    output_.uma_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::segmentation_platform::proto::UMAOutput& TrainingOutput::_internal_uma_output() const {
  return _internal_has_uma_output()
      ? *output_.uma_output_
      : reinterpret_cast< ::segmentation_platform::proto::UMAOutput&>(::segmentation_platform::proto::_UMAOutput_default_instance_);
}
inline const ::segmentation_platform::proto::UMAOutput& TrainingOutput::uma_output() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutput.uma_output)
  return _internal_uma_output();
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::unsafe_arena_release_uma_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.TrainingOutput.uma_output)
  if (_internal_has_uma_output()) {
    clear_has_output();
    ::segmentation_platform::proto::UMAOutput* temp = output_.uma_output_;
    output_.uma_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrainingOutput::unsafe_arena_set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output) {
  clear_output();
  if (uma_output) {
    set_has_uma_output();
    output_.uma_output_ = uma_output;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.TrainingOutput.uma_output)
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::_internal_mutable_uma_output() {
  if (!_internal_has_uma_output()) {
    clear_output();
    set_has_uma_output();
    output_.uma_output_ = CreateMaybeMessage< ::segmentation_platform::proto::UMAOutput >(GetArenaForAllocation());
  }
  return output_.uma_output_;
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::mutable_uma_output() {
  ::segmentation_platform::proto::UMAOutput* _msg = _internal_mutable_uma_output();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutput.uma_output)
  return _msg;
}

inline bool TrainingOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void TrainingOutput::clear_has_output() {
  _oneof_case_[0] = OUTPUT_NOT_SET;
}
inline TrainingOutput::OutputCase TrainingOutput::output_case() const {
  return TrainingOutput::OutputCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UMAOutput

// optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
inline bool UMAOutput::_internal_has_uma_feature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || uma_feature_ != nullptr);
  return value;
}
inline bool UMAOutput::has_uma_feature() const {
  return _internal_has_uma_feature();
}
inline void UMAOutput::clear_uma_feature() {
  if (uma_feature_ != nullptr) uma_feature_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::segmentation_platform::proto::UMAFeature& UMAOutput::_internal_uma_feature() const {
  const ::segmentation_platform::proto::UMAFeature* p = uma_feature_;
  return p != nullptr ? *p : reinterpret_cast<const ::segmentation_platform::proto::UMAFeature&>(
      ::segmentation_platform::proto::_UMAFeature_default_instance_);
}
inline const ::segmentation_platform::proto::UMAFeature& UMAOutput::uma_feature() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAOutput.uma_feature)
  return _internal_uma_feature();
}
inline void UMAOutput::unsafe_arena_set_allocated_uma_feature(
    ::segmentation_platform::proto::UMAFeature* uma_feature) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uma_feature_);
  }
  uma_feature_ = uma_feature;
  if (uma_feature) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.UMAOutput.uma_feature)
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::release_uma_feature() {
  _has_bits_[0] &= ~0x00000001u;
  ::segmentation_platform::proto::UMAFeature* temp = uma_feature_;
  uma_feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::unsafe_arena_release_uma_feature() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.UMAOutput.uma_feature)
  _has_bits_[0] &= ~0x00000001u;
  ::segmentation_platform::proto::UMAFeature* temp = uma_feature_;
  uma_feature_ = nullptr;
  return temp;
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::_internal_mutable_uma_feature() {
  _has_bits_[0] |= 0x00000001u;
  if (uma_feature_ == nullptr) {
    auto* p = CreateMaybeMessage<::segmentation_platform::proto::UMAFeature>(GetArenaForAllocation());
    uma_feature_ = p;
  }
  return uma_feature_;
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::mutable_uma_feature() {
  ::segmentation_platform::proto::UMAFeature* _msg = _internal_mutable_uma_feature();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.UMAOutput.uma_feature)
  return _msg;
}
inline void UMAOutput::set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete uma_feature_;
  }
  if (uma_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_feature);
    if (message_arena != submessage_arena) {
      uma_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uma_feature, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  uma_feature_ = uma_feature;
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.UMAOutput.uma_feature)
}

// optional uint64 duration = 2;
inline bool UMAOutput::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UMAOutput::has_duration() const {
  return _internal_has_duration();
}
inline void UMAOutput::clear_duration() {
  duration_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UMAOutput::_internal_duration() const {
  return duration_;
}
inline uint64_t UMAOutput::duration() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAOutput.duration)
  return _internal_duration();
}
inline void UMAOutput::_internal_set_duration(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  duration_ = value;
}
inline void UMAOutput::set_duration(uint64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAOutput.duration)
}

// -------------------------------------------------------------------

// SegmentationModelMetadata_DiscreteMapping_Entry

// optional float min_result = 1;
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::_internal_has_min_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::has_min_result() const {
  return _internal_has_min_result();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::clear_min_result() {
  min_result_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SegmentationModelMetadata_DiscreteMapping_Entry::_internal_min_result() const {
  return min_result_;
}
inline float SegmentationModelMetadata_DiscreteMapping_Entry::min_result() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.min_result)
  return _internal_min_result();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::_internal_set_min_result(float value) {
  _has_bits_[0] |= 0x00000002u;
  min_result_ = value;
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::set_min_result(float value) {
  _internal_set_min_result(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.min_result)
}

// optional int64 rank = 2;
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::_internal_has_rank() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::has_rank() const {
  return _internal_has_rank();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::clear_rank() {
  rank_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t SegmentationModelMetadata_DiscreteMapping_Entry::_internal_rank() const {
  return rank_;
}
inline int64_t SegmentationModelMetadata_DiscreteMapping_Entry::rank() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.rank)
  return _internal_rank();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::_internal_set_rank(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  rank_ = value;
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::set_rank(int64_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.rank)
}

// -------------------------------------------------------------------

// SegmentationModelMetadata_DiscreteMapping

// repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
inline int SegmentationModelMetadata_DiscreteMapping::_internal_entries_size() const {
  return entries_.size();
}
inline int SegmentationModelMetadata_DiscreteMapping::entries_size() const {
  return _internal_entries_size();
}
inline void SegmentationModelMetadata_DiscreteMapping::clear_entries() {
  entries_.Clear();
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* SegmentationModelMetadata_DiscreteMapping::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry >*
SegmentationModelMetadata_DiscreteMapping::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
  return &entries_;
}
inline const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& SegmentationModelMetadata_DiscreteMapping::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& SegmentationModelMetadata_DiscreteMapping::entries(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
  return _internal_entries(index);
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* SegmentationModelMetadata_DiscreteMapping::_internal_add_entries() {
  return entries_.Add();
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* SegmentationModelMetadata_DiscreteMapping::add_entries() {
  ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry >&
SegmentationModelMetadata_DiscreteMapping::entries() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
  return entries_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SegmentationModelMetadata

// optional .segmentation_platform.proto.VersionInfo version_info = 9;
inline bool SegmentationModelMetadata::_internal_has_version_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || version_info_ != nullptr);
  return value;
}
inline bool SegmentationModelMetadata::has_version_info() const {
  return _internal_has_version_info();
}
inline void SegmentationModelMetadata::clear_version_info() {
  if (version_info_ != nullptr) version_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::segmentation_platform::proto::VersionInfo& SegmentationModelMetadata::_internal_version_info() const {
  const ::segmentation_platform::proto::VersionInfo* p = version_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::segmentation_platform::proto::VersionInfo&>(
      ::segmentation_platform::proto::_VersionInfo_default_instance_);
}
inline const ::segmentation_platform::proto::VersionInfo& SegmentationModelMetadata::version_info() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.version_info)
  return _internal_version_info();
}
inline void SegmentationModelMetadata::unsafe_arena_set_allocated_version_info(
    ::segmentation_platform::proto::VersionInfo* version_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_info_);
  }
  version_info_ = version_info;
  if (version_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.version_info)
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::release_version_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::segmentation_platform::proto::VersionInfo* temp = version_info_;
  version_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::unsafe_arena_release_version_info() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.version_info)
  _has_bits_[0] &= ~0x00000002u;
  ::segmentation_platform::proto::VersionInfo* temp = version_info_;
  version_info_ = nullptr;
  return temp;
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::_internal_mutable_version_info() {
  _has_bits_[0] |= 0x00000002u;
  if (version_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::segmentation_platform::proto::VersionInfo>(GetArenaForAllocation());
    version_info_ = p;
  }
  return version_info_;
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::mutable_version_info() {
  ::segmentation_platform::proto::VersionInfo* _msg = _internal_mutable_version_info();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.version_info)
  return _msg;
}
inline void SegmentationModelMetadata::set_allocated_version_info(::segmentation_platform::proto::VersionInfo* version_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete version_info_;
  }
  if (version_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version_info);
    if (message_arena != submessage_arena) {
      version_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_info_ = version_info;
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.version_info)
}

// repeated .segmentation_platform.proto.UMAFeature features = 1;
inline int SegmentationModelMetadata::_internal_features_size() const {
  return features_.size();
}
inline int SegmentationModelMetadata::features_size() const {
  return _internal_features_size();
}
inline void SegmentationModelMetadata::clear_features() {
  features_.Clear();
}
inline ::segmentation_platform::proto::UMAFeature* SegmentationModelMetadata::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.features)
  return features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::UMAFeature >*
SegmentationModelMetadata::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SegmentationModelMetadata.features)
  return &features_;
}
inline const ::segmentation_platform::proto::UMAFeature& SegmentationModelMetadata::_internal_features(int index) const {
  return features_.Get(index);
}
inline const ::segmentation_platform::proto::UMAFeature& SegmentationModelMetadata::features(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.features)
  return _internal_features(index);
}
inline ::segmentation_platform::proto::UMAFeature* SegmentationModelMetadata::_internal_add_features() {
  return features_.Add();
}
inline ::segmentation_platform::proto::UMAFeature* SegmentationModelMetadata::add_features() {
  ::segmentation_platform::proto::UMAFeature* _add = _internal_add_features();
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SegmentationModelMetadata.features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::UMAFeature >&
SegmentationModelMetadata::features() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SegmentationModelMetadata.features)
  return features_;
}

// repeated .segmentation_platform.proto.InputFeature input_features = 10;
inline int SegmentationModelMetadata::_internal_input_features_size() const {
  return input_features_.size();
}
inline int SegmentationModelMetadata::input_features_size() const {
  return _internal_input_features_size();
}
inline void SegmentationModelMetadata::clear_input_features() {
  input_features_.Clear();
}
inline ::segmentation_platform::proto::InputFeature* SegmentationModelMetadata::mutable_input_features(int index) {
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.input_features)
  return input_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::InputFeature >*
SegmentationModelMetadata::mutable_input_features() {
  // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SegmentationModelMetadata.input_features)
  return &input_features_;
}
inline const ::segmentation_platform::proto::InputFeature& SegmentationModelMetadata::_internal_input_features(int index) const {
  return input_features_.Get(index);
}
inline const ::segmentation_platform::proto::InputFeature& SegmentationModelMetadata::input_features(int index) const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.input_features)
  return _internal_input_features(index);
}
inline ::segmentation_platform::proto::InputFeature* SegmentationModelMetadata::_internal_add_input_features() {
  return input_features_.Add();
}
inline ::segmentation_platform::proto::InputFeature* SegmentationModelMetadata::add_input_features() {
  ::segmentation_platform::proto::InputFeature* _add = _internal_add_input_features();
  // @@protoc_insertion_point(field_add:segmentation_platform.proto.SegmentationModelMetadata.input_features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::segmentation_platform::proto::InputFeature >&
SegmentationModelMetadata::input_features() const {
  // @@protoc_insertion_point(field_list:segmentation_platform.proto.SegmentationModelMetadata.input_features)
  return input_features_;
}

// optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
inline bool SegmentationModelMetadata::_internal_has_training_outputs() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || training_outputs_ != nullptr);
  return value;
}
inline bool SegmentationModelMetadata::has_training_outputs() const {
  return _internal_has_training_outputs();
}
inline void SegmentationModelMetadata::clear_training_outputs() {
  if (training_outputs_ != nullptr) training_outputs_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::segmentation_platform::proto::TrainingOutputs& SegmentationModelMetadata::_internal_training_outputs() const {
  const ::segmentation_platform::proto::TrainingOutputs* p = training_outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::segmentation_platform::proto::TrainingOutputs&>(
      ::segmentation_platform::proto::_TrainingOutputs_default_instance_);
}
inline const ::segmentation_platform::proto::TrainingOutputs& SegmentationModelMetadata::training_outputs() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
  return _internal_training_outputs();
}
inline void SegmentationModelMetadata::unsafe_arena_set_allocated_training_outputs(
    ::segmentation_platform::proto::TrainingOutputs* training_outputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(training_outputs_);
  }
  training_outputs_ = training_outputs;
  if (training_outputs) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::release_training_outputs() {
  _has_bits_[0] &= ~0x00000004u;
  ::segmentation_platform::proto::TrainingOutputs* temp = training_outputs_;
  training_outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::unsafe_arena_release_training_outputs() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
  _has_bits_[0] &= ~0x00000004u;
  ::segmentation_platform::proto::TrainingOutputs* temp = training_outputs_;
  training_outputs_ = nullptr;
  return temp;
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::_internal_mutable_training_outputs() {
  _has_bits_[0] |= 0x00000004u;
  if (training_outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs>(GetArenaForAllocation());
    training_outputs_ = p;
  }
  return training_outputs_;
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::mutable_training_outputs() {
  ::segmentation_platform::proto::TrainingOutputs* _msg = _internal_mutable_training_outputs();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
  return _msg;
}
inline void SegmentationModelMetadata::set_allocated_training_outputs(::segmentation_platform::proto::TrainingOutputs* training_outputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete training_outputs_;
  }
  if (training_outputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(training_outputs);
    if (message_arena != submessage_arena) {
      training_outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, training_outputs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  training_outputs_ = training_outputs;
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
}

// optional .segmentation_platform.proto.TimeUnit time_unit = 2;
inline bool SegmentationModelMetadata::_internal_has_time_unit() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SegmentationModelMetadata::has_time_unit() const {
  return _internal_has_time_unit();
}
inline void SegmentationModelMetadata::clear_time_unit() {
  time_unit_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::segmentation_platform::proto::TimeUnit SegmentationModelMetadata::_internal_time_unit() const {
  return static_cast< ::segmentation_platform::proto::TimeUnit >(time_unit_);
}
inline ::segmentation_platform::proto::TimeUnit SegmentationModelMetadata::time_unit() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.time_unit)
  return _internal_time_unit();
}
inline void SegmentationModelMetadata::_internal_set_time_unit(::segmentation_platform::proto::TimeUnit value) {
  assert(::segmentation_platform::proto::TimeUnit_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  time_unit_ = value;
}
inline void SegmentationModelMetadata::set_time_unit(::segmentation_platform::proto::TimeUnit value) {
  _internal_set_time_unit(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.time_unit)
}

// optional uint64 bucket_duration = 3;
inline bool SegmentationModelMetadata::_internal_has_bucket_duration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SegmentationModelMetadata::has_bucket_duration() const {
  return _internal_has_bucket_duration();
}
inline void SegmentationModelMetadata::clear_bucket_duration() {
  bucket_duration_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t SegmentationModelMetadata::_internal_bucket_duration() const {
  return bucket_duration_;
}
inline uint64_t SegmentationModelMetadata::bucket_duration() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.bucket_duration)
  return _internal_bucket_duration();
}
inline void SegmentationModelMetadata::_internal_set_bucket_duration(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  bucket_duration_ = value;
}
inline void SegmentationModelMetadata::set_bucket_duration(uint64_t value) {
  _internal_set_bucket_duration(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.bucket_duration)
}

// optional int64 signal_storage_length = 4;
inline bool SegmentationModelMetadata::_internal_has_signal_storage_length() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SegmentationModelMetadata::has_signal_storage_length() const {
  return _internal_has_signal_storage_length();
}
inline void SegmentationModelMetadata::clear_signal_storage_length() {
  signal_storage_length_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t SegmentationModelMetadata::_internal_signal_storage_length() const {
  return signal_storage_length_;
}
inline int64_t SegmentationModelMetadata::signal_storage_length() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.signal_storage_length)
  return _internal_signal_storage_length();
}
inline void SegmentationModelMetadata::_internal_set_signal_storage_length(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  signal_storage_length_ = value;
}
inline void SegmentationModelMetadata::set_signal_storage_length(int64_t value) {
  _internal_set_signal_storage_length(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.signal_storage_length)
}

// optional int64 min_signal_collection_length = 5;
inline bool SegmentationModelMetadata::_internal_has_min_signal_collection_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SegmentationModelMetadata::has_min_signal_collection_length() const {
  return _internal_has_min_signal_collection_length();
}
inline void SegmentationModelMetadata::clear_min_signal_collection_length() {
  min_signal_collection_length_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t SegmentationModelMetadata::_internal_min_signal_collection_length() const {
  return min_signal_collection_length_;
}
inline int64_t SegmentationModelMetadata::min_signal_collection_length() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.min_signal_collection_length)
  return _internal_min_signal_collection_length();
}
inline void SegmentationModelMetadata::_internal_set_min_signal_collection_length(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  min_signal_collection_length_ = value;
}
inline void SegmentationModelMetadata::set_min_signal_collection_length(int64_t value) {
  _internal_set_min_signal_collection_length(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.min_signal_collection_length)
}

// optional int64 result_time_to_live = 6;
inline bool SegmentationModelMetadata::_internal_has_result_time_to_live() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SegmentationModelMetadata::has_result_time_to_live() const {
  return _internal_has_result_time_to_live();
}
inline void SegmentationModelMetadata::clear_result_time_to_live() {
  result_time_to_live_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t SegmentationModelMetadata::_internal_result_time_to_live() const {
  return result_time_to_live_;
}
inline int64_t SegmentationModelMetadata::result_time_to_live() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.result_time_to_live)
  return _internal_result_time_to_live();
}
inline void SegmentationModelMetadata::_internal_set_result_time_to_live(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  result_time_to_live_ = value;
}
inline void SegmentationModelMetadata::set_result_time_to_live(int64_t value) {
  _internal_set_result_time_to_live(value);
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.result_time_to_live)
}

// map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
inline int SegmentationModelMetadata::_internal_discrete_mappings_size() const {
  return discrete_mappings_.size();
}
inline int SegmentationModelMetadata::discrete_mappings_size() const {
  return _internal_discrete_mappings_size();
}
inline void SegmentationModelMetadata::clear_discrete_mappings() {
  discrete_mappings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >&
SegmentationModelMetadata::_internal_discrete_mappings() const {
  return discrete_mappings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >&
SegmentationModelMetadata::discrete_mappings() const {
  // @@protoc_insertion_point(field_map:segmentation_platform.proto.SegmentationModelMetadata.discrete_mappings)
  return _internal_discrete_mappings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >*
SegmentationModelMetadata::_internal_mutable_discrete_mappings() {
  return discrete_mappings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >*
SegmentationModelMetadata::mutable_discrete_mappings() {
  // @@protoc_insertion_point(field_mutable_map:segmentation_platform.proto.SegmentationModelMetadata.discrete_mappings)
  return _internal_mutable_discrete_mappings();
}

// optional string default_discrete_mapping = 8;
inline bool SegmentationModelMetadata::_internal_has_default_discrete_mapping() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SegmentationModelMetadata::has_default_discrete_mapping() const {
  return _internal_has_default_discrete_mapping();
}
inline void SegmentationModelMetadata::clear_default_discrete_mapping() {
  default_discrete_mapping_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SegmentationModelMetadata::default_discrete_mapping() const {
  // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
  return _internal_default_discrete_mapping();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentationModelMetadata::set_default_discrete_mapping(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 default_discrete_mapping_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
}
inline std::string* SegmentationModelMetadata::mutable_default_discrete_mapping() {
  std::string* _s = _internal_mutable_default_discrete_mapping();
  // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
  return _s;
}
inline const std::string& SegmentationModelMetadata::_internal_default_discrete_mapping() const {
  return default_discrete_mapping_.Get();
}
inline void SegmentationModelMetadata::_internal_set_default_discrete_mapping(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  default_discrete_mapping_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentationModelMetadata::_internal_mutable_default_discrete_mapping() {
  _has_bits_[0] |= 0x00000001u;
  return default_discrete_mapping_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentationModelMetadata::release_default_discrete_mapping() {
  // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
  if (!_internal_has_default_discrete_mapping()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = default_discrete_mapping_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_discrete_mapping_.IsDefault()) {
    default_discrete_mapping_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SegmentationModelMetadata::set_allocated_default_discrete_mapping(std::string* default_discrete_mapping) {
  if (default_discrete_mapping != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  default_discrete_mapping_.SetAllocated(default_discrete_mapping, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_discrete_mapping_.IsDefault()) {
    default_discrete_mapping_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace segmentation_platform

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::segmentation_platform::proto::CustomInput_FillPolicy> : ::std::true_type {};
template <> struct is_proto_enum< ::segmentation_platform::proto::SqlFeature_BindValue_ParamType> : ::std::true_type {};
template <> struct is_proto_enum< ::segmentation_platform::proto::CurrentVersion> : ::std::true_type {};
template <> struct is_proto_enum< ::segmentation_platform::proto::TimeUnit> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto
