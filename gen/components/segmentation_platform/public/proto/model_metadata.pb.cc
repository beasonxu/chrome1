// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/segmentation_platform/public/proto/model_metadata.proto

#include "components/segmentation_platform/public/proto/model_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace segmentation_platform {
namespace proto {
PROTOBUF_CONSTEXPR VersionInfo::VersionInfo(
    ::_pbi::ConstantInitialized)
  : metadata_min_version_(0)
  , metadata_cur_version_(0){}
struct VersionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionInfoDefaultTypeInternal() {}
  union {
    VersionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
PROTOBUF_CONSTEXPR UMAFeature::UMAFeature(
    ::_pbi::ConstantInitialized)
  : enum_ids_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_hash_(uint64_t{0u})
  , type_(0)

  , aggregation_(0)

  , bucket_count_(uint64_t{0u})
  , tensor_length_(uint64_t{0u}){}
struct UMAFeatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UMAFeatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UMAFeatureDefaultTypeInternal() {}
  union {
    UMAFeature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UMAFeatureDefaultTypeInternal _UMAFeature_default_instance_;
PROTOBUF_CONSTEXPR CustomInput_AdditionalArgsEntry_DoNotUse::CustomInput_AdditionalArgsEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CustomInput_AdditionalArgsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal _CustomInput_AdditionalArgsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CustomInput::CustomInput(
    ::_pbi::ConstantInitialized)
  : default_value_()
  , additional_args_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tensor_length_(0)
  , fill_policy_(0)
{}
struct CustomInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomInputDefaultTypeInternal() {}
  union {
    CustomInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomInputDefaultTypeInternal _CustomInput_default_instance_;
PROTOBUF_CONSTEXPR SignalFilterConfig_UkmEvent::SignalFilterConfig_UkmEvent(
    ::_pbi::ConstantInitialized)
  : metric_hash_filter_()
  , event_hash_(uint64_t{0u}){}
struct SignalFilterConfig_UkmEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalFilterConfig_UkmEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalFilterConfig_UkmEventDefaultTypeInternal() {}
  union {
    SignalFilterConfig_UkmEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalFilterConfig_UkmEventDefaultTypeInternal _SignalFilterConfig_UkmEvent_default_instance_;
PROTOBUF_CONSTEXPR SignalFilterConfig::SignalFilterConfig(
    ::_pbi::ConstantInitialized)
  : ukm_events_(){}
struct SignalFilterConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignalFilterConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignalFilterConfigDefaultTypeInternal() {}
  union {
    SignalFilterConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalFilterConfigDefaultTypeInternal _SignalFilterConfig_default_instance_;
PROTOBUF_CONSTEXPR SqlFeature_BindValue::SqlFeature_BindValue(
    ::_pbi::ConstantInitialized)
  : bind_field_index_()
  , value_(nullptr)
  , param_type_(0)
{}
struct SqlFeature_BindValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SqlFeature_BindValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SqlFeature_BindValueDefaultTypeInternal() {}
  union {
    SqlFeature_BindValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SqlFeature_BindValueDefaultTypeInternal _SqlFeature_BindValue_default_instance_;
PROTOBUF_CONSTEXPR SqlFeature::SqlFeature(
    ::_pbi::ConstantInitialized)
  : bind_values_()
  , sql_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , signal_filter_(nullptr){}
struct SqlFeatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SqlFeatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SqlFeatureDefaultTypeInternal() {}
  union {
    SqlFeature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SqlFeatureDefaultTypeInternal _SqlFeature_default_instance_;
PROTOBUF_CONSTEXPR InputFeature::InputFeature(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct InputFeatureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InputFeatureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InputFeatureDefaultTypeInternal() {}
  union {
    InputFeature _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InputFeatureDefaultTypeInternal _InputFeature_default_instance_;
PROTOBUF_CONSTEXPR TrainingOutputs::TrainingOutputs(
    ::_pbi::ConstantInitialized)
  : outputs_(){}
struct TrainingOutputsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrainingOutputsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrainingOutputsDefaultTypeInternal() {}
  union {
    TrainingOutputs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainingOutputsDefaultTypeInternal _TrainingOutputs_default_instance_;
PROTOBUF_CONSTEXPR TrainingOutput::TrainingOutput(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct TrainingOutputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrainingOutputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrainingOutputDefaultTypeInternal() {}
  union {
    TrainingOutput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainingOutputDefaultTypeInternal _TrainingOutput_default_instance_;
PROTOBUF_CONSTEXPR UMAOutput::UMAOutput(
    ::_pbi::ConstantInitialized)
  : uma_feature_(nullptr)
  , duration_(uint64_t{0u}){}
struct UMAOutputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UMAOutputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UMAOutputDefaultTypeInternal() {}
  union {
    UMAOutput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UMAOutputDefaultTypeInternal _UMAOutput_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping_Entry::SegmentationModelMetadata_DiscreteMapping_Entry(
    ::_pbi::ConstantInitialized)
  : rank_(int64_t{0})
  , min_result_(0){}
struct SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal() {}
  union {
    SegmentationModelMetadata_DiscreteMapping_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal _SegmentationModelMetadata_DiscreteMapping_Entry_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping::SegmentationModelMetadata_DiscreteMapping(
    ::_pbi::ConstantInitialized)
  : entries_(){}
struct SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal() {}
  union {
    SegmentationModelMetadata_DiscreteMapping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal _SegmentationModelMetadata_DiscreteMapping_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal _SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata::SegmentationModelMetadata(
    ::_pbi::ConstantInitialized)
  : features_()
  , discrete_mappings_()
  , input_features_()
  , default_discrete_mapping_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_info_(nullptr)
  , training_outputs_(nullptr)
  , bucket_duration_(uint64_t{0u})
  , signal_storage_length_(int64_t{0})
  , min_signal_collection_length_(int64_t{0})
  , result_time_to_live_(int64_t{0})
  , time_unit_(0)
{}
struct SegmentationModelMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SegmentationModelMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SegmentationModelMetadataDefaultTypeInternal() {}
  union {
    SegmentationModelMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadataDefaultTypeInternal _SegmentationModelMetadata_default_instance_;
}  // namespace proto
}  // namespace segmentation_platform
namespace segmentation_platform {
namespace proto {
bool CustomInput_FillPolicy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomInput_FillPolicy_strings[4] = {};

static const char CustomInput_FillPolicy_names[] =
  "FILL_PREDICTION_TIME"
  "PRICE_TRACKING_HINTS"
  "TIME_RANGE_BEFORE_PREDICTION"
  "UNKNOWN_FILL_POLICY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomInput_FillPolicy_entries[] = {
  { {CustomInput_FillPolicy_names + 0, 20}, 1 },
  { {CustomInput_FillPolicy_names + 20, 20}, 3 },
  { {CustomInput_FillPolicy_names + 40, 28}, 2 },
  { {CustomInput_FillPolicy_names + 68, 19}, 0 },
};

static const int CustomInput_FillPolicy_entries_by_number[] = {
  3, // 0 -> UNKNOWN_FILL_POLICY
  0, // 1 -> FILL_PREDICTION_TIME
  2, // 2 -> TIME_RANGE_BEFORE_PREDICTION
  1, // 3 -> PRICE_TRACKING_HINTS
};

const std::string& CustomInput_FillPolicy_Name(
    CustomInput_FillPolicy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CustomInput_FillPolicy_entries,
          CustomInput_FillPolicy_entries_by_number,
          4, CustomInput_FillPolicy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CustomInput_FillPolicy_entries,
      CustomInput_FillPolicy_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CustomInput_FillPolicy_strings[idx].get();
}
bool CustomInput_FillPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomInput_FillPolicy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CustomInput_FillPolicy_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CustomInput_FillPolicy>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CustomInput_FillPolicy CustomInput::UNKNOWN_FILL_POLICY;
constexpr CustomInput_FillPolicy CustomInput::FILL_PREDICTION_TIME;
constexpr CustomInput_FillPolicy CustomInput::TIME_RANGE_BEFORE_PREDICTION;
constexpr CustomInput_FillPolicy CustomInput::PRICE_TRACKING_HINTS;
constexpr CustomInput_FillPolicy CustomInput::FillPolicy_MIN;
constexpr CustomInput_FillPolicy CustomInput::FillPolicy_MAX;
constexpr int CustomInput::FillPolicy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SqlFeature_BindValue_ParamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SqlFeature_BindValue_ParamType_strings[8] = {};

static const char SqlFeature_BindValue_ParamType_names[] =
  "BOOL"
  "DOUBLE"
  "INT"
  "INT64"
  "NULL"
  "STRING"
  "TIME"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SqlFeature_BindValue_ParamType_entries[] = {
  { {SqlFeature_BindValue_ParamType_names + 0, 4}, 2 },
  { {SqlFeature_BindValue_ParamType_names + 4, 6}, 5 },
  { {SqlFeature_BindValue_ParamType_names + 10, 3}, 3 },
  { {SqlFeature_BindValue_ParamType_names + 13, 5}, 4 },
  { {SqlFeature_BindValue_ParamType_names + 18, 4}, 1 },
  { {SqlFeature_BindValue_ParamType_names + 22, 6}, 6 },
  { {SqlFeature_BindValue_ParamType_names + 28, 4}, 7 },
  { {SqlFeature_BindValue_ParamType_names + 32, 7}, 0 },
};

static const int SqlFeature_BindValue_ParamType_entries_by_number[] = {
  7, // 0 -> UNKNOWN
  4, // 1 -> NULL
  0, // 2 -> BOOL
  2, // 3 -> INT
  3, // 4 -> INT64
  1, // 5 -> DOUBLE
  5, // 6 -> STRING
  6, // 7 -> TIME
};

const std::string& SqlFeature_BindValue_ParamType_Name(
    SqlFeature_BindValue_ParamType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SqlFeature_BindValue_ParamType_entries,
          SqlFeature_BindValue_ParamType_entries_by_number,
          8, SqlFeature_BindValue_ParamType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SqlFeature_BindValue_ParamType_entries,
      SqlFeature_BindValue_ParamType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SqlFeature_BindValue_ParamType_strings[idx].get();
}
bool SqlFeature_BindValue_ParamType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqlFeature_BindValue_ParamType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SqlFeature_BindValue_ParamType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<SqlFeature_BindValue_ParamType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::UNKNOWN;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::NULL_;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::BOOL;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::INT;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::INT64;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::DOUBLE;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::STRING;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::TIME;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::ParamType_MIN;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::ParamType_MAX;
constexpr int SqlFeature_BindValue::ParamType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CurrentVersion_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CurrentVersion_strings[1] = {};

static const char CurrentVersion_names[] =
  "METADATA_VERSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CurrentVersion_entries[] = {
  { {CurrentVersion_names + 0, 16}, 1 },
};

static const int CurrentVersion_entries_by_number[] = {
  0, // 1 -> METADATA_VERSION
};

const std::string& CurrentVersion_Name(
    CurrentVersion value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CurrentVersion_entries,
          CurrentVersion_entries_by_number,
          1, CurrentVersion_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CurrentVersion_entries,
      CurrentVersion_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CurrentVersion_strings[idx].get();
}
bool CurrentVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrentVersion* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CurrentVersion_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<CurrentVersion>(int_value);
  }
  return success;
}
bool TimeUnit_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TimeUnit_strings[8] = {};

static const char TimeUnit_names[] =
  "DAY"
  "HOUR"
  "MINUTE"
  "MONTH"
  "SECOND"
  "UNKNOWN_TIME_UNIT"
  "WEEK"
  "YEAR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TimeUnit_entries[] = {
  { {TimeUnit_names + 0, 3}, 4 },
  { {TimeUnit_names + 3, 4}, 5 },
  { {TimeUnit_names + 7, 6}, 6 },
  { {TimeUnit_names + 13, 5}, 2 },
  { {TimeUnit_names + 18, 6}, 7 },
  { {TimeUnit_names + 24, 17}, 0 },
  { {TimeUnit_names + 41, 4}, 3 },
  { {TimeUnit_names + 45, 4}, 1 },
};

static const int TimeUnit_entries_by_number[] = {
  5, // 0 -> UNKNOWN_TIME_UNIT
  7, // 1 -> YEAR
  3, // 2 -> MONTH
  6, // 3 -> WEEK
  0, // 4 -> DAY
  1, // 5 -> HOUR
  2, // 6 -> MINUTE
  4, // 7 -> SECOND
};

const std::string& TimeUnit_Name(
    TimeUnit value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TimeUnit_entries,
          TimeUnit_entries_by_number,
          8, TimeUnit_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TimeUnit_entries,
      TimeUnit_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TimeUnit_strings[idx].get();
}
bool TimeUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeUnit* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TimeUnit_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TimeUnit>(int_value);
  }
  return success;
}

// ===================================================================

class VersionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VersionInfo>()._has_bits_);
  static void set_has_metadata_min_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_metadata_cur_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

VersionInfo::VersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.VersionInfo)
}
VersionInfo::VersionInfo(const VersionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&metadata_min_version_, &from.metadata_min_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&metadata_cur_version_) -
    reinterpret_cast<char*>(&metadata_min_version_)) + sizeof(metadata_cur_version_));
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.VersionInfo)
}

inline void VersionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&metadata_min_version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&metadata_cur_version_) -
    reinterpret_cast<char*>(&metadata_min_version_)) + sizeof(metadata_cur_version_));
}

VersionInfo::~VersionInfo() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.VersionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VersionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VersionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.VersionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&metadata_min_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&metadata_cur_version_) -
        reinterpret_cast<char*>(&metadata_min_version_)) + sizeof(metadata_cur_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 metadata_min_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_metadata_min_version(&has_bits);
          metadata_min_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 metadata_cur_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_metadata_cur_version(&has_bits);
          metadata_cur_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VersionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.VersionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 metadata_min_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_metadata_min_version(), target);
  }

  // optional int32 metadata_cur_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_metadata_cur_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.VersionInfo)
  return target;
}

size_t VersionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.VersionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 metadata_min_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_metadata_min_version());
    }

    // optional int32 metadata_cur_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_metadata_cur_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VersionInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VersionInfo*>(
      &from));
}

void VersionInfo::MergeFrom(const VersionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.VersionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      metadata_min_version_ = from.metadata_min_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      metadata_cur_version_ = from.metadata_cur_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VersionInfo::CopyFrom(const VersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.VersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionInfo::IsInitialized() const {
  return true;
}

void VersionInfo::InternalSwap(VersionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VersionInfo, metadata_cur_version_)
      + sizeof(VersionInfo::metadata_cur_version_)
      - PROTOBUF_FIELD_OFFSET(VersionInfo, metadata_min_version_)>(
          reinterpret_cast<char*>(&metadata_min_version_),
          reinterpret_cast<char*>(&other->metadata_min_version_));
}

std::string VersionInfo::GetTypeName() const {
  return "segmentation_platform.proto.VersionInfo";
}


// ===================================================================

class UMAFeature::_Internal {
 public:
  using HasBits = decltype(std::declval<UMAFeature>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bucket_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tensor_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_aggregation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

UMAFeature::UMAFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  enum_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.UMAFeature)
}
UMAFeature::UMAFeature(const UMAFeature& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      enum_ids_(from.enum_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&name_hash_, &from.name_hash_,
    static_cast<size_t>(reinterpret_cast<char*>(&tensor_length_) -
    reinterpret_cast<char*>(&name_hash_)) + sizeof(tensor_length_));
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.UMAFeature)
}

inline void UMAFeature::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&name_hash_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tensor_length_) -
    reinterpret_cast<char*>(&name_hash_)) + sizeof(tensor_length_));
}

UMAFeature::~UMAFeature() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.UMAFeature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UMAFeature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void UMAFeature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UMAFeature::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.UMAFeature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enum_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&name_hash_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tensor_length_) -
        reinterpret_cast<char*>(&name_hash_)) + sizeof(tensor_length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UMAFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .segmentation_platform.proto.SignalType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::SignalType_IsValid(val))) {
            _internal_set_type(static_cast<::segmentation_platform::proto::SignalType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 name_hash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_name_hash(&has_bits);
          name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bucket_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bucket_count(&has_bits);
          bucket_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tensor_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tensor_length(&has_bits);
          tensor_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.Aggregation aggregation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::Aggregation_IsValid(val))) {
            _internal_set_aggregation(static_cast<::segmentation_platform::proto::Aggregation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int32 enum_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_enum_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_enum_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UMAFeature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.UMAFeature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .segmentation_platform.proto.SignalType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional fixed64 name_hash = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_name_hash(), target);
  }

  // optional uint64 bucket_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_bucket_count(), target);
  }

  // optional uint64 tensor_length = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_tensor_length(), target);
  }

  // optional .segmentation_platform.proto.Aggregation aggregation = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_aggregation(), target);
  }

  // repeated int32 enum_ids = 7;
  for (int i = 0, n = this->_internal_enum_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_enum_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.UMAFeature)
  return target;
}

size_t UMAFeature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.UMAFeature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 enum_ids = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->enum_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_enum_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional fixed64 name_hash = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .segmentation_platform.proto.SignalType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .segmentation_platform.proto.Aggregation aggregation = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_aggregation());
    }

    // optional uint64 bucket_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bucket_count());
    }

    // optional uint64 tensor_length = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tensor_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UMAFeature::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UMAFeature*>(
      &from));
}

void UMAFeature::MergeFrom(const UMAFeature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.UMAFeature)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  enum_ids_.MergeFrom(from.enum_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      name_hash_ = from.name_hash_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      aggregation_ = from.aggregation_;
    }
    if (cached_has_bits & 0x00000010u) {
      bucket_count_ = from.bucket_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      tensor_length_ = from.tensor_length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UMAFeature::CopyFrom(const UMAFeature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.UMAFeature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UMAFeature::IsInitialized() const {
  return true;
}

void UMAFeature::InternalSwap(UMAFeature* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  enum_ids_.InternalSwap(&other->enum_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UMAFeature, tensor_length_)
      + sizeof(UMAFeature::tensor_length_)
      - PROTOBUF_FIELD_OFFSET(UMAFeature, name_hash_)>(
          reinterpret_cast<char*>(&name_hash_),
          reinterpret_cast<char*>(&other->name_hash_));
}

std::string UMAFeature::GetTypeName() const {
  return "segmentation_platform.proto.UMAFeature";
}


// ===================================================================

CustomInput_AdditionalArgsEntry_DoNotUse::CustomInput_AdditionalArgsEntry_DoNotUse() {}
CustomInput_AdditionalArgsEntry_DoNotUse::CustomInput_AdditionalArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CustomInput_AdditionalArgsEntry_DoNotUse::MergeFrom(const CustomInput_AdditionalArgsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class CustomInput::_Internal {
 public:
  using HasBits = decltype(std::declval<CustomInput>()._has_bits_);
  static void set_has_tensor_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fill_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CustomInput::CustomInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  default_value_(arena),
  additional_args_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.CustomInput)
}
CustomInput::CustomInput(const CustomInput& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      default_value_(from.default_value_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  additional_args_.MergeFrom(from.additional_args_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&tensor_length_, &from.tensor_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&fill_policy_) -
    reinterpret_cast<char*>(&tensor_length_)) + sizeof(fill_policy_));
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.CustomInput)
}

inline void CustomInput::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tensor_length_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fill_policy_) -
    reinterpret_cast<char*>(&tensor_length_)) + sizeof(fill_policy_));
}

CustomInput::~CustomInput() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.CustomInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CustomInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  additional_args_.Destruct();
  name_.Destroy();
}

void CustomInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CustomInput::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.CustomInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  default_value_.Clear();
  additional_args_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&tensor_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fill_policy_) -
        reinterpret_cast<char*>(&tensor_length_)) + sizeof(fill_policy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CustomInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tensor_length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tensor_length(&has_bits);
          tensor_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::CustomInput_FillPolicy_IsValid(val))) {
            _internal_set_fill_policy(static_cast<::segmentation_platform::proto::CustomInput_FillPolicy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated float default_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_default_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<29>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_default_value(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> additional_args = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&additional_args_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.CustomInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tensor_length = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tensor_length(), target);
  }

  // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_fill_policy(), target);
  }

  // repeated float default_value = 3;
  for (int i = 0, n = this->_internal_default_value_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_default_value(i), target);
  }

  // map<string, string> additional_args = 4;
  if (!this->_internal_additional_args().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CustomInput_AdditionalArgsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_additional_args();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.CustomInput)
  return target;
}

size_t CustomInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.CustomInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float default_value = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_default_value_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_default_value_size());
    total_size += data_size;
  }

  // map<string, string> additional_args = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_additional_args_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_additional_args().begin();
      it != this->_internal_additional_args().end(); ++it) {
    total_size += CustomInput_AdditionalArgsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 tensor_length = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tensor_length());
    }

    // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_fill_policy());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CustomInput::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CustomInput*>(
      &from));
}

void CustomInput::MergeFrom(const CustomInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.CustomInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  default_value_.MergeFrom(from.default_value_);
  additional_args_.MergeFrom(from.additional_args_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      tensor_length_ = from.tensor_length_;
    }
    if (cached_has_bits & 0x00000004u) {
      fill_policy_ = from.fill_policy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CustomInput::CopyFrom(const CustomInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.CustomInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomInput::IsInitialized() const {
  return true;
}

void CustomInput::InternalSwap(CustomInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  default_value_.InternalSwap(&other->default_value_);
  additional_args_.InternalSwap(&other->additional_args_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CustomInput, fill_policy_)
      + sizeof(CustomInput::fill_policy_)
      - PROTOBUF_FIELD_OFFSET(CustomInput, tensor_length_)>(
          reinterpret_cast<char*>(&tensor_length_),
          reinterpret_cast<char*>(&other->tensor_length_));
}

std::string CustomInput::GetTypeName() const {
  return "segmentation_platform.proto.CustomInput";
}


// ===================================================================

class SignalFilterConfig_UkmEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SignalFilterConfig_UkmEvent>()._has_bits_);
  static void set_has_event_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SignalFilterConfig_UkmEvent::SignalFilterConfig_UkmEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  metric_hash_filter_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
}
SignalFilterConfig_UkmEvent::SignalFilterConfig_UkmEvent(const SignalFilterConfig_UkmEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      metric_hash_filter_(from.metric_hash_filter_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  event_hash_ = from.event_hash_;
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
}

inline void SignalFilterConfig_UkmEvent::SharedCtor() {
event_hash_ = uint64_t{0u};
}

SignalFilterConfig_UkmEvent::~SignalFilterConfig_UkmEvent() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignalFilterConfig_UkmEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SignalFilterConfig_UkmEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignalFilterConfig_UkmEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  metric_hash_filter_.Clear();
  event_hash_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SignalFilterConfig_UkmEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 event_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_event_hash(&has_bits);
          event_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 metric_hash_filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_metric_hash_filter(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_metric_hash_filter(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignalFilterConfig_UkmEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 event_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_event_hash(), target);
  }

  // repeated uint64 metric_hash_filter = 2;
  for (int i = 0, n = this->_internal_metric_hash_filter_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_metric_hash_filter(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  return target;
}

size_t SignalFilterConfig_UkmEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 metric_hash_filter = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->metric_hash_filter_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_metric_hash_filter_size());
    total_size += data_size;
  }

  // optional uint64 event_hash = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_event_hash());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignalFilterConfig_UkmEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SignalFilterConfig_UkmEvent*>(
      &from));
}

void SignalFilterConfig_UkmEvent::MergeFrom(const SignalFilterConfig_UkmEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  metric_hash_filter_.MergeFrom(from.metric_hash_filter_);
  if (from._internal_has_event_hash()) {
    _internal_set_event_hash(from._internal_event_hash());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignalFilterConfig_UkmEvent::CopyFrom(const SignalFilterConfig_UkmEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalFilterConfig_UkmEvent::IsInitialized() const {
  return true;
}

void SignalFilterConfig_UkmEvent::InternalSwap(SignalFilterConfig_UkmEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  metric_hash_filter_.InternalSwap(&other->metric_hash_filter_);
  swap(event_hash_, other->event_hash_);
}

std::string SignalFilterConfig_UkmEvent::GetTypeName() const {
  return "segmentation_platform.proto.SignalFilterConfig.UkmEvent";
}


// ===================================================================

class SignalFilterConfig::_Internal {
 public:
};

SignalFilterConfig::SignalFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  ukm_events_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SignalFilterConfig)
}
SignalFilterConfig::SignalFilterConfig(const SignalFilterConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      ukm_events_(from.ukm_events_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SignalFilterConfig)
}

inline void SignalFilterConfig::SharedCtor() {
}

SignalFilterConfig::~SignalFilterConfig() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SignalFilterConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignalFilterConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SignalFilterConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignalFilterConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SignalFilterConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ukm_events_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SignalFilterConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ukm_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignalFilterConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SignalFilterConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ukm_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_ukm_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SignalFilterConfig)
  return target;
}

size_t SignalFilterConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SignalFilterConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
  total_size += 1UL * this->_internal_ukm_events_size();
  for (const auto& msg : this->ukm_events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SignalFilterConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SignalFilterConfig*>(
      &from));
}

void SignalFilterConfig::MergeFrom(const SignalFilterConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SignalFilterConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ukm_events_.MergeFrom(from.ukm_events_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignalFilterConfig::CopyFrom(const SignalFilterConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SignalFilterConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalFilterConfig::IsInitialized() const {
  return true;
}

void SignalFilterConfig::InternalSwap(SignalFilterConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ukm_events_.InternalSwap(&other->ukm_events_);
}

std::string SignalFilterConfig::GetTypeName() const {
  return "segmentation_platform.proto.SignalFilterConfig";
}


// ===================================================================

class SqlFeature_BindValue::_Internal {
 public:
  using HasBits = decltype(std::declval<SqlFeature_BindValue>()._has_bits_);
  static void set_has_param_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::segmentation_platform::proto::CustomInput& value(const SqlFeature_BindValue* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::segmentation_platform::proto::CustomInput&
SqlFeature_BindValue::_Internal::value(const SqlFeature_BindValue* msg) {
  return *msg->value_;
}
SqlFeature_BindValue::SqlFeature_BindValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  bind_field_index_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SqlFeature.BindValue)
}
SqlFeature_BindValue::SqlFeature_BindValue(const SqlFeature_BindValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      bind_field_index_(from.bind_field_index_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value()) {
    value_ = new ::segmentation_platform::proto::CustomInput(*from.value_);
  } else {
    value_ = nullptr;
  }
  param_type_ = from.param_type_;
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SqlFeature.BindValue)
}

inline void SqlFeature_BindValue::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&value_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&param_type_) -
    reinterpret_cast<char*>(&value_)) + sizeof(param_type_));
}

SqlFeature_BindValue::~SqlFeature_BindValue() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SqlFeature.BindValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SqlFeature_BindValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_;
}

void SqlFeature_BindValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SqlFeature_BindValue::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SqlFeature.BindValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bind_field_index_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_ != nullptr);
    value_->Clear();
  }
  param_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SqlFeature_BindValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 bind_field_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_bind_field_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_bind_field_index(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::SqlFeature_BindValue_ParamType_IsValid(val))) {
            _internal_set_param_type(static_cast<::segmentation_platform::proto::SqlFeature_BindValue_ParamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.CustomInput value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SqlFeature_BindValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SqlFeature.BindValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 bind_field_index = 1;
  for (int i = 0, n = this->_internal_bind_field_index_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_bind_field_index(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_param_type(), target);
  }

  // optional .segmentation_platform.proto.CustomInput value = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SqlFeature.BindValue)
  return target;
}

size_t SqlFeature_BindValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SqlFeature.BindValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 bind_field_index = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->bind_field_index_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_bind_field_index_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .segmentation_platform.proto.CustomInput value = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_);
    }

    // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_param_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SqlFeature_BindValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SqlFeature_BindValue*>(
      &from));
}

void SqlFeature_BindValue::MergeFrom(const SqlFeature_BindValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SqlFeature.BindValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  bind_field_index_.MergeFrom(from.bind_field_index_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_value()->::segmentation_platform::proto::CustomInput::MergeFrom(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      param_type_ = from.param_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SqlFeature_BindValue::CopyFrom(const SqlFeature_BindValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SqlFeature.BindValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SqlFeature_BindValue::IsInitialized() const {
  return true;
}

void SqlFeature_BindValue::InternalSwap(SqlFeature_BindValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  bind_field_index_.InternalSwap(&other->bind_field_index_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SqlFeature_BindValue, param_type_)
      + sizeof(SqlFeature_BindValue::param_type_)
      - PROTOBUF_FIELD_OFFSET(SqlFeature_BindValue, value_)>(
          reinterpret_cast<char*>(&value_),
          reinterpret_cast<char*>(&other->value_));
}

std::string SqlFeature_BindValue::GetTypeName() const {
  return "segmentation_platform.proto.SqlFeature.BindValue";
}


// ===================================================================

class SqlFeature::_Internal {
 public:
  using HasBits = decltype(std::declval<SqlFeature>()._has_bits_);
  static void set_has_sql(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::segmentation_platform::proto::SignalFilterConfig& signal_filter(const SqlFeature* msg);
  static void set_has_signal_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::segmentation_platform::proto::SignalFilterConfig&
SqlFeature::_Internal::signal_filter(const SqlFeature* msg) {
  return *msg->signal_filter_;
}
SqlFeature::SqlFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  bind_values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SqlFeature)
}
SqlFeature::SqlFeature(const SqlFeature& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      bind_values_(from.bind_values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sql()) {
    sql_.Set(from._internal_sql(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_signal_filter()) {
    signal_filter_ = new ::segmentation_platform::proto::SignalFilterConfig(*from.signal_filter_);
  } else {
    signal_filter_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SqlFeature)
}

inline void SqlFeature::SharedCtor() {
sql_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sql_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signal_filter_ = nullptr;
}

SqlFeature::~SqlFeature() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SqlFeature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SqlFeature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sql_.Destroy();
  name_.Destroy();
  if (this != internal_default_instance()) delete signal_filter_;
}

void SqlFeature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SqlFeature::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SqlFeature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bind_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sql_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(signal_filter_ != nullptr);
      signal_filter_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SqlFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sql = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sql();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_signal_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bind_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SqlFeature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SqlFeature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string sql = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sql(), target);
  }

  // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::signal_filter(this),
        _Internal::signal_filter(this).GetCachedSize(), target, stream);
  }

  // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bind_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_bind_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SqlFeature)
  return target;
}

size_t SqlFeature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SqlFeature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
  total_size += 1UL * this->_internal_bind_values_size();
  for (const auto& msg : this->bind_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sql = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sql());
    }

    // optional string name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *signal_filter_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SqlFeature::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SqlFeature*>(
      &from));
}

void SqlFeature::MergeFrom(const SqlFeature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SqlFeature)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  bind_values_.MergeFrom(from.bind_values_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sql(from._internal_sql());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_signal_filter()->::segmentation_platform::proto::SignalFilterConfig::MergeFrom(from._internal_signal_filter());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SqlFeature::CopyFrom(const SqlFeature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SqlFeature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SqlFeature::IsInitialized() const {
  return true;
}

void SqlFeature::InternalSwap(SqlFeature* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  bind_values_.InternalSwap(&other->bind_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sql_, lhs_arena,
      &other->sql_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(signal_filter_, other->signal_filter_);
}

std::string SqlFeature::GetTypeName() const {
  return "segmentation_platform.proto.SqlFeature";
}


// ===================================================================

class InputFeature::_Internal {
 public:
  static const ::segmentation_platform::proto::UMAFeature& uma_feature(const InputFeature* msg);
  static const ::segmentation_platform::proto::CustomInput& custom_input(const InputFeature* msg);
  static const ::segmentation_platform::proto::SqlFeature& sql_feature(const InputFeature* msg);
};

const ::segmentation_platform::proto::UMAFeature&
InputFeature::_Internal::uma_feature(const InputFeature* msg) {
  return *msg->Feature_.uma_feature_;
}
const ::segmentation_platform::proto::CustomInput&
InputFeature::_Internal::custom_input(const InputFeature* msg) {
  return *msg->Feature_.custom_input_;
}
const ::segmentation_platform::proto::SqlFeature&
InputFeature::_Internal::sql_feature(const InputFeature* msg) {
  return *msg->Feature_.sql_feature_;
}
void InputFeature::set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Feature();
  if (uma_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_feature);
    if (message_arena != submessage_arena) {
      uma_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uma_feature, submessage_arena);
    }
    set_has_uma_feature();
    Feature_.uma_feature_ = uma_feature;
  }
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.InputFeature.uma_feature)
}
void InputFeature::set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Feature();
  if (custom_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_input);
    if (message_arena != submessage_arena) {
      custom_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom_input, submessage_arena);
    }
    set_has_custom_input();
    Feature_.custom_input_ = custom_input;
  }
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.InputFeature.custom_input)
}
void InputFeature::set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Feature();
  if (sql_feature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sql_feature);
    if (message_arena != submessage_arena) {
      sql_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sql_feature, submessage_arena);
    }
    set_has_sql_feature();
    Feature_.sql_feature_ = sql_feature;
  }
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.InputFeature.sql_feature)
}
InputFeature::InputFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.InputFeature)
}
InputFeature::InputFeature(const InputFeature& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_Feature();
  switch (from.Feature_case()) {
    case kUmaFeature: {
      _internal_mutable_uma_feature()->::segmentation_platform::proto::UMAFeature::MergeFrom(from._internal_uma_feature());
      break;
    }
    case kCustomInput: {
      _internal_mutable_custom_input()->::segmentation_platform::proto::CustomInput::MergeFrom(from._internal_custom_input());
      break;
    }
    case kSqlFeature: {
      _internal_mutable_sql_feature()->::segmentation_platform::proto::SqlFeature::MergeFrom(from._internal_sql_feature());
      break;
    }
    case FEATURE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.InputFeature)
}

inline void InputFeature::SharedCtor() {
clear_has_Feature();
}

InputFeature::~InputFeature() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.InputFeature)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InputFeature::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Feature()) {
    clear_Feature();
  }
}

void InputFeature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InputFeature::clear_Feature() {
// @@protoc_insertion_point(one_of_clear_start:segmentation_platform.proto.InputFeature)
  switch (Feature_case()) {
    case kUmaFeature: {
      if (GetArenaForAllocation() == nullptr) {
        delete Feature_.uma_feature_;
      }
      break;
    }
    case kCustomInput: {
      if (GetArenaForAllocation() == nullptr) {
        delete Feature_.custom_input_;
      }
      break;
    }
    case kSqlFeature: {
      if (GetArenaForAllocation() == nullptr) {
        delete Feature_.sql_feature_;
      }
      break;
    }
    case FEATURE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = FEATURE_NOT_SET;
}


void InputFeature::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.InputFeature)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_Feature();
  _internal_metadata_.Clear<std::string>();
}

const char* InputFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .segmentation_platform.proto.UMAFeature uma_feature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_uma_feature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .segmentation_platform.proto.CustomInput custom_input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_input(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .segmentation_platform.proto.SqlFeature sql_feature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sql_feature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InputFeature::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.InputFeature)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (Feature_case()) {
    case kUmaFeature: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::uma_feature(this),
          _Internal::uma_feature(this).GetCachedSize(), target, stream);
      break;
    }
    case kCustomInput: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::custom_input(this),
          _Internal::custom_input(this).GetCachedSize(), target, stream);
      break;
    }
    case kSqlFeature: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::sql_feature(this),
          _Internal::sql_feature(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.InputFeature)
  return target;
}

size_t InputFeature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.InputFeature)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Feature_case()) {
    // .segmentation_platform.proto.UMAFeature uma_feature = 1;
    case kUmaFeature: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Feature_.uma_feature_);
      break;
    }
    // .segmentation_platform.proto.CustomInput custom_input = 2;
    case kCustomInput: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Feature_.custom_input_);
      break;
    }
    // .segmentation_platform.proto.SqlFeature sql_feature = 3;
    case kSqlFeature: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *Feature_.sql_feature_);
      break;
    }
    case FEATURE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InputFeature::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InputFeature*>(
      &from));
}

void InputFeature::MergeFrom(const InputFeature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.InputFeature)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.Feature_case()) {
    case kUmaFeature: {
      _internal_mutable_uma_feature()->::segmentation_platform::proto::UMAFeature::MergeFrom(from._internal_uma_feature());
      break;
    }
    case kCustomInput: {
      _internal_mutable_custom_input()->::segmentation_platform::proto::CustomInput::MergeFrom(from._internal_custom_input());
      break;
    }
    case kSqlFeature: {
      _internal_mutable_sql_feature()->::segmentation_platform::proto::SqlFeature::MergeFrom(from._internal_sql_feature());
      break;
    }
    case FEATURE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InputFeature::CopyFrom(const InputFeature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.InputFeature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputFeature::IsInitialized() const {
  return true;
}

void InputFeature::InternalSwap(InputFeature* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(Feature_, other->Feature_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string InputFeature::GetTypeName() const {
  return "segmentation_platform.proto.InputFeature";
}


// ===================================================================

class TrainingOutputs::_Internal {
 public:
};

TrainingOutputs::TrainingOutputs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  outputs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.TrainingOutputs)
}
TrainingOutputs::TrainingOutputs(const TrainingOutputs& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outputs_(from.outputs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.TrainingOutputs)
}

inline void TrainingOutputs::SharedCtor() {
}

TrainingOutputs::~TrainingOutputs() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.TrainingOutputs)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrainingOutputs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TrainingOutputs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrainingOutputs::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.TrainingOutputs)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  outputs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TrainingOutputs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_outputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrainingOutputs::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.TrainingOutputs)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outputs_size()); i < n; i++) {
    const auto& repfield = this->_internal_outputs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.TrainingOutputs)
  return target;
}

size_t TrainingOutputs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.TrainingOutputs)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
  total_size += 1UL * this->_internal_outputs_size();
  for (const auto& msg : this->outputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrainingOutputs::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TrainingOutputs*>(
      &from));
}

void TrainingOutputs::MergeFrom(const TrainingOutputs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.TrainingOutputs)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  outputs_.MergeFrom(from.outputs_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrainingOutputs::CopyFrom(const TrainingOutputs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.TrainingOutputs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainingOutputs::IsInitialized() const {
  return true;
}

void TrainingOutputs::InternalSwap(TrainingOutputs* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  outputs_.InternalSwap(&other->outputs_);
}

std::string TrainingOutputs::GetTypeName() const {
  return "segmentation_platform.proto.TrainingOutputs";
}


// ===================================================================

class TrainingOutput::_Internal {
 public:
  static const ::segmentation_platform::proto::UMAOutput& uma_output(const TrainingOutput* msg);
};

const ::segmentation_platform::proto::UMAOutput&
TrainingOutput::_Internal::uma_output(const TrainingOutput* msg) {
  return *msg->output_.uma_output_;
}
void TrainingOutput::set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_output();
  if (uma_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_output);
    if (message_arena != submessage_arena) {
      uma_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uma_output, submessage_arena);
    }
    set_has_uma_output();
    output_.uma_output_ = uma_output;
  }
  // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.TrainingOutput.uma_output)
}
TrainingOutput::TrainingOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.TrainingOutput)
}
TrainingOutput::TrainingOutput(const TrainingOutput& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_output();
  switch (from.output_case()) {
    case kUmaOutput: {
      _internal_mutable_uma_output()->::segmentation_platform::proto::UMAOutput::MergeFrom(from._internal_uma_output());
      break;
    }
    case OUTPUT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.TrainingOutput)
}

inline void TrainingOutput::SharedCtor() {
clear_has_output();
}

TrainingOutput::~TrainingOutput() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.TrainingOutput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrainingOutput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_output()) {
    clear_output();
  }
}

void TrainingOutput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrainingOutput::clear_output() {
// @@protoc_insertion_point(one_of_clear_start:segmentation_platform.proto.TrainingOutput)
  switch (output_case()) {
    case kUmaOutput: {
      if (GetArenaForAllocation() == nullptr) {
        delete output_.uma_output_;
      }
      break;
    }
    case OUTPUT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OUTPUT_NOT_SET;
}


void TrainingOutput::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.TrainingOutput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_output();
  _internal_metadata_.Clear<std::string>();
}

const char* TrainingOutput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .segmentation_platform.proto.UMAOutput uma_output = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_uma_output(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrainingOutput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.TrainingOutput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .segmentation_platform.proto.UMAOutput uma_output = 1;
  if (_internal_has_uma_output()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::uma_output(this),
        _Internal::uma_output(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.TrainingOutput)
  return target;
}

size_t TrainingOutput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.TrainingOutput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (output_case()) {
    // .segmentation_platform.proto.UMAOutput uma_output = 1;
    case kUmaOutput: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *output_.uma_output_);
      break;
    }
    case OUTPUT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrainingOutput::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TrainingOutput*>(
      &from));
}

void TrainingOutput::MergeFrom(const TrainingOutput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.TrainingOutput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.output_case()) {
    case kUmaOutput: {
      _internal_mutable_uma_output()->::segmentation_platform::proto::UMAOutput::MergeFrom(from._internal_uma_output());
      break;
    }
    case OUTPUT_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrainingOutput::CopyFrom(const TrainingOutput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.TrainingOutput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainingOutput::IsInitialized() const {
  return true;
}

void TrainingOutput::InternalSwap(TrainingOutput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(output_, other->output_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string TrainingOutput::GetTypeName() const {
  return "segmentation_platform.proto.TrainingOutput";
}


// ===================================================================

class UMAOutput::_Internal {
 public:
  using HasBits = decltype(std::declval<UMAOutput>()._has_bits_);
  static const ::segmentation_platform::proto::UMAFeature& uma_feature(const UMAOutput* msg);
  static void set_has_uma_feature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::segmentation_platform::proto::UMAFeature&
UMAOutput::_Internal::uma_feature(const UMAOutput* msg) {
  return *msg->uma_feature_;
}
UMAOutput::UMAOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.UMAOutput)
}
UMAOutput::UMAOutput(const UMAOutput& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_uma_feature()) {
    uma_feature_ = new ::segmentation_platform::proto::UMAFeature(*from.uma_feature_);
  } else {
    uma_feature_ = nullptr;
  }
  duration_ = from.duration_;
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.UMAOutput)
}

inline void UMAOutput::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&uma_feature_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&duration_) -
    reinterpret_cast<char*>(&uma_feature_)) + sizeof(duration_));
}

UMAOutput::~UMAOutput() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.UMAOutput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UMAOutput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete uma_feature_;
}

void UMAOutput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UMAOutput::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.UMAOutput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(uma_feature_ != nullptr);
    uma_feature_->Clear();
  }
  duration_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UMAOutput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_uma_feature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_duration(&has_bits);
          duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UMAOutput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.UMAOutput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::uma_feature(this),
        _Internal::uma_feature(this).GetCachedSize(), target, stream);
  }

  // optional uint64 duration = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.UMAOutput)
  return target;
}

size_t UMAOutput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.UMAOutput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *uma_feature_);
    }

    // optional uint64 duration = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_duration());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UMAOutput::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UMAOutput*>(
      &from));
}

void UMAOutput::MergeFrom(const UMAOutput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.UMAOutput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_uma_feature()->::segmentation_platform::proto::UMAFeature::MergeFrom(from._internal_uma_feature());
    }
    if (cached_has_bits & 0x00000002u) {
      duration_ = from.duration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UMAOutput::CopyFrom(const UMAOutput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.UMAOutput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UMAOutput::IsInitialized() const {
  return true;
}

void UMAOutput::InternalSwap(UMAOutput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UMAOutput, duration_)
      + sizeof(UMAOutput::duration_)
      - PROTOBUF_FIELD_OFFSET(UMAOutput, uma_feature_)>(
          reinterpret_cast<char*>(&uma_feature_),
          reinterpret_cast<char*>(&other->uma_feature_));
}

std::string UMAOutput::GetTypeName() const {
  return "segmentation_platform.proto.UMAOutput";
}


// ===================================================================

class SegmentationModelMetadata_DiscreteMapping_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<SegmentationModelMetadata_DiscreteMapping_Entry>()._has_bits_);
  static void set_has_min_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SegmentationModelMetadata_DiscreteMapping_Entry::SegmentationModelMetadata_DiscreteMapping_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
}
SegmentationModelMetadata_DiscreteMapping_Entry::SegmentationModelMetadata_DiscreteMapping_Entry(const SegmentationModelMetadata_DiscreteMapping_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&rank_, &from.rank_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_result_) -
    reinterpret_cast<char*>(&rank_)) + sizeof(min_result_));
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
}

inline void SegmentationModelMetadata_DiscreteMapping_Entry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rank_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&min_result_) -
    reinterpret_cast<char*>(&rank_)) + sizeof(min_result_));
}

SegmentationModelMetadata_DiscreteMapping_Entry::~SegmentationModelMetadata_DiscreteMapping_Entry() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SegmentationModelMetadata_DiscreteMapping_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SegmentationModelMetadata_DiscreteMapping_Entry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SegmentationModelMetadata_DiscreteMapping_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&rank_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_result_) -
        reinterpret_cast<char*>(&rank_)) + sizeof(min_result_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SegmentationModelMetadata_DiscreteMapping_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float min_result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_min_result(&has_bits);
          min_result_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int64 rank = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rank(&has_bits);
          rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SegmentationModelMetadata_DiscreteMapping_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float min_result = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_min_result(), target);
  }

  // optional int64 rank = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_rank(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  return target;
}

size_t SegmentationModelMetadata_DiscreteMapping_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 rank = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rank());
    }

    // optional float min_result = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SegmentationModelMetadata_DiscreteMapping_Entry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SegmentationModelMetadata_DiscreteMapping_Entry*>(
      &from));
}

void SegmentationModelMetadata_DiscreteMapping_Entry::MergeFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      rank_ = from.rank_;
    }
    if (cached_has_bits & 0x00000002u) {
      min_result_ = from.min_result_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SegmentationModelMetadata_DiscreteMapping_Entry::CopyFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SegmentationModelMetadata_DiscreteMapping_Entry::IsInitialized() const {
  return true;
}

void SegmentationModelMetadata_DiscreteMapping_Entry::InternalSwap(SegmentationModelMetadata_DiscreteMapping_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata_DiscreteMapping_Entry, min_result_)
      + sizeof(SegmentationModelMetadata_DiscreteMapping_Entry::min_result_)
      - PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata_DiscreteMapping_Entry, rank_)>(
          reinterpret_cast<char*>(&rank_),
          reinterpret_cast<char*>(&other->rank_));
}

std::string SegmentationModelMetadata_DiscreteMapping_Entry::GetTypeName() const {
  return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry";
}


// ===================================================================

class SegmentationModelMetadata_DiscreteMapping::_Internal {
 public:
};

SegmentationModelMetadata_DiscreteMapping::SegmentationModelMetadata_DiscreteMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
}
SegmentationModelMetadata_DiscreteMapping::SegmentationModelMetadata_DiscreteMapping(const SegmentationModelMetadata_DiscreteMapping& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
}

inline void SegmentationModelMetadata_DiscreteMapping::SharedCtor() {
}

SegmentationModelMetadata_DiscreteMapping::~SegmentationModelMetadata_DiscreteMapping() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SegmentationModelMetadata_DiscreteMapping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SegmentationModelMetadata_DiscreteMapping::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SegmentationModelMetadata_DiscreteMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SegmentationModelMetadata_DiscreteMapping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SegmentationModelMetadata_DiscreteMapping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  return target;
}

size_t SegmentationModelMetadata_DiscreteMapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SegmentationModelMetadata_DiscreteMapping::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SegmentationModelMetadata_DiscreteMapping*>(
      &from));
}

void SegmentationModelMetadata_DiscreteMapping::MergeFrom(const SegmentationModelMetadata_DiscreteMapping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SegmentationModelMetadata_DiscreteMapping::CopyFrom(const SegmentationModelMetadata_DiscreteMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SegmentationModelMetadata_DiscreteMapping::IsInitialized() const {
  return true;
}

void SegmentationModelMetadata_DiscreteMapping::InternalSwap(SegmentationModelMetadata_DiscreteMapping* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

std::string SegmentationModelMetadata_DiscreteMapping::GetTypeName() const {
  return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping";
}


// ===================================================================

SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse() {}
SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::MergeFrom(const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class SegmentationModelMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<SegmentationModelMetadata>()._has_bits_);
  static const ::segmentation_platform::proto::VersionInfo& version_info(const SegmentationModelMetadata* msg);
  static void set_has_version_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::segmentation_platform::proto::TrainingOutputs& training_outputs(const SegmentationModelMetadata* msg);
  static void set_has_training_outputs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bucket_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signal_storage_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_min_signal_collection_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_result_time_to_live(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_default_discrete_mapping(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::segmentation_platform::proto::VersionInfo&
SegmentationModelMetadata::_Internal::version_info(const SegmentationModelMetadata* msg) {
  return *msg->version_info_;
}
const ::segmentation_platform::proto::TrainingOutputs&
SegmentationModelMetadata::_Internal::training_outputs(const SegmentationModelMetadata* msg) {
  return *msg->training_outputs_;
}
SegmentationModelMetadata::SegmentationModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  features_(arena),
  discrete_mappings_(arena),
  input_features_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SegmentationModelMetadata)
}
SegmentationModelMetadata::SegmentationModelMetadata(const SegmentationModelMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      features_(from.features_),
      input_features_(from.input_features_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  discrete_mappings_.MergeFrom(from.discrete_mappings_);
  default_discrete_mapping_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    default_discrete_mapping_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_default_discrete_mapping()) {
    default_discrete_mapping_.Set(from._internal_default_discrete_mapping(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_version_info()) {
    version_info_ = new ::segmentation_platform::proto::VersionInfo(*from.version_info_);
  } else {
    version_info_ = nullptr;
  }
  if (from._internal_has_training_outputs()) {
    training_outputs_ = new ::segmentation_platform::proto::TrainingOutputs(*from.training_outputs_);
  } else {
    training_outputs_ = nullptr;
  }
  ::memcpy(&bucket_duration_, &from.bucket_duration_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_unit_) -
    reinterpret_cast<char*>(&bucket_duration_)) + sizeof(time_unit_));
  // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SegmentationModelMetadata)
}

inline void SegmentationModelMetadata::SharedCtor() {
default_discrete_mapping_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  default_discrete_mapping_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_unit_) -
    reinterpret_cast<char*>(&version_info_)) + sizeof(time_unit_));
}

SegmentationModelMetadata::~SegmentationModelMetadata() {
  // @@protoc_insertion_point(destructor:segmentation_platform.proto.SegmentationModelMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SegmentationModelMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  discrete_mappings_.Destruct();
  default_discrete_mapping_.Destroy();
  if (this != internal_default_instance()) delete version_info_;
  if (this != internal_default_instance()) delete training_outputs_;
}

void SegmentationModelMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SegmentationModelMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SegmentationModelMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  features_.Clear();
  discrete_mappings_.Clear();
  input_features_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      default_discrete_mapping_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(version_info_ != nullptr);
      version_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(training_outputs_ != nullptr);
      training_outputs_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&bucket_duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_unit_) -
        reinterpret_cast<char*>(&bucket_duration_)) + sizeof(time_unit_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SegmentationModelMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .segmentation_platform.proto.UMAFeature features = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_features(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::TimeUnit_IsValid(val))) {
            _internal_set_time_unit(static_cast<::segmentation_platform::proto::TimeUnit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bucket_duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bucket_duration(&has_bits);
          bucket_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 signal_storage_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_signal_storage_length(&has_bits);
          signal_storage_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 min_signal_collection_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_min_signal_collection_length(&has_bits);
          min_signal_collection_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 result_time_to_live = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_result_time_to_live(&has_bits);
          result_time_to_live_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&discrete_mappings_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string default_discrete_mapping = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_default_discrete_mapping();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.VersionInfo version_info = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_version_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .segmentation_platform.proto.InputFeature input_features = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input_features(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_training_outputs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SegmentationModelMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SegmentationModelMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.UMAFeature features = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_features_size()); i < n; i++) {
    const auto& repfield = this->_internal_features(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_time_unit(), target);
  }

  // optional uint64 bucket_duration = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_bucket_duration(), target);
  }

  // optional int64 signal_storage_length = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_signal_storage_length(), target);
  }

  // optional int64 min_signal_collection_length = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_min_signal_collection_length(), target);
  }

  // optional int64 result_time_to_live = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_result_time_to_live(), target);
  }

  // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
  if (!this->_internal_discrete_mappings().empty()) {
    using MapType = ::_pb::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>;
    using WireHelper = SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_discrete_mappings();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // optional string default_discrete_mapping = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_default_discrete_mapping(), target);
  }

  // optional .segmentation_platform.proto.VersionInfo version_info = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::version_info(this),
        _Internal::version_info(this).GetCachedSize(), target, stream);
  }

  // repeated .segmentation_platform.proto.InputFeature input_features = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_features_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_features(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::training_outputs(this),
        _Internal::training_outputs(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SegmentationModelMetadata)
  return target;
}

size_t SegmentationModelMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SegmentationModelMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .segmentation_platform.proto.UMAFeature features = 1;
  total_size += 1UL * this->_internal_features_size();
  for (const auto& msg : this->features_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_discrete_mappings_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >::const_iterator
      it = this->_internal_discrete_mappings().begin();
      it != this->_internal_discrete_mappings().end(); ++it) {
    total_size += SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .segmentation_platform.proto.InputFeature input_features = 10;
  total_size += 1UL * this->_internal_input_features_size();
  for (const auto& msg : this->input_features_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string default_discrete_mapping = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_default_discrete_mapping());
    }

    // optional .segmentation_platform.proto.VersionInfo version_info = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *version_info_);
    }

    // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *training_outputs_);
    }

    // optional uint64 bucket_duration = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bucket_duration());
    }

    // optional int64 signal_storage_length = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_signal_storage_length());
    }

    // optional int64 min_signal_collection_length = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_signal_collection_length());
    }

    // optional int64 result_time_to_live = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_result_time_to_live());
    }

    // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_time_unit());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SegmentationModelMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SegmentationModelMetadata*>(
      &from));
}

void SegmentationModelMetadata::MergeFrom(const SegmentationModelMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SegmentationModelMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  features_.MergeFrom(from.features_);
  discrete_mappings_.MergeFrom(from.discrete_mappings_);
  input_features_.MergeFrom(from.input_features_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_default_discrete_mapping(from._internal_default_discrete_mapping());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_version_info()->::segmentation_platform::proto::VersionInfo::MergeFrom(from._internal_version_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_training_outputs()->::segmentation_platform::proto::TrainingOutputs::MergeFrom(from._internal_training_outputs());
    }
    if (cached_has_bits & 0x00000008u) {
      bucket_duration_ = from.bucket_duration_;
    }
    if (cached_has_bits & 0x00000010u) {
      signal_storage_length_ = from.signal_storage_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      min_signal_collection_length_ = from.min_signal_collection_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      result_time_to_live_ = from.result_time_to_live_;
    }
    if (cached_has_bits & 0x00000080u) {
      time_unit_ = from.time_unit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SegmentationModelMetadata::CopyFrom(const SegmentationModelMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SegmentationModelMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SegmentationModelMetadata::IsInitialized() const {
  return true;
}

void SegmentationModelMetadata::InternalSwap(SegmentationModelMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  features_.InternalSwap(&other->features_);
  discrete_mappings_.InternalSwap(&other->discrete_mappings_);
  input_features_.InternalSwap(&other->input_features_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &default_discrete_mapping_, lhs_arena,
      &other->default_discrete_mapping_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata, time_unit_)
      + sizeof(SegmentationModelMetadata::time_unit_)
      - PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata, version_info_)>(
          reinterpret_cast<char*>(&version_info_),
          reinterpret_cast<char*>(&other->version_info_));
}

std::string SegmentationModelMetadata::GetTypeName() const {
  return "segmentation_platform.proto.SegmentationModelMetadata";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace segmentation_platform
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::VersionInfo*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::VersionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::VersionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::UMAFeature*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::UMAFeature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::UMAFeature >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::CustomInput*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::CustomInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::CustomInput >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SignalFilterConfig_UkmEvent*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SignalFilterConfig_UkmEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SignalFilterConfig*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SignalFilterConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SignalFilterConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SqlFeature_BindValue*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SqlFeature_BindValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SqlFeature_BindValue >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SqlFeature*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SqlFeature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SqlFeature >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::InputFeature*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::InputFeature >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::InputFeature >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::TrainingOutputs*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::TrainingOutputs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::TrainingOutputs >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::TrainingOutput*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::TrainingOutput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::TrainingOutput >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::UMAOutput*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::UMAOutput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::UMAOutput >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata*
Arena::CreateMaybeMessage< ::segmentation_platform::proto::SegmentationModelMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::segmentation_platform::proto::SegmentationModelMetadata >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
