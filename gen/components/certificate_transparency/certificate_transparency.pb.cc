// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certificate_transparency.proto

#include "certificate_transparency.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace chrome_browser_certificate_transparency {
PROTOBUF_CONSTEXPR FinalTreeHead::FinalTreeHead(
    ::_pbi::ConstantInitialized)
  : sha256_root_hash_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tree_size_(uint64_t{0u}){}
struct FinalTreeHeadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FinalTreeHeadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FinalTreeHeadDefaultTypeInternal() {}
  union {
    FinalTreeHead _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FinalTreeHeadDefaultTypeInternal _FinalTreeHead_default_instance_;
PROTOBUF_CONSTEXPR CTLog_Interval::CTLog_Interval(
    ::_pbi::ConstantInitialized)
  : start_(nullptr)
  , end_(nullptr){}
struct CTLog_IntervalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CTLog_IntervalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CTLog_IntervalDefaultTypeInternal() {}
  union {
    CTLog_Interval _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLog_IntervalDefaultTypeInternal _CTLog_Interval_default_instance_;
PROTOBUF_CONSTEXPR CTLog_State::CTLog_State(
    ::_pbi::ConstantInitialized)
  : state_start_(nullptr)
  , current_state_(0)
{}
struct CTLog_StateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CTLog_StateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CTLog_StateDefaultTypeInternal() {}
  union {
    CTLog_State _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLog_StateDefaultTypeInternal _CTLog_State_default_instance_;
PROTOBUF_CONSTEXPR CTLog_OperatorChange::CTLog_OperatorChange(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , operator_start_(nullptr){}
struct CTLog_OperatorChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CTLog_OperatorChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CTLog_OperatorChangeDefaultTypeInternal() {}
  union {
    CTLog_OperatorChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLog_OperatorChangeDefaultTypeInternal _CTLog_OperatorChange_default_instance_;
PROTOBUF_CONSTEXPR CTLog::CTLog(
    ::_pbi::ConstantInitialized)
  : state_()
  , operator_history_()
  , description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , log_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , temporal_interval_(nullptr)
  , read_only_info_(nullptr)
  , mmd_secs_(uint64_t{0u})
  , purpose_(0)
{}
struct CTLogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CTLogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CTLogDefaultTypeInternal() {}
  union {
    CTLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLogDefaultTypeInternal _CTLog_default_instance_;
PROTOBUF_CONSTEXPR LogOperator::LogOperator(
    ::_pbi::ConstantInitialized)
  : email_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct LogOperatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogOperatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogOperatorDefaultTypeInternal() {}
  union {
    LogOperator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogOperatorDefaultTypeInternal _LogOperator_default_instance_;
PROTOBUF_CONSTEXPR CTLogList::CTLogList(
    ::_pbi::ConstantInitialized)
  : operators_()
  , logs_()
  , timestamp_(nullptr)
  , list_version_major_(uint64_t{0u})
  , list_version_minor_(uint64_t{0u})
  , compatibility_version_(uint64_t{0u}){}
struct CTLogListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CTLogListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CTLogListDefaultTypeInternal() {}
  union {
    CTLogList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLogListDefaultTypeInternal _CTLogList_default_instance_;
}  // namespace chrome_browser_certificate_transparency
namespace chrome_browser_certificate_transparency {
bool CTLog_Purpose_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CTLog_Purpose_strings[3] = {};

static const char CTLog_Purpose_names[] =
  "PROD"
  "TEST"
  "UNSET_PURPOSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CTLog_Purpose_entries[] = {
  { {CTLog_Purpose_names + 0, 4}, 1 },
  { {CTLog_Purpose_names + 4, 4}, 2 },
  { {CTLog_Purpose_names + 8, 13}, 0 },
};

static const int CTLog_Purpose_entries_by_number[] = {
  2, // 0 -> UNSET_PURPOSE
  0, // 1 -> PROD
  1, // 2 -> TEST
};

const std::string& CTLog_Purpose_Name(
    CTLog_Purpose value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CTLog_Purpose_entries,
          CTLog_Purpose_entries_by_number,
          3, CTLog_Purpose_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CTLog_Purpose_entries,
      CTLog_Purpose_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CTLog_Purpose_strings[idx].get();
}
bool CTLog_Purpose_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_Purpose* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CTLog_Purpose_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CTLog_Purpose>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CTLog_Purpose CTLog::UNSET_PURPOSE;
constexpr CTLog_Purpose CTLog::PROD;
constexpr CTLog_Purpose CTLog::TEST;
constexpr CTLog_Purpose CTLog::Purpose_MIN;
constexpr CTLog_Purpose CTLog::Purpose_MAX;
constexpr int CTLog::Purpose_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CTLog_CurrentState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CTLog_CurrentState_strings[7] = {};

static const char CTLog_CurrentState_names[] =
  "PENDING"
  "QUALIFIED"
  "READ_ONLY"
  "REJECTED"
  "RETIRED"
  "UNSET_STATE"
  "USABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CTLog_CurrentState_entries[] = {
  { {CTLog_CurrentState_names + 0, 7}, 1 },
  { {CTLog_CurrentState_names + 7, 9}, 2 },
  { {CTLog_CurrentState_names + 16, 9}, 4 },
  { {CTLog_CurrentState_names + 25, 8}, 6 },
  { {CTLog_CurrentState_names + 33, 7}, 5 },
  { {CTLog_CurrentState_names + 40, 11}, 0 },
  { {CTLog_CurrentState_names + 51, 6}, 3 },
};

static const int CTLog_CurrentState_entries_by_number[] = {
  5, // 0 -> UNSET_STATE
  0, // 1 -> PENDING
  1, // 2 -> QUALIFIED
  6, // 3 -> USABLE
  2, // 4 -> READ_ONLY
  4, // 5 -> RETIRED
  3, // 6 -> REJECTED
};

const std::string& CTLog_CurrentState_Name(
    CTLog_CurrentState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CTLog_CurrentState_entries,
          CTLog_CurrentState_entries_by_number,
          7, CTLog_CurrentState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CTLog_CurrentState_entries,
      CTLog_CurrentState_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CTLog_CurrentState_strings[idx].get();
}
bool CTLog_CurrentState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_CurrentState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CTLog_CurrentState_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<CTLog_CurrentState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CTLog_CurrentState CTLog::UNSET_STATE;
constexpr CTLog_CurrentState CTLog::PENDING;
constexpr CTLog_CurrentState CTLog::QUALIFIED;
constexpr CTLog_CurrentState CTLog::USABLE;
constexpr CTLog_CurrentState CTLog::READ_ONLY;
constexpr CTLog_CurrentState CTLog::RETIRED;
constexpr CTLog_CurrentState CTLog::REJECTED;
constexpr CTLog_CurrentState CTLog::CurrentState_MIN;
constexpr CTLog_CurrentState CTLog::CurrentState_MAX;
constexpr int CTLog::CurrentState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class FinalTreeHead::_Internal {
 public:
};

FinalTreeHead::FinalTreeHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.FinalTreeHead)
}
FinalTreeHead::FinalTreeHead(const FinalTreeHead& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sha256_root_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sha256_root_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sha256_root_hash().empty()) {
    sha256_root_hash_.Set(from._internal_sha256_root_hash(), 
      GetArenaForAllocation());
  }
  tree_size_ = from.tree_size_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.FinalTreeHead)
}

inline void FinalTreeHead::SharedCtor() {
sha256_root_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sha256_root_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tree_size_ = uint64_t{0u};
}

FinalTreeHead::~FinalTreeHead() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.FinalTreeHead)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FinalTreeHead::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sha256_root_hash_.Destroy();
}

void FinalTreeHead::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FinalTreeHead::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.FinalTreeHead)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sha256_root_hash_.ClearToEmpty();
  tree_size_ = uint64_t{0u};
  _internal_metadata_.Clear<std::string>();
}

const char* FinalTreeHead::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 tree_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          tree_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sha256_root_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sha256_root_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FinalTreeHead::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.FinalTreeHead)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 tree_size = 1;
  if (this->_internal_tree_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tree_size(), target);
  }

  // string sha256_root_hash = 2;
  if (!this->_internal_sha256_root_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sha256_root_hash().data(), static_cast<int>(this->_internal_sha256_root_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sha256_root_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.FinalTreeHead)
  return target;
}

size_t FinalTreeHead::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.FinalTreeHead)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sha256_root_hash = 2;
  if (!this->_internal_sha256_root_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sha256_root_hash());
  }

  // uint64 tree_size = 1;
  if (this->_internal_tree_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tree_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FinalTreeHead::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FinalTreeHead*>(
      &from));
}

void FinalTreeHead::MergeFrom(const FinalTreeHead& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.FinalTreeHead)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sha256_root_hash().empty()) {
    _internal_set_sha256_root_hash(from._internal_sha256_root_hash());
  }
  if (from._internal_tree_size() != 0) {
    _internal_set_tree_size(from._internal_tree_size());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FinalTreeHead::CopyFrom(const FinalTreeHead& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.FinalTreeHead)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinalTreeHead::IsInitialized() const {
  return true;
}

void FinalTreeHead::InternalSwap(FinalTreeHead* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sha256_root_hash_, lhs_arena,
      &other->sha256_root_hash_, rhs_arena
  );
  swap(tree_size_, other->tree_size_);
}

std::string FinalTreeHead::GetTypeName() const {
  return "chrome_browser_certificate_transparency.FinalTreeHead";
}


// ===================================================================

class CTLog_Interval::_Internal {
 public:
  static const ::chrome_browser_certificate_transparency::CTTimestamp& start(const CTLog_Interval* msg);
  static const ::chrome_browser_certificate_transparency::CTTimestamp& end(const CTLog_Interval* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp&
CTLog_Interval::_Internal::start(const CTLog_Interval* msg) {
  return *msg->start_;
}
const ::chrome_browser_certificate_transparency::CTTimestamp&
CTLog_Interval::_Internal::end(const CTLog_Interval* msg) {
  return *msg->end_;
}
void CTLog_Interval::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
void CTLog_Interval::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
CTLog_Interval::CTLog_Interval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog.Interval)
}
CTLog_Interval::CTLog_Interval(const CTLog_Interval& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_start()) {
    start_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from._internal_has_end()) {
    end_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from.end_);
  } else {
    end_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog.Interval)
}

inline void CTLog_Interval::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_) -
    reinterpret_cast<char*>(&start_)) + sizeof(end_));
}

CTLog_Interval::~CTLog_Interval() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog.Interval)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CTLog_Interval::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void CTLog_Interval::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTLog_Interval::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog.Interval)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* CTLog_Interval::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTLog_Interval::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog.Interval)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
  if (this->_internal_has_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
  if (this->_internal_has_end()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog.Interval)
  return target;
}

size_t CTLog_Interval::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog.Interval)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
  if (this->_internal_has_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *start_);
  }

  // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
  if (this->_internal_has_end()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *end_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CTLog_Interval::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CTLog_Interval*>(
      &from));
}

void CTLog_Interval::MergeFrom(const CTLog_Interval& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog.Interval)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_start()) {
    _internal_mutable_start()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_start());
  }
  if (from._internal_has_end()) {
    _internal_mutable_end()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_end());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog_Interval::CopyFrom(const CTLog_Interval& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog.Interval)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTLog_Interval::IsInitialized() const {
  return true;
}

void CTLog_Interval::InternalSwap(CTLog_Interval* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTLog_Interval, end_)
      + sizeof(CTLog_Interval::end_)
      - PROTOBUF_FIELD_OFFSET(CTLog_Interval, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

std::string CTLog_Interval::GetTypeName() const {
  return "chrome_browser_certificate_transparency.CTLog.Interval";
}


// ===================================================================

class CTLog_State::_Internal {
 public:
  static const ::chrome_browser_certificate_transparency::CTTimestamp& state_start(const CTLog_State* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp&
CTLog_State::_Internal::state_start(const CTLog_State* msg) {
  return *msg->state_start_;
}
void CTLog_State::clear_state_start() {
  if (GetArenaForAllocation() == nullptr && state_start_ != nullptr) {
    delete state_start_;
  }
  state_start_ = nullptr;
}
CTLog_State::CTLog_State(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog.State)
}
CTLog_State::CTLog_State(const CTLog_State& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_state_start()) {
    state_start_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from.state_start_);
  } else {
    state_start_ = nullptr;
  }
  current_state_ = from.current_state_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog.State)
}

inline void CTLog_State::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&state_start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_state_) -
    reinterpret_cast<char*>(&state_start_)) + sizeof(current_state_));
}

CTLog_State::~CTLog_State() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog.State)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CTLog_State::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete state_start_;
}

void CTLog_State::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTLog_State::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog.State)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && state_start_ != nullptr) {
    delete state_start_;
  }
  state_start_ = nullptr;
  current_state_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* CTLog_State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_state(static_cast<::chrome_browser_certificate_transparency::CTLog_CurrentState>(val));
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_state_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTLog_State::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog.State)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
  if (this->_internal_current_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_current_state(), target);
  }

  // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
  if (this->_internal_has_state_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::state_start(this),
        _Internal::state_start(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog.State)
  return target;
}

size_t CTLog_State::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog.State)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
  if (this->_internal_has_state_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *state_start_);
  }

  // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
  if (this->_internal_current_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_current_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CTLog_State::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CTLog_State*>(
      &from));
}

void CTLog_State::MergeFrom(const CTLog_State& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog.State)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state_start()) {
    _internal_mutable_state_start()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_state_start());
  }
  if (from._internal_current_state() != 0) {
    _internal_set_current_state(from._internal_current_state());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog_State::CopyFrom(const CTLog_State& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog.State)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTLog_State::IsInitialized() const {
  return true;
}

void CTLog_State::InternalSwap(CTLog_State* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTLog_State, current_state_)
      + sizeof(CTLog_State::current_state_)
      - PROTOBUF_FIELD_OFFSET(CTLog_State, state_start_)>(
          reinterpret_cast<char*>(&state_start_),
          reinterpret_cast<char*>(&other->state_start_));
}

std::string CTLog_State::GetTypeName() const {
  return "chrome_browser_certificate_transparency.CTLog.State";
}


// ===================================================================

class CTLog_OperatorChange::_Internal {
 public:
  static const ::chrome_browser_certificate_transparency::CTTimestamp& operator_start(const CTLog_OperatorChange* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp&
CTLog_OperatorChange::_Internal::operator_start(const CTLog_OperatorChange* msg) {
  return *msg->operator_start_;
}
void CTLog_OperatorChange::clear_operator_start() {
  if (GetArenaForAllocation() == nullptr && operator_start_ != nullptr) {
    delete operator_start_;
  }
  operator_start_ = nullptr;
}
CTLog_OperatorChange::CTLog_OperatorChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog.OperatorChange)
}
CTLog_OperatorChange::CTLog_OperatorChange(const CTLog_OperatorChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_operator_start()) {
    operator_start_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from.operator_start_);
  } else {
    operator_start_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog.OperatorChange)
}

inline void CTLog_OperatorChange::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
operator_start_ = nullptr;
}

CTLog_OperatorChange::~CTLog_OperatorChange() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CTLog_OperatorChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  if (this != internal_default_instance()) delete operator_start_;
}

void CTLog_OperatorChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTLog_OperatorChange::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && operator_start_ != nullptr) {
    delete operator_start_;
  }
  operator_start_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* CTLog_OperatorChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_operator_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTLog_OperatorChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.CTLog.OperatorChange.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
  if (this->_internal_has_operator_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::operator_start(this),
        _Internal::operator_start(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  return target;
}

size_t CTLog_OperatorChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
  if (this->_internal_has_operator_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *operator_start_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CTLog_OperatorChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CTLog_OperatorChange*>(
      &from));
}

void CTLog_OperatorChange::MergeFrom(const CTLog_OperatorChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_operator_start()) {
    _internal_mutable_operator_start()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_operator_start());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog_OperatorChange::CopyFrom(const CTLog_OperatorChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTLog_OperatorChange::IsInitialized() const {
  return true;
}

void CTLog_OperatorChange::InternalSwap(CTLog_OperatorChange* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(operator_start_, other->operator_start_);
}

std::string CTLog_OperatorChange::GetTypeName() const {
  return "chrome_browser_certificate_transparency.CTLog.OperatorChange";
}


// ===================================================================

class CTLog::_Internal {
 public:
  static const ::chrome_browser_certificate_transparency::CTLog_Interval& temporal_interval(const CTLog* msg);
  static const ::chrome_browser_certificate_transparency::FinalTreeHead& read_only_info(const CTLog* msg);
};

const ::chrome_browser_certificate_transparency::CTLog_Interval&
CTLog::_Internal::temporal_interval(const CTLog* msg) {
  return *msg->temporal_interval_;
}
const ::chrome_browser_certificate_transparency::FinalTreeHead&
CTLog::_Internal::read_only_info(const CTLog* msg) {
  return *msg->read_only_info_;
}
CTLog::CTLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  state_(arena),
  operator_history_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog)
}
CTLog::CTLog(const CTLog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      state_(from.state_),
      operator_history_(from.operator_history_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  log_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    log_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_log_id().empty()) {
    log_id_.Set(from._internal_log_id(), 
      GetArenaForAllocation());
  }
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_temporal_interval()) {
    temporal_interval_ = new ::chrome_browser_certificate_transparency::CTLog_Interval(*from.temporal_interval_);
  } else {
    temporal_interval_ = nullptr;
  }
  if (from._internal_has_read_only_info()) {
    read_only_info_ = new ::chrome_browser_certificate_transparency::FinalTreeHead(*from.read_only_info_);
  } else {
    read_only_info_ = nullptr;
  }
  ::memcpy(&mmd_secs_, &from.mmd_secs_,
    static_cast<size_t>(reinterpret_cast<char*>(&purpose_) -
    reinterpret_cast<char*>(&mmd_secs_)) + sizeof(purpose_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog)
}

inline void CTLog::SharedCtor() {
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
log_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  log_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&temporal_interval_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&purpose_) -
    reinterpret_cast<char*>(&temporal_interval_)) + sizeof(purpose_));
}

CTLog::~CTLog() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CTLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.Destroy();
  key_.Destroy();
  log_id_.Destroy();
  url_.Destroy();
  if (this != internal_default_instance()) delete temporal_interval_;
  if (this != internal_default_instance()) delete read_only_info_;
}

void CTLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTLog::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_.Clear();
  operator_history_.Clear();
  description_.ClearToEmpty();
  key_.ClearToEmpty();
  log_id_.ClearToEmpty();
  url_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && temporal_interval_ != nullptr) {
    delete temporal_interval_;
  }
  temporal_interval_ = nullptr;
  if (GetArenaForAllocation() == nullptr && read_only_info_ != nullptr) {
    delete read_only_info_;
  }
  read_only_info_ = nullptr;
  ::memset(&mmd_secs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&purpose_) -
      reinterpret_cast<char*>(&mmd_secs_)) + sizeof(purpose_));
  _internal_metadata_.Clear<std::string>();
}

const char* CTLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string log_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_log_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // uint64 mmd_secs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          mmd_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_temporal_interval(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_purpose(static_cast<::chrome_browser_certificate_transparency::CTLog_Purpose>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_state(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operator_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_read_only_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTLog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.CTLog.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // string key = 2;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.CTLog.key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  // string log_id = 3;
  if (!this->_internal_log_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_log_id().data(), static_cast<int>(this->_internal_log_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.CTLog.log_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_log_id(), target);
  }

  // uint64 mmd_secs = 4;
  if (this->_internal_mmd_secs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_mmd_secs(), target);
  }

  // string url = 5;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.CTLog.url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_url(), target);
  }

  // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
  if (this->_internal_has_temporal_interval()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::temporal_interval(this),
        _Internal::temporal_interval(this).GetCachedSize(), target, stream);
  }

  // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
  if (this->_internal_purpose() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_purpose(), target);
  }

  // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_state_size()); i < n; i++) {
    const auto& repfield = this->_internal_state(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_operator_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_operator_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
  if (this->_internal_has_read_only_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::read_only_info(this),
        _Internal::read_only_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog)
  return target;
}

size_t CTLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
  total_size += 1UL * this->_internal_state_size();
  for (const auto& msg : this->state_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
  total_size += 1UL * this->_internal_operator_history_size();
  for (const auto& msg : this->operator_history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string log_id = 3;
  if (!this->_internal_log_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_log_id());
  }

  // string url = 5;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
  if (this->_internal_has_temporal_interval()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *temporal_interval_);
  }

  // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
  if (this->_internal_has_read_only_info()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *read_only_info_);
  }

  // uint64 mmd_secs = 4;
  if (this->_internal_mmd_secs() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_mmd_secs());
  }

  // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
  if (this->_internal_purpose() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_purpose());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CTLog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CTLog*>(
      &from));
}

void CTLog::MergeFrom(const CTLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  state_.MergeFrom(from.state_);
  operator_history_.MergeFrom(from.operator_history_);
  if (!from._internal_description().empty()) {
    _internal_set_description(from._internal_description());
  }
  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (!from._internal_log_id().empty()) {
    _internal_set_log_id(from._internal_log_id());
  }
  if (!from._internal_url().empty()) {
    _internal_set_url(from._internal_url());
  }
  if (from._internal_has_temporal_interval()) {
    _internal_mutable_temporal_interval()->::chrome_browser_certificate_transparency::CTLog_Interval::MergeFrom(from._internal_temporal_interval());
  }
  if (from._internal_has_read_only_info()) {
    _internal_mutable_read_only_info()->::chrome_browser_certificate_transparency::FinalTreeHead::MergeFrom(from._internal_read_only_info());
  }
  if (from._internal_mmd_secs() != 0) {
    _internal_set_mmd_secs(from._internal_mmd_secs());
  }
  if (from._internal_purpose() != 0) {
    _internal_set_purpose(from._internal_purpose());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog::CopyFrom(const CTLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTLog::IsInitialized() const {
  return true;
}

void CTLog::InternalSwap(CTLog* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  state_.InternalSwap(&other->state_);
  operator_history_.InternalSwap(&other->operator_history_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &log_id_, lhs_arena,
      &other->log_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTLog, purpose_)
      + sizeof(CTLog::purpose_)
      - PROTOBUF_FIELD_OFFSET(CTLog, temporal_interval_)>(
          reinterpret_cast<char*>(&temporal_interval_),
          reinterpret_cast<char*>(&other->temporal_interval_));
}

std::string CTLog::GetTypeName() const {
  return "chrome_browser_certificate_transparency.CTLog";
}


// ===================================================================

class LogOperator::_Internal {
 public:
};

LogOperator::LogOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  email_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.LogOperator)
}
LogOperator::LogOperator(const LogOperator& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      email_(from.email_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.LogOperator)
}

inline void LogOperator::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LogOperator::~LogOperator() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.LogOperator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogOperator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void LogOperator::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LogOperator::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.LogOperator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  email_.Clear();
  name_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* LogOperator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_email();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogOperator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.LogOperator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.LogOperator.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated string email = 2;
  for (int i = 0, n = this->_internal_email_size(); i < n; i++) {
    const auto& s = this->_internal_email(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "chrome_browser_certificate_transparency.LogOperator.email");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.LogOperator)
  return target;
}

size_t LogOperator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.LogOperator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string email = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(email_.size());
  for (int i = 0, n = email_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      email_.Get(i));
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogOperator::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LogOperator*>(
      &from));
}

void LogOperator::MergeFrom(const LogOperator& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.LogOperator)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  email_.MergeFrom(from.email_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogOperator::CopyFrom(const LogOperator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.LogOperator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogOperator::IsInitialized() const {
  return true;
}

void LogOperator::InternalSwap(LogOperator* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  email_.InternalSwap(&other->email_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string LogOperator::GetTypeName() const {
  return "chrome_browser_certificate_transparency.LogOperator";
}


// ===================================================================

class CTLogList::_Internal {
 public:
  static const ::chrome_browser_certificate_transparency::CTTimestamp& timestamp(const CTLogList* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp&
CTLogList::_Internal::timestamp(const CTLogList* msg) {
  return *msg->timestamp_;
}
void CTLogList::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
}
CTLogList::CTLogList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  operators_(arena),
  logs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLogList)
}
CTLogList::CTLogList(const CTLogList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      operators_(from.operators_),
      logs_(from.logs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_timestamp()) {
    timestamp_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from.timestamp_);
  } else {
    timestamp_ = nullptr;
  }
  ::memcpy(&list_version_major_, &from.list_version_major_,
    static_cast<size_t>(reinterpret_cast<char*>(&compatibility_version_) -
    reinterpret_cast<char*>(&list_version_major_)) + sizeof(compatibility_version_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLogList)
}

inline void CTLogList::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compatibility_version_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(compatibility_version_));
}

CTLogList::~CTLogList() {
  // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLogList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CTLogList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete timestamp_;
}

void CTLogList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTLogList::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLogList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  operators_.Clear();
  logs_.Clear();
  if (GetArenaForAllocation() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
  ::memset(&list_version_major_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&compatibility_version_) -
      reinterpret_cast<char*>(&list_version_major_)) + sizeof(compatibility_version_));
  _internal_metadata_.Clear<std::string>();
}

const char* CTLogList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 list_version_major = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          list_version_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 list_version_minor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          list_version_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 compatibility_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          compatibility_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operators(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTLogList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLogList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 list_version_major = 1;
  if (this->_internal_list_version_major() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_list_version_major(), target);
  }

  // uint64 list_version_minor = 2;
  if (this->_internal_list_version_minor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_list_version_minor(), target);
  }

  // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // uint64 compatibility_version = 4;
  if (this->_internal_compatibility_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_compatibility_version(), target);
  }

  // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_operators_size()); i < n; i++) {
    const auto& repfield = this->_internal_operators(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_logs_size()); i < n; i++) {
    const auto& repfield = this->_internal_logs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLogList)
  return target;
}

size_t CTLogList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLogList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
  total_size += 1UL * this->_internal_operators_size();
  for (const auto& msg : this->operators_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
  total_size += 1UL * this->_internal_logs_size();
  for (const auto& msg : this->logs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *timestamp_);
  }

  // uint64 list_version_major = 1;
  if (this->_internal_list_version_major() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_list_version_major());
  }

  // uint64 list_version_minor = 2;
  if (this->_internal_list_version_minor() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_list_version_minor());
  }

  // uint64 compatibility_version = 4;
  if (this->_internal_compatibility_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_compatibility_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CTLogList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CTLogList*>(
      &from));
}

void CTLogList::MergeFrom(const CTLogList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLogList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  operators_.MergeFrom(from.operators_);
  logs_.MergeFrom(from.logs_);
  if (from._internal_has_timestamp()) {
    _internal_mutable_timestamp()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_timestamp());
  }
  if (from._internal_list_version_major() != 0) {
    _internal_set_list_version_major(from._internal_list_version_major());
  }
  if (from._internal_list_version_minor() != 0) {
    _internal_set_list_version_minor(from._internal_list_version_minor());
  }
  if (from._internal_compatibility_version() != 0) {
    _internal_set_compatibility_version(from._internal_compatibility_version());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLogList::CopyFrom(const CTLogList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLogList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTLogList::IsInitialized() const {
  return true;
}

void CTLogList::InternalSwap(CTLogList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  operators_.InternalSwap(&other->operators_);
  logs_.InternalSwap(&other->logs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTLogList, compatibility_version_)
      + sizeof(CTLogList::compatibility_version_)
      - PROTOBUF_FIELD_OFFSET(CTLogList, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

std::string CTLogList::GetTypeName() const {
  return "chrome_browser_certificate_transparency.CTLogList";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace chrome_browser_certificate_transparency
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::FinalTreeHead*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::FinalTreeHead >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::FinalTreeHead >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog_Interval*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::CTLog_Interval >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::CTLog_Interval >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog_State*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::CTLog_State >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::CTLog_State >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog_OperatorChange*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::CTLog_OperatorChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::CTLog_OperatorChange >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::CTLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::CTLog >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::LogOperator*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::LogOperator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::LogOperator >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLogList*
Arena::CreateMaybeMessage< ::chrome_browser_certificate_transparency::CTLogList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_certificate_transparency::CTLogList >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
