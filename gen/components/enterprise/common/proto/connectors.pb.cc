// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/enterprise/common/proto/connectors.proto

#include "components/enterprise/common/proto/connectors.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace enterprise_connectors {
PROTOBUF_CONSTEXPR ContentMetaData::ContentMetaData(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filename_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , digest_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , email_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , content_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , csd_(nullptr){}
struct ContentMetaDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentMetaDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentMetaDataDefaultTypeInternal() {}
  union {
    ContentMetaData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentMetaDataDefaultTypeInternal _ContentMetaData_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata_Browser::ClientMetadata_Browser(
    ::_pbi::ConstantInitialized)
  : browser_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_agent_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , chrome_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , machine_user_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientMetadata_BrowserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMetadata_BrowserDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMetadata_BrowserDefaultTypeInternal() {}
  union {
    ClientMetadata_Browser _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadata_BrowserDefaultTypeInternal _ClientMetadata_Browser_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata_Device::ClientMetadata_Device(
    ::_pbi::ConstantInitialized)
  : dm_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , os_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , os_platform_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientMetadata_DeviceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMetadata_DeviceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMetadata_DeviceDefaultTypeInternal() {}
  union {
    ClientMetadata_Device _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadata_DeviceDefaultTypeInternal _ClientMetadata_Device_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata_Profile::ClientMetadata_Profile(
    ::_pbi::ConstantInitialized)
  : dm_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gaia_email_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , profile_path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , profile_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientMetadata_ProfileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMetadata_ProfileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMetadata_ProfileDefaultTypeInternal() {}
  union {
    ClientMetadata_Profile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadata_ProfileDefaultTypeInternal _ClientMetadata_Profile_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata::ClientMetadata(
    ::_pbi::ConstantInitialized)
  : browser_(nullptr)
  , device_(nullptr)
  , profile_(nullptr){}
struct ClientMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientMetadataDefaultTypeInternal() {}
  union {
    ClientMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadataDefaultTypeInternal _ClientMetadata_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisRequest::ContentAnalysisRequest(
    ::_pbi::ConstantInitialized)
  : tags_()
  , device_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , fcm_notification_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , request_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , request_data_(nullptr)
  , client_metadata_(nullptr)
  , expires_at_(int64_t{0})
  , analysis_connector_(0)

  , _oneof_case_{}{}
struct ContentAnalysisRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentAnalysisRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentAnalysisRequestDefaultTypeInternal() {}
  union {
    ContentAnalysisRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisRequestDefaultTypeInternal _ContentAnalysisRequest_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_CustomMessage::ContentAnalysisResponse_Result_CustomMessage(
    ::_pbi::ConstantInitialized)
  : learn_more_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal() {}
  union {
    ContentAnalysisResponse_Result_CustomMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal _ContentAnalysisResponse_Result_CustomMessage_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule::ContentAnalysisResponse_Result_TriggeredRule(
    ::_pbi::ConstantInitialized)
  : rule_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , rule_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , custom_message_(nullptr)
  , action_(0)
{}
struct ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal() {}
  union {
    ContentAnalysisResponse_Result_TriggeredRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal _ContentAnalysisResponse_Result_TriggeredRule_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result::ContentAnalysisResponse_Result(
    ::_pbi::ConstantInitialized)
  : triggered_rules_()
  , tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , malware_family_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , malware_category_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , evidence_locker_filepath_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , custom_message_(nullptr)
  , status_(0)
{}
struct ContentAnalysisResponse_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentAnalysisResponse_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentAnalysisResponse_ResultDefaultTypeInternal() {}
  union {
    ContentAnalysisResponse_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponse_ResultDefaultTypeInternal _ContentAnalysisResponse_Result_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse::ContentAnalysisResponse(
    ::_pbi::ConstantInitialized)
  : results_()
  , request_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ContentAnalysisResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentAnalysisResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentAnalysisResponseDefaultTypeInternal() {}
  union {
    ContentAnalysisResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponseDefaultTypeInternal _ContentAnalysisResponse_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisAcknowledgement::ContentAnalysisAcknowledgement(
    ::_pbi::ConstantInitialized)
  : request_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , final_action_(0)

  , status_(1)
{}
struct ContentAnalysisAcknowledgementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContentAnalysisAcknowledgementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContentAnalysisAcknowledgementDefaultTypeInternal() {}
  union {
    ContentAnalysisAcknowledgement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisAcknowledgementDefaultTypeInternal _ContentAnalysisAcknowledgement_default_instance_;
}  // namespace enterprise_connectors
namespace enterprise_connectors {
bool ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisResponse_Result_TriggeredRule_Action_strings[4] = {};

static const char ContentAnalysisResponse_Result_TriggeredRule_Action_names[] =
  "ACTION_UNSPECIFIED"
  "BLOCK"
  "REPORT_ONLY"
  "WARN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisResponse_Result_TriggeredRule_Action_entries[] = {
  { {ContentAnalysisResponse_Result_TriggeredRule_Action_names + 0, 18}, 0 },
  { {ContentAnalysisResponse_Result_TriggeredRule_Action_names + 18, 5}, 3 },
  { {ContentAnalysisResponse_Result_TriggeredRule_Action_names + 23, 11}, 1 },
  { {ContentAnalysisResponse_Result_TriggeredRule_Action_names + 34, 4}, 2 },
};

static const int ContentAnalysisResponse_Result_TriggeredRule_Action_entries_by_number[] = {
  0, // 0 -> ACTION_UNSPECIFIED
  2, // 1 -> REPORT_ONLY
  3, // 2 -> WARN
  1, // 3 -> BLOCK
};

const std::string& ContentAnalysisResponse_Result_TriggeredRule_Action_Name(
    ContentAnalysisResponse_Result_TriggeredRule_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContentAnalysisResponse_Result_TriggeredRule_Action_entries,
          ContentAnalysisResponse_Result_TriggeredRule_Action_entries_by_number,
          4, ContentAnalysisResponse_Result_TriggeredRule_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContentAnalysisResponse_Result_TriggeredRule_Action_entries,
      ContentAnalysisResponse_Result_TriggeredRule_Action_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContentAnalysisResponse_Result_TriggeredRule_Action_strings[idx].get();
}
bool ContentAnalysisResponse_Result_TriggeredRule_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_TriggeredRule_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContentAnalysisResponse_Result_TriggeredRule_Action_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ContentAnalysisResponse_Result_TriggeredRule_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::ACTION_UNSPECIFIED;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::REPORT_ONLY;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::WARN;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::BLOCK;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::Action_MIN;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::Action_MAX;
constexpr int ContentAnalysisResponse_Result_TriggeredRule::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisResponse_Result_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisResponse_Result_Status_strings[3] = {};

static const char ContentAnalysisResponse_Result_Status_names[] =
  "FAILURE"
  "STATUS_UNKNOWN"
  "SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisResponse_Result_Status_entries[] = {
  { {ContentAnalysisResponse_Result_Status_names + 0, 7}, 2 },
  { {ContentAnalysisResponse_Result_Status_names + 7, 14}, 0 },
  { {ContentAnalysisResponse_Result_Status_names + 21, 7}, 1 },
};

static const int ContentAnalysisResponse_Result_Status_entries_by_number[] = {
  1, // 0 -> STATUS_UNKNOWN
  2, // 1 -> SUCCESS
  0, // 2 -> FAILURE
};

const std::string& ContentAnalysisResponse_Result_Status_Name(
    ContentAnalysisResponse_Result_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContentAnalysisResponse_Result_Status_entries,
          ContentAnalysisResponse_Result_Status_entries_by_number,
          3, ContentAnalysisResponse_Result_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContentAnalysisResponse_Result_Status_entries,
      ContentAnalysisResponse_Result_Status_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContentAnalysisResponse_Result_Status_strings[idx].get();
}
bool ContentAnalysisResponse_Result_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContentAnalysisResponse_Result_Status_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ContentAnalysisResponse_Result_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::STATUS_UNKNOWN;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::SUCCESS;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::FAILURE;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::Status_MIN;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::Status_MAX;
constexpr int ContentAnalysisResponse_Result::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisAcknowledgement_Status_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisAcknowledgement_Status_strings[3] = {};

static const char ContentAnalysisAcknowledgement_Status_names[] =
  "INVALID_RESPONSE"
  "SUCCESS"
  "TOO_LATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisAcknowledgement_Status_entries[] = {
  { {ContentAnalysisAcknowledgement_Status_names + 0, 16}, 2 },
  { {ContentAnalysisAcknowledgement_Status_names + 16, 7}, 1 },
  { {ContentAnalysisAcknowledgement_Status_names + 23, 8}, 3 },
};

static const int ContentAnalysisAcknowledgement_Status_entries_by_number[] = {
  1, // 1 -> SUCCESS
  0, // 2 -> INVALID_RESPONSE
  2, // 3 -> TOO_LATE
};

const std::string& ContentAnalysisAcknowledgement_Status_Name(
    ContentAnalysisAcknowledgement_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContentAnalysisAcknowledgement_Status_entries,
          ContentAnalysisAcknowledgement_Status_entries_by_number,
          3, ContentAnalysisAcknowledgement_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContentAnalysisAcknowledgement_Status_entries,
      ContentAnalysisAcknowledgement_Status_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContentAnalysisAcknowledgement_Status_strings[idx].get();
}
bool ContentAnalysisAcknowledgement_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContentAnalysisAcknowledgement_Status_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ContentAnalysisAcknowledgement_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::SUCCESS;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::INVALID_RESPONSE;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::TOO_LATE;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::Status_MIN;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::Status_MAX;
constexpr int ContentAnalysisAcknowledgement::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisAcknowledgement_FinalAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisAcknowledgement_FinalAction_strings[5] = {};

static const char ContentAnalysisAcknowledgement_FinalAction_names[] =
  "ACTION_UNSPECIFIED"
  "ALLOW"
  "BLOCK"
  "REPORT_ONLY"
  "WARN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisAcknowledgement_FinalAction_entries[] = {
  { {ContentAnalysisAcknowledgement_FinalAction_names + 0, 18}, 0 },
  { {ContentAnalysisAcknowledgement_FinalAction_names + 18, 5}, 1 },
  { {ContentAnalysisAcknowledgement_FinalAction_names + 23, 5}, 4 },
  { {ContentAnalysisAcknowledgement_FinalAction_names + 28, 11}, 2 },
  { {ContentAnalysisAcknowledgement_FinalAction_names + 39, 4}, 3 },
};

static const int ContentAnalysisAcknowledgement_FinalAction_entries_by_number[] = {
  0, // 0 -> ACTION_UNSPECIFIED
  1, // 1 -> ALLOW
  3, // 2 -> REPORT_ONLY
  4, // 3 -> WARN
  2, // 4 -> BLOCK
};

const std::string& ContentAnalysisAcknowledgement_FinalAction_Name(
    ContentAnalysisAcknowledgement_FinalAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContentAnalysisAcknowledgement_FinalAction_entries,
          ContentAnalysisAcknowledgement_FinalAction_entries_by_number,
          5, ContentAnalysisAcknowledgement_FinalAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContentAnalysisAcknowledgement_FinalAction_entries,
      ContentAnalysisAcknowledgement_FinalAction_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContentAnalysisAcknowledgement_FinalAction_strings[idx].get();
}
bool ContentAnalysisAcknowledgement_FinalAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_FinalAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContentAnalysisAcknowledgement_FinalAction_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ContentAnalysisAcknowledgement_FinalAction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::ACTION_UNSPECIFIED;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::ALLOW;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::REPORT_ONLY;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::WARN;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::BLOCK;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::FinalAction_MIN;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::FinalAction_MAX;
constexpr int ContentAnalysisAcknowledgement::FinalAction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AnalysisConnector_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AnalysisConnector_strings[6] = {};

static const char AnalysisConnector_names[] =
  "ANALYSIS_CONNECTOR_UNSPECIFIED"
  "BULK_DATA_ENTRY"
  "FILE_ATTACHED"
  "FILE_DOWNLOADED"
  "FILE_TRANSFER"
  "PRINT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AnalysisConnector_entries[] = {
  { {AnalysisConnector_names + 0, 30}, 0 },
  { {AnalysisConnector_names + 30, 15}, 3 },
  { {AnalysisConnector_names + 45, 13}, 2 },
  { {AnalysisConnector_names + 58, 15}, 1 },
  { {AnalysisConnector_names + 73, 13}, 5 },
  { {AnalysisConnector_names + 86, 5}, 4 },
};

static const int AnalysisConnector_entries_by_number[] = {
  0, // 0 -> ANALYSIS_CONNECTOR_UNSPECIFIED
  3, // 1 -> FILE_DOWNLOADED
  2, // 2 -> FILE_ATTACHED
  1, // 3 -> BULK_DATA_ENTRY
  5, // 4 -> PRINT
  4, // 5 -> FILE_TRANSFER
};

const std::string& AnalysisConnector_Name(
    AnalysisConnector value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AnalysisConnector_entries,
          AnalysisConnector_entries_by_number,
          6, AnalysisConnector_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AnalysisConnector_entries,
      AnalysisConnector_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AnalysisConnector_strings[idx].get();
}
bool AnalysisConnector_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnalysisConnector* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AnalysisConnector_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<AnalysisConnector>(int_value);
  }
  return success;
}

// ===================================================================

class ContentMetaData::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentMetaData>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_digest(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ClientDownloadRequest& csd(const ContentMetaData* msg);
  static void set_has_csd(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_email(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_content_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::safe_browsing::ClientDownloadRequest&
ContentMetaData::_Internal::csd(const ContentMetaData* msg) {
  return *msg->csd_;
}
void ContentMetaData::clear_csd() {
  if (csd_ != nullptr) csd_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
ContentMetaData::ContentMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentMetaData)
}
ContentMetaData::ContentMetaData(const ContentMetaData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    filename_.Set(from._internal_filename(), 
      GetArenaForAllocation());
  }
  digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    digest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_digest()) {
    digest_.Set(from._internal_digest(), 
      GetArenaForAllocation());
  }
  email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_email()) {
    email_.Set(from._internal_email(), 
      GetArenaForAllocation());
  }
  content_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    content_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content_type()) {
    content_type_.Set(from._internal_content_type(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_csd()) {
    csd_ = new ::safe_browsing::ClientDownloadRequest(*from.csd_);
  } else {
    csd_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentMetaData)
}

inline void ContentMetaData::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
digest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  digest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
content_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  content_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
csd_ = nullptr;
}

ContentMetaData::~ContentMetaData() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentMetaData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentMetaData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  filename_.Destroy();
  digest_.Destroy();
  email_.Destroy();
  content_type_.Destroy();
  if (this != internal_default_instance()) delete csd_;
}

void ContentMetaData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentMetaData::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentMetaData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      digest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      content_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(csd_ != nullptr);
      csd_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentMetaData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filename = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string digest = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ClientDownloadRequest csd = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_csd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string email = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string content_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_content_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentMetaData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentMetaData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string filename = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_filename(), target);
  }

  // optional string digest = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_digest(), target);
  }

  // optional .safe_browsing.ClientDownloadRequest csd = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::csd(this),
        _Internal::csd(this).GetCachedSize(), target, stream);
  }

  // optional string email = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_email(), target);
  }

  // optional string content_type = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_content_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentMetaData)
  return target;
}

size_t ContentMetaData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentMetaData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string filename = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional string digest = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_digest());
    }

    // optional string email = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_email());
    }

    // optional string content_type = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content_type());
    }

    // optional .safe_browsing.ClientDownloadRequest csd = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *csd_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentMetaData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentMetaData*>(
      &from));
}

void ContentMetaData::MergeFrom(const ContentMetaData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentMetaData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_digest(from._internal_digest());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_email(from._internal_email());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_content_type(from._internal_content_type());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_csd()->::safe_browsing::ClientDownloadRequest::MergeFrom(from._internal_csd());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentMetaData::CopyFrom(const ContentMetaData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentMetaData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentMetaData::IsInitialized() const {
  if (_internal_has_csd()) {
    if (!csd_->IsInitialized()) return false;
  }
  return true;
}

void ContentMetaData::InternalSwap(ContentMetaData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &filename_, lhs_arena,
      &other->filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &digest_, lhs_arena,
      &other->digest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &content_type_, lhs_arena,
      &other->content_type_, rhs_arena
  );
  swap(csd_, other->csd_);
}

std::string ContentMetaData::GetTypeName() const {
  return "enterprise_connectors.ContentMetaData";
}


// ===================================================================

class ClientMetadata_Browser::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMetadata_Browser>()._has_bits_);
  static void set_has_browser_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_agent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chrome_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_machine_user(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ClientMetadata_Browser::ClientMetadata_Browser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata.Browser)
}
ClientMetadata_Browser::ClientMetadata_Browser(const ClientMetadata_Browser& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  browser_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    browser_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_id()) {
    browser_id_.Set(from._internal_browser_id(), 
      GetArenaForAllocation());
  }
  user_agent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_agent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_agent()) {
    user_agent_.Set(from._internal_user_agent(), 
      GetArenaForAllocation());
  }
  chrome_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chrome_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chrome_version()) {
    chrome_version_.Set(from._internal_chrome_version(), 
      GetArenaForAllocation());
  }
  machine_user_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    machine_user_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_user()) {
    machine_user_.Set(from._internal_machine_user(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata.Browser)
}

inline void ClientMetadata_Browser::SharedCtor() {
browser_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  browser_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
machine_user_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  machine_user_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMetadata_Browser::~ClientMetadata_Browser() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata.Browser)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMetadata_Browser::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  browser_id_.Destroy();
  user_agent_.Destroy();
  chrome_version_.Destroy();
  machine_user_.Destroy();
}

void ClientMetadata_Browser::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientMetadata_Browser::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata.Browser)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      browser_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_agent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      chrome_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      machine_user_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata_Browser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string browser_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_browser_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_agent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_agent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chrome_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_chrome_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string machine_user = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_machine_user();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata_Browser::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata.Browser)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string browser_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_browser_id(), target);
  }

  // optional string user_agent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_agent(), target);
  }

  // optional string chrome_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_chrome_version(), target);
  }

  // optional string machine_user = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_machine_user(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata.Browser)
  return target;
}

size_t ClientMetadata_Browser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata.Browser)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string browser_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_browser_id());
    }

    // optional string user_agent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_agent());
    }

    // optional string chrome_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chrome_version());
    }

    // optional string machine_user = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_user());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMetadata_Browser::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMetadata_Browser*>(
      &from));
}

void ClientMetadata_Browser::MergeFrom(const ClientMetadata_Browser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata.Browser)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_browser_id(from._internal_browser_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_agent(from._internal_user_agent());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_chrome_version(from._internal_chrome_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_machine_user(from._internal_machine_user());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata_Browser::CopyFrom(const ClientMetadata_Browser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata.Browser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMetadata_Browser::IsInitialized() const {
  return true;
}

void ClientMetadata_Browser::InternalSwap(ClientMetadata_Browser* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &browser_id_, lhs_arena,
      &other->browser_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_agent_, lhs_arena,
      &other->user_agent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &chrome_version_, lhs_arena,
      &other->chrome_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &machine_user_, lhs_arena,
      &other->machine_user_, rhs_arena
  );
}

std::string ClientMetadata_Browser::GetTypeName() const {
  return "enterprise_connectors.ClientMetadata.Browser";
}


// ===================================================================

class ClientMetadata_Device::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMetadata_Device>()._has_bits_);
  static void set_has_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_os_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ClientMetadata_Device::ClientMetadata_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata.Device)
}
ClientMetadata_Device::ClientMetadata_Device(const ClientMetadata_Device& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dm_token()) {
    dm_token_.Set(from._internal_dm_token(), 
      GetArenaForAllocation());
  }
  client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_id()) {
    client_id_.Set(from._internal_client_id(), 
      GetArenaForAllocation());
  }
  os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    os_version_.Set(from._internal_os_version(), 
      GetArenaForAllocation());
  }
  os_platform_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    os_platform_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_platform()) {
    os_platform_.Set(from._internal_os_platform(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata.Device)
}

inline void ClientMetadata_Device::SharedCtor() {
dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
os_platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  os_platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMetadata_Device::~ClientMetadata_Device() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata.Device)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMetadata_Device::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  dm_token_.Destroy();
  client_id_.Destroy();
  os_version_.Destroy();
  os_platform_.Destroy();
  name_.Destroy();
}

void ClientMetadata_Device::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientMetadata_Device::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata.Device)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      client_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      os_platform_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata_Device::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string dm_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string client_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_platform = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_os_platform();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata_Device::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata.Device)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string dm_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_dm_token(), target);
  }

  // optional string client_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_client_id(), target);
  }

  // optional string os_version = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_os_version(), target);
  }

  // optional string os_platform = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_os_platform(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata.Device)
  return target;
}

size_t ClientMetadata_Device::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata.Device)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string dm_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dm_token());
    }

    // optional string client_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_id());
    }

    // optional string os_version = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_version());
    }

    // optional string os_platform = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_platform());
    }

    // optional string name = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMetadata_Device::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMetadata_Device*>(
      &from));
}

void ClientMetadata_Device::MergeFrom(const ClientMetadata_Device& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata.Device)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_dm_token(from._internal_dm_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_client_id(from._internal_client_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_os_platform(from._internal_os_platform());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_name(from._internal_name());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata_Device::CopyFrom(const ClientMetadata_Device& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata.Device)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMetadata_Device::IsInitialized() const {
  return true;
}

void ClientMetadata_Device::InternalSwap(ClientMetadata_Device* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &dm_token_, lhs_arena,
      &other->dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_id_, lhs_arena,
      &other->client_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &os_version_, lhs_arena,
      &other->os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &os_platform_, lhs_arena,
      &other->os_platform_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string ClientMetadata_Device::GetTypeName() const {
  return "enterprise_connectors.ClientMetadata.Device";
}


// ===================================================================

class ClientMetadata_Profile::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMetadata_Profile>()._has_bits_);
  static void set_has_dm_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gaia_email(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_profile_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_profile_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

ClientMetadata_Profile::ClientMetadata_Profile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata.Profile)
}
ClientMetadata_Profile::ClientMetadata_Profile(const ClientMetadata_Profile& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  dm_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dm_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dm_token()) {
    dm_token_.Set(from._internal_dm_token(), 
      GetArenaForAllocation());
  }
  gaia_email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gaia_email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gaia_email()) {
    gaia_email_.Set(from._internal_gaia_email(), 
      GetArenaForAllocation());
  }
  profile_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    profile_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profile_path()) {
    profile_path_.Set(from._internal_profile_path(), 
      GetArenaForAllocation());
  }
  profile_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    profile_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_profile_name()) {
    profile_name_.Set(from._internal_profile_name(), 
      GetArenaForAllocation());
  }
  client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_id()) {
    client_id_.Set(from._internal_client_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata.Profile)
}

inline void ClientMetadata_Profile::SharedCtor() {
dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gaia_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gaia_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
profile_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  profile_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
profile_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  profile_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMetadata_Profile::~ClientMetadata_Profile() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata.Profile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMetadata_Profile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  dm_token_.Destroy();
  gaia_email_.Destroy();
  profile_path_.Destroy();
  profile_name_.Destroy();
  client_id_.Destroy();
}

void ClientMetadata_Profile::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientMetadata_Profile::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata.Profile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      dm_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      gaia_email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      profile_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      profile_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      client_id_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata_Profile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string dm_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_dm_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gaia_email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_gaia_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string profile_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_profile_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string profile_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_profile_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string client_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata_Profile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata.Profile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string dm_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_dm_token(), target);
  }

  // optional string gaia_email = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_gaia_email(), target);
  }

  // optional string profile_path = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_profile_path(), target);
  }

  // optional string profile_name = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_profile_name(), target);
  }

  // optional string client_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_client_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata.Profile)
  return target;
}

size_t ClientMetadata_Profile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata.Profile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string dm_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dm_token());
    }

    // optional string gaia_email = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gaia_email());
    }

    // optional string profile_path = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profile_path());
    }

    // optional string profile_name = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_profile_name());
    }

    // optional string client_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMetadata_Profile::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMetadata_Profile*>(
      &from));
}

void ClientMetadata_Profile::MergeFrom(const ClientMetadata_Profile& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata.Profile)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_dm_token(from._internal_dm_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_gaia_email(from._internal_gaia_email());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_profile_path(from._internal_profile_path());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_profile_name(from._internal_profile_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_client_id(from._internal_client_id());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata_Profile::CopyFrom(const ClientMetadata_Profile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata.Profile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMetadata_Profile::IsInitialized() const {
  return true;
}

void ClientMetadata_Profile::InternalSwap(ClientMetadata_Profile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &dm_token_, lhs_arena,
      &other->dm_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gaia_email_, lhs_arena,
      &other->gaia_email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &profile_path_, lhs_arena,
      &other->profile_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &profile_name_, lhs_arena,
      &other->profile_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_id_, lhs_arena,
      &other->client_id_, rhs_arena
  );
}

std::string ClientMetadata_Profile::GetTypeName() const {
  return "enterprise_connectors.ClientMetadata.Profile";
}


// ===================================================================

class ClientMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientMetadata>()._has_bits_);
  static const ::enterprise_connectors::ClientMetadata_Browser& browser(const ClientMetadata* msg);
  static void set_has_browser(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::enterprise_connectors::ClientMetadata_Device& device(const ClientMetadata* msg);
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_connectors::ClientMetadata_Profile& profile(const ClientMetadata* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_connectors::ClientMetadata_Browser&
ClientMetadata::_Internal::browser(const ClientMetadata* msg) {
  return *msg->browser_;
}
const ::enterprise_connectors::ClientMetadata_Device&
ClientMetadata::_Internal::device(const ClientMetadata* msg) {
  return *msg->device_;
}
const ::enterprise_connectors::ClientMetadata_Profile&
ClientMetadata::_Internal::profile(const ClientMetadata* msg) {
  return *msg->profile_;
}
ClientMetadata::ClientMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata)
}
ClientMetadata::ClientMetadata(const ClientMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_browser()) {
    browser_ = new ::enterprise_connectors::ClientMetadata_Browser(*from.browser_);
  } else {
    browser_ = nullptr;
  }
  if (from._internal_has_device()) {
    device_ = new ::enterprise_connectors::ClientMetadata_Device(*from.device_);
  } else {
    device_ = nullptr;
  }
  if (from._internal_has_profile()) {
    profile_ = new ::enterprise_connectors::ClientMetadata_Profile(*from.profile_);
  } else {
    profile_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata)
}

inline void ClientMetadata::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&browser_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&profile_) -
    reinterpret_cast<char*>(&browser_)) + sizeof(profile_));
}

ClientMetadata::~ClientMetadata() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete browser_;
  if (this != internal_default_instance()) delete device_;
  if (this != internal_default_instance()) delete profile_;
}

void ClientMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(browser_ != nullptr);
      browser_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(device_ != nullptr);
      device_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(profile_ != nullptr);
      profile_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_browser(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ClientMetadata.Device device = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_device(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::browser(this),
        _Internal::browser(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_connectors.ClientMetadata.Device device = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::device(this),
        _Internal::device(this).GetCachedSize(), target, stream);
  }

  // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::profile(this),
        _Internal::profile(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata)
  return target;
}

size_t ClientMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *browser_);
    }

    // optional .enterprise_connectors.ClientMetadata.Device device = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_);
    }

    // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *profile_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientMetadata*>(
      &from));
}

void ClientMetadata::MergeFrom(const ClientMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_browser()->::enterprise_connectors::ClientMetadata_Browser::MergeFrom(from._internal_browser());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_device()->::enterprise_connectors::ClientMetadata_Device::MergeFrom(from._internal_device());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_profile()->::enterprise_connectors::ClientMetadata_Profile::MergeFrom(from._internal_profile());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata::CopyFrom(const ClientMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMetadata::IsInitialized() const {
  return true;
}

void ClientMetadata::InternalSwap(ClientMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientMetadata, profile_)
      + sizeof(ClientMetadata::profile_)
      - PROTOBUF_FIELD_OFFSET(ClientMetadata, browser_)>(
          reinterpret_cast<char*>(&browser_),
          reinterpret_cast<char*>(&other->browser_));
}

std::string ClientMetadata::GetTypeName() const {
  return "enterprise_connectors.ClientMetadata";
}


// ===================================================================

class ContentAnalysisRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentAnalysisRequest>()._has_bits_);
  static void set_has_device_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fcm_notification_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_request_token(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_analysis_connector(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::enterprise_connectors::ContentMetaData& request_data(const ContentAnalysisRequest* msg);
  static void set_has_request_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::enterprise_connectors::ClientMetadata& client_metadata(const ContentAnalysisRequest* msg);
  static void set_has_client_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_expires_at(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::enterprise_connectors::ContentMetaData&
ContentAnalysisRequest::_Internal::request_data(const ContentAnalysisRequest* msg) {
  return *msg->request_data_;
}
const ::enterprise_connectors::ClientMetadata&
ContentAnalysisRequest::_Internal::client_metadata(const ContentAnalysisRequest* msg) {
  return *msg->client_metadata_;
}
ContentAnalysisRequest::ContentAnalysisRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  tags_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisRequest)
}
ContentAnalysisRequest::ContentAnalysisRequest(const ContentAnalysisRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      tags_(from.tags_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  device_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_token()) {
    device_token_.Set(from._internal_device_token(), 
      GetArenaForAllocation());
  }
  fcm_notification_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    fcm_notification_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fcm_notification_token()) {
    fcm_notification_token_.Set(from._internal_fcm_notification_token(), 
      GetArenaForAllocation());
  }
  request_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_token()) {
    request_token_.Set(from._internal_request_token(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_request_data()) {
    request_data_ = new ::enterprise_connectors::ContentMetaData(*from.request_data_);
  } else {
    request_data_ = nullptr;
  }
  if (from._internal_has_client_metadata()) {
    client_metadata_ = new ::enterprise_connectors::ClientMetadata(*from.client_metadata_);
  } else {
    client_metadata_ = nullptr;
  }
  ::memcpy(&expires_at_, &from.expires_at_,
    static_cast<size_t>(reinterpret_cast<char*>(&analysis_connector_) -
    reinterpret_cast<char*>(&expires_at_)) + sizeof(analysis_connector_));
  clear_has_content_data();
  switch (from.content_data_case()) {
    case kTextContent: {
      _internal_set_text_content(from._internal_text_content());
      break;
    }
    case kFilePath: {
      _internal_set_file_path(from._internal_file_path());
      break;
    }
    case CONTENT_DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisRequest)
}

inline void ContentAnalysisRequest::SharedCtor() {
device_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fcm_notification_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  fcm_notification_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_data_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&analysis_connector_) -
    reinterpret_cast<char*>(&request_data_)) + sizeof(analysis_connector_));
clear_has_content_data();
}

ContentAnalysisRequest::~ContentAnalysisRequest() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentAnalysisRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_token_.Destroy();
  fcm_notification_token_.Destroy();
  request_token_.Destroy();
  if (this != internal_default_instance()) delete request_data_;
  if (this != internal_default_instance()) delete client_metadata_;
  if (has_content_data()) {
    clear_content_data();
  }
}

void ContentAnalysisRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentAnalysisRequest::clear_content_data() {
// @@protoc_insertion_point(one_of_clear_start:enterprise_connectors.ContentAnalysisRequest)
  switch (content_data_case()) {
    case kTextContent: {
      content_data_.text_content_.Destroy();
      break;
    }
    case kFilePath: {
      content_data_.file_path_.Destroy();
      break;
    }
    case CONTENT_DATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CONTENT_DATA_NOT_SET;
}


void ContentAnalysisRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tags_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      device_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      fcm_notification_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      request_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(request_data_ != nullptr);
      request_data_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(client_metadata_ != nullptr);
      client_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&expires_at_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&analysis_connector_) -
        reinterpret_cast<char*>(&expires_at_)) + sizeof(analysis_connector_));
  }
  clear_content_data();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string fcm_notification_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fcm_notification_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string request_token = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_request_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::AnalysisConnector_IsValid(val))) {
            _internal_set_analysis_connector(static_cast<::enterprise_connectors::AnalysisConnector>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ContentMetaData request_data = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text_content = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_text_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string file_path = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_file_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 expires_at = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_expires_at(&has_bits);
          expires_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_token(), target);
  }

  // optional string fcm_notification_token = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_fcm_notification_token(), target);
  }

  // optional string request_token = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_request_token(), target);
  }

  // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_analysis_connector(), target);
  }

  // optional .enterprise_connectors.ContentMetaData request_data = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::request_data(this),
        _Internal::request_data(this).GetCachedSize(), target, stream);
  }

  // repeated string tags = 11;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    target = stream->WriteString(11, s, target);
  }

  // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::client_metadata(this),
        _Internal::client_metadata(this).GetCachedSize(), target, stream);
  }

  switch (content_data_case()) {
    case kTextContent: {
      target = stream->WriteStringMaybeAliased(
          13, this->_internal_text_content(), target);
      break;
    }
    case kFilePath: {
      target = stream->WriteStringMaybeAliased(
          14, this->_internal_file_path(), target);
      break;
    }
    default: ;
  }
  // optional int64 expires_at = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_expires_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisRequest)
  return target;
}

size_t ContentAnalysisRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tags = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tags_.size());
  for (int i = 0, n = tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      tags_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string device_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_token());
    }

    // optional string fcm_notification_token = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fcm_notification_token());
    }

    // optional string request_token = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_request_token());
    }

    // optional .enterprise_connectors.ContentMetaData request_data = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *request_data_);
    }

    // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_metadata_);
    }

    // optional int64 expires_at = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expires_at());
    }

    // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_analysis_connector());
    }

  }
  switch (content_data_case()) {
    // string text_content = 13;
    case kTextContent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text_content());
      break;
    }
    // string file_path = 14;
    case kFilePath: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_path());
      break;
    }
    case CONTENT_DATA_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentAnalysisRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentAnalysisRequest*>(
      &from));
}

void ContentAnalysisRequest::MergeFrom(const ContentAnalysisRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  tags_.MergeFrom(from.tags_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_token(from._internal_device_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_fcm_notification_token(from._internal_fcm_notification_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_request_token(from._internal_request_token());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_request_data()->::enterprise_connectors::ContentMetaData::MergeFrom(from._internal_request_data());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_client_metadata()->::enterprise_connectors::ClientMetadata::MergeFrom(from._internal_client_metadata());
    }
    if (cached_has_bits & 0x00000020u) {
      expires_at_ = from.expires_at_;
    }
    if (cached_has_bits & 0x00000040u) {
      analysis_connector_ = from.analysis_connector_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.content_data_case()) {
    case kTextContent: {
      _internal_set_text_content(from._internal_text_content());
      break;
    }
    case kFilePath: {
      _internal_set_file_path(from._internal_file_path());
      break;
    }
    case CONTENT_DATA_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisRequest::CopyFrom(const ContentAnalysisRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentAnalysisRequest::IsInitialized() const {
  if (_internal_has_request_data()) {
    if (!request_data_->IsInitialized()) return false;
  }
  return true;
}

void ContentAnalysisRequest::InternalSwap(ContentAnalysisRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tags_.InternalSwap(&other->tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_token_, lhs_arena,
      &other->device_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &fcm_notification_token_, lhs_arena,
      &other->fcm_notification_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &request_token_, lhs_arena,
      &other->request_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContentAnalysisRequest, analysis_connector_)
      + sizeof(ContentAnalysisRequest::analysis_connector_)
      - PROTOBUF_FIELD_OFFSET(ContentAnalysisRequest, request_data_)>(
          reinterpret_cast<char*>(&request_data_),
          reinterpret_cast<char*>(&other->request_data_));
  swap(content_data_, other->content_data_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ContentAnalysisRequest::GetTypeName() const {
  return "enterprise_connectors.ContentAnalysisRequest";
}


// ===================================================================

class ContentAnalysisResponse_Result_CustomMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentAnalysisResponse_Result_CustomMessage>()._has_bits_);
  static void set_has_learn_more_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ContentAnalysisResponse_Result_CustomMessage::ContentAnalysisResponse_Result_CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
}
ContentAnalysisResponse_Result_CustomMessage::ContentAnalysisResponse_Result_CustomMessage(const ContentAnalysisResponse_Result_CustomMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  learn_more_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    learn_more_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_learn_more_url()) {
    learn_more_url_.Set(from._internal_learn_more_url(), 
      GetArenaForAllocation());
  }
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
}

inline void ContentAnalysisResponse_Result_CustomMessage::SharedCtor() {
learn_more_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  learn_more_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse_Result_CustomMessage::~ContentAnalysisResponse_Result_CustomMessage() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentAnalysisResponse_Result_CustomMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  learn_more_url_.Destroy();
  message_.Destroy();
}

void ContentAnalysisResponse_Result_CustomMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentAnalysisResponse_Result_CustomMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      learn_more_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      message_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result_CustomMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string learn_more_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_learn_more_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result_CustomMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string learn_more_url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_learn_more_url(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  return target;
}

size_t ContentAnalysisResponse_Result_CustomMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string learn_more_url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_learn_more_url());
    }

    // optional string message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentAnalysisResponse_Result_CustomMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result_CustomMessage*>(
      &from));
}

void ContentAnalysisResponse_Result_CustomMessage::MergeFrom(const ContentAnalysisResponse_Result_CustomMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_learn_more_url(from._internal_learn_more_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_message(from._internal_message());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result_CustomMessage::CopyFrom(const ContentAnalysisResponse_Result_CustomMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentAnalysisResponse_Result_CustomMessage::IsInitialized() const {
  return true;
}

void ContentAnalysisResponse_Result_CustomMessage::InternalSwap(ContentAnalysisResponse_Result_CustomMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &learn_more_url_, lhs_arena,
      &other->learn_more_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
}

std::string ContentAnalysisResponse_Result_CustomMessage::GetTypeName() const {
  return "enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage";
}


// ===================================================================

class ContentAnalysisResponse_Result_TriggeredRule::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentAnalysisResponse_Result_TriggeredRule>()._has_bits_);
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rule_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rule_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& custom_message(const ContentAnalysisResponse_Result_TriggeredRule* msg);
  static void set_has_custom_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage&
ContentAnalysisResponse_Result_TriggeredRule::_Internal::custom_message(const ContentAnalysisResponse_Result_TriggeredRule* msg) {
  return *msg->custom_message_;
}
ContentAnalysisResponse_Result_TriggeredRule::ContentAnalysisResponse_Result_TriggeredRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
}
ContentAnalysisResponse_Result_TriggeredRule::ContentAnalysisResponse_Result_TriggeredRule(const ContentAnalysisResponse_Result_TriggeredRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  rule_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rule_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_name()) {
    rule_name_.Set(from._internal_rule_name(), 
      GetArenaForAllocation());
  }
  rule_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rule_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rule_id()) {
    rule_id_.Set(from._internal_rule_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_custom_message()) {
    custom_message_ = new ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage(*from.custom_message_);
  } else {
    custom_message_ = nullptr;
  }
  action_ = from.action_;
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
}

inline void ContentAnalysisResponse_Result_TriggeredRule::SharedCtor() {
rule_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rule_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rule_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rule_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&custom_message_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&action_) -
    reinterpret_cast<char*>(&custom_message_)) + sizeof(action_));
}

ContentAnalysisResponse_Result_TriggeredRule::~ContentAnalysisResponse_Result_TriggeredRule() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentAnalysisResponse_Result_TriggeredRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  rule_name_.Destroy();
  rule_id_.Destroy();
  if (this != internal_default_instance()) delete custom_message_;
}

void ContentAnalysisResponse_Result_TriggeredRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentAnalysisResponse_Result_TriggeredRule::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      rule_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      rule_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(custom_message_ != nullptr);
      custom_message_->Clear();
    }
  }
  action_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result_TriggeredRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(val))) {
            _internal_set_action(static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string rule_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_rule_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string rule_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rule_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result_TriggeredRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_action(), target);
  }

  // optional string rule_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_rule_name(), target);
  }

  // optional string rule_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rule_id(), target);
  }

  // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::custom_message(this),
        _Internal::custom_message(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  return target;
}

size_t ContentAnalysisResponse_Result_TriggeredRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string rule_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_name());
    }

    // optional string rule_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rule_id());
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *custom_message_);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentAnalysisResponse_Result_TriggeredRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result_TriggeredRule*>(
      &from));
}

void ContentAnalysisResponse_Result_TriggeredRule::MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_rule_name(from._internal_rule_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_rule_id(from._internal_rule_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_custom_message()->::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage::MergeFrom(from._internal_custom_message());
    }
    if (cached_has_bits & 0x00000008u) {
      action_ = from.action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result_TriggeredRule::CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentAnalysisResponse_Result_TriggeredRule::IsInitialized() const {
  return true;
}

void ContentAnalysisResponse_Result_TriggeredRule::InternalSwap(ContentAnalysisResponse_Result_TriggeredRule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &rule_name_, lhs_arena,
      &other->rule_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &rule_id_, lhs_arena,
      &other->rule_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result_TriggeredRule, action_)
      + sizeof(ContentAnalysisResponse_Result_TriggeredRule::action_)
      - PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result_TriggeredRule, custom_message_)>(
          reinterpret_cast<char*>(&custom_message_),
          reinterpret_cast<char*>(&other->custom_message_));
}

std::string ContentAnalysisResponse_Result_TriggeredRule::GetTypeName() const {
  return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule";
}


// ===================================================================

class ContentAnalysisResponse_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentAnalysisResponse_Result>()._has_bits_);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& custom_message(const ContentAnalysisResponse_Result* msg);
  static void set_has_custom_message(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_malware_family(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_malware_category(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_evidence_locker_filepath(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage&
ContentAnalysisResponse_Result::_Internal::custom_message(const ContentAnalysisResponse_Result* msg) {
  return *msg->custom_message_;
}
ContentAnalysisResponse_Result::ContentAnalysisResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  triggered_rules_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result)
}
ContentAnalysisResponse_Result::ContentAnalysisResponse_Result(const ContentAnalysisResponse_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      triggered_rules_(from.triggered_rules_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  malware_family_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    malware_family_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_malware_family()) {
    malware_family_.Set(from._internal_malware_family(), 
      GetArenaForAllocation());
  }
  malware_category_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    malware_category_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_malware_category()) {
    malware_category_.Set(from._internal_malware_category(), 
      GetArenaForAllocation());
  }
  evidence_locker_filepath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    evidence_locker_filepath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_evidence_locker_filepath()) {
    evidence_locker_filepath_.Set(from._internal_evidence_locker_filepath(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_custom_message()) {
    custom_message_ = new ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage(*from.custom_message_);
  } else {
    custom_message_ = nullptr;
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result)
}

inline void ContentAnalysisResponse_Result::SharedCtor() {
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
malware_family_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  malware_family_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
malware_category_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  malware_category_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
evidence_locker_filepath_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  evidence_locker_filepath_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&custom_message_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&custom_message_)) + sizeof(status_));
}

ContentAnalysisResponse_Result::~ContentAnalysisResponse_Result() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentAnalysisResponse_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tag_.Destroy();
  malware_family_.Destroy();
  malware_category_.Destroy();
  evidence_locker_filepath_.Destroy();
  if (this != internal_default_instance()) delete custom_message_;
}

void ContentAnalysisResponse_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentAnalysisResponse_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  triggered_rules_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      malware_family_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      malware_category_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      evidence_locker_filepath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(custom_message_ != nullptr);
      custom_message_->Clear();
    }
  }
  status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisResponse_Result_Status_IsValid(val))) {
            _internal_set_status(static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_triggered_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string malware_family = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_malware_family();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string malware_category = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_malware_category();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string evidence_locker_filepath = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_evidence_locker_filepath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tag = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tag(), target);
  }

  // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_triggered_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_triggered_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string malware_family = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_malware_family(), target);
  }

  // optional string malware_category = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_malware_category(), target);
  }

  // optional string evidence_locker_filepath = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_evidence_locker_filepath(), target);
  }

  // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::custom_message(this),
        _Internal::custom_message(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result)
  return target;
}

size_t ContentAnalysisResponse_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
  total_size += 1UL * this->_internal_triggered_rules_size();
  for (const auto& msg : this->triggered_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional string malware_family = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_malware_family());
    }

    // optional string malware_category = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_malware_category());
    }

    // optional string evidence_locker_filepath = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_evidence_locker_filepath());
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *custom_message_);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentAnalysisResponse_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result*>(
      &from));
}

void ContentAnalysisResponse_Result::MergeFrom(const ContentAnalysisResponse_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  triggered_rules_.MergeFrom(from.triggered_rules_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_malware_family(from._internal_malware_family());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_malware_category(from._internal_malware_category());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_evidence_locker_filepath(from._internal_evidence_locker_filepath());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_custom_message()->::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage::MergeFrom(from._internal_custom_message());
    }
    if (cached_has_bits & 0x00000020u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result::CopyFrom(const ContentAnalysisResponse_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentAnalysisResponse_Result::IsInitialized() const {
  return true;
}

void ContentAnalysisResponse_Result::InternalSwap(ContentAnalysisResponse_Result* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  triggered_rules_.InternalSwap(&other->triggered_rules_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &malware_family_, lhs_arena,
      &other->malware_family_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &malware_category_, lhs_arena,
      &other->malware_category_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &evidence_locker_filepath_, lhs_arena,
      &other->evidence_locker_filepath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result, status_)
      + sizeof(ContentAnalysisResponse_Result::status_)
      - PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result, custom_message_)>(
          reinterpret_cast<char*>(&custom_message_),
          reinterpret_cast<char*>(&other->custom_message_));
}

std::string ContentAnalysisResponse_Result::GetTypeName() const {
  return "enterprise_connectors.ContentAnalysisResponse.Result";
}


// ===================================================================

class ContentAnalysisResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentAnalysisResponse>()._has_bits_);
  static void set_has_request_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContentAnalysisResponse::ContentAnalysisResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  results_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse)
}
ContentAnalysisResponse::ContentAnalysisResponse(const ContentAnalysisResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      results_(from.results_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  request_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_token()) {
    request_token_.Set(from._internal_request_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse)
}

inline void ContentAnalysisResponse::SharedCtor() {
request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse::~ContentAnalysisResponse() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentAnalysisResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  request_token_.Destroy();
}

void ContentAnalysisResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentAnalysisResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  results_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    request_token_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string request_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_request_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string request_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_request_token(), target);
  }

  // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse)
  return target;
}

size_t ContentAnalysisResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
  total_size += 1UL * this->_internal_results_size();
  for (const auto& msg : this->results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string request_token = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_request_token());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentAnalysisResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse*>(
      &from));
}

void ContentAnalysisResponse::MergeFrom(const ContentAnalysisResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  results_.MergeFrom(from.results_);
  if (from._internal_has_request_token()) {
    _internal_set_request_token(from._internal_request_token());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse::CopyFrom(const ContentAnalysisResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentAnalysisResponse::IsInitialized() const {
  return true;
}

void ContentAnalysisResponse::InternalSwap(ContentAnalysisResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  results_.InternalSwap(&other->results_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &request_token_, lhs_arena,
      &other->request_token_, rhs_arena
  );
}

std::string ContentAnalysisResponse::GetTypeName() const {
  return "enterprise_connectors.ContentAnalysisResponse";
}


// ===================================================================

class ContentAnalysisAcknowledgement::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentAnalysisAcknowledgement>()._has_bits_);
  static void set_has_request_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_final_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ContentAnalysisAcknowledgement::ContentAnalysisAcknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisAcknowledgement)
}
ContentAnalysisAcknowledgement::ContentAnalysisAcknowledgement(const ContentAnalysisAcknowledgement& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  request_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_token()) {
    request_token_.Set(from._internal_request_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&final_action_, &from.final_action_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&final_action_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisAcknowledgement)
}

inline void ContentAnalysisAcknowledgement::SharedCtor() {
request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
final_action_ = 0;
status_ = 1;
}

ContentAnalysisAcknowledgement::~ContentAnalysisAcknowledgement() {
  // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisAcknowledgement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContentAnalysisAcknowledgement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  request_token_.Destroy();
}

void ContentAnalysisAcknowledgement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContentAnalysisAcknowledgement::Clear() {
// @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisAcknowledgement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    request_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    final_action_ = 0;
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisAcknowledgement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string request_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_request_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisAcknowledgement_Status_IsValid(val))) {
            _internal_set_status(static_cast<::enterprise_connectors::ContentAnalysisAcknowledgement_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction_IsValid(val))) {
            _internal_set_final_action(static_cast<::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisAcknowledgement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisAcknowledgement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string request_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_request_token(), target);
  }

  // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_final_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisAcknowledgement)
  return target;
}

size_t ContentAnalysisAcknowledgement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisAcknowledgement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string request_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_request_token());
    }

    // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_final_action());
    }

    // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentAnalysisAcknowledgement::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContentAnalysisAcknowledgement*>(
      &from));
}

void ContentAnalysisAcknowledgement::MergeFrom(const ContentAnalysisAcknowledgement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisAcknowledgement)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_request_token(from._internal_request_token());
    }
    if (cached_has_bits & 0x00000002u) {
      final_action_ = from.final_action_;
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisAcknowledgement::CopyFrom(const ContentAnalysisAcknowledgement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisAcknowledgement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentAnalysisAcknowledgement::IsInitialized() const {
  return true;
}

void ContentAnalysisAcknowledgement::InternalSwap(ContentAnalysisAcknowledgement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &request_token_, lhs_arena,
      &other->request_token_, rhs_arena
  );
  swap(final_action_, other->final_action_);
  swap(status_, other->status_);
}

std::string ContentAnalysisAcknowledgement::GetTypeName() const {
  return "enterprise_connectors.ContentAnalysisAcknowledgement";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace enterprise_connectors
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentMetaData*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentMetaData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentMetaData >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata_Browser*
Arena::CreateMaybeMessage< ::enterprise_connectors::ClientMetadata_Browser >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ClientMetadata_Browser >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata_Device*
Arena::CreateMaybeMessage< ::enterprise_connectors::ClientMetadata_Device >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ClientMetadata_Device >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata_Profile*
Arena::CreateMaybeMessage< ::enterprise_connectors::ClientMetadata_Profile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ClientMetadata_Profile >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata*
Arena::CreateMaybeMessage< ::enterprise_connectors::ClientMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ClientMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisRequest*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentAnalysisRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentAnalysisRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentAnalysisResponse_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentAnalysisResponse_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentAnalysisResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentAnalysisResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisAcknowledgement*
Arena::CreateMaybeMessage< ::enterprise_connectors::ContentAnalysisAcknowledgement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::enterprise_connectors::ContentAnalysisAcknowledgement >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
