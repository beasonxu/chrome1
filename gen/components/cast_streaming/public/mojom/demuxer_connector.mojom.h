// components/cast_streaming/public/mojom/demuxer_connector.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_CAST_STREAMING_PUBLIC_MOJOM_DEMUXER_CONNECTOR_MOJOM_H_
#define COMPONENTS_CAST_STREAMING_PUBLIC_MOJOM_DEMUXER_CONNECTOR_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/cast_streaming/public/mojom/demuxer_connector.mojom-shared.h"
#include "components/cast_streaming/public/mojom/demuxer_connector.mojom-forward.h"
#include "media/mojo/mojom/media_types.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"




namespace cast_streaming {
namespace mojom {

class AudioBufferRequesterProxy;

template <typename ImplRefTraits>
class AudioBufferRequesterStub;

class AudioBufferRequesterRequestValidator;
class AudioBufferRequesterResponseValidator;


class  AudioBufferRequester
    : public AudioBufferRequesterInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = AudioBufferRequesterInterfaceBase;
  using Proxy_ = AudioBufferRequesterProxy;

  template <typename ImplRefTraits>
  using Stub_ = AudioBufferRequesterStub<ImplRefTraits>;

  using RequestValidator_ = AudioBufferRequesterRequestValidator;
  using ResponseValidator_ = AudioBufferRequesterResponseValidator;
  enum MethodMinVersions : uint32_t {
    kGetBufferMinVersion = 0,
    kEnableBitstreamConverterMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct GetBuffer_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct EnableBitstreamConverter_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~AudioBufferRequester() = default;


  using GetBufferCallback = base::OnceCallback<void(GetAudioBufferResponsePtr)>;
  
  virtual void GetBuffer(GetBufferCallback callback) = 0;


  using EnableBitstreamConverterCallback = base::OnceCallback<void(bool)>;
  
  virtual void EnableBitstreamConverter(EnableBitstreamConverterCallback callback) = 0;
};

class VideoBufferRequesterProxy;

template <typename ImplRefTraits>
class VideoBufferRequesterStub;

class VideoBufferRequesterRequestValidator;
class VideoBufferRequesterResponseValidator;


class  VideoBufferRequester
    : public VideoBufferRequesterInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = VideoBufferRequesterInterfaceBase;
  using Proxy_ = VideoBufferRequesterProxy;

  template <typename ImplRefTraits>
  using Stub_ = VideoBufferRequesterStub<ImplRefTraits>;

  using RequestValidator_ = VideoBufferRequesterRequestValidator;
  using ResponseValidator_ = VideoBufferRequesterResponseValidator;
  enum MethodMinVersions : uint32_t {
    kGetBufferMinVersion = 0,
    kEnableBitstreamConverterMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct GetBuffer_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct EnableBitstreamConverter_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~VideoBufferRequester() = default;


  using GetBufferCallback = base::OnceCallback<void(GetVideoBufferResponsePtr)>;
  
  virtual void GetBuffer(GetBufferCallback callback) = 0;


  using EnableBitstreamConverterCallback = base::OnceCallback<void(bool)>;
  
  virtual void EnableBitstreamConverter(EnableBitstreamConverterCallback callback) = 0;
};

class DemuxerConnectorProxy;

template <typename ImplRefTraits>
class DemuxerConnectorStub;

class DemuxerConnectorRequestValidator;
class DemuxerConnectorResponseValidator;


class  DemuxerConnector
    : public DemuxerConnectorInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = DemuxerConnectorInterfaceBase;
  using Proxy_ = DemuxerConnectorProxy;

  template <typename ImplRefTraits>
  using Stub_ = DemuxerConnectorStub<ImplRefTraits>;

  using RequestValidator_ = DemuxerConnectorRequestValidator;
  using ResponseValidator_ = DemuxerConnectorResponseValidator;
  enum MethodMinVersions : uint32_t {
    kEnableReceiverMinVersion = 0,
    kOnStreamsInitializedMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct EnableReceiver_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnStreamsInitialized_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~DemuxerConnector() = default;


  using EnableReceiverCallback = base::OnceCallback<void()>;
  
  virtual void EnableReceiver(EnableReceiverCallback callback) = 0;

  
  virtual void OnStreamsInitialized(AudioStreamInitializationInfoPtr audio_buffer_requester, VideoStreamInitializationInfoPtr video_buffer_requester) = 0;
};



class  AudioBufferRequesterProxy
    : public AudioBufferRequester {
 public:
  using InterfaceType = AudioBufferRequester;

  explicit AudioBufferRequesterProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetBuffer(GetBufferCallback callback) final;
  
  void EnableBitstreamConverter(EnableBitstreamConverterCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  VideoBufferRequesterProxy
    : public VideoBufferRequester {
 public:
  using InterfaceType = VideoBufferRequester;

  explicit VideoBufferRequesterProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetBuffer(GetBufferCallback callback) final;
  
  void EnableBitstreamConverter(EnableBitstreamConverterCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  DemuxerConnectorProxy
    : public DemuxerConnector {
 public:
  using InterfaceType = DemuxerConnector;

  explicit DemuxerConnectorProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void EnableReceiver(EnableReceiverCallback callback) final;
  
  void OnStreamsInitialized(AudioStreamInitializationInfoPtr audio_buffer_requester, VideoStreamInitializationInfoPtr video_buffer_requester) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  AudioBufferRequesterStubDispatch {
 public:
  static bool Accept(AudioBufferRequester* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      AudioBufferRequester* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<AudioBufferRequester>>
class AudioBufferRequesterStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  AudioBufferRequesterStub() = default;
  ~AudioBufferRequesterStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AudioBufferRequesterStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AudioBufferRequesterStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  VideoBufferRequesterStubDispatch {
 public:
  static bool Accept(VideoBufferRequester* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      VideoBufferRequester* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<VideoBufferRequester>>
class VideoBufferRequesterStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  VideoBufferRequesterStub() = default;
  ~VideoBufferRequesterStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return VideoBufferRequesterStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return VideoBufferRequesterStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  DemuxerConnectorStubDispatch {
 public:
  static bool Accept(DemuxerConnector* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      DemuxerConnector* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<DemuxerConnector>>
class DemuxerConnectorStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  DemuxerConnectorStub() = default;
  ~DemuxerConnectorStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return DemuxerConnectorStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return DemuxerConnectorStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  AudioBufferRequesterRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  VideoBufferRequesterRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  DemuxerConnectorRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  AudioBufferRequesterResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  VideoBufferRequesterResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  DemuxerConnectorResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};









class  GetAudioBufferResponse {
 public:
  using DataView = GetAudioBufferResponseDataView;
  using Data_ = internal::GetAudioBufferResponse_Data;
  using Tag = Data_::GetAudioBufferResponse_Tag;

  template <typename... Args>
  static GetAudioBufferResponsePtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |stream_info|.
  static GetAudioBufferResponsePtr
  NewStreamInfo(
      AudioStreamInfoPtr stream_info) {
    auto result = GetAudioBufferResponsePtr(absl::in_place);
    result->set_stream_info(std::move(stream_info));
    return result;
  }
  // Construct an instance holding |buffer|.
  static GetAudioBufferResponsePtr
  NewBuffer(
      ::media::mojom::DecoderBufferPtr buffer) {
    auto result = GetAudioBufferResponsePtr(absl::in_place);
    result->set_buffer(std::move(buffer));
    return result;
  }

  template <typename U>
  static GetAudioBufferResponsePtr From(const U& u) {
    return mojo::TypeConverter<GetAudioBufferResponsePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, GetAudioBufferResponse>::Convert(*this);
  }

  GetAudioBufferResponse();
  ~GetAudioBufferResponse();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = GetAudioBufferResponsePtr>
  GetAudioBufferResponsePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, GetAudioBufferResponse>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, GetAudioBufferResponse>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_stream_info() const { return tag_ == Tag::kStreamInfo; }

  
  AudioStreamInfoPtr& get_stream_info() const {
    CHECK(tag_ == Tag::kStreamInfo);
    return *(data_.stream_info);
  }

  
  void set_stream_info(
      AudioStreamInfoPtr stream_info);
  
  bool is_buffer() const { return tag_ == Tag::kBuffer; }

  
  ::media::mojom::DecoderBufferPtr& get_buffer() const {
    CHECK(tag_ == Tag::kBuffer);
    return *(data_.buffer);
  }

  
  void set_buffer(
      ::media::mojom::DecoderBufferPtr buffer);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        GetAudioBufferResponse::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<GetAudioBufferResponse::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    AudioStreamInfoPtr* stream_info;
    ::media::mojom::DecoderBufferPtr* buffer;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



class  GetVideoBufferResponse {
 public:
  using DataView = GetVideoBufferResponseDataView;
  using Data_ = internal::GetVideoBufferResponse_Data;
  using Tag = Data_::GetVideoBufferResponse_Tag;

  template <typename... Args>
  static GetVideoBufferResponsePtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |stream_info|.
  static GetVideoBufferResponsePtr
  NewStreamInfo(
      VideoStreamInfoPtr stream_info) {
    auto result = GetVideoBufferResponsePtr(absl::in_place);
    result->set_stream_info(std::move(stream_info));
    return result;
  }
  // Construct an instance holding |buffer|.
  static GetVideoBufferResponsePtr
  NewBuffer(
      ::media::mojom::DecoderBufferPtr buffer) {
    auto result = GetVideoBufferResponsePtr(absl::in_place);
    result->set_buffer(std::move(buffer));
    return result;
  }

  template <typename U>
  static GetVideoBufferResponsePtr From(const U& u) {
    return mojo::TypeConverter<GetVideoBufferResponsePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, GetVideoBufferResponse>::Convert(*this);
  }

  GetVideoBufferResponse();
  ~GetVideoBufferResponse();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = GetVideoBufferResponsePtr>
  GetVideoBufferResponsePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, GetVideoBufferResponse>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, GetVideoBufferResponse>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_stream_info() const { return tag_ == Tag::kStreamInfo; }

  
  VideoStreamInfoPtr& get_stream_info() const {
    CHECK(tag_ == Tag::kStreamInfo);
    return *(data_.stream_info);
  }

  
  void set_stream_info(
      VideoStreamInfoPtr stream_info);
  
  bool is_buffer() const { return tag_ == Tag::kBuffer; }

  
  ::media::mojom::DecoderBufferPtr& get_buffer() const {
    CHECK(tag_ == Tag::kBuffer);
    return *(data_.buffer);
  }

  
  void set_buffer(
      ::media::mojom::DecoderBufferPtr buffer);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        GetVideoBufferResponse::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<GetVideoBufferResponse::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    VideoStreamInfoPtr* stream_info;
    ::media::mojom::DecoderBufferPtr* buffer;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class  AudioStreamInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AudioStreamInfo, T>::value>;
  using DataView = AudioStreamInfoDataView;
  using Data_ = internal::AudioStreamInfo_Data;

  template <typename... Args>
  static AudioStreamInfoPtr New(Args&&... args) {
    return AudioStreamInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AudioStreamInfoPtr From(const U& u) {
    return mojo::TypeConverter<AudioStreamInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AudioStreamInfo>::Convert(*this);
  }


  AudioStreamInfo();

  AudioStreamInfo(
      const ::media::AudioDecoderConfig& decoder_config,
      ::mojo::ScopedDataPipeConsumerHandle data_pipe);

AudioStreamInfo(const AudioStreamInfo&) = delete;
AudioStreamInfo& operator=(const AudioStreamInfo&) = delete;

  ~AudioStreamInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AudioStreamInfoPtr>
  AudioStreamInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AudioStreamInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AudioStreamInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AudioStreamInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AudioStreamInfo_UnserializedMessageContext<
            UserType, AudioStreamInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AudioStreamInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AudioStreamInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AudioStreamInfo_UnserializedMessageContext<
            UserType, AudioStreamInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AudioStreamInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::AudioDecoderConfig decoder_config;
  
  ::mojo::ScopedDataPipeConsumerHandle data_pipe;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AudioStreamInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AudioStreamInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AudioStreamInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AudioStreamInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoStreamInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoStreamInfo, T>::value>;
  using DataView = VideoStreamInfoDataView;
  using Data_ = internal::VideoStreamInfo_Data;

  template <typename... Args>
  static VideoStreamInfoPtr New(Args&&... args) {
    return VideoStreamInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoStreamInfoPtr From(const U& u) {
    return mojo::TypeConverter<VideoStreamInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoStreamInfo>::Convert(*this);
  }


  VideoStreamInfo();

  VideoStreamInfo(
      const ::media::VideoDecoderConfig& decoder_config,
      ::mojo::ScopedDataPipeConsumerHandle data_pipe);

VideoStreamInfo(const VideoStreamInfo&) = delete;
VideoStreamInfo& operator=(const VideoStreamInfo&) = delete;

  ~VideoStreamInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoStreamInfoPtr>
  VideoStreamInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoStreamInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoStreamInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoStreamInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoStreamInfo_UnserializedMessageContext<
            UserType, VideoStreamInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoStreamInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoStreamInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoStreamInfo_UnserializedMessageContext<
            UserType, VideoStreamInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoStreamInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoDecoderConfig decoder_config;
  
  ::mojo::ScopedDataPipeConsumerHandle data_pipe;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoStreamInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoStreamInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoStreamInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoStreamInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AudioStreamInitializationInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AudioStreamInitializationInfo, T>::value>;
  using DataView = AudioStreamInitializationInfoDataView;
  using Data_ = internal::AudioStreamInitializationInfo_Data;

  template <typename... Args>
  static AudioStreamInitializationInfoPtr New(Args&&... args) {
    return AudioStreamInitializationInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AudioStreamInitializationInfoPtr From(const U& u) {
    return mojo::TypeConverter<AudioStreamInitializationInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AudioStreamInitializationInfo>::Convert(*this);
  }


  AudioStreamInitializationInfo();

  AudioStreamInitializationInfo(
      ::mojo::PendingRemote<AudioBufferRequester> buffer_requester,
      AudioStreamInfoPtr stream_initialization_info);

AudioStreamInitializationInfo(const AudioStreamInitializationInfo&) = delete;
AudioStreamInitializationInfo& operator=(const AudioStreamInitializationInfo&) = delete;

  ~AudioStreamInitializationInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AudioStreamInitializationInfoPtr>
  AudioStreamInitializationInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AudioStreamInitializationInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AudioStreamInitializationInfo_UnserializedMessageContext<
            UserType, AudioStreamInitializationInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AudioStreamInitializationInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AudioStreamInitializationInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AudioStreamInitializationInfo_UnserializedMessageContext<
            UserType, AudioStreamInitializationInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AudioStreamInitializationInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::mojo::PendingRemote<AudioBufferRequester> buffer_requester;
  
  AudioStreamInfoPtr stream_initialization_info;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoStreamInitializationInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoStreamInitializationInfo, T>::value>;
  using DataView = VideoStreamInitializationInfoDataView;
  using Data_ = internal::VideoStreamInitializationInfo_Data;

  template <typename... Args>
  static VideoStreamInitializationInfoPtr New(Args&&... args) {
    return VideoStreamInitializationInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoStreamInitializationInfoPtr From(const U& u) {
    return mojo::TypeConverter<VideoStreamInitializationInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoStreamInitializationInfo>::Convert(*this);
  }


  VideoStreamInitializationInfo();

  VideoStreamInitializationInfo(
      ::mojo::PendingRemote<VideoBufferRequester> buffer_requester,
      VideoStreamInfoPtr stream_initialization_info);

VideoStreamInitializationInfo(const VideoStreamInitializationInfo&) = delete;
VideoStreamInitializationInfo& operator=(const VideoStreamInitializationInfo&) = delete;

  ~VideoStreamInitializationInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoStreamInitializationInfoPtr>
  VideoStreamInitializationInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoStreamInitializationInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoStreamInitializationInfo_UnserializedMessageContext<
            UserType, VideoStreamInitializationInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoStreamInitializationInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoStreamInitializationInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoStreamInitializationInfo_UnserializedMessageContext<
            UserType, VideoStreamInitializationInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoStreamInitializationInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::mojo::PendingRemote<VideoBufferRequester> buffer_requester;
  
  VideoStreamInfoPtr stream_initialization_info;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
GetAudioBufferResponsePtr GetAudioBufferResponse::Clone() const {
  switch (tag_) {
    case Tag::kStreamInfo:
      return NewStreamInfo(
          mojo::Clone(*data_.stream_info));
    case Tag::kBuffer:
      return NewBuffer(
          mojo::Clone(*data_.buffer));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, GetAudioBufferResponse>::value>::type*>
bool GetAudioBufferResponse::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kStreamInfo:
      return mojo::Equals(*(data_.stream_info), *(other.data_.stream_info));
    case Tag::kBuffer:
      return mojo::Equals(*(data_.buffer), *(other.data_.buffer));
  }

  return false;
}
template <typename UnionPtrType>
GetVideoBufferResponsePtr GetVideoBufferResponse::Clone() const {
  switch (tag_) {
    case Tag::kStreamInfo:
      return NewStreamInfo(
          mojo::Clone(*data_.stream_info));
    case Tag::kBuffer:
      return NewBuffer(
          mojo::Clone(*data_.buffer));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, GetVideoBufferResponse>::value>::type*>
bool GetVideoBufferResponse::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kStreamInfo:
      return mojo::Equals(*(data_.stream_info), *(other.data_.stream_info));
    case Tag::kBuffer:
      return mojo::Equals(*(data_.buffer), *(other.data_.buffer));
  }

  return false;
}
template <typename StructPtrType>
AudioStreamInfoPtr AudioStreamInfo::Clone() const {
  return New(
      mojo::Clone(decoder_config),
      mojo::Clone(data_pipe)
  );
}

template <typename T, AudioStreamInfo::EnableIfSame<T>*>
bool AudioStreamInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->decoder_config, other_struct.decoder_config))
    return false;
  if (!mojo::Equals(this->data_pipe, other_struct.data_pipe))
    return false;
  return true;
}

template <typename T, AudioStreamInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.decoder_config < rhs.decoder_config)
    return true;
  if (rhs.decoder_config < lhs.decoder_config)
    return false;
  if (lhs.data_pipe < rhs.data_pipe)
    return true;
  if (rhs.data_pipe < lhs.data_pipe)
    return false;
  return false;
}
template <typename StructPtrType>
VideoStreamInfoPtr VideoStreamInfo::Clone() const {
  return New(
      mojo::Clone(decoder_config),
      mojo::Clone(data_pipe)
  );
}

template <typename T, VideoStreamInfo::EnableIfSame<T>*>
bool VideoStreamInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->decoder_config, other_struct.decoder_config))
    return false;
  if (!mojo::Equals(this->data_pipe, other_struct.data_pipe))
    return false;
  return true;
}

template <typename T, VideoStreamInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.decoder_config < rhs.decoder_config)
    return true;
  if (rhs.decoder_config < lhs.decoder_config)
    return false;
  if (lhs.data_pipe < rhs.data_pipe)
    return true;
  if (rhs.data_pipe < lhs.data_pipe)
    return false;
  return false;
}
template <typename StructPtrType>
AudioStreamInitializationInfoPtr AudioStreamInitializationInfo::Clone() const {
  return New(
      mojo::Clone(buffer_requester),
      mojo::Clone(stream_initialization_info)
  );
}

template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>*>
bool AudioStreamInitializationInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->buffer_requester, other_struct.buffer_requester))
    return false;
  if (!mojo::Equals(this->stream_initialization_info, other_struct.stream_initialization_info))
    return false;
  return true;
}

template <typename T, AudioStreamInitializationInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.buffer_requester < rhs.buffer_requester)
    return true;
  if (rhs.buffer_requester < lhs.buffer_requester)
    return false;
  if (lhs.stream_initialization_info < rhs.stream_initialization_info)
    return true;
  if (rhs.stream_initialization_info < lhs.stream_initialization_info)
    return false;
  return false;
}
template <typename StructPtrType>
VideoStreamInitializationInfoPtr VideoStreamInitializationInfo::Clone() const {
  return New(
      mojo::Clone(buffer_requester),
      mojo::Clone(stream_initialization_info)
  );
}

template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>*>
bool VideoStreamInitializationInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->buffer_requester, other_struct.buffer_requester))
    return false;
  if (!mojo::Equals(this->stream_initialization_info, other_struct.stream_initialization_info))
    return false;
  return true;
}

template <typename T, VideoStreamInitializationInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.buffer_requester < rhs.buffer_requester)
    return true;
  if (rhs.buffer_requester < lhs.buffer_requester)
    return false;
  if (lhs.stream_initialization_info < rhs.stream_initialization_info)
    return true;
  if (rhs.stream_initialization_info < lhs.stream_initialization_info)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace cast_streaming

namespace mojo {


template <>
struct  StructTraits<::cast_streaming::mojom::AudioStreamInfo::DataView,
                                         ::cast_streaming::mojom::AudioStreamInfoPtr> {
  static bool IsNull(const ::cast_streaming::mojom::AudioStreamInfoPtr& input) { return !input; }
  static void SetToNull(::cast_streaming::mojom::AudioStreamInfoPtr* output) { output->reset(); }

  static const decltype(::cast_streaming::mojom::AudioStreamInfo::decoder_config)& decoder_config(
      const ::cast_streaming::mojom::AudioStreamInfoPtr& input) {
    return input->decoder_config;
  }

  static  decltype(::cast_streaming::mojom::AudioStreamInfo::data_pipe)& data_pipe(
       ::cast_streaming::mojom::AudioStreamInfoPtr& input) {
    return input->data_pipe;
  }

  static bool Read(::cast_streaming::mojom::AudioStreamInfo::DataView input, ::cast_streaming::mojom::AudioStreamInfoPtr* output);
};


template <>
struct  StructTraits<::cast_streaming::mojom::VideoStreamInfo::DataView,
                                         ::cast_streaming::mojom::VideoStreamInfoPtr> {
  static bool IsNull(const ::cast_streaming::mojom::VideoStreamInfoPtr& input) { return !input; }
  static void SetToNull(::cast_streaming::mojom::VideoStreamInfoPtr* output) { output->reset(); }

  static const decltype(::cast_streaming::mojom::VideoStreamInfo::decoder_config)& decoder_config(
      const ::cast_streaming::mojom::VideoStreamInfoPtr& input) {
    return input->decoder_config;
  }

  static  decltype(::cast_streaming::mojom::VideoStreamInfo::data_pipe)& data_pipe(
       ::cast_streaming::mojom::VideoStreamInfoPtr& input) {
    return input->data_pipe;
  }

  static bool Read(::cast_streaming::mojom::VideoStreamInfo::DataView input, ::cast_streaming::mojom::VideoStreamInfoPtr* output);
};


template <>
struct  StructTraits<::cast_streaming::mojom::AudioStreamInitializationInfo::DataView,
                                         ::cast_streaming::mojom::AudioStreamInitializationInfoPtr> {
  static bool IsNull(const ::cast_streaming::mojom::AudioStreamInitializationInfoPtr& input) { return !input; }
  static void SetToNull(::cast_streaming::mojom::AudioStreamInitializationInfoPtr* output) { output->reset(); }

  static  decltype(::cast_streaming::mojom::AudioStreamInitializationInfo::buffer_requester)& buffer_requester(
       ::cast_streaming::mojom::AudioStreamInitializationInfoPtr& input) {
    return input->buffer_requester;
  }

  static  decltype(::cast_streaming::mojom::AudioStreamInitializationInfo::stream_initialization_info)& stream_initialization_info(
       ::cast_streaming::mojom::AudioStreamInitializationInfoPtr& input) {
    return input->stream_initialization_info;
  }

  static bool Read(::cast_streaming::mojom::AudioStreamInitializationInfo::DataView input, ::cast_streaming::mojom::AudioStreamInitializationInfoPtr* output);
};


template <>
struct  StructTraits<::cast_streaming::mojom::VideoStreamInitializationInfo::DataView,
                                         ::cast_streaming::mojom::VideoStreamInitializationInfoPtr> {
  static bool IsNull(const ::cast_streaming::mojom::VideoStreamInitializationInfoPtr& input) { return !input; }
  static void SetToNull(::cast_streaming::mojom::VideoStreamInitializationInfoPtr* output) { output->reset(); }

  static  decltype(::cast_streaming::mojom::VideoStreamInitializationInfo::buffer_requester)& buffer_requester(
       ::cast_streaming::mojom::VideoStreamInitializationInfoPtr& input) {
    return input->buffer_requester;
  }

  static  decltype(::cast_streaming::mojom::VideoStreamInitializationInfo::stream_initialization_info)& stream_initialization_info(
       ::cast_streaming::mojom::VideoStreamInitializationInfoPtr& input) {
    return input->stream_initialization_info;
  }

  static bool Read(::cast_streaming::mojom::VideoStreamInitializationInfo::DataView input, ::cast_streaming::mojom::VideoStreamInitializationInfoPtr* output);
};


template <>
struct  UnionTraits<::cast_streaming::mojom::GetAudioBufferResponse::DataView,
                                        ::cast_streaming::mojom::GetAudioBufferResponsePtr> {
  static bool IsNull(const ::cast_streaming::mojom::GetAudioBufferResponsePtr& input) { return !input; }
  static void SetToNull(::cast_streaming::mojom::GetAudioBufferResponsePtr* output) { output->reset(); }

  static ::cast_streaming::mojom::GetAudioBufferResponse::Tag GetTag(const ::cast_streaming::mojom::GetAudioBufferResponsePtr& input) {
    return input->which();
  }

  static  ::cast_streaming::mojom::AudioStreamInfoPtr& stream_info( ::cast_streaming::mojom::GetAudioBufferResponsePtr& input) {
    return input->get_stream_info();
  }

  static const ::media::mojom::DecoderBufferPtr& buffer(const ::cast_streaming::mojom::GetAudioBufferResponsePtr& input) {
    return input->get_buffer();
  }

  static bool Read(::cast_streaming::mojom::GetAudioBufferResponse::DataView input, ::cast_streaming::mojom::GetAudioBufferResponsePtr* output);
};


template <>
struct  UnionTraits<::cast_streaming::mojom::GetVideoBufferResponse::DataView,
                                        ::cast_streaming::mojom::GetVideoBufferResponsePtr> {
  static bool IsNull(const ::cast_streaming::mojom::GetVideoBufferResponsePtr& input) { return !input; }
  static void SetToNull(::cast_streaming::mojom::GetVideoBufferResponsePtr* output) { output->reset(); }

  static ::cast_streaming::mojom::GetVideoBufferResponse::Tag GetTag(const ::cast_streaming::mojom::GetVideoBufferResponsePtr& input) {
    return input->which();
  }

  static  ::cast_streaming::mojom::VideoStreamInfoPtr& stream_info( ::cast_streaming::mojom::GetVideoBufferResponsePtr& input) {
    return input->get_stream_info();
  }

  static const ::media::mojom::DecoderBufferPtr& buffer(const ::cast_streaming::mojom::GetVideoBufferResponsePtr& input) {
    return input->get_buffer();
  }

  static bool Read(::cast_streaming::mojom::GetVideoBufferResponse::DataView input, ::cast_streaming::mojom::GetVideoBufferResponsePtr* output);
};

}  // namespace mojo

#endif  // COMPONENTS_CAST_STREAMING_PUBLIC_MOJOM_DEMUXER_CONNECTOR_MOJOM_H_