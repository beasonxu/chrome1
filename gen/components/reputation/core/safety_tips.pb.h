// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safety_tips.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_safety_5ftips_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_safety_5ftips_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_safety_5ftips_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_safety_5ftips_2eproto {
  static const uint32_t offsets[];
};
namespace reputation {
class Cohort;
struct CohortDefaultTypeInternal;
extern CohortDefaultTypeInternal _Cohort_default_instance_;
class FlaggedPage;
struct FlaggedPageDefaultTypeInternal;
extern FlaggedPageDefaultTypeInternal _FlaggedPage_default_instance_;
class HeuristicLaunchConfig;
struct HeuristicLaunchConfigDefaultTypeInternal;
extern HeuristicLaunchConfigDefaultTypeInternal _HeuristicLaunchConfig_default_instance_;
class HostPattern;
struct HostPatternDefaultTypeInternal;
extern HostPatternDefaultTypeInternal _HostPattern_default_instance_;
class SafetyTipsConfig;
struct SafetyTipsConfigDefaultTypeInternal;
extern SafetyTipsConfigDefaultTypeInternal _SafetyTipsConfig_default_instance_;
class UrlPattern;
struct UrlPatternDefaultTypeInternal;
extern UrlPatternDefaultTypeInternal _UrlPattern_default_instance_;
}  // namespace reputation
PROTOBUF_NAMESPACE_OPEN
template<> ::reputation::Cohort* Arena::CreateMaybeMessage<::reputation::Cohort>(Arena*);
template<> ::reputation::FlaggedPage* Arena::CreateMaybeMessage<::reputation::FlaggedPage>(Arena*);
template<> ::reputation::HeuristicLaunchConfig* Arena::CreateMaybeMessage<::reputation::HeuristicLaunchConfig>(Arena*);
template<> ::reputation::HostPattern* Arena::CreateMaybeMessage<::reputation::HostPattern>(Arena*);
template<> ::reputation::SafetyTipsConfig* Arena::CreateMaybeMessage<::reputation::SafetyTipsConfig>(Arena*);
template<> ::reputation::UrlPattern* Arena::CreateMaybeMessage<::reputation::UrlPattern>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace reputation {

enum FlaggedPage_FlagType : int {
  FlaggedPage_FlagType_UNKNOWN = 0,
  FlaggedPage_FlagType_BAD_REP = 1,
  FlaggedPage_FlagType_YOUNG_DOMAIN = 2
};
bool FlaggedPage_FlagType_IsValid(int value);
constexpr FlaggedPage_FlagType FlaggedPage_FlagType_FlagType_MIN = FlaggedPage_FlagType_UNKNOWN;
constexpr FlaggedPage_FlagType FlaggedPage_FlagType_FlagType_MAX = FlaggedPage_FlagType_YOUNG_DOMAIN;
constexpr int FlaggedPage_FlagType_FlagType_ARRAYSIZE = FlaggedPage_FlagType_FlagType_MAX + 1;

const std::string& FlaggedPage_FlagType_Name(FlaggedPage_FlagType value);
template<typename T>
inline const std::string& FlaggedPage_FlagType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlaggedPage_FlagType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlaggedPage_FlagType_Name.");
  return FlaggedPage_FlagType_Name(static_cast<FlaggedPage_FlagType>(enum_t_value));
}
bool FlaggedPage_FlagType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlaggedPage_FlagType* value);
enum HeuristicLaunchConfig_Heuristic : int {
  HeuristicLaunchConfig_Heuristic_HEURISTIC_UNKNOWN = 0,
  HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_ENGAGED_SITES = 1,
  HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_TOP_SITES = 2,
  HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_TOP_DOMAINS = 3,
  HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES = 4
};
bool HeuristicLaunchConfig_Heuristic_IsValid(int value);
constexpr HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig_Heuristic_Heuristic_MIN = HeuristicLaunchConfig_Heuristic_HEURISTIC_UNKNOWN;
constexpr HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig_Heuristic_Heuristic_MAX = HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES;
constexpr int HeuristicLaunchConfig_Heuristic_Heuristic_ARRAYSIZE = HeuristicLaunchConfig_Heuristic_Heuristic_MAX + 1;

const std::string& HeuristicLaunchConfig_Heuristic_Name(HeuristicLaunchConfig_Heuristic value);
template<typename T>
inline const std::string& HeuristicLaunchConfig_Heuristic_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HeuristicLaunchConfig_Heuristic>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HeuristicLaunchConfig_Heuristic_Name.");
  return HeuristicLaunchConfig_Heuristic_Name(static_cast<HeuristicLaunchConfig_Heuristic>(enum_t_value));
}
bool HeuristicLaunchConfig_Heuristic_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeuristicLaunchConfig_Heuristic* value);
// ===================================================================

class FlaggedPage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.FlaggedPage) */ {
 public:
  inline FlaggedPage() : FlaggedPage(nullptr) {}
  ~FlaggedPage() override;
  explicit PROTOBUF_CONSTEXPR FlaggedPage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlaggedPage(const FlaggedPage& from);
  FlaggedPage(FlaggedPage&& from) noexcept
    : FlaggedPage() {
    *this = ::std::move(from);
  }

  inline FlaggedPage& operator=(const FlaggedPage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlaggedPage& operator=(FlaggedPage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FlaggedPage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlaggedPage* internal_default_instance() {
    return reinterpret_cast<const FlaggedPage*>(
               &_FlaggedPage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FlaggedPage& a, FlaggedPage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FlaggedPage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlaggedPage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlaggedPage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlaggedPage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FlaggedPage& from);
  void MergeFrom(const FlaggedPage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlaggedPage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reputation.FlaggedPage";
  }
  protected:
  explicit FlaggedPage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef FlaggedPage_FlagType FlagType;
  static constexpr FlagType UNKNOWN =
    FlaggedPage_FlagType_UNKNOWN;
  static constexpr FlagType BAD_REP =
    FlaggedPage_FlagType_BAD_REP;
  static constexpr FlagType YOUNG_DOMAIN =
    FlaggedPage_FlagType_YOUNG_DOMAIN;
  static inline bool FlagType_IsValid(int value) {
    return FlaggedPage_FlagType_IsValid(value);
  }
  static constexpr FlagType FlagType_MIN =
    FlaggedPage_FlagType_FlagType_MIN;
  static constexpr FlagType FlagType_MAX =
    FlaggedPage_FlagType_FlagType_MAX;
  static constexpr int FlagType_ARRAYSIZE =
    FlaggedPage_FlagType_FlagType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FlagType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlagType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlagType_Name.");
    return FlaggedPage_FlagType_Name(enum_t_value);
  }
  static inline bool FlagType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FlagType* value) {
    return FlaggedPage_FlagType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string pattern = 1;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const std::string& pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* pattern);
  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
  std::string* _internal_mutable_pattern();
  public:

  // optional .reputation.FlaggedPage.FlagType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::reputation::FlaggedPage_FlagType type() const;
  void set_type(::reputation::FlaggedPage_FlagType value);
  private:
  ::reputation::FlaggedPage_FlagType _internal_type() const;
  void _internal_set_type(::reputation::FlaggedPage_FlagType value);
  public:

  // @@protoc_insertion_point(class_scope:reputation.FlaggedPage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
  int type_;
  friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class UrlPattern final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.UrlPattern) */ {
 public:
  inline UrlPattern() : UrlPattern(nullptr) {}
  ~UrlPattern() override;
  explicit PROTOBUF_CONSTEXPR UrlPattern(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UrlPattern(const UrlPattern& from);
  UrlPattern(UrlPattern&& from) noexcept
    : UrlPattern() {
    *this = ::std::move(from);
  }

  inline UrlPattern& operator=(const UrlPattern& from) {
    CopyFrom(from);
    return *this;
  }
  inline UrlPattern& operator=(UrlPattern&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UrlPattern& default_instance() {
    return *internal_default_instance();
  }
  static inline const UrlPattern* internal_default_instance() {
    return reinterpret_cast<const UrlPattern*>(
               &_UrlPattern_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UrlPattern& a, UrlPattern& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UrlPattern* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UrlPattern* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UrlPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UrlPattern>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UrlPattern& from);
  void MergeFrom(const UrlPattern& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UrlPattern* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reputation.UrlPattern";
  }
  protected:
  explicit UrlPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCohortIndexFieldNumber = 2,
    kPatternFieldNumber = 1,
  };
  // repeated uint32 cohort_index = 2 [packed = true];
  int cohort_index_size() const;
  private:
  int _internal_cohort_index_size() const;
  public:
  void clear_cohort_index();
  private:
  uint32_t _internal_cohort_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_cohort_index() const;
  void _internal_add_cohort_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_cohort_index();
  public:
  uint32_t cohort_index(int index) const;
  void set_cohort_index(int index, uint32_t value);
  void add_cohort_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      cohort_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_cohort_index();

  // optional string pattern = 1;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const std::string& pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* pattern);
  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
  std::string* _internal_mutable_pattern();
  public:

  // @@protoc_insertion_point(class_scope:reputation.UrlPattern)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > cohort_index_;
  mutable std::atomic<int> _cohort_index_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
  friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class HostPattern final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.HostPattern) */ {
 public:
  inline HostPattern() : HostPattern(nullptr) {}
  ~HostPattern() override;
  explicit PROTOBUF_CONSTEXPR HostPattern(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostPattern(const HostPattern& from);
  HostPattern(HostPattern&& from) noexcept
    : HostPattern() {
    *this = ::std::move(from);
  }

  inline HostPattern& operator=(const HostPattern& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostPattern& operator=(HostPattern&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HostPattern& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostPattern* internal_default_instance() {
    return reinterpret_cast<const HostPattern*>(
               &_HostPattern_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HostPattern& a, HostPattern& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(HostPattern* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostPattern* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostPattern>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostPattern& from);
  void MergeFrom(const HostPattern& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostPattern* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reputation.HostPattern";
  }
  protected:
  explicit HostPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegexFieldNumber = 1,
  };
  // optional string regex = 1;
  bool has_regex() const;
  private:
  bool _internal_has_regex() const;
  public:
  void clear_regex();
  const std::string& regex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regex();
  PROTOBUF_NODISCARD std::string* release_regex();
  void set_allocated_regex(std::string* regex);
  private:
  const std::string& _internal_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regex(const std::string& value);
  std::string* _internal_mutable_regex();
  public:

  // @@protoc_insertion_point(class_scope:reputation.HostPattern)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regex_;
  friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class HeuristicLaunchConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.HeuristicLaunchConfig) */ {
 public:
  inline HeuristicLaunchConfig() : HeuristicLaunchConfig(nullptr) {}
  ~HeuristicLaunchConfig() override;
  explicit PROTOBUF_CONSTEXPR HeuristicLaunchConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeuristicLaunchConfig(const HeuristicLaunchConfig& from);
  HeuristicLaunchConfig(HeuristicLaunchConfig&& from) noexcept
    : HeuristicLaunchConfig() {
    *this = ::std::move(from);
  }

  inline HeuristicLaunchConfig& operator=(const HeuristicLaunchConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeuristicLaunchConfig& operator=(HeuristicLaunchConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HeuristicLaunchConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeuristicLaunchConfig* internal_default_instance() {
    return reinterpret_cast<const HeuristicLaunchConfig*>(
               &_HeuristicLaunchConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HeuristicLaunchConfig& a, HeuristicLaunchConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(HeuristicLaunchConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeuristicLaunchConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeuristicLaunchConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeuristicLaunchConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HeuristicLaunchConfig& from);
  void MergeFrom(const HeuristicLaunchConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeuristicLaunchConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reputation.HeuristicLaunchConfig";
  }
  protected:
  explicit HeuristicLaunchConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef HeuristicLaunchConfig_Heuristic Heuristic;
  static constexpr Heuristic HEURISTIC_UNKNOWN =
    HeuristicLaunchConfig_Heuristic_HEURISTIC_UNKNOWN;
  static constexpr Heuristic HEURISTIC_CHARACTER_SWAP_ENGAGED_SITES =
    HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_ENGAGED_SITES;
  static constexpr Heuristic HEURISTIC_CHARACTER_SWAP_TOP_SITES =
    HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_TOP_SITES;
  static constexpr Heuristic HEURISTIC_COMBO_SQUATTING_TOP_DOMAINS =
    HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_TOP_DOMAINS;
  static constexpr Heuristic HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES =
    HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES;
  static inline bool Heuristic_IsValid(int value) {
    return HeuristicLaunchConfig_Heuristic_IsValid(value);
  }
  static constexpr Heuristic Heuristic_MIN =
    HeuristicLaunchConfig_Heuristic_Heuristic_MIN;
  static constexpr Heuristic Heuristic_MAX =
    HeuristicLaunchConfig_Heuristic_Heuristic_MAX;
  static constexpr int Heuristic_ARRAYSIZE =
    HeuristicLaunchConfig_Heuristic_Heuristic_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Heuristic_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Heuristic>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Heuristic_Name.");
    return HeuristicLaunchConfig_Heuristic_Name(enum_t_value);
  }
  static inline bool Heuristic_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Heuristic* value) {
    return HeuristicLaunchConfig_Heuristic_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeuristicFieldNumber = 1,
    kLaunchPercentageFieldNumber = 2,
  };
  // optional .reputation.HeuristicLaunchConfig.Heuristic heuristic = 1;
  bool has_heuristic() const;
  private:
  bool _internal_has_heuristic() const;
  public:
  void clear_heuristic();
  ::reputation::HeuristicLaunchConfig_Heuristic heuristic() const;
  void set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value);
  private:
  ::reputation::HeuristicLaunchConfig_Heuristic _internal_heuristic() const;
  void _internal_set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value);
  public:

  // optional uint32 launch_percentage = 2;
  bool has_launch_percentage() const;
  private:
  bool _internal_has_launch_percentage() const;
  public:
  void clear_launch_percentage();
  uint32_t launch_percentage() const;
  void set_launch_percentage(uint32_t value);
  private:
  uint32_t _internal_launch_percentage() const;
  void _internal_set_launch_percentage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:reputation.HeuristicLaunchConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int heuristic_;
  uint32_t launch_percentage_;
  friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class Cohort final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.Cohort) */ {
 public:
  inline Cohort() : Cohort(nullptr) {}
  ~Cohort() override;
  explicit PROTOBUF_CONSTEXPR Cohort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cohort(const Cohort& from);
  Cohort(Cohort&& from) noexcept
    : Cohort() {
    *this = ::std::move(from);
  }

  inline Cohort& operator=(const Cohort& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cohort& operator=(Cohort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Cohort& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cohort* internal_default_instance() {
    return reinterpret_cast<const Cohort*>(
               &_Cohort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Cohort& a, Cohort& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Cohort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cohort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cohort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cohort>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Cohort& from);
  void MergeFrom(const Cohort& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Cohort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reputation.Cohort";
  }
  protected:
  explicit Cohort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedIndexFieldNumber = 1,
    kCanonicalIndexFieldNumber = 2,
  };
  // repeated uint32 allowed_index = 1 [packed = true];
  int allowed_index_size() const;
  private:
  int _internal_allowed_index_size() const;
  public:
  void clear_allowed_index();
  private:
  uint32_t _internal_allowed_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_allowed_index() const;
  void _internal_add_allowed_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_allowed_index();
  public:
  uint32_t allowed_index(int index) const;
  void set_allowed_index(int index, uint32_t value);
  void add_allowed_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      allowed_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_allowed_index();

  // repeated uint32 canonical_index = 2 [packed = true];
  int canonical_index_size() const;
  private:
  int _internal_canonical_index_size() const;
  public:
  void clear_canonical_index();
  private:
  uint32_t _internal_canonical_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_canonical_index() const;
  void _internal_add_canonical_index(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_canonical_index();
  public:
  uint32_t canonical_index(int index) const;
  void set_canonical_index(int index, uint32_t value);
  void add_canonical_index(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      canonical_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_canonical_index();

  // @@protoc_insertion_point(class_scope:reputation.Cohort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > allowed_index_;
  mutable std::atomic<int> _allowed_index_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > canonical_index_;
  mutable std::atomic<int> _canonical_index_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class SafetyTipsConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.SafetyTipsConfig) */ {
 public:
  inline SafetyTipsConfig() : SafetyTipsConfig(nullptr) {}
  ~SafetyTipsConfig() override;
  explicit PROTOBUF_CONSTEXPR SafetyTipsConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SafetyTipsConfig(const SafetyTipsConfig& from);
  SafetyTipsConfig(SafetyTipsConfig&& from) noexcept
    : SafetyTipsConfig() {
    *this = ::std::move(from);
  }

  inline SafetyTipsConfig& operator=(const SafetyTipsConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SafetyTipsConfig& operator=(SafetyTipsConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SafetyTipsConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SafetyTipsConfig* internal_default_instance() {
    return reinterpret_cast<const SafetyTipsConfig*>(
               &_SafetyTipsConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SafetyTipsConfig& a, SafetyTipsConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SafetyTipsConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SafetyTipsConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SafetyTipsConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SafetyTipsConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SafetyTipsConfig& from);
  void MergeFrom(const SafetyTipsConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SafetyTipsConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reputation.SafetyTipsConfig";
  }
  protected:
  explicit SafetyTipsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlaggedPageFieldNumber = 2,
    kAllowedPatternFieldNumber = 3,
    kAllowedTargetPatternFieldNumber = 4,
    kCommonWordFieldNumber = 5,
    kLaunchConfigFieldNumber = 6,
    kCanonicalPatternFieldNumber = 7,
    kCohortFieldNumber = 8,
    kVersionIdFieldNumber = 1,
  };
  // repeated .reputation.FlaggedPage flagged_page = 2;
  int flagged_page_size() const;
  private:
  int _internal_flagged_page_size() const;
  public:
  void clear_flagged_page();
  ::reputation::FlaggedPage* mutable_flagged_page(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::FlaggedPage >*
      mutable_flagged_page();
  private:
  const ::reputation::FlaggedPage& _internal_flagged_page(int index) const;
  ::reputation::FlaggedPage* _internal_add_flagged_page();
  public:
  const ::reputation::FlaggedPage& flagged_page(int index) const;
  ::reputation::FlaggedPage* add_flagged_page();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::FlaggedPage >&
      flagged_page() const;

  // repeated .reputation.UrlPattern allowed_pattern = 3;
  int allowed_pattern_size() const;
  private:
  int _internal_allowed_pattern_size() const;
  public:
  void clear_allowed_pattern();
  ::reputation::UrlPattern* mutable_allowed_pattern(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >*
      mutable_allowed_pattern();
  private:
  const ::reputation::UrlPattern& _internal_allowed_pattern(int index) const;
  ::reputation::UrlPattern* _internal_add_allowed_pattern();
  public:
  const ::reputation::UrlPattern& allowed_pattern(int index) const;
  ::reputation::UrlPattern* add_allowed_pattern();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >&
      allowed_pattern() const;

  // repeated .reputation.HostPattern allowed_target_pattern = 4;
  int allowed_target_pattern_size() const;
  private:
  int _internal_allowed_target_pattern_size() const;
  public:
  void clear_allowed_target_pattern();
  ::reputation::HostPattern* mutable_allowed_target_pattern(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HostPattern >*
      mutable_allowed_target_pattern();
  private:
  const ::reputation::HostPattern& _internal_allowed_target_pattern(int index) const;
  ::reputation::HostPattern* _internal_add_allowed_target_pattern();
  public:
  const ::reputation::HostPattern& allowed_target_pattern(int index) const;
  ::reputation::HostPattern* add_allowed_target_pattern();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HostPattern >&
      allowed_target_pattern() const;

  // repeated string common_word = 5;
  int common_word_size() const;
  private:
  int _internal_common_word_size() const;
  public:
  void clear_common_word();
  const std::string& common_word(int index) const;
  std::string* mutable_common_word(int index);
  void set_common_word(int index, const std::string& value);
  void set_common_word(int index, std::string&& value);
  void set_common_word(int index, const char* value);
  void set_common_word(int index, const char* value, size_t size);
  std::string* add_common_word();
  void add_common_word(const std::string& value);
  void add_common_word(std::string&& value);
  void add_common_word(const char* value);
  void add_common_word(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& common_word() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_common_word();
  private:
  const std::string& _internal_common_word(int index) const;
  std::string* _internal_add_common_word();
  public:

  // repeated .reputation.HeuristicLaunchConfig launch_config = 6;
  int launch_config_size() const;
  private:
  int _internal_launch_config_size() const;
  public:
  void clear_launch_config();
  ::reputation::HeuristicLaunchConfig* mutable_launch_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HeuristicLaunchConfig >*
      mutable_launch_config();
  private:
  const ::reputation::HeuristicLaunchConfig& _internal_launch_config(int index) const;
  ::reputation::HeuristicLaunchConfig* _internal_add_launch_config();
  public:
  const ::reputation::HeuristicLaunchConfig& launch_config(int index) const;
  ::reputation::HeuristicLaunchConfig* add_launch_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HeuristicLaunchConfig >&
      launch_config() const;

  // repeated .reputation.UrlPattern canonical_pattern = 7;
  int canonical_pattern_size() const;
  private:
  int _internal_canonical_pattern_size() const;
  public:
  void clear_canonical_pattern();
  ::reputation::UrlPattern* mutable_canonical_pattern(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >*
      mutable_canonical_pattern();
  private:
  const ::reputation::UrlPattern& _internal_canonical_pattern(int index) const;
  ::reputation::UrlPattern* _internal_add_canonical_pattern();
  public:
  const ::reputation::UrlPattern& canonical_pattern(int index) const;
  ::reputation::UrlPattern* add_canonical_pattern();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >&
      canonical_pattern() const;

  // repeated .reputation.Cohort cohort = 8;
  int cohort_size() const;
  private:
  int _internal_cohort_size() const;
  public:
  void clear_cohort();
  ::reputation::Cohort* mutable_cohort(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::Cohort >*
      mutable_cohort();
  private:
  const ::reputation::Cohort& _internal_cohort(int index) const;
  ::reputation::Cohort* _internal_add_cohort();
  public:
  const ::reputation::Cohort& cohort(int index) const;
  ::reputation::Cohort* add_cohort();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::Cohort >&
      cohort() const;

  // optional uint32 version_id = 1;
  bool has_version_id() const;
  private:
  bool _internal_has_version_id() const;
  public:
  void clear_version_id();
  uint32_t version_id() const;
  void set_version_id(uint32_t value);
  private:
  uint32_t _internal_version_id() const;
  void _internal_set_version_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:reputation.SafetyTipsConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::FlaggedPage > flagged_page_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern > allowed_pattern_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HostPattern > allowed_target_pattern_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> common_word_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HeuristicLaunchConfig > launch_config_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern > canonical_pattern_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::Cohort > cohort_;
  uint32_t version_id_;
  friend struct ::TableStruct_safety_5ftips_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FlaggedPage

// optional string pattern = 1;
inline bool FlaggedPage::_internal_has_pattern() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlaggedPage::has_pattern() const {
  return _internal_has_pattern();
}
inline void FlaggedPage::clear_pattern() {
  pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlaggedPage::pattern() const {
  // @@protoc_insertion_point(field_get:reputation.FlaggedPage.pattern)
  return _internal_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlaggedPage::set_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:reputation.FlaggedPage.pattern)
}
inline std::string* FlaggedPage::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:reputation.FlaggedPage.pattern)
  return _s;
}
inline const std::string& FlaggedPage::_internal_pattern() const {
  return pattern_.Get();
}
inline void FlaggedPage::_internal_set_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* FlaggedPage::_internal_mutable_pattern() {
  _has_bits_[0] |= 0x00000001u;
  return pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* FlaggedPage::release_pattern() {
  // @@protoc_insertion_point(field_release:reputation.FlaggedPage.pattern)
  if (!_internal_has_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pattern_.IsDefault()) {
    pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FlaggedPage::set_allocated_pattern(std::string* pattern) {
  if (pattern != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pattern_.IsDefault()) {
    pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:reputation.FlaggedPage.pattern)
}

// optional .reputation.FlaggedPage.FlagType type = 2;
inline bool FlaggedPage::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FlaggedPage::has_type() const {
  return _internal_has_type();
}
inline void FlaggedPage::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::reputation::FlaggedPage_FlagType FlaggedPage::_internal_type() const {
  return static_cast< ::reputation::FlaggedPage_FlagType >(type_);
}
inline ::reputation::FlaggedPage_FlagType FlaggedPage::type() const {
  // @@protoc_insertion_point(field_get:reputation.FlaggedPage.type)
  return _internal_type();
}
inline void FlaggedPage::_internal_set_type(::reputation::FlaggedPage_FlagType value) {
  assert(::reputation::FlaggedPage_FlagType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void FlaggedPage::set_type(::reputation::FlaggedPage_FlagType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:reputation.FlaggedPage.type)
}

// -------------------------------------------------------------------

// UrlPattern

// optional string pattern = 1;
inline bool UrlPattern::_internal_has_pattern() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UrlPattern::has_pattern() const {
  return _internal_has_pattern();
}
inline void UrlPattern::clear_pattern() {
  pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UrlPattern::pattern() const {
  // @@protoc_insertion_point(field_get:reputation.UrlPattern.pattern)
  return _internal_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UrlPattern::set_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:reputation.UrlPattern.pattern)
}
inline std::string* UrlPattern::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:reputation.UrlPattern.pattern)
  return _s;
}
inline const std::string& UrlPattern::_internal_pattern() const {
  return pattern_.Get();
}
inline void UrlPattern::_internal_set_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* UrlPattern::_internal_mutable_pattern() {
  _has_bits_[0] |= 0x00000001u;
  return pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* UrlPattern::release_pattern() {
  // @@protoc_insertion_point(field_release:reputation.UrlPattern.pattern)
  if (!_internal_has_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pattern_.IsDefault()) {
    pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UrlPattern::set_allocated_pattern(std::string* pattern) {
  if (pattern != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pattern_.IsDefault()) {
    pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:reputation.UrlPattern.pattern)
}

// repeated uint32 cohort_index = 2 [packed = true];
inline int UrlPattern::_internal_cohort_index_size() const {
  return cohort_index_.size();
}
inline int UrlPattern::cohort_index_size() const {
  return _internal_cohort_index_size();
}
inline void UrlPattern::clear_cohort_index() {
  cohort_index_.Clear();
}
inline uint32_t UrlPattern::_internal_cohort_index(int index) const {
  return cohort_index_.Get(index);
}
inline uint32_t UrlPattern::cohort_index(int index) const {
  // @@protoc_insertion_point(field_get:reputation.UrlPattern.cohort_index)
  return _internal_cohort_index(index);
}
inline void UrlPattern::set_cohort_index(int index, uint32_t value) {
  cohort_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:reputation.UrlPattern.cohort_index)
}
inline void UrlPattern::_internal_add_cohort_index(uint32_t value) {
  cohort_index_.Add(value);
}
inline void UrlPattern::add_cohort_index(uint32_t value) {
  _internal_add_cohort_index(value);
  // @@protoc_insertion_point(field_add:reputation.UrlPattern.cohort_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UrlPattern::_internal_cohort_index() const {
  return cohort_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UrlPattern::cohort_index() const {
  // @@protoc_insertion_point(field_list:reputation.UrlPattern.cohort_index)
  return _internal_cohort_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UrlPattern::_internal_mutable_cohort_index() {
  return &cohort_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UrlPattern::mutable_cohort_index() {
  // @@protoc_insertion_point(field_mutable_list:reputation.UrlPattern.cohort_index)
  return _internal_mutable_cohort_index();
}

// -------------------------------------------------------------------

// HostPattern

// optional string regex = 1;
inline bool HostPattern::_internal_has_regex() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HostPattern::has_regex() const {
  return _internal_has_regex();
}
inline void HostPattern::clear_regex() {
  regex_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HostPattern::regex() const {
  // @@protoc_insertion_point(field_get:reputation.HostPattern.regex)
  return _internal_regex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostPattern::set_regex(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 regex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:reputation.HostPattern.regex)
}
inline std::string* HostPattern::mutable_regex() {
  std::string* _s = _internal_mutable_regex();
  // @@protoc_insertion_point(field_mutable:reputation.HostPattern.regex)
  return _s;
}
inline const std::string& HostPattern::_internal_regex() const {
  return regex_.Get();
}
inline void HostPattern::_internal_set_regex(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  regex_.Set(value, GetArenaForAllocation());
}
inline std::string* HostPattern::_internal_mutable_regex() {
  _has_bits_[0] |= 0x00000001u;
  return regex_.Mutable(GetArenaForAllocation());
}
inline std::string* HostPattern::release_regex() {
  // @@protoc_insertion_point(field_release:reputation.HostPattern.regex)
  if (!_internal_has_regex()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = regex_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regex_.IsDefault()) {
    regex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HostPattern::set_allocated_regex(std::string* regex) {
  if (regex != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  regex_.SetAllocated(regex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regex_.IsDefault()) {
    regex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:reputation.HostPattern.regex)
}

// -------------------------------------------------------------------

// HeuristicLaunchConfig

// optional .reputation.HeuristicLaunchConfig.Heuristic heuristic = 1;
inline bool HeuristicLaunchConfig::_internal_has_heuristic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeuristicLaunchConfig::has_heuristic() const {
  return _internal_has_heuristic();
}
inline void HeuristicLaunchConfig::clear_heuristic() {
  heuristic_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::reputation::HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig::_internal_heuristic() const {
  return static_cast< ::reputation::HeuristicLaunchConfig_Heuristic >(heuristic_);
}
inline ::reputation::HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig::heuristic() const {
  // @@protoc_insertion_point(field_get:reputation.HeuristicLaunchConfig.heuristic)
  return _internal_heuristic();
}
inline void HeuristicLaunchConfig::_internal_set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value) {
  assert(::reputation::HeuristicLaunchConfig_Heuristic_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  heuristic_ = value;
}
inline void HeuristicLaunchConfig::set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value) {
  _internal_set_heuristic(value);
  // @@protoc_insertion_point(field_set:reputation.HeuristicLaunchConfig.heuristic)
}

// optional uint32 launch_percentage = 2;
inline bool HeuristicLaunchConfig::_internal_has_launch_percentage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HeuristicLaunchConfig::has_launch_percentage() const {
  return _internal_has_launch_percentage();
}
inline void HeuristicLaunchConfig::clear_launch_percentage() {
  launch_percentage_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t HeuristicLaunchConfig::_internal_launch_percentage() const {
  return launch_percentage_;
}
inline uint32_t HeuristicLaunchConfig::launch_percentage() const {
  // @@protoc_insertion_point(field_get:reputation.HeuristicLaunchConfig.launch_percentage)
  return _internal_launch_percentage();
}
inline void HeuristicLaunchConfig::_internal_set_launch_percentage(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  launch_percentage_ = value;
}
inline void HeuristicLaunchConfig::set_launch_percentage(uint32_t value) {
  _internal_set_launch_percentage(value);
  // @@protoc_insertion_point(field_set:reputation.HeuristicLaunchConfig.launch_percentage)
}

// -------------------------------------------------------------------

// Cohort

// repeated uint32 allowed_index = 1 [packed = true];
inline int Cohort::_internal_allowed_index_size() const {
  return allowed_index_.size();
}
inline int Cohort::allowed_index_size() const {
  return _internal_allowed_index_size();
}
inline void Cohort::clear_allowed_index() {
  allowed_index_.Clear();
}
inline uint32_t Cohort::_internal_allowed_index(int index) const {
  return allowed_index_.Get(index);
}
inline uint32_t Cohort::allowed_index(int index) const {
  // @@protoc_insertion_point(field_get:reputation.Cohort.allowed_index)
  return _internal_allowed_index(index);
}
inline void Cohort::set_allowed_index(int index, uint32_t value) {
  allowed_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:reputation.Cohort.allowed_index)
}
inline void Cohort::_internal_add_allowed_index(uint32_t value) {
  allowed_index_.Add(value);
}
inline void Cohort::add_allowed_index(uint32_t value) {
  _internal_add_allowed_index(value);
  // @@protoc_insertion_point(field_add:reputation.Cohort.allowed_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Cohort::_internal_allowed_index() const {
  return allowed_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Cohort::allowed_index() const {
  // @@protoc_insertion_point(field_list:reputation.Cohort.allowed_index)
  return _internal_allowed_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Cohort::_internal_mutable_allowed_index() {
  return &allowed_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Cohort::mutable_allowed_index() {
  // @@protoc_insertion_point(field_mutable_list:reputation.Cohort.allowed_index)
  return _internal_mutable_allowed_index();
}

// repeated uint32 canonical_index = 2 [packed = true];
inline int Cohort::_internal_canonical_index_size() const {
  return canonical_index_.size();
}
inline int Cohort::canonical_index_size() const {
  return _internal_canonical_index_size();
}
inline void Cohort::clear_canonical_index() {
  canonical_index_.Clear();
}
inline uint32_t Cohort::_internal_canonical_index(int index) const {
  return canonical_index_.Get(index);
}
inline uint32_t Cohort::canonical_index(int index) const {
  // @@protoc_insertion_point(field_get:reputation.Cohort.canonical_index)
  return _internal_canonical_index(index);
}
inline void Cohort::set_canonical_index(int index, uint32_t value) {
  canonical_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:reputation.Cohort.canonical_index)
}
inline void Cohort::_internal_add_canonical_index(uint32_t value) {
  canonical_index_.Add(value);
}
inline void Cohort::add_canonical_index(uint32_t value) {
  _internal_add_canonical_index(value);
  // @@protoc_insertion_point(field_add:reputation.Cohort.canonical_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Cohort::_internal_canonical_index() const {
  return canonical_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Cohort::canonical_index() const {
  // @@protoc_insertion_point(field_list:reputation.Cohort.canonical_index)
  return _internal_canonical_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Cohort::_internal_mutable_canonical_index() {
  return &canonical_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Cohort::mutable_canonical_index() {
  // @@protoc_insertion_point(field_mutable_list:reputation.Cohort.canonical_index)
  return _internal_mutable_canonical_index();
}

// -------------------------------------------------------------------

// SafetyTipsConfig

// optional uint32 version_id = 1;
inline bool SafetyTipsConfig::_internal_has_version_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SafetyTipsConfig::has_version_id() const {
  return _internal_has_version_id();
}
inline void SafetyTipsConfig::clear_version_id() {
  version_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SafetyTipsConfig::_internal_version_id() const {
  return version_id_;
}
inline uint32_t SafetyTipsConfig::version_id() const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.version_id)
  return _internal_version_id();
}
inline void SafetyTipsConfig::_internal_set_version_id(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  version_id_ = value;
}
inline void SafetyTipsConfig::set_version_id(uint32_t value) {
  _internal_set_version_id(value);
  // @@protoc_insertion_point(field_set:reputation.SafetyTipsConfig.version_id)
}

// repeated .reputation.FlaggedPage flagged_page = 2;
inline int SafetyTipsConfig::_internal_flagged_page_size() const {
  return flagged_page_.size();
}
inline int SafetyTipsConfig::flagged_page_size() const {
  return _internal_flagged_page_size();
}
inline void SafetyTipsConfig::clear_flagged_page() {
  flagged_page_.Clear();
}
inline ::reputation::FlaggedPage* SafetyTipsConfig::mutable_flagged_page(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.flagged_page)
  return flagged_page_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::FlaggedPage >*
SafetyTipsConfig::mutable_flagged_page() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.flagged_page)
  return &flagged_page_;
}
inline const ::reputation::FlaggedPage& SafetyTipsConfig::_internal_flagged_page(int index) const {
  return flagged_page_.Get(index);
}
inline const ::reputation::FlaggedPage& SafetyTipsConfig::flagged_page(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.flagged_page)
  return _internal_flagged_page(index);
}
inline ::reputation::FlaggedPage* SafetyTipsConfig::_internal_add_flagged_page() {
  return flagged_page_.Add();
}
inline ::reputation::FlaggedPage* SafetyTipsConfig::add_flagged_page() {
  ::reputation::FlaggedPage* _add = _internal_add_flagged_page();
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.flagged_page)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::FlaggedPage >&
SafetyTipsConfig::flagged_page() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.flagged_page)
  return flagged_page_;
}

// repeated .reputation.UrlPattern allowed_pattern = 3;
inline int SafetyTipsConfig::_internal_allowed_pattern_size() const {
  return allowed_pattern_.size();
}
inline int SafetyTipsConfig::allowed_pattern_size() const {
  return _internal_allowed_pattern_size();
}
inline void SafetyTipsConfig::clear_allowed_pattern() {
  allowed_pattern_.Clear();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::mutable_allowed_pattern(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.allowed_pattern)
  return allowed_pattern_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >*
SafetyTipsConfig::mutable_allowed_pattern() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.allowed_pattern)
  return &allowed_pattern_;
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::_internal_allowed_pattern(int index) const {
  return allowed_pattern_.Get(index);
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::allowed_pattern(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.allowed_pattern)
  return _internal_allowed_pattern(index);
}
inline ::reputation::UrlPattern* SafetyTipsConfig::_internal_add_allowed_pattern() {
  return allowed_pattern_.Add();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::add_allowed_pattern() {
  ::reputation::UrlPattern* _add = _internal_add_allowed_pattern();
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.allowed_pattern)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >&
SafetyTipsConfig::allowed_pattern() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.allowed_pattern)
  return allowed_pattern_;
}

// repeated .reputation.HostPattern allowed_target_pattern = 4;
inline int SafetyTipsConfig::_internal_allowed_target_pattern_size() const {
  return allowed_target_pattern_.size();
}
inline int SafetyTipsConfig::allowed_target_pattern_size() const {
  return _internal_allowed_target_pattern_size();
}
inline void SafetyTipsConfig::clear_allowed_target_pattern() {
  allowed_target_pattern_.Clear();
}
inline ::reputation::HostPattern* SafetyTipsConfig::mutable_allowed_target_pattern(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.allowed_target_pattern)
  return allowed_target_pattern_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HostPattern >*
SafetyTipsConfig::mutable_allowed_target_pattern() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.allowed_target_pattern)
  return &allowed_target_pattern_;
}
inline const ::reputation::HostPattern& SafetyTipsConfig::_internal_allowed_target_pattern(int index) const {
  return allowed_target_pattern_.Get(index);
}
inline const ::reputation::HostPattern& SafetyTipsConfig::allowed_target_pattern(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.allowed_target_pattern)
  return _internal_allowed_target_pattern(index);
}
inline ::reputation::HostPattern* SafetyTipsConfig::_internal_add_allowed_target_pattern() {
  return allowed_target_pattern_.Add();
}
inline ::reputation::HostPattern* SafetyTipsConfig::add_allowed_target_pattern() {
  ::reputation::HostPattern* _add = _internal_add_allowed_target_pattern();
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.allowed_target_pattern)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HostPattern >&
SafetyTipsConfig::allowed_target_pattern() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.allowed_target_pattern)
  return allowed_target_pattern_;
}

// repeated string common_word = 5;
inline int SafetyTipsConfig::_internal_common_word_size() const {
  return common_word_.size();
}
inline int SafetyTipsConfig::common_word_size() const {
  return _internal_common_word_size();
}
inline void SafetyTipsConfig::clear_common_word() {
  common_word_.Clear();
}
inline std::string* SafetyTipsConfig::add_common_word() {
  std::string* _s = _internal_add_common_word();
  // @@protoc_insertion_point(field_add_mutable:reputation.SafetyTipsConfig.common_word)
  return _s;
}
inline const std::string& SafetyTipsConfig::_internal_common_word(int index) const {
  return common_word_.Get(index);
}
inline const std::string& SafetyTipsConfig::common_word(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.common_word)
  return _internal_common_word(index);
}
inline std::string* SafetyTipsConfig::mutable_common_word(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.common_word)
  return common_word_.Mutable(index);
}
inline void SafetyTipsConfig::set_common_word(int index, const std::string& value) {
  common_word_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::set_common_word(int index, std::string&& value) {
  common_word_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::set_common_word(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  common_word_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::set_common_word(int index, const char* value, size_t size) {
  common_word_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:reputation.SafetyTipsConfig.common_word)
}
inline std::string* SafetyTipsConfig::_internal_add_common_word() {
  return common_word_.Add();
}
inline void SafetyTipsConfig::add_common_word(const std::string& value) {
  common_word_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::add_common_word(std::string&& value) {
  common_word_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::add_common_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  common_word_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::add_common_word(const char* value, size_t size) {
  common_word_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:reputation.SafetyTipsConfig.common_word)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SafetyTipsConfig::common_word() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.common_word)
  return common_word_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SafetyTipsConfig::mutable_common_word() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.common_word)
  return &common_word_;
}

// repeated .reputation.HeuristicLaunchConfig launch_config = 6;
inline int SafetyTipsConfig::_internal_launch_config_size() const {
  return launch_config_.size();
}
inline int SafetyTipsConfig::launch_config_size() const {
  return _internal_launch_config_size();
}
inline void SafetyTipsConfig::clear_launch_config() {
  launch_config_.Clear();
}
inline ::reputation::HeuristicLaunchConfig* SafetyTipsConfig::mutable_launch_config(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.launch_config)
  return launch_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HeuristicLaunchConfig >*
SafetyTipsConfig::mutable_launch_config() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.launch_config)
  return &launch_config_;
}
inline const ::reputation::HeuristicLaunchConfig& SafetyTipsConfig::_internal_launch_config(int index) const {
  return launch_config_.Get(index);
}
inline const ::reputation::HeuristicLaunchConfig& SafetyTipsConfig::launch_config(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.launch_config)
  return _internal_launch_config(index);
}
inline ::reputation::HeuristicLaunchConfig* SafetyTipsConfig::_internal_add_launch_config() {
  return launch_config_.Add();
}
inline ::reputation::HeuristicLaunchConfig* SafetyTipsConfig::add_launch_config() {
  ::reputation::HeuristicLaunchConfig* _add = _internal_add_launch_config();
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.launch_config)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::HeuristicLaunchConfig >&
SafetyTipsConfig::launch_config() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.launch_config)
  return launch_config_;
}

// repeated .reputation.UrlPattern canonical_pattern = 7;
inline int SafetyTipsConfig::_internal_canonical_pattern_size() const {
  return canonical_pattern_.size();
}
inline int SafetyTipsConfig::canonical_pattern_size() const {
  return _internal_canonical_pattern_size();
}
inline void SafetyTipsConfig::clear_canonical_pattern() {
  canonical_pattern_.Clear();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::mutable_canonical_pattern(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.canonical_pattern)
  return canonical_pattern_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >*
SafetyTipsConfig::mutable_canonical_pattern() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.canonical_pattern)
  return &canonical_pattern_;
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::_internal_canonical_pattern(int index) const {
  return canonical_pattern_.Get(index);
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::canonical_pattern(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.canonical_pattern)
  return _internal_canonical_pattern(index);
}
inline ::reputation::UrlPattern* SafetyTipsConfig::_internal_add_canonical_pattern() {
  return canonical_pattern_.Add();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::add_canonical_pattern() {
  ::reputation::UrlPattern* _add = _internal_add_canonical_pattern();
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.canonical_pattern)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::UrlPattern >&
SafetyTipsConfig::canonical_pattern() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.canonical_pattern)
  return canonical_pattern_;
}

// repeated .reputation.Cohort cohort = 8;
inline int SafetyTipsConfig::_internal_cohort_size() const {
  return cohort_.size();
}
inline int SafetyTipsConfig::cohort_size() const {
  return _internal_cohort_size();
}
inline void SafetyTipsConfig::clear_cohort() {
  cohort_.Clear();
}
inline ::reputation::Cohort* SafetyTipsConfig::mutable_cohort(int index) {
  // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.cohort)
  return cohort_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::Cohort >*
SafetyTipsConfig::mutable_cohort() {
  // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.cohort)
  return &cohort_;
}
inline const ::reputation::Cohort& SafetyTipsConfig::_internal_cohort(int index) const {
  return cohort_.Get(index);
}
inline const ::reputation::Cohort& SafetyTipsConfig::cohort(int index) const {
  // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.cohort)
  return _internal_cohort(index);
}
inline ::reputation::Cohort* SafetyTipsConfig::_internal_add_cohort() {
  return cohort_.Add();
}
inline ::reputation::Cohort* SafetyTipsConfig::add_cohort() {
  ::reputation::Cohort* _add = _internal_add_cohort();
  // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.cohort)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reputation::Cohort >&
SafetyTipsConfig::cohort() const {
  // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.cohort)
  return cohort_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace reputation

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::reputation::FlaggedPage_FlagType> : ::std::true_type {};
template <> struct is_proto_enum< ::reputation::HeuristicLaunchConfig_Heuristic> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_safety_5ftips_2eproto
