// components/printing/common/print.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "components/printing/common/print.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/printing/common/print.mojom-params-data.h"
#include "components/printing/common/print.mojom-shared-message-ids.h"

#include "components/printing/common/print.mojom-import-headers.h"
#include "components/printing/common/print.mojom-test-utils.h"


#ifndef COMPONENTS_PRINTING_COMMON_PRINT_MOJOM_JUMBO_H_
#define COMPONENTS_PRINTING_COMMON_PRINT_MOJOM_JUMBO_H_
#endif



namespace printing {
namespace mojom {
PrintFrameContentParams::PrintFrameContentParams()
    : printable_area(),
      document_cookie() {}

PrintFrameContentParams::PrintFrameContentParams(
    const ::gfx::Rect& printable_area_in,
    int32_t document_cookie_in)
    : printable_area(std::move(printable_area_in)),
      document_cookie(std::move(document_cookie_in)) {}

PrintFrameContentParams::~PrintFrameContentParams() = default;

void PrintFrameContentParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "printable_area"), this->printable_area,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "document_cookie"), this->document_cookie,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PrintFrameContentParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
OptionsFromDocumentParams::OptionsFromDocumentParams()
    : is_scaling_disabled(),
      copies(),
      duplex() {}

OptionsFromDocumentParams::OptionsFromDocumentParams(
    bool is_scaling_disabled_in,
    int32_t copies_in,
    ::printing::mojom::DuplexMode duplex_in)
    : is_scaling_disabled(std::move(is_scaling_disabled_in)),
      copies(std::move(copies_in)),
      duplex(std::move(duplex_in)) {}

OptionsFromDocumentParams::~OptionsFromDocumentParams() = default;
size_t OptionsFromDocumentParams::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->is_scaling_disabled);
  seed = mojo::internal::Hash(seed, this->copies);
  seed = mojo::internal::Hash(seed, this->duplex);
  return seed;
}

void OptionsFromDocumentParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_scaling_disabled"), this->is_scaling_disabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "copies"), this->copies,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "duplex"), this->duplex,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::printing::mojom::DuplexMode>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool OptionsFromDocumentParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DidPrintContentParams::DidPrintContentParams()
    : metafile_data_region(),
      subframe_content_info() {}

DidPrintContentParams::DidPrintContentParams(
    ::base::ReadOnlySharedMemoryRegion metafile_data_region_in,
    const base::flat_map<uint32_t, ::base::UnguessableToken>& subframe_content_info_in)
    : metafile_data_region(std::move(metafile_data_region_in)),
      subframe_content_info(std::move(subframe_content_info_in)) {}

DidPrintContentParams::~DidPrintContentParams() = default;

void DidPrintContentParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "metafile_data_region"), this->metafile_data_region,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::ReadOnlySharedMemoryRegion>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "subframe_content_info"), this->subframe_content_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<uint32_t, ::base::UnguessableToken>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DidPrintContentParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DidStartPreviewParams::DidStartPreviewParams()
    : page_count(),
      pages_to_render(),
      pages_per_sheet(),
      page_size(),
      fit_to_page_scaling() {}

DidStartPreviewParams::DidStartPreviewParams(
    uint32_t page_count_in,
    std::vector<uint32_t> pages_to_render_in,
    int32_t pages_per_sheet_in,
    const ::gfx::Size& page_size_in,
    int32_t fit_to_page_scaling_in)
    : page_count(std::move(page_count_in)),
      pages_to_render(std::move(pages_to_render_in)),
      pages_per_sheet(std::move(pages_per_sheet_in)),
      page_size(std::move(page_size_in)),
      fit_to_page_scaling(std::move(fit_to_page_scaling_in)) {}

DidStartPreviewParams::~DidStartPreviewParams() = default;

void DidStartPreviewParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_count"), this->page_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pages_to_render"), this->pages_to_render,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<uint32_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pages_per_sheet"), this->pages_per_sheet,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_size"), this->page_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "fit_to_page_scaling"), this->fit_to_page_scaling,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DidStartPreviewParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DidPreviewPageParams::DidPreviewPageParams()
    : content(),
      page_number(),
      document_cookie() {}

DidPreviewPageParams::DidPreviewPageParams(
    DidPrintContentParamsPtr content_in,
    uint32_t page_number_in,
    int32_t document_cookie_in)
    : content(std::move(content_in)),
      page_number(std::move(page_number_in)),
      document_cookie(std::move(document_cookie_in)) {}

DidPreviewPageParams::~DidPreviewPageParams() = default;

void DidPreviewPageParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "content"), this->content,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DidPrintContentParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_number"), this->page_number,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "document_cookie"), this->document_cookie,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DidPreviewPageParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DidPreviewDocumentParams::DidPreviewDocumentParams()
    : content(),
      document_cookie(),
      expected_pages_count() {}

DidPreviewDocumentParams::DidPreviewDocumentParams(
    DidPrintContentParamsPtr content_in,
    int32_t document_cookie_in,
    uint32_t expected_pages_count_in)
    : content(std::move(content_in)),
      document_cookie(std::move(document_cookie_in)),
      expected_pages_count(std::move(expected_pages_count_in)) {}

DidPreviewDocumentParams::~DidPreviewDocumentParams() = default;

void DidPreviewDocumentParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "content"), this->content,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DidPrintContentParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "document_cookie"), this->document_cookie,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "expected_pages_count"), this->expected_pages_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DidPreviewDocumentParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PrintParams::PrintParams()
    : page_size(),
      content_size(),
      printable_area(),
      margin_top(0),
      margin_left(0),
      page_orientation(::printing::mojom::PageOrientation::kUpright),
      dpi(),
      scale_factor(1.0),
      document_cookie(0),
      selection_only(false),
      supports_alpha_blend(false),
      preview_ui_id(-1),
      preview_request_id(0),
      is_first_request(false),
      print_scaling_option(::printing::mojom::PrintScalingOption::kSourceSize),
      print_to_pdf(false),
      display_header_footer(false),
      title(),
      url(),
      header_template(),
      footer_template(),
      rasterize_pdf(false),
      rasterize_pdf_dpi(0),
      should_print_backgrounds(false),
      printed_doc_type(::printing::mojom::SkiaDocumentType::kPDF),
      prefer_css_page_size(false),
      pages_per_sheet(1U) {}

PrintParams::PrintParams(
    const ::gfx::Size& page_size_in,
    const ::gfx::Size& content_size_in,
    const ::gfx::Rect& printable_area_in,
    int32_t margin_top_in,
    int32_t margin_left_in,
    ::printing::mojom::PageOrientation page_orientation_in,
    const ::gfx::Size& dpi_in,
    double scale_factor_in,
    int32_t document_cookie_in,
    bool selection_only_in,
    bool supports_alpha_blend_in,
    int32_t preview_ui_id_in,
    int32_t preview_request_id_in,
    bool is_first_request_in,
    ::printing::mojom::PrintScalingOption print_scaling_option_in,
    bool print_to_pdf_in,
    bool display_header_footer_in,
    const ::std::u16string& title_in,
    const ::std::u16string& url_in,
    const ::std::u16string& header_template_in,
    const ::std::u16string& footer_template_in,
    bool rasterize_pdf_in,
    int32_t rasterize_pdf_dpi_in,
    bool should_print_backgrounds_in,
    ::printing::mojom::SkiaDocumentType printed_doc_type_in,
    bool prefer_css_page_size_in,
    uint32_t pages_per_sheet_in)
    : page_size(std::move(page_size_in)),
      content_size(std::move(content_size_in)),
      printable_area(std::move(printable_area_in)),
      margin_top(std::move(margin_top_in)),
      margin_left(std::move(margin_left_in)),
      page_orientation(std::move(page_orientation_in)),
      dpi(std::move(dpi_in)),
      scale_factor(std::move(scale_factor_in)),
      document_cookie(std::move(document_cookie_in)),
      selection_only(std::move(selection_only_in)),
      supports_alpha_blend(std::move(supports_alpha_blend_in)),
      preview_ui_id(std::move(preview_ui_id_in)),
      preview_request_id(std::move(preview_request_id_in)),
      is_first_request(std::move(is_first_request_in)),
      print_scaling_option(std::move(print_scaling_option_in)),
      print_to_pdf(std::move(print_to_pdf_in)),
      display_header_footer(std::move(display_header_footer_in)),
      title(std::move(title_in)),
      url(std::move(url_in)),
      header_template(std::move(header_template_in)),
      footer_template(std::move(footer_template_in)),
      rasterize_pdf(std::move(rasterize_pdf_in)),
      rasterize_pdf_dpi(std::move(rasterize_pdf_dpi_in)),
      should_print_backgrounds(std::move(should_print_backgrounds_in)),
      printed_doc_type(std::move(printed_doc_type_in)),
      prefer_css_page_size(std::move(prefer_css_page_size_in)),
      pages_per_sheet(std::move(pages_per_sheet_in)) {}

PrintParams::~PrintParams() = default;

void PrintParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_size"), this->page_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "content_size"), this->content_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "printable_area"), this->printable_area,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "margin_top"), this->margin_top,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "margin_left"), this->margin_left,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_orientation"), this->page_orientation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::printing::mojom::PageOrientation>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dpi"), this->dpi,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "scale_factor"), this->scale_factor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "document_cookie"), this->document_cookie,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "selection_only"), this->selection_only,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "supports_alpha_blend"), this->supports_alpha_blend,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "preview_ui_id"), this->preview_ui_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "preview_request_id"), this->preview_request_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_first_request"), this->is_first_request,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "print_scaling_option"), this->print_scaling_option,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::printing::mojom::PrintScalingOption>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "print_to_pdf"), this->print_to_pdf,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "display_header_footer"), this->display_header_footer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "title"), this->title,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "header_template"), this->header_template,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "footer_template"), this->footer_template,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "rasterize_pdf"), this->rasterize_pdf,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "rasterize_pdf_dpi"), this->rasterize_pdf_dpi,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "should_print_backgrounds"), this->should_print_backgrounds,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "printed_doc_type"), this->printed_doc_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::printing::mojom::SkiaDocumentType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "prefer_css_page_size"), this->prefer_css_page_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pages_per_sheet"), this->pages_per_sheet,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PrintParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PrintPagesParams::PrintPagesParams()
    : params(),
      pages() {}

PrintPagesParams::PrintPagesParams(
    PrintParamsPtr params_in,
    std::vector<::printing::PageRange> pages_in)
    : params(std::move(params_in)),
      pages(std::move(pages_in)) {}

PrintPagesParams::~PrintPagesParams() = default;

void PrintPagesParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "params"), this->params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type PrintParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pages"), this->pages,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::printing::PageRange>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PrintPagesParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DidPrintDocumentParams::DidPrintDocumentParams()
    : content(),
      document_cookie(),
      page_size(),
      content_area(),
      physical_offsets() {}

DidPrintDocumentParams::DidPrintDocumentParams(
    DidPrintContentParamsPtr content_in,
    int32_t document_cookie_in,
    const ::gfx::Size& page_size_in,
    const ::gfx::Rect& content_area_in,
    const ::gfx::Point& physical_offsets_in)
    : content(std::move(content_in)),
      document_cookie(std::move(document_cookie_in)),
      page_size(std::move(page_size_in)),
      content_area(std::move(content_area_in)),
      physical_offsets(std::move(physical_offsets_in)) {}

DidPrintDocumentParams::~DidPrintDocumentParams() = default;

void DidPrintDocumentParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "content"), this->content,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DidPrintContentParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "document_cookie"), this->document_cookie,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_size"), this->page_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "content_area"), this->content_area,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "physical_offsets"), this->physical_offsets,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Point&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DidPrintDocumentParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ScriptedPrintParams::ScriptedPrintParams()
    : cookie(),
      expected_pages_count(),
      has_selection(),
      is_scripted(),
      margin_type() {}

ScriptedPrintParams::ScriptedPrintParams(
    int32_t cookie_in,
    uint32_t expected_pages_count_in,
    bool has_selection_in,
    bool is_scripted_in,
    ::printing::mojom::MarginType margin_type_in)
    : cookie(std::move(cookie_in)),
      expected_pages_count(std::move(expected_pages_count_in)),
      has_selection(std::move(has_selection_in)),
      is_scripted(std::move(is_scripted_in)),
      margin_type(std::move(margin_type_in)) {}

ScriptedPrintParams::~ScriptedPrintParams() = default;
size_t ScriptedPrintParams::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->cookie);
  seed = mojo::internal::Hash(seed, this->expected_pages_count);
  seed = mojo::internal::Hash(seed, this->has_selection);
  seed = mojo::internal::Hash(seed, this->is_scripted);
  seed = mojo::internal::Hash(seed, this->margin_type);
  return seed;
}

void ScriptedPrintParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cookie"), this->cookie,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "expected_pages_count"), this->expected_pages_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_selection"), this->has_selection,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_scripted"), this->is_scripted,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "margin_type"), this->margin_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::printing::mojom::MarginType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ScriptedPrintParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PrintWithParamsResult::PrintWithParamsResult() : tag_(Tag::kParams) {
  data_.params = new DidPrintDocumentParamsPtr;
}

PrintWithParamsResult::~PrintWithParamsResult() {
  DestroyActive();
}


void PrintWithParamsResult::set_params(
    DidPrintDocumentParamsPtr params) {
  if (tag_ == Tag::kParams) {
    *(data_.params) = std::move(params);
  } else {
    DestroyActive();
    tag_ = Tag::kParams;
    data_.params = new DidPrintDocumentParamsPtr(
        std::move(params));
  }
}
void PrintWithParamsResult::set_failure_reason(
    PrintFailureReason failure_reason) {
  if (tag_ != Tag::kFailureReason) {
    DestroyActive();
    tag_ = Tag::kFailureReason;
  }
  data_.failure_reason = failure_reason;
}

void PrintWithParamsResult::DestroyActive() {
  switch (tag_) {

    case Tag::kParams:

      delete data_.params;
      break;
    case Tag::kFailureReason:

      break;
  }
}

bool PrintWithParamsResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char PrintRenderer::Name_[] = "printing.mojom.PrintRenderer";

PrintRenderer::IPCStableHashFunction PrintRenderer::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPrintRenderer_CreatePreviewDocument_Name: {
      return &PrintRenderer::CreatePreviewDocument_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PrintRenderer::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPrintRenderer_CreatePreviewDocument_Name:
            return "Receive printing::mojom::PrintRenderer::CreatePreviewDocument";
    }
  } else {
    switch (message.name()) {
      case internal::kPrintRenderer_CreatePreviewDocument_Name:
            return "Receive reply printing::mojom::PrintRenderer::CreatePreviewDocument";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PrintRenderer::CreatePreviewDocument_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderer::CreatePreviewDocument");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class PrintRenderer_CreatePreviewDocument_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PrintRenderer_CreatePreviewDocument_ForwardToCallback(
      PrintRenderer::CreatePreviewDocumentCallback callback
      ) : callback_(std::move(callback)) {
  }

  PrintRenderer_CreatePreviewDocument_ForwardToCallback(const PrintRenderer_CreatePreviewDocument_ForwardToCallback&) = delete;
  PrintRenderer_CreatePreviewDocument_ForwardToCallback& operator=(const PrintRenderer_CreatePreviewDocument_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PrintRenderer::CreatePreviewDocumentCallback callback_;
};

PrintRendererProxy::PrintRendererProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PrintRendererProxy::CreatePreviewDocument(
    ::base::Value::Dict in_job_settings, CreatePreviewDocumentCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintRenderer::CreatePreviewDocument", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("job_settings"), in_job_settings,
                        "<value of type ::base::Value::Dict>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderer_CreatePreviewDocument_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderer_CreatePreviewDocument_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->job_settings)::BaseType> job_settings_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::DictionaryValueDataView>(
      in_job_settings, job_settings_fragment);
  params->job_settings.Set(
      job_settings_fragment.is_null() ? nullptr : job_settings_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->job_settings.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null job_settings in PrintRenderer.CreatePreviewDocument request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderer::Name_);
  message.set_method_name("CreatePreviewDocument");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintRenderer_CreatePreviewDocument_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class PrintRenderer_CreatePreviewDocument_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PrintRenderer::CreatePreviewDocumentCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PrintRenderer_CreatePreviewDocument_ProxyToResponder> proxy(
        new PrintRenderer_CreatePreviewDocument_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PrintRenderer_CreatePreviewDocument_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PrintRenderer_CreatePreviewDocument_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PrintRenderer_CreatePreviewDocument_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PrintRenderer::CreatePreviewDocumentCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::ReadOnlySharedMemoryRegion in_preview_document_region);
};

bool PrintRenderer_CreatePreviewDocument_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintRenderer_CreatePreviewDocument_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PrintRenderer_CreatePreviewDocument_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::ReadOnlySharedMemoryRegion p_preview_document_region{};
  PrintRenderer_CreatePreviewDocument_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadPreviewDocumentRegion(&p_preview_document_region))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintRenderer::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_preview_document_region));
  return true;
}

void PrintRenderer_CreatePreviewDocument_ProxyToResponder::Run(
    ::base::ReadOnlySharedMemoryRegion in_preview_document_region) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply printing::mojom::PrintRenderer::CreatePreviewDocument", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("preview_document_region"), in_preview_document_region,
                        "<value of type ::base::ReadOnlySharedMemoryRegion>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderer_CreatePreviewDocument_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderer_CreatePreviewDocument_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->preview_document_region)::BaseType> preview_document_region_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView>(
      in_preview_document_region, preview_document_region_fragment);
  params->preview_document_region.Set(
      preview_document_region_fragment.is_null() ? nullptr : preview_document_region_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderer::Name_);
  message.set_method_name("CreatePreviewDocument");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PrintRendererStubDispatch::Accept(
    PrintRenderer* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPrintRenderer_CreatePreviewDocument_Name: {
      break;
    }
  }
  return false;
}

// static
bool PrintRendererStubDispatch::AcceptWithResponder(
    PrintRenderer* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPrintRenderer_CreatePreviewDocument_Name: {

      internal::PrintRenderer_CreatePreviewDocument_Params_Data* params =
          reinterpret_cast<
              internal::PrintRenderer_CreatePreviewDocument_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::Value::Dict p_job_settings{};
      PrintRenderer_CreatePreviewDocument_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadJobSettings(&p_job_settings))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderer::Name_, 0, false);
        return false;
      }
      PrintRenderer::CreatePreviewDocumentCallback callback =
          PrintRenderer_CreatePreviewDocument_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePreviewDocument(
std::move(p_job_settings), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPrintRendererValidationInfo[] = {
    {&internal::PrintRenderer_CreatePreviewDocument_Params_Data::Validate,
     &internal::PrintRenderer_CreatePreviewDocument_ResponseParams_Data::Validate},
};

bool PrintRendererRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintRenderer::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPrintRendererValidationInfo);
}

bool PrintRendererResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintRenderer::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kPrintRendererValidationInfo);
}
const char PrintPreviewUI::Name_[] = "printing.mojom.PrintPreviewUI";

PrintPreviewUI::IPCStableHashFunction PrintPreviewUI::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PrintPreviewUI::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
# endif // !BUILDFLAG(IS_FUCHSIA)

PrintPreviewUIProxy::PrintPreviewUIProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

// static
bool PrintPreviewUIStubDispatch::Accept(
    PrintPreviewUI* impl,
    mojo::Message* message) {
  return false;
}

// static
bool PrintPreviewUIStubDispatch::AcceptWithResponder(
    PrintPreviewUI* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  return false;
}



bool PrintPreviewUIRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintPreviewUI::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, {});
}

const char PrintRenderFrame::Name_[] = "printing.mojom.PrintRenderFrame";

PrintRenderFrame::IPCStableHashFunction PrintRenderFrame::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPrintRenderFrame_PrintRequestedPages_Name: {
      return &PrintRenderFrame::PrintRequestedPages_Sym::IPCStableHash;
    }
    case internal::kPrintRenderFrame_PrintWithParams_Name: {
      return &PrintRenderFrame::PrintWithParams_Sym::IPCStableHash;
    }
    case internal::kPrintRenderFrame_PrintFrameContent_Name: {
      return &PrintRenderFrame::PrintFrameContent_Sym::IPCStableHash;
    }
    case internal::kPrintRenderFrame_SetPrintingEnabled_Name: {
      return &PrintRenderFrame::SetPrintingEnabled_Sym::IPCStableHash;
    }
    case internal::kPrintRenderFrame_PrintingDone_Name: {
      return &PrintRenderFrame::PrintingDone_Sym::IPCStableHash;
    }
    case internal::kPrintRenderFrame_PrintNodeUnderContextMenu_Name: {
      return &PrintRenderFrame::PrintNodeUnderContextMenu_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PrintRenderFrame::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPrintRenderFrame_PrintRequestedPages_Name:
            return "Receive printing::mojom::PrintRenderFrame::PrintRequestedPages";
      case internal::kPrintRenderFrame_PrintWithParams_Name:
            return "Receive printing::mojom::PrintRenderFrame::PrintWithParams";
      case internal::kPrintRenderFrame_PrintFrameContent_Name:
            return "Receive printing::mojom::PrintRenderFrame::PrintFrameContent";
      case internal::kPrintRenderFrame_SetPrintingEnabled_Name:
            return "Receive printing::mojom::PrintRenderFrame::SetPrintingEnabled";
      case internal::kPrintRenderFrame_PrintingDone_Name:
            return "Receive printing::mojom::PrintRenderFrame::PrintingDone";
      case internal::kPrintRenderFrame_PrintNodeUnderContextMenu_Name:
            return "Receive printing::mojom::PrintRenderFrame::PrintNodeUnderContextMenu";
    }
  } else {
    switch (message.name()) {
      case internal::kPrintRenderFrame_PrintRequestedPages_Name:
            return "Receive reply printing::mojom::PrintRenderFrame::PrintRequestedPages";
      case internal::kPrintRenderFrame_PrintWithParams_Name:
            return "Receive reply printing::mojom::PrintRenderFrame::PrintWithParams";
      case internal::kPrintRenderFrame_PrintFrameContent_Name:
            return "Receive reply printing::mojom::PrintRenderFrame::PrintFrameContent";
      case internal::kPrintRenderFrame_SetPrintingEnabled_Name:
            return "Receive reply printing::mojom::PrintRenderFrame::SetPrintingEnabled";
      case internal::kPrintRenderFrame_PrintingDone_Name:
            return "Receive reply printing::mojom::PrintRenderFrame::PrintingDone";
      case internal::kPrintRenderFrame_PrintNodeUnderContextMenu_Name:
            return "Receive reply printing::mojom::PrintRenderFrame::PrintNodeUnderContextMenu";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PrintRenderFrame::PrintRequestedPages_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderFrame::PrintRequestedPages");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintRenderFrame::PrintWithParams_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderFrame::PrintWithParams");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintRenderFrame::PrintFrameContent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderFrame::PrintFrameContent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintRenderFrame::SetPrintingEnabled_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderFrame::SetPrintingEnabled");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintRenderFrame::PrintingDone_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderFrame::PrintingDone");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintRenderFrame::PrintNodeUnderContextMenu_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintRenderFrame::PrintNodeUnderContextMenu");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class PrintRenderFrame_PrintWithParams_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PrintRenderFrame_PrintWithParams_ForwardToCallback(
      PrintRenderFrame::PrintWithParamsCallback callback
      ) : callback_(std::move(callback)) {
  }

  PrintRenderFrame_PrintWithParams_ForwardToCallback(const PrintRenderFrame_PrintWithParams_ForwardToCallback&) = delete;
  PrintRenderFrame_PrintWithParams_ForwardToCallback& operator=(const PrintRenderFrame_PrintWithParams_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PrintRenderFrame::PrintWithParamsCallback callback_;
};

class PrintRenderFrame_PrintFrameContent_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PrintRenderFrame_PrintFrameContent_ForwardToCallback(
      PrintRenderFrame::PrintFrameContentCallback callback
      ) : callback_(std::move(callback)) {
  }

  PrintRenderFrame_PrintFrameContent_ForwardToCallback(const PrintRenderFrame_PrintFrameContent_ForwardToCallback&) = delete;
  PrintRenderFrame_PrintFrameContent_ForwardToCallback& operator=(const PrintRenderFrame_PrintFrameContent_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PrintRenderFrame::PrintFrameContentCallback callback_;
};

PrintRenderFrameProxy::PrintRenderFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PrintRenderFrameProxy::PrintRequestedPages(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send printing::mojom::PrintRenderFrame::PrintRequestedPages");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintRequestedPages_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintRequestedPages_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintRequestedPages");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PrintRenderFrameProxy::PrintWithParams(
    PrintPagesParamsPtr in_params, PrintWithParamsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintRenderFrame::PrintWithParams", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type PrintPagesParamsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintWithParams_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintWithParams_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::PrintPagesParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in PrintRenderFrame.PrintWithParams request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintWithParams");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintRenderFrame_PrintWithParams_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void PrintRenderFrameProxy::PrintFrameContent(
    PrintFrameContentParamsPtr in_params, PrintFrameContentCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintRenderFrame::PrintFrameContent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type PrintFrameContentParamsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintFrameContent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintFrameContent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::PrintFrameContentParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in PrintRenderFrame.PrintFrameContent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintFrameContent");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintRenderFrame_PrintFrameContent_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void PrintRenderFrameProxy::SetPrintingEnabled(
    bool in_enabled) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintRenderFrame::SetPrintingEnabled", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("enabled"), in_enabled,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_SetPrintingEnabled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_SetPrintingEnabled_Params_Data> params(
          message);
  params.Allocate();
  params->enabled = in_enabled;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("SetPrintingEnabled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PrintRenderFrameProxy::PrintingDone(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintRenderFrame::PrintingDone", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintingDone_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintingDone_Params_Data> params(
          message);
  params.Allocate();
  params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintingDone");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PrintRenderFrameProxy::PrintNodeUnderContextMenu(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send printing::mojom::PrintRenderFrame::PrintNodeUnderContextMenu");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintNodeUnderContextMenu_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintNodeUnderContextMenu_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintNodeUnderContextMenu");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class PrintRenderFrame_PrintWithParams_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PrintRenderFrame::PrintWithParamsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PrintRenderFrame_PrintWithParams_ProxyToResponder> proxy(
        new PrintRenderFrame_PrintWithParams_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PrintRenderFrame_PrintWithParams_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PrintRenderFrame_PrintWithParams_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PrintRenderFrame_PrintWithParams_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PrintRenderFrame::PrintWithParamsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      PrintWithParamsResultPtr in_result);
};

bool PrintRenderFrame_PrintWithParams_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintRenderFrame_PrintWithParams_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PrintRenderFrame_PrintWithParams_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PrintWithParamsResultPtr p_result{};
  PrintRenderFrame_PrintWithParams_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintRenderFrame::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void PrintRenderFrame_PrintWithParams_ProxyToResponder::Run(
    PrintWithParamsResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply printing::mojom::PrintRenderFrame::PrintWithParams", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type PrintWithParamsResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintWithParams_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintWithParams_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::printing::mojom::PrintWithParamsResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintWithParams");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PrintRenderFrame_PrintFrameContent_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PrintRenderFrame::PrintFrameContentCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PrintRenderFrame_PrintFrameContent_ProxyToResponder> proxy(
        new PrintRenderFrame_PrintFrameContent_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PrintRenderFrame_PrintFrameContent_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PrintRenderFrame_PrintFrameContent_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PrintRenderFrame_PrintFrameContent_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PrintRenderFrame::PrintFrameContentCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_document_cookie, DidPrintContentParamsPtr in_params);
};

bool PrintRenderFrame_PrintFrameContent_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintRenderFrame_PrintFrameContent_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PrintRenderFrame_PrintFrameContent_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_document_cookie{};
  DidPrintContentParamsPtr p_params{};
  PrintRenderFrame_PrintFrameContent_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_document_cookie = input_data_view.document_cookie();
  if (success && !input_data_view.ReadParams(&p_params))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintRenderFrame::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_document_cookie), 
std::move(p_params));
  return true;
}

void PrintRenderFrame_PrintFrameContent_ProxyToResponder::Run(
    int32_t in_document_cookie, DidPrintContentParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply printing::mojom::PrintRenderFrame::PrintFrameContent", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("document_cookie"), in_document_cookie,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type DidPrintContentParamsPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintRenderFrame_PrintFrameContent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintRenderFrame_PrintFrameContent_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->document_cookie = in_document_cookie;
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::DidPrintContentParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintRenderFrame::Name_);
  message.set_method_name("PrintFrameContent");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PrintRenderFrameStubDispatch::Accept(
    PrintRenderFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPrintRenderFrame_PrintRequestedPages_Name: {

      DCHECK(message->is_serialized());
      internal::PrintRenderFrame_PrintRequestedPages_Params_Data* params =
          reinterpret_cast<internal::PrintRenderFrame_PrintRequestedPages_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PrintRenderFrame_PrintRequestedPages_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderFrame::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintRequestedPages();
      return true;
    }
    case internal::kPrintRenderFrame_PrintWithParams_Name: {
      break;
    }
    case internal::kPrintRenderFrame_PrintFrameContent_Name: {
      break;
    }
    case internal::kPrintRenderFrame_SetPrintingEnabled_Name: {

      DCHECK(message->is_serialized());
      internal::PrintRenderFrame_SetPrintingEnabled_Params_Data* params =
          reinterpret_cast<internal::PrintRenderFrame_SetPrintingEnabled_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_enabled{};
      PrintRenderFrame_SetPrintingEnabled_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_enabled = input_data_view.enabled();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderFrame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetPrintingEnabled(
std::move(p_enabled));
      return true;
    }
    case internal::kPrintRenderFrame_PrintingDone_Name: {

      DCHECK(message->is_serialized());
      internal::PrintRenderFrame_PrintingDone_Params_Data* params =
          reinterpret_cast<internal::PrintRenderFrame_PrintingDone_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_success{};
      PrintRenderFrame_PrintingDone_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_success = input_data_view.success();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderFrame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintingDone(
std::move(p_success));
      return true;
    }
    case internal::kPrintRenderFrame_PrintNodeUnderContextMenu_Name: {

      DCHECK(message->is_serialized());
      internal::PrintRenderFrame_PrintNodeUnderContextMenu_Params_Data* params =
          reinterpret_cast<internal::PrintRenderFrame_PrintNodeUnderContextMenu_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PrintRenderFrame_PrintNodeUnderContextMenu_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderFrame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintNodeUnderContextMenu();
      return true;
    }
  }
  return false;
}

// static
bool PrintRenderFrameStubDispatch::AcceptWithResponder(
    PrintRenderFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPrintRenderFrame_PrintRequestedPages_Name: {
      break;
    }
    case internal::kPrintRenderFrame_PrintWithParams_Name: {

      internal::PrintRenderFrame_PrintWithParams_Params_Data* params =
          reinterpret_cast<
              internal::PrintRenderFrame_PrintWithParams_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PrintPagesParamsPtr p_params{};
      PrintRenderFrame_PrintWithParams_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderFrame::Name_, 1, false);
        return false;
      }
      PrintRenderFrame::PrintWithParamsCallback callback =
          PrintRenderFrame_PrintWithParams_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintWithParams(
std::move(p_params), std::move(callback));
      return true;
    }
    case internal::kPrintRenderFrame_PrintFrameContent_Name: {

      internal::PrintRenderFrame_PrintFrameContent_Params_Data* params =
          reinterpret_cast<
              internal::PrintRenderFrame_PrintFrameContent_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PrintFrameContentParamsPtr p_params{};
      PrintRenderFrame_PrintFrameContent_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintRenderFrame::Name_, 2, false);
        return false;
      }
      PrintRenderFrame::PrintFrameContentCallback callback =
          PrintRenderFrame_PrintFrameContent_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintFrameContent(
std::move(p_params), std::move(callback));
      return true;
    }
    case internal::kPrintRenderFrame_SetPrintingEnabled_Name: {
      break;
    }
    case internal::kPrintRenderFrame_PrintingDone_Name: {
      break;
    }
    case internal::kPrintRenderFrame_PrintNodeUnderContextMenu_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPrintRenderFrameValidationInfo[] = {
    {&internal::PrintRenderFrame_PrintRequestedPages_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PrintRenderFrame_PrintWithParams_Params_Data::Validate,
     &internal::PrintRenderFrame_PrintWithParams_ResponseParams_Data::Validate},
    {&internal::PrintRenderFrame_PrintFrameContent_Params_Data::Validate,
     &internal::PrintRenderFrame_PrintFrameContent_ResponseParams_Data::Validate},
    {&internal::PrintRenderFrame_SetPrintingEnabled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PrintRenderFrame_PrintingDone_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PrintRenderFrame_PrintNodeUnderContextMenu_Params_Data::Validate,
     nullptr /* no response */},
};

bool PrintRenderFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintRenderFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPrintRenderFrameValidationInfo);
}

bool PrintRenderFrameResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintRenderFrame::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kPrintRenderFrameValidationInfo);
}
const char PrintManagerHost::Name_[] = "printing.mojom.PrintManagerHost";

PrintManagerHost::IPCStableHashFunction PrintManagerHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPrintManagerHost_DidGetPrintedPagesCount_Name: {
      return &PrintManagerHost::DidGetPrintedPagesCount_Sym::IPCStableHash;
    }
    case internal::kPrintManagerHost_GetDefaultPrintSettings_Name: {
      return &PrintManagerHost::GetDefaultPrintSettings_Sym::IPCStableHash;
    }
    case internal::kPrintManagerHost_DidShowPrintDialog_Name: {
      return &PrintManagerHost::DidShowPrintDialog_Sym::IPCStableHash;
    }
    case internal::kPrintManagerHost_DidPrintDocument_Name: {
      return &PrintManagerHost::DidPrintDocument_Sym::IPCStableHash;
    }
    case internal::kPrintManagerHost_ScriptedPrint_Name: {
      return &PrintManagerHost::ScriptedPrint_Sym::IPCStableHash;
    }
    case internal::kPrintManagerHost_ShowInvalidPrinterSettingsError_Name: {
      return &PrintManagerHost::ShowInvalidPrinterSettingsError_Sym::IPCStableHash;
    }
    case internal::kPrintManagerHost_PrintingFailed_Name: {
      return &PrintManagerHost::PrintingFailed_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PrintManagerHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPrintManagerHost_DidGetPrintedPagesCount_Name:
            return "Receive printing::mojom::PrintManagerHost::DidGetPrintedPagesCount";
      case internal::kPrintManagerHost_GetDefaultPrintSettings_Name:
            return "Receive printing::mojom::PrintManagerHost::GetDefaultPrintSettings";
      case internal::kPrintManagerHost_DidShowPrintDialog_Name:
            return "Receive printing::mojom::PrintManagerHost::DidShowPrintDialog";
      case internal::kPrintManagerHost_DidPrintDocument_Name:
            return "Receive printing::mojom::PrintManagerHost::DidPrintDocument";
      case internal::kPrintManagerHost_ScriptedPrint_Name:
            return "Receive printing::mojom::PrintManagerHost::ScriptedPrint";
      case internal::kPrintManagerHost_ShowInvalidPrinterSettingsError_Name:
            return "Receive printing::mojom::PrintManagerHost::ShowInvalidPrinterSettingsError";
      case internal::kPrintManagerHost_PrintingFailed_Name:
            return "Receive printing::mojom::PrintManagerHost::PrintingFailed";
    }
  } else {
    switch (message.name()) {
      case internal::kPrintManagerHost_DidGetPrintedPagesCount_Name:
            return "Receive reply printing::mojom::PrintManagerHost::DidGetPrintedPagesCount";
      case internal::kPrintManagerHost_GetDefaultPrintSettings_Name:
            return "Receive reply printing::mojom::PrintManagerHost::GetDefaultPrintSettings";
      case internal::kPrintManagerHost_DidShowPrintDialog_Name:
            return "Receive reply printing::mojom::PrintManagerHost::DidShowPrintDialog";
      case internal::kPrintManagerHost_DidPrintDocument_Name:
            return "Receive reply printing::mojom::PrintManagerHost::DidPrintDocument";
      case internal::kPrintManagerHost_ScriptedPrint_Name:
            return "Receive reply printing::mojom::PrintManagerHost::ScriptedPrint";
      case internal::kPrintManagerHost_ShowInvalidPrinterSettingsError_Name:
            return "Receive reply printing::mojom::PrintManagerHost::ShowInvalidPrinterSettingsError";
      case internal::kPrintManagerHost_PrintingFailed_Name:
            return "Receive reply printing::mojom::PrintManagerHost::PrintingFailed";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PrintManagerHost::DidGetPrintedPagesCount_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::DidGetPrintedPagesCount");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintManagerHost::GetDefaultPrintSettings_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::GetDefaultPrintSettings");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintManagerHost::DidShowPrintDialog_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::DidShowPrintDialog");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintManagerHost::DidPrintDocument_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::DidPrintDocument");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintManagerHost::ScriptedPrint_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::ScriptedPrint");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintManagerHost::ShowInvalidPrinterSettingsError_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::ShowInvalidPrinterSettingsError");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PrintManagerHost::PrintingFailed_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)printing::mojom::PrintManagerHost::PrintingFailed");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)
bool PrintManagerHost::GetDefaultPrintSettings(PrintParamsPtr* out_default_settings) {
  NOTREACHED();
  return false;
}
bool PrintManagerHost::DidPrintDocument(DidPrintDocumentParamsPtr params, bool* out_completed) {
  NOTREACHED();
  return false;
}
bool PrintManagerHost::ScriptedPrint(ScriptedPrintParamsPtr params, PrintPagesParamsPtr* out_settings) {
  NOTREACHED();
  return false;
}
class PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse(
      bool* result, PrintParamsPtr* out_default_settings)
      : result_(result), out_default_settings_(out_default_settings) {
    DCHECK(!*result_);
  }

  PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse(const PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse&) = delete;
  PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse& operator=(const PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  PrintParamsPtr* out_default_settings_;};

class PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback(
      PrintManagerHost::GetDefaultPrintSettingsCallback callback
      ) : callback_(std::move(callback)) {
  }

  PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback(const PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback&) = delete;
  PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback& operator=(const PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PrintManagerHost::GetDefaultPrintSettingsCallback callback_;
};
class PrintManagerHost_DidPrintDocument_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  PrintManagerHost_DidPrintDocument_HandleSyncResponse(
      bool* result, bool* out_completed)
      : result_(result), out_completed_(out_completed) {
    DCHECK(!*result_);
  }

  PrintManagerHost_DidPrintDocument_HandleSyncResponse(const PrintManagerHost_DidPrintDocument_HandleSyncResponse&) = delete;
  PrintManagerHost_DidPrintDocument_HandleSyncResponse& operator=(const PrintManagerHost_DidPrintDocument_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_completed_;};

class PrintManagerHost_DidPrintDocument_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PrintManagerHost_DidPrintDocument_ForwardToCallback(
      PrintManagerHost::DidPrintDocumentCallback callback
      ) : callback_(std::move(callback)) {
  }

  PrintManagerHost_DidPrintDocument_ForwardToCallback(const PrintManagerHost_DidPrintDocument_ForwardToCallback&) = delete;
  PrintManagerHost_DidPrintDocument_ForwardToCallback& operator=(const PrintManagerHost_DidPrintDocument_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PrintManagerHost::DidPrintDocumentCallback callback_;
};
class PrintManagerHost_ScriptedPrint_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  PrintManagerHost_ScriptedPrint_HandleSyncResponse(
      bool* result, PrintPagesParamsPtr* out_settings)
      : result_(result), out_settings_(out_settings) {
    DCHECK(!*result_);
  }

  PrintManagerHost_ScriptedPrint_HandleSyncResponse(const PrintManagerHost_ScriptedPrint_HandleSyncResponse&) = delete;
  PrintManagerHost_ScriptedPrint_HandleSyncResponse& operator=(const PrintManagerHost_ScriptedPrint_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  PrintPagesParamsPtr* out_settings_;};

class PrintManagerHost_ScriptedPrint_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PrintManagerHost_ScriptedPrint_ForwardToCallback(
      PrintManagerHost::ScriptedPrintCallback callback
      ) : callback_(std::move(callback)) {
  }

  PrintManagerHost_ScriptedPrint_ForwardToCallback(const PrintManagerHost_ScriptedPrint_ForwardToCallback&) = delete;
  PrintManagerHost_ScriptedPrint_ForwardToCallback& operator=(const PrintManagerHost_ScriptedPrint_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PrintManagerHost::ScriptedPrintCallback callback_;
};

PrintManagerHostProxy::PrintManagerHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PrintManagerHostProxy::DidGetPrintedPagesCount(
    int32_t in_cookie, uint32_t in_number_pages) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintManagerHost::DidGetPrintedPagesCount", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cookie"), in_cookie,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("number_pages"), in_number_pages,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_DidGetPrintedPagesCount_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_DidGetPrintedPagesCount_Params_Data> params(
          message);
  params.Allocate();
  params->cookie = in_cookie;
  params->number_pages = in_number_pages;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("DidGetPrintedPagesCount");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool PrintManagerHostProxy::GetDefaultPrintSettings(
    PrintParamsPtr* out_param_default_settings) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call printing::mojom::PrintManagerHost::GetDefaultPrintSettings (sync)");
#else
  TRACE_EVENT0("mojom", "PrintManagerHost::GetDefaultPrintSettings");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_GetDefaultPrintSettings_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_GetDefaultPrintSettings_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("GetDefaultPrintSettings");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse(
          &result, out_param_default_settings));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "PrintManagerHost::GetDefaultPrintSettings", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("default_settings"), out_param_default_settings,
                        "<value of type PrintParamsPtr>");
   });
#endif
  return result;
}

void PrintManagerHostProxy::GetDefaultPrintSettings(
    GetDefaultPrintSettingsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send printing::mojom::PrintManagerHost::GetDefaultPrintSettings");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_GetDefaultPrintSettings_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_GetDefaultPrintSettings_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("GetDefaultPrintSettings");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void PrintManagerHostProxy::DidShowPrintDialog(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send printing::mojom::PrintManagerHost::DidShowPrintDialog");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_DidShowPrintDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_DidShowPrintDialog_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("DidShowPrintDialog");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool PrintManagerHostProxy::DidPrintDocument(
    DidPrintDocumentParamsPtr param_params, bool* out_param_completed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call printing::mojom::PrintManagerHost::DidPrintDocument (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), param_params,
                        "<value of type DidPrintDocumentParamsPtr>");
   });
#else
  TRACE_EVENT0("mojom", "PrintManagerHost::DidPrintDocument");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_DidPrintDocument_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_DidPrintDocument_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::DidPrintDocumentParamsDataView>(
      param_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in PrintManagerHost.DidPrintDocument request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("DidPrintDocument");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintManagerHost_DidPrintDocument_HandleSyncResponse(
          &result, out_param_completed));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "PrintManagerHost::DidPrintDocument", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("completed"), out_param_completed,
                        "<value of type bool>");
   });
#endif
  return result;
}

void PrintManagerHostProxy::DidPrintDocument(
    DidPrintDocumentParamsPtr in_params, DidPrintDocumentCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintManagerHost::DidPrintDocument", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type DidPrintDocumentParamsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_DidPrintDocument_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_DidPrintDocument_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::DidPrintDocumentParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in PrintManagerHost.DidPrintDocument request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("DidPrintDocument");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintManagerHost_DidPrintDocument_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool PrintManagerHostProxy::ScriptedPrint(
    ScriptedPrintParamsPtr param_params, PrintPagesParamsPtr* out_param_settings) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call printing::mojom::PrintManagerHost::ScriptedPrint (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), param_params,
                        "<value of type ScriptedPrintParamsPtr>");
   });
#else
  TRACE_EVENT0("mojom", "PrintManagerHost::ScriptedPrint");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_ScriptedPrint_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_ScriptedPrint_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::ScriptedPrintParamsDataView>(
      param_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in PrintManagerHost.ScriptedPrint request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("ScriptedPrint");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintManagerHost_ScriptedPrint_HandleSyncResponse(
          &result, out_param_settings));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "PrintManagerHost::ScriptedPrint", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("settings"), out_param_settings,
                        "<value of type PrintPagesParamsPtr>");
   });
#endif
  return result;
}

void PrintManagerHostProxy::ScriptedPrint(
    ScriptedPrintParamsPtr in_params, ScriptedPrintCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintManagerHost::ScriptedPrint", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type ScriptedPrintParamsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_ScriptedPrint_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_ScriptedPrint_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::ScriptedPrintParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in PrintManagerHost.ScriptedPrint request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("ScriptedPrint");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PrintManagerHost_ScriptedPrint_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void PrintManagerHostProxy::ShowInvalidPrinterSettingsError(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send printing::mojom::PrintManagerHost::ShowInvalidPrinterSettingsError");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_ShowInvalidPrinterSettingsError_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_ShowInvalidPrinterSettingsError_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("ShowInvalidPrinterSettingsError");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PrintManagerHostProxy::PrintingFailed(
    int32_t in_cookie, PrintFailureReason in_reason) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send printing::mojom::PrintManagerHost::PrintingFailed", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cookie"), in_cookie,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reason"), in_reason,
                        "<value of type PrintFailureReason>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_PrintingFailed_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_PrintingFailed_Params_Data> params(
          message);
  params.Allocate();
  params->cookie = in_cookie;
  mojo::internal::Serialize<::printing::mojom::PrintFailureReason>(
      in_reason, &params->reason);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("PrintingFailed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PrintManagerHost::GetDefaultPrintSettingsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder> proxy(
        new PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PrintManagerHost::GetDefaultPrintSettingsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      PrintParamsPtr in_default_settings);
};

bool PrintManagerHost_GetDefaultPrintSettings_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintManagerHost_GetDefaultPrintSettings_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PrintManagerHost_GetDefaultPrintSettings_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PrintParamsPtr p_default_settings{};
  PrintManagerHost_GetDefaultPrintSettings_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadDefaultSettings(&p_default_settings))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintManagerHost::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_default_settings));
  return true;
}

void PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder::Run(
    PrintParamsPtr in_default_settings) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply printing::mojom::PrintManagerHost::GetDefaultPrintSettings", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("default_settings"), in_default_settings,
                        "<value of type PrintParamsPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_GetDefaultPrintSettings_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_GetDefaultPrintSettings_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->default_settings)::BaseType> default_settings_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::PrintParamsDataView>(
      in_default_settings, default_settings_fragment);
  params->default_settings.Set(
      default_settings_fragment.is_null() ? nullptr : default_settings_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->default_settings.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null default_settings in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("GetDefaultPrintSettings");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool PrintManagerHost_GetDefaultPrintSettings_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintManagerHost_GetDefaultPrintSettings_ResponseParams_Data* params =
      reinterpret_cast<internal::PrintManagerHost_GetDefaultPrintSettings_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  PrintParamsPtr p_default_settings{};
  PrintManagerHost_GetDefaultPrintSettings_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadDefaultSettings(&p_default_settings))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintManagerHost::Name_, 1, true);
    return false;
  }
  *out_default_settings_ = std::move(p_default_settings);
  *result_ = true;
  return true;
}
class PrintManagerHost_DidPrintDocument_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PrintManagerHost::DidPrintDocumentCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PrintManagerHost_DidPrintDocument_ProxyToResponder> proxy(
        new PrintManagerHost_DidPrintDocument_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PrintManagerHost_DidPrintDocument_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PrintManagerHost_DidPrintDocument_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PrintManagerHost_DidPrintDocument_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PrintManagerHost::DidPrintDocumentCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_completed);
};

bool PrintManagerHost_DidPrintDocument_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintManagerHost_DidPrintDocument_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PrintManagerHost_DidPrintDocument_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_completed{};
  PrintManagerHost_DidPrintDocument_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_completed = input_data_view.completed();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintManagerHost::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_completed));
  return true;
}

void PrintManagerHost_DidPrintDocument_ProxyToResponder::Run(
    bool in_completed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply printing::mojom::PrintManagerHost::DidPrintDocument", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("completed"), in_completed,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_DidPrintDocument_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_DidPrintDocument_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->completed = in_completed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("DidPrintDocument");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool PrintManagerHost_DidPrintDocument_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintManagerHost_DidPrintDocument_ResponseParams_Data* params =
      reinterpret_cast<internal::PrintManagerHost_DidPrintDocument_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  bool p_completed{};
  PrintManagerHost_DidPrintDocument_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_completed = input_data_view.completed();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintManagerHost::Name_, 3, true);
    return false;
  }
  *out_completed_ = std::move(p_completed);
  *result_ = true;
  return true;
}
class PrintManagerHost_ScriptedPrint_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PrintManagerHost::ScriptedPrintCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PrintManagerHost_ScriptedPrint_ProxyToResponder> proxy(
        new PrintManagerHost_ScriptedPrint_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PrintManagerHost_ScriptedPrint_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PrintManagerHost_ScriptedPrint_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PrintManagerHost_ScriptedPrint_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PrintManagerHost::ScriptedPrintCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      PrintPagesParamsPtr in_settings);
};

bool PrintManagerHost_ScriptedPrint_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintManagerHost_ScriptedPrint_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PrintManagerHost_ScriptedPrint_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PrintPagesParamsPtr p_settings{};
  PrintManagerHost_ScriptedPrint_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadSettings(&p_settings))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintManagerHost::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_settings));
  return true;
}

void PrintManagerHost_ScriptedPrint_ProxyToResponder::Run(
    PrintPagesParamsPtr in_settings) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply printing::mojom::PrintManagerHost::ScriptedPrint", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("settings"), in_settings,
                        "<value of type PrintPagesParamsPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPrintManagerHost_ScriptedPrint_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::printing::mojom::internal::PrintManagerHost_ScriptedPrint_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->settings)::BaseType> settings_fragment(
          params.message());
  mojo::internal::Serialize<::printing::mojom::PrintPagesParamsDataView>(
      in_settings, settings_fragment);
  params->settings.Set(
      settings_fragment.is_null() ? nullptr : settings_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->settings.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null settings in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PrintManagerHost::Name_);
  message.set_method_name("ScriptedPrint");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool PrintManagerHost_ScriptedPrint_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PrintManagerHost_ScriptedPrint_ResponseParams_Data* params =
      reinterpret_cast<internal::PrintManagerHost_ScriptedPrint_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  PrintPagesParamsPtr p_settings{};
  PrintManagerHost_ScriptedPrint_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadSettings(&p_settings))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PrintManagerHost::Name_, 4, true);
    return false;
  }
  *out_settings_ = std::move(p_settings);
  *result_ = true;
  return true;
}

// static
bool PrintManagerHostStubDispatch::Accept(
    PrintManagerHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPrintManagerHost_DidGetPrintedPagesCount_Name: {

      DCHECK(message->is_serialized());
      internal::PrintManagerHost_DidGetPrintedPagesCount_Params_Data* params =
          reinterpret_cast<internal::PrintManagerHost_DidGetPrintedPagesCount_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_cookie{};
      uint32_t p_number_pages{};
      PrintManagerHost_DidGetPrintedPagesCount_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_cookie = input_data_view.cookie();
      if (success)
        p_number_pages = input_data_view.number_pages();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidGetPrintedPagesCount(
std::move(p_cookie), 
std::move(p_number_pages));
      return true;
    }
    case internal::kPrintManagerHost_GetDefaultPrintSettings_Name: {
      break;
    }
    case internal::kPrintManagerHost_DidShowPrintDialog_Name: {

      DCHECK(message->is_serialized());
      internal::PrintManagerHost_DidShowPrintDialog_Params_Data* params =
          reinterpret_cast<internal::PrintManagerHost_DidShowPrintDialog_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PrintManagerHost_DidShowPrintDialog_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidShowPrintDialog();
      return true;
    }
    case internal::kPrintManagerHost_DidPrintDocument_Name: {
      break;
    }
    case internal::kPrintManagerHost_ScriptedPrint_Name: {
      break;
    }
    case internal::kPrintManagerHost_ShowInvalidPrinterSettingsError_Name: {

      DCHECK(message->is_serialized());
      internal::PrintManagerHost_ShowInvalidPrinterSettingsError_Params_Data* params =
          reinterpret_cast<internal::PrintManagerHost_ShowInvalidPrinterSettingsError_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PrintManagerHost_ShowInvalidPrinterSettingsError_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowInvalidPrinterSettingsError();
      return true;
    }
    case internal::kPrintManagerHost_PrintingFailed_Name: {

      DCHECK(message->is_serialized());
      internal::PrintManagerHost_PrintingFailed_Params_Data* params =
          reinterpret_cast<internal::PrintManagerHost_PrintingFailed_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_cookie{};
      PrintFailureReason p_reason{};
      PrintManagerHost_PrintingFailed_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_cookie = input_data_view.cookie();
      if (success && !input_data_view.ReadReason(&p_reason))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintingFailed(
std::move(p_cookie), 
std::move(p_reason));
      return true;
    }
  }
  return false;
}

// static
bool PrintManagerHostStubDispatch::AcceptWithResponder(
    PrintManagerHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPrintManagerHost_DidGetPrintedPagesCount_Name: {
      break;
    }
    case internal::kPrintManagerHost_GetDefaultPrintSettings_Name: {

      internal::PrintManagerHost_GetDefaultPrintSettings_Params_Data* params =
          reinterpret_cast<
              internal::PrintManagerHost_GetDefaultPrintSettings_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      PrintManagerHost_GetDefaultPrintSettings_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 1, false);
        return false;
      }
      PrintManagerHost::GetDefaultPrintSettingsCallback callback =
          PrintManagerHost_GetDefaultPrintSettings_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDefaultPrintSettings(std::move(callback));
      return true;
    }
    case internal::kPrintManagerHost_DidShowPrintDialog_Name: {
      break;
    }
    case internal::kPrintManagerHost_DidPrintDocument_Name: {

      internal::PrintManagerHost_DidPrintDocument_Params_Data* params =
          reinterpret_cast<
              internal::PrintManagerHost_DidPrintDocument_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      DidPrintDocumentParamsPtr p_params{};
      PrintManagerHost_DidPrintDocument_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 3, false);
        return false;
      }
      PrintManagerHost::DidPrintDocumentCallback callback =
          PrintManagerHost_DidPrintDocument_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidPrintDocument(
std::move(p_params), std::move(callback));
      return true;
    }
    case internal::kPrintManagerHost_ScriptedPrint_Name: {

      internal::PrintManagerHost_ScriptedPrint_Params_Data* params =
          reinterpret_cast<
              internal::PrintManagerHost_ScriptedPrint_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ScriptedPrintParamsPtr p_params{};
      PrintManagerHost_ScriptedPrint_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PrintManagerHost::Name_, 4, false);
        return false;
      }
      PrintManagerHost::ScriptedPrintCallback callback =
          PrintManagerHost_ScriptedPrint_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScriptedPrint(
std::move(p_params), std::move(callback));
      return true;
    }
    case internal::kPrintManagerHost_ShowInvalidPrinterSettingsError_Name: {
      break;
    }
    case internal::kPrintManagerHost_PrintingFailed_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPrintManagerHostValidationInfo[] = {
    {&internal::PrintManagerHost_DidGetPrintedPagesCount_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PrintManagerHost_GetDefaultPrintSettings_Params_Data::Validate,
     &internal::PrintManagerHost_GetDefaultPrintSettings_ResponseParams_Data::Validate},
    {&internal::PrintManagerHost_DidShowPrintDialog_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PrintManagerHost_DidPrintDocument_Params_Data::Validate,
     &internal::PrintManagerHost_DidPrintDocument_ResponseParams_Data::Validate},
    {&internal::PrintManagerHost_ScriptedPrint_Params_Data::Validate,
     &internal::PrintManagerHost_ScriptedPrint_ResponseParams_Data::Validate},
    {&internal::PrintManagerHost_ShowInvalidPrinterSettingsError_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PrintManagerHost_PrintingFailed_Params_Data::Validate,
     nullptr /* no response */},
};

bool PrintManagerHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintManagerHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPrintManagerHostValidationInfo);
}

bool PrintManagerHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::printing::mojom::PrintManagerHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kPrintManagerHostValidationInfo);
}


}  // namespace mojom
}  // namespace printing


namespace mojo {


// static
bool StructTraits<::printing::mojom::PrintFrameContentParams::DataView, ::printing::mojom::PrintFrameContentParamsPtr>::Read(
    ::printing::mojom::PrintFrameContentParams::DataView input,
    ::printing::mojom::PrintFrameContentParamsPtr* output) {
  bool success = true;
  ::printing::mojom::PrintFrameContentParamsPtr result(::printing::mojom::PrintFrameContentParams::New());
  
      if (success && !input.ReadPrintableArea(&result->printable_area))
        success = false;
      if (success)
        result->document_cookie = input.document_cookie();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::OptionsFromDocumentParams::DataView, ::printing::mojom::OptionsFromDocumentParamsPtr>::Read(
    ::printing::mojom::OptionsFromDocumentParams::DataView input,
    ::printing::mojom::OptionsFromDocumentParamsPtr* output) {
  bool success = true;
  ::printing::mojom::OptionsFromDocumentParamsPtr result(::printing::mojom::OptionsFromDocumentParams::New());
  
      if (success)
        result->is_scaling_disabled = input.is_scaling_disabled();
      if (success)
        result->copies = input.copies();
      if (success && !input.ReadDuplex(&result->duplex))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::DidPrintContentParams::DataView, ::printing::mojom::DidPrintContentParamsPtr>::Read(
    ::printing::mojom::DidPrintContentParams::DataView input,
    ::printing::mojom::DidPrintContentParamsPtr* output) {
  bool success = true;
  ::printing::mojom::DidPrintContentParamsPtr result(::printing::mojom::DidPrintContentParams::New());
  
      if (success && !input.ReadMetafileDataRegion(&result->metafile_data_region))
        success = false;
      if (success && !input.ReadSubframeContentInfo(&result->subframe_content_info))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::DidStartPreviewParams::DataView, ::printing::mojom::DidStartPreviewParamsPtr>::Read(
    ::printing::mojom::DidStartPreviewParams::DataView input,
    ::printing::mojom::DidStartPreviewParamsPtr* output) {
  bool success = true;
  ::printing::mojom::DidStartPreviewParamsPtr result(::printing::mojom::DidStartPreviewParams::New());
  
      if (success)
        result->page_count = input.page_count();
      if (success && !input.ReadPagesToRender(&result->pages_to_render))
        success = false;
      if (success)
        result->pages_per_sheet = input.pages_per_sheet();
      if (success && !input.ReadPageSize(&result->page_size))
        success = false;
      if (success)
        result->fit_to_page_scaling = input.fit_to_page_scaling();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::DidPreviewPageParams::DataView, ::printing::mojom::DidPreviewPageParamsPtr>::Read(
    ::printing::mojom::DidPreviewPageParams::DataView input,
    ::printing::mojom::DidPreviewPageParamsPtr* output) {
  bool success = true;
  ::printing::mojom::DidPreviewPageParamsPtr result(::printing::mojom::DidPreviewPageParams::New());
  
      if (success && !input.ReadContent(&result->content))
        success = false;
      if (success)
        result->page_number = input.page_number();
      if (success)
        result->document_cookie = input.document_cookie();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::DidPreviewDocumentParams::DataView, ::printing::mojom::DidPreviewDocumentParamsPtr>::Read(
    ::printing::mojom::DidPreviewDocumentParams::DataView input,
    ::printing::mojom::DidPreviewDocumentParamsPtr* output) {
  bool success = true;
  ::printing::mojom::DidPreviewDocumentParamsPtr result(::printing::mojom::DidPreviewDocumentParams::New());
  
      if (success && !input.ReadContent(&result->content))
        success = false;
      if (success)
        result->document_cookie = input.document_cookie();
      if (success)
        result->expected_pages_count = input.expected_pages_count();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::PrintParams::DataView, ::printing::mojom::PrintParamsPtr>::Read(
    ::printing::mojom::PrintParams::DataView input,
    ::printing::mojom::PrintParamsPtr* output) {
  bool success = true;
  ::printing::mojom::PrintParamsPtr result(::printing::mojom::PrintParams::New());
  
      if (success && !input.ReadPageSize(&result->page_size))
        success = false;
      if (success && !input.ReadContentSize(&result->content_size))
        success = false;
      if (success && !input.ReadPrintableArea(&result->printable_area))
        success = false;
      if (success)
        result->margin_top = input.margin_top();
      if (success)
        result->margin_left = input.margin_left();
      if (success && !input.ReadPageOrientation(&result->page_orientation))
        success = false;
      if (success && !input.ReadDpi(&result->dpi))
        success = false;
      if (success)
        result->scale_factor = input.scale_factor();
      if (success)
        result->document_cookie = input.document_cookie();
      if (success)
        result->selection_only = input.selection_only();
      if (success)
        result->supports_alpha_blend = input.supports_alpha_blend();
      if (success)
        result->preview_ui_id = input.preview_ui_id();
      if (success)
        result->preview_request_id = input.preview_request_id();
      if (success)
        result->is_first_request = input.is_first_request();
      if (success && !input.ReadPrintScalingOption(&result->print_scaling_option))
        success = false;
      if (success)
        result->print_to_pdf = input.print_to_pdf();
      if (success)
        result->display_header_footer = input.display_header_footer();
      if (success && !input.ReadTitle(&result->title))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadHeaderTemplate(&result->header_template))
        success = false;
      if (success && !input.ReadFooterTemplate(&result->footer_template))
        success = false;
      if (success)
        result->rasterize_pdf = input.rasterize_pdf();
      if (success)
        result->rasterize_pdf_dpi = input.rasterize_pdf_dpi();
      if (success)
        result->should_print_backgrounds = input.should_print_backgrounds();
      if (success && !input.ReadPrintedDocType(&result->printed_doc_type))
        success = false;
      if (success)
        result->prefer_css_page_size = input.prefer_css_page_size();
      if (success)
        result->pages_per_sheet = input.pages_per_sheet();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::PrintPagesParams::DataView, ::printing::mojom::PrintPagesParamsPtr>::Read(
    ::printing::mojom::PrintPagesParams::DataView input,
    ::printing::mojom::PrintPagesParamsPtr* output) {
  bool success = true;
  ::printing::mojom::PrintPagesParamsPtr result(::printing::mojom::PrintPagesParams::New());
  
      if (success && !input.ReadParams(&result->params))
        success = false;
      if (success && !input.ReadPages(&result->pages))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::DidPrintDocumentParams::DataView, ::printing::mojom::DidPrintDocumentParamsPtr>::Read(
    ::printing::mojom::DidPrintDocumentParams::DataView input,
    ::printing::mojom::DidPrintDocumentParamsPtr* output) {
  bool success = true;
  ::printing::mojom::DidPrintDocumentParamsPtr result(::printing::mojom::DidPrintDocumentParams::New());
  
      if (success && !input.ReadContent(&result->content))
        success = false;
      if (success)
        result->document_cookie = input.document_cookie();
      if (success && !input.ReadPageSize(&result->page_size))
        success = false;
      if (success && !input.ReadContentArea(&result->content_area))
        success = false;
      if (success && !input.ReadPhysicalOffsets(&result->physical_offsets))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::printing::mojom::ScriptedPrintParams::DataView, ::printing::mojom::ScriptedPrintParamsPtr>::Read(
    ::printing::mojom::ScriptedPrintParams::DataView input,
    ::printing::mojom::ScriptedPrintParamsPtr* output) {
  bool success = true;
  ::printing::mojom::ScriptedPrintParamsPtr result(::printing::mojom::ScriptedPrintParams::New());
  
      if (success)
        result->cookie = input.cookie();
      if (success)
        result->expected_pages_count = input.expected_pages_count();
      if (success)
        result->has_selection = input.has_selection();
      if (success)
        result->is_scripted = input.is_scripted();
      if (success && !input.ReadMarginType(&result->margin_type))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::printing::mojom::PrintWithParamsResult::DataView, ::printing::mojom::PrintWithParamsResultPtr>::Read(
    ::printing::mojom::PrintWithParamsResult::DataView input,
    ::printing::mojom::PrintWithParamsResultPtr* output) {
  using UnionType = ::printing::mojom::PrintWithParamsResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kParams: {
      ::printing::mojom::DidPrintDocumentParamsPtr result_params;
      if (!input.ReadParams(&result_params))
        return false;

      *output = UnionType::NewParams(
          std::move(result_params));
      break;
    }
    case Tag::kFailureReason: {
      ::printing::mojom::PrintFailureReason result_failure_reason;
      if (!input.ReadFailureReason(&result_failure_reason))
        return false;

      *output = UnionType::NewFailureReason(result_failure_reason);
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace printing {
namespace mojom {


void PrintRendererInterceptorForTesting::CreatePreviewDocument(::base::Value::Dict job_settings, CreatePreviewDocumentCallback callback) {
  GetForwardingInterface()->CreatePreviewDocument(std::move(job_settings), std::move(callback));
}
PrintRendererAsyncWaiter::PrintRendererAsyncWaiter(
    PrintRenderer* proxy) : proxy_(proxy) {}

PrintRendererAsyncWaiter::~PrintRendererAsyncWaiter() = default;

void PrintRendererAsyncWaiter::CreatePreviewDocument(
    ::base::Value::Dict job_settings, ::base::ReadOnlySharedMemoryRegion* out_preview_document_region) {
  base::RunLoop loop;
  proxy_->CreatePreviewDocument(std::move(job_settings),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::ReadOnlySharedMemoryRegion* out_preview_document_region
,
             ::base::ReadOnlySharedMemoryRegion preview_document_region) {*out_preview_document_region = std::move(preview_document_region);
            loop->Quit();
          },
          &loop,
          out_preview_document_region));
  loop.Run();
}



PrintPreviewUIAsyncWaiter::PrintPreviewUIAsyncWaiter(
    PrintPreviewUI* proxy) : proxy_(proxy) {}

PrintPreviewUIAsyncWaiter::~PrintPreviewUIAsyncWaiter() = default;




void PrintRenderFrameInterceptorForTesting::PrintRequestedPages() {
  GetForwardingInterface()->PrintRequestedPages();
}
void PrintRenderFrameInterceptorForTesting::PrintWithParams(PrintPagesParamsPtr params, PrintWithParamsCallback callback) {
  GetForwardingInterface()->PrintWithParams(std::move(params), std::move(callback));
}
void PrintRenderFrameInterceptorForTesting::PrintFrameContent(PrintFrameContentParamsPtr params, PrintFrameContentCallback callback) {
  GetForwardingInterface()->PrintFrameContent(std::move(params), std::move(callback));
}
void PrintRenderFrameInterceptorForTesting::SetPrintingEnabled(bool enabled) {
  GetForwardingInterface()->SetPrintingEnabled(std::move(enabled));
}
void PrintRenderFrameInterceptorForTesting::PrintingDone(bool success) {
  GetForwardingInterface()->PrintingDone(std::move(success));
}
void PrintRenderFrameInterceptorForTesting::PrintNodeUnderContextMenu() {
  GetForwardingInterface()->PrintNodeUnderContextMenu();
}
PrintRenderFrameAsyncWaiter::PrintRenderFrameAsyncWaiter(
    PrintRenderFrame* proxy) : proxy_(proxy) {}

PrintRenderFrameAsyncWaiter::~PrintRenderFrameAsyncWaiter() = default;

void PrintRenderFrameAsyncWaiter::PrintWithParams(
    PrintPagesParamsPtr params, PrintWithParamsResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->PrintWithParams(std::move(params),
      base::BindOnce(
          [](base::RunLoop* loop,
             PrintWithParamsResultPtr* out_result
,
             PrintWithParamsResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void PrintRenderFrameAsyncWaiter::PrintFrameContent(
    PrintFrameContentParamsPtr params, int32_t* out_document_cookie, DidPrintContentParamsPtr* out_params) {
  base::RunLoop loop;
  proxy_->PrintFrameContent(std::move(params),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_document_cookie
,
             DidPrintContentParamsPtr* out_params
,
             int32_t document_cookie,
             DidPrintContentParamsPtr params) {*out_document_cookie = std::move(document_cookie);*out_params = std::move(params);
            loop->Quit();
          },
          &loop,
          out_document_cookie,
          out_params));
  loop.Run();
}



void PrintManagerHostInterceptorForTesting::DidGetPrintedPagesCount(int32_t cookie, uint32_t number_pages) {
  GetForwardingInterface()->DidGetPrintedPagesCount(std::move(cookie), std::move(number_pages));
}
void PrintManagerHostInterceptorForTesting::GetDefaultPrintSettings(GetDefaultPrintSettingsCallback callback) {
  GetForwardingInterface()->GetDefaultPrintSettings(std::move(callback));
}
void PrintManagerHostInterceptorForTesting::DidShowPrintDialog() {
  GetForwardingInterface()->DidShowPrintDialog();
}
void PrintManagerHostInterceptorForTesting::DidPrintDocument(DidPrintDocumentParamsPtr params, DidPrintDocumentCallback callback) {
  GetForwardingInterface()->DidPrintDocument(std::move(params), std::move(callback));
}
void PrintManagerHostInterceptorForTesting::ScriptedPrint(ScriptedPrintParamsPtr params, ScriptedPrintCallback callback) {
  GetForwardingInterface()->ScriptedPrint(std::move(params), std::move(callback));
}
void PrintManagerHostInterceptorForTesting::ShowInvalidPrinterSettingsError() {
  GetForwardingInterface()->ShowInvalidPrinterSettingsError();
}
void PrintManagerHostInterceptorForTesting::PrintingFailed(int32_t cookie, PrintFailureReason reason) {
  GetForwardingInterface()->PrintingFailed(std::move(cookie), std::move(reason));
}
PrintManagerHostAsyncWaiter::PrintManagerHostAsyncWaiter(
    PrintManagerHost* proxy) : proxy_(proxy) {}

PrintManagerHostAsyncWaiter::~PrintManagerHostAsyncWaiter() = default;

void PrintManagerHostAsyncWaiter::GetDefaultPrintSettings(
    PrintParamsPtr* out_default_settings) {
  base::RunLoop loop;
  proxy_->GetDefaultPrintSettings(
      base::BindOnce(
          [](base::RunLoop* loop,
             PrintParamsPtr* out_default_settings
,
             PrintParamsPtr default_settings) {*out_default_settings = std::move(default_settings);
            loop->Quit();
          },
          &loop,
          out_default_settings));
  loop.Run();
}
void PrintManagerHostAsyncWaiter::DidPrintDocument(
    DidPrintDocumentParamsPtr params, bool* out_completed) {
  base::RunLoop loop;
  proxy_->DidPrintDocument(std::move(params),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_completed
,
             bool completed) {*out_completed = std::move(completed);
            loop->Quit();
          },
          &loop,
          out_completed));
  loop.Run();
}
void PrintManagerHostAsyncWaiter::ScriptedPrint(
    ScriptedPrintParamsPtr params, PrintPagesParamsPtr* out_settings) {
  base::RunLoop loop;
  proxy_->ScriptedPrint(std::move(params),
      base::BindOnce(
          [](base::RunLoop* loop,
             PrintPagesParamsPtr* out_settings
,
             PrintPagesParamsPtr settings) {*out_settings = std::move(settings);
            loop->Quit();
          },
          &loop,
          out_settings));
  loop.Run();
}





}  // namespace mojom
}  // namespace printing


#if defined(__clang__)
#pragma clang diagnostic pop
#endif