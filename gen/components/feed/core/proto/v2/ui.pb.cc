// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/v2/ui.proto

#include "components/feed/core/proto/v2/ui.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace feedui {
PROTOBUF_CONSTEXPR StreamUpdate_SliceUpdate::StreamUpdate_SliceUpdate(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct StreamUpdate_SliceUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamUpdate_SliceUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamUpdate_SliceUpdateDefaultTypeInternal() {}
  union {
    StreamUpdate_SliceUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamUpdate_SliceUpdateDefaultTypeInternal _StreamUpdate_SliceUpdate_default_instance_;
PROTOBUF_CONSTEXPR StreamUpdate::StreamUpdate(
    ::_pbi::ConstantInitialized)
  : updated_slices_()
  , new_shared_states_()
  , logging_parameters_(nullptr)
  , fetch_time_ms_(int64_t{0}){}
struct StreamUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamUpdateDefaultTypeInternal() {}
  union {
    StreamUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamUpdateDefaultTypeInternal _StreamUpdate_default_instance_;
PROTOBUF_CONSTEXPR LoggingParameters::LoggingParameters(
    ::_pbi::ConstantInitialized)
  : session_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , email_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_instance_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , root_event_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , logging_enabled_(false)
  , view_actions_enabled_(false){}
struct LoggingParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoggingParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoggingParametersDefaultTypeInternal() {}
  union {
    LoggingParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoggingParametersDefaultTypeInternal _LoggingParameters_default_instance_;
PROTOBUF_CONSTEXPR Slice::Slice(
    ::_pbi::ConstantInitialized)
  : slice_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct SliceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SliceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SliceDefaultTypeInternal() {}
  union {
    Slice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SliceDefaultTypeInternal _Slice_default_instance_;
PROTOBUF_CONSTEXPR ZeroStateSlice::ZeroStateSlice(
    ::_pbi::ConstantInitialized)
  : type_(0)
{}
struct ZeroStateSliceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ZeroStateSliceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ZeroStateSliceDefaultTypeInternal() {}
  union {
    ZeroStateSlice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ZeroStateSliceDefaultTypeInternal _ZeroStateSlice_default_instance_;
PROTOBUF_CONSTEXPR LoadingSpinnerSlice::LoadingSpinnerSlice(
    ::_pbi::ConstantInitialized)
  : is_at_top_(false){}
struct LoadingSpinnerSliceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadingSpinnerSliceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadingSpinnerSliceDefaultTypeInternal() {}
  union {
    LoadingSpinnerSlice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadingSpinnerSliceDefaultTypeInternal _LoadingSpinnerSlice_default_instance_;
PROTOBUF_CONSTEXPR XSurfaceSlice::XSurfaceSlice(
    ::_pbi::ConstantInitialized)
  : xsurface_frame_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct XSurfaceSliceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XSurfaceSliceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~XSurfaceSliceDefaultTypeInternal() {}
  union {
    XSurfaceSlice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XSurfaceSliceDefaultTypeInternal _XSurfaceSlice_default_instance_;
PROTOBUF_CONSTEXPR SharedState::SharedState(
    ::_pbi::ConstantInitialized)
  : id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , xsurface_shared_state_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct SharedStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SharedStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SharedStateDefaultTypeInternal() {}
  union {
    SharedState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SharedStateDefaultTypeInternal _SharedState_default_instance_;
}  // namespace feedui
namespace feedui {
bool ZeroStateSlice_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ZeroStateSlice_Type_strings[4] = {};

static const char ZeroStateSlice_Type_names[] =
  "CANT_REFRESH"
  "NO_CARDS_AVAILABLE"
  "NO_WEB_FEED_SUBSCRIPTIONS"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ZeroStateSlice_Type_entries[] = {
  { {ZeroStateSlice_Type_names + 0, 12}, 2 },
  { {ZeroStateSlice_Type_names + 12, 18}, 1 },
  { {ZeroStateSlice_Type_names + 30, 25}, 3 },
  { {ZeroStateSlice_Type_names + 55, 7}, 0 },
};

static const int ZeroStateSlice_Type_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  1, // 1 -> NO_CARDS_AVAILABLE
  0, // 2 -> CANT_REFRESH
  2, // 3 -> NO_WEB_FEED_SUBSCRIPTIONS
};

const std::string& ZeroStateSlice_Type_Name(
    ZeroStateSlice_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ZeroStateSlice_Type_entries,
          ZeroStateSlice_Type_entries_by_number,
          4, ZeroStateSlice_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ZeroStateSlice_Type_entries,
      ZeroStateSlice_Type_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ZeroStateSlice_Type_strings[idx].get();
}
bool ZeroStateSlice_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ZeroStateSlice_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ZeroStateSlice_Type_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ZeroStateSlice_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ZeroStateSlice_Type ZeroStateSlice::UNKNOWN;
constexpr ZeroStateSlice_Type ZeroStateSlice::NO_CARDS_AVAILABLE;
constexpr ZeroStateSlice_Type ZeroStateSlice::CANT_REFRESH;
constexpr ZeroStateSlice_Type ZeroStateSlice::NO_WEB_FEED_SUBSCRIPTIONS;
constexpr ZeroStateSlice_Type ZeroStateSlice::Type_MIN;
constexpr ZeroStateSlice_Type ZeroStateSlice::Type_MAX;
constexpr int ZeroStateSlice::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class StreamUpdate_SliceUpdate::_Internal {
 public:
  static const ::feedui::Slice& slice(const StreamUpdate_SliceUpdate* msg);
};

const ::feedui::Slice&
StreamUpdate_SliceUpdate::_Internal::slice(const StreamUpdate_SliceUpdate* msg) {
  return *msg->update_.slice_;
}
void StreamUpdate_SliceUpdate::set_allocated_slice(::feedui::Slice* slice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_update();
  if (slice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(slice);
    if (message_arena != submessage_arena) {
      slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slice, submessage_arena);
    }
    set_has_slice();
    update_.slice_ = slice;
  }
  // @@protoc_insertion_point(field_set_allocated:feedui.StreamUpdate.SliceUpdate.slice)
}
StreamUpdate_SliceUpdate::StreamUpdate_SliceUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.StreamUpdate.SliceUpdate)
}
StreamUpdate_SliceUpdate::StreamUpdate_SliceUpdate(const StreamUpdate_SliceUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_update();
  switch (from.update_case()) {
    case kSlice: {
      _internal_mutable_slice()->::feedui::Slice::MergeFrom(from._internal_slice());
      break;
    }
    case kSliceId: {
      _internal_set_slice_id(from._internal_slice_id());
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:feedui.StreamUpdate.SliceUpdate)
}

inline void StreamUpdate_SliceUpdate::SharedCtor() {
clear_has_update();
}

StreamUpdate_SliceUpdate::~StreamUpdate_SliceUpdate() {
  // @@protoc_insertion_point(destructor:feedui.StreamUpdate.SliceUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamUpdate_SliceUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_update()) {
    clear_update();
  }
}

void StreamUpdate_SliceUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StreamUpdate_SliceUpdate::clear_update() {
// @@protoc_insertion_point(one_of_clear_start:feedui.StreamUpdate.SliceUpdate)
  switch (update_case()) {
    case kSlice: {
      if (GetArenaForAllocation() == nullptr) {
        delete update_.slice_;
      }
      break;
    }
    case kSliceId: {
      update_.slice_id_.Destroy();
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = UPDATE_NOT_SET;
}


void StreamUpdate_SliceUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.StreamUpdate.SliceUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_update();
  _internal_metadata_.Clear<std::string>();
}

const char* StreamUpdate_SliceUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .feedui.Slice slice = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_slice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string slice_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_slice_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamUpdate_SliceUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.StreamUpdate.SliceUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .feedui.Slice slice = 1;
  if (_internal_has_slice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::slice(this),
        _Internal::slice(this).GetCachedSize(), target, stream);
  }

  // string slice_id = 2;
  if (_internal_has_slice_id()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_slice_id().data(), static_cast<int>(this->_internal_slice_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "feedui.StreamUpdate.SliceUpdate.slice_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_slice_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.StreamUpdate.SliceUpdate)
  return target;
}

size_t StreamUpdate_SliceUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.StreamUpdate.SliceUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (update_case()) {
    // .feedui.Slice slice = 1;
    case kSlice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *update_.slice_);
      break;
    }
    // string slice_id = 2;
    case kSliceId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_slice_id());
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamUpdate_SliceUpdate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StreamUpdate_SliceUpdate*>(
      &from));
}

void StreamUpdate_SliceUpdate::MergeFrom(const StreamUpdate_SliceUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.StreamUpdate.SliceUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.update_case()) {
    case kSlice: {
      _internal_mutable_slice()->::feedui::Slice::MergeFrom(from._internal_slice());
      break;
    }
    case kSliceId: {
      _internal_set_slice_id(from._internal_slice_id());
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamUpdate_SliceUpdate::CopyFrom(const StreamUpdate_SliceUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.StreamUpdate.SliceUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamUpdate_SliceUpdate::IsInitialized() const {
  return true;
}

void StreamUpdate_SliceUpdate::InternalSwap(StreamUpdate_SliceUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(update_, other->update_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string StreamUpdate_SliceUpdate::GetTypeName() const {
  return "feedui.StreamUpdate.SliceUpdate";
}


// ===================================================================

class StreamUpdate::_Internal {
 public:
  static const ::feedui::LoggingParameters& logging_parameters(const StreamUpdate* msg);
};

const ::feedui::LoggingParameters&
StreamUpdate::_Internal::logging_parameters(const StreamUpdate* msg) {
  return *msg->logging_parameters_;
}
StreamUpdate::StreamUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  updated_slices_(arena),
  new_shared_states_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.StreamUpdate)
}
StreamUpdate::StreamUpdate(const StreamUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      updated_slices_(from.updated_slices_),
      new_shared_states_(from.new_shared_states_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_logging_parameters()) {
    logging_parameters_ = new ::feedui::LoggingParameters(*from.logging_parameters_);
  } else {
    logging_parameters_ = nullptr;
  }
  fetch_time_ms_ = from.fetch_time_ms_;
  // @@protoc_insertion_point(copy_constructor:feedui.StreamUpdate)
}

inline void StreamUpdate::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&logging_parameters_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fetch_time_ms_) -
    reinterpret_cast<char*>(&logging_parameters_)) + sizeof(fetch_time_ms_));
}

StreamUpdate::~StreamUpdate() {
  // @@protoc_insertion_point(destructor:feedui.StreamUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete logging_parameters_;
}

void StreamUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StreamUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.StreamUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  updated_slices_.Clear();
  new_shared_states_.Clear();
  if (GetArenaForAllocation() == nullptr && logging_parameters_ != nullptr) {
    delete logging_parameters_;
  }
  logging_parameters_ = nullptr;
  fetch_time_ms_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* StreamUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .feedui.StreamUpdate.SliceUpdate updated_slices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_updated_slices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .feedui.SharedState new_shared_states = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_new_shared_states(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 fetch_time_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          fetch_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .feedui.LoggingParameters logging_parameters = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_logging_parameters(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.StreamUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .feedui.StreamUpdate.SliceUpdate updated_slices = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_updated_slices_size()); i < n; i++) {
    const auto& repfield = this->_internal_updated_slices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .feedui.SharedState new_shared_states = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_new_shared_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_new_shared_states(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 fetch_time_ms = 3;
  if (this->_internal_fetch_time_ms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_fetch_time_ms(), target);
  }

  // .feedui.LoggingParameters logging_parameters = 4;
  if (this->_internal_has_logging_parameters()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::logging_parameters(this),
        _Internal::logging_parameters(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.StreamUpdate)
  return target;
}

size_t StreamUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.StreamUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .feedui.StreamUpdate.SliceUpdate updated_slices = 1;
  total_size += 1UL * this->_internal_updated_slices_size();
  for (const auto& msg : this->updated_slices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .feedui.SharedState new_shared_states = 2;
  total_size += 1UL * this->_internal_new_shared_states_size();
  for (const auto& msg : this->new_shared_states_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .feedui.LoggingParameters logging_parameters = 4;
  if (this->_internal_has_logging_parameters()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *logging_parameters_);
  }

  // int64 fetch_time_ms = 3;
  if (this->_internal_fetch_time_ms() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_fetch_time_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StreamUpdate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StreamUpdate*>(
      &from));
}

void StreamUpdate::MergeFrom(const StreamUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.StreamUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  updated_slices_.MergeFrom(from.updated_slices_);
  new_shared_states_.MergeFrom(from.new_shared_states_);
  if (from._internal_has_logging_parameters()) {
    _internal_mutable_logging_parameters()->::feedui::LoggingParameters::MergeFrom(from._internal_logging_parameters());
  }
  if (from._internal_fetch_time_ms() != 0) {
    _internal_set_fetch_time_ms(from._internal_fetch_time_ms());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamUpdate::CopyFrom(const StreamUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.StreamUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamUpdate::IsInitialized() const {
  return true;
}

void StreamUpdate::InternalSwap(StreamUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  updated_slices_.InternalSwap(&other->updated_slices_);
  new_shared_states_.InternalSwap(&other->new_shared_states_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StreamUpdate, fetch_time_ms_)
      + sizeof(StreamUpdate::fetch_time_ms_)
      - PROTOBUF_FIELD_OFFSET(StreamUpdate, logging_parameters_)>(
          reinterpret_cast<char*>(&logging_parameters_),
          reinterpret_cast<char*>(&other->logging_parameters_));
}

std::string StreamUpdate::GetTypeName() const {
  return "feedui.StreamUpdate";
}


// ===================================================================

class LoggingParameters::_Internal {
 public:
};

LoggingParameters::LoggingParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.LoggingParameters)
}
LoggingParameters::LoggingParameters(const LoggingParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_session_id().empty()) {
    session_id_.Set(from._internal_session_id(), 
      GetArenaForAllocation());
  }
  email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    email_.Set(from._internal_email(), 
      GetArenaForAllocation());
  }
  client_instance_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_instance_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client_instance_id().empty()) {
    client_instance_id_.Set(from._internal_client_instance_id(), 
      GetArenaForAllocation());
  }
  root_event_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    root_event_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_root_event_id().empty()) {
    root_event_id_.Set(from._internal_root_event_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&logging_enabled_, &from.logging_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&view_actions_enabled_) -
    reinterpret_cast<char*>(&logging_enabled_)) + sizeof(view_actions_enabled_));
  // @@protoc_insertion_point(copy_constructor:feedui.LoggingParameters)
}

inline void LoggingParameters::SharedCtor() {
session_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  session_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_instance_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_instance_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
root_event_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  root_event_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&logging_enabled_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&view_actions_enabled_) -
    reinterpret_cast<char*>(&logging_enabled_)) + sizeof(view_actions_enabled_));
}

LoggingParameters::~LoggingParameters() {
  // @@protoc_insertion_point(destructor:feedui.LoggingParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoggingParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  session_id_.Destroy();
  email_.Destroy();
  client_instance_id_.Destroy();
  root_event_id_.Destroy();
}

void LoggingParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoggingParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.LoggingParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  session_id_.ClearToEmpty();
  email_.ClearToEmpty();
  client_instance_id_.ClearToEmpty();
  root_event_id_.ClearToEmpty();
  ::memset(&logging_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&view_actions_enabled_) -
      reinterpret_cast<char*>(&logging_enabled_)) + sizeof(view_actions_enabled_));
  _internal_metadata_.Clear<std::string>();
}

const char* LoggingParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string client_instance_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_client_instance_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bool logging_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          logging_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool view_actions_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          view_actions_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes root_event_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_root_event_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoggingParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.LoggingParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string session_id = 1;
  if (!this->_internal_session_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_session_id().data(), static_cast<int>(this->_internal_session_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "feedui.LoggingParameters.session_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_session_id(), target);
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "feedui.LoggingParameters.email");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  // string client_instance_id = 3;
  if (!this->_internal_client_instance_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client_instance_id().data(), static_cast<int>(this->_internal_client_instance_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "feedui.LoggingParameters.client_instance_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_client_instance_id(), target);
  }

  // bool logging_enabled = 4;
  if (this->_internal_logging_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_logging_enabled(), target);
  }

  // bool view_actions_enabled = 5;
  if (this->_internal_view_actions_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_view_actions_enabled(), target);
  }

  // bytes root_event_id = 6;
  if (!this->_internal_root_event_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_root_event_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.LoggingParameters)
  return target;
}

size_t LoggingParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.LoggingParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string session_id = 1;
  if (!this->_internal_session_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_session_id());
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string client_instance_id = 3;
  if (!this->_internal_client_instance_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_instance_id());
  }

  // bytes root_event_id = 6;
  if (!this->_internal_root_event_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_root_event_id());
  }

  // bool logging_enabled = 4;
  if (this->_internal_logging_enabled() != 0) {
    total_size += 1 + 1;
  }

  // bool view_actions_enabled = 5;
  if (this->_internal_view_actions_enabled() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoggingParameters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoggingParameters*>(
      &from));
}

void LoggingParameters::MergeFrom(const LoggingParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.LoggingParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_session_id().empty()) {
    _internal_set_session_id(from._internal_session_id());
  }
  if (!from._internal_email().empty()) {
    _internal_set_email(from._internal_email());
  }
  if (!from._internal_client_instance_id().empty()) {
    _internal_set_client_instance_id(from._internal_client_instance_id());
  }
  if (!from._internal_root_event_id().empty()) {
    _internal_set_root_event_id(from._internal_root_event_id());
  }
  if (from._internal_logging_enabled() != 0) {
    _internal_set_logging_enabled(from._internal_logging_enabled());
  }
  if (from._internal_view_actions_enabled() != 0) {
    _internal_set_view_actions_enabled(from._internal_view_actions_enabled());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoggingParameters::CopyFrom(const LoggingParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.LoggingParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoggingParameters::IsInitialized() const {
  return true;
}

void LoggingParameters::InternalSwap(LoggingParameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &session_id_, lhs_arena,
      &other->session_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &email_, lhs_arena,
      &other->email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_instance_id_, lhs_arena,
      &other->client_instance_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &root_event_id_, lhs_arena,
      &other->root_event_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoggingParameters, view_actions_enabled_)
      + sizeof(LoggingParameters::view_actions_enabled_)
      - PROTOBUF_FIELD_OFFSET(LoggingParameters, logging_enabled_)>(
          reinterpret_cast<char*>(&logging_enabled_),
          reinterpret_cast<char*>(&other->logging_enabled_));
}

std::string LoggingParameters::GetTypeName() const {
  return "feedui.LoggingParameters";
}


// ===================================================================

class Slice::_Internal {
 public:
  static const ::feedui::XSurfaceSlice& xsurface_slice(const Slice* msg);
  static const ::feedui::ZeroStateSlice& zero_state_slice(const Slice* msg);
  static const ::feedui::LoadingSpinnerSlice& loading_spinner_slice(const Slice* msg);
};

const ::feedui::XSurfaceSlice&
Slice::_Internal::xsurface_slice(const Slice* msg) {
  return *msg->SliceData_.xsurface_slice_;
}
const ::feedui::ZeroStateSlice&
Slice::_Internal::zero_state_slice(const Slice* msg) {
  return *msg->SliceData_.zero_state_slice_;
}
const ::feedui::LoadingSpinnerSlice&
Slice::_Internal::loading_spinner_slice(const Slice* msg) {
  return *msg->SliceData_.loading_spinner_slice_;
}
void Slice::set_allocated_xsurface_slice(::feedui::XSurfaceSlice* xsurface_slice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_SliceData();
  if (xsurface_slice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xsurface_slice);
    if (message_arena != submessage_arena) {
      xsurface_slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xsurface_slice, submessage_arena);
    }
    set_has_xsurface_slice();
    SliceData_.xsurface_slice_ = xsurface_slice;
  }
  // @@protoc_insertion_point(field_set_allocated:feedui.Slice.xsurface_slice)
}
void Slice::set_allocated_zero_state_slice(::feedui::ZeroStateSlice* zero_state_slice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_SliceData();
  if (zero_state_slice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zero_state_slice);
    if (message_arena != submessage_arena) {
      zero_state_slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zero_state_slice, submessage_arena);
    }
    set_has_zero_state_slice();
    SliceData_.zero_state_slice_ = zero_state_slice;
  }
  // @@protoc_insertion_point(field_set_allocated:feedui.Slice.zero_state_slice)
}
void Slice::set_allocated_loading_spinner_slice(::feedui::LoadingSpinnerSlice* loading_spinner_slice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_SliceData();
  if (loading_spinner_slice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loading_spinner_slice);
    if (message_arena != submessage_arena) {
      loading_spinner_slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loading_spinner_slice, submessage_arena);
    }
    set_has_loading_spinner_slice();
    SliceData_.loading_spinner_slice_ = loading_spinner_slice;
  }
  // @@protoc_insertion_point(field_set_allocated:feedui.Slice.loading_spinner_slice)
}
Slice::Slice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.Slice)
}
Slice::Slice(const Slice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  slice_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    slice_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_slice_id().empty()) {
    slice_id_.Set(from._internal_slice_id(), 
      GetArenaForAllocation());
  }
  clear_has_SliceData();
  switch (from.SliceData_case()) {
    case kXsurfaceSlice: {
      _internal_mutable_xsurface_slice()->::feedui::XSurfaceSlice::MergeFrom(from._internal_xsurface_slice());
      break;
    }
    case kZeroStateSlice: {
      _internal_mutable_zero_state_slice()->::feedui::ZeroStateSlice::MergeFrom(from._internal_zero_state_slice());
      break;
    }
    case kLoadingSpinnerSlice: {
      _internal_mutable_loading_spinner_slice()->::feedui::LoadingSpinnerSlice::MergeFrom(from._internal_loading_spinner_slice());
      break;
    }
    case SLICEDATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:feedui.Slice)
}

inline void Slice::SharedCtor() {
slice_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  slice_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_SliceData();
}

Slice::~Slice() {
  // @@protoc_insertion_point(destructor:feedui.Slice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Slice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  slice_id_.Destroy();
  if (has_SliceData()) {
    clear_SliceData();
  }
}

void Slice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Slice::clear_SliceData() {
// @@protoc_insertion_point(one_of_clear_start:feedui.Slice)
  switch (SliceData_case()) {
    case kXsurfaceSlice: {
      if (GetArenaForAllocation() == nullptr) {
        delete SliceData_.xsurface_slice_;
      }
      break;
    }
    case kZeroStateSlice: {
      if (GetArenaForAllocation() == nullptr) {
        delete SliceData_.zero_state_slice_;
      }
      break;
    }
    case kLoadingSpinnerSlice: {
      if (GetArenaForAllocation() == nullptr) {
        delete SliceData_.loading_spinner_slice_;
      }
      break;
    }
    case SLICEDATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SLICEDATA_NOT_SET;
}


void Slice::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.Slice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slice_id_.ClearToEmpty();
  clear_SliceData();
  _internal_metadata_.Clear<std::string>();
}

const char* Slice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .feedui.XSurfaceSlice xsurface_slice = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_xsurface_slice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string slice_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_slice_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .feedui.ZeroStateSlice zero_state_slice = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_zero_state_slice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .feedui.LoadingSpinnerSlice loading_spinner_slice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_loading_spinner_slice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Slice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.Slice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .feedui.XSurfaceSlice xsurface_slice = 1;
  if (_internal_has_xsurface_slice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::xsurface_slice(this),
        _Internal::xsurface_slice(this).GetCachedSize(), target, stream);
  }

  // string slice_id = 2;
  if (!this->_internal_slice_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_slice_id().data(), static_cast<int>(this->_internal_slice_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "feedui.Slice.slice_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_slice_id(), target);
  }

  // .feedui.ZeroStateSlice zero_state_slice = 3;
  if (_internal_has_zero_state_slice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::zero_state_slice(this),
        _Internal::zero_state_slice(this).GetCachedSize(), target, stream);
  }

  // .feedui.LoadingSpinnerSlice loading_spinner_slice = 4;
  if (_internal_has_loading_spinner_slice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::loading_spinner_slice(this),
        _Internal::loading_spinner_slice(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.Slice)
  return target;
}

size_t Slice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.Slice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string slice_id = 2;
  if (!this->_internal_slice_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_slice_id());
  }

  switch (SliceData_case()) {
    // .feedui.XSurfaceSlice xsurface_slice = 1;
    case kXsurfaceSlice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *SliceData_.xsurface_slice_);
      break;
    }
    // .feedui.ZeroStateSlice zero_state_slice = 3;
    case kZeroStateSlice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *SliceData_.zero_state_slice_);
      break;
    }
    // .feedui.LoadingSpinnerSlice loading_spinner_slice = 4;
    case kLoadingSpinnerSlice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *SliceData_.loading_spinner_slice_);
      break;
    }
    case SLICEDATA_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Slice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Slice*>(
      &from));
}

void Slice::MergeFrom(const Slice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.Slice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_slice_id().empty()) {
    _internal_set_slice_id(from._internal_slice_id());
  }
  switch (from.SliceData_case()) {
    case kXsurfaceSlice: {
      _internal_mutable_xsurface_slice()->::feedui::XSurfaceSlice::MergeFrom(from._internal_xsurface_slice());
      break;
    }
    case kZeroStateSlice: {
      _internal_mutable_zero_state_slice()->::feedui::ZeroStateSlice::MergeFrom(from._internal_zero_state_slice());
      break;
    }
    case kLoadingSpinnerSlice: {
      _internal_mutable_loading_spinner_slice()->::feedui::LoadingSpinnerSlice::MergeFrom(from._internal_loading_spinner_slice());
      break;
    }
    case SLICEDATA_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Slice::CopyFrom(const Slice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.Slice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Slice::IsInitialized() const {
  return true;
}

void Slice::InternalSwap(Slice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &slice_id_, lhs_arena,
      &other->slice_id_, rhs_arena
  );
  swap(SliceData_, other->SliceData_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Slice::GetTypeName() const {
  return "feedui.Slice";
}


// ===================================================================

class ZeroStateSlice::_Internal {
 public:
};

ZeroStateSlice::ZeroStateSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.ZeroStateSlice)
}
ZeroStateSlice::ZeroStateSlice(const ZeroStateSlice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:feedui.ZeroStateSlice)
}

inline void ZeroStateSlice::SharedCtor() {
type_ = 0;
}

ZeroStateSlice::~ZeroStateSlice() {
  // @@protoc_insertion_point(destructor:feedui.ZeroStateSlice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ZeroStateSlice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ZeroStateSlice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ZeroStateSlice::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.ZeroStateSlice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ZeroStateSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .feedui.ZeroStateSlice.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::feedui::ZeroStateSlice_Type>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ZeroStateSlice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.ZeroStateSlice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .feedui.ZeroStateSlice.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.ZeroStateSlice)
  return target;
}

size_t ZeroStateSlice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.ZeroStateSlice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .feedui.ZeroStateSlice.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ZeroStateSlice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ZeroStateSlice*>(
      &from));
}

void ZeroStateSlice::MergeFrom(const ZeroStateSlice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.ZeroStateSlice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ZeroStateSlice::CopyFrom(const ZeroStateSlice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.ZeroStateSlice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZeroStateSlice::IsInitialized() const {
  return true;
}

void ZeroStateSlice::InternalSwap(ZeroStateSlice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
}

std::string ZeroStateSlice::GetTypeName() const {
  return "feedui.ZeroStateSlice";
}


// ===================================================================

class LoadingSpinnerSlice::_Internal {
 public:
};

LoadingSpinnerSlice::LoadingSpinnerSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.LoadingSpinnerSlice)
}
LoadingSpinnerSlice::LoadingSpinnerSlice(const LoadingSpinnerSlice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  is_at_top_ = from.is_at_top_;
  // @@protoc_insertion_point(copy_constructor:feedui.LoadingSpinnerSlice)
}

inline void LoadingSpinnerSlice::SharedCtor() {
is_at_top_ = false;
}

LoadingSpinnerSlice::~LoadingSpinnerSlice() {
  // @@protoc_insertion_point(destructor:feedui.LoadingSpinnerSlice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadingSpinnerSlice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoadingSpinnerSlice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoadingSpinnerSlice::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.LoadingSpinnerSlice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  is_at_top_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* LoadingSpinnerSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool is_at_top = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          is_at_top_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadingSpinnerSlice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.LoadingSpinnerSlice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_at_top = 1;
  if (this->_internal_is_at_top() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_at_top(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.LoadingSpinnerSlice)
  return target;
}

size_t LoadingSpinnerSlice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.LoadingSpinnerSlice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool is_at_top = 1;
  if (this->_internal_is_at_top() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoadingSpinnerSlice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoadingSpinnerSlice*>(
      &from));
}

void LoadingSpinnerSlice::MergeFrom(const LoadingSpinnerSlice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.LoadingSpinnerSlice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_is_at_top() != 0) {
    _internal_set_is_at_top(from._internal_is_at_top());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoadingSpinnerSlice::CopyFrom(const LoadingSpinnerSlice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.LoadingSpinnerSlice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadingSpinnerSlice::IsInitialized() const {
  return true;
}

void LoadingSpinnerSlice::InternalSwap(LoadingSpinnerSlice* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(is_at_top_, other->is_at_top_);
}

std::string LoadingSpinnerSlice::GetTypeName() const {
  return "feedui.LoadingSpinnerSlice";
}


// ===================================================================

class XSurfaceSlice::_Internal {
 public:
};

XSurfaceSlice::XSurfaceSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.XSurfaceSlice)
}
XSurfaceSlice::XSurfaceSlice(const XSurfaceSlice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  xsurface_frame_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    xsurface_frame_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_xsurface_frame().empty()) {
    xsurface_frame_.Set(from._internal_xsurface_frame(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:feedui.XSurfaceSlice)
}

inline void XSurfaceSlice::SharedCtor() {
xsurface_frame_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  xsurface_frame_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

XSurfaceSlice::~XSurfaceSlice() {
  // @@protoc_insertion_point(destructor:feedui.XSurfaceSlice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void XSurfaceSlice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  xsurface_frame_.Destroy();
}

void XSurfaceSlice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void XSurfaceSlice::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.XSurfaceSlice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  xsurface_frame_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* XSurfaceSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes xsurface_frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_xsurface_frame();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* XSurfaceSlice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.XSurfaceSlice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes xsurface_frame = 1;
  if (!this->_internal_xsurface_frame().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_xsurface_frame(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.XSurfaceSlice)
  return target;
}

size_t XSurfaceSlice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.XSurfaceSlice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes xsurface_frame = 1;
  if (!this->_internal_xsurface_frame().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_xsurface_frame());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void XSurfaceSlice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const XSurfaceSlice*>(
      &from));
}

void XSurfaceSlice::MergeFrom(const XSurfaceSlice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.XSurfaceSlice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_xsurface_frame().empty()) {
    _internal_set_xsurface_frame(from._internal_xsurface_frame());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void XSurfaceSlice::CopyFrom(const XSurfaceSlice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.XSurfaceSlice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XSurfaceSlice::IsInitialized() const {
  return true;
}

void XSurfaceSlice::InternalSwap(XSurfaceSlice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &xsurface_frame_, lhs_arena,
      &other->xsurface_frame_, rhs_arena
  );
}

std::string XSurfaceSlice::GetTypeName() const {
  return "feedui.XSurfaceSlice";
}


// ===================================================================

class SharedState::_Internal {
 public:
};

SharedState::SharedState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:feedui.SharedState)
}
SharedState::SharedState(const SharedState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    id_.Set(from._internal_id(), 
      GetArenaForAllocation());
  }
  xsurface_shared_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    xsurface_shared_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_xsurface_shared_state().empty()) {
    xsurface_shared_state_.Set(from._internal_xsurface_shared_state(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:feedui.SharedState)
}

inline void SharedState::SharedCtor() {
id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
xsurface_shared_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  xsurface_shared_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SharedState::~SharedState() {
  // @@protoc_insertion_point(destructor:feedui.SharedState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SharedState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_.Destroy();
  xsurface_shared_state_.Destroy();
}

void SharedState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SharedState::Clear() {
// @@protoc_insertion_point(message_clear_start:feedui.SharedState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_.ClearToEmpty();
  xsurface_shared_state_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* SharedState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes xsurface_shared_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_xsurface_shared_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SharedState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:feedui.SharedState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "feedui.SharedState.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // bytes xsurface_shared_state = 2;
  if (!this->_internal_xsurface_shared_state().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_xsurface_shared_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:feedui.SharedState)
  return target;
}

size_t SharedState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:feedui.SharedState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string id = 1;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // bytes xsurface_shared_state = 2;
  if (!this->_internal_xsurface_shared_state().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_xsurface_shared_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SharedState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SharedState*>(
      &from));
}

void SharedState::MergeFrom(const SharedState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:feedui.SharedState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _internal_set_id(from._internal_id());
  }
  if (!from._internal_xsurface_shared_state().empty()) {
    _internal_set_xsurface_shared_state(from._internal_xsurface_shared_state());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SharedState::CopyFrom(const SharedState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:feedui.SharedState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SharedState::IsInitialized() const {
  return true;
}

void SharedState::InternalSwap(SharedState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_, lhs_arena,
      &other->id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &xsurface_shared_state_, lhs_arena,
      &other->xsurface_shared_state_, rhs_arena
  );
}

std::string SharedState::GetTypeName() const {
  return "feedui.SharedState";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace feedui
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::feedui::StreamUpdate_SliceUpdate*
Arena::CreateMaybeMessage< ::feedui::StreamUpdate_SliceUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::StreamUpdate_SliceUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::StreamUpdate*
Arena::CreateMaybeMessage< ::feedui::StreamUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::StreamUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::LoggingParameters*
Arena::CreateMaybeMessage< ::feedui::LoggingParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::LoggingParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::Slice*
Arena::CreateMaybeMessage< ::feedui::Slice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::Slice >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::ZeroStateSlice*
Arena::CreateMaybeMessage< ::feedui::ZeroStateSlice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::ZeroStateSlice >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::LoadingSpinnerSlice*
Arena::CreateMaybeMessage< ::feedui::LoadingSpinnerSlice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::LoadingSpinnerSlice >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::XSurfaceSlice*
Arena::CreateMaybeMessage< ::feedui::XSurfaceSlice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::XSurfaceSlice >(arena);
}
template<> PROTOBUF_NOINLINE ::feedui::SharedState*
Arena::CreateMaybeMessage< ::feedui::SharedState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::feedui::SharedState >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
