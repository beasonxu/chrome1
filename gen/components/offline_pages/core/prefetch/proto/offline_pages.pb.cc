// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: offline_pages.proto

#include "offline_pages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace offline_pages {
namespace proto {
PROTOBUF_CONSTEXPR Timestamp::Timestamp(
    ::_pbi::ConstantInitialized)
  : seconds_(int64_t{0})
  , nanos_(0){}
struct TimestampDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampDefaultTypeInternal() {}
  union {
    Timestamp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampDefaultTypeInternal _Timestamp_default_instance_;
PROTOBUF_CONSTEXPR PageBundle::PageBundle(
    ::_pbi::ConstantInitialized)
  : archives_(){}
struct PageBundleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PageBundleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PageBundleDefaultTypeInternal() {}
  union {
    PageBundle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageBundleDefaultTypeInternal _PageBundle_default_instance_;
PROTOBUF_CONSTEXPR Archive::Archive(
    ::_pbi::ConstantInitialized)
  : page_infos_()
  , body_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , body_length_(int64_t{0})
  , output_format_(0)
{}
struct ArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArchiveDefaultTypeInternal() {}
  union {
    Archive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArchiveDefaultTypeInternal _Archive_default_instance_;
PROTOBUF_CONSTEXPR PageInfo::PageInfo(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , redirect_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , status_(nullptr)
  , render_time_(nullptr)
  , transformation_(0)
{}
struct PageInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PageInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PageInfoDefaultTypeInternal() {}
  union {
    PageInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageInfoDefaultTypeInternal _PageInfo_default_instance_;
PROTOBUF_CONSTEXPR GeneratePageBundleRequest::GeneratePageBundleRequest(
    ::_pbi::ConstantInitialized)
  : browser_languages_()
  , pages_()
  , user_agent_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , gcm_registration_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , max_bundle_size_bytes_(int64_t{0})
  , output_format_(0)
{}
struct GeneratePageBundleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeneratePageBundleRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeneratePageBundleRequestDefaultTypeInternal() {}
  union {
    GeneratePageBundleRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeneratePageBundleRequestDefaultTypeInternal _GeneratePageBundleRequest_default_instance_;
PROTOBUF_CONSTEXPR PageParameters::PageParameters(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , transformation_(0)
{}
struct PageParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PageParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PageParametersDefaultTypeInternal() {}
  union {
    PageParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageParametersDefaultTypeInternal _PageParameters_default_instance_;
}  // namespace proto
}  // namespace offline_pages
namespace offline_pages {
namespace proto {
bool Transformation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Transformation_strings[2] = {};

static const char Transformation_names[] =
  "NO_TRANSFORMATION"
  "TRANSFORMATION_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Transformation_entries[] = {
  { {Transformation_names + 0, 17}, 1 },
  { {Transformation_names + 17, 26}, 0 },
};

static const int Transformation_entries_by_number[] = {
  1, // 0 -> TRANSFORMATION_UNSPECIFIED
  0, // 1 -> NO_TRANSFORMATION
};

const std::string& Transformation_Name(
    Transformation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Transformation_entries,
          Transformation_entries_by_number,
          2, Transformation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Transformation_entries,
      Transformation_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Transformation_strings[idx].get();
}
bool Transformation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transformation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Transformation_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Transformation>(int_value);
  }
  return success;
}
bool OutputFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OutputFormat_strings[2] = {};

static const char OutputFormat_names[] =
  "FORMAT_MHTML"
  "FORMAT_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OutputFormat_entries[] = {
  { {OutputFormat_names + 0, 12}, 1 },
  { {OutputFormat_names + 12, 18}, 0 },
};

static const int OutputFormat_entries_by_number[] = {
  1, // 0 -> FORMAT_UNSPECIFIED
  0, // 1 -> FORMAT_MHTML
};

const std::string& OutputFormat_Name(
    OutputFormat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OutputFormat_entries,
          OutputFormat_entries_by_number,
          2, OutputFormat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OutputFormat_entries,
      OutputFormat_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OutputFormat_strings[idx].get();
}
bool OutputFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutputFormat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OutputFormat_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<OutputFormat>(int_value);
  }
  return success;
}

// ===================================================================

class Timestamp::_Internal {
 public:
  using HasBits = decltype(std::declval<Timestamp>()._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nanos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Timestamp::Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:offline_pages.proto.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  // @@protoc_insertion_point(copy_constructor:offline_pages.proto.Timestamp)
}

inline void Timestamp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
}

Timestamp::~Timestamp() {
  // @@protoc_insertion_point(destructor:offline_pages.proto.Timestamp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Timestamp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Timestamp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Timestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:offline_pages.proto.Timestamp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nanos_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Timestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nanos(&has_bits);
          nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Timestamp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:offline_pages.proto.Timestamp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // optional int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:offline_pages.proto.Timestamp)
  return target;
}

size_t Timestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:offline_pages.proto.Timestamp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // optional int32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Timestamp::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Timestamp*>(
      &from));
}

void Timestamp::MergeFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:offline_pages.proto.Timestamp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nanos_ = from.nanos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Timestamp::CopyFrom(const Timestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:offline_pages.proto.Timestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamp::IsInitialized() const {
  return true;
}

void Timestamp::InternalSwap(Timestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Timestamp, nanos_)
      + sizeof(Timestamp::nanos_)
      - PROTOBUF_FIELD_OFFSET(Timestamp, seconds_)>(
          reinterpret_cast<char*>(&seconds_),
          reinterpret_cast<char*>(&other->seconds_));
}

std::string Timestamp::GetTypeName() const {
  return "offline_pages.proto.Timestamp";
}


// ===================================================================

class PageBundle::_Internal {
 public:
};

PageBundle::PageBundle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  archives_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:offline_pages.proto.PageBundle)
}
PageBundle::PageBundle(const PageBundle& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      archives_(from.archives_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:offline_pages.proto.PageBundle)
}

inline void PageBundle::SharedCtor() {
}

PageBundle::~PageBundle() {
  // @@protoc_insertion_point(destructor:offline_pages.proto.PageBundle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PageBundle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PageBundle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PageBundle::Clear() {
// @@protoc_insertion_point(message_clear_start:offline_pages.proto.PageBundle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  archives_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PageBundle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .offline_pages.proto.Archive archives = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_archives(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PageBundle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:offline_pages.proto.PageBundle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .offline_pages.proto.Archive archives = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_archives_size()); i < n; i++) {
    const auto& repfield = this->_internal_archives(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:offline_pages.proto.PageBundle)
  return target;
}

size_t PageBundle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:offline_pages.proto.PageBundle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .offline_pages.proto.Archive archives = 1;
  total_size += 1UL * this->_internal_archives_size();
  for (const auto& msg : this->archives_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PageBundle::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PageBundle*>(
      &from));
}

void PageBundle::MergeFrom(const PageBundle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:offline_pages.proto.PageBundle)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  archives_.MergeFrom(from.archives_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageBundle::CopyFrom(const PageBundle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:offline_pages.proto.PageBundle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PageBundle::IsInitialized() const {
  return true;
}

void PageBundle::InternalSwap(PageBundle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  archives_.InternalSwap(&other->archives_);
}

std::string PageBundle::GetTypeName() const {
  return "offline_pages.proto.PageBundle";
}


// ===================================================================

class Archive::_Internal {
 public:
  using HasBits = decltype(std::declval<Archive>()._has_bits_);
  static void set_has_output_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_body_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_body_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Archive::Archive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  page_infos_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:offline_pages.proto.Archive)
}
Archive::Archive(const Archive& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      page_infos_(from.page_infos_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  body_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    body_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body_name()) {
    body_name_.Set(from._internal_body_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&body_length_, &from.body_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&output_format_) -
    reinterpret_cast<char*>(&body_length_)) + sizeof(output_format_));
  // @@protoc_insertion_point(copy_constructor:offline_pages.proto.Archive)
}

inline void Archive::SharedCtor() {
body_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  body_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&body_length_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&output_format_) -
    reinterpret_cast<char*>(&body_length_)) + sizeof(output_format_));
}

Archive::~Archive() {
  // @@protoc_insertion_point(destructor:offline_pages.proto.Archive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Archive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  body_name_.Destroy();
}

void Archive::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Archive::Clear() {
// @@protoc_insertion_point(message_clear_start:offline_pages.proto.Archive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  page_infos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    body_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&body_length_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&output_format_) -
        reinterpret_cast<char*>(&body_length_)) + sizeof(output_format_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Archive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .offline_pages.proto.PageInfo page_infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_page_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .offline_pages.proto.OutputFormat output_format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::offline_pages::proto::OutputFormat_IsValid(val))) {
            _internal_set_output_format(static_cast<::offline_pages::proto::OutputFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string body_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_body_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 body_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_body_length(&has_bits);
          body_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Archive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:offline_pages.proto.Archive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .offline_pages.proto.PageInfo page_infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_page_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_page_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .offline_pages.proto.OutputFormat output_format = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_output_format(), target);
  }

  // optional string body_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_body_name(), target);
  }

  // optional int64 body_length = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_body_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:offline_pages.proto.Archive)
  return target;
}

size_t Archive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:offline_pages.proto.Archive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .offline_pages.proto.PageInfo page_infos = 1;
  total_size += 1UL * this->_internal_page_infos_size();
  for (const auto& msg : this->page_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string body_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_body_name());
    }

    // optional int64 body_length = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_body_length());
    }

    // optional .offline_pages.proto.OutputFormat output_format = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_output_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Archive::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Archive*>(
      &from));
}

void Archive::MergeFrom(const Archive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:offline_pages.proto.Archive)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  page_infos_.MergeFrom(from.page_infos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_body_name(from._internal_body_name());
    }
    if (cached_has_bits & 0x00000002u) {
      body_length_ = from.body_length_;
    }
    if (cached_has_bits & 0x00000004u) {
      output_format_ = from.output_format_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Archive::CopyFrom(const Archive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:offline_pages.proto.Archive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Archive::IsInitialized() const {
  return true;
}

void Archive::InternalSwap(Archive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  page_infos_.InternalSwap(&other->page_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &body_name_, lhs_arena,
      &other->body_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Archive, output_format_)
      + sizeof(Archive::output_format_)
      - PROTOBUF_FIELD_OFFSET(Archive, body_length_)>(
          reinterpret_cast<char*>(&body_length_),
          reinterpret_cast<char*>(&other->body_length_));
}

std::string Archive::GetTypeName() const {
  return "offline_pages.proto.Archive";
}


// ===================================================================

class PageInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PageInfo>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_redirect_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::offline_pages::proto::Status& status(const PageInfo* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_transformation(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::offline_pages::proto::Timestamp& render_time(const PageInfo* msg);
  static void set_has_render_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::offline_pages::proto::Status&
PageInfo::_Internal::status(const PageInfo* msg) {
  return *msg->status_;
}
const ::offline_pages::proto::Timestamp&
PageInfo::_Internal::render_time(const PageInfo* msg) {
  return *msg->render_time_;
}
void PageInfo::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
PageInfo::PageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:offline_pages.proto.PageInfo)
}
PageInfo::PageInfo(const PageInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  redirect_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    redirect_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_redirect_url()) {
    redirect_url_.Set(from._internal_redirect_url(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_status()) {
    status_ = new ::offline_pages::proto::Status(*from.status_);
  } else {
    status_ = nullptr;
  }
  if (from._internal_has_render_time()) {
    render_time_ = new ::offline_pages::proto::Timestamp(*from.render_time_);
  } else {
    render_time_ = nullptr;
  }
  transformation_ = from.transformation_;
  // @@protoc_insertion_point(copy_constructor:offline_pages.proto.PageInfo)
}

inline void PageInfo::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
redirect_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  redirect_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transformation_) -
    reinterpret_cast<char*>(&status_)) + sizeof(transformation_));
}

PageInfo::~PageInfo() {
  // @@protoc_insertion_point(destructor:offline_pages.proto.PageInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PageInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  redirect_url_.Destroy();
  if (this != internal_default_instance()) delete status_;
  if (this != internal_default_instance()) delete render_time_;
}

void PageInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PageInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:offline_pages.proto.PageInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      redirect_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(render_time_ != nullptr);
      render_time_->Clear();
    }
  }
  transformation_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PageInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string redirect_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_redirect_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .offline_pages.proto.Status status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .offline_pages.proto.Transformation transformation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::offline_pages::proto::Transformation_IsValid(val))) {
            _internal_set_transformation(static_cast<::offline_pages::proto::Transformation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .offline_pages.proto.Timestamp render_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_render_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PageInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:offline_pages.proto.PageInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string redirect_url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_redirect_url(), target);
  }

  // optional .offline_pages.proto.Status status = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  // optional .offline_pages.proto.Transformation transformation = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_transformation(), target);
  }

  // optional .offline_pages.proto.Timestamp render_time = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::render_time(this),
        _Internal::render_time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:offline_pages.proto.PageInfo)
  return target;
}

size_t PageInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:offline_pages.proto.PageInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string redirect_url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_redirect_url());
    }

    // optional .offline_pages.proto.Status status = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

    // optional .offline_pages.proto.Timestamp render_time = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *render_time_);
    }

    // optional .offline_pages.proto.Transformation transformation = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_transformation());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PageInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PageInfo*>(
      &from));
}

void PageInfo::MergeFrom(const PageInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:offline_pages.proto.PageInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_redirect_url(from._internal_redirect_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_status()->::offline_pages::proto::Status::MergeFrom(from._internal_status());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_render_time()->::offline_pages::proto::Timestamp::MergeFrom(from._internal_render_time());
    }
    if (cached_has_bits & 0x00000010u) {
      transformation_ = from.transformation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageInfo::CopyFrom(const PageInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:offline_pages.proto.PageInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PageInfo::IsInitialized() const {
  return true;
}

void PageInfo::InternalSwap(PageInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &redirect_url_, lhs_arena,
      &other->redirect_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PageInfo, transformation_)
      + sizeof(PageInfo::transformation_)
      - PROTOBUF_FIELD_OFFSET(PageInfo, status_)>(
          reinterpret_cast<char*>(&status_),
          reinterpret_cast<char*>(&other->status_));
}

std::string PageInfo::GetTypeName() const {
  return "offline_pages.proto.PageInfo";
}


// ===================================================================

class GeneratePageBundleRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GeneratePageBundleRequest>()._has_bits_);
  static void set_has_user_agent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_output_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_bundle_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gcm_registration_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GeneratePageBundleRequest::GeneratePageBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  browser_languages_(arena),
  pages_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:offline_pages.proto.GeneratePageBundleRequest)
}
GeneratePageBundleRequest::GeneratePageBundleRequest(const GeneratePageBundleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      browser_languages_(from.browser_languages_),
      pages_(from.pages_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  user_agent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_agent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_agent()) {
    user_agent_.Set(from._internal_user_agent(), 
      GetArenaForAllocation());
  }
  gcm_registration_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gcm_registration_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gcm_registration_id()) {
    gcm_registration_id_.Set(from._internal_gcm_registration_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&max_bundle_size_bytes_, &from.max_bundle_size_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&output_format_) -
    reinterpret_cast<char*>(&max_bundle_size_bytes_)) + sizeof(output_format_));
  // @@protoc_insertion_point(copy_constructor:offline_pages.proto.GeneratePageBundleRequest)
}

inline void GeneratePageBundleRequest::SharedCtor() {
user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
gcm_registration_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gcm_registration_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_bundle_size_bytes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&output_format_) -
    reinterpret_cast<char*>(&max_bundle_size_bytes_)) + sizeof(output_format_));
}

GeneratePageBundleRequest::~GeneratePageBundleRequest() {
  // @@protoc_insertion_point(destructor:offline_pages.proto.GeneratePageBundleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeneratePageBundleRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_agent_.Destroy();
  gcm_registration_id_.Destroy();
}

void GeneratePageBundleRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeneratePageBundleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:offline_pages.proto.GeneratePageBundleRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  browser_languages_.Clear();
  pages_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_agent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      gcm_registration_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&max_bundle_size_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&output_format_) -
        reinterpret_cast<char*>(&max_bundle_size_bytes_)) + sizeof(output_format_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GeneratePageBundleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_agent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_agent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string browser_languages = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_browser_languages();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .offline_pages.proto.OutputFormat output_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::offline_pages::proto::OutputFormat_IsValid(val))) {
            _internal_set_output_format(static_cast<::offline_pages::proto::OutputFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_bundle_size_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_bundle_size_bytes(&has_bits);
          max_bundle_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string gcm_registration_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gcm_registration_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .offline_pages.proto.PageParameters pages = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeneratePageBundleRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:offline_pages.proto.GeneratePageBundleRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_agent = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_agent(), target);
  }

  // repeated string browser_languages = 2;
  for (int i = 0, n = this->_internal_browser_languages_size(); i < n; i++) {
    const auto& s = this->_internal_browser_languages(i);
    target = stream->WriteString(2, s, target);
  }

  // optional .offline_pages.proto.OutputFormat output_format = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_output_format(), target);
  }

  // optional int64 max_bundle_size_bytes = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_max_bundle_size_bytes(), target);
  }

  // optional string gcm_registration_id = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gcm_registration_id(), target);
  }

  // repeated .offline_pages.proto.PageParameters pages = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pages_size()); i < n; i++) {
    const auto& repfield = this->_internal_pages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:offline_pages.proto.GeneratePageBundleRequest)
  return target;
}

size_t GeneratePageBundleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:offline_pages.proto.GeneratePageBundleRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string browser_languages = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(browser_languages_.size());
  for (int i = 0, n = browser_languages_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      browser_languages_.Get(i));
  }

  // repeated .offline_pages.proto.PageParameters pages = 6;
  total_size += 1UL * this->_internal_pages_size();
  for (const auto& msg : this->pages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string user_agent = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_agent());
    }

    // optional string gcm_registration_id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gcm_registration_id());
    }

    // optional int64 max_bundle_size_bytes = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_bundle_size_bytes());
    }

    // optional .offline_pages.proto.OutputFormat output_format = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_output_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GeneratePageBundleRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GeneratePageBundleRequest*>(
      &from));
}

void GeneratePageBundleRequest::MergeFrom(const GeneratePageBundleRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:offline_pages.proto.GeneratePageBundleRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  browser_languages_.MergeFrom(from.browser_languages_);
  pages_.MergeFrom(from.pages_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_agent(from._internal_user_agent());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_gcm_registration_id(from._internal_gcm_registration_id());
    }
    if (cached_has_bits & 0x00000004u) {
      max_bundle_size_bytes_ = from.max_bundle_size_bytes_;
    }
    if (cached_has_bits & 0x00000008u) {
      output_format_ = from.output_format_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeneratePageBundleRequest::CopyFrom(const GeneratePageBundleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:offline_pages.proto.GeneratePageBundleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeneratePageBundleRequest::IsInitialized() const {
  return true;
}

void GeneratePageBundleRequest::InternalSwap(GeneratePageBundleRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  browser_languages_.InternalSwap(&other->browser_languages_);
  pages_.InternalSwap(&other->pages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_agent_, lhs_arena,
      &other->user_agent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &gcm_registration_id_, lhs_arena,
      &other->gcm_registration_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeneratePageBundleRequest, output_format_)
      + sizeof(GeneratePageBundleRequest::output_format_)
      - PROTOBUF_FIELD_OFFSET(GeneratePageBundleRequest, max_bundle_size_bytes_)>(
          reinterpret_cast<char*>(&max_bundle_size_bytes_),
          reinterpret_cast<char*>(&other->max_bundle_size_bytes_));
}

std::string GeneratePageBundleRequest::GetTypeName() const {
  return "offline_pages.proto.GeneratePageBundleRequest";
}


// ===================================================================

class PageParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<PageParameters>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_transformation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PageParameters::PageParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:offline_pages.proto.PageParameters)
}
PageParameters::PageParameters(const PageParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  transformation_ = from.transformation_;
  // @@protoc_insertion_point(copy_constructor:offline_pages.proto.PageParameters)
}

inline void PageParameters::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
transformation_ = 0;
}

PageParameters::~PageParameters() {
  // @@protoc_insertion_point(destructor:offline_pages.proto.PageParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PageParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void PageParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PageParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:offline_pages.proto.PageParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  transformation_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PageParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .offline_pages.proto.Transformation transformation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::offline_pages::proto::Transformation_IsValid(val))) {
            _internal_set_transformation(static_cast<::offline_pages::proto::Transformation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PageParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:offline_pages.proto.PageParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional .offline_pages.proto.Transformation transformation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_transformation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:offline_pages.proto.PageParameters)
  return target;
}

size_t PageParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:offline_pages.proto.PageParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional .offline_pages.proto.Transformation transformation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_transformation());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PageParameters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PageParameters*>(
      &from));
}

void PageParameters::MergeFrom(const PageParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:offline_pages.proto.PageParameters)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      transformation_ = from.transformation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageParameters::CopyFrom(const PageParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:offline_pages.proto.PageParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PageParameters::IsInitialized() const {
  return true;
}

void PageParameters::InternalSwap(PageParameters* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  swap(transformation_, other->transformation_);
}

std::string PageParameters::GetTypeName() const {
  return "offline_pages.proto.PageParameters";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace offline_pages
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::offline_pages::proto::Timestamp*
Arena::CreateMaybeMessage< ::offline_pages::proto::Timestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::offline_pages::proto::Timestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::offline_pages::proto::PageBundle*
Arena::CreateMaybeMessage< ::offline_pages::proto::PageBundle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::offline_pages::proto::PageBundle >(arena);
}
template<> PROTOBUF_NOINLINE ::offline_pages::proto::Archive*
Arena::CreateMaybeMessage< ::offline_pages::proto::Archive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::offline_pages::proto::Archive >(arena);
}
template<> PROTOBUF_NOINLINE ::offline_pages::proto::PageInfo*
Arena::CreateMaybeMessage< ::offline_pages::proto::PageInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::offline_pages::proto::PageInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::offline_pages::proto::GeneratePageBundleRequest*
Arena::CreateMaybeMessage< ::offline_pages::proto::GeneratePageBundleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::offline_pages::proto::GeneratePageBundleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::offline_pages::proto::PageParameters*
Arena::CreateMaybeMessage< ::offline_pages::proto::PageParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::offline_pages::proto::PageParameters >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
