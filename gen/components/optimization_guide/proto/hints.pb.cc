// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/hints.proto

#include "components/optimization_guide/proto/hints.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace optimization_guide {
namespace proto {
PROTOBUF_CONSTEXPR MatchedHintInfo::MatchedHintInfo(
    ::_pbi::ConstantInitialized)
  : key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(int64_t{0})
  , key_representation_(0)
{}
struct MatchedHintInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MatchedHintInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MatchedHintInfoDefaultTypeInternal() {}
  union {
    MatchedHintInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchedHintInfoDefaultTypeInternal _MatchedHintInfo_default_instance_;
PROTOBUF_CONSTEXPR HostInfo::HostInfo(
    ::_pbi::ConstantInitialized)
  : host_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , matched_hint_(nullptr){}
struct HostInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HostInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HostInfoDefaultTypeInternal() {}
  union {
    HostInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostInfoDefaultTypeInternal _HostInfo_default_instance_;
PROTOBUF_CONSTEXPR UrlInfo::UrlInfo(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct UrlInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UrlInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UrlInfoDefaultTypeInternal() {}
  union {
    UrlInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UrlInfoDefaultTypeInternal _UrlInfo_default_instance_;
PROTOBUF_CONSTEXPR HashedHostInfos::HashedHostInfos(
    ::_pbi::ConstantInitialized)
  : partial_host_hashes_()
  , num_hash_bits_(0u){}
struct HashedHostInfosDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HashedHostInfosDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HashedHostInfosDefaultTypeInternal() {}
  union {
    HashedHostInfos _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashedHostInfosDefaultTypeInternal _HashedHostInfos_default_instance_;
PROTOBUF_CONSTEXPR GetHintsRequest::GetHintsRequest(
    ::_pbi::ConstantInitialized)
  : hosts_()
  , supported_optimizations_()
  , urls_()
  , supported_key_representations_()
  , locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hashed_hosts_(nullptr)
  , context_(0)
{}
struct GetHintsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetHintsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetHintsRequestDefaultTypeInternal() {}
  union {
    GetHintsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHintsRequestDefaultTypeInternal _GetHintsRequest_default_instance_;
PROTOBUF_CONSTEXPR GetHintsResponse::GetHintsResponse(
    ::_pbi::ConstantInitialized)
  : hints_()
  , hints_to_remove_()
  , max_cache_duration_(nullptr){}
struct GetHintsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetHintsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetHintsResponseDefaultTypeInternal() {}
  union {
    GetHintsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHintsResponseDefaultTypeInternal _GetHintsResponse_default_instance_;
PROTOBUF_CONSTEXPR Optimization::Optimization(
    ::_pbi::ConstantInitialized)
  : tuning_version_(uint64_t{0u})
  , optimization_type_(0)

  , _oneof_case_{}{}
struct OptimizationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptimizationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptimizationDefaultTypeInternal() {}
  union {
    Optimization _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationDefaultTypeInternal _Optimization_default_instance_;
PROTOBUF_CONSTEXPR PageHint::PageHint(
    ::_pbi::ConstantInitialized)
  : allowlisted_optimizations_()
  , page_pattern_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PageHintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PageHintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PageHintDefaultTypeInternal() {}
  union {
    PageHint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageHintDefaultTypeInternal _PageHint_default_instance_;
PROTOBUF_CONSTEXPR Hint::Hint(
    ::_pbi::ConstantInitialized)
  : allowlisted_optimizations_()
  , page_hints_()
  , key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , max_cache_duration_(nullptr)
  , key_representation_(0)
{}
struct HintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HintDefaultTypeInternal() {}
  union {
    Hint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HintDefaultTypeInternal _Hint_default_instance_;
PROTOBUF_CONSTEXPR BloomFilter::BloomFilter(
    ::_pbi::ConstantInitialized)
  : data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , num_hash_functions_(0u)
  , num_bits_(0u){}
struct BloomFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BloomFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BloomFilterDefaultTypeInternal() {}
  union {
    BloomFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BloomFilterDefaultTypeInternal _BloomFilter_default_instance_;
PROTOBUF_CONSTEXPR OptimizationFilter::OptimizationFilter(
    ::_pbi::ConstantInitialized)
  : regexps_()
  , exclusion_regexps_()
  , bloom_filter_(nullptr)
  , optimization_type_(0)

  , skip_host_suffix_checking_(false){}
struct OptimizationFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OptimizationFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OptimizationFilterDefaultTypeInternal() {}
  union {
    OptimizationFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationFilterDefaultTypeInternal _OptimizationFilter_default_instance_;
PROTOBUF_CONSTEXPR Configuration::Configuration(
    ::_pbi::ConstantInitialized)
  : hints_()
  , optimization_blocklists_()
  , optimization_allowlists_(){}
struct ConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigurationDefaultTypeInternal() {}
  union {
    Configuration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigurationDefaultTypeInternal _Configuration_default_instance_;
PROTOBUF_CONSTEXPR Version::Version(
    ::_pbi::ConstantInitialized)
  : generation_timestamp_(nullptr)
  , hint_source_(0)
{}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace proto
}  // namespace optimization_guide
namespace optimization_guide {
namespace proto {
bool OptimizationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OptimizationType_strings[24] = {};

static const char OptimizationType_names[] =
  "ABOUT_THIS_SITE"
  "BLOOM_FILTER_VALIDATION"
  "COMPRESS_PUBLIC_IMAGES"
  "DEFER_ALL_SCRIPT"
  "FAST_HOST_HINTS"
  "HISTORY_CLUSTERS"
  "IBAN_AUTOFILL_BLOCKED"
  "LINK_PERFORMANCE"
  "LITE_PAGE"
  "LITE_PAGE_REDIRECT"
  "LITE_VIDEO"
  "LOADING_PREDICTOR"
  "LOGIN_DETECTION"
  "MERCHANT_TRUST_SIGNALS"
  "MERCHANT_TRUST_SIGNALS_V2"
  "METADATA_FETCH_VALIDATION"
  "NOSCRIPT"
  "PAGE_ENTITIES"
  "PERFORMANCE_HINTS"
  "PRICE_TRACKING"
  "RESOURCE_LOADING"
  "SHOPPING_PAGE_PREDICTOR"
  "THANK_CREATOR_ELIGIBLE"
  "TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OptimizationType_entries[] = {
  { {OptimizationType_names + 0, 15}, 20 },
  { {OptimizationType_names + 15, 23}, 19 },
  { {OptimizationType_names + 38, 22}, 8 },
  { {OptimizationType_names + 60, 16}, 5 },
  { {OptimizationType_names + 76, 15}, 10 },
  { {OptimizationType_names + 91, 16}, 23 },
  { {OptimizationType_names + 107, 21}, 25 },
  { {OptimizationType_names + 128, 16}, 14 },
  { {OptimizationType_names + 144, 9}, 7 },
  { {OptimizationType_names + 153, 18}, 3 },
  { {OptimizationType_names + 171, 10}, 13 },
  { {OptimizationType_names + 181, 17}, 9 },
  { {OptimizationType_names + 198, 15}, 16 },
  { {OptimizationType_names + 213, 22}, 17 },
  { {OptimizationType_names + 235, 25}, 21 },
  { {OptimizationType_names + 260, 25}, 4 },
  { {OptimizationType_names + 285, 8}, 1 },
  { {OptimizationType_names + 293, 13}, 22 },
  { {OptimizationType_names + 306, 17}, 6 },
  { {OptimizationType_names + 323, 14}, 18 },
  { {OptimizationType_names + 337, 16}, 2 },
  { {OptimizationType_names + 353, 23}, 15 },
  { {OptimizationType_names + 376, 22}, 24 },
  { {OptimizationType_names + 398, 16}, 0 },
};

static const int OptimizationType_entries_by_number[] = {
  23, // 0 -> TYPE_UNSPECIFIED
  16, // 1 -> NOSCRIPT
  20, // 2 -> RESOURCE_LOADING
  9, // 3 -> LITE_PAGE_REDIRECT
  15, // 4 -> METADATA_FETCH_VALIDATION
  3, // 5 -> DEFER_ALL_SCRIPT
  18, // 6 -> PERFORMANCE_HINTS
  8, // 7 -> LITE_PAGE
  2, // 8 -> COMPRESS_PUBLIC_IMAGES
  11, // 9 -> LOADING_PREDICTOR
  4, // 10 -> FAST_HOST_HINTS
  10, // 13 -> LITE_VIDEO
  7, // 14 -> LINK_PERFORMANCE
  21, // 15 -> SHOPPING_PAGE_PREDICTOR
  12, // 16 -> LOGIN_DETECTION
  13, // 17 -> MERCHANT_TRUST_SIGNALS
  19, // 18 -> PRICE_TRACKING
  1, // 19 -> BLOOM_FILTER_VALIDATION
  0, // 20 -> ABOUT_THIS_SITE
  14, // 21 -> MERCHANT_TRUST_SIGNALS_V2
  17, // 22 -> PAGE_ENTITIES
  5, // 23 -> HISTORY_CLUSTERS
  22, // 24 -> THANK_CREATOR_ELIGIBLE
  6, // 25 -> IBAN_AUTOFILL_BLOCKED
};

const std::string& OptimizationType_Name(
    OptimizationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OptimizationType_entries,
          OptimizationType_entries_by_number,
          24, OptimizationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OptimizationType_entries,
      OptimizationType_entries_by_number,
      24, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OptimizationType_strings[idx].get();
}
bool OptimizationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptimizationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OptimizationType_entries, 24, name, &int_value);
  if (success) {
    *value = static_cast<OptimizationType>(int_value);
  }
  return success;
}
bool KeyRepresentation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KeyRepresentation_strings[5] = {};

static const char KeyRepresentation_names[] =
  "FULL_URL"
  "HASHED_HOST"
  "HOST"
  "HOST_SUFFIX"
  "REPRESENTATION_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KeyRepresentation_entries[] = {
  { {KeyRepresentation_names + 0, 8}, 2 },
  { {KeyRepresentation_names + 8, 11}, 4 },
  { {KeyRepresentation_names + 19, 4}, 3 },
  { {KeyRepresentation_names + 23, 11}, 1 },
  { {KeyRepresentation_names + 34, 26}, 0 },
};

static const int KeyRepresentation_entries_by_number[] = {
  4, // 0 -> REPRESENTATION_UNSPECIFIED
  3, // 1 -> HOST_SUFFIX
  0, // 2 -> FULL_URL
  2, // 3 -> HOST
  1, // 4 -> HASHED_HOST
};

const std::string& KeyRepresentation_Name(
    KeyRepresentation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          KeyRepresentation_entries,
          KeyRepresentation_entries_by_number,
          5, KeyRepresentation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      KeyRepresentation_entries,
      KeyRepresentation_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     KeyRepresentation_strings[idx].get();
}
bool KeyRepresentation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyRepresentation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      KeyRepresentation_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<KeyRepresentation>(int_value);
  }
  return success;
}
bool HintSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HintSource_strings[3] = {};

static const char HintSource_names[] =
  "HINT_SOURCE_OPTIMIZATION_GUIDE_SERVICE"
  "HINT_SOURCE_OPTIMIZATION_HINTS_COMPONENT"
  "HINT_SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HintSource_entries[] = {
  { {HintSource_names + 0, 38}, 2 },
  { {HintSource_names + 38, 40}, 1 },
  { {HintSource_names + 78, 19}, 0 },
};

static const int HintSource_entries_by_number[] = {
  2, // 0 -> HINT_SOURCE_UNKNOWN
  1, // 1 -> HINT_SOURCE_OPTIMIZATION_HINTS_COMPONENT
  0, // 2 -> HINT_SOURCE_OPTIMIZATION_GUIDE_SERVICE
};

const std::string& HintSource_Name(
    HintSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          HintSource_entries,
          HintSource_entries_by_number,
          3, HintSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      HintSource_entries,
      HintSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     HintSource_strings[idx].get();
}
bool HintSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HintSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      HintSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<HintSource>(int_value);
  }
  return success;
}

// ===================================================================

class MatchedHintInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MatchedHintInfo>()._has_bits_);
  static void set_has_key_representation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MatchedHintInfo::MatchedHintInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.MatchedHintInfo)
}
MatchedHintInfo::MatchedHintInfo(const MatchedHintInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&key_representation_) -
    reinterpret_cast<char*>(&version_)) + sizeof(key_representation_));
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.MatchedHintInfo)
}

inline void MatchedHintInfo::SharedCtor() {
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&key_representation_) -
    reinterpret_cast<char*>(&version_)) + sizeof(key_representation_));
}

MatchedHintInfo::~MatchedHintInfo() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.MatchedHintInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MatchedHintInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.Destroy();
}

void MatchedHintInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MatchedHintInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.MatchedHintInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    key_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&key_representation_) -
        reinterpret_cast<char*>(&version_)) + sizeof(key_representation_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MatchedHintInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::KeyRepresentation_IsValid(val))) {
            _internal_set_key_representation(static_cast<::optimization_guide::proto::KeyRepresentation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchedHintInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.MatchedHintInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_key_representation(), target);
  }

  // optional string key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  // optional int64 version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.MatchedHintInfo)
  return target;
}

size_t MatchedHintInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.MatchedHintInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional int64 version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

    // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_key_representation());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatchedHintInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MatchedHintInfo*>(
      &from));
}

void MatchedHintInfo::MergeFrom(const MatchedHintInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.MatchedHintInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      key_representation_ = from.key_representation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchedHintInfo::CopyFrom(const MatchedHintInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.MatchedHintInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchedHintInfo::IsInitialized() const {
  return true;
}

void MatchedHintInfo::InternalSwap(MatchedHintInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchedHintInfo, key_representation_)
      + sizeof(MatchedHintInfo::key_representation_)
      - PROTOBUF_FIELD_OFFSET(MatchedHintInfo, version_)>(
          reinterpret_cast<char*>(&version_),
          reinterpret_cast<char*>(&other->version_));
}

std::string MatchedHintInfo::GetTypeName() const {
  return "optimization_guide.proto.MatchedHintInfo";
}


// ===================================================================

class HostInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<HostInfo>()._has_bits_);
  static void set_has_host(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::optimization_guide::proto::MatchedHintInfo& matched_hint(const HostInfo* msg);
  static void set_has_matched_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::optimization_guide::proto::MatchedHintInfo&
HostInfo::_Internal::matched_hint(const HostInfo* msg) {
  return *msg->matched_hint_;
}
HostInfo::HostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.HostInfo)
}
HostInfo::HostInfo(const HostInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  host_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    host_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host()) {
    host_.Set(from._internal_host(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_matched_hint()) {
    matched_hint_ = new ::optimization_guide::proto::MatchedHintInfo(*from.matched_hint_);
  } else {
    matched_hint_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.HostInfo)
}

inline void HostInfo::SharedCtor() {
host_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  host_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
matched_hint_ = nullptr;
}

HostInfo::~HostInfo() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.HostInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HostInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  host_.Destroy();
  if (this != internal_default_instance()) delete matched_hint_;
}

void HostInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HostInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.HostInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      host_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(matched_hint_ != nullptr);
      matched_hint_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HostInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string host = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_host();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.MatchedHintInfo matched_hint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_matched_hint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HostInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.HostInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string host = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_host(), target);
  }

  // optional .optimization_guide.proto.MatchedHintInfo matched_hint = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::matched_hint(this),
        _Internal::matched_hint(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.HostInfo)
  return target;
}

size_t HostInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.HostInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string host = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host());
    }

    // optional .optimization_guide.proto.MatchedHintInfo matched_hint = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *matched_hint_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HostInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HostInfo*>(
      &from));
}

void HostInfo::MergeFrom(const HostInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.HostInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_host(from._internal_host());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_matched_hint()->::optimization_guide::proto::MatchedHintInfo::MergeFrom(from._internal_matched_hint());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostInfo::CopyFrom(const HostInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.HostInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HostInfo::IsInitialized() const {
  return true;
}

void HostInfo::InternalSwap(HostInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &host_, lhs_arena,
      &other->host_, rhs_arena
  );
  swap(matched_hint_, other->matched_hint_);
}

std::string HostInfo::GetTypeName() const {
  return "optimization_guide.proto.HostInfo";
}


// ===================================================================

class UrlInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UrlInfo>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UrlInfo::UrlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.UrlInfo)
}
UrlInfo::UrlInfo(const UrlInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.UrlInfo)
}

inline void UrlInfo::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UrlInfo::~UrlInfo() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.UrlInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UrlInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void UrlInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UrlInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.UrlInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UrlInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UrlInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.UrlInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.UrlInfo)
  return target;
}

size_t UrlInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.UrlInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string url = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UrlInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UrlInfo*>(
      &from));
}

void UrlInfo::MergeFrom(const UrlInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.UrlInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_url()) {
    _internal_set_url(from._internal_url());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UrlInfo::CopyFrom(const UrlInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.UrlInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UrlInfo::IsInitialized() const {
  return true;
}

void UrlInfo::InternalSwap(UrlInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
}

std::string UrlInfo::GetTypeName() const {
  return "optimization_guide.proto.UrlInfo";
}


// ===================================================================

class HashedHostInfos::_Internal {
 public:
  using HasBits = decltype(std::declval<HashedHostInfos>()._has_bits_);
  static void set_has_num_hash_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

HashedHostInfos::HashedHostInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  partial_host_hashes_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.HashedHostInfos)
}
HashedHostInfos::HashedHostInfos(const HashedHostInfos& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      partial_host_hashes_(from.partial_host_hashes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  num_hash_bits_ = from.num_hash_bits_;
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.HashedHostInfos)
}

inline void HashedHostInfos::SharedCtor() {
num_hash_bits_ = 0u;
}

HashedHostInfos::~HashedHostInfos() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.HashedHostInfos)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HashedHostInfos::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HashedHostInfos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HashedHostInfos::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.HashedHostInfos)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partial_host_hashes_.Clear();
  num_hash_bits_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HashedHostInfos::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 partial_host_hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_partial_host_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_partial_host_hashes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_hash_bits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_hash_bits(&has_bits);
          num_hash_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HashedHostInfos::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.HashedHostInfos)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 partial_host_hashes = 1;
  for (int i = 0, n = this->_internal_partial_host_hashes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_partial_host_hashes(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 num_hash_bits = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_hash_bits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.HashedHostInfos)
  return target;
}

size_t HashedHostInfos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.HashedHostInfos)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 partial_host_hashes = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->partial_host_hashes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_partial_host_hashes_size());
    total_size += data_size;
  }

  // optional uint32 num_hash_bits = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_hash_bits());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HashedHostInfos::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HashedHostInfos*>(
      &from));
}

void HashedHostInfos::MergeFrom(const HashedHostInfos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.HashedHostInfos)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  partial_host_hashes_.MergeFrom(from.partial_host_hashes_);
  if (from._internal_has_num_hash_bits()) {
    _internal_set_num_hash_bits(from._internal_num_hash_bits());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HashedHostInfos::CopyFrom(const HashedHostInfos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.HashedHostInfos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashedHostInfos::IsInitialized() const {
  return true;
}

void HashedHostInfos::InternalSwap(HashedHostInfos* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partial_host_hashes_.InternalSwap(&other->partial_host_hashes_);
  swap(num_hash_bits_, other->num_hash_bits_);
}

std::string HashedHostInfos::GetTypeName() const {
  return "optimization_guide.proto.HashedHostInfos";
}


// ===================================================================

class GetHintsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetHintsRequest>()._has_bits_);
  static const ::optimization_guide::proto::HashedHostInfos& hashed_hosts(const GetHintsRequest* msg);
  static void set_has_hashed_hosts(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::optimization_guide::proto::HashedHostInfos&
GetHintsRequest::_Internal::hashed_hosts(const GetHintsRequest* msg) {
  return *msg->hashed_hosts_;
}
GetHintsRequest::GetHintsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  hosts_(arena),
  supported_optimizations_(arena),
  urls_(arena),
  supported_key_representations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.GetHintsRequest)
}
GetHintsRequest::GetHintsRequest(const GetHintsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      hosts_(from.hosts_),
      supported_optimizations_(from.supported_optimizations_),
      urls_(from.urls_),
      supported_key_representations_(from.supported_key_representations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(from._internal_locale(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_hashed_hosts()) {
    hashed_hosts_ = new ::optimization_guide::proto::HashedHostInfos(*from.hashed_hosts_);
  } else {
    hashed_hosts_ = nullptr;
  }
  context_ = from.context_;
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.GetHintsRequest)
}

inline void GetHintsRequest::SharedCtor() {
locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hashed_hosts_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&context_) -
    reinterpret_cast<char*>(&hashed_hosts_)) + sizeof(context_));
}

GetHintsRequest::~GetHintsRequest() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.GetHintsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetHintsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.Destroy();
  if (this != internal_default_instance()) delete hashed_hosts_;
}

void GetHintsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetHintsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.GetHintsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hosts_.Clear();
  supported_optimizations_.Clear();
  urls_.Clear();
  supported_key_representations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(hashed_hosts_ != nullptr);
      hashed_hosts_->Clear();
    }
  }
  context_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetHintsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .optimization_guide.proto.HostInfo hosts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.OptimizationType supported_optimizations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationType_IsValid(val))) {
              _internal_add_supported_optimizations(static_cast<::optimization_guide::proto::OptimizationType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_optimizations(), ptr, ctx, ::optimization_guide::proto::OptimizationType_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.RequestContext context = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::RequestContext_IsValid(val))) {
            _internal_set_context(static_cast<::optimization_guide::proto::RequestContext>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.UrlInfo urls = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_urls(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.KeyRepresentation supported_key_representations = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::KeyRepresentation_IsValid(val))) {
              _internal_add_supported_key_representations(static_cast<::optimization_guide::proto::KeyRepresentation>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_key_representations(), ptr, ctx, ::optimization_guide::proto::KeyRepresentation_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.HashedHostInfos hashed_hosts = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_hashed_hosts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetHintsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.GetHintsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.HostInfo hosts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hosts_size()); i < n; i++) {
    const auto& repfield = this->_internal_hosts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .optimization_guide.proto.OptimizationType supported_optimizations = 2;
  for (int i = 0, n = this->_internal_supported_optimizations_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_supported_optimizations(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.RequestContext context = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_context(), target);
  }

  // repeated .optimization_guide.proto.UrlInfo urls = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_urls_size()); i < n; i++) {
    const auto& repfield = this->_internal_urls(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .optimization_guide.proto.KeyRepresentation supported_key_representations = 5;
  for (int i = 0, n = this->_internal_supported_key_representations_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_supported_key_representations(i), target);
  }

  // optional string locale = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_locale(), target);
  }

  // optional .optimization_guide.proto.HashedHostInfos hashed_hosts = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::hashed_hosts(this),
        _Internal::hashed_hosts(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.GetHintsRequest)
  return target;
}

size_t GetHintsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.GetHintsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.HostInfo hosts = 1;
  total_size += 1UL * this->_internal_hosts_size();
  for (const auto& msg : this->hosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .optimization_guide.proto.OptimizationType supported_optimizations = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_optimizations_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_supported_optimizations(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .optimization_guide.proto.UrlInfo urls = 4;
  total_size += 1UL * this->_internal_urls_size();
  for (const auto& msg : this->urls_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .optimization_guide.proto.KeyRepresentation supported_key_representations = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_key_representations_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_supported_key_representations(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string locale = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional .optimization_guide.proto.HashedHostInfos hashed_hosts = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hashed_hosts_);
    }

    // optional .optimization_guide.proto.RequestContext context = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_context());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetHintsRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetHintsRequest*>(
      &from));
}

void GetHintsRequest::MergeFrom(const GetHintsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.GetHintsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  hosts_.MergeFrom(from.hosts_);
  supported_optimizations_.MergeFrom(from.supported_optimizations_);
  urls_.MergeFrom(from.urls_);
  supported_key_representations_.MergeFrom(from.supported_key_representations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_hashed_hosts()->::optimization_guide::proto::HashedHostInfos::MergeFrom(from._internal_hashed_hosts());
    }
    if (cached_has_bits & 0x00000004u) {
      context_ = from.context_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetHintsRequest::CopyFrom(const GetHintsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.GetHintsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHintsRequest::IsInitialized() const {
  return true;
}

void GetHintsRequest::InternalSwap(GetHintsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hosts_.InternalSwap(&other->hosts_);
  supported_optimizations_.InternalSwap(&other->supported_optimizations_);
  urls_.InternalSwap(&other->urls_);
  supported_key_representations_.InternalSwap(&other->supported_key_representations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetHintsRequest, context_)
      + sizeof(GetHintsRequest::context_)
      - PROTOBUF_FIELD_OFFSET(GetHintsRequest, hashed_hosts_)>(
          reinterpret_cast<char*>(&hashed_hosts_),
          reinterpret_cast<char*>(&other->hashed_hosts_));
}

std::string GetHintsRequest::GetTypeName() const {
  return "optimization_guide.proto.GetHintsRequest";
}


// ===================================================================

class GetHintsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetHintsResponse>()._has_bits_);
  static const ::optimization_guide::proto::Duration& max_cache_duration(const GetHintsResponse* msg);
  static void set_has_max_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::optimization_guide::proto::Duration&
GetHintsResponse::_Internal::max_cache_duration(const GetHintsResponse* msg) {
  return *msg->max_cache_duration_;
}
void GetHintsResponse::clear_max_cache_duration() {
  if (max_cache_duration_ != nullptr) max_cache_duration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
GetHintsResponse::GetHintsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  hints_(arena),
  hints_to_remove_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.GetHintsResponse)
}
GetHintsResponse::GetHintsResponse(const GetHintsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      hints_(from.hints_),
      hints_to_remove_(from.hints_to_remove_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_max_cache_duration()) {
    max_cache_duration_ = new ::optimization_guide::proto::Duration(*from.max_cache_duration_);
  } else {
    max_cache_duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.GetHintsResponse)
}

inline void GetHintsResponse::SharedCtor() {
max_cache_duration_ = nullptr;
}

GetHintsResponse::~GetHintsResponse() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.GetHintsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetHintsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete max_cache_duration_;
}

void GetHintsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetHintsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.GetHintsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hints_.Clear();
  hints_to_remove_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(max_cache_duration_ != nullptr);
    max_cache_duration_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetHintsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .optimization_guide.proto.Hint hints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.Duration max_cache_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_max_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.MatchedHintInfo hints_to_remove = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hints_to_remove(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetHintsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.GetHintsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.Hint hints = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hints_size()); i < n; i++) {
    const auto& repfield = this->_internal_hints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.Duration max_cache_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::max_cache_duration(this),
        _Internal::max_cache_duration(this).GetCachedSize(), target, stream);
  }

  // repeated .optimization_guide.proto.MatchedHintInfo hints_to_remove = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hints_to_remove_size()); i < n; i++) {
    const auto& repfield = this->_internal_hints_to_remove(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.GetHintsResponse)
  return target;
}

size_t GetHintsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.GetHintsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.Hint hints = 1;
  total_size += 1UL * this->_internal_hints_size();
  for (const auto& msg : this->hints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .optimization_guide.proto.MatchedHintInfo hints_to_remove = 3;
  total_size += 1UL * this->_internal_hints_to_remove_size();
  for (const auto& msg : this->hints_to_remove_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .optimization_guide.proto.Duration max_cache_duration = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *max_cache_duration_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetHintsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetHintsResponse*>(
      &from));
}

void GetHintsResponse::MergeFrom(const GetHintsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.GetHintsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  hints_.MergeFrom(from.hints_);
  hints_to_remove_.MergeFrom(from.hints_to_remove_);
  if (from._internal_has_max_cache_duration()) {
    _internal_mutable_max_cache_duration()->::optimization_guide::proto::Duration::MergeFrom(from._internal_max_cache_duration());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetHintsResponse::CopyFrom(const GetHintsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.GetHintsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHintsResponse::IsInitialized() const {
  return true;
}

void GetHintsResponse::InternalSwap(GetHintsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hints_.InternalSwap(&other->hints_);
  hints_to_remove_.InternalSwap(&other->hints_to_remove_);
  swap(max_cache_duration_, other->max_cache_duration_);
}

std::string GetHintsResponse::GetTypeName() const {
  return "optimization_guide.proto.GetHintsResponse";
}


// ===================================================================

class Optimization::_Internal {
 public:
  using HasBits = decltype(std::declval<Optimization>()._has_bits_);
  static void set_has_optimization_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tuning_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::optimization_guide::proto::PerformanceHintsMetadata& performance_hints_metadata(const Optimization* msg);
  static const ::optimization_guide::proto::PublicImageMetadata& public_image_metadata(const Optimization* msg);
  static const ::optimization_guide::proto::LoadingPredictorMetadata& loading_predictor_metadata(const Optimization* msg);
  static const ::optimization_guide::proto::Any& any_metadata(const Optimization* msg);
};

const ::optimization_guide::proto::PerformanceHintsMetadata&
Optimization::_Internal::performance_hints_metadata(const Optimization* msg) {
  return *msg->metadata_.performance_hints_metadata_;
}
const ::optimization_guide::proto::PublicImageMetadata&
Optimization::_Internal::public_image_metadata(const Optimization* msg) {
  return *msg->metadata_.public_image_metadata_;
}
const ::optimization_guide::proto::LoadingPredictorMetadata&
Optimization::_Internal::loading_predictor_metadata(const Optimization* msg) {
  return *msg->metadata_.loading_predictor_metadata_;
}
const ::optimization_guide::proto::Any&
Optimization::_Internal::any_metadata(const Optimization* msg) {
  return *msg->metadata_.any_metadata_;
}
void Optimization::set_allocated_performance_hints_metadata(::optimization_guide::proto::PerformanceHintsMetadata* performance_hints_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_metadata();
  if (performance_hints_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(performance_hints_metadata));
    if (message_arena != submessage_arena) {
      performance_hints_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance_hints_metadata, submessage_arena);
    }
    set_has_performance_hints_metadata();
    metadata_.performance_hints_metadata_ = performance_hints_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Optimization.performance_hints_metadata)
}
void Optimization::clear_performance_hints_metadata() {
  if (_internal_has_performance_hints_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.performance_hints_metadata_;
    }
    clear_has_metadata();
  }
}
void Optimization::set_allocated_public_image_metadata(::optimization_guide::proto::PublicImageMetadata* public_image_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_metadata();
  if (public_image_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_image_metadata));
    if (message_arena != submessage_arena) {
      public_image_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_image_metadata, submessage_arena);
    }
    set_has_public_image_metadata();
    metadata_.public_image_metadata_ = public_image_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Optimization.public_image_metadata)
}
void Optimization::clear_public_image_metadata() {
  if (_internal_has_public_image_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.public_image_metadata_;
    }
    clear_has_metadata();
  }
}
void Optimization::set_allocated_loading_predictor_metadata(::optimization_guide::proto::LoadingPredictorMetadata* loading_predictor_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_metadata();
  if (loading_predictor_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(loading_predictor_metadata));
    if (message_arena != submessage_arena) {
      loading_predictor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loading_predictor_metadata, submessage_arena);
    }
    set_has_loading_predictor_metadata();
    metadata_.loading_predictor_metadata_ = loading_predictor_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Optimization.loading_predictor_metadata)
}
void Optimization::clear_loading_predictor_metadata() {
  if (_internal_has_loading_predictor_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.loading_predictor_metadata_;
    }
    clear_has_metadata();
  }
}
void Optimization::set_allocated_any_metadata(::optimization_guide::proto::Any* any_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_metadata();
  if (any_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(any_metadata));
    if (message_arena != submessage_arena) {
      any_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any_metadata, submessage_arena);
    }
    set_has_any_metadata();
    metadata_.any_metadata_ = any_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Optimization.any_metadata)
}
void Optimization::clear_any_metadata() {
  if (_internal_has_any_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete metadata_.any_metadata_;
    }
    clear_has_metadata();
  }
}
Optimization::Optimization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Optimization)
}
Optimization::Optimization(const Optimization& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&tuning_version_, &from.tuning_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&optimization_type_) -
    reinterpret_cast<char*>(&tuning_version_)) + sizeof(optimization_type_));
  clear_has_metadata();
  switch (from.metadata_case()) {
    case kPerformanceHintsMetadata: {
      _internal_mutable_performance_hints_metadata()->::optimization_guide::proto::PerformanceHintsMetadata::MergeFrom(from._internal_performance_hints_metadata());
      break;
    }
    case kPublicImageMetadata: {
      _internal_mutable_public_image_metadata()->::optimization_guide::proto::PublicImageMetadata::MergeFrom(from._internal_public_image_metadata());
      break;
    }
    case kLoadingPredictorMetadata: {
      _internal_mutable_loading_predictor_metadata()->::optimization_guide::proto::LoadingPredictorMetadata::MergeFrom(from._internal_loading_predictor_metadata());
      break;
    }
    case kAnyMetadata: {
      _internal_mutable_any_metadata()->::optimization_guide::proto::Any::MergeFrom(from._internal_any_metadata());
      break;
    }
    case METADATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Optimization)
}

inline void Optimization::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tuning_version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&optimization_type_) -
    reinterpret_cast<char*>(&tuning_version_)) + sizeof(optimization_type_));
clear_has_metadata();
}

Optimization::~Optimization() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.Optimization)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Optimization::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_metadata()) {
    clear_metadata();
  }
}

void Optimization::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Optimization::clear_metadata() {
// @@protoc_insertion_point(one_of_clear_start:optimization_guide.proto.Optimization)
  switch (metadata_case()) {
    case kPerformanceHintsMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete metadata_.performance_hints_metadata_;
      }
      break;
    }
    case kPublicImageMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete metadata_.public_image_metadata_;
      }
      break;
    }
    case kLoadingPredictorMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete metadata_.loading_predictor_metadata_;
      }
      break;
    }
    case kAnyMetadata: {
      if (GetArenaForAllocation() == nullptr) {
        delete metadata_.any_metadata_;
      }
      break;
    }
    case METADATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = METADATA_NOT_SET;
}


void Optimization::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Optimization)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&tuning_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&optimization_type_) -
        reinterpret_cast<char*>(&tuning_version_)) + sizeof(optimization_type_));
  }
  clear_metadata();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Optimization::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationType_IsValid(val))) {
            _internal_set_optimization_type(static_cast<::optimization_guide::proto::OptimizationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 tuning_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tuning_version(&has_bits);
          tuning_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .optimization_guide.proto.PerformanceHintsMetadata performance_hints_metadata = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_performance_hints_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .optimization_guide.proto.PublicImageMetadata public_image_metadata = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_public_image_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .optimization_guide.proto.LoadingPredictorMetadata loading_predictor_metadata = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_loading_predictor_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .optimization_guide.proto.Any any_metadata = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_any_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Optimization::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Optimization)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_optimization_type(), target);
  }

  // optional uint64 tuning_version = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_tuning_version(), target);
  }

  switch (metadata_case()) {
    case kPerformanceHintsMetadata: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::performance_hints_metadata(this),
          _Internal::performance_hints_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    case kPublicImageMetadata: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::public_image_metadata(this),
          _Internal::public_image_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    case kLoadingPredictorMetadata: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::loading_predictor_metadata(this),
          _Internal::loading_predictor_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    case kAnyMetadata: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::any_metadata(this),
          _Internal::any_metadata(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Optimization)
  return target;
}

size_t Optimization::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Optimization)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 tuning_version = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tuning_version());
    }

    // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_optimization_type());
    }

  }
  switch (metadata_case()) {
    // .optimization_guide.proto.PerformanceHintsMetadata performance_hints_metadata = 11;
    case kPerformanceHintsMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_.performance_hints_metadata_);
      break;
    }
    // .optimization_guide.proto.PublicImageMetadata public_image_metadata = 12;
    case kPublicImageMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_.public_image_metadata_);
      break;
    }
    // .optimization_guide.proto.LoadingPredictorMetadata loading_predictor_metadata = 13;
    case kLoadingPredictorMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_.loading_predictor_metadata_);
      break;
    }
    // .optimization_guide.proto.Any any_metadata = 15;
    case kAnyMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_.any_metadata_);
      break;
    }
    case METADATA_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Optimization::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Optimization*>(
      &from));
}

void Optimization::MergeFrom(const Optimization& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Optimization)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      tuning_version_ = from.tuning_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      optimization_type_ = from.optimization_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.metadata_case()) {
    case kPerformanceHintsMetadata: {
      _internal_mutable_performance_hints_metadata()->::optimization_guide::proto::PerformanceHintsMetadata::MergeFrom(from._internal_performance_hints_metadata());
      break;
    }
    case kPublicImageMetadata: {
      _internal_mutable_public_image_metadata()->::optimization_guide::proto::PublicImageMetadata::MergeFrom(from._internal_public_image_metadata());
      break;
    }
    case kLoadingPredictorMetadata: {
      _internal_mutable_loading_predictor_metadata()->::optimization_guide::proto::LoadingPredictorMetadata::MergeFrom(from._internal_loading_predictor_metadata());
      break;
    }
    case kAnyMetadata: {
      _internal_mutable_any_metadata()->::optimization_guide::proto::Any::MergeFrom(from._internal_any_metadata());
      break;
    }
    case METADATA_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Optimization::CopyFrom(const Optimization& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Optimization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optimization::IsInitialized() const {
  return true;
}

void Optimization::InternalSwap(Optimization* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Optimization, optimization_type_)
      + sizeof(Optimization::optimization_type_)
      - PROTOBUF_FIELD_OFFSET(Optimization, tuning_version_)>(
          reinterpret_cast<char*>(&tuning_version_),
          reinterpret_cast<char*>(&other->tuning_version_));
  swap(metadata_, other->metadata_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string Optimization::GetTypeName() const {
  return "optimization_guide.proto.Optimization";
}


// ===================================================================

class PageHint::_Internal {
 public:
  using HasBits = decltype(std::declval<PageHint>()._has_bits_);
  static void set_has_page_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PageHint::PageHint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  allowlisted_optimizations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.PageHint)
}
PageHint::PageHint(const PageHint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      allowlisted_optimizations_(from.allowlisted_optimizations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  page_pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    page_pattern_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_page_pattern()) {
    page_pattern_.Set(from._internal_page_pattern(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.PageHint)
}

inline void PageHint::SharedCtor() {
page_pattern_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  page_pattern_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PageHint::~PageHint() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.PageHint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PageHint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  page_pattern_.Destroy();
}

void PageHint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PageHint::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.PageHint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowlisted_optimizations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    page_pattern_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PageHint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string page_pattern = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_page_pattern();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allowlisted_optimizations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PageHint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.PageHint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string page_pattern = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_page_pattern(), target);
  }

  // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_allowlisted_optimizations_size()); i < n; i++) {
    const auto& repfield = this->_internal_allowlisted_optimizations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.PageHint)
  return target;
}

size_t PageHint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.PageHint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
  total_size += 1UL * this->_internal_allowlisted_optimizations_size();
  for (const auto& msg : this->allowlisted_optimizations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string page_pattern = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_pattern());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PageHint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PageHint*>(
      &from));
}

void PageHint::MergeFrom(const PageHint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.PageHint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  allowlisted_optimizations_.MergeFrom(from.allowlisted_optimizations_);
  if (from._internal_has_page_pattern()) {
    _internal_set_page_pattern(from._internal_page_pattern());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageHint::CopyFrom(const PageHint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.PageHint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PageHint::IsInitialized() const {
  return true;
}

void PageHint::InternalSwap(PageHint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowlisted_optimizations_.InternalSwap(&other->allowlisted_optimizations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &page_pattern_, lhs_arena,
      &other->page_pattern_, rhs_arena
  );
}

std::string PageHint::GetTypeName() const {
  return "optimization_guide.proto.PageHint";
}


// ===================================================================

class Hint::_Internal {
 public:
  using HasBits = decltype(std::declval<Hint>()._has_bits_);
  static void set_has_key_representation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::optimization_guide::proto::Duration& max_cache_duration(const Hint* msg);
  static void set_has_max_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::optimization_guide::proto::Duration&
Hint::_Internal::max_cache_duration(const Hint* msg) {
  return *msg->max_cache_duration_;
}
void Hint::clear_max_cache_duration() {
  if (max_cache_duration_ != nullptr) max_cache_duration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
Hint::Hint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  allowlisted_optimizations_(arena),
  page_hints_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Hint)
}
Hint::Hint(const Hint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      allowlisted_optimizations_(from.allowlisted_optimizations_),
      page_hints_(from.page_hints_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(from._internal_version(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_max_cache_duration()) {
    max_cache_duration_ = new ::optimization_guide::proto::Duration(*from.max_cache_duration_);
  } else {
    max_cache_duration_ = nullptr;
  }
  key_representation_ = from.key_representation_;
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Hint)
}

inline void Hint::SharedCtor() {
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_cache_duration_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&key_representation_) -
    reinterpret_cast<char*>(&max_cache_duration_)) + sizeof(key_representation_));
}

Hint::~Hint() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.Hint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Hint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.Destroy();
  version_.Destroy();
  if (this != internal_default_instance()) delete max_cache_duration_;
}

void Hint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Hint::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Hint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowlisted_optimizations_.Clear();
  page_hints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(max_cache_duration_ != nullptr);
      max_cache_duration_->Clear();
    }
  }
  key_representation_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Hint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::KeyRepresentation_IsValid(val))) {
            _internal_set_key_representation(static_cast<::optimization_guide::proto::KeyRepresentation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allowlisted_optimizations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.PageHint page_hints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_page_hints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.Duration max_cache_duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_max_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Hint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Hint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_key_representation(), target);
  }

  // optional string key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_allowlisted_optimizations_size()); i < n; i++) {
    const auto& repfield = this->_internal_allowlisted_optimizations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .optimization_guide.proto.PageHint page_hints = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_page_hints_size()); i < n; i++) {
    const auto& repfield = this->_internal_page_hints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string version = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_version(), target);
  }

  // optional .optimization_guide.proto.Duration max_cache_duration = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::max_cache_duration(this),
        _Internal::max_cache_duration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Hint)
  return target;
}

size_t Hint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Hint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
  total_size += 1UL * this->_internal_allowlisted_optimizations_size();
  for (const auto& msg : this->allowlisted_optimizations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .optimization_guide.proto.PageHint page_hints = 4;
  total_size += 1UL * this->_internal_page_hints_size();
  for (const auto& msg : this->page_hints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string version = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional .optimization_guide.proto.Duration max_cache_duration = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *max_cache_duration_);
    }

    // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_key_representation());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Hint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Hint*>(
      &from));
}

void Hint::MergeFrom(const Hint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Hint)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  allowlisted_optimizations_.MergeFrom(from.allowlisted_optimizations_);
  page_hints_.MergeFrom(from.page_hints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_max_cache_duration()->::optimization_guide::proto::Duration::MergeFrom(from._internal_max_cache_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      key_representation_ = from.key_representation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hint::CopyFrom(const Hint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Hint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hint::IsInitialized() const {
  return true;
}

void Hint::InternalSwap(Hint* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowlisted_optimizations_.InternalSwap(&other->allowlisted_optimizations_);
  page_hints_.InternalSwap(&other->page_hints_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Hint, key_representation_)
      + sizeof(Hint::key_representation_)
      - PROTOBUF_FIELD_OFFSET(Hint, max_cache_duration_)>(
          reinterpret_cast<char*>(&max_cache_duration_),
          reinterpret_cast<char*>(&other->max_cache_duration_));
}

std::string Hint::GetTypeName() const {
  return "optimization_guide.proto.Hint";
}


// ===================================================================

class BloomFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<BloomFilter>()._has_bits_);
  static void set_has_num_hash_functions(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BloomFilter::BloomFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.BloomFilter)
}
BloomFilter::BloomFilter(const BloomFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&num_hash_functions_, &from.num_hash_functions_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_bits_) -
    reinterpret_cast<char*>(&num_hash_functions_)) + sizeof(num_bits_));
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.BloomFilter)
}

inline void BloomFilter::SharedCtor() {
data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&num_hash_functions_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_bits_) -
    reinterpret_cast<char*>(&num_hash_functions_)) + sizeof(num_bits_));
}

BloomFilter::~BloomFilter() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.BloomFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BloomFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.Destroy();
}

void BloomFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BloomFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.BloomFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&num_hash_functions_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_bits_) -
        reinterpret_cast<char*>(&num_hash_functions_)) + sizeof(num_bits_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BloomFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 num_hash_functions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num_hash_functions(&has_bits);
          num_hash_functions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_bits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_bits(&has_bits);
          num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BloomFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.BloomFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 num_hash_functions = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_hash_functions(), target);
  }

  // optional uint32 num_bits = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_bits(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.BloomFilter)
  return target;
}

size_t BloomFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.BloomFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 num_hash_functions = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_hash_functions());
    }

    // optional uint32 num_bits = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_bits());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BloomFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BloomFilter*>(
      &from));
}

void BloomFilter::MergeFrom(const BloomFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.BloomFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      num_hash_functions_ = from.num_hash_functions_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_bits_ = from.num_bits_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BloomFilter::CopyFrom(const BloomFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.BloomFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BloomFilter::IsInitialized() const {
  return true;
}

void BloomFilter::InternalSwap(BloomFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BloomFilter, num_bits_)
      + sizeof(BloomFilter::num_bits_)
      - PROTOBUF_FIELD_OFFSET(BloomFilter, num_hash_functions_)>(
          reinterpret_cast<char*>(&num_hash_functions_),
          reinterpret_cast<char*>(&other->num_hash_functions_));
}

std::string BloomFilter::GetTypeName() const {
  return "optimization_guide.proto.BloomFilter";
}


// ===================================================================

class OptimizationFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<OptimizationFilter>()._has_bits_);
  static void set_has_optimization_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::optimization_guide::proto::BloomFilter& bloom_filter(const OptimizationFilter* msg);
  static void set_has_bloom_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skip_host_suffix_checking(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::optimization_guide::proto::BloomFilter&
OptimizationFilter::_Internal::bloom_filter(const OptimizationFilter* msg) {
  return *msg->bloom_filter_;
}
OptimizationFilter::OptimizationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  regexps_(arena),
  exclusion_regexps_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.OptimizationFilter)
}
OptimizationFilter::OptimizationFilter(const OptimizationFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      regexps_(from.regexps_),
      exclusion_regexps_(from.exclusion_regexps_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_bloom_filter()) {
    bloom_filter_ = new ::optimization_guide::proto::BloomFilter(*from.bloom_filter_);
  } else {
    bloom_filter_ = nullptr;
  }
  ::memcpy(&optimization_type_, &from.optimization_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&skip_host_suffix_checking_) -
    reinterpret_cast<char*>(&optimization_type_)) + sizeof(skip_host_suffix_checking_));
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.OptimizationFilter)
}

inline void OptimizationFilter::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bloom_filter_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&skip_host_suffix_checking_) -
    reinterpret_cast<char*>(&bloom_filter_)) + sizeof(skip_host_suffix_checking_));
}

OptimizationFilter::~OptimizationFilter() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.OptimizationFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OptimizationFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete bloom_filter_;
}

void OptimizationFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OptimizationFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.OptimizationFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  regexps_.Clear();
  exclusion_regexps_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(bloom_filter_ != nullptr);
    bloom_filter_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&optimization_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&skip_host_suffix_checking_) -
        reinterpret_cast<char*>(&optimization_type_)) + sizeof(skip_host_suffix_checking_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OptimizationFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationType_IsValid(val))) {
            _internal_set_optimization_type(static_cast<::optimization_guide::proto::OptimizationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.BloomFilter bloom_filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bloom_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string regexps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_regexps();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_host_suffix_checking = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_skip_host_suffix_checking(&has_bits);
          skip_host_suffix_checking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string exclusion_regexps = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclusion_regexps();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OptimizationFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.OptimizationFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_optimization_type(), target);
  }

  // optional .optimization_guide.proto.BloomFilter bloom_filter = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::bloom_filter(this),
        _Internal::bloom_filter(this).GetCachedSize(), target, stream);
  }

  // repeated string regexps = 3;
  for (int i = 0, n = this->_internal_regexps_size(); i < n; i++) {
    const auto& s = this->_internal_regexps(i);
    target = stream->WriteString(3, s, target);
  }

  // optional bool skip_host_suffix_checking = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_skip_host_suffix_checking(), target);
  }

  // repeated string exclusion_regexps = 5;
  for (int i = 0, n = this->_internal_exclusion_regexps_size(); i < n; i++) {
    const auto& s = this->_internal_exclusion_regexps(i);
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.OptimizationFilter)
  return target;
}

size_t OptimizationFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.OptimizationFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string regexps = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(regexps_.size());
  for (int i = 0, n = regexps_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      regexps_.Get(i));
  }

  // repeated string exclusion_regexps = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(exclusion_regexps_.size());
  for (int i = 0, n = exclusion_regexps_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      exclusion_regexps_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .optimization_guide.proto.BloomFilter bloom_filter = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bloom_filter_);
    }

    // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_optimization_type());
    }

    // optional bool skip_host_suffix_checking = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OptimizationFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OptimizationFilter*>(
      &from));
}

void OptimizationFilter::MergeFrom(const OptimizationFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.OptimizationFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  regexps_.MergeFrom(from.regexps_);
  exclusion_regexps_.MergeFrom(from.exclusion_regexps_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_bloom_filter()->::optimization_guide::proto::BloomFilter::MergeFrom(from._internal_bloom_filter());
    }
    if (cached_has_bits & 0x00000002u) {
      optimization_type_ = from.optimization_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      skip_host_suffix_checking_ = from.skip_host_suffix_checking_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OptimizationFilter::CopyFrom(const OptimizationFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.OptimizationFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptimizationFilter::IsInitialized() const {
  return true;
}

void OptimizationFilter::InternalSwap(OptimizationFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  regexps_.InternalSwap(&other->regexps_);
  exclusion_regexps_.InternalSwap(&other->exclusion_regexps_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OptimizationFilter, skip_host_suffix_checking_)
      + sizeof(OptimizationFilter::skip_host_suffix_checking_)
      - PROTOBUF_FIELD_OFFSET(OptimizationFilter, bloom_filter_)>(
          reinterpret_cast<char*>(&bloom_filter_),
          reinterpret_cast<char*>(&other->bloom_filter_));
}

std::string OptimizationFilter::GetTypeName() const {
  return "optimization_guide.proto.OptimizationFilter";
}


// ===================================================================

class Configuration::_Internal {
 public:
};

Configuration::Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  hints_(arena),
  optimization_blocklists_(arena),
  optimization_allowlists_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Configuration)
}
Configuration::Configuration(const Configuration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      hints_(from.hints_),
      optimization_blocklists_(from.optimization_blocklists_),
      optimization_allowlists_(from.optimization_allowlists_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Configuration)
}

inline void Configuration::SharedCtor() {
}

Configuration::~Configuration() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.Configuration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Configuration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Configuration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Configuration::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Configuration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hints_.Clear();
  optimization_blocklists_.Clear();
  optimization_allowlists_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Configuration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .optimization_guide.proto.Hint hints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.OptimizationFilter optimization_blocklists = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_optimization_blocklists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .optimization_guide.proto.OptimizationFilter optimization_allowlists = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_optimization_allowlists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Configuration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Configuration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.Hint hints = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hints_size()); i < n; i++) {
    const auto& repfield = this->_internal_hints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .optimization_guide.proto.OptimizationFilter optimization_blocklists = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_optimization_blocklists_size()); i < n; i++) {
    const auto& repfield = this->_internal_optimization_blocklists(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .optimization_guide.proto.OptimizationFilter optimization_allowlists = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_optimization_allowlists_size()); i < n; i++) {
    const auto& repfield = this->_internal_optimization_allowlists(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Configuration)
  return target;
}

size_t Configuration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Configuration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .optimization_guide.proto.Hint hints = 1;
  total_size += 1UL * this->_internal_hints_size();
  for (const auto& msg : this->hints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .optimization_guide.proto.OptimizationFilter optimization_blocklists = 2;
  total_size += 1UL * this->_internal_optimization_blocklists_size();
  for (const auto& msg : this->optimization_blocklists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .optimization_guide.proto.OptimizationFilter optimization_allowlists = 3;
  total_size += 1UL * this->_internal_optimization_allowlists_size();
  for (const auto& msg : this->optimization_allowlists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Configuration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Configuration*>(
      &from));
}

void Configuration::MergeFrom(const Configuration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Configuration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  hints_.MergeFrom(from.hints_);
  optimization_blocklists_.MergeFrom(from.optimization_blocklists_);
  optimization_allowlists_.MergeFrom(from.optimization_allowlists_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Configuration::CopyFrom(const Configuration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Configuration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Configuration::IsInitialized() const {
  return true;
}

void Configuration::InternalSwap(Configuration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  hints_.InternalSwap(&other->hints_);
  optimization_blocklists_.InternalSwap(&other->optimization_blocklists_);
  optimization_allowlists_.InternalSwap(&other->optimization_allowlists_);
}

std::string Configuration::GetTypeName() const {
  return "optimization_guide.proto.Configuration";
}


// ===================================================================

class Version::_Internal {
 public:
  using HasBits = decltype(std::declval<Version>()._has_bits_);
  static const ::optimization_guide::proto::Timestamp& generation_timestamp(const Version* msg);
  static void set_has_generation_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hint_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::optimization_guide::proto::Timestamp&
Version::_Internal::generation_timestamp(const Version* msg) {
  return *msg->generation_timestamp_;
}
void Version::clear_generation_timestamp() {
  if (generation_timestamp_ != nullptr) generation_timestamp_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_generation_timestamp()) {
    generation_timestamp_ = new ::optimization_guide::proto::Timestamp(*from.generation_timestamp_);
  } else {
    generation_timestamp_ = nullptr;
  }
  hint_source_ = from.hint_source_;
  // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Version)
}

inline void Version::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&generation_timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hint_source_) -
    reinterpret_cast<char*>(&generation_timestamp_)) + sizeof(hint_source_));
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:optimization_guide.proto.Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete generation_timestamp_;
}

void Version::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(generation_timestamp_ != nullptr);
    generation_timestamp_->Clear();
  }
  hint_source_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .optimization_guide.proto.Timestamp generation_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_generation_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .optimization_guide.proto.HintSource hint_source = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::HintSource_IsValid(val))) {
            _internal_set_hint_source(static_cast<::optimization_guide::proto::HintSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .optimization_guide.proto.Timestamp generation_timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::generation_timestamp(this),
        _Internal::generation_timestamp(this).GetCachedSize(), target, stream);
  }

  // optional .optimization_guide.proto.HintSource hint_source = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_hint_source(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Version)
  return target;
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Version)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .optimization_guide.proto.Timestamp generation_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *generation_timestamp_);
    }

    // optional .optimization_guide.proto.HintSource hint_source = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_hint_source());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Version::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Version*>(
      &from));
}

void Version::MergeFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Version)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_generation_timestamp()->::optimization_guide::proto::Timestamp::MergeFrom(from._internal_generation_timestamp());
    }
    if (cached_has_bits & 0x00000002u) {
      hint_source_ = from.hint_source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Version, hint_source_)
      + sizeof(Version::hint_source_)
      - PROTOBUF_FIELD_OFFSET(Version, generation_timestamp_)>(
          reinterpret_cast<char*>(&generation_timestamp_),
          reinterpret_cast<char*>(&other->generation_timestamp_));
}

std::string Version::GetTypeName() const {
  return "optimization_guide.proto.Version";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::MatchedHintInfo*
Arena::CreateMaybeMessage< ::optimization_guide::proto::MatchedHintInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::MatchedHintInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::HostInfo*
Arena::CreateMaybeMessage< ::optimization_guide::proto::HostInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::HostInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::UrlInfo*
Arena::CreateMaybeMessage< ::optimization_guide::proto::UrlInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::UrlInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::HashedHostInfos*
Arena::CreateMaybeMessage< ::optimization_guide::proto::HashedHostInfos >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::HashedHostInfos >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::GetHintsRequest*
Arena::CreateMaybeMessage< ::optimization_guide::proto::GetHintsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::GetHintsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::GetHintsResponse*
Arena::CreateMaybeMessage< ::optimization_guide::proto::GetHintsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::GetHintsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::Optimization*
Arena::CreateMaybeMessage< ::optimization_guide::proto::Optimization >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::Optimization >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::PageHint*
Arena::CreateMaybeMessage< ::optimization_guide::proto::PageHint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::PageHint >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::Hint*
Arena::CreateMaybeMessage< ::optimization_guide::proto::Hint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::Hint >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::BloomFilter*
Arena::CreateMaybeMessage< ::optimization_guide::proto::BloomFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::BloomFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::OptimizationFilter*
Arena::CreateMaybeMessage< ::optimization_guide::proto::OptimizationFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::OptimizationFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::Configuration*
Arena::CreateMaybeMessage< ::optimization_guide::proto::Configuration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::Configuration >(arena);
}
template<> PROTOBUF_NOINLINE ::optimization_guide::proto::Version*
Arena::CreateMaybeMessage< ::optimization_guide::proto::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::optimization_guide::proto::Version >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
