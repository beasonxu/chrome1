// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/webauthn_credential_specifics.proto

package org.chromium.components.sync.protocol;

public interface WebauthnCredentialSpecificsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:sync_pb.WebauthnCredentialSpecifics)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * Sync's ID for this entity (sometimes called the client unique tag), 16
   * random bytes. This value is used within Sync to identify this entity. The
   * credential ID is not used because the (hashed) sync_id is exposed to the
   * Sync server, and we don’t want Google to be able to map a credential ID to
   * an account. Password entities construct this value from the concatenation
   * of many fields and depend on the fact that the server only sees a hash of
   * it. But the only high-entropy secret here is the private key, which will
   * have different encryption in the future, and private keys are not the sort
   * of data to copy into other fields. Therefore this independent value is
   * provided to form the client's ID.
   * </pre>
   *
   * <code>optional bytes sync_id = 1;</code>
   * @return Whether the syncId field is set.
   */
  boolean hasSyncId();
  /**
   * <pre>
   * Sync's ID for this entity (sometimes called the client unique tag), 16
   * random bytes. This value is used within Sync to identify this entity. The
   * credential ID is not used because the (hashed) sync_id is exposed to the
   * Sync server, and we don’t want Google to be able to map a credential ID to
   * an account. Password entities construct this value from the concatenation
   * of many fields and depend on the fact that the server only sees a hash of
   * it. But the only high-entropy secret here is the private key, which will
   * have different encryption in the future, and private keys are not the sort
   * of data to copy into other fields. Therefore this independent value is
   * provided to form the client's ID.
   * </pre>
   *
   * <code>optional bytes sync_id = 1;</code>
   * @return The syncId.
   */
  com.google.protobuf.ByteString getSyncId();

  /**
   * <pre>
   * The credential ID, 16 random bytes. This is a value surfaced in
   * the WebAuthn API (https://www.w3.org/TR/webauthn-2/#credential-id).
   * </pre>
   *
   * <code>optional bytes credential_id = 2;</code>
   * @return Whether the credentialId field is set.
   */
  boolean hasCredentialId();
  /**
   * <pre>
   * The credential ID, 16 random bytes. This is a value surfaced in
   * the WebAuthn API (https://www.w3.org/TR/webauthn-2/#credential-id).
   * </pre>
   *
   * <code>optional bytes credential_id = 2;</code>
   * @return The credentialId.
   */
  com.google.protobuf.ByteString getCredentialId();

  /**
   * <pre>
   * An RP ID is a WebAuthn concept:
   * https://www.w3.org/TR/webauthn-2/#rp-id. It’s usually a domain name,
   * although in non-Web contexts it can be a URL with a non-Web scheme.
   * </pre>
   *
   * <code>optional string rp_id = 3;</code>
   * @return Whether the rpId field is set.
   */
  boolean hasRpId();
  /**
   * <pre>
   * An RP ID is a WebAuthn concept:
   * https://www.w3.org/TR/webauthn-2/#rp-id. It’s usually a domain name,
   * although in non-Web contexts it can be a URL with a non-Web scheme.
   * </pre>
   *
   * <code>optional string rp_id = 3;</code>
   * @return The rpId.
   */
  java.lang.String getRpId();
  /**
   * <pre>
   * An RP ID is a WebAuthn concept:
   * https://www.w3.org/TR/webauthn-2/#rp-id. It’s usually a domain name,
   * although in non-Web contexts it can be a URL with a non-Web scheme.
   * </pre>
   *
   * <code>optional string rp_id = 3;</code>
   * @return The bytes for rpId.
   */
  com.google.protobuf.ByteString
      getRpIdBytes();

  /**
   * <pre>
   * The user ID, which is also called a “user handle” in WebAuthn
   * (https://www.w3.org/TR/webauthn-2/#user-handle), is an RP-specific
   * identifier that is up to 64-bytes long. An authenticator conceptually only
   * stores a single credential for a given (rp_id, user_id) pair, but there
   * may be several credentials in Sync. They are prioritised using
   * newly_shadowed_credential_ids and creation_time. See below.
   * (We wish to be able to retain several entities for a single (rp_id,
   * user_id) pair because there’s an edge case where we may wish to revert to
   * an older entry and thus need to keep the older entry around in Sync. The
   * revert could happen on a different device too.)
   * </pre>
   *
   * <code>optional bytes user_id = 4;</code>
   * @return Whether the userId field is set.
   */
  boolean hasUserId();
  /**
   * <pre>
   * The user ID, which is also called a “user handle” in WebAuthn
   * (https://www.w3.org/TR/webauthn-2/#user-handle), is an RP-specific
   * identifier that is up to 64-bytes long. An authenticator conceptually only
   * stores a single credential for a given (rp_id, user_id) pair, but there
   * may be several credentials in Sync. They are prioritised using
   * newly_shadowed_credential_ids and creation_time. See below.
   * (We wish to be able to retain several entities for a single (rp_id,
   * user_id) pair because there’s an edge case where we may wish to revert to
   * an older entry and thus need to keep the older entry around in Sync. The
   * revert could happen on a different device too.)
   * </pre>
   *
   * <code>optional bytes user_id = 4;</code>
   * @return The userId.
   */
  com.google.protobuf.ByteString getUserId();

  /**
   * <pre>
   * The id of credentials with the same (rp_id, user_id) that were
   * shadowed by the creation of this entity.
   * A credential is shadowed if one or more other credentials (from the same
   * account, and with the same (rp_id, user_id)) include its credential_id in
   * their list of shadowed IDs. Shadowed credentials are ignored when finding
   * a credential to sign with. If there is more than one candidate remaining
   * after filtering shadowed credentials then the most recently created (based
   * on creation_time) is used.
   * The reason for all this is that sites can replace a credential by creating
   * another one with the same (rp_id, user_id) pair. However, we don't
   * immediately know whether the WebAuthn response reached the website's
   * server. Consider a user with a poor internet connection. Javascript in the
   * site's origin triggers a credential creation that “overwrites” an existing
   * credential, but the Javascript is unable to send the new public key to the
   * website's server. The user is now locked out: the old credential has been
   * over-written but the website's server doesn't know about the new one.
   * Thus we wish to keep “overwritten” credentials around for a while to allow
   * for some sort of recovery. In the simple case, a new credential shadows
   * the single, previous old credential. We could depend on creation_time, but
   * client clocks aren't always accurate, thus this field.
   * In complicated cases two devices might race to replace a credential, in
   * which case (after mutual syncing) two candidate credentials exist for the
   * same (rp_id, user_id) pair because neither shadows the other. In this case
   * we pick the newest based on |creation_time| but it's quite possible that
   * some recovery will be needed because the website's server thinks the other
   * one is correct.
   * A generation counter isn't used because a single device might replace a
   * series of credentials as it tries to update the website's server. But that
   * doesn't mean that it should dominate a different device that replaced it
   * only once, but later.
   * </pre>
   *
   * <code>repeated bytes newly_shadowed_credential_ids = 5;</code>
   * @return A list containing the newlyShadowedCredentialIds.
   */
  java.util.List<com.google.protobuf.ByteString> getNewlyShadowedCredentialIdsList();
  /**
   * <pre>
   * The id of credentials with the same (rp_id, user_id) that were
   * shadowed by the creation of this entity.
   * A credential is shadowed if one or more other credentials (from the same
   * account, and with the same (rp_id, user_id)) include its credential_id in
   * their list of shadowed IDs. Shadowed credentials are ignored when finding
   * a credential to sign with. If there is more than one candidate remaining
   * after filtering shadowed credentials then the most recently created (based
   * on creation_time) is used.
   * The reason for all this is that sites can replace a credential by creating
   * another one with the same (rp_id, user_id) pair. However, we don't
   * immediately know whether the WebAuthn response reached the website's
   * server. Consider a user with a poor internet connection. Javascript in the
   * site's origin triggers a credential creation that “overwrites” an existing
   * credential, but the Javascript is unable to send the new public key to the
   * website's server. The user is now locked out: the old credential has been
   * over-written but the website's server doesn't know about the new one.
   * Thus we wish to keep “overwritten” credentials around for a while to allow
   * for some sort of recovery. In the simple case, a new credential shadows
   * the single, previous old credential. We could depend on creation_time, but
   * client clocks aren't always accurate, thus this field.
   * In complicated cases two devices might race to replace a credential, in
   * which case (after mutual syncing) two candidate credentials exist for the
   * same (rp_id, user_id) pair because neither shadows the other. In this case
   * we pick the newest based on |creation_time| but it's quite possible that
   * some recovery will be needed because the website's server thinks the other
   * one is correct.
   * A generation counter isn't used because a single device might replace a
   * series of credentials as it tries to update the website's server. But that
   * doesn't mean that it should dominate a different device that replaced it
   * only once, but later.
   * </pre>
   *
   * <code>repeated bytes newly_shadowed_credential_ids = 5;</code>
   * @return The count of newlyShadowedCredentialIds.
   */
  int getNewlyShadowedCredentialIdsCount();
  /**
   * <pre>
   * The id of credentials with the same (rp_id, user_id) that were
   * shadowed by the creation of this entity.
   * A credential is shadowed if one or more other credentials (from the same
   * account, and with the same (rp_id, user_id)) include its credential_id in
   * their list of shadowed IDs. Shadowed credentials are ignored when finding
   * a credential to sign with. If there is more than one candidate remaining
   * after filtering shadowed credentials then the most recently created (based
   * on creation_time) is used.
   * The reason for all this is that sites can replace a credential by creating
   * another one with the same (rp_id, user_id) pair. However, we don't
   * immediately know whether the WebAuthn response reached the website's
   * server. Consider a user with a poor internet connection. Javascript in the
   * site's origin triggers a credential creation that “overwrites” an existing
   * credential, but the Javascript is unable to send the new public key to the
   * website's server. The user is now locked out: the old credential has been
   * over-written but the website's server doesn't know about the new one.
   * Thus we wish to keep “overwritten” credentials around for a while to allow
   * for some sort of recovery. In the simple case, a new credential shadows
   * the single, previous old credential. We could depend on creation_time, but
   * client clocks aren't always accurate, thus this field.
   * In complicated cases two devices might race to replace a credential, in
   * which case (after mutual syncing) two candidate credentials exist for the
   * same (rp_id, user_id) pair because neither shadows the other. In this case
   * we pick the newest based on |creation_time| but it's quite possible that
   * some recovery will be needed because the website's server thinks the other
   * one is correct.
   * A generation counter isn't used because a single device might replace a
   * series of credentials as it tries to update the website's server. But that
   * doesn't mean that it should dominate a different device that replaced it
   * only once, but later.
   * </pre>
   *
   * <code>repeated bytes newly_shadowed_credential_ids = 5;</code>
   * @param index The index of the element to return.
   * @return The newlyShadowedCredentialIds at the given index.
   */
  com.google.protobuf.ByteString getNewlyShadowedCredentialIds(int index);

  /**
   * <pre>
   * The local time on the device when this credential was created. Given in
   * milliseconds since the UNIX epoch. This is used to break ties between
   * credentials. See newly_shadowed_credential_ids.
   * </pre>
   *
   * <code>optional int64 creation_time = 6;</code>
   * @return Whether the creationTime field is set.
   */
  boolean hasCreationTime();
  /**
   * <pre>
   * The local time on the device when this credential was created. Given in
   * milliseconds since the UNIX epoch. This is used to break ties between
   * credentials. See newly_shadowed_credential_ids.
   * </pre>
   *
   * <code>optional int64 creation_time = 6;</code>
   * @return The creationTime.
   */
  long getCreationTime();

  /**
   * <pre>
   * The human-readable account identifier. Usually an email address.
   * https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialentity-name
   * </pre>
   *
   * <code>optional string user_name = 7;</code>
   * @return Whether the userName field is set.
   */
  boolean hasUserName();
  /**
   * <pre>
   * The human-readable account identifier. Usually an email address.
   * https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialentity-name
   * </pre>
   *
   * <code>optional string user_name = 7;</code>
   * @return The userName.
   */
  java.lang.String getUserName();
  /**
   * <pre>
   * The human-readable account identifier. Usually an email address.
   * https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialentity-name
   * </pre>
   *
   * <code>optional string user_name = 7;</code>
   * @return The bytes for userName.
   */
  com.google.protobuf.ByteString
      getUserNameBytes();

  /**
   * <pre>
   * The human-readable name. Usually a legal name. This is the only mutable
   * field in a credential.
   * https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname.
   * </pre>
   *
   * <code>optional string user_display_name = 8;</code>
   * @return Whether the userDisplayName field is set.
   */
  boolean hasUserDisplayName();
  /**
   * <pre>
   * The human-readable name. Usually a legal name. This is the only mutable
   * field in a credential.
   * https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname.
   * </pre>
   *
   * <code>optional string user_display_name = 8;</code>
   * @return The userDisplayName.
   */
  java.lang.String getUserDisplayName();
  /**
   * <pre>
   * The human-readable name. Usually a legal name. This is the only mutable
   * field in a credential.
   * https://www.w3.org/TR/webauthn-2/#dom-publickeycredentialuserentity-displayname.
   * </pre>
   *
   * <code>optional string user_display_name = 8;</code>
   * @return The bytes for userDisplayName.
   */
  com.google.protobuf.ByteString
      getUserDisplayNameBytes();

  /**
   * <pre>
   * The bytes of the private key, in a format known to the consumers of these
   * sync entities. In the future the private key may be encrypted with a
   * different key and then stored in a future encrypted_private_key field.
   * </pre>
   *
   * <code>optional bytes private_key = 9;</code>
   * @return Whether the privateKey field is set.
   */
  boolean hasPrivateKey();
  /**
   * <pre>
   * The bytes of the private key, in a format known to the consumers of these
   * sync entities. In the future the private key may be encrypted with a
   * different key and then stored in a future encrypted_private_key field.
   * </pre>
   *
   * <code>optional bytes private_key = 9;</code>
   * @return The privateKey.
   */
  com.google.protobuf.ByteString getPrivateKey();

  /**
   * <pre>
   * Credentials may optionally be enabled for Secure Payment Confirmation[1] on
   * third-party sites. This is opt-in at creation time.
   * [1] https://www.w3.org/TR/secure-payment-confirmation/
   * </pre>
   *
   * <code>optional bool third_party_payments_support = 11;</code>
   * @return Whether the thirdPartyPaymentsSupport field is set.
   */
  boolean hasThirdPartyPaymentsSupport();
  /**
   * <pre>
   * Credentials may optionally be enabled for Secure Payment Confirmation[1] on
   * third-party sites. This is opt-in at creation time.
   * [1] https://www.w3.org/TR/secure-payment-confirmation/
   * </pre>
   *
   * <code>optional bool third_party_payments_support = 11;</code>
   * @return The thirdPartyPaymentsSupport.
   */
  boolean getThirdPartyPaymentsSupport();
}
