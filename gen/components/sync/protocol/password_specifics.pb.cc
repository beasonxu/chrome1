// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/password_specifics.proto

#include "components/sync/protocol/password_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR PasswordSpecificsData_PasswordIssues_PasswordIssue::PasswordSpecificsData_PasswordIssues_PasswordIssue(
    ::_pbi::ConstantInitialized)
  : date_first_detection_microseconds_(uint64_t{0u})
  , is_muted_(false){}
struct PasswordSpecificsData_PasswordIssues_PasswordIssueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsData_PasswordIssues_PasswordIssueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsData_PasswordIssues_PasswordIssueDefaultTypeInternal() {}
  union {
    PasswordSpecificsData_PasswordIssues_PasswordIssue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsData_PasswordIssues_PasswordIssueDefaultTypeInternal _PasswordSpecificsData_PasswordIssues_PasswordIssue_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData_PasswordIssues::PasswordSpecificsData_PasswordIssues(
    ::_pbi::ConstantInitialized)
  : leaked_password_issue_(nullptr)
  , reused_password_issue_(nullptr)
  , weak_password_issue_(nullptr)
  , phished_password_issue_(nullptr){}
struct PasswordSpecificsData_PasswordIssuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsData_PasswordIssuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsData_PasswordIssuesDefaultTypeInternal() {}
  union {
    PasswordSpecificsData_PasswordIssues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsData_PasswordIssuesDefaultTypeInternal _PasswordSpecificsData_PasswordIssues_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData_Notes_Note::PasswordSpecificsData_Notes_Note(
    ::_pbi::ConstantInitialized)
  : unique_display_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , date_created_windows_epoch_micros_(int64_t{0})
  , hide_by_default_(false){}
struct PasswordSpecificsData_Notes_NoteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsData_Notes_NoteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsData_Notes_NoteDefaultTypeInternal() {}
  union {
    PasswordSpecificsData_Notes_Note _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsData_Notes_NoteDefaultTypeInternal _PasswordSpecificsData_Notes_Note_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData_Notes::PasswordSpecificsData_Notes(
    ::_pbi::ConstantInitialized)
  : note_(){}
struct PasswordSpecificsData_NotesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsData_NotesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsData_NotesDefaultTypeInternal() {}
  union {
    PasswordSpecificsData_Notes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsData_NotesDefaultTypeInternal _PasswordSpecificsData_Notes_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData::PasswordSpecificsData(
    ::_pbi::ConstantInitialized)
  : signon_realm_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , origin_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , username_element_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , username_value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , password_element_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , password_value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , display_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , avatar_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , federation_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , password_issues_(nullptr)
  , notes_(nullptr)
  , scheme_(0)
  , ssl_valid_(false)
  , preferred_(false)
  , blacklisted_(false)
  , date_created_(int64_t{0})
  , type_(0)
  , times_used_(0)
  , date_last_used_(int64_t{0})
  , date_password_modified_windows_epoch_micros_(int64_t{0}){}
struct PasswordSpecificsDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsDataDefaultTypeInternal() {}
  union {
    PasswordSpecificsData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsDataDefaultTypeInternal _PasswordSpecificsData_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsMetadata::PasswordSpecificsMetadata(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , blacklisted_(false){}
struct PasswordSpecificsMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsMetadataDefaultTypeInternal() {}
  union {
    PasswordSpecificsMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsMetadataDefaultTypeInternal _PasswordSpecificsMetadata_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecifics::PasswordSpecifics(
    ::_pbi::ConstantInitialized)
  : encrypted_(nullptr)
  , client_only_encrypted_data_(nullptr)
  , unencrypted_metadata_(nullptr)
  , encrypted_notes_backup_(nullptr){}
struct PasswordSpecificsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasswordSpecificsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasswordSpecificsDefaultTypeInternal() {}
  union {
    PasswordSpecifics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsDefaultTypeInternal _PasswordSpecifics_default_instance_;
}  // namespace sync_pb
namespace sync_pb {
bool PasswordSpecificsData_Scheme_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PasswordSpecificsData_Scheme_strings[5] = {};

static const char PasswordSpecificsData_Scheme_names[] =
  "SCHEME_BASIC"
  "SCHEME_DIGEST"
  "SCHEME_HTML"
  "SCHEME_OTHER"
  "USERNAME_ONLY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PasswordSpecificsData_Scheme_entries[] = {
  { {PasswordSpecificsData_Scheme_names + 0, 12}, 1 },
  { {PasswordSpecificsData_Scheme_names + 12, 13}, 2 },
  { {PasswordSpecificsData_Scheme_names + 25, 11}, 0 },
  { {PasswordSpecificsData_Scheme_names + 36, 12}, 3 },
  { {PasswordSpecificsData_Scheme_names + 48, 13}, 4 },
};

static const int PasswordSpecificsData_Scheme_entries_by_number[] = {
  2, // 0 -> SCHEME_HTML
  0, // 1 -> SCHEME_BASIC
  1, // 2 -> SCHEME_DIGEST
  3, // 3 -> SCHEME_OTHER
  4, // 4 -> USERNAME_ONLY
};

const std::string& PasswordSpecificsData_Scheme_Name(
    PasswordSpecificsData_Scheme value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PasswordSpecificsData_Scheme_entries,
          PasswordSpecificsData_Scheme_entries_by_number,
          5, PasswordSpecificsData_Scheme_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PasswordSpecificsData_Scheme_entries,
      PasswordSpecificsData_Scheme_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PasswordSpecificsData_Scheme_strings[idx].get();
}
bool PasswordSpecificsData_Scheme_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PasswordSpecificsData_Scheme* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PasswordSpecificsData_Scheme_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<PasswordSpecificsData_Scheme>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_HTML;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_BASIC;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_DIGEST;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_OTHER;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::USERNAME_ONLY;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::Scheme_MIN;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::Scheme_MAX;
constexpr int PasswordSpecificsData::Scheme_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class PasswordSpecificsData_PasswordIssues_PasswordIssue::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordSpecificsData_PasswordIssues_PasswordIssue>()._has_bits_);
  static void set_has_date_first_detection_microseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_muted(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PasswordSpecificsData_PasswordIssues_PasswordIssue::PasswordSpecificsData_PasswordIssues_PasswordIssue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
}
PasswordSpecificsData_PasswordIssues_PasswordIssue::PasswordSpecificsData_PasswordIssues_PasswordIssue(const PasswordSpecificsData_PasswordIssues_PasswordIssue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&date_first_detection_microseconds_, &from.date_first_detection_microseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_muted_) -
    reinterpret_cast<char*>(&date_first_detection_microseconds_)) + sizeof(is_muted_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
}

inline void PasswordSpecificsData_PasswordIssues_PasswordIssue::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&date_first_detection_microseconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_muted_) -
    reinterpret_cast<char*>(&date_first_detection_microseconds_)) + sizeof(is_muted_));
}

PasswordSpecificsData_PasswordIssues_PasswordIssue::~PasswordSpecificsData_PasswordIssues_PasswordIssue() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecificsData_PasswordIssues_PasswordIssue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PasswordSpecificsData_PasswordIssues_PasswordIssue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecificsData_PasswordIssues_PasswordIssue::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&date_first_detection_microseconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_muted_) -
        reinterpret_cast<char*>(&date_first_detection_microseconds_)) + sizeof(is_muted_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData_PasswordIssues_PasswordIssue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 date_first_detection_microseconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_date_first_detection_microseconds(&has_bits);
          date_first_detection_microseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_muted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_muted(&has_bits);
          is_muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData_PasswordIssues_PasswordIssue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 date_first_detection_microseconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_date_first_detection_microseconds(), target);
  }

  // optional bool is_muted = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_muted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  return target;
}

size_t PasswordSpecificsData_PasswordIssues_PasswordIssue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 date_first_detection_microseconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_date_first_detection_microseconds());
    }

    // optional bool is_muted = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecificsData_PasswordIssues_PasswordIssue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData_PasswordIssues_PasswordIssue*>(
      &from));
}

void PasswordSpecificsData_PasswordIssues_PasswordIssue::MergeFrom(const PasswordSpecificsData_PasswordIssues_PasswordIssue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      date_first_detection_microseconds_ = from.date_first_detection_microseconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_muted_ = from.is_muted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData_PasswordIssues_PasswordIssue::CopyFrom(const PasswordSpecificsData_PasswordIssues_PasswordIssue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecificsData_PasswordIssues_PasswordIssue::IsInitialized() const {
  return true;
}

void PasswordSpecificsData_PasswordIssues_PasswordIssue::InternalSwap(PasswordSpecificsData_PasswordIssues_PasswordIssue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_PasswordIssues_PasswordIssue, is_muted_)
      + sizeof(PasswordSpecificsData_PasswordIssues_PasswordIssue::is_muted_)
      - PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_PasswordIssues_PasswordIssue, date_first_detection_microseconds_)>(
          reinterpret_cast<char*>(&date_first_detection_microseconds_),
          reinterpret_cast<char*>(&other->date_first_detection_microseconds_));
}

std::string PasswordSpecificsData_PasswordIssues_PasswordIssue::GetTypeName() const {
  return "sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue";
}


// ===================================================================

class PasswordSpecificsData_PasswordIssues::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordSpecificsData_PasswordIssues>()._has_bits_);
  static const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue& leaked_password_issue(const PasswordSpecificsData_PasswordIssues* msg);
  static void set_has_leaked_password_issue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue& reused_password_issue(const PasswordSpecificsData_PasswordIssues* msg);
  static void set_has_reused_password_issue(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue& weak_password_issue(const PasswordSpecificsData_PasswordIssues* msg);
  static void set_has_weak_password_issue(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue& phished_password_issue(const PasswordSpecificsData_PasswordIssues* msg);
  static void set_has_phished_password_issue(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue&
PasswordSpecificsData_PasswordIssues::_Internal::leaked_password_issue(const PasswordSpecificsData_PasswordIssues* msg) {
  return *msg->leaked_password_issue_;
}
const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue&
PasswordSpecificsData_PasswordIssues::_Internal::reused_password_issue(const PasswordSpecificsData_PasswordIssues* msg) {
  return *msg->reused_password_issue_;
}
const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue&
PasswordSpecificsData_PasswordIssues::_Internal::weak_password_issue(const PasswordSpecificsData_PasswordIssues* msg) {
  return *msg->weak_password_issue_;
}
const ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue&
PasswordSpecificsData_PasswordIssues::_Internal::phished_password_issue(const PasswordSpecificsData_PasswordIssues* msg) {
  return *msg->phished_password_issue_;
}
PasswordSpecificsData_PasswordIssues::PasswordSpecificsData_PasswordIssues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData.PasswordIssues)
}
PasswordSpecificsData_PasswordIssues::PasswordSpecificsData_PasswordIssues(const PasswordSpecificsData_PasswordIssues& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_leaked_password_issue()) {
    leaked_password_issue_ = new ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue(*from.leaked_password_issue_);
  } else {
    leaked_password_issue_ = nullptr;
  }
  if (from._internal_has_reused_password_issue()) {
    reused_password_issue_ = new ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue(*from.reused_password_issue_);
  } else {
    reused_password_issue_ = nullptr;
  }
  if (from._internal_has_weak_password_issue()) {
    weak_password_issue_ = new ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue(*from.weak_password_issue_);
  } else {
    weak_password_issue_ = nullptr;
  }
  if (from._internal_has_phished_password_issue()) {
    phished_password_issue_ = new ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue(*from.phished_password_issue_);
  } else {
    phished_password_issue_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData.PasswordIssues)
}

inline void PasswordSpecificsData_PasswordIssues::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&leaked_password_issue_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&phished_password_issue_) -
    reinterpret_cast<char*>(&leaked_password_issue_)) + sizeof(phished_password_issue_));
}

PasswordSpecificsData_PasswordIssues::~PasswordSpecificsData_PasswordIssues() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData.PasswordIssues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecificsData_PasswordIssues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete leaked_password_issue_;
  if (this != internal_default_instance()) delete reused_password_issue_;
  if (this != internal_default_instance()) delete weak_password_issue_;
  if (this != internal_default_instance()) delete phished_password_issue_;
}

void PasswordSpecificsData_PasswordIssues::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecificsData_PasswordIssues::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData.PasswordIssues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(leaked_password_issue_ != nullptr);
      leaked_password_issue_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(reused_password_issue_ != nullptr);
      reused_password_issue_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(weak_password_issue_ != nullptr);
      weak_password_issue_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(phished_password_issue_ != nullptr);
      phished_password_issue_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData_PasswordIssues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue leaked_password_issue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_leaked_password_issue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue reused_password_issue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_reused_password_issue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue weak_password_issue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_weak_password_issue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue phished_password_issue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_phished_password_issue(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData_PasswordIssues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData.PasswordIssues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue leaked_password_issue = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::leaked_password_issue(this),
        _Internal::leaked_password_issue(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue reused_password_issue = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::reused_password_issue(this),
        _Internal::reused_password_issue(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue weak_password_issue = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::weak_password_issue(this),
        _Internal::weak_password_issue(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue phished_password_issue = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::phished_password_issue(this),
        _Internal::phished_password_issue(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData.PasswordIssues)
  return target;
}

size_t PasswordSpecificsData_PasswordIssues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData.PasswordIssues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue leaked_password_issue = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *leaked_password_issue_);
    }

    // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue reused_password_issue = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *reused_password_issue_);
    }

    // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue weak_password_issue = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *weak_password_issue_);
    }

    // optional .sync_pb.PasswordSpecificsData.PasswordIssues.PasswordIssue phished_password_issue = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *phished_password_issue_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecificsData_PasswordIssues::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData_PasswordIssues*>(
      &from));
}

void PasswordSpecificsData_PasswordIssues::MergeFrom(const PasswordSpecificsData_PasswordIssues& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData.PasswordIssues)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_leaked_password_issue()->::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue::MergeFrom(from._internal_leaked_password_issue());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_reused_password_issue()->::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue::MergeFrom(from._internal_reused_password_issue());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_weak_password_issue()->::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue::MergeFrom(from._internal_weak_password_issue());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_phished_password_issue()->::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue::MergeFrom(from._internal_phished_password_issue());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData_PasswordIssues::CopyFrom(const PasswordSpecificsData_PasswordIssues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData.PasswordIssues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecificsData_PasswordIssues::IsInitialized() const {
  return true;
}

void PasswordSpecificsData_PasswordIssues::InternalSwap(PasswordSpecificsData_PasswordIssues* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_PasswordIssues, phished_password_issue_)
      + sizeof(PasswordSpecificsData_PasswordIssues::phished_password_issue_)
      - PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_PasswordIssues, leaked_password_issue_)>(
          reinterpret_cast<char*>(&leaked_password_issue_),
          reinterpret_cast<char*>(&other->leaked_password_issue_));
}

std::string PasswordSpecificsData_PasswordIssues::GetTypeName() const {
  return "sync_pb.PasswordSpecificsData.PasswordIssues";
}


// ===================================================================

class PasswordSpecificsData_Notes_Note::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordSpecificsData_Notes_Note>()._has_bits_);
  static void set_has_unique_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_date_created_windows_epoch_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hide_by_default(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

PasswordSpecificsData_Notes_Note::PasswordSpecificsData_Notes_Note(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData.Notes.Note)
}
PasswordSpecificsData_Notes_Note::PasswordSpecificsData_Notes_Note(const PasswordSpecificsData_Notes_Note& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  unique_display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    unique_display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_unique_display_name()) {
    unique_display_name_.Set(from._internal_unique_display_name(), 
      GetArenaForAllocation());
  }
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  ::memcpy(&date_created_windows_epoch_micros_, &from.date_created_windows_epoch_micros_,
    static_cast<size_t>(reinterpret_cast<char*>(&hide_by_default_) -
    reinterpret_cast<char*>(&date_created_windows_epoch_micros_)) + sizeof(hide_by_default_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData.Notes.Note)
}

inline void PasswordSpecificsData_Notes_Note::SharedCtor() {
unique_display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  unique_display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&date_created_windows_epoch_micros_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hide_by_default_) -
    reinterpret_cast<char*>(&date_created_windows_epoch_micros_)) + sizeof(hide_by_default_));
}

PasswordSpecificsData_Notes_Note::~PasswordSpecificsData_Notes_Note() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData.Notes.Note)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecificsData_Notes_Note::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  unique_display_name_.Destroy();
  value_.Destroy();
}

void PasswordSpecificsData_Notes_Note::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecificsData_Notes_Note::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData.Notes.Note)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      unique_display_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&date_created_windows_epoch_micros_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hide_by_default_) -
        reinterpret_cast<char*>(&date_created_windows_epoch_micros_)) + sizeof(hide_by_default_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData_Notes_Note::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string unique_display_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_unique_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 date_created_windows_epoch_micros = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_date_created_windows_epoch_micros(&has_bits);
          date_created_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hide_by_default = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hide_by_default(&has_bits);
          hide_by_default_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData_Notes_Note::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData.Notes.Note)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string unique_display_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_unique_display_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  // optional int64 date_created_windows_epoch_micros = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_date_created_windows_epoch_micros(), target);
  }

  // optional bool hide_by_default = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hide_by_default(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData.Notes.Note)
  return target;
}

size_t PasswordSpecificsData_Notes_Note::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData.Notes.Note)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string unique_display_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_unique_display_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional int64 date_created_windows_epoch_micros = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_date_created_windows_epoch_micros());
    }

    // optional bool hide_by_default = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecificsData_Notes_Note::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData_Notes_Note*>(
      &from));
}

void PasswordSpecificsData_Notes_Note::MergeFrom(const PasswordSpecificsData_Notes_Note& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData.Notes.Note)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_unique_display_name(from._internal_unique_display_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      date_created_windows_epoch_micros_ = from.date_created_windows_epoch_micros_;
    }
    if (cached_has_bits & 0x00000008u) {
      hide_by_default_ = from.hide_by_default_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData_Notes_Note::CopyFrom(const PasswordSpecificsData_Notes_Note& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData.Notes.Note)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecificsData_Notes_Note::IsInitialized() const {
  return true;
}

void PasswordSpecificsData_Notes_Note::InternalSwap(PasswordSpecificsData_Notes_Note* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &unique_display_name_, lhs_arena,
      &other->unique_display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_Notes_Note, hide_by_default_)
      + sizeof(PasswordSpecificsData_Notes_Note::hide_by_default_)
      - PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_Notes_Note, date_created_windows_epoch_micros_)>(
          reinterpret_cast<char*>(&date_created_windows_epoch_micros_),
          reinterpret_cast<char*>(&other->date_created_windows_epoch_micros_));
}

std::string PasswordSpecificsData_Notes_Note::GetTypeName() const {
  return "sync_pb.PasswordSpecificsData.Notes.Note";
}


// ===================================================================

class PasswordSpecificsData_Notes::_Internal {
 public:
};

PasswordSpecificsData_Notes::PasswordSpecificsData_Notes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  note_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData.Notes)
}
PasswordSpecificsData_Notes::PasswordSpecificsData_Notes(const PasswordSpecificsData_Notes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      note_(from.note_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData.Notes)
}

inline void PasswordSpecificsData_Notes::SharedCtor() {
}

PasswordSpecificsData_Notes::~PasswordSpecificsData_Notes() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData.Notes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecificsData_Notes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PasswordSpecificsData_Notes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecificsData_Notes::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData.Notes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  note_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData_Notes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sync_pb.PasswordSpecificsData.Notes.Note note = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_note(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData_Notes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData.Notes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sync_pb.PasswordSpecificsData.Notes.Note note = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_note_size()); i < n; i++) {
    const auto& repfield = this->_internal_note(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData.Notes)
  return target;
}

size_t PasswordSpecificsData_Notes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData.Notes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sync_pb.PasswordSpecificsData.Notes.Note note = 1;
  total_size += 1UL * this->_internal_note_size();
  for (const auto& msg : this->note_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecificsData_Notes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData_Notes*>(
      &from));
}

void PasswordSpecificsData_Notes::MergeFrom(const PasswordSpecificsData_Notes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData.Notes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  note_.MergeFrom(from.note_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData_Notes::CopyFrom(const PasswordSpecificsData_Notes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData.Notes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecificsData_Notes::IsInitialized() const {
  return true;
}

void PasswordSpecificsData_Notes::InternalSwap(PasswordSpecificsData_Notes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  note_.InternalSwap(&other->note_);
}

std::string PasswordSpecificsData_Notes::GetTypeName() const {
  return "sync_pb.PasswordSpecificsData.Notes";
}


// ===================================================================

class PasswordSpecificsData::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordSpecificsData>()._has_bits_);
  static void set_has_scheme(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_signon_realm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_username_element(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_username_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_password_element(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_password_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ssl_valid(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_preferred(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_date_created(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_blacklisted(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_times_used(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_avatar_url(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_federation_url(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_date_last_used(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::sync_pb::PasswordSpecificsData_PasswordIssues& password_issues(const PasswordSpecificsData* msg);
  static void set_has_password_issues(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_date_password_modified_windows_epoch_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::sync_pb::PasswordSpecificsData_Notes& notes(const PasswordSpecificsData* msg);
  static void set_has_notes(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::sync_pb::PasswordSpecificsData_PasswordIssues&
PasswordSpecificsData::_Internal::password_issues(const PasswordSpecificsData* msg) {
  return *msg->password_issues_;
}
const ::sync_pb::PasswordSpecificsData_Notes&
PasswordSpecificsData::_Internal::notes(const PasswordSpecificsData* msg) {
  return *msg->notes_;
}
PasswordSpecificsData::PasswordSpecificsData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData)
}
PasswordSpecificsData::PasswordSpecificsData(const PasswordSpecificsData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  signon_realm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signon_realm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signon_realm()) {
    signon_realm_.Set(from._internal_signon_realm(), 
      GetArenaForAllocation());
  }
  origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_origin()) {
    origin_.Set(from._internal_origin(), 
      GetArenaForAllocation());
  }
  action_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    action_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_action()) {
    action_.Set(from._internal_action(), 
      GetArenaForAllocation());
  }
  username_element_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_element_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_username_element()) {
    username_element_.Set(from._internal_username_element(), 
      GetArenaForAllocation());
  }
  username_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_username_value()) {
    username_value_.Set(from._internal_username_value(), 
      GetArenaForAllocation());
  }
  password_element_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_element_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password_element()) {
    password_element_.Set(from._internal_password_element(), 
      GetArenaForAllocation());
  }
  password_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password_value()) {
    password_value_.Set(from._internal_password_value(), 
      GetArenaForAllocation());
  }
  display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_display_name()) {
    display_name_.Set(from._internal_display_name(), 
      GetArenaForAllocation());
  }
  avatar_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_url()) {
    avatar_url_.Set(from._internal_avatar_url(), 
      GetArenaForAllocation());
  }
  federation_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    federation_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_federation_url()) {
    federation_url_.Set(from._internal_federation_url(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_password_issues()) {
    password_issues_ = new ::sync_pb::PasswordSpecificsData_PasswordIssues(*from.password_issues_);
  } else {
    password_issues_ = nullptr;
  }
  if (from._internal_has_notes()) {
    notes_ = new ::sync_pb::PasswordSpecificsData_Notes(*from.notes_);
  } else {
    notes_ = nullptr;
  }
  ::memcpy(&scheme_, &from.scheme_,
    static_cast<size_t>(reinterpret_cast<char*>(&date_password_modified_windows_epoch_micros_) -
    reinterpret_cast<char*>(&scheme_)) + sizeof(date_password_modified_windows_epoch_micros_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData)
}

inline void PasswordSpecificsData::SharedCtor() {
signon_realm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signon_realm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
action_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  action_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
username_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
username_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
avatar_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
federation_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  federation_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&password_issues_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&date_password_modified_windows_epoch_micros_) -
    reinterpret_cast<char*>(&password_issues_)) + sizeof(date_password_modified_windows_epoch_micros_));
}

PasswordSpecificsData::~PasswordSpecificsData() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecificsData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signon_realm_.Destroy();
  origin_.Destroy();
  action_.Destroy();
  username_element_.Destroy();
  username_value_.Destroy();
  password_element_.Destroy();
  password_value_.Destroy();
  display_name_.Destroy();
  avatar_url_.Destroy();
  federation_url_.Destroy();
  if (this != internal_default_instance()) delete password_issues_;
  if (this != internal_default_instance()) delete notes_;
}

void PasswordSpecificsData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecificsData::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      signon_realm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      origin_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      action_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      username_element_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      username_value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      password_element_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      password_value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      display_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      avatar_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      federation_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(password_issues_ != nullptr);
      password_issues_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(notes_ != nullptr);
      notes_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&scheme_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&blacklisted_) -
        reinterpret_cast<char*>(&scheme_)) + sizeof(blacklisted_));
  }
  if (cached_has_bits & 0x001f0000u) {
    ::memset(&date_created_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&date_password_modified_windows_epoch_micros_) -
        reinterpret_cast<char*>(&date_created_)) + sizeof(date_password_modified_windows_epoch_micros_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 scheme = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_scheme(&has_bits);
          scheme_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signon_realm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signon_realm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string origin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_origin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_action();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string username_element = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_username_element();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string username_value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_username_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password_element = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_password_element();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_password_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ssl_valid = 9 [deprecated = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_ssl_valid(&has_bits);
          ssl_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool preferred = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_preferred(&has_bits);
          preferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 date_created = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_date_created(&has_bits);
          date_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool blacklisted = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_blacklisted(&has_bits);
          blacklisted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 times_used = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_times_used(&has_bits);
          times_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string display_name = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string avatar_url = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_avatar_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string federation_url = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_federation_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 date_last_used = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_date_last_used(&has_bits);
          date_last_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsData.PasswordIssues password_issues = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_password_issues(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 date_password_modified_windows_epoch_micros = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_date_password_modified_windows_epoch_micros(&has_bits);
          date_password_modified_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsData.Notes notes = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_notes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 scheme = 1;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_scheme(), target);
  }

  // optional string signon_realm = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_signon_realm(), target);
  }

  // optional string origin = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_origin(), target);
  }

  // optional string action = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_action(), target);
  }

  // optional string username_element = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_username_element(), target);
  }

  // optional string username_value = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_username_value(), target);
  }

  // optional string password_element = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_password_element(), target);
  }

  // optional string password_value = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_password_value(), target);
  }

  // optional bool ssl_valid = 9 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_ssl_valid(), target);
  }

  // optional bool preferred = 10 [deprecated = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_preferred(), target);
  }

  // optional int64 date_created = 11;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_date_created(), target);
  }

  // optional bool blacklisted = 12;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_blacklisted(), target);
  }

  // optional int32 type = 13;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_type(), target);
  }

  // optional int32 times_used = 14;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_times_used(), target);
  }

  // optional string display_name = 15;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_display_name(), target);
  }

  // optional string avatar_url = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_avatar_url(), target);
  }

  // optional string federation_url = 17;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_federation_url(), target);
  }

  // optional int64 date_last_used = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(18, this->_internal_date_last_used(), target);
  }

  // optional .sync_pb.PasswordSpecificsData.PasswordIssues password_issues = 19;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::password_issues(this),
        _Internal::password_issues(this).GetCachedSize(), target, stream);
  }

  // optional int64 date_password_modified_windows_epoch_micros = 20;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(20, this->_internal_date_password_modified_windows_epoch_micros(), target);
  }

  // optional .sync_pb.PasswordSpecificsData.Notes notes = 21;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::notes(this),
        _Internal::notes(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData)
  return target;
}

size_t PasswordSpecificsData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string signon_realm = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signon_realm());
    }

    // optional string origin = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_origin());
    }

    // optional string action = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_action());
    }

    // optional string username_element = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_username_element());
    }

    // optional string username_value = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_username_value());
    }

    // optional string password_element = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password_element());
    }

    // optional string password_value = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password_value());
    }

    // optional string display_name = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_display_name());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string avatar_url = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_avatar_url());
    }

    // optional string federation_url = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_federation_url());
    }

    // optional .sync_pb.PasswordSpecificsData.PasswordIssues password_issues = 19;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *password_issues_);
    }

    // optional .sync_pb.PasswordSpecificsData.Notes notes = 21;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *notes_);
    }

    // optional int32 scheme = 1;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_scheme());
    }

    // optional bool ssl_valid = 9 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool preferred = 10 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool blacklisted = 12;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x001f0000u) {
    // optional int64 date_created = 11;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_date_created());
    }

    // optional int32 type = 13;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 times_used = 14;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_times_used());
    }

    // optional int64 date_last_used = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_date_last_used());
    }

    // optional int64 date_password_modified_windows_epoch_micros = 20;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_date_password_modified_windows_epoch_micros());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecificsData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData*>(
      &from));
}

void PasswordSpecificsData::MergeFrom(const PasswordSpecificsData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_signon_realm(from._internal_signon_realm());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_origin(from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_action(from._internal_action());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_username_element(from._internal_username_element());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_username_value(from._internal_username_value());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_password_element(from._internal_password_element());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_password_value(from._internal_password_value());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_display_name(from._internal_display_name());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_avatar_url(from._internal_avatar_url());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_federation_url(from._internal_federation_url());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_password_issues()->::sync_pb::PasswordSpecificsData_PasswordIssues::MergeFrom(from._internal_password_issues());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_notes()->::sync_pb::PasswordSpecificsData_Notes::MergeFrom(from._internal_notes());
    }
    if (cached_has_bits & 0x00001000u) {
      scheme_ = from.scheme_;
    }
    if (cached_has_bits & 0x00002000u) {
      ssl_valid_ = from.ssl_valid_;
    }
    if (cached_has_bits & 0x00004000u) {
      preferred_ = from.preferred_;
    }
    if (cached_has_bits & 0x00008000u) {
      blacklisted_ = from.blacklisted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      date_created_ = from.date_created_;
    }
    if (cached_has_bits & 0x00020000u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00040000u) {
      times_used_ = from.times_used_;
    }
    if (cached_has_bits & 0x00080000u) {
      date_last_used_ = from.date_last_used_;
    }
    if (cached_has_bits & 0x00100000u) {
      date_password_modified_windows_epoch_micros_ = from.date_password_modified_windows_epoch_micros_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData::CopyFrom(const PasswordSpecificsData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecificsData::IsInitialized() const {
  return true;
}

void PasswordSpecificsData::InternalSwap(PasswordSpecificsData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &signon_realm_, lhs_arena,
      &other->signon_realm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &origin_, lhs_arena,
      &other->origin_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &action_, lhs_arena,
      &other->action_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &username_element_, lhs_arena,
      &other->username_element_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &username_value_, lhs_arena,
      &other->username_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &password_element_, lhs_arena,
      &other->password_element_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &password_value_, lhs_arena,
      &other->password_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &display_name_, lhs_arena,
      &other->display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &avatar_url_, lhs_arena,
      &other->avatar_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &federation_url_, lhs_arena,
      &other->federation_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasswordSpecificsData, date_password_modified_windows_epoch_micros_)
      + sizeof(PasswordSpecificsData::date_password_modified_windows_epoch_micros_)
      - PROTOBUF_FIELD_OFFSET(PasswordSpecificsData, password_issues_)>(
          reinterpret_cast<char*>(&password_issues_),
          reinterpret_cast<char*>(&other->password_issues_));
}

std::string PasswordSpecificsData::GetTypeName() const {
  return "sync_pb.PasswordSpecificsData";
}


// ===================================================================

class PasswordSpecificsMetadata::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordSpecificsMetadata>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blacklisted(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PasswordSpecificsMetadata::PasswordSpecificsMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsMetadata)
}
PasswordSpecificsMetadata::PasswordSpecificsMetadata(const PasswordSpecificsMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  blacklisted_ = from.blacklisted_;
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsMetadata)
}

inline void PasswordSpecificsMetadata::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
blacklisted_ = false;
}

PasswordSpecificsMetadata::~PasswordSpecificsMetadata() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecificsMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void PasswordSpecificsMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecificsMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  blacklisted_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool blacklisted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_blacklisted(&has_bits);
          blacklisted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional bool blacklisted = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_blacklisted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsMetadata)
  return target;
}

size_t PasswordSpecificsMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional bool blacklisted = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecificsMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecificsMetadata*>(
      &from));
}

void PasswordSpecificsMetadata::MergeFrom(const PasswordSpecificsMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      blacklisted_ = from.blacklisted_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsMetadata::CopyFrom(const PasswordSpecificsMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecificsMetadata::IsInitialized() const {
  return true;
}

void PasswordSpecificsMetadata::InternalSwap(PasswordSpecificsMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  swap(blacklisted_, other->blacklisted_);
}

std::string PasswordSpecificsMetadata::GetTypeName() const {
  return "sync_pb.PasswordSpecificsMetadata";
}


// ===================================================================

class PasswordSpecifics::_Internal {
 public:
  using HasBits = decltype(std::declval<PasswordSpecifics>()._has_bits_);
  static const ::sync_pb::EncryptedData& encrypted(const PasswordSpecifics* msg);
  static void set_has_encrypted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sync_pb::PasswordSpecificsData& client_only_encrypted_data(const PasswordSpecifics* msg);
  static void set_has_client_only_encrypted_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sync_pb::PasswordSpecificsMetadata& unencrypted_metadata(const PasswordSpecifics* msg);
  static void set_has_unencrypted_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sync_pb::EncryptedData& encrypted_notes_backup(const PasswordSpecifics* msg);
  static void set_has_encrypted_notes_backup(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::sync_pb::EncryptedData&
PasswordSpecifics::_Internal::encrypted(const PasswordSpecifics* msg) {
  return *msg->encrypted_;
}
const ::sync_pb::PasswordSpecificsData&
PasswordSpecifics::_Internal::client_only_encrypted_data(const PasswordSpecifics* msg) {
  return *msg->client_only_encrypted_data_;
}
const ::sync_pb::PasswordSpecificsMetadata&
PasswordSpecifics::_Internal::unencrypted_metadata(const PasswordSpecifics* msg) {
  return *msg->unencrypted_metadata_;
}
const ::sync_pb::EncryptedData&
PasswordSpecifics::_Internal::encrypted_notes_backup(const PasswordSpecifics* msg) {
  return *msg->encrypted_notes_backup_;
}
void PasswordSpecifics::clear_encrypted() {
  if (encrypted_ != nullptr) encrypted_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void PasswordSpecifics::clear_encrypted_notes_backup() {
  if (encrypted_notes_backup_ != nullptr) encrypted_notes_backup_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
PasswordSpecifics::PasswordSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecifics)
}
PasswordSpecifics::PasswordSpecifics(const PasswordSpecifics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_encrypted()) {
    encrypted_ = new ::sync_pb::EncryptedData(*from.encrypted_);
  } else {
    encrypted_ = nullptr;
  }
  if (from._internal_has_client_only_encrypted_data()) {
    client_only_encrypted_data_ = new ::sync_pb::PasswordSpecificsData(*from.client_only_encrypted_data_);
  } else {
    client_only_encrypted_data_ = nullptr;
  }
  if (from._internal_has_unencrypted_metadata()) {
    unencrypted_metadata_ = new ::sync_pb::PasswordSpecificsMetadata(*from.unencrypted_metadata_);
  } else {
    unencrypted_metadata_ = nullptr;
  }
  if (from._internal_has_encrypted_notes_backup()) {
    encrypted_notes_backup_ = new ::sync_pb::EncryptedData(*from.encrypted_notes_backup_);
  } else {
    encrypted_notes_backup_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecifics)
}

inline void PasswordSpecifics::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&encrypted_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&encrypted_notes_backup_) -
    reinterpret_cast<char*>(&encrypted_)) + sizeof(encrypted_notes_backup_));
}

PasswordSpecifics::~PasswordSpecifics() {
  // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecifics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasswordSpecifics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete encrypted_;
  if (this != internal_default_instance()) delete client_only_encrypted_data_;
  if (this != internal_default_instance()) delete unencrypted_metadata_;
  if (this != internal_default_instance()) delete encrypted_notes_backup_;
}

void PasswordSpecifics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PasswordSpecifics::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecifics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(encrypted_ != nullptr);
      encrypted_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_only_encrypted_data_ != nullptr);
      client_only_encrypted_data_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(unencrypted_metadata_ != nullptr);
      unencrypted_metadata_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(encrypted_notes_backup_ != nullptr);
      encrypted_notes_backup_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.EncryptedData encrypted = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_encrypted(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_only_encrypted_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_unencrypted_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.EncryptedData encrypted_notes_backup = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_encrypted_notes_backup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecifics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecifics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.EncryptedData encrypted = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::encrypted(this),
        _Internal::encrypted(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::client_only_encrypted_data(this),
        _Internal::client_only_encrypted_data(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::unencrypted_metadata(this),
        _Internal::unencrypted_metadata(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.EncryptedData encrypted_notes_backup = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::encrypted_notes_backup(this),
        _Internal::encrypted_notes_backup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecifics)
  return target;
}

size_t PasswordSpecifics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecifics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .sync_pb.EncryptedData encrypted = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *encrypted_);
    }

    // optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_only_encrypted_data_);
    }

    // optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *unencrypted_metadata_);
    }

    // optional .sync_pb.EncryptedData encrypted_notes_backup = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *encrypted_notes_backup_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PasswordSpecifics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PasswordSpecifics*>(
      &from));
}

void PasswordSpecifics::MergeFrom(const PasswordSpecifics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecifics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_encrypted()->::sync_pb::EncryptedData::MergeFrom(from._internal_encrypted());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_only_encrypted_data()->::sync_pb::PasswordSpecificsData::MergeFrom(from._internal_client_only_encrypted_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_unencrypted_metadata()->::sync_pb::PasswordSpecificsMetadata::MergeFrom(from._internal_unencrypted_metadata());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_encrypted_notes_backup()->::sync_pb::EncryptedData::MergeFrom(from._internal_encrypted_notes_backup());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecifics::CopyFrom(const PasswordSpecifics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecifics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasswordSpecifics::IsInitialized() const {
  return true;
}

void PasswordSpecifics::InternalSwap(PasswordSpecifics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasswordSpecifics, encrypted_notes_backup_)
      + sizeof(PasswordSpecifics::encrypted_notes_backup_)
      - PROTOBUF_FIELD_OFFSET(PasswordSpecifics, encrypted_)>(
          reinterpret_cast<char*>(&encrypted_),
          reinterpret_cast<char*>(&other->encrypted_));
}

std::string PasswordSpecifics::GetTypeName() const {
  return "sync_pb.PasswordSpecifics";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecificsData_PasswordIssues_PasswordIssue >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData_PasswordIssues*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecificsData_PasswordIssues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecificsData_PasswordIssues >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData_Notes_Note*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecificsData_Notes_Note >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecificsData_Notes_Note >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData_Notes*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecificsData_Notes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecificsData_Notes >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecificsData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecificsData >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsMetadata*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecificsMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecificsMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecifics*
Arena::CreateMaybeMessage< ::sync_pb::PasswordSpecifics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::PasswordSpecifics >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
