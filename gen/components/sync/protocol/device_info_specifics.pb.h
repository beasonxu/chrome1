// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/device_info_specifics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/sync_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto {
  static const uint32_t offsets[];
};
namespace sync_pb {
class ChromeVersionInfo;
struct ChromeVersionInfoDefaultTypeInternal;
extern ChromeVersionInfoDefaultTypeInternal _ChromeVersionInfo_default_instance_;
class DeviceInfoSpecifics;
struct DeviceInfoSpecificsDefaultTypeInternal;
extern DeviceInfoSpecificsDefaultTypeInternal _DeviceInfoSpecifics_default_instance_;
class FeatureSpecificFields;
struct FeatureSpecificFieldsDefaultTypeInternal;
extern FeatureSpecificFieldsDefaultTypeInternal _FeatureSpecificFields_default_instance_;
class GooglePlayServicesVersionInfo;
struct GooglePlayServicesVersionInfoDefaultTypeInternal;
extern GooglePlayServicesVersionInfoDefaultTypeInternal _GooglePlayServicesVersionInfo_default_instance_;
class InvalidationSpecificFields;
struct InvalidationSpecificFieldsDefaultTypeInternal;
extern InvalidationSpecificFieldsDefaultTypeInternal _InvalidationSpecificFields_default_instance_;
class PhoneAsASecurityKeySpecificFields;
struct PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal;
extern PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal _PhoneAsASecurityKeySpecificFields_default_instance_;
class SharingSpecificFields;
struct SharingSpecificFieldsDefaultTypeInternal;
extern SharingSpecificFieldsDefaultTypeInternal _SharingSpecificFields_default_instance_;
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::sync_pb::ChromeVersionInfo* Arena::CreateMaybeMessage<::sync_pb::ChromeVersionInfo>(Arena*);
template<> ::sync_pb::DeviceInfoSpecifics* Arena::CreateMaybeMessage<::sync_pb::DeviceInfoSpecifics>(Arena*);
template<> ::sync_pb::FeatureSpecificFields* Arena::CreateMaybeMessage<::sync_pb::FeatureSpecificFields>(Arena*);
template<> ::sync_pb::GooglePlayServicesVersionInfo* Arena::CreateMaybeMessage<::sync_pb::GooglePlayServicesVersionInfo>(Arena*);
template<> ::sync_pb::InvalidationSpecificFields* Arena::CreateMaybeMessage<::sync_pb::InvalidationSpecificFields>(Arena*);
template<> ::sync_pb::PhoneAsASecurityKeySpecificFields* Arena::CreateMaybeMessage<::sync_pb::PhoneAsASecurityKeySpecificFields>(Arena*);
template<> ::sync_pb::SharingSpecificFields* Arena::CreateMaybeMessage<::sync_pb::SharingSpecificFields>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum SharingSpecificFields_EnabledFeatures : int {
  SharingSpecificFields_EnabledFeatures_UNKNOWN = 0,
  SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_VAPID = 1,
  SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_VAPID = 2,
  SharingSpecificFields_EnabledFeatures_SMS_FETCHER = 3,
  SharingSpecificFields_EnabledFeatures_REMOTE_COPY = 4,
  SharingSpecificFields_EnabledFeatures_DISCOVERY = 6,
  SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_V2 = 7,
  SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_V2 = 8,
  SharingSpecificFields_EnabledFeatures_OPTIMIZATION_GUIDE_PUSH_NOTIFICATION = 9
};
bool SharingSpecificFields_EnabledFeatures_IsValid(int value);
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields_EnabledFeatures_EnabledFeatures_MIN = SharingSpecificFields_EnabledFeatures_UNKNOWN;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields_EnabledFeatures_EnabledFeatures_MAX = SharingSpecificFields_EnabledFeatures_OPTIMIZATION_GUIDE_PUSH_NOTIFICATION;
constexpr int SharingSpecificFields_EnabledFeatures_EnabledFeatures_ARRAYSIZE = SharingSpecificFields_EnabledFeatures_EnabledFeatures_MAX + 1;

const std::string& SharingSpecificFields_EnabledFeatures_Name(SharingSpecificFields_EnabledFeatures value);
template<typename T>
inline const std::string& SharingSpecificFields_EnabledFeatures_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SharingSpecificFields_EnabledFeatures>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SharingSpecificFields_EnabledFeatures_Name.");
  return SharingSpecificFields_EnabledFeatures_Name(static_cast<SharingSpecificFields_EnabledFeatures>(enum_t_value));
}
bool SharingSpecificFields_EnabledFeatures_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharingSpecificFields_EnabledFeatures* value);
// ===================================================================

class DeviceInfoSpecifics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.DeviceInfoSpecifics) */ {
 public:
  inline DeviceInfoSpecifics() : DeviceInfoSpecifics(nullptr) {}
  ~DeviceInfoSpecifics() override;
  explicit PROTOBUF_CONSTEXPR DeviceInfoSpecifics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfoSpecifics(const DeviceInfoSpecifics& from);
  DeviceInfoSpecifics(DeviceInfoSpecifics&& from) noexcept
    : DeviceInfoSpecifics() {
    *this = ::std::move(from);
  }

  inline DeviceInfoSpecifics& operator=(const DeviceInfoSpecifics& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfoSpecifics& operator=(DeviceInfoSpecifics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DeviceInfoSpecifics& default_instance() {
    return *internal_default_instance();
  }
  enum ClientVersionInfoCase {
    kChromeVersionInfo = 17,
    kGooglePlayServicesVersionInfo = 18,
    CLIENT_VERSION_INFO_NOT_SET = 0,
  };

  static inline const DeviceInfoSpecifics* internal_default_instance() {
    return reinterpret_cast<const DeviceInfoSpecifics*>(
               &_DeviceInfoSpecifics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceInfoSpecifics& a, DeviceInfoSpecifics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DeviceInfoSpecifics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfoSpecifics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfoSpecifics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfoSpecifics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DeviceInfoSpecifics& from);
  void MergeFrom(const DeviceInfoSpecifics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceInfoSpecifics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.DeviceInfoSpecifics";
  }
  protected:
  explicit DeviceInfoSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacheGuidFieldNumber = 1,
    kClientNameFieldNumber = 2,
    kSyncUserAgentFieldNumber = 4,
    kChromeVersionFieldNumber = 5,
    kSigninScopedDeviceIdFieldNumber = 7,
    kModelFieldNumber = 11,
    kManufacturerFieldNumber = 12,
    kFullHardwareClassFieldNumber = 16,
    kFeatureFieldsFieldNumber = 9,
    kSharingFieldsFieldNumber = 10,
    kInvalidationFieldsFieldNumber = 14,
    kPaaskFieldsFieldNumber = 15,
    kDeprecatedBackupTimestampFieldNumber = 6,
    kLastUpdatedTimestampFieldNumber = 8,
    kDeviceTypeFieldNumber = 3,
    kPulseIntervalInMinutesFieldNumber = 13,
    kChromeVersionInfoFieldNumber = 17,
    kGooglePlayServicesVersionInfoFieldNumber = 18,
  };
  // optional string cache_guid = 1;
  bool has_cache_guid() const;
  private:
  bool _internal_has_cache_guid() const;
  public:
  void clear_cache_guid();
  const std::string& cache_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_guid();
  PROTOBUF_NODISCARD std::string* release_cache_guid();
  void set_allocated_cache_guid(std::string* cache_guid);
  private:
  const std::string& _internal_cache_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_guid(const std::string& value);
  std::string* _internal_mutable_cache_guid();
  public:

  // optional string client_name = 2;
  bool has_client_name() const;
  private:
  bool _internal_has_client_name() const;
  public:
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // optional string sync_user_agent = 4;
  bool has_sync_user_agent() const;
  private:
  bool _internal_has_sync_user_agent() const;
  public:
  void clear_sync_user_agent();
  const std::string& sync_user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sync_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sync_user_agent();
  PROTOBUF_NODISCARD std::string* release_sync_user_agent();
  void set_allocated_sync_user_agent(std::string* sync_user_agent);
  private:
  const std::string& _internal_sync_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_user_agent(const std::string& value);
  std::string* _internal_mutable_sync_user_agent();
  public:

  // optional string chrome_version = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_chrome_version() const;
  private:
  bool _internal_has_chrome_version() const;
  public:
  PROTOBUF_DEPRECATED void clear_chrome_version();
  PROTOBUF_DEPRECATED const std::string& chrome_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_chrome_version(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_chrome_version();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_chrome_version();
  PROTOBUF_DEPRECATED void set_allocated_chrome_version(std::string* chrome_version);
  private:
  const std::string& _internal_chrome_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_version(const std::string& value);
  std::string* _internal_mutable_chrome_version();
  public:

  // optional string signin_scoped_device_id = 7;
  bool has_signin_scoped_device_id() const;
  private:
  bool _internal_has_signin_scoped_device_id() const;
  public:
  void clear_signin_scoped_device_id();
  const std::string& signin_scoped_device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signin_scoped_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signin_scoped_device_id();
  PROTOBUF_NODISCARD std::string* release_signin_scoped_device_id();
  void set_allocated_signin_scoped_device_id(std::string* signin_scoped_device_id);
  private:
  const std::string& _internal_signin_scoped_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signin_scoped_device_id(const std::string& value);
  std::string* _internal_mutable_signin_scoped_device_id();
  public:

  // optional string model = 11;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional string manufacturer = 12;
  bool has_manufacturer() const;
  private:
  bool _internal_has_manufacturer() const;
  public:
  void clear_manufacturer();
  const std::string& manufacturer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manufacturer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manufacturer();
  PROTOBUF_NODISCARD std::string* release_manufacturer();
  void set_allocated_manufacturer(std::string* manufacturer);
  private:
  const std::string& _internal_manufacturer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
  std::string* _internal_mutable_manufacturer();
  public:

  // optional string full_hardware_class = 16;
  bool has_full_hardware_class() const;
  private:
  bool _internal_has_full_hardware_class() const;
  public:
  void clear_full_hardware_class();
  const std::string& full_hardware_class() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_hardware_class(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_hardware_class();
  PROTOBUF_NODISCARD std::string* release_full_hardware_class();
  void set_allocated_full_hardware_class(std::string* full_hardware_class);
  private:
  const std::string& _internal_full_hardware_class() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_hardware_class(const std::string& value);
  std::string* _internal_mutable_full_hardware_class();
  public:

  // optional .sync_pb.FeatureSpecificFields feature_fields = 9;
  bool has_feature_fields() const;
  private:
  bool _internal_has_feature_fields() const;
  public:
  void clear_feature_fields();
  const ::sync_pb::FeatureSpecificFields& feature_fields() const;
  PROTOBUF_NODISCARD ::sync_pb::FeatureSpecificFields* release_feature_fields();
  ::sync_pb::FeatureSpecificFields* mutable_feature_fields();
  void set_allocated_feature_fields(::sync_pb::FeatureSpecificFields* feature_fields);
  private:
  const ::sync_pb::FeatureSpecificFields& _internal_feature_fields() const;
  ::sync_pb::FeatureSpecificFields* _internal_mutable_feature_fields();
  public:
  void unsafe_arena_set_allocated_feature_fields(
      ::sync_pb::FeatureSpecificFields* feature_fields);
  ::sync_pb::FeatureSpecificFields* unsafe_arena_release_feature_fields();

  // optional .sync_pb.SharingSpecificFields sharing_fields = 10;
  bool has_sharing_fields() const;
  private:
  bool _internal_has_sharing_fields() const;
  public:
  void clear_sharing_fields();
  const ::sync_pb::SharingSpecificFields& sharing_fields() const;
  PROTOBUF_NODISCARD ::sync_pb::SharingSpecificFields* release_sharing_fields();
  ::sync_pb::SharingSpecificFields* mutable_sharing_fields();
  void set_allocated_sharing_fields(::sync_pb::SharingSpecificFields* sharing_fields);
  private:
  const ::sync_pb::SharingSpecificFields& _internal_sharing_fields() const;
  ::sync_pb::SharingSpecificFields* _internal_mutable_sharing_fields();
  public:
  void unsafe_arena_set_allocated_sharing_fields(
      ::sync_pb::SharingSpecificFields* sharing_fields);
  ::sync_pb::SharingSpecificFields* unsafe_arena_release_sharing_fields();

  // optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
  bool has_invalidation_fields() const;
  private:
  bool _internal_has_invalidation_fields() const;
  public:
  void clear_invalidation_fields();
  const ::sync_pb::InvalidationSpecificFields& invalidation_fields() const;
  PROTOBUF_NODISCARD ::sync_pb::InvalidationSpecificFields* release_invalidation_fields();
  ::sync_pb::InvalidationSpecificFields* mutable_invalidation_fields();
  void set_allocated_invalidation_fields(::sync_pb::InvalidationSpecificFields* invalidation_fields);
  private:
  const ::sync_pb::InvalidationSpecificFields& _internal_invalidation_fields() const;
  ::sync_pb::InvalidationSpecificFields* _internal_mutable_invalidation_fields();
  public:
  void unsafe_arena_set_allocated_invalidation_fields(
      ::sync_pb::InvalidationSpecificFields* invalidation_fields);
  ::sync_pb::InvalidationSpecificFields* unsafe_arena_release_invalidation_fields();

  // optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
  bool has_paask_fields() const;
  private:
  bool _internal_has_paask_fields() const;
  public:
  void clear_paask_fields();
  const ::sync_pb::PhoneAsASecurityKeySpecificFields& paask_fields() const;
  PROTOBUF_NODISCARD ::sync_pb::PhoneAsASecurityKeySpecificFields* release_paask_fields();
  ::sync_pb::PhoneAsASecurityKeySpecificFields* mutable_paask_fields();
  void set_allocated_paask_fields(::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields);
  private:
  const ::sync_pb::PhoneAsASecurityKeySpecificFields& _internal_paask_fields() const;
  ::sync_pb::PhoneAsASecurityKeySpecificFields* _internal_mutable_paask_fields();
  public:
  void unsafe_arena_set_allocated_paask_fields(
      ::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields);
  ::sync_pb::PhoneAsASecurityKeySpecificFields* unsafe_arena_release_paask_fields();

  // optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_deprecated_backup_timestamp() const;
  private:
  bool _internal_has_deprecated_backup_timestamp() const;
  public:
  PROTOBUF_DEPRECATED void clear_deprecated_backup_timestamp();
  PROTOBUF_DEPRECATED int64_t deprecated_backup_timestamp() const;
  PROTOBUF_DEPRECATED void set_deprecated_backup_timestamp(int64_t value);
  private:
  int64_t _internal_deprecated_backup_timestamp() const;
  void _internal_set_deprecated_backup_timestamp(int64_t value);
  public:

  // optional int64 last_updated_timestamp = 8;
  bool has_last_updated_timestamp() const;
  private:
  bool _internal_has_last_updated_timestamp() const;
  public:
  void clear_last_updated_timestamp();
  int64_t last_updated_timestamp() const;
  void set_last_updated_timestamp(int64_t value);
  private:
  int64_t _internal_last_updated_timestamp() const;
  void _internal_set_last_updated_timestamp(int64_t value);
  public:

  // optional .sync_pb.SyncEnums.DeviceType device_type = 3;
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::sync_pb::SyncEnums_DeviceType device_type() const;
  void set_device_type(::sync_pb::SyncEnums_DeviceType value);
  private:
  ::sync_pb::SyncEnums_DeviceType _internal_device_type() const;
  void _internal_set_device_type(::sync_pb::SyncEnums_DeviceType value);
  public:

  // optional int32 pulse_interval_in_minutes = 13;
  bool has_pulse_interval_in_minutes() const;
  private:
  bool _internal_has_pulse_interval_in_minutes() const;
  public:
  void clear_pulse_interval_in_minutes();
  int32_t pulse_interval_in_minutes() const;
  void set_pulse_interval_in_minutes(int32_t value);
  private:
  int32_t _internal_pulse_interval_in_minutes() const;
  void _internal_set_pulse_interval_in_minutes(int32_t value);
  public:

  // .sync_pb.ChromeVersionInfo chrome_version_info = 17;
  bool has_chrome_version_info() const;
  private:
  bool _internal_has_chrome_version_info() const;
  public:
  void clear_chrome_version_info();
  const ::sync_pb::ChromeVersionInfo& chrome_version_info() const;
  PROTOBUF_NODISCARD ::sync_pb::ChromeVersionInfo* release_chrome_version_info();
  ::sync_pb::ChromeVersionInfo* mutable_chrome_version_info();
  void set_allocated_chrome_version_info(::sync_pb::ChromeVersionInfo* chrome_version_info);
  private:
  const ::sync_pb::ChromeVersionInfo& _internal_chrome_version_info() const;
  ::sync_pb::ChromeVersionInfo* _internal_mutable_chrome_version_info();
  public:
  void unsafe_arena_set_allocated_chrome_version_info(
      ::sync_pb::ChromeVersionInfo* chrome_version_info);
  ::sync_pb::ChromeVersionInfo* unsafe_arena_release_chrome_version_info();

  // .sync_pb.GooglePlayServicesVersionInfo google_play_services_version_info = 18;
  bool has_google_play_services_version_info() const;
  private:
  bool _internal_has_google_play_services_version_info() const;
  public:
  void clear_google_play_services_version_info();
  const ::sync_pb::GooglePlayServicesVersionInfo& google_play_services_version_info() const;
  PROTOBUF_NODISCARD ::sync_pb::GooglePlayServicesVersionInfo* release_google_play_services_version_info();
  ::sync_pb::GooglePlayServicesVersionInfo* mutable_google_play_services_version_info();
  void set_allocated_google_play_services_version_info(::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info);
  private:
  const ::sync_pb::GooglePlayServicesVersionInfo& _internal_google_play_services_version_info() const;
  ::sync_pb::GooglePlayServicesVersionInfo* _internal_mutable_google_play_services_version_info();
  public:
  void unsafe_arena_set_allocated_google_play_services_version_info(
      ::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info);
  ::sync_pb::GooglePlayServicesVersionInfo* unsafe_arena_release_google_play_services_version_info();

  void clear_client_version_info();
  ClientVersionInfoCase client_version_info_case() const;
  // @@protoc_insertion_point(class_scope:sync_pb.DeviceInfoSpecifics)
 private:
  class _Internal;
  void set_has_chrome_version_info();
  void set_has_google_play_services_version_info();

  inline bool has_client_version_info() const;
  inline void clear_has_client_version_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_user_agent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signin_scoped_device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_hardware_class_;
  ::sync_pb::FeatureSpecificFields* feature_fields_;
  ::sync_pb::SharingSpecificFields* sharing_fields_;
  ::sync_pb::InvalidationSpecificFields* invalidation_fields_;
  ::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields_;
  int64_t deprecated_backup_timestamp_;
  int64_t last_updated_timestamp_;
  int device_type_;
  int32_t pulse_interval_in_minutes_;
  union ClientVersionInfoUnion {
    constexpr ClientVersionInfoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sync_pb::ChromeVersionInfo* chrome_version_info_;
    ::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info_;
  } client_version_info_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class FeatureSpecificFields final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.FeatureSpecificFields) */ {
 public:
  inline FeatureSpecificFields() : FeatureSpecificFields(nullptr) {}
  ~FeatureSpecificFields() override;
  explicit PROTOBUF_CONSTEXPR FeatureSpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureSpecificFields(const FeatureSpecificFields& from);
  FeatureSpecificFields(FeatureSpecificFields&& from) noexcept
    : FeatureSpecificFields() {
    *this = ::std::move(from);
  }

  inline FeatureSpecificFields& operator=(const FeatureSpecificFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureSpecificFields& operator=(FeatureSpecificFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FeatureSpecificFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureSpecificFields* internal_default_instance() {
    return reinterpret_cast<const FeatureSpecificFields*>(
               &_FeatureSpecificFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FeatureSpecificFields& a, FeatureSpecificFields& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FeatureSpecificFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureSpecificFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureSpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureSpecificFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FeatureSpecificFields& from);
  void MergeFrom(const FeatureSpecificFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureSpecificFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.FeatureSpecificFields";
  }
  protected:
  explicit FeatureSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendTabToSelfReceivingEnabledFieldNumber = 1,
  };
  // optional bool send_tab_to_self_receiving_enabled = 1;
  bool has_send_tab_to_self_receiving_enabled() const;
  private:
  bool _internal_has_send_tab_to_self_receiving_enabled() const;
  public:
  void clear_send_tab_to_self_receiving_enabled();
  bool send_tab_to_self_receiving_enabled() const;
  void set_send_tab_to_self_receiving_enabled(bool value);
  private:
  bool _internal_send_tab_to_self_receiving_enabled() const;
  void _internal_set_send_tab_to_self_receiving_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.FeatureSpecificFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool send_tab_to_self_receiving_enabled_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SharingSpecificFields final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SharingSpecificFields) */ {
 public:
  inline SharingSpecificFields() : SharingSpecificFields(nullptr) {}
  ~SharingSpecificFields() override;
  explicit PROTOBUF_CONSTEXPR SharingSpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharingSpecificFields(const SharingSpecificFields& from);
  SharingSpecificFields(SharingSpecificFields&& from) noexcept
    : SharingSpecificFields() {
    *this = ::std::move(from);
  }

  inline SharingSpecificFields& operator=(const SharingSpecificFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharingSpecificFields& operator=(SharingSpecificFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SharingSpecificFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharingSpecificFields* internal_default_instance() {
    return reinterpret_cast<const SharingSpecificFields*>(
               &_SharingSpecificFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SharingSpecificFields& a, SharingSpecificFields& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SharingSpecificFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharingSpecificFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharingSpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharingSpecificFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SharingSpecificFields& from);
  void MergeFrom(const SharingSpecificFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharingSpecificFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.SharingSpecificFields";
  }
  protected:
  explicit SharingSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SharingSpecificFields_EnabledFeatures EnabledFeatures;
  static constexpr EnabledFeatures UNKNOWN =
    SharingSpecificFields_EnabledFeatures_UNKNOWN;
  static constexpr EnabledFeatures CLICK_TO_CALL_VAPID =
    SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_VAPID;
  static constexpr EnabledFeatures SHARED_CLIPBOARD_VAPID =
    SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_VAPID;
  static constexpr EnabledFeatures SMS_FETCHER =
    SharingSpecificFields_EnabledFeatures_SMS_FETCHER;
  static constexpr EnabledFeatures REMOTE_COPY =
    SharingSpecificFields_EnabledFeatures_REMOTE_COPY;
  static constexpr EnabledFeatures DISCOVERY =
    SharingSpecificFields_EnabledFeatures_DISCOVERY;
  static constexpr EnabledFeatures CLICK_TO_CALL_V2 =
    SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_V2;
  static constexpr EnabledFeatures SHARED_CLIPBOARD_V2 =
    SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_V2;
  static constexpr EnabledFeatures OPTIMIZATION_GUIDE_PUSH_NOTIFICATION =
    SharingSpecificFields_EnabledFeatures_OPTIMIZATION_GUIDE_PUSH_NOTIFICATION;
  static inline bool EnabledFeatures_IsValid(int value) {
    return SharingSpecificFields_EnabledFeatures_IsValid(value);
  }
  static constexpr EnabledFeatures EnabledFeatures_MIN =
    SharingSpecificFields_EnabledFeatures_EnabledFeatures_MIN;
  static constexpr EnabledFeatures EnabledFeatures_MAX =
    SharingSpecificFields_EnabledFeatures_EnabledFeatures_MAX;
  static constexpr int EnabledFeatures_ARRAYSIZE =
    SharingSpecificFields_EnabledFeatures_EnabledFeatures_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EnabledFeatures_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnabledFeatures>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnabledFeatures_Name.");
    return SharingSpecificFields_EnabledFeatures_Name(enum_t_value);
  }
  static inline bool EnabledFeatures_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnabledFeatures* value) {
    return SharingSpecificFields_EnabledFeatures_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFeaturesFieldNumber = 4,
    kVapidFcmTokenFieldNumber = 1,
    kVapidP256DhFieldNumber = 2,
    kVapidAuthSecretFieldNumber = 3,
    kSenderIdFcmTokenDeprecatedFieldNumber = 5,
    kSenderIdP256DhDeprecatedFieldNumber = 6,
    kSenderIdAuthSecretDeprecatedFieldNumber = 7,
    kSenderIdFcmTokenV2FieldNumber = 8,
    kSenderIdP256DhV2FieldNumber = 9,
    kSenderIdAuthSecretV2FieldNumber = 10,
  };
  // repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
  int enabled_features_size() const;
  private:
  int _internal_enabled_features_size() const;
  public:
  void clear_enabled_features();
  private:
  ::sync_pb::SharingSpecificFields_EnabledFeatures _internal_enabled_features(int index) const;
  void _internal_add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_enabled_features();
  public:
  ::sync_pb::SharingSpecificFields_EnabledFeatures enabled_features(int index) const;
  void set_enabled_features(int index, ::sync_pb::SharingSpecificFields_EnabledFeatures value);
  void add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& enabled_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_enabled_features();

  // optional string vapid_fcm_token = 1;
  bool has_vapid_fcm_token() const;
  private:
  bool _internal_has_vapid_fcm_token() const;
  public:
  void clear_vapid_fcm_token();
  const std::string& vapid_fcm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vapid_fcm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vapid_fcm_token();
  PROTOBUF_NODISCARD std::string* release_vapid_fcm_token();
  void set_allocated_vapid_fcm_token(std::string* vapid_fcm_token);
  private:
  const std::string& _internal_vapid_fcm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_fcm_token(const std::string& value);
  std::string* _internal_mutable_vapid_fcm_token();
  public:

  // optional bytes vapid_p256dh = 2;
  bool has_vapid_p256dh() const;
  private:
  bool _internal_has_vapid_p256dh() const;
  public:
  void clear_vapid_p256dh();
  const std::string& vapid_p256dh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vapid_p256dh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vapid_p256dh();
  PROTOBUF_NODISCARD std::string* release_vapid_p256dh();
  void set_allocated_vapid_p256dh(std::string* vapid_p256dh);
  private:
  const std::string& _internal_vapid_p256dh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_p256dh(const std::string& value);
  std::string* _internal_mutable_vapid_p256dh();
  public:

  // optional bytes vapid_auth_secret = 3;
  bool has_vapid_auth_secret() const;
  private:
  bool _internal_has_vapid_auth_secret() const;
  public:
  void clear_vapid_auth_secret();
  const std::string& vapid_auth_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vapid_auth_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vapid_auth_secret();
  PROTOBUF_NODISCARD std::string* release_vapid_auth_secret();
  void set_allocated_vapid_auth_secret(std::string* vapid_auth_secret);
  private:
  const std::string& _internal_vapid_auth_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_auth_secret(const std::string& value);
  std::string* _internal_mutable_vapid_auth_secret();
  public:

  // optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_sender_id_fcm_token_deprecated() const;
  private:
  bool _internal_has_sender_id_fcm_token_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_sender_id_fcm_token_deprecated();
  PROTOBUF_DEPRECATED const std::string& sender_id_fcm_token_deprecated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_sender_id_fcm_token_deprecated(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_sender_id_fcm_token_deprecated();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_sender_id_fcm_token_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_sender_id_fcm_token_deprecated(std::string* sender_id_fcm_token_deprecated);
  private:
  const std::string& _internal_sender_id_fcm_token_deprecated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_fcm_token_deprecated(const std::string& value);
  std::string* _internal_mutable_sender_id_fcm_token_deprecated();
  public:

  // optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_sender_id_p256dh_deprecated() const;
  private:
  bool _internal_has_sender_id_p256dh_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_sender_id_p256dh_deprecated();
  PROTOBUF_DEPRECATED const std::string& sender_id_p256dh_deprecated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_sender_id_p256dh_deprecated(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_sender_id_p256dh_deprecated();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_sender_id_p256dh_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_sender_id_p256dh_deprecated(std::string* sender_id_p256dh_deprecated);
  private:
  const std::string& _internal_sender_id_p256dh_deprecated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_p256dh_deprecated(const std::string& value);
  std::string* _internal_mutable_sender_id_p256dh_deprecated();
  public:

  // optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_sender_id_auth_secret_deprecated() const;
  private:
  bool _internal_has_sender_id_auth_secret_deprecated() const;
  public:
  PROTOBUF_DEPRECATED void clear_sender_id_auth_secret_deprecated();
  PROTOBUF_DEPRECATED const std::string& sender_id_auth_secret_deprecated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_sender_id_auth_secret_deprecated(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_sender_id_auth_secret_deprecated();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_sender_id_auth_secret_deprecated();
  PROTOBUF_DEPRECATED void set_allocated_sender_id_auth_secret_deprecated(std::string* sender_id_auth_secret_deprecated);
  private:
  const std::string& _internal_sender_id_auth_secret_deprecated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_auth_secret_deprecated(const std::string& value);
  std::string* _internal_mutable_sender_id_auth_secret_deprecated();
  public:

  // optional string sender_id_fcm_token_v2 = 8;
  bool has_sender_id_fcm_token_v2() const;
  private:
  bool _internal_has_sender_id_fcm_token_v2() const;
  public:
  void clear_sender_id_fcm_token_v2();
  const std::string& sender_id_fcm_token_v2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id_fcm_token_v2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id_fcm_token_v2();
  PROTOBUF_NODISCARD std::string* release_sender_id_fcm_token_v2();
  void set_allocated_sender_id_fcm_token_v2(std::string* sender_id_fcm_token_v2);
  private:
  const std::string& _internal_sender_id_fcm_token_v2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_fcm_token_v2(const std::string& value);
  std::string* _internal_mutable_sender_id_fcm_token_v2();
  public:

  // optional bytes sender_id_p256dh_v2 = 9;
  bool has_sender_id_p256dh_v2() const;
  private:
  bool _internal_has_sender_id_p256dh_v2() const;
  public:
  void clear_sender_id_p256dh_v2();
  const std::string& sender_id_p256dh_v2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id_p256dh_v2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id_p256dh_v2();
  PROTOBUF_NODISCARD std::string* release_sender_id_p256dh_v2();
  void set_allocated_sender_id_p256dh_v2(std::string* sender_id_p256dh_v2);
  private:
  const std::string& _internal_sender_id_p256dh_v2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_p256dh_v2(const std::string& value);
  std::string* _internal_mutable_sender_id_p256dh_v2();
  public:

  // optional bytes sender_id_auth_secret_v2 = 10;
  bool has_sender_id_auth_secret_v2() const;
  private:
  bool _internal_has_sender_id_auth_secret_v2() const;
  public:
  void clear_sender_id_auth_secret_v2();
  const std::string& sender_id_auth_secret_v2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id_auth_secret_v2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id_auth_secret_v2();
  PROTOBUF_NODISCARD std::string* release_sender_id_auth_secret_v2();
  void set_allocated_sender_id_auth_secret_v2(std::string* sender_id_auth_secret_v2);
  private:
  const std::string& _internal_sender_id_auth_secret_v2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_auth_secret_v2(const std::string& value);
  std::string* _internal_mutable_sender_id_auth_secret_v2();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.SharingSpecificFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> enabled_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_fcm_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_p256dh_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_auth_secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_fcm_token_deprecated_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_p256dh_deprecated_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_auth_secret_deprecated_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_fcm_token_v2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_p256dh_v2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_auth_secret_v2_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class InvalidationSpecificFields final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.InvalidationSpecificFields) */ {
 public:
  inline InvalidationSpecificFields() : InvalidationSpecificFields(nullptr) {}
  ~InvalidationSpecificFields() override;
  explicit PROTOBUF_CONSTEXPR InvalidationSpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvalidationSpecificFields(const InvalidationSpecificFields& from);
  InvalidationSpecificFields(InvalidationSpecificFields&& from) noexcept
    : InvalidationSpecificFields() {
    *this = ::std::move(from);
  }

  inline InvalidationSpecificFields& operator=(const InvalidationSpecificFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidationSpecificFields& operator=(InvalidationSpecificFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InvalidationSpecificFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvalidationSpecificFields* internal_default_instance() {
    return reinterpret_cast<const InvalidationSpecificFields*>(
               &_InvalidationSpecificFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InvalidationSpecificFields& a, InvalidationSpecificFields& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InvalidationSpecificFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvalidationSpecificFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvalidationSpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvalidationSpecificFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InvalidationSpecificFields& from);
  void MergeFrom(const InvalidationSpecificFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InvalidationSpecificFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.InvalidationSpecificFields";
  }
  protected:
  explicit InvalidationSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterestedDataTypeIdsFieldNumber = 2,
    kInstanceIdTokenFieldNumber = 1,
  };
  // repeated int32 interested_data_type_ids = 2;
  int interested_data_type_ids_size() const;
  private:
  int _internal_interested_data_type_ids_size() const;
  public:
  void clear_interested_data_type_ids();
  private:
  int32_t _internal_interested_data_type_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_interested_data_type_ids() const;
  void _internal_add_interested_data_type_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_interested_data_type_ids();
  public:
  int32_t interested_data_type_ids(int index) const;
  void set_interested_data_type_ids(int index, int32_t value);
  void add_interested_data_type_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      interested_data_type_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_interested_data_type_ids();

  // optional string instance_id_token = 1;
  bool has_instance_id_token() const;
  private:
  bool _internal_has_instance_id_token() const;
  public:
  void clear_instance_id_token();
  const std::string& instance_id_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id_token();
  PROTOBUF_NODISCARD std::string* release_instance_id_token();
  void set_allocated_instance_id_token(std::string* instance_id_token);
  private:
  const std::string& _internal_instance_id_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id_token(const std::string& value);
  std::string* _internal_mutable_instance_id_token();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.InvalidationSpecificFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > interested_data_type_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_token_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class PhoneAsASecurityKeySpecificFields final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.PhoneAsASecurityKeySpecificFields) */ {
 public:
  inline PhoneAsASecurityKeySpecificFields() : PhoneAsASecurityKeySpecificFields(nullptr) {}
  ~PhoneAsASecurityKeySpecificFields() override;
  explicit PROTOBUF_CONSTEXPR PhoneAsASecurityKeySpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhoneAsASecurityKeySpecificFields(const PhoneAsASecurityKeySpecificFields& from);
  PhoneAsASecurityKeySpecificFields(PhoneAsASecurityKeySpecificFields&& from) noexcept
    : PhoneAsASecurityKeySpecificFields() {
    *this = ::std::move(from);
  }

  inline PhoneAsASecurityKeySpecificFields& operator=(const PhoneAsASecurityKeySpecificFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneAsASecurityKeySpecificFields& operator=(PhoneAsASecurityKeySpecificFields&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PhoneAsASecurityKeySpecificFields& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhoneAsASecurityKeySpecificFields* internal_default_instance() {
    return reinterpret_cast<const PhoneAsASecurityKeySpecificFields*>(
               &_PhoneAsASecurityKeySpecificFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PhoneAsASecurityKeySpecificFields& a, PhoneAsASecurityKeySpecificFields& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PhoneAsASecurityKeySpecificFields* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneAsASecurityKeySpecificFields* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhoneAsASecurityKeySpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhoneAsASecurityKeySpecificFields>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PhoneAsASecurityKeySpecificFields& from);
  void MergeFrom(const PhoneAsASecurityKeySpecificFields& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PhoneAsASecurityKeySpecificFields* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.PhoneAsASecurityKeySpecificFields";
  }
  protected:
  explicit PhoneAsASecurityKeySpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContactIdFieldNumber = 2,
    kSecretFieldNumber = 3,
    kPeerPublicKeyX962FieldNumber = 5,
    kTunnelServerDomainFieldNumber = 1,
    kIdFieldNumber = 4,
  };
  // optional bytes contact_id = 2;
  bool has_contact_id() const;
  private:
  bool _internal_has_contact_id() const;
  public:
  void clear_contact_id();
  const std::string& contact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_id();
  PROTOBUF_NODISCARD std::string* release_contact_id();
  void set_allocated_contact_id(std::string* contact_id);
  private:
  const std::string& _internal_contact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_id(const std::string& value);
  std::string* _internal_mutable_contact_id();
  public:

  // optional bytes secret = 3;
  bool has_secret() const;
  private:
  bool _internal_has_secret() const;
  public:
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // optional bytes peer_public_key_x962 = 5;
  bool has_peer_public_key_x962() const;
  private:
  bool _internal_has_peer_public_key_x962() const;
  public:
  void clear_peer_public_key_x962();
  const std::string& peer_public_key_x962() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_public_key_x962(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_public_key_x962();
  PROTOBUF_NODISCARD std::string* release_peer_public_key_x962();
  void set_allocated_peer_public_key_x962(std::string* peer_public_key_x962);
  private:
  const std::string& _internal_peer_public_key_x962() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_public_key_x962(const std::string& value);
  std::string* _internal_mutable_peer_public_key_x962();
  public:

  // optional uint32 tunnel_server_domain = 1;
  bool has_tunnel_server_domain() const;
  private:
  bool _internal_has_tunnel_server_domain() const;
  public:
  void clear_tunnel_server_domain();
  uint32_t tunnel_server_domain() const;
  void set_tunnel_server_domain(uint32_t value);
  private:
  uint32_t _internal_tunnel_server_domain() const;
  void _internal_set_tunnel_server_domain(uint32_t value);
  public:

  // optional fixed32 id = 4;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.PhoneAsASecurityKeySpecificFields)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_public_key_x962_;
  uint32_t tunnel_server_domain_;
  uint32_t id_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class ChromeVersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ChromeVersionInfo) */ {
 public:
  inline ChromeVersionInfo() : ChromeVersionInfo(nullptr) {}
  ~ChromeVersionInfo() override;
  explicit PROTOBUF_CONSTEXPR ChromeVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromeVersionInfo(const ChromeVersionInfo& from);
  ChromeVersionInfo(ChromeVersionInfo&& from) noexcept
    : ChromeVersionInfo() {
    *this = ::std::move(from);
  }

  inline ChromeVersionInfo& operator=(const ChromeVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromeVersionInfo& operator=(ChromeVersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromeVersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromeVersionInfo* internal_default_instance() {
    return reinterpret_cast<const ChromeVersionInfo*>(
               &_ChromeVersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChromeVersionInfo& a, ChromeVersionInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ChromeVersionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromeVersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromeVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromeVersionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromeVersionInfo& from);
  void MergeFrom(const ChromeVersionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeVersionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ChromeVersionInfo";
  }
  protected:
  explicit ChromeVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionNumberFieldNumber = 1,
  };
  // optional string version_number = 1;
  bool has_version_number() const;
  private:
  bool _internal_has_version_number() const;
  public:
  void clear_version_number();
  const std::string& version_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_number();
  PROTOBUF_NODISCARD std::string* release_version_number();
  void set_allocated_version_number(std::string* version_number);
  private:
  const std::string& _internal_version_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_number(const std::string& value);
  std::string* _internal_mutable_version_number();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ChromeVersionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_number_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class GooglePlayServicesVersionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.GooglePlayServicesVersionInfo) */ {
 public:
  inline GooglePlayServicesVersionInfo() : GooglePlayServicesVersionInfo(nullptr) {}
  ~GooglePlayServicesVersionInfo() override;
  explicit PROTOBUF_CONSTEXPR GooglePlayServicesVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GooglePlayServicesVersionInfo(const GooglePlayServicesVersionInfo& from);
  GooglePlayServicesVersionInfo(GooglePlayServicesVersionInfo&& from) noexcept
    : GooglePlayServicesVersionInfo() {
    *this = ::std::move(from);
  }

  inline GooglePlayServicesVersionInfo& operator=(const GooglePlayServicesVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GooglePlayServicesVersionInfo& operator=(GooglePlayServicesVersionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GooglePlayServicesVersionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GooglePlayServicesVersionInfo* internal_default_instance() {
    return reinterpret_cast<const GooglePlayServicesVersionInfo*>(
               &_GooglePlayServicesVersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GooglePlayServicesVersionInfo& a, GooglePlayServicesVersionInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GooglePlayServicesVersionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GooglePlayServicesVersionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GooglePlayServicesVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GooglePlayServicesVersionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GooglePlayServicesVersionInfo& from);
  void MergeFrom(const GooglePlayServicesVersionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GooglePlayServicesVersionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.GooglePlayServicesVersionInfo";
  }
  protected:
  explicit GooglePlayServicesVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApkVersionNameFieldNumber = 1,
  };
  // optional string apk_version_name = 1;
  bool has_apk_version_name() const;
  private:
  bool _internal_has_apk_version_name() const;
  public:
  void clear_apk_version_name();
  const std::string& apk_version_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apk_version_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apk_version_name();
  PROTOBUF_NODISCARD std::string* release_apk_version_name();
  void set_allocated_apk_version_name(std::string* apk_version_name);
  private:
  const std::string& _internal_apk_version_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apk_version_name(const std::string& value);
  std::string* _internal_mutable_apk_version_name();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.GooglePlayServicesVersionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apk_version_name_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceInfoSpecifics

// optional string cache_guid = 1;
inline bool DeviceInfoSpecifics::_internal_has_cache_guid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_cache_guid() const {
  return _internal_has_cache_guid();
}
inline void DeviceInfoSpecifics::clear_cache_guid() {
  cache_guid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInfoSpecifics::cache_guid() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.cache_guid)
  return _internal_cache_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_cache_guid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cache_guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.cache_guid)
}
inline std::string* DeviceInfoSpecifics::mutable_cache_guid() {
  std::string* _s = _internal_mutable_cache_guid();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.cache_guid)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_cache_guid() const {
  return cache_guid_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_cache_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cache_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_cache_guid() {
  _has_bits_[0] |= 0x00000001u;
  return cache_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_cache_guid() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.cache_guid)
  if (!_internal_has_cache_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cache_guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_guid_.IsDefault()) {
    cache_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_cache_guid(std::string* cache_guid) {
  if (cache_guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cache_guid_.SetAllocated(cache_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_guid_.IsDefault()) {
    cache_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.cache_guid)
}

// optional string client_name = 2;
inline bool DeviceInfoSpecifics::_internal_has_client_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_client_name() const {
  return _internal_has_client_name();
}
inline void DeviceInfoSpecifics::clear_client_name() {
  client_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceInfoSpecifics::client_name() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_client_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.client_name)
}
inline std::string* DeviceInfoSpecifics::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.client_name)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_client_name() const {
  return client_name_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_client_name() {
  _has_bits_[0] |= 0x00000002u;
  return client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_client_name() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.client_name)
  if (!_internal_has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = client_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.client_name)
}

// optional .sync_pb.SyncEnums.DeviceType device_type = 3;
inline bool DeviceInfoSpecifics::_internal_has_device_type() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_device_type() const {
  return _internal_has_device_type();
}
inline void DeviceInfoSpecifics::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::sync_pb::SyncEnums_DeviceType DeviceInfoSpecifics::_internal_device_type() const {
  return static_cast< ::sync_pb::SyncEnums_DeviceType >(device_type_);
}
inline ::sync_pb::SyncEnums_DeviceType DeviceInfoSpecifics::device_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.device_type)
  return _internal_device_type();
}
inline void DeviceInfoSpecifics::_internal_set_device_type(::sync_pb::SyncEnums_DeviceType value) {
  assert(::sync_pb::SyncEnums_DeviceType_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  device_type_ = value;
}
inline void DeviceInfoSpecifics::set_device_type(::sync_pb::SyncEnums_DeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.device_type)
}

// optional string sync_user_agent = 4;
inline bool DeviceInfoSpecifics::_internal_has_sync_user_agent() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_sync_user_agent() const {
  return _internal_has_sync_user_agent();
}
inline void DeviceInfoSpecifics::clear_sync_user_agent() {
  sync_user_agent_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceInfoSpecifics::sync_user_agent() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.sync_user_agent)
  return _internal_sync_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_sync_user_agent(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sync_user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.sync_user_agent)
}
inline std::string* DeviceInfoSpecifics::mutable_sync_user_agent() {
  std::string* _s = _internal_mutable_sync_user_agent();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.sync_user_agent)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_sync_user_agent() const {
  return sync_user_agent_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_sync_user_agent(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sync_user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_sync_user_agent() {
  _has_bits_[0] |= 0x00000004u;
  return sync_user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_sync_user_agent() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.sync_user_agent)
  if (!_internal_has_sync_user_agent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = sync_user_agent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sync_user_agent_.IsDefault()) {
    sync_user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_sync_user_agent(std::string* sync_user_agent) {
  if (sync_user_agent != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sync_user_agent_.SetAllocated(sync_user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sync_user_agent_.IsDefault()) {
    sync_user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.sync_user_agent)
}

// optional string chrome_version = 5 [deprecated = true];
inline bool DeviceInfoSpecifics::_internal_has_chrome_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_chrome_version() const {
  return _internal_has_chrome_version();
}
inline void DeviceInfoSpecifics::clear_chrome_version() {
  chrome_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceInfoSpecifics::chrome_version() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.chrome_version)
  return _internal_chrome_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_chrome_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 chrome_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.chrome_version)
}
inline std::string* DeviceInfoSpecifics::mutable_chrome_version() {
  std::string* _s = _internal_mutable_chrome_version();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.chrome_version)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_chrome_version() const {
  return chrome_version_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_chrome_version(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  chrome_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_chrome_version() {
  _has_bits_[0] |= 0x00000008u;
  return chrome_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_chrome_version() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.chrome_version)
  if (!_internal_has_chrome_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = chrome_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chrome_version_.IsDefault()) {
    chrome_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_chrome_version(std::string* chrome_version) {
  if (chrome_version != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  chrome_version_.SetAllocated(chrome_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chrome_version_.IsDefault()) {
    chrome_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.chrome_version)
}

// optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
inline bool DeviceInfoSpecifics::_internal_has_deprecated_backup_timestamp() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_deprecated_backup_timestamp() const {
  return _internal_has_deprecated_backup_timestamp();
}
inline void DeviceInfoSpecifics::clear_deprecated_backup_timestamp() {
  deprecated_backup_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline int64_t DeviceInfoSpecifics::_internal_deprecated_backup_timestamp() const {
  return deprecated_backup_timestamp_;
}
inline int64_t DeviceInfoSpecifics::deprecated_backup_timestamp() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.deprecated_backup_timestamp)
  return _internal_deprecated_backup_timestamp();
}
inline void DeviceInfoSpecifics::_internal_set_deprecated_backup_timestamp(int64_t value) {
  _has_bits_[0] |= 0x00001000u;
  deprecated_backup_timestamp_ = value;
}
inline void DeviceInfoSpecifics::set_deprecated_backup_timestamp(int64_t value) {
  _internal_set_deprecated_backup_timestamp(value);
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.deprecated_backup_timestamp)
}

// optional string signin_scoped_device_id = 7;
inline bool DeviceInfoSpecifics::_internal_has_signin_scoped_device_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_signin_scoped_device_id() const {
  return _internal_has_signin_scoped_device_id();
}
inline void DeviceInfoSpecifics::clear_signin_scoped_device_id() {
  signin_scoped_device_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceInfoSpecifics::signin_scoped_device_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
  return _internal_signin_scoped_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_signin_scoped_device_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 signin_scoped_device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
}
inline std::string* DeviceInfoSpecifics::mutable_signin_scoped_device_id() {
  std::string* _s = _internal_mutable_signin_scoped_device_id();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_signin_scoped_device_id() const {
  return signin_scoped_device_id_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_signin_scoped_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  signin_scoped_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_signin_scoped_device_id() {
  _has_bits_[0] |= 0x00000010u;
  return signin_scoped_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_signin_scoped_device_id() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
  if (!_internal_has_signin_scoped_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = signin_scoped_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signin_scoped_device_id_.IsDefault()) {
    signin_scoped_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_signin_scoped_device_id(std::string* signin_scoped_device_id) {
  if (signin_scoped_device_id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  signin_scoped_device_id_.SetAllocated(signin_scoped_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signin_scoped_device_id_.IsDefault()) {
    signin_scoped_device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
}

// optional int64 last_updated_timestamp = 8;
inline bool DeviceInfoSpecifics::_internal_has_last_updated_timestamp() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_last_updated_timestamp() const {
  return _internal_has_last_updated_timestamp();
}
inline void DeviceInfoSpecifics::clear_last_updated_timestamp() {
  last_updated_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline int64_t DeviceInfoSpecifics::_internal_last_updated_timestamp() const {
  return last_updated_timestamp_;
}
inline int64_t DeviceInfoSpecifics::last_updated_timestamp() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.last_updated_timestamp)
  return _internal_last_updated_timestamp();
}
inline void DeviceInfoSpecifics::_internal_set_last_updated_timestamp(int64_t value) {
  _has_bits_[0] |= 0x00002000u;
  last_updated_timestamp_ = value;
}
inline void DeviceInfoSpecifics::set_last_updated_timestamp(int64_t value) {
  _internal_set_last_updated_timestamp(value);
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.last_updated_timestamp)
}

// optional .sync_pb.FeatureSpecificFields feature_fields = 9;
inline bool DeviceInfoSpecifics::_internal_has_feature_fields() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || feature_fields_ != nullptr);
  return value;
}
inline bool DeviceInfoSpecifics::has_feature_fields() const {
  return _internal_has_feature_fields();
}
inline void DeviceInfoSpecifics::clear_feature_fields() {
  if (feature_fields_ != nullptr) feature_fields_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::sync_pb::FeatureSpecificFields& DeviceInfoSpecifics::_internal_feature_fields() const {
  const ::sync_pb::FeatureSpecificFields* p = feature_fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::FeatureSpecificFields&>(
      ::sync_pb::_FeatureSpecificFields_default_instance_);
}
inline const ::sync_pb::FeatureSpecificFields& DeviceInfoSpecifics::feature_fields() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.feature_fields)
  return _internal_feature_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_feature_fields(
    ::sync_pb::FeatureSpecificFields* feature_fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_fields_);
  }
  feature_fields_ = feature_fields;
  if (feature_fields) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.feature_fields)
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::release_feature_fields() {
  _has_bits_[0] &= ~0x00000100u;
  ::sync_pb::FeatureSpecificFields* temp = feature_fields_;
  feature_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::unsafe_arena_release_feature_fields() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.feature_fields)
  _has_bits_[0] &= ~0x00000100u;
  ::sync_pb::FeatureSpecificFields* temp = feature_fields_;
  feature_fields_ = nullptr;
  return temp;
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::_internal_mutable_feature_fields() {
  _has_bits_[0] |= 0x00000100u;
  if (feature_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::FeatureSpecificFields>(GetArenaForAllocation());
    feature_fields_ = p;
  }
  return feature_fields_;
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::mutable_feature_fields() {
  ::sync_pb::FeatureSpecificFields* _msg = _internal_mutable_feature_fields();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.feature_fields)
  return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_feature_fields(::sync_pb::FeatureSpecificFields* feature_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete feature_fields_;
  }
  if (feature_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature_fields);
    if (message_arena != submessage_arena) {
      feature_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_fields, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  feature_fields_ = feature_fields;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.feature_fields)
}

// optional .sync_pb.SharingSpecificFields sharing_fields = 10;
inline bool DeviceInfoSpecifics::_internal_has_sharing_fields() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || sharing_fields_ != nullptr);
  return value;
}
inline bool DeviceInfoSpecifics::has_sharing_fields() const {
  return _internal_has_sharing_fields();
}
inline void DeviceInfoSpecifics::clear_sharing_fields() {
  if (sharing_fields_ != nullptr) sharing_fields_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::sync_pb::SharingSpecificFields& DeviceInfoSpecifics::_internal_sharing_fields() const {
  const ::sync_pb::SharingSpecificFields* p = sharing_fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SharingSpecificFields&>(
      ::sync_pb::_SharingSpecificFields_default_instance_);
}
inline const ::sync_pb::SharingSpecificFields& DeviceInfoSpecifics::sharing_fields() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.sharing_fields)
  return _internal_sharing_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_sharing_fields(
    ::sync_pb::SharingSpecificFields* sharing_fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sharing_fields_);
  }
  sharing_fields_ = sharing_fields;
  if (sharing_fields) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.sharing_fields)
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::release_sharing_fields() {
  _has_bits_[0] &= ~0x00000200u;
  ::sync_pb::SharingSpecificFields* temp = sharing_fields_;
  sharing_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::unsafe_arena_release_sharing_fields() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.sharing_fields)
  _has_bits_[0] &= ~0x00000200u;
  ::sync_pb::SharingSpecificFields* temp = sharing_fields_;
  sharing_fields_ = nullptr;
  return temp;
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::_internal_mutable_sharing_fields() {
  _has_bits_[0] |= 0x00000200u;
  if (sharing_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::SharingSpecificFields>(GetArenaForAllocation());
    sharing_fields_ = p;
  }
  return sharing_fields_;
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::mutable_sharing_fields() {
  ::sync_pb::SharingSpecificFields* _msg = _internal_mutable_sharing_fields();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.sharing_fields)
  return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_sharing_fields(::sync_pb::SharingSpecificFields* sharing_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sharing_fields_;
  }
  if (sharing_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sharing_fields);
    if (message_arena != submessage_arena) {
      sharing_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sharing_fields, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  sharing_fields_ = sharing_fields;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.sharing_fields)
}

// optional string model = 11;
inline bool DeviceInfoSpecifics::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_model() const {
  return _internal_has_model();
}
inline void DeviceInfoSpecifics::clear_model() {
  model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceInfoSpecifics::model() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.model)
}
inline std::string* DeviceInfoSpecifics::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.model)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_model() const {
  return model_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  model_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000020u;
  return model_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_model() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault()) {
    model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.model)
}

// optional string manufacturer = 12;
inline bool DeviceInfoSpecifics::_internal_has_manufacturer() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_manufacturer() const {
  return _internal_has_manufacturer();
}
inline void DeviceInfoSpecifics::clear_manufacturer() {
  manufacturer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceInfoSpecifics::manufacturer() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.manufacturer)
  return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_manufacturer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 manufacturer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.manufacturer)
}
inline std::string* DeviceInfoSpecifics::mutable_manufacturer() {
  std::string* _s = _internal_mutable_manufacturer();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.manufacturer)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_manufacturer() const {
  return manufacturer_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_manufacturer(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_manufacturer() {
  _has_bits_[0] |= 0x00000040u;
  return manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_manufacturer() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.manufacturer)
  if (!_internal_has_manufacturer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_manufacturer(std::string* manufacturer) {
  if (manufacturer != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manufacturer_.IsDefault()) {
    manufacturer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.manufacturer)
}

// optional int32 pulse_interval_in_minutes = 13;
inline bool DeviceInfoSpecifics::_internal_has_pulse_interval_in_minutes() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_pulse_interval_in_minutes() const {
  return _internal_has_pulse_interval_in_minutes();
}
inline void DeviceInfoSpecifics::clear_pulse_interval_in_minutes() {
  pulse_interval_in_minutes_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline int32_t DeviceInfoSpecifics::_internal_pulse_interval_in_minutes() const {
  return pulse_interval_in_minutes_;
}
inline int32_t DeviceInfoSpecifics::pulse_interval_in_minutes() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.pulse_interval_in_minutes)
  return _internal_pulse_interval_in_minutes();
}
inline void DeviceInfoSpecifics::_internal_set_pulse_interval_in_minutes(int32_t value) {
  _has_bits_[0] |= 0x00008000u;
  pulse_interval_in_minutes_ = value;
}
inline void DeviceInfoSpecifics::set_pulse_interval_in_minutes(int32_t value) {
  _internal_set_pulse_interval_in_minutes(value);
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.pulse_interval_in_minutes)
}

// optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
inline bool DeviceInfoSpecifics::_internal_has_invalidation_fields() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || invalidation_fields_ != nullptr);
  return value;
}
inline bool DeviceInfoSpecifics::has_invalidation_fields() const {
  return _internal_has_invalidation_fields();
}
inline void DeviceInfoSpecifics::clear_invalidation_fields() {
  if (invalidation_fields_ != nullptr) invalidation_fields_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::sync_pb::InvalidationSpecificFields& DeviceInfoSpecifics::_internal_invalidation_fields() const {
  const ::sync_pb::InvalidationSpecificFields* p = invalidation_fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::InvalidationSpecificFields&>(
      ::sync_pb::_InvalidationSpecificFields_default_instance_);
}
inline const ::sync_pb::InvalidationSpecificFields& DeviceInfoSpecifics::invalidation_fields() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.invalidation_fields)
  return _internal_invalidation_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_invalidation_fields(
    ::sync_pb::InvalidationSpecificFields* invalidation_fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(invalidation_fields_);
  }
  invalidation_fields_ = invalidation_fields;
  if (invalidation_fields) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.invalidation_fields)
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::release_invalidation_fields() {
  _has_bits_[0] &= ~0x00000400u;
  ::sync_pb::InvalidationSpecificFields* temp = invalidation_fields_;
  invalidation_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::unsafe_arena_release_invalidation_fields() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.invalidation_fields)
  _has_bits_[0] &= ~0x00000400u;
  ::sync_pb::InvalidationSpecificFields* temp = invalidation_fields_;
  invalidation_fields_ = nullptr;
  return temp;
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::_internal_mutable_invalidation_fields() {
  _has_bits_[0] |= 0x00000400u;
  if (invalidation_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::InvalidationSpecificFields>(GetArenaForAllocation());
    invalidation_fields_ = p;
  }
  return invalidation_fields_;
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::mutable_invalidation_fields() {
  ::sync_pb::InvalidationSpecificFields* _msg = _internal_mutable_invalidation_fields();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.invalidation_fields)
  return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_invalidation_fields(::sync_pb::InvalidationSpecificFields* invalidation_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete invalidation_fields_;
  }
  if (invalidation_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invalidation_fields);
    if (message_arena != submessage_arena) {
      invalidation_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, invalidation_fields, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  invalidation_fields_ = invalidation_fields;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.invalidation_fields)
}

// optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
inline bool DeviceInfoSpecifics::_internal_has_paask_fields() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || paask_fields_ != nullptr);
  return value;
}
inline bool DeviceInfoSpecifics::has_paask_fields() const {
  return _internal_has_paask_fields();
}
inline void DeviceInfoSpecifics::clear_paask_fields() {
  if (paask_fields_ != nullptr) paask_fields_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::sync_pb::PhoneAsASecurityKeySpecificFields& DeviceInfoSpecifics::_internal_paask_fields() const {
  const ::sync_pb::PhoneAsASecurityKeySpecificFields* p = paask_fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::PhoneAsASecurityKeySpecificFields&>(
      ::sync_pb::_PhoneAsASecurityKeySpecificFields_default_instance_);
}
inline const ::sync_pb::PhoneAsASecurityKeySpecificFields& DeviceInfoSpecifics::paask_fields() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.paask_fields)
  return _internal_paask_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_paask_fields(
    ::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paask_fields_);
  }
  paask_fields_ = paask_fields;
  if (paask_fields) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.paask_fields)
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::release_paask_fields() {
  _has_bits_[0] &= ~0x00000800u;
  ::sync_pb::PhoneAsASecurityKeySpecificFields* temp = paask_fields_;
  paask_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::unsafe_arena_release_paask_fields() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.paask_fields)
  _has_bits_[0] &= ~0x00000800u;
  ::sync_pb::PhoneAsASecurityKeySpecificFields* temp = paask_fields_;
  paask_fields_ = nullptr;
  return temp;
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::_internal_mutable_paask_fields() {
  _has_bits_[0] |= 0x00000800u;
  if (paask_fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::PhoneAsASecurityKeySpecificFields>(GetArenaForAllocation());
    paask_fields_ = p;
  }
  return paask_fields_;
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::mutable_paask_fields() {
  ::sync_pb::PhoneAsASecurityKeySpecificFields* _msg = _internal_mutable_paask_fields();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.paask_fields)
  return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_paask_fields(::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete paask_fields_;
  }
  if (paask_fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paask_fields);
    if (message_arena != submessage_arena) {
      paask_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paask_fields, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  paask_fields_ = paask_fields;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.paask_fields)
}

// optional string full_hardware_class = 16;
inline bool DeviceInfoSpecifics::_internal_has_full_hardware_class() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceInfoSpecifics::has_full_hardware_class() const {
  return _internal_has_full_hardware_class();
}
inline void DeviceInfoSpecifics::clear_full_hardware_class() {
  full_hardware_class_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceInfoSpecifics::full_hardware_class() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.full_hardware_class)
  return _internal_full_hardware_class();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfoSpecifics::set_full_hardware_class(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 full_hardware_class_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.full_hardware_class)
}
inline std::string* DeviceInfoSpecifics::mutable_full_hardware_class() {
  std::string* _s = _internal_mutable_full_hardware_class();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.full_hardware_class)
  return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_full_hardware_class() const {
  return full_hardware_class_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_full_hardware_class(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  full_hardware_class_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_full_hardware_class() {
  _has_bits_[0] |= 0x00000080u;
  return full_hardware_class_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_full_hardware_class() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.full_hardware_class)
  if (!_internal_has_full_hardware_class()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = full_hardware_class_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_hardware_class_.IsDefault()) {
    full_hardware_class_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeviceInfoSpecifics::set_allocated_full_hardware_class(std::string* full_hardware_class) {
  if (full_hardware_class != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  full_hardware_class_.SetAllocated(full_hardware_class, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_hardware_class_.IsDefault()) {
    full_hardware_class_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.full_hardware_class)
}

// .sync_pb.ChromeVersionInfo chrome_version_info = 17;
inline bool DeviceInfoSpecifics::_internal_has_chrome_version_info() const {
  return client_version_info_case() == kChromeVersionInfo;
}
inline bool DeviceInfoSpecifics::has_chrome_version_info() const {
  return _internal_has_chrome_version_info();
}
inline void DeviceInfoSpecifics::set_has_chrome_version_info() {
  _oneof_case_[0] = kChromeVersionInfo;
}
inline void DeviceInfoSpecifics::clear_chrome_version_info() {
  if (_internal_has_chrome_version_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete client_version_info_.chrome_version_info_;
    }
    clear_has_client_version_info();
  }
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::release_chrome_version_info() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.chrome_version_info)
  if (_internal_has_chrome_version_info()) {
    clear_has_client_version_info();
    ::sync_pb::ChromeVersionInfo* temp = client_version_info_.chrome_version_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    client_version_info_.chrome_version_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sync_pb::ChromeVersionInfo& DeviceInfoSpecifics::_internal_chrome_version_info() const {
  return _internal_has_chrome_version_info()
      ? *client_version_info_.chrome_version_info_
      : reinterpret_cast< ::sync_pb::ChromeVersionInfo&>(::sync_pb::_ChromeVersionInfo_default_instance_);
}
inline const ::sync_pb::ChromeVersionInfo& DeviceInfoSpecifics::chrome_version_info() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.chrome_version_info)
  return _internal_chrome_version_info();
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::unsafe_arena_release_chrome_version_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.DeviceInfoSpecifics.chrome_version_info)
  if (_internal_has_chrome_version_info()) {
    clear_has_client_version_info();
    ::sync_pb::ChromeVersionInfo* temp = client_version_info_.chrome_version_info_;
    client_version_info_.chrome_version_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_chrome_version_info(::sync_pb::ChromeVersionInfo* chrome_version_info) {
  clear_client_version_info();
  if (chrome_version_info) {
    set_has_chrome_version_info();
    client_version_info_.chrome_version_info_ = chrome_version_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.chrome_version_info)
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::_internal_mutable_chrome_version_info() {
  if (!_internal_has_chrome_version_info()) {
    clear_client_version_info();
    set_has_chrome_version_info();
    client_version_info_.chrome_version_info_ = CreateMaybeMessage< ::sync_pb::ChromeVersionInfo >(GetArenaForAllocation());
  }
  return client_version_info_.chrome_version_info_;
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::mutable_chrome_version_info() {
  ::sync_pb::ChromeVersionInfo* _msg = _internal_mutable_chrome_version_info();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.chrome_version_info)
  return _msg;
}

// .sync_pb.GooglePlayServicesVersionInfo google_play_services_version_info = 18;
inline bool DeviceInfoSpecifics::_internal_has_google_play_services_version_info() const {
  return client_version_info_case() == kGooglePlayServicesVersionInfo;
}
inline bool DeviceInfoSpecifics::has_google_play_services_version_info() const {
  return _internal_has_google_play_services_version_info();
}
inline void DeviceInfoSpecifics::set_has_google_play_services_version_info() {
  _oneof_case_[0] = kGooglePlayServicesVersionInfo;
}
inline void DeviceInfoSpecifics::clear_google_play_services_version_info() {
  if (_internal_has_google_play_services_version_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete client_version_info_.google_play_services_version_info_;
    }
    clear_has_client_version_info();
  }
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::release_google_play_services_version_info() {
  // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
  if (_internal_has_google_play_services_version_info()) {
    clear_has_client_version_info();
    ::sync_pb::GooglePlayServicesVersionInfo* temp = client_version_info_.google_play_services_version_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    client_version_info_.google_play_services_version_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sync_pb::GooglePlayServicesVersionInfo& DeviceInfoSpecifics::_internal_google_play_services_version_info() const {
  return _internal_has_google_play_services_version_info()
      ? *client_version_info_.google_play_services_version_info_
      : reinterpret_cast< ::sync_pb::GooglePlayServicesVersionInfo&>(::sync_pb::_GooglePlayServicesVersionInfo_default_instance_);
}
inline const ::sync_pb::GooglePlayServicesVersionInfo& DeviceInfoSpecifics::google_play_services_version_info() const {
  // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
  return _internal_google_play_services_version_info();
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::unsafe_arena_release_google_play_services_version_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
  if (_internal_has_google_play_services_version_info()) {
    clear_has_client_version_info();
    ::sync_pb::GooglePlayServicesVersionInfo* temp = client_version_info_.google_play_services_version_info_;
    client_version_info_.google_play_services_version_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_google_play_services_version_info(::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info) {
  clear_client_version_info();
  if (google_play_services_version_info) {
    set_has_google_play_services_version_info();
    client_version_info_.google_play_services_version_info_ = google_play_services_version_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::_internal_mutable_google_play_services_version_info() {
  if (!_internal_has_google_play_services_version_info()) {
    clear_client_version_info();
    set_has_google_play_services_version_info();
    client_version_info_.google_play_services_version_info_ = CreateMaybeMessage< ::sync_pb::GooglePlayServicesVersionInfo >(GetArenaForAllocation());
  }
  return client_version_info_.google_play_services_version_info_;
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::mutable_google_play_services_version_info() {
  ::sync_pb::GooglePlayServicesVersionInfo* _msg = _internal_mutable_google_play_services_version_info();
  // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
  return _msg;
}

inline bool DeviceInfoSpecifics::has_client_version_info() const {
  return client_version_info_case() != CLIENT_VERSION_INFO_NOT_SET;
}
inline void DeviceInfoSpecifics::clear_has_client_version_info() {
  _oneof_case_[0] = CLIENT_VERSION_INFO_NOT_SET;
}
inline DeviceInfoSpecifics::ClientVersionInfoCase DeviceInfoSpecifics::client_version_info_case() const {
  return DeviceInfoSpecifics::ClientVersionInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeatureSpecificFields

// optional bool send_tab_to_self_receiving_enabled = 1;
inline bool FeatureSpecificFields::_internal_has_send_tab_to_self_receiving_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FeatureSpecificFields::has_send_tab_to_self_receiving_enabled() const {
  return _internal_has_send_tab_to_self_receiving_enabled();
}
inline void FeatureSpecificFields::clear_send_tab_to_self_receiving_enabled() {
  send_tab_to_self_receiving_enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool FeatureSpecificFields::_internal_send_tab_to_self_receiving_enabled() const {
  return send_tab_to_self_receiving_enabled_;
}
inline bool FeatureSpecificFields::send_tab_to_self_receiving_enabled() const {
  // @@protoc_insertion_point(field_get:sync_pb.FeatureSpecificFields.send_tab_to_self_receiving_enabled)
  return _internal_send_tab_to_self_receiving_enabled();
}
inline void FeatureSpecificFields::_internal_set_send_tab_to_self_receiving_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  send_tab_to_self_receiving_enabled_ = value;
}
inline void FeatureSpecificFields::set_send_tab_to_self_receiving_enabled(bool value) {
  _internal_set_send_tab_to_self_receiving_enabled(value);
  // @@protoc_insertion_point(field_set:sync_pb.FeatureSpecificFields.send_tab_to_self_receiving_enabled)
}

// -------------------------------------------------------------------

// SharingSpecificFields

// optional string vapid_fcm_token = 1;
inline bool SharingSpecificFields::_internal_has_vapid_fcm_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_vapid_fcm_token() const {
  return _internal_has_vapid_fcm_token();
}
inline void SharingSpecificFields::clear_vapid_fcm_token() {
  vapid_fcm_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SharingSpecificFields::vapid_fcm_token() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.vapid_fcm_token)
  return _internal_vapid_fcm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_vapid_fcm_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 vapid_fcm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.vapid_fcm_token)
}
inline std::string* SharingSpecificFields::mutable_vapid_fcm_token() {
  std::string* _s = _internal_mutable_vapid_fcm_token();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.vapid_fcm_token)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_vapid_fcm_token() const {
  return vapid_fcm_token_.Get();
}
inline void SharingSpecificFields::_internal_set_vapid_fcm_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vapid_fcm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_vapid_fcm_token() {
  _has_bits_[0] |= 0x00000001u;
  return vapid_fcm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_vapid_fcm_token() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.vapid_fcm_token)
  if (!_internal_has_vapid_fcm_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = vapid_fcm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_fcm_token_.IsDefault()) {
    vapid_fcm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_vapid_fcm_token(std::string* vapid_fcm_token) {
  if (vapid_fcm_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vapid_fcm_token_.SetAllocated(vapid_fcm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_fcm_token_.IsDefault()) {
    vapid_fcm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.vapid_fcm_token)
}

// optional bytes vapid_p256dh = 2;
inline bool SharingSpecificFields::_internal_has_vapid_p256dh() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_vapid_p256dh() const {
  return _internal_has_vapid_p256dh();
}
inline void SharingSpecificFields::clear_vapid_p256dh() {
  vapid_p256dh_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SharingSpecificFields::vapid_p256dh() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.vapid_p256dh)
  return _internal_vapid_p256dh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_vapid_p256dh(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 vapid_p256dh_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.vapid_p256dh)
}
inline std::string* SharingSpecificFields::mutable_vapid_p256dh() {
  std::string* _s = _internal_mutable_vapid_p256dh();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.vapid_p256dh)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_vapid_p256dh() const {
  return vapid_p256dh_.Get();
}
inline void SharingSpecificFields::_internal_set_vapid_p256dh(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vapid_p256dh_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_vapid_p256dh() {
  _has_bits_[0] |= 0x00000002u;
  return vapid_p256dh_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_vapid_p256dh() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.vapid_p256dh)
  if (!_internal_has_vapid_p256dh()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = vapid_p256dh_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_p256dh_.IsDefault()) {
    vapid_p256dh_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_vapid_p256dh(std::string* vapid_p256dh) {
  if (vapid_p256dh != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vapid_p256dh_.SetAllocated(vapid_p256dh, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_p256dh_.IsDefault()) {
    vapid_p256dh_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.vapid_p256dh)
}

// optional bytes vapid_auth_secret = 3;
inline bool SharingSpecificFields::_internal_has_vapid_auth_secret() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_vapid_auth_secret() const {
  return _internal_has_vapid_auth_secret();
}
inline void SharingSpecificFields::clear_vapid_auth_secret() {
  vapid_auth_secret_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SharingSpecificFields::vapid_auth_secret() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.vapid_auth_secret)
  return _internal_vapid_auth_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_vapid_auth_secret(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 vapid_auth_secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.vapid_auth_secret)
}
inline std::string* SharingSpecificFields::mutable_vapid_auth_secret() {
  std::string* _s = _internal_mutable_vapid_auth_secret();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.vapid_auth_secret)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_vapid_auth_secret() const {
  return vapid_auth_secret_.Get();
}
inline void SharingSpecificFields::_internal_set_vapid_auth_secret(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  vapid_auth_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_vapid_auth_secret() {
  _has_bits_[0] |= 0x00000004u;
  return vapid_auth_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_vapid_auth_secret() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.vapid_auth_secret)
  if (!_internal_has_vapid_auth_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = vapid_auth_secret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_auth_secret_.IsDefault()) {
    vapid_auth_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_vapid_auth_secret(std::string* vapid_auth_secret) {
  if (vapid_auth_secret != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  vapid_auth_secret_.SetAllocated(vapid_auth_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_auth_secret_.IsDefault()) {
    vapid_auth_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.vapid_auth_secret)
}

// repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
inline int SharingSpecificFields::_internal_enabled_features_size() const {
  return enabled_features_.size();
}
inline int SharingSpecificFields::enabled_features_size() const {
  return _internal_enabled_features_size();
}
inline void SharingSpecificFields::clear_enabled_features() {
  enabled_features_.Clear();
}
inline ::sync_pb::SharingSpecificFields_EnabledFeatures SharingSpecificFields::_internal_enabled_features(int index) const {
  return static_cast< ::sync_pb::SharingSpecificFields_EnabledFeatures >(enabled_features_.Get(index));
}
inline ::sync_pb::SharingSpecificFields_EnabledFeatures SharingSpecificFields::enabled_features(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.enabled_features)
  return _internal_enabled_features(index);
}
inline void SharingSpecificFields::set_enabled_features(int index, ::sync_pb::SharingSpecificFields_EnabledFeatures value) {
  assert(::sync_pb::SharingSpecificFields_EnabledFeatures_IsValid(value));
  enabled_features_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.enabled_features)
}
inline void SharingSpecificFields::_internal_add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value) {
  assert(::sync_pb::SharingSpecificFields_EnabledFeatures_IsValid(value));
  enabled_features_.Add(value);
}
inline void SharingSpecificFields::add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value) {
  _internal_add_enabled_features(value);
  // @@protoc_insertion_point(field_add:sync_pb.SharingSpecificFields.enabled_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SharingSpecificFields::enabled_features() const {
  // @@protoc_insertion_point(field_list:sync_pb.SharingSpecificFields.enabled_features)
  return enabled_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SharingSpecificFields::_internal_mutable_enabled_features() {
  return &enabled_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SharingSpecificFields::mutable_enabled_features() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.SharingSpecificFields.enabled_features)
  return _internal_mutable_enabled_features();
}

// optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
inline bool SharingSpecificFields::_internal_has_sender_id_fcm_token_deprecated() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_sender_id_fcm_token_deprecated() const {
  return _internal_has_sender_id_fcm_token_deprecated();
}
inline void SharingSpecificFields::clear_sender_id_fcm_token_deprecated() {
  sender_id_fcm_token_deprecated_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SharingSpecificFields::sender_id_fcm_token_deprecated() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
  return _internal_sender_id_fcm_token_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_sender_id_fcm_token_deprecated(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 sender_id_fcm_token_deprecated_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
}
inline std::string* SharingSpecificFields::mutable_sender_id_fcm_token_deprecated() {
  std::string* _s = _internal_mutable_sender_id_fcm_token_deprecated();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_fcm_token_deprecated() const {
  return sender_id_fcm_token_deprecated_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_fcm_token_deprecated(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  sender_id_fcm_token_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_fcm_token_deprecated() {
  _has_bits_[0] |= 0x00000008u;
  return sender_id_fcm_token_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_fcm_token_deprecated() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
  if (!_internal_has_sender_id_fcm_token_deprecated()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = sender_id_fcm_token_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_fcm_token_deprecated_.IsDefault()) {
    sender_id_fcm_token_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_fcm_token_deprecated(std::string* sender_id_fcm_token_deprecated) {
  if (sender_id_fcm_token_deprecated != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sender_id_fcm_token_deprecated_.SetAllocated(sender_id_fcm_token_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_fcm_token_deprecated_.IsDefault()) {
    sender_id_fcm_token_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
}

// optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
inline bool SharingSpecificFields::_internal_has_sender_id_p256dh_deprecated() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_sender_id_p256dh_deprecated() const {
  return _internal_has_sender_id_p256dh_deprecated();
}
inline void SharingSpecificFields::clear_sender_id_p256dh_deprecated() {
  sender_id_p256dh_deprecated_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SharingSpecificFields::sender_id_p256dh_deprecated() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
  return _internal_sender_id_p256dh_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_sender_id_p256dh_deprecated(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 sender_id_p256dh_deprecated_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
}
inline std::string* SharingSpecificFields::mutable_sender_id_p256dh_deprecated() {
  std::string* _s = _internal_mutable_sender_id_p256dh_deprecated();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_p256dh_deprecated() const {
  return sender_id_p256dh_deprecated_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_p256dh_deprecated(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  sender_id_p256dh_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_p256dh_deprecated() {
  _has_bits_[0] |= 0x00000010u;
  return sender_id_p256dh_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_p256dh_deprecated() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
  if (!_internal_has_sender_id_p256dh_deprecated()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = sender_id_p256dh_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_p256dh_deprecated_.IsDefault()) {
    sender_id_p256dh_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_p256dh_deprecated(std::string* sender_id_p256dh_deprecated) {
  if (sender_id_p256dh_deprecated != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  sender_id_p256dh_deprecated_.SetAllocated(sender_id_p256dh_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_p256dh_deprecated_.IsDefault()) {
    sender_id_p256dh_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
}

// optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
inline bool SharingSpecificFields::_internal_has_sender_id_auth_secret_deprecated() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_sender_id_auth_secret_deprecated() const {
  return _internal_has_sender_id_auth_secret_deprecated();
}
inline void SharingSpecificFields::clear_sender_id_auth_secret_deprecated() {
  sender_id_auth_secret_deprecated_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SharingSpecificFields::sender_id_auth_secret_deprecated() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
  return _internal_sender_id_auth_secret_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_sender_id_auth_secret_deprecated(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 sender_id_auth_secret_deprecated_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
}
inline std::string* SharingSpecificFields::mutable_sender_id_auth_secret_deprecated() {
  std::string* _s = _internal_mutable_sender_id_auth_secret_deprecated();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_auth_secret_deprecated() const {
  return sender_id_auth_secret_deprecated_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_auth_secret_deprecated(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  sender_id_auth_secret_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_auth_secret_deprecated() {
  _has_bits_[0] |= 0x00000020u;
  return sender_id_auth_secret_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_auth_secret_deprecated() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
  if (!_internal_has_sender_id_auth_secret_deprecated()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = sender_id_auth_secret_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_auth_secret_deprecated_.IsDefault()) {
    sender_id_auth_secret_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_auth_secret_deprecated(std::string* sender_id_auth_secret_deprecated) {
  if (sender_id_auth_secret_deprecated != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  sender_id_auth_secret_deprecated_.SetAllocated(sender_id_auth_secret_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_auth_secret_deprecated_.IsDefault()) {
    sender_id_auth_secret_deprecated_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
}

// optional string sender_id_fcm_token_v2 = 8;
inline bool SharingSpecificFields::_internal_has_sender_id_fcm_token_v2() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_sender_id_fcm_token_v2() const {
  return _internal_has_sender_id_fcm_token_v2();
}
inline void SharingSpecificFields::clear_sender_id_fcm_token_v2() {
  sender_id_fcm_token_v2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SharingSpecificFields::sender_id_fcm_token_v2() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
  return _internal_sender_id_fcm_token_v2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_sender_id_fcm_token_v2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 sender_id_fcm_token_v2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
}
inline std::string* SharingSpecificFields::mutable_sender_id_fcm_token_v2() {
  std::string* _s = _internal_mutable_sender_id_fcm_token_v2();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_fcm_token_v2() const {
  return sender_id_fcm_token_v2_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_fcm_token_v2(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  sender_id_fcm_token_v2_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_fcm_token_v2() {
  _has_bits_[0] |= 0x00000040u;
  return sender_id_fcm_token_v2_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_fcm_token_v2() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
  if (!_internal_has_sender_id_fcm_token_v2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = sender_id_fcm_token_v2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_fcm_token_v2_.IsDefault()) {
    sender_id_fcm_token_v2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_fcm_token_v2(std::string* sender_id_fcm_token_v2) {
  if (sender_id_fcm_token_v2 != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  sender_id_fcm_token_v2_.SetAllocated(sender_id_fcm_token_v2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_fcm_token_v2_.IsDefault()) {
    sender_id_fcm_token_v2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
}

// optional bytes sender_id_p256dh_v2 = 9;
inline bool SharingSpecificFields::_internal_has_sender_id_p256dh_v2() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_sender_id_p256dh_v2() const {
  return _internal_has_sender_id_p256dh_v2();
}
inline void SharingSpecificFields::clear_sender_id_p256dh_v2() {
  sender_id_p256dh_v2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SharingSpecificFields::sender_id_p256dh_v2() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
  return _internal_sender_id_p256dh_v2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_sender_id_p256dh_v2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 sender_id_p256dh_v2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
}
inline std::string* SharingSpecificFields::mutable_sender_id_p256dh_v2() {
  std::string* _s = _internal_mutable_sender_id_p256dh_v2();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_p256dh_v2() const {
  return sender_id_p256dh_v2_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_p256dh_v2(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  sender_id_p256dh_v2_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_p256dh_v2() {
  _has_bits_[0] |= 0x00000080u;
  return sender_id_p256dh_v2_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_p256dh_v2() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
  if (!_internal_has_sender_id_p256dh_v2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = sender_id_p256dh_v2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_p256dh_v2_.IsDefault()) {
    sender_id_p256dh_v2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_p256dh_v2(std::string* sender_id_p256dh_v2) {
  if (sender_id_p256dh_v2 != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  sender_id_p256dh_v2_.SetAllocated(sender_id_p256dh_v2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_p256dh_v2_.IsDefault()) {
    sender_id_p256dh_v2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
}

// optional bytes sender_id_auth_secret_v2 = 10;
inline bool SharingSpecificFields::_internal_has_sender_id_auth_secret_v2() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SharingSpecificFields::has_sender_id_auth_secret_v2() const {
  return _internal_has_sender_id_auth_secret_v2();
}
inline void SharingSpecificFields::clear_sender_id_auth_secret_v2() {
  sender_id_auth_secret_v2_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& SharingSpecificFields::sender_id_auth_secret_v2() const {
  // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
  return _internal_sender_id_auth_secret_v2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingSpecificFields::set_sender_id_auth_secret_v2(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 sender_id_auth_secret_v2_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
}
inline std::string* SharingSpecificFields::mutable_sender_id_auth_secret_v2() {
  std::string* _s = _internal_mutable_sender_id_auth_secret_v2();
  // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
  return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_auth_secret_v2() const {
  return sender_id_auth_secret_v2_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_auth_secret_v2(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  sender_id_auth_secret_v2_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_auth_secret_v2() {
  _has_bits_[0] |= 0x00000100u;
  return sender_id_auth_secret_v2_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_auth_secret_v2() {
  // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
  if (!_internal_has_sender_id_auth_secret_v2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = sender_id_auth_secret_v2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_auth_secret_v2_.IsDefault()) {
    sender_id_auth_secret_v2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_auth_secret_v2(std::string* sender_id_auth_secret_v2) {
  if (sender_id_auth_secret_v2 != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  sender_id_auth_secret_v2_.SetAllocated(sender_id_auth_secret_v2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_auth_secret_v2_.IsDefault()) {
    sender_id_auth_secret_v2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
}

// -------------------------------------------------------------------

// InvalidationSpecificFields

// optional string instance_id_token = 1;
inline bool InvalidationSpecificFields::_internal_has_instance_id_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InvalidationSpecificFields::has_instance_id_token() const {
  return _internal_has_instance_id_token();
}
inline void InvalidationSpecificFields::clear_instance_id_token() {
  instance_id_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InvalidationSpecificFields::instance_id_token() const {
  // @@protoc_insertion_point(field_get:sync_pb.InvalidationSpecificFields.instance_id_token)
  return _internal_instance_id_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvalidationSpecificFields::set_instance_id_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 instance_id_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.InvalidationSpecificFields.instance_id_token)
}
inline std::string* InvalidationSpecificFields::mutable_instance_id_token() {
  std::string* _s = _internal_mutable_instance_id_token();
  // @@protoc_insertion_point(field_mutable:sync_pb.InvalidationSpecificFields.instance_id_token)
  return _s;
}
inline const std::string& InvalidationSpecificFields::_internal_instance_id_token() const {
  return instance_id_token_.Get();
}
inline void InvalidationSpecificFields::_internal_set_instance_id_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  instance_id_token_.Set(value, GetArenaForAllocation());
}
inline std::string* InvalidationSpecificFields::_internal_mutable_instance_id_token() {
  _has_bits_[0] |= 0x00000001u;
  return instance_id_token_.Mutable(GetArenaForAllocation());
}
inline std::string* InvalidationSpecificFields::release_instance_id_token() {
  // @@protoc_insertion_point(field_release:sync_pb.InvalidationSpecificFields.instance_id_token)
  if (!_internal_has_instance_id_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = instance_id_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instance_id_token_.IsDefault()) {
    instance_id_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InvalidationSpecificFields::set_allocated_instance_id_token(std::string* instance_id_token) {
  if (instance_id_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  instance_id_token_.SetAllocated(instance_id_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instance_id_token_.IsDefault()) {
    instance_id_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.InvalidationSpecificFields.instance_id_token)
}

// repeated int32 interested_data_type_ids = 2;
inline int InvalidationSpecificFields::_internal_interested_data_type_ids_size() const {
  return interested_data_type_ids_.size();
}
inline int InvalidationSpecificFields::interested_data_type_ids_size() const {
  return _internal_interested_data_type_ids_size();
}
inline void InvalidationSpecificFields::clear_interested_data_type_ids() {
  interested_data_type_ids_.Clear();
}
inline int32_t InvalidationSpecificFields::_internal_interested_data_type_ids(int index) const {
  return interested_data_type_ids_.Get(index);
}
inline int32_t InvalidationSpecificFields::interested_data_type_ids(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
  return _internal_interested_data_type_ids(index);
}
inline void InvalidationSpecificFields::set_interested_data_type_ids(int index, int32_t value) {
  interested_data_type_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
}
inline void InvalidationSpecificFields::_internal_add_interested_data_type_ids(int32_t value) {
  interested_data_type_ids_.Add(value);
}
inline void InvalidationSpecificFields::add_interested_data_type_ids(int32_t value) {
  _internal_add_interested_data_type_ids(value);
  // @@protoc_insertion_point(field_add:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
InvalidationSpecificFields::_internal_interested_data_type_ids() const {
  return interested_data_type_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
InvalidationSpecificFields::interested_data_type_ids() const {
  // @@protoc_insertion_point(field_list:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
  return _internal_interested_data_type_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
InvalidationSpecificFields::_internal_mutable_interested_data_type_ids() {
  return &interested_data_type_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
InvalidationSpecificFields::mutable_interested_data_type_ids() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
  return _internal_mutable_interested_data_type_ids();
}

// -------------------------------------------------------------------

// PhoneAsASecurityKeySpecificFields

// optional uint32 tunnel_server_domain = 1;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_tunnel_server_domain() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_tunnel_server_domain() const {
  return _internal_has_tunnel_server_domain();
}
inline void PhoneAsASecurityKeySpecificFields::clear_tunnel_server_domain() {
  tunnel_server_domain_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::_internal_tunnel_server_domain() const {
  return tunnel_server_domain_;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::tunnel_server_domain() const {
  // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.tunnel_server_domain)
  return _internal_tunnel_server_domain();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_tunnel_server_domain(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  tunnel_server_domain_ = value;
}
inline void PhoneAsASecurityKeySpecificFields::set_tunnel_server_domain(uint32_t value) {
  _internal_set_tunnel_server_domain(value);
  // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.tunnel_server_domain)
}

// optional bytes contact_id = 2;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_contact_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_contact_id() const {
  return _internal_has_contact_id();
}
inline void PhoneAsASecurityKeySpecificFields::clear_contact_id() {
  contact_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::contact_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
  return _internal_contact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhoneAsASecurityKeySpecificFields::set_contact_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 contact_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_contact_id() {
  std::string* _s = _internal_mutable_contact_id();
  // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
  return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_contact_id() const {
  return contact_id_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_contact_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  contact_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_contact_id() {
  _has_bits_[0] |= 0x00000001u;
  return contact_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_contact_id() {
  // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
  if (!_internal_has_contact_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = contact_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contact_id_.IsDefault()) {
    contact_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_contact_id(std::string* contact_id) {
  if (contact_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  contact_id_.SetAllocated(contact_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contact_id_.IsDefault()) {
    contact_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
}

// optional bytes secret = 3;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_secret() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_secret() const {
  return _internal_has_secret();
}
inline void PhoneAsASecurityKeySpecificFields::clear_secret() {
  secret_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::secret() const {
  // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhoneAsASecurityKeySpecificFields::set_secret(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
  return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_secret() const {
  return secret_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_secret(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  secret_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_secret() {
  _has_bits_[0] |= 0x00000002u;
  return secret_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_secret() {
  // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
  if (!_internal_has_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = secret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault()) {
    secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
}

// optional fixed32 id = 4;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_id() const {
  return _internal_has_id();
}
inline void PhoneAsASecurityKeySpecificFields::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::_internal_id() const {
  return id_;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::id() const {
  // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.id)
  return _internal_id();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_id(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  id_ = value;
}
inline void PhoneAsASecurityKeySpecificFields::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.id)
}

// optional bytes peer_public_key_x962 = 5;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_peer_public_key_x962() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_peer_public_key_x962() const {
  return _internal_has_peer_public_key_x962();
}
inline void PhoneAsASecurityKeySpecificFields::clear_peer_public_key_x962() {
  peer_public_key_x962_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::peer_public_key_x962() const {
  // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
  return _internal_peer_public_key_x962();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhoneAsASecurityKeySpecificFields::set_peer_public_key_x962(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 peer_public_key_x962_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_peer_public_key_x962() {
  std::string* _s = _internal_mutable_peer_public_key_x962();
  // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
  return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_peer_public_key_x962() const {
  return peer_public_key_x962_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_peer_public_key_x962(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  peer_public_key_x962_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_peer_public_key_x962() {
  _has_bits_[0] |= 0x00000004u;
  return peer_public_key_x962_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_peer_public_key_x962() {
  // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
  if (!_internal_has_peer_public_key_x962()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = peer_public_key_x962_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_public_key_x962_.IsDefault()) {
    peer_public_key_x962_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_peer_public_key_x962(std::string* peer_public_key_x962) {
  if (peer_public_key_x962 != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  peer_public_key_x962_.SetAllocated(peer_public_key_x962, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_public_key_x962_.IsDefault()) {
    peer_public_key_x962_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
}

// -------------------------------------------------------------------

// ChromeVersionInfo

// optional string version_number = 1;
inline bool ChromeVersionInfo::_internal_has_version_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromeVersionInfo::has_version_number() const {
  return _internal_has_version_number();
}
inline void ChromeVersionInfo::clear_version_number() {
  version_number_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeVersionInfo::version_number() const {
  // @@protoc_insertion_point(field_get:sync_pb.ChromeVersionInfo.version_number)
  return _internal_version_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromeVersionInfo::set_version_number(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ChromeVersionInfo.version_number)
}
inline std::string* ChromeVersionInfo::mutable_version_number() {
  std::string* _s = _internal_mutable_version_number();
  // @@protoc_insertion_point(field_mutable:sync_pb.ChromeVersionInfo.version_number)
  return _s;
}
inline const std::string& ChromeVersionInfo::_internal_version_number() const {
  return version_number_.Get();
}
inline void ChromeVersionInfo::_internal_set_version_number(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_number_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeVersionInfo::_internal_mutable_version_number() {
  _has_bits_[0] |= 0x00000001u;
  return version_number_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeVersionInfo::release_version_number() {
  // @@protoc_insertion_point(field_release:sync_pb.ChromeVersionInfo.version_number)
  if (!_internal_has_version_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_number_.IsDefault()) {
    version_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromeVersionInfo::set_allocated_version_number(std::string* version_number) {
  if (version_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_number_.SetAllocated(version_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_number_.IsDefault()) {
    version_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ChromeVersionInfo.version_number)
}

// -------------------------------------------------------------------

// GooglePlayServicesVersionInfo

// optional string apk_version_name = 1;
inline bool GooglePlayServicesVersionInfo::_internal_has_apk_version_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GooglePlayServicesVersionInfo::has_apk_version_name() const {
  return _internal_has_apk_version_name();
}
inline void GooglePlayServicesVersionInfo::clear_apk_version_name() {
  apk_version_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GooglePlayServicesVersionInfo::apk_version_name() const {
  // @@protoc_insertion_point(field_get:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
  return _internal_apk_version_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GooglePlayServicesVersionInfo::set_apk_version_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 apk_version_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
}
inline std::string* GooglePlayServicesVersionInfo::mutable_apk_version_name() {
  std::string* _s = _internal_mutable_apk_version_name();
  // @@protoc_insertion_point(field_mutable:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
  return _s;
}
inline const std::string& GooglePlayServicesVersionInfo::_internal_apk_version_name() const {
  return apk_version_name_.Get();
}
inline void GooglePlayServicesVersionInfo::_internal_set_apk_version_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  apk_version_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GooglePlayServicesVersionInfo::_internal_mutable_apk_version_name() {
  _has_bits_[0] |= 0x00000001u;
  return apk_version_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GooglePlayServicesVersionInfo::release_apk_version_name() {
  // @@protoc_insertion_point(field_release:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
  if (!_internal_has_apk_version_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = apk_version_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (apk_version_name_.IsDefault()) {
    apk_version_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GooglePlayServicesVersionInfo::set_allocated_apk_version_name(std::string* apk_version_name) {
  if (apk_version_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  apk_version_name_.SetAllocated(apk_version_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (apk_version_name_.IsDefault()) {
    apk_version_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sync_pb::SharingSpecificFields_EnabledFeatures> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto
