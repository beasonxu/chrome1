// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/nigori_specifics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/encryption.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto {
  static const uint32_t offsets[];
};
namespace sync_pb {
class NigoriKey;
struct NigoriKeyDefaultTypeInternal;
extern NigoriKeyDefaultTypeInternal _NigoriKey_default_instance_;
class NigoriKeyBag;
struct NigoriKeyBagDefaultTypeInternal;
extern NigoriKeyBagDefaultTypeInternal _NigoriKeyBag_default_instance_;
class NigoriSpecifics;
struct NigoriSpecificsDefaultTypeInternal;
extern NigoriSpecificsDefaultTypeInternal _NigoriSpecifics_default_instance_;
class NigoriSpecifics_TrustedVaultDebugInfo;
struct NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal;
extern NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal _NigoriSpecifics_TrustedVaultDebugInfo_default_instance_;
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::sync_pb::NigoriKey* Arena::CreateMaybeMessage<::sync_pb::NigoriKey>(Arena*);
template<> ::sync_pb::NigoriKeyBag* Arena::CreateMaybeMessage<::sync_pb::NigoriKeyBag>(Arena*);
template<> ::sync_pb::NigoriSpecifics* Arena::CreateMaybeMessage<::sync_pb::NigoriSpecifics>(Arena*);
template<> ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* Arena::CreateMaybeMessage<::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum NigoriSpecifics_PassphraseType : int {
  NigoriSpecifics_PassphraseType_UNKNOWN = 0,
  NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE = 1,
  NigoriSpecifics_PassphraseType_KEYSTORE_PASSPHRASE = 2,
  NigoriSpecifics_PassphraseType_FROZEN_IMPLICIT_PASSPHRASE = 3,
  NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE = 4,
  NigoriSpecifics_PassphraseType_TRUSTED_VAULT_PASSPHRASE = 5
};
bool NigoriSpecifics_PassphraseType_IsValid(int value);
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics_PassphraseType_PassphraseType_MIN = NigoriSpecifics_PassphraseType_UNKNOWN;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics_PassphraseType_PassphraseType_MAX = NigoriSpecifics_PassphraseType_TRUSTED_VAULT_PASSPHRASE;
constexpr int NigoriSpecifics_PassphraseType_PassphraseType_ARRAYSIZE = NigoriSpecifics_PassphraseType_PassphraseType_MAX + 1;

const std::string& NigoriSpecifics_PassphraseType_Name(NigoriSpecifics_PassphraseType value);
template<typename T>
inline const std::string& NigoriSpecifics_PassphraseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NigoriSpecifics_PassphraseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NigoriSpecifics_PassphraseType_Name.");
  return NigoriSpecifics_PassphraseType_Name(static_cast<NigoriSpecifics_PassphraseType>(enum_t_value));
}
bool NigoriSpecifics_PassphraseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NigoriSpecifics_PassphraseType* value);
enum NigoriSpecifics_KeyDerivationMethod : int {
  NigoriSpecifics_KeyDerivationMethod_UNSPECIFIED = 0,
  NigoriSpecifics_KeyDerivationMethod_PBKDF2_HMAC_SHA1_1003 = 1,
  NigoriSpecifics_KeyDerivationMethod_SCRYPT_8192_8_11 = 2
};
bool NigoriSpecifics_KeyDerivationMethod_IsValid(int value);
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MIN = NigoriSpecifics_KeyDerivationMethod_UNSPECIFIED;
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MAX = NigoriSpecifics_KeyDerivationMethod_SCRYPT_8192_8_11;
constexpr int NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_ARRAYSIZE = NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MAX + 1;

const std::string& NigoriSpecifics_KeyDerivationMethod_Name(NigoriSpecifics_KeyDerivationMethod value);
template<typename T>
inline const std::string& NigoriSpecifics_KeyDerivationMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NigoriSpecifics_KeyDerivationMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NigoriSpecifics_KeyDerivationMethod_Name.");
  return NigoriSpecifics_KeyDerivationMethod_Name(static_cast<NigoriSpecifics_KeyDerivationMethod>(enum_t_value));
}
bool NigoriSpecifics_KeyDerivationMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NigoriSpecifics_KeyDerivationMethod* value);
// ===================================================================

class NigoriKey final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriKey) */ {
 public:
  inline NigoriKey() : NigoriKey(nullptr) {}
  ~NigoriKey() override;
  explicit PROTOBUF_CONSTEXPR NigoriKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NigoriKey(const NigoriKey& from);
  NigoriKey(NigoriKey&& from) noexcept
    : NigoriKey() {
    *this = ::std::move(from);
  }

  inline NigoriKey& operator=(const NigoriKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline NigoriKey& operator=(NigoriKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NigoriKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const NigoriKey* internal_default_instance() {
    return reinterpret_cast<const NigoriKey*>(
               &_NigoriKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NigoriKey& a, NigoriKey& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NigoriKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NigoriKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NigoriKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NigoriKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NigoriKey& from);
  void MergeFrom(const NigoriKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NigoriKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.NigoriKey";
  }
  protected:
  explicit NigoriKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeprecatedNameFieldNumber = 1,
    kDeprecatedUserKeyFieldNumber = 2,
    kEncryptionKeyFieldNumber = 3,
    kMacKeyFieldNumber = 4,
  };
  // optional string deprecated_name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_deprecated_name() const;
  private:
  bool _internal_has_deprecated_name() const;
  public:
  PROTOBUF_DEPRECATED void clear_deprecated_name();
  PROTOBUF_DEPRECATED const std::string& deprecated_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_deprecated_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_deprecated_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_deprecated_name();
  PROTOBUF_DEPRECATED void set_allocated_deprecated_name(std::string* deprecated_name);
  private:
  const std::string& _internal_deprecated_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_name(const std::string& value);
  std::string* _internal_mutable_deprecated_name();
  public:

  // optional bytes deprecated_user_key = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_deprecated_user_key() const;
  private:
  bool _internal_has_deprecated_user_key() const;
  public:
  PROTOBUF_DEPRECATED void clear_deprecated_user_key();
  PROTOBUF_DEPRECATED const std::string& deprecated_user_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_deprecated_user_key(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_deprecated_user_key();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_deprecated_user_key();
  PROTOBUF_DEPRECATED void set_allocated_deprecated_user_key(std::string* deprecated_user_key);
  private:
  const std::string& _internal_deprecated_user_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_user_key(const std::string& value);
  std::string* _internal_mutable_deprecated_user_key();
  public:

  // optional bytes encryption_key = 3;
  bool has_encryption_key() const;
  private:
  bool _internal_has_encryption_key() const;
  public:
  void clear_encryption_key();
  const std::string& encryption_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encryption_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encryption_key();
  PROTOBUF_NODISCARD std::string* release_encryption_key();
  void set_allocated_encryption_key(std::string* encryption_key);
  private:
  const std::string& _internal_encryption_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_key(const std::string& value);
  std::string* _internal_mutable_encryption_key();
  public:

  // optional bytes mac_key = 4;
  bool has_mac_key() const;
  private:
  bool _internal_has_mac_key() const;
  public:
  void clear_mac_key();
  const std::string& mac_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_key();
  PROTOBUF_NODISCARD std::string* release_mac_key();
  void set_allocated_mac_key(std::string* mac_key);
  private:
  const std::string& _internal_mac_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_key(const std::string& value);
  std::string* _internal_mutable_mac_key();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_user_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_key_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NigoriKeyBag final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriKeyBag) */ {
 public:
  inline NigoriKeyBag() : NigoriKeyBag(nullptr) {}
  ~NigoriKeyBag() override;
  explicit PROTOBUF_CONSTEXPR NigoriKeyBag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NigoriKeyBag(const NigoriKeyBag& from);
  NigoriKeyBag(NigoriKeyBag&& from) noexcept
    : NigoriKeyBag() {
    *this = ::std::move(from);
  }

  inline NigoriKeyBag& operator=(const NigoriKeyBag& from) {
    CopyFrom(from);
    return *this;
  }
  inline NigoriKeyBag& operator=(NigoriKeyBag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NigoriKeyBag& default_instance() {
    return *internal_default_instance();
  }
  static inline const NigoriKeyBag* internal_default_instance() {
    return reinterpret_cast<const NigoriKeyBag*>(
               &_NigoriKeyBag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NigoriKeyBag& a, NigoriKeyBag& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NigoriKeyBag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NigoriKeyBag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NigoriKeyBag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NigoriKeyBag>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NigoriKeyBag& from);
  void MergeFrom(const NigoriKeyBag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NigoriKeyBag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.NigoriKeyBag";
  }
  protected:
  explicit NigoriKeyBag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
  };
  // repeated .sync_pb.NigoriKey key = 2;
  int key_size() const;
  private:
  int _internal_key_size() const;
  public:
  void clear_key();
  ::sync_pb::NigoriKey* mutable_key(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NigoriKey >*
      mutable_key();
  private:
  const ::sync_pb::NigoriKey& _internal_key(int index) const;
  ::sync_pb::NigoriKey* _internal_add_key();
  public:
  const ::sync_pb::NigoriKey& key(int index) const;
  ::sync_pb::NigoriKey* add_key();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NigoriKey >&
      key() const;

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriKeyBag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NigoriKey > key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NigoriSpecifics_TrustedVaultDebugInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo) */ {
 public:
  inline NigoriSpecifics_TrustedVaultDebugInfo() : NigoriSpecifics_TrustedVaultDebugInfo(nullptr) {}
  ~NigoriSpecifics_TrustedVaultDebugInfo() override;
  explicit PROTOBUF_CONSTEXPR NigoriSpecifics_TrustedVaultDebugInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NigoriSpecifics_TrustedVaultDebugInfo(const NigoriSpecifics_TrustedVaultDebugInfo& from);
  NigoriSpecifics_TrustedVaultDebugInfo(NigoriSpecifics_TrustedVaultDebugInfo&& from) noexcept
    : NigoriSpecifics_TrustedVaultDebugInfo() {
    *this = ::std::move(from);
  }

  inline NigoriSpecifics_TrustedVaultDebugInfo& operator=(const NigoriSpecifics_TrustedVaultDebugInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NigoriSpecifics_TrustedVaultDebugInfo& operator=(NigoriSpecifics_TrustedVaultDebugInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NigoriSpecifics_TrustedVaultDebugInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NigoriSpecifics_TrustedVaultDebugInfo* internal_default_instance() {
    return reinterpret_cast<const NigoriSpecifics_TrustedVaultDebugInfo*>(
               &_NigoriSpecifics_TrustedVaultDebugInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NigoriSpecifics_TrustedVaultDebugInfo& a, NigoriSpecifics_TrustedVaultDebugInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NigoriSpecifics_TrustedVaultDebugInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NigoriSpecifics_TrustedVaultDebugInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NigoriSpecifics_TrustedVaultDebugInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NigoriSpecifics_TrustedVaultDebugInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NigoriSpecifics_TrustedVaultDebugInfo& from);
  void MergeFrom(const NigoriSpecifics_TrustedVaultDebugInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NigoriSpecifics_TrustedVaultDebugInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.NigoriSpecifics.TrustedVaultDebugInfo";
  }
  protected:
  explicit NigoriSpecifics_TrustedVaultDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMigrationTimeFieldNumber = 1,
    kKeyVersionFieldNumber = 2,
  };
  // optional int64 migration_time = 1;
  bool has_migration_time() const;
  private:
  bool _internal_has_migration_time() const;
  public:
  void clear_migration_time();
  int64_t migration_time() const;
  void set_migration_time(int64_t value);
  private:
  int64_t _internal_migration_time() const;
  void _internal_set_migration_time(int64_t value);
  public:

  // optional int32 key_version = 2;
  bool has_key_version() const;
  private:
  bool _internal_has_key_version() const;
  public:
  void clear_key_version();
  int32_t key_version() const;
  void set_key_version(int32_t value);
  private:
  int32_t _internal_key_version() const;
  void _internal_set_key_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t migration_time_;
  int32_t key_version_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NigoriSpecifics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriSpecifics) */ {
 public:
  inline NigoriSpecifics() : NigoriSpecifics(nullptr) {}
  ~NigoriSpecifics() override;
  explicit PROTOBUF_CONSTEXPR NigoriSpecifics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NigoriSpecifics(const NigoriSpecifics& from);
  NigoriSpecifics(NigoriSpecifics&& from) noexcept
    : NigoriSpecifics() {
    *this = ::std::move(from);
  }

  inline NigoriSpecifics& operator=(const NigoriSpecifics& from) {
    CopyFrom(from);
    return *this;
  }
  inline NigoriSpecifics& operator=(NigoriSpecifics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NigoriSpecifics& default_instance() {
    return *internal_default_instance();
  }
  static inline const NigoriSpecifics* internal_default_instance() {
    return reinterpret_cast<const NigoriSpecifics*>(
               &_NigoriSpecifics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NigoriSpecifics& a, NigoriSpecifics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NigoriSpecifics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NigoriSpecifics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NigoriSpecifics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NigoriSpecifics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NigoriSpecifics& from);
  void MergeFrom(const NigoriSpecifics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NigoriSpecifics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.NigoriSpecifics";
  }
  protected:
  explicit NigoriSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NigoriSpecifics_TrustedVaultDebugInfo TrustedVaultDebugInfo;

  typedef NigoriSpecifics_PassphraseType PassphraseType;
  static constexpr PassphraseType UNKNOWN =
    NigoriSpecifics_PassphraseType_UNKNOWN;
  static constexpr PassphraseType IMPLICIT_PASSPHRASE =
    NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE;
  static constexpr PassphraseType KEYSTORE_PASSPHRASE =
    NigoriSpecifics_PassphraseType_KEYSTORE_PASSPHRASE;
  static constexpr PassphraseType FROZEN_IMPLICIT_PASSPHRASE =
    NigoriSpecifics_PassphraseType_FROZEN_IMPLICIT_PASSPHRASE;
  static constexpr PassphraseType CUSTOM_PASSPHRASE =
    NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE;
  static constexpr PassphraseType TRUSTED_VAULT_PASSPHRASE =
    NigoriSpecifics_PassphraseType_TRUSTED_VAULT_PASSPHRASE;
  static inline bool PassphraseType_IsValid(int value) {
    return NigoriSpecifics_PassphraseType_IsValid(value);
  }
  static constexpr PassphraseType PassphraseType_MIN =
    NigoriSpecifics_PassphraseType_PassphraseType_MIN;
  static constexpr PassphraseType PassphraseType_MAX =
    NigoriSpecifics_PassphraseType_PassphraseType_MAX;
  static constexpr int PassphraseType_ARRAYSIZE =
    NigoriSpecifics_PassphraseType_PassphraseType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PassphraseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PassphraseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PassphraseType_Name.");
    return NigoriSpecifics_PassphraseType_Name(enum_t_value);
  }
  static inline bool PassphraseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PassphraseType* value) {
    return NigoriSpecifics_PassphraseType_Parse(name, value);
  }

  typedef NigoriSpecifics_KeyDerivationMethod KeyDerivationMethod;
  static constexpr KeyDerivationMethod UNSPECIFIED =
    NigoriSpecifics_KeyDerivationMethod_UNSPECIFIED;
  static constexpr KeyDerivationMethod PBKDF2_HMAC_SHA1_1003 =
    NigoriSpecifics_KeyDerivationMethod_PBKDF2_HMAC_SHA1_1003;
  static constexpr KeyDerivationMethod SCRYPT_8192_8_11 =
    NigoriSpecifics_KeyDerivationMethod_SCRYPT_8192_8_11;
  static inline bool KeyDerivationMethod_IsValid(int value) {
    return NigoriSpecifics_KeyDerivationMethod_IsValid(value);
  }
  static constexpr KeyDerivationMethod KeyDerivationMethod_MIN =
    NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MIN;
  static constexpr KeyDerivationMethod KeyDerivationMethod_MAX =
    NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MAX;
  static constexpr int KeyDerivationMethod_ARRAYSIZE =
    NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_ARRAYSIZE;
  template<typename T>
  static inline const std::string& KeyDerivationMethod_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KeyDerivationMethod>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KeyDerivationMethod_Name.");
    return NigoriSpecifics_KeyDerivationMethod_Name(enum_t_value);
  }
  static inline bool KeyDerivationMethod_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KeyDerivationMethod* value) {
    return NigoriSpecifics_KeyDerivationMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCustomPassphraseKeyDerivationSaltFieldNumber = 46,
    kEncryptionKeybagFieldNumber = 1,
    kKeystoreDecryptorTokenFieldNumber = 31,
    kTrustedVaultDebugInfoFieldNumber = 50,
    kKeybagIsFrozenFieldNumber = 2,
    kEncryptBookmarksFieldNumber = 13,
    kEncryptPreferencesFieldNumber = 14,
    kEncryptAutofillProfileFieldNumber = 15,
    kEncryptAutofillFieldNumber = 16,
    kEncryptThemesFieldNumber = 17,
    kEncryptTypedUrlsFieldNumber = 18,
    kEncryptExtensionsFieldNumber = 19,
    kEncryptSessionsFieldNumber = 20,
    kEncryptAppsFieldNumber = 21,
    kEncryptSearchEnginesFieldNumber = 22,
    kEncryptEverythingFieldNumber = 24,
    kEncryptExtensionSettingsFieldNumber = 25,
    kEncryptAppNotificationsFieldNumber = 26,
    kEncryptAppSettingsFieldNumber = 27,
    kSyncTabFaviconsFieldNumber = 29,
    kKeystoreMigrationTimeFieldNumber = 32,
    kCustomPassphraseTimeFieldNumber = 33,
    kEncryptDictionaryFieldNumber = 34,
    kEncryptAppListFieldNumber = 38,
    kEncryptAutofillWalletMetadataFieldNumber = 39,
    kServerOnlyWasMissingKeystoreMigrationTimeFieldNumber = 40,
    kEncryptArcPackageFieldNumber = 41,
    kEncryptPrintersFieldNumber = 42,
    kEncryptReadingListFieldNumber = 43,
    kEncryptSendTabToSelfFieldNumber = 47,
    kCustomPassphraseKeyDerivationMethodFieldNumber = 45,
    kEncryptWebAppsFieldNumber = 48,
    kEncryptOsPreferencesFieldNumber = 49,
    kEncryptWorkspaceDeskFieldNumber = 51,
    kEncryptPrintersAuthorizationServersFieldNumber = 52,
    kPassphraseTypeFieldNumber = 30,
  };
  // optional string custom_passphrase_key_derivation_salt = 46;
  bool has_custom_passphrase_key_derivation_salt() const;
  private:
  bool _internal_has_custom_passphrase_key_derivation_salt() const;
  public:
  void clear_custom_passphrase_key_derivation_salt();
  const std::string& custom_passphrase_key_derivation_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_passphrase_key_derivation_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_passphrase_key_derivation_salt();
  PROTOBUF_NODISCARD std::string* release_custom_passphrase_key_derivation_salt();
  void set_allocated_custom_passphrase_key_derivation_salt(std::string* custom_passphrase_key_derivation_salt);
  private:
  const std::string& _internal_custom_passphrase_key_derivation_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_passphrase_key_derivation_salt(const std::string& value);
  std::string* _internal_mutable_custom_passphrase_key_derivation_salt();
  public:

  // optional .sync_pb.EncryptedData encryption_keybag = 1;
  bool has_encryption_keybag() const;
  private:
  bool _internal_has_encryption_keybag() const;
  public:
  void clear_encryption_keybag();
  const ::sync_pb::EncryptedData& encryption_keybag() const;
  PROTOBUF_NODISCARD ::sync_pb::EncryptedData* release_encryption_keybag();
  ::sync_pb::EncryptedData* mutable_encryption_keybag();
  void set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag);
  private:
  const ::sync_pb::EncryptedData& _internal_encryption_keybag() const;
  ::sync_pb::EncryptedData* _internal_mutable_encryption_keybag();
  public:
  void unsafe_arena_set_allocated_encryption_keybag(
      ::sync_pb::EncryptedData* encryption_keybag);
  ::sync_pb::EncryptedData* unsafe_arena_release_encryption_keybag();

  // optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
  bool has_keystore_decryptor_token() const;
  private:
  bool _internal_has_keystore_decryptor_token() const;
  public:
  void clear_keystore_decryptor_token();
  const ::sync_pb::EncryptedData& keystore_decryptor_token() const;
  PROTOBUF_NODISCARD ::sync_pb::EncryptedData* release_keystore_decryptor_token();
  ::sync_pb::EncryptedData* mutable_keystore_decryptor_token();
  void set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token);
  private:
  const ::sync_pb::EncryptedData& _internal_keystore_decryptor_token() const;
  ::sync_pb::EncryptedData* _internal_mutable_keystore_decryptor_token();
  public:
  void unsafe_arena_set_allocated_keystore_decryptor_token(
      ::sync_pb::EncryptedData* keystore_decryptor_token);
  ::sync_pb::EncryptedData* unsafe_arena_release_keystore_decryptor_token();

  // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
  bool has_trusted_vault_debug_info() const;
  private:
  bool _internal_has_trusted_vault_debug_info() const;
  public:
  void clear_trusted_vault_debug_info();
  const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& trusted_vault_debug_info() const;
  PROTOBUF_NODISCARD ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* release_trusted_vault_debug_info();
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* mutable_trusted_vault_debug_info();
  void set_allocated_trusted_vault_debug_info(::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info);
  private:
  const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& _internal_trusted_vault_debug_info() const;
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* _internal_mutable_trusted_vault_debug_info();
  public:
  void unsafe_arena_set_allocated_trusted_vault_debug_info(
      ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info);
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* unsafe_arena_release_trusted_vault_debug_info();

  // optional bool keybag_is_frozen = 2;
  bool has_keybag_is_frozen() const;
  private:
  bool _internal_has_keybag_is_frozen() const;
  public:
  void clear_keybag_is_frozen();
  bool keybag_is_frozen() const;
  void set_keybag_is_frozen(bool value);
  private:
  bool _internal_keybag_is_frozen() const;
  void _internal_set_keybag_is_frozen(bool value);
  public:

  // optional bool encrypt_bookmarks = 13;
  bool has_encrypt_bookmarks() const;
  private:
  bool _internal_has_encrypt_bookmarks() const;
  public:
  void clear_encrypt_bookmarks();
  bool encrypt_bookmarks() const;
  void set_encrypt_bookmarks(bool value);
  private:
  bool _internal_encrypt_bookmarks() const;
  void _internal_set_encrypt_bookmarks(bool value);
  public:

  // optional bool encrypt_preferences = 14;
  bool has_encrypt_preferences() const;
  private:
  bool _internal_has_encrypt_preferences() const;
  public:
  void clear_encrypt_preferences();
  bool encrypt_preferences() const;
  void set_encrypt_preferences(bool value);
  private:
  bool _internal_encrypt_preferences() const;
  void _internal_set_encrypt_preferences(bool value);
  public:

  // optional bool encrypt_autofill_profile = 15;
  bool has_encrypt_autofill_profile() const;
  private:
  bool _internal_has_encrypt_autofill_profile() const;
  public:
  void clear_encrypt_autofill_profile();
  bool encrypt_autofill_profile() const;
  void set_encrypt_autofill_profile(bool value);
  private:
  bool _internal_encrypt_autofill_profile() const;
  void _internal_set_encrypt_autofill_profile(bool value);
  public:

  // optional bool encrypt_autofill = 16;
  bool has_encrypt_autofill() const;
  private:
  bool _internal_has_encrypt_autofill() const;
  public:
  void clear_encrypt_autofill();
  bool encrypt_autofill() const;
  void set_encrypt_autofill(bool value);
  private:
  bool _internal_encrypt_autofill() const;
  void _internal_set_encrypt_autofill(bool value);
  public:

  // optional bool encrypt_themes = 17;
  bool has_encrypt_themes() const;
  private:
  bool _internal_has_encrypt_themes() const;
  public:
  void clear_encrypt_themes();
  bool encrypt_themes() const;
  void set_encrypt_themes(bool value);
  private:
  bool _internal_encrypt_themes() const;
  void _internal_set_encrypt_themes(bool value);
  public:

  // optional bool encrypt_typed_urls = 18;
  bool has_encrypt_typed_urls() const;
  private:
  bool _internal_has_encrypt_typed_urls() const;
  public:
  void clear_encrypt_typed_urls();
  bool encrypt_typed_urls() const;
  void set_encrypt_typed_urls(bool value);
  private:
  bool _internal_encrypt_typed_urls() const;
  void _internal_set_encrypt_typed_urls(bool value);
  public:

  // optional bool encrypt_extensions = 19;
  bool has_encrypt_extensions() const;
  private:
  bool _internal_has_encrypt_extensions() const;
  public:
  void clear_encrypt_extensions();
  bool encrypt_extensions() const;
  void set_encrypt_extensions(bool value);
  private:
  bool _internal_encrypt_extensions() const;
  void _internal_set_encrypt_extensions(bool value);
  public:

  // optional bool encrypt_sessions = 20;
  bool has_encrypt_sessions() const;
  private:
  bool _internal_has_encrypt_sessions() const;
  public:
  void clear_encrypt_sessions();
  bool encrypt_sessions() const;
  void set_encrypt_sessions(bool value);
  private:
  bool _internal_encrypt_sessions() const;
  void _internal_set_encrypt_sessions(bool value);
  public:

  // optional bool encrypt_apps = 21;
  bool has_encrypt_apps() const;
  private:
  bool _internal_has_encrypt_apps() const;
  public:
  void clear_encrypt_apps();
  bool encrypt_apps() const;
  void set_encrypt_apps(bool value);
  private:
  bool _internal_encrypt_apps() const;
  void _internal_set_encrypt_apps(bool value);
  public:

  // optional bool encrypt_search_engines = 22;
  bool has_encrypt_search_engines() const;
  private:
  bool _internal_has_encrypt_search_engines() const;
  public:
  void clear_encrypt_search_engines();
  bool encrypt_search_engines() const;
  void set_encrypt_search_engines(bool value);
  private:
  bool _internal_encrypt_search_engines() const;
  void _internal_set_encrypt_search_engines(bool value);
  public:

  // optional bool encrypt_everything = 24;
  bool has_encrypt_everything() const;
  private:
  bool _internal_has_encrypt_everything() const;
  public:
  void clear_encrypt_everything();
  bool encrypt_everything() const;
  void set_encrypt_everything(bool value);
  private:
  bool _internal_encrypt_everything() const;
  void _internal_set_encrypt_everything(bool value);
  public:

  // optional bool encrypt_extension_settings = 25;
  bool has_encrypt_extension_settings() const;
  private:
  bool _internal_has_encrypt_extension_settings() const;
  public:
  void clear_encrypt_extension_settings();
  bool encrypt_extension_settings() const;
  void set_encrypt_extension_settings(bool value);
  private:
  bool _internal_encrypt_extension_settings() const;
  void _internal_set_encrypt_extension_settings(bool value);
  public:

  // optional bool encrypt_app_notifications = 26 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_encrypt_app_notifications() const;
  private:
  bool _internal_has_encrypt_app_notifications() const;
  public:
  PROTOBUF_DEPRECATED void clear_encrypt_app_notifications();
  PROTOBUF_DEPRECATED bool encrypt_app_notifications() const;
  PROTOBUF_DEPRECATED void set_encrypt_app_notifications(bool value);
  private:
  bool _internal_encrypt_app_notifications() const;
  void _internal_set_encrypt_app_notifications(bool value);
  public:

  // optional bool encrypt_app_settings = 27;
  bool has_encrypt_app_settings() const;
  private:
  bool _internal_has_encrypt_app_settings() const;
  public:
  void clear_encrypt_app_settings();
  bool encrypt_app_settings() const;
  void set_encrypt_app_settings(bool value);
  private:
  bool _internal_encrypt_app_settings() const;
  void _internal_set_encrypt_app_settings(bool value);
  public:

  // optional bool sync_tab_favicons = 29;
  bool has_sync_tab_favicons() const;
  private:
  bool _internal_has_sync_tab_favicons() const;
  public:
  void clear_sync_tab_favicons();
  bool sync_tab_favicons() const;
  void set_sync_tab_favicons(bool value);
  private:
  bool _internal_sync_tab_favicons() const;
  void _internal_set_sync_tab_favicons(bool value);
  public:

  // optional int64 keystore_migration_time = 32;
  bool has_keystore_migration_time() const;
  private:
  bool _internal_has_keystore_migration_time() const;
  public:
  void clear_keystore_migration_time();
  int64_t keystore_migration_time() const;
  void set_keystore_migration_time(int64_t value);
  private:
  int64_t _internal_keystore_migration_time() const;
  void _internal_set_keystore_migration_time(int64_t value);
  public:

  // optional int64 custom_passphrase_time = 33;
  bool has_custom_passphrase_time() const;
  private:
  bool _internal_has_custom_passphrase_time() const;
  public:
  void clear_custom_passphrase_time();
  int64_t custom_passphrase_time() const;
  void set_custom_passphrase_time(int64_t value);
  private:
  int64_t _internal_custom_passphrase_time() const;
  void _internal_set_custom_passphrase_time(int64_t value);
  public:

  // optional bool encrypt_dictionary = 34;
  bool has_encrypt_dictionary() const;
  private:
  bool _internal_has_encrypt_dictionary() const;
  public:
  void clear_encrypt_dictionary();
  bool encrypt_dictionary() const;
  void set_encrypt_dictionary(bool value);
  private:
  bool _internal_encrypt_dictionary() const;
  void _internal_set_encrypt_dictionary(bool value);
  public:

  // optional bool encrypt_app_list = 38;
  bool has_encrypt_app_list() const;
  private:
  bool _internal_has_encrypt_app_list() const;
  public:
  void clear_encrypt_app_list();
  bool encrypt_app_list() const;
  void set_encrypt_app_list(bool value);
  private:
  bool _internal_encrypt_app_list() const;
  void _internal_set_encrypt_app_list(bool value);
  public:

  // optional bool encrypt_autofill_wallet_metadata = 39;
  bool has_encrypt_autofill_wallet_metadata() const;
  private:
  bool _internal_has_encrypt_autofill_wallet_metadata() const;
  public:
  void clear_encrypt_autofill_wallet_metadata();
  bool encrypt_autofill_wallet_metadata() const;
  void set_encrypt_autofill_wallet_metadata(bool value);
  private:
  bool _internal_encrypt_autofill_wallet_metadata() const;
  void _internal_set_encrypt_autofill_wallet_metadata(bool value);
  public:

  // optional bool server_only_was_missing_keystore_migration_time = 40;
  bool has_server_only_was_missing_keystore_migration_time() const;
  private:
  bool _internal_has_server_only_was_missing_keystore_migration_time() const;
  public:
  void clear_server_only_was_missing_keystore_migration_time();
  bool server_only_was_missing_keystore_migration_time() const;
  void set_server_only_was_missing_keystore_migration_time(bool value);
  private:
  bool _internal_server_only_was_missing_keystore_migration_time() const;
  void _internal_set_server_only_was_missing_keystore_migration_time(bool value);
  public:

  // optional bool encrypt_arc_package = 41;
  bool has_encrypt_arc_package() const;
  private:
  bool _internal_has_encrypt_arc_package() const;
  public:
  void clear_encrypt_arc_package();
  bool encrypt_arc_package() const;
  void set_encrypt_arc_package(bool value);
  private:
  bool _internal_encrypt_arc_package() const;
  void _internal_set_encrypt_arc_package(bool value);
  public:

  // optional bool encrypt_printers = 42;
  bool has_encrypt_printers() const;
  private:
  bool _internal_has_encrypt_printers() const;
  public:
  void clear_encrypt_printers();
  bool encrypt_printers() const;
  void set_encrypt_printers(bool value);
  private:
  bool _internal_encrypt_printers() const;
  void _internal_set_encrypt_printers(bool value);
  public:

  // optional bool encrypt_reading_list = 43;
  bool has_encrypt_reading_list() const;
  private:
  bool _internal_has_encrypt_reading_list() const;
  public:
  void clear_encrypt_reading_list();
  bool encrypt_reading_list() const;
  void set_encrypt_reading_list(bool value);
  private:
  bool _internal_encrypt_reading_list() const;
  void _internal_set_encrypt_reading_list(bool value);
  public:

  // optional bool encrypt_send_tab_to_self = 47;
  bool has_encrypt_send_tab_to_self() const;
  private:
  bool _internal_has_encrypt_send_tab_to_self() const;
  public:
  void clear_encrypt_send_tab_to_self();
  bool encrypt_send_tab_to_self() const;
  void set_encrypt_send_tab_to_self(bool value);
  private:
  bool _internal_encrypt_send_tab_to_self() const;
  void _internal_set_encrypt_send_tab_to_self(bool value);
  public:

  // optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
  bool has_custom_passphrase_key_derivation_method() const;
  private:
  bool _internal_has_custom_passphrase_key_derivation_method() const;
  public:
  void clear_custom_passphrase_key_derivation_method();
  int32_t custom_passphrase_key_derivation_method() const;
  void set_custom_passphrase_key_derivation_method(int32_t value);
  private:
  int32_t _internal_custom_passphrase_key_derivation_method() const;
  void _internal_set_custom_passphrase_key_derivation_method(int32_t value);
  public:

  // optional bool encrypt_web_apps = 48;
  bool has_encrypt_web_apps() const;
  private:
  bool _internal_has_encrypt_web_apps() const;
  public:
  void clear_encrypt_web_apps();
  bool encrypt_web_apps() const;
  void set_encrypt_web_apps(bool value);
  private:
  bool _internal_encrypt_web_apps() const;
  void _internal_set_encrypt_web_apps(bool value);
  public:

  // optional bool encrypt_os_preferences = 49;
  bool has_encrypt_os_preferences() const;
  private:
  bool _internal_has_encrypt_os_preferences() const;
  public:
  void clear_encrypt_os_preferences();
  bool encrypt_os_preferences() const;
  void set_encrypt_os_preferences(bool value);
  private:
  bool _internal_encrypt_os_preferences() const;
  void _internal_set_encrypt_os_preferences(bool value);
  public:

  // optional bool encrypt_workspace_desk = 51;
  bool has_encrypt_workspace_desk() const;
  private:
  bool _internal_has_encrypt_workspace_desk() const;
  public:
  void clear_encrypt_workspace_desk();
  bool encrypt_workspace_desk() const;
  void set_encrypt_workspace_desk(bool value);
  private:
  bool _internal_encrypt_workspace_desk() const;
  void _internal_set_encrypt_workspace_desk(bool value);
  public:

  // optional bool encrypt_printers_authorization_servers = 52;
  bool has_encrypt_printers_authorization_servers() const;
  private:
  bool _internal_has_encrypt_printers_authorization_servers() const;
  public:
  void clear_encrypt_printers_authorization_servers();
  bool encrypt_printers_authorization_servers() const;
  void set_encrypt_printers_authorization_servers(bool value);
  private:
  bool _internal_encrypt_printers_authorization_servers() const;
  void _internal_set_encrypt_printers_authorization_servers(bool value);
  public:

  // optional int32 passphrase_type = 30 [default = 1];
  bool has_passphrase_type() const;
  private:
  bool _internal_has_passphrase_type() const;
  public:
  void clear_passphrase_type();
  int32_t passphrase_type() const;
  void set_passphrase_type(int32_t value);
  private:
  int32_t _internal_passphrase_type() const;
  void _internal_set_passphrase_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_passphrase_key_derivation_salt_;
  ::sync_pb::EncryptedData* encryption_keybag_;
  ::sync_pb::EncryptedData* keystore_decryptor_token_;
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info_;
  bool keybag_is_frozen_;
  bool encrypt_bookmarks_;
  bool encrypt_preferences_;
  bool encrypt_autofill_profile_;
  bool encrypt_autofill_;
  bool encrypt_themes_;
  bool encrypt_typed_urls_;
  bool encrypt_extensions_;
  bool encrypt_sessions_;
  bool encrypt_apps_;
  bool encrypt_search_engines_;
  bool encrypt_everything_;
  bool encrypt_extension_settings_;
  bool encrypt_app_notifications_;
  bool encrypt_app_settings_;
  bool sync_tab_favicons_;
  int64_t keystore_migration_time_;
  int64_t custom_passphrase_time_;
  bool encrypt_dictionary_;
  bool encrypt_app_list_;
  bool encrypt_autofill_wallet_metadata_;
  bool server_only_was_missing_keystore_migration_time_;
  bool encrypt_arc_package_;
  bool encrypt_printers_;
  bool encrypt_reading_list_;
  bool encrypt_send_tab_to_self_;
  int32_t custom_passphrase_key_derivation_method_;
  bool encrypt_web_apps_;
  bool encrypt_os_preferences_;
  bool encrypt_workspace_desk_;
  bool encrypt_printers_authorization_servers_;
  int32_t passphrase_type_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NigoriKey

// optional string deprecated_name = 1 [deprecated = true];
inline bool NigoriKey::_internal_has_deprecated_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NigoriKey::has_deprecated_name() const {
  return _internal_has_deprecated_name();
}
inline void NigoriKey::clear_deprecated_name() {
  deprecated_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NigoriKey::deprecated_name() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.deprecated_name)
  return _internal_deprecated_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NigoriKey::set_deprecated_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 deprecated_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.deprecated_name)
}
inline std::string* NigoriKey::mutable_deprecated_name() {
  std::string* _s = _internal_mutable_deprecated_name();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.deprecated_name)
  return _s;
}
inline const std::string& NigoriKey::_internal_deprecated_name() const {
  return deprecated_name_.Get();
}
inline void NigoriKey::_internal_set_deprecated_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  deprecated_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_deprecated_name() {
  _has_bits_[0] |= 0x00000001u;
  return deprecated_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_deprecated_name() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.deprecated_name)
  if (!_internal_has_deprecated_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = deprecated_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deprecated_name_.IsDefault()) {
    deprecated_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NigoriKey::set_allocated_deprecated_name(std::string* deprecated_name) {
  if (deprecated_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  deprecated_name_.SetAllocated(deprecated_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deprecated_name_.IsDefault()) {
    deprecated_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.deprecated_name)
}

// optional bytes deprecated_user_key = 2 [deprecated = true];
inline bool NigoriKey::_internal_has_deprecated_user_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NigoriKey::has_deprecated_user_key() const {
  return _internal_has_deprecated_user_key();
}
inline void NigoriKey::clear_deprecated_user_key() {
  deprecated_user_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NigoriKey::deprecated_user_key() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.deprecated_user_key)
  return _internal_deprecated_user_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NigoriKey::set_deprecated_user_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 deprecated_user_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.deprecated_user_key)
}
inline std::string* NigoriKey::mutable_deprecated_user_key() {
  std::string* _s = _internal_mutable_deprecated_user_key();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.deprecated_user_key)
  return _s;
}
inline const std::string& NigoriKey::_internal_deprecated_user_key() const {
  return deprecated_user_key_.Get();
}
inline void NigoriKey::_internal_set_deprecated_user_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  deprecated_user_key_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_deprecated_user_key() {
  _has_bits_[0] |= 0x00000002u;
  return deprecated_user_key_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_deprecated_user_key() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.deprecated_user_key)
  if (!_internal_has_deprecated_user_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = deprecated_user_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deprecated_user_key_.IsDefault()) {
    deprecated_user_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NigoriKey::set_allocated_deprecated_user_key(std::string* deprecated_user_key) {
  if (deprecated_user_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  deprecated_user_key_.SetAllocated(deprecated_user_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deprecated_user_key_.IsDefault()) {
    deprecated_user_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.deprecated_user_key)
}

// optional bytes encryption_key = 3;
inline bool NigoriKey::_internal_has_encryption_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NigoriKey::has_encryption_key() const {
  return _internal_has_encryption_key();
}
inline void NigoriKey::clear_encryption_key() {
  encryption_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NigoriKey::encryption_key() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.encryption_key)
  return _internal_encryption_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NigoriKey::set_encryption_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 encryption_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.encryption_key)
}
inline std::string* NigoriKey::mutable_encryption_key() {
  std::string* _s = _internal_mutable_encryption_key();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.encryption_key)
  return _s;
}
inline const std::string& NigoriKey::_internal_encryption_key() const {
  return encryption_key_.Get();
}
inline void NigoriKey::_internal_set_encryption_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  encryption_key_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_encryption_key() {
  _has_bits_[0] |= 0x00000004u;
  return encryption_key_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_encryption_key() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.encryption_key)
  if (!_internal_has_encryption_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = encryption_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_key_.IsDefault()) {
    encryption_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NigoriKey::set_allocated_encryption_key(std::string* encryption_key) {
  if (encryption_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encryption_key_.SetAllocated(encryption_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encryption_key_.IsDefault()) {
    encryption_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.encryption_key)
}

// optional bytes mac_key = 4;
inline bool NigoriKey::_internal_has_mac_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NigoriKey::has_mac_key() const {
  return _internal_has_mac_key();
}
inline void NigoriKey::clear_mac_key() {
  mac_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NigoriKey::mac_key() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.mac_key)
  return _internal_mac_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NigoriKey::set_mac_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 mac_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.mac_key)
}
inline std::string* NigoriKey::mutable_mac_key() {
  std::string* _s = _internal_mutable_mac_key();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.mac_key)
  return _s;
}
inline const std::string& NigoriKey::_internal_mac_key() const {
  return mac_key_.Get();
}
inline void NigoriKey::_internal_set_mac_key(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  mac_key_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_mac_key() {
  _has_bits_[0] |= 0x00000008u;
  return mac_key_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_mac_key() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.mac_key)
  if (!_internal_has_mac_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = mac_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_key_.IsDefault()) {
    mac_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NigoriKey::set_allocated_mac_key(std::string* mac_key) {
  if (mac_key != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  mac_key_.SetAllocated(mac_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_key_.IsDefault()) {
    mac_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.mac_key)
}

// -------------------------------------------------------------------

// NigoriKeyBag

// repeated .sync_pb.NigoriKey key = 2;
inline int NigoriKeyBag::_internal_key_size() const {
  return key_.size();
}
inline int NigoriKeyBag::key_size() const {
  return _internal_key_size();
}
inline void NigoriKeyBag::clear_key() {
  key_.Clear();
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKeyBag.key)
  return key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NigoriKey >*
NigoriKeyBag::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.NigoriKeyBag.key)
  return &key_;
}
inline const ::sync_pb::NigoriKey& NigoriKeyBag::_internal_key(int index) const {
  return key_.Get(index);
}
inline const ::sync_pb::NigoriKey& NigoriKeyBag::key(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriKeyBag.key)
  return _internal_key(index);
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::_internal_add_key() {
  return key_.Add();
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::add_key() {
  ::sync_pb::NigoriKey* _add = _internal_add_key();
  // @@protoc_insertion_point(field_add:sync_pb.NigoriKeyBag.key)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NigoriKey >&
NigoriKeyBag::key() const {
  // @@protoc_insertion_point(field_list:sync_pb.NigoriKeyBag.key)
  return key_;
}

// -------------------------------------------------------------------

// NigoriSpecifics_TrustedVaultDebugInfo

// optional int64 migration_time = 1;
inline bool NigoriSpecifics_TrustedVaultDebugInfo::_internal_has_migration_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NigoriSpecifics_TrustedVaultDebugInfo::has_migration_time() const {
  return _internal_has_migration_time();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::clear_migration_time() {
  migration_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t NigoriSpecifics_TrustedVaultDebugInfo::_internal_migration_time() const {
  return migration_time_;
}
inline int64_t NigoriSpecifics_TrustedVaultDebugInfo::migration_time() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.migration_time)
  return _internal_migration_time();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::_internal_set_migration_time(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  migration_time_ = value;
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::set_migration_time(int64_t value) {
  _internal_set_migration_time(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.migration_time)
}

// optional int32 key_version = 2;
inline bool NigoriSpecifics_TrustedVaultDebugInfo::_internal_has_key_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NigoriSpecifics_TrustedVaultDebugInfo::has_key_version() const {
  return _internal_has_key_version();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::clear_key_version() {
  key_version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t NigoriSpecifics_TrustedVaultDebugInfo::_internal_key_version() const {
  return key_version_;
}
inline int32_t NigoriSpecifics_TrustedVaultDebugInfo::key_version() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.key_version)
  return _internal_key_version();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::_internal_set_key_version(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  key_version_ = value;
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::set_key_version(int32_t value) {
  _internal_set_key_version(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.key_version)
}

// -------------------------------------------------------------------

// NigoriSpecifics

// optional .sync_pb.EncryptedData encryption_keybag = 1;
inline bool NigoriSpecifics::_internal_has_encryption_keybag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || encryption_keybag_ != nullptr);
  return value;
}
inline bool NigoriSpecifics::has_encryption_keybag() const {
  return _internal_has_encryption_keybag();
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::_internal_encryption_keybag() const {
  const ::sync_pb::EncryptedData* p = encryption_keybag_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::EncryptedData&>(
      ::sync_pb::_EncryptedData_default_instance_);
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::encryption_keybag() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encryption_keybag)
  return _internal_encryption_keybag();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_encryption_keybag(
    ::sync_pb::EncryptedData* encryption_keybag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_keybag_);
  }
  encryption_keybag_ = encryption_keybag;
  if (encryption_keybag) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.encryption_keybag)
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::release_encryption_keybag() {
  _has_bits_[0] &= ~0x00000002u;
  ::sync_pb::EncryptedData* temp = encryption_keybag_;
  encryption_keybag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::unsafe_arena_release_encryption_keybag() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.encryption_keybag)
  _has_bits_[0] &= ~0x00000002u;
  ::sync_pb::EncryptedData* temp = encryption_keybag_;
  encryption_keybag_ = nullptr;
  return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::_internal_mutable_encryption_keybag() {
  _has_bits_[0] |= 0x00000002u;
  if (encryption_keybag_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::EncryptedData>(GetArenaForAllocation());
    encryption_keybag_ = p;
  }
  return encryption_keybag_;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::mutable_encryption_keybag() {
  ::sync_pb::EncryptedData* _msg = _internal_mutable_encryption_keybag();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.encryption_keybag)
  return _msg;
}
inline void NigoriSpecifics::set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_keybag_);
  }
  if (encryption_keybag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_keybag));
    if (message_arena != submessage_arena) {
      encryption_keybag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_keybag, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encryption_keybag_ = encryption_keybag;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.encryption_keybag)
}

// optional bool keybag_is_frozen = 2;
inline bool NigoriSpecifics::_internal_has_keybag_is_frozen() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_keybag_is_frozen() const {
  return _internal_has_keybag_is_frozen();
}
inline void NigoriSpecifics::clear_keybag_is_frozen() {
  keybag_is_frozen_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool NigoriSpecifics::_internal_keybag_is_frozen() const {
  return keybag_is_frozen_;
}
inline bool NigoriSpecifics::keybag_is_frozen() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.keybag_is_frozen)
  return _internal_keybag_is_frozen();
}
inline void NigoriSpecifics::_internal_set_keybag_is_frozen(bool value) {
  _has_bits_[0] |= 0x00000010u;
  keybag_is_frozen_ = value;
}
inline void NigoriSpecifics::set_keybag_is_frozen(bool value) {
  _internal_set_keybag_is_frozen(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.keybag_is_frozen)
}

// optional bool encrypt_bookmarks = 13;
inline bool NigoriSpecifics::_internal_has_encrypt_bookmarks() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_bookmarks() const {
  return _internal_has_encrypt_bookmarks();
}
inline void NigoriSpecifics::clear_encrypt_bookmarks() {
  encrypt_bookmarks_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool NigoriSpecifics::_internal_encrypt_bookmarks() const {
  return encrypt_bookmarks_;
}
inline bool NigoriSpecifics::encrypt_bookmarks() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_bookmarks)
  return _internal_encrypt_bookmarks();
}
inline void NigoriSpecifics::_internal_set_encrypt_bookmarks(bool value) {
  _has_bits_[0] |= 0x00000020u;
  encrypt_bookmarks_ = value;
}
inline void NigoriSpecifics::set_encrypt_bookmarks(bool value) {
  _internal_set_encrypt_bookmarks(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_bookmarks)
}

// optional bool encrypt_preferences = 14;
inline bool NigoriSpecifics::_internal_has_encrypt_preferences() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_preferences() const {
  return _internal_has_encrypt_preferences();
}
inline void NigoriSpecifics::clear_encrypt_preferences() {
  encrypt_preferences_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool NigoriSpecifics::_internal_encrypt_preferences() const {
  return encrypt_preferences_;
}
inline bool NigoriSpecifics::encrypt_preferences() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_preferences)
  return _internal_encrypt_preferences();
}
inline void NigoriSpecifics::_internal_set_encrypt_preferences(bool value) {
  _has_bits_[0] |= 0x00000040u;
  encrypt_preferences_ = value;
}
inline void NigoriSpecifics::set_encrypt_preferences(bool value) {
  _internal_set_encrypt_preferences(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_preferences)
}

// optional bool encrypt_autofill_profile = 15;
inline bool NigoriSpecifics::_internal_has_encrypt_autofill_profile() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_autofill_profile() const {
  return _internal_has_encrypt_autofill_profile();
}
inline void NigoriSpecifics::clear_encrypt_autofill_profile() {
  encrypt_autofill_profile_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool NigoriSpecifics::_internal_encrypt_autofill_profile() const {
  return encrypt_autofill_profile_;
}
inline bool NigoriSpecifics::encrypt_autofill_profile() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_autofill_profile)
  return _internal_encrypt_autofill_profile();
}
inline void NigoriSpecifics::_internal_set_encrypt_autofill_profile(bool value) {
  _has_bits_[0] |= 0x00000080u;
  encrypt_autofill_profile_ = value;
}
inline void NigoriSpecifics::set_encrypt_autofill_profile(bool value) {
  _internal_set_encrypt_autofill_profile(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_autofill_profile)
}

// optional bool encrypt_autofill = 16;
inline bool NigoriSpecifics::_internal_has_encrypt_autofill() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_autofill() const {
  return _internal_has_encrypt_autofill();
}
inline void NigoriSpecifics::clear_encrypt_autofill() {
  encrypt_autofill_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool NigoriSpecifics::_internal_encrypt_autofill() const {
  return encrypt_autofill_;
}
inline bool NigoriSpecifics::encrypt_autofill() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_autofill)
  return _internal_encrypt_autofill();
}
inline void NigoriSpecifics::_internal_set_encrypt_autofill(bool value) {
  _has_bits_[0] |= 0x00000100u;
  encrypt_autofill_ = value;
}
inline void NigoriSpecifics::set_encrypt_autofill(bool value) {
  _internal_set_encrypt_autofill(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_autofill)
}

// optional bool encrypt_themes = 17;
inline bool NigoriSpecifics::_internal_has_encrypt_themes() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_themes() const {
  return _internal_has_encrypt_themes();
}
inline void NigoriSpecifics::clear_encrypt_themes() {
  encrypt_themes_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool NigoriSpecifics::_internal_encrypt_themes() const {
  return encrypt_themes_;
}
inline bool NigoriSpecifics::encrypt_themes() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_themes)
  return _internal_encrypt_themes();
}
inline void NigoriSpecifics::_internal_set_encrypt_themes(bool value) {
  _has_bits_[0] |= 0x00000200u;
  encrypt_themes_ = value;
}
inline void NigoriSpecifics::set_encrypt_themes(bool value) {
  _internal_set_encrypt_themes(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_themes)
}

// optional bool encrypt_typed_urls = 18;
inline bool NigoriSpecifics::_internal_has_encrypt_typed_urls() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_typed_urls() const {
  return _internal_has_encrypt_typed_urls();
}
inline void NigoriSpecifics::clear_encrypt_typed_urls() {
  encrypt_typed_urls_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool NigoriSpecifics::_internal_encrypt_typed_urls() const {
  return encrypt_typed_urls_;
}
inline bool NigoriSpecifics::encrypt_typed_urls() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_typed_urls)
  return _internal_encrypt_typed_urls();
}
inline void NigoriSpecifics::_internal_set_encrypt_typed_urls(bool value) {
  _has_bits_[0] |= 0x00000400u;
  encrypt_typed_urls_ = value;
}
inline void NigoriSpecifics::set_encrypt_typed_urls(bool value) {
  _internal_set_encrypt_typed_urls(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_typed_urls)
}

// optional bool encrypt_extensions = 19;
inline bool NigoriSpecifics::_internal_has_encrypt_extensions() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_extensions() const {
  return _internal_has_encrypt_extensions();
}
inline void NigoriSpecifics::clear_encrypt_extensions() {
  encrypt_extensions_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool NigoriSpecifics::_internal_encrypt_extensions() const {
  return encrypt_extensions_;
}
inline bool NigoriSpecifics::encrypt_extensions() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_extensions)
  return _internal_encrypt_extensions();
}
inline void NigoriSpecifics::_internal_set_encrypt_extensions(bool value) {
  _has_bits_[0] |= 0x00000800u;
  encrypt_extensions_ = value;
}
inline void NigoriSpecifics::set_encrypt_extensions(bool value) {
  _internal_set_encrypt_extensions(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_extensions)
}

// optional bool encrypt_sessions = 20;
inline bool NigoriSpecifics::_internal_has_encrypt_sessions() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_sessions() const {
  return _internal_has_encrypt_sessions();
}
inline void NigoriSpecifics::clear_encrypt_sessions() {
  encrypt_sessions_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool NigoriSpecifics::_internal_encrypt_sessions() const {
  return encrypt_sessions_;
}
inline bool NigoriSpecifics::encrypt_sessions() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_sessions)
  return _internal_encrypt_sessions();
}
inline void NigoriSpecifics::_internal_set_encrypt_sessions(bool value) {
  _has_bits_[0] |= 0x00001000u;
  encrypt_sessions_ = value;
}
inline void NigoriSpecifics::set_encrypt_sessions(bool value) {
  _internal_set_encrypt_sessions(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_sessions)
}

// optional bool encrypt_apps = 21;
inline bool NigoriSpecifics::_internal_has_encrypt_apps() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_apps() const {
  return _internal_has_encrypt_apps();
}
inline void NigoriSpecifics::clear_encrypt_apps() {
  encrypt_apps_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool NigoriSpecifics::_internal_encrypt_apps() const {
  return encrypt_apps_;
}
inline bool NigoriSpecifics::encrypt_apps() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_apps)
  return _internal_encrypt_apps();
}
inline void NigoriSpecifics::_internal_set_encrypt_apps(bool value) {
  _has_bits_[0] |= 0x00002000u;
  encrypt_apps_ = value;
}
inline void NigoriSpecifics::set_encrypt_apps(bool value) {
  _internal_set_encrypt_apps(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_apps)
}

// optional bool encrypt_search_engines = 22;
inline bool NigoriSpecifics::_internal_has_encrypt_search_engines() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_search_engines() const {
  return _internal_has_encrypt_search_engines();
}
inline void NigoriSpecifics::clear_encrypt_search_engines() {
  encrypt_search_engines_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool NigoriSpecifics::_internal_encrypt_search_engines() const {
  return encrypt_search_engines_;
}
inline bool NigoriSpecifics::encrypt_search_engines() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_search_engines)
  return _internal_encrypt_search_engines();
}
inline void NigoriSpecifics::_internal_set_encrypt_search_engines(bool value) {
  _has_bits_[0] |= 0x00004000u;
  encrypt_search_engines_ = value;
}
inline void NigoriSpecifics::set_encrypt_search_engines(bool value) {
  _internal_set_encrypt_search_engines(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_search_engines)
}

// optional bool encrypt_everything = 24;
inline bool NigoriSpecifics::_internal_has_encrypt_everything() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_everything() const {
  return _internal_has_encrypt_everything();
}
inline void NigoriSpecifics::clear_encrypt_everything() {
  encrypt_everything_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool NigoriSpecifics::_internal_encrypt_everything() const {
  return encrypt_everything_;
}
inline bool NigoriSpecifics::encrypt_everything() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_everything)
  return _internal_encrypt_everything();
}
inline void NigoriSpecifics::_internal_set_encrypt_everything(bool value) {
  _has_bits_[0] |= 0x00008000u;
  encrypt_everything_ = value;
}
inline void NigoriSpecifics::set_encrypt_everything(bool value) {
  _internal_set_encrypt_everything(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_everything)
}

// optional bool encrypt_extension_settings = 25;
inline bool NigoriSpecifics::_internal_has_encrypt_extension_settings() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_extension_settings() const {
  return _internal_has_encrypt_extension_settings();
}
inline void NigoriSpecifics::clear_encrypt_extension_settings() {
  encrypt_extension_settings_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool NigoriSpecifics::_internal_encrypt_extension_settings() const {
  return encrypt_extension_settings_;
}
inline bool NigoriSpecifics::encrypt_extension_settings() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_extension_settings)
  return _internal_encrypt_extension_settings();
}
inline void NigoriSpecifics::_internal_set_encrypt_extension_settings(bool value) {
  _has_bits_[0] |= 0x00010000u;
  encrypt_extension_settings_ = value;
}
inline void NigoriSpecifics::set_encrypt_extension_settings(bool value) {
  _internal_set_encrypt_extension_settings(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_extension_settings)
}

// optional bool encrypt_app_notifications = 26 [deprecated = true];
inline bool NigoriSpecifics::_internal_has_encrypt_app_notifications() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_app_notifications() const {
  return _internal_has_encrypt_app_notifications();
}
inline void NigoriSpecifics::clear_encrypt_app_notifications() {
  encrypt_app_notifications_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool NigoriSpecifics::_internal_encrypt_app_notifications() const {
  return encrypt_app_notifications_;
}
inline bool NigoriSpecifics::encrypt_app_notifications() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_app_notifications)
  return _internal_encrypt_app_notifications();
}
inline void NigoriSpecifics::_internal_set_encrypt_app_notifications(bool value) {
  _has_bits_[0] |= 0x00020000u;
  encrypt_app_notifications_ = value;
}
inline void NigoriSpecifics::set_encrypt_app_notifications(bool value) {
  _internal_set_encrypt_app_notifications(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_app_notifications)
}

// optional bool encrypt_app_settings = 27;
inline bool NigoriSpecifics::_internal_has_encrypt_app_settings() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_app_settings() const {
  return _internal_has_encrypt_app_settings();
}
inline void NigoriSpecifics::clear_encrypt_app_settings() {
  encrypt_app_settings_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool NigoriSpecifics::_internal_encrypt_app_settings() const {
  return encrypt_app_settings_;
}
inline bool NigoriSpecifics::encrypt_app_settings() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_app_settings)
  return _internal_encrypt_app_settings();
}
inline void NigoriSpecifics::_internal_set_encrypt_app_settings(bool value) {
  _has_bits_[0] |= 0x00040000u;
  encrypt_app_settings_ = value;
}
inline void NigoriSpecifics::set_encrypt_app_settings(bool value) {
  _internal_set_encrypt_app_settings(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_app_settings)
}

// optional bool sync_tab_favicons = 29;
inline bool NigoriSpecifics::_internal_has_sync_tab_favicons() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_sync_tab_favicons() const {
  return _internal_has_sync_tab_favicons();
}
inline void NigoriSpecifics::clear_sync_tab_favicons() {
  sync_tab_favicons_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool NigoriSpecifics::_internal_sync_tab_favicons() const {
  return sync_tab_favicons_;
}
inline bool NigoriSpecifics::sync_tab_favicons() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.sync_tab_favicons)
  return _internal_sync_tab_favicons();
}
inline void NigoriSpecifics::_internal_set_sync_tab_favicons(bool value) {
  _has_bits_[0] |= 0x00080000u;
  sync_tab_favicons_ = value;
}
inline void NigoriSpecifics::set_sync_tab_favicons(bool value) {
  _internal_set_sync_tab_favicons(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.sync_tab_favicons)
}

// optional int32 passphrase_type = 30 [default = 1];
inline bool NigoriSpecifics::_internal_has_passphrase_type() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_passphrase_type() const {
  return _internal_has_passphrase_type();
}
inline void NigoriSpecifics::clear_passphrase_type() {
  passphrase_type_ = 1;
  _has_bits_[1] &= ~0x00000008u;
}
inline int32_t NigoriSpecifics::_internal_passphrase_type() const {
  return passphrase_type_;
}
inline int32_t NigoriSpecifics::passphrase_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.passphrase_type)
  return _internal_passphrase_type();
}
inline void NigoriSpecifics::_internal_set_passphrase_type(int32_t value) {
  _has_bits_[1] |= 0x00000008u;
  passphrase_type_ = value;
}
inline void NigoriSpecifics::set_passphrase_type(int32_t value) {
  _internal_set_passphrase_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.passphrase_type)
}

// optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
inline bool NigoriSpecifics::_internal_has_keystore_decryptor_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || keystore_decryptor_token_ != nullptr);
  return value;
}
inline bool NigoriSpecifics::has_keystore_decryptor_token() const {
  return _internal_has_keystore_decryptor_token();
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::_internal_keystore_decryptor_token() const {
  const ::sync_pb::EncryptedData* p = keystore_decryptor_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::EncryptedData&>(
      ::sync_pb::_EncryptedData_default_instance_);
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::keystore_decryptor_token() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.keystore_decryptor_token)
  return _internal_keystore_decryptor_token();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_keystore_decryptor_token(
    ::sync_pb::EncryptedData* keystore_decryptor_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keystore_decryptor_token_);
  }
  keystore_decryptor_token_ = keystore_decryptor_token;
  if (keystore_decryptor_token) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.keystore_decryptor_token)
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::release_keystore_decryptor_token() {
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::EncryptedData* temp = keystore_decryptor_token_;
  keystore_decryptor_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::unsafe_arena_release_keystore_decryptor_token() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.keystore_decryptor_token)
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::EncryptedData* temp = keystore_decryptor_token_;
  keystore_decryptor_token_ = nullptr;
  return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::_internal_mutable_keystore_decryptor_token() {
  _has_bits_[0] |= 0x00000004u;
  if (keystore_decryptor_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::EncryptedData>(GetArenaForAllocation());
    keystore_decryptor_token_ = p;
  }
  return keystore_decryptor_token_;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::mutable_keystore_decryptor_token() {
  ::sync_pb::EncryptedData* _msg = _internal_mutable_keystore_decryptor_token();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.keystore_decryptor_token)
  return _msg;
}
inline void NigoriSpecifics::set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(keystore_decryptor_token_);
  }
  if (keystore_decryptor_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keystore_decryptor_token));
    if (message_arena != submessage_arena) {
      keystore_decryptor_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keystore_decryptor_token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  keystore_decryptor_token_ = keystore_decryptor_token;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.keystore_decryptor_token)
}

// optional int64 keystore_migration_time = 32;
inline bool NigoriSpecifics::_internal_has_keystore_migration_time() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_keystore_migration_time() const {
  return _internal_has_keystore_migration_time();
}
inline void NigoriSpecifics::clear_keystore_migration_time() {
  keystore_migration_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline int64_t NigoriSpecifics::_internal_keystore_migration_time() const {
  return keystore_migration_time_;
}
inline int64_t NigoriSpecifics::keystore_migration_time() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.keystore_migration_time)
  return _internal_keystore_migration_time();
}
inline void NigoriSpecifics::_internal_set_keystore_migration_time(int64_t value) {
  _has_bits_[0] |= 0x00100000u;
  keystore_migration_time_ = value;
}
inline void NigoriSpecifics::set_keystore_migration_time(int64_t value) {
  _internal_set_keystore_migration_time(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.keystore_migration_time)
}

// optional int64 custom_passphrase_time = 33;
inline bool NigoriSpecifics::_internal_has_custom_passphrase_time() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_custom_passphrase_time() const {
  return _internal_has_custom_passphrase_time();
}
inline void NigoriSpecifics::clear_custom_passphrase_time() {
  custom_passphrase_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00200000u;
}
inline int64_t NigoriSpecifics::_internal_custom_passphrase_time() const {
  return custom_passphrase_time_;
}
inline int64_t NigoriSpecifics::custom_passphrase_time() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.custom_passphrase_time)
  return _internal_custom_passphrase_time();
}
inline void NigoriSpecifics::_internal_set_custom_passphrase_time(int64_t value) {
  _has_bits_[0] |= 0x00200000u;
  custom_passphrase_time_ = value;
}
inline void NigoriSpecifics::set_custom_passphrase_time(int64_t value) {
  _internal_set_custom_passphrase_time(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.custom_passphrase_time)
}

// optional bool encrypt_dictionary = 34;
inline bool NigoriSpecifics::_internal_has_encrypt_dictionary() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_dictionary() const {
  return _internal_has_encrypt_dictionary();
}
inline void NigoriSpecifics::clear_encrypt_dictionary() {
  encrypt_dictionary_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool NigoriSpecifics::_internal_encrypt_dictionary() const {
  return encrypt_dictionary_;
}
inline bool NigoriSpecifics::encrypt_dictionary() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_dictionary)
  return _internal_encrypt_dictionary();
}
inline void NigoriSpecifics::_internal_set_encrypt_dictionary(bool value) {
  _has_bits_[0] |= 0x00400000u;
  encrypt_dictionary_ = value;
}
inline void NigoriSpecifics::set_encrypt_dictionary(bool value) {
  _internal_set_encrypt_dictionary(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_dictionary)
}

// optional bool encrypt_app_list = 38;
inline bool NigoriSpecifics::_internal_has_encrypt_app_list() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_app_list() const {
  return _internal_has_encrypt_app_list();
}
inline void NigoriSpecifics::clear_encrypt_app_list() {
  encrypt_app_list_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool NigoriSpecifics::_internal_encrypt_app_list() const {
  return encrypt_app_list_;
}
inline bool NigoriSpecifics::encrypt_app_list() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_app_list)
  return _internal_encrypt_app_list();
}
inline void NigoriSpecifics::_internal_set_encrypt_app_list(bool value) {
  _has_bits_[0] |= 0x00800000u;
  encrypt_app_list_ = value;
}
inline void NigoriSpecifics::set_encrypt_app_list(bool value) {
  _internal_set_encrypt_app_list(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_app_list)
}

// optional bool encrypt_autofill_wallet_metadata = 39;
inline bool NigoriSpecifics::_internal_has_encrypt_autofill_wallet_metadata() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_autofill_wallet_metadata() const {
  return _internal_has_encrypt_autofill_wallet_metadata();
}
inline void NigoriSpecifics::clear_encrypt_autofill_wallet_metadata() {
  encrypt_autofill_wallet_metadata_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool NigoriSpecifics::_internal_encrypt_autofill_wallet_metadata() const {
  return encrypt_autofill_wallet_metadata_;
}
inline bool NigoriSpecifics::encrypt_autofill_wallet_metadata() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_autofill_wallet_metadata)
  return _internal_encrypt_autofill_wallet_metadata();
}
inline void NigoriSpecifics::_internal_set_encrypt_autofill_wallet_metadata(bool value) {
  _has_bits_[0] |= 0x01000000u;
  encrypt_autofill_wallet_metadata_ = value;
}
inline void NigoriSpecifics::set_encrypt_autofill_wallet_metadata(bool value) {
  _internal_set_encrypt_autofill_wallet_metadata(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_autofill_wallet_metadata)
}

// optional bool server_only_was_missing_keystore_migration_time = 40;
inline bool NigoriSpecifics::_internal_has_server_only_was_missing_keystore_migration_time() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_server_only_was_missing_keystore_migration_time() const {
  return _internal_has_server_only_was_missing_keystore_migration_time();
}
inline void NigoriSpecifics::clear_server_only_was_missing_keystore_migration_time() {
  server_only_was_missing_keystore_migration_time_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool NigoriSpecifics::_internal_server_only_was_missing_keystore_migration_time() const {
  return server_only_was_missing_keystore_migration_time_;
}
inline bool NigoriSpecifics::server_only_was_missing_keystore_migration_time() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.server_only_was_missing_keystore_migration_time)
  return _internal_server_only_was_missing_keystore_migration_time();
}
inline void NigoriSpecifics::_internal_set_server_only_was_missing_keystore_migration_time(bool value) {
  _has_bits_[0] |= 0x02000000u;
  server_only_was_missing_keystore_migration_time_ = value;
}
inline void NigoriSpecifics::set_server_only_was_missing_keystore_migration_time(bool value) {
  _internal_set_server_only_was_missing_keystore_migration_time(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.server_only_was_missing_keystore_migration_time)
}

// optional bool encrypt_arc_package = 41;
inline bool NigoriSpecifics::_internal_has_encrypt_arc_package() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_arc_package() const {
  return _internal_has_encrypt_arc_package();
}
inline void NigoriSpecifics::clear_encrypt_arc_package() {
  encrypt_arc_package_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool NigoriSpecifics::_internal_encrypt_arc_package() const {
  return encrypt_arc_package_;
}
inline bool NigoriSpecifics::encrypt_arc_package() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_arc_package)
  return _internal_encrypt_arc_package();
}
inline void NigoriSpecifics::_internal_set_encrypt_arc_package(bool value) {
  _has_bits_[0] |= 0x04000000u;
  encrypt_arc_package_ = value;
}
inline void NigoriSpecifics::set_encrypt_arc_package(bool value) {
  _internal_set_encrypt_arc_package(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_arc_package)
}

// optional bool encrypt_printers = 42;
inline bool NigoriSpecifics::_internal_has_encrypt_printers() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_printers() const {
  return _internal_has_encrypt_printers();
}
inline void NigoriSpecifics::clear_encrypt_printers() {
  encrypt_printers_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool NigoriSpecifics::_internal_encrypt_printers() const {
  return encrypt_printers_;
}
inline bool NigoriSpecifics::encrypt_printers() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_printers)
  return _internal_encrypt_printers();
}
inline void NigoriSpecifics::_internal_set_encrypt_printers(bool value) {
  _has_bits_[0] |= 0x08000000u;
  encrypt_printers_ = value;
}
inline void NigoriSpecifics::set_encrypt_printers(bool value) {
  _internal_set_encrypt_printers(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_printers)
}

// optional bool encrypt_reading_list = 43;
inline bool NigoriSpecifics::_internal_has_encrypt_reading_list() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_reading_list() const {
  return _internal_has_encrypt_reading_list();
}
inline void NigoriSpecifics::clear_encrypt_reading_list() {
  encrypt_reading_list_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool NigoriSpecifics::_internal_encrypt_reading_list() const {
  return encrypt_reading_list_;
}
inline bool NigoriSpecifics::encrypt_reading_list() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_reading_list)
  return _internal_encrypt_reading_list();
}
inline void NigoriSpecifics::_internal_set_encrypt_reading_list(bool value) {
  _has_bits_[0] |= 0x10000000u;
  encrypt_reading_list_ = value;
}
inline void NigoriSpecifics::set_encrypt_reading_list(bool value) {
  _internal_set_encrypt_reading_list(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_reading_list)
}

// optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
inline bool NigoriSpecifics::_internal_has_custom_passphrase_key_derivation_method() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_custom_passphrase_key_derivation_method() const {
  return _internal_has_custom_passphrase_key_derivation_method();
}
inline void NigoriSpecifics::clear_custom_passphrase_key_derivation_method() {
  custom_passphrase_key_derivation_method_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline int32_t NigoriSpecifics::_internal_custom_passphrase_key_derivation_method() const {
  return custom_passphrase_key_derivation_method_;
}
inline int32_t NigoriSpecifics::custom_passphrase_key_derivation_method() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_method)
  return _internal_custom_passphrase_key_derivation_method();
}
inline void NigoriSpecifics::_internal_set_custom_passphrase_key_derivation_method(int32_t value) {
  _has_bits_[0] |= 0x40000000u;
  custom_passphrase_key_derivation_method_ = value;
}
inline void NigoriSpecifics::set_custom_passphrase_key_derivation_method(int32_t value) {
  _internal_set_custom_passphrase_key_derivation_method(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_method)
}

// optional string custom_passphrase_key_derivation_salt = 46;
inline bool NigoriSpecifics::_internal_has_custom_passphrase_key_derivation_salt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_custom_passphrase_key_derivation_salt() const {
  return _internal_has_custom_passphrase_key_derivation_salt();
}
inline void NigoriSpecifics::clear_custom_passphrase_key_derivation_salt() {
  custom_passphrase_key_derivation_salt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NigoriSpecifics::custom_passphrase_key_derivation_salt() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
  return _internal_custom_passphrase_key_derivation_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NigoriSpecifics::set_custom_passphrase_key_derivation_salt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 custom_passphrase_key_derivation_salt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
}
inline std::string* NigoriSpecifics::mutable_custom_passphrase_key_derivation_salt() {
  std::string* _s = _internal_mutable_custom_passphrase_key_derivation_salt();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
  return _s;
}
inline const std::string& NigoriSpecifics::_internal_custom_passphrase_key_derivation_salt() const {
  return custom_passphrase_key_derivation_salt_.Get();
}
inline void NigoriSpecifics::_internal_set_custom_passphrase_key_derivation_salt(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  custom_passphrase_key_derivation_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriSpecifics::_internal_mutable_custom_passphrase_key_derivation_salt() {
  _has_bits_[0] |= 0x00000001u;
  return custom_passphrase_key_derivation_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriSpecifics::release_custom_passphrase_key_derivation_salt() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
  if (!_internal_has_custom_passphrase_key_derivation_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = custom_passphrase_key_derivation_salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (custom_passphrase_key_derivation_salt_.IsDefault()) {
    custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NigoriSpecifics::set_allocated_custom_passphrase_key_derivation_salt(std::string* custom_passphrase_key_derivation_salt) {
  if (custom_passphrase_key_derivation_salt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  custom_passphrase_key_derivation_salt_.SetAllocated(custom_passphrase_key_derivation_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (custom_passphrase_key_derivation_salt_.IsDefault()) {
    custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
}

// optional bool encrypt_send_tab_to_self = 47;
inline bool NigoriSpecifics::_internal_has_encrypt_send_tab_to_self() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_send_tab_to_self() const {
  return _internal_has_encrypt_send_tab_to_self();
}
inline void NigoriSpecifics::clear_encrypt_send_tab_to_self() {
  encrypt_send_tab_to_self_ = false;
  _has_bits_[0] &= ~0x20000000u;
}
inline bool NigoriSpecifics::_internal_encrypt_send_tab_to_self() const {
  return encrypt_send_tab_to_self_;
}
inline bool NigoriSpecifics::encrypt_send_tab_to_self() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_send_tab_to_self)
  return _internal_encrypt_send_tab_to_self();
}
inline void NigoriSpecifics::_internal_set_encrypt_send_tab_to_self(bool value) {
  _has_bits_[0] |= 0x20000000u;
  encrypt_send_tab_to_self_ = value;
}
inline void NigoriSpecifics::set_encrypt_send_tab_to_self(bool value) {
  _internal_set_encrypt_send_tab_to_self(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_send_tab_to_self)
}

// optional bool encrypt_web_apps = 48;
inline bool NigoriSpecifics::_internal_has_encrypt_web_apps() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_web_apps() const {
  return _internal_has_encrypt_web_apps();
}
inline void NigoriSpecifics::clear_encrypt_web_apps() {
  encrypt_web_apps_ = false;
  _has_bits_[0] &= ~0x80000000u;
}
inline bool NigoriSpecifics::_internal_encrypt_web_apps() const {
  return encrypt_web_apps_;
}
inline bool NigoriSpecifics::encrypt_web_apps() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_web_apps)
  return _internal_encrypt_web_apps();
}
inline void NigoriSpecifics::_internal_set_encrypt_web_apps(bool value) {
  _has_bits_[0] |= 0x80000000u;
  encrypt_web_apps_ = value;
}
inline void NigoriSpecifics::set_encrypt_web_apps(bool value) {
  _internal_set_encrypt_web_apps(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_web_apps)
}

// optional bool encrypt_os_preferences = 49;
inline bool NigoriSpecifics::_internal_has_encrypt_os_preferences() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_os_preferences() const {
  return _internal_has_encrypt_os_preferences();
}
inline void NigoriSpecifics::clear_encrypt_os_preferences() {
  encrypt_os_preferences_ = false;
  _has_bits_[1] &= ~0x00000001u;
}
inline bool NigoriSpecifics::_internal_encrypt_os_preferences() const {
  return encrypt_os_preferences_;
}
inline bool NigoriSpecifics::encrypt_os_preferences() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_os_preferences)
  return _internal_encrypt_os_preferences();
}
inline void NigoriSpecifics::_internal_set_encrypt_os_preferences(bool value) {
  _has_bits_[1] |= 0x00000001u;
  encrypt_os_preferences_ = value;
}
inline void NigoriSpecifics::set_encrypt_os_preferences(bool value) {
  _internal_set_encrypt_os_preferences(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_os_preferences)
}

// optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
inline bool NigoriSpecifics::_internal_has_trusted_vault_debug_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || trusted_vault_debug_info_ != nullptr);
  return value;
}
inline bool NigoriSpecifics::has_trusted_vault_debug_info() const {
  return _internal_has_trusted_vault_debug_info();
}
inline void NigoriSpecifics::clear_trusted_vault_debug_info() {
  if (trusted_vault_debug_info_ != nullptr) trusted_vault_debug_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& NigoriSpecifics::_internal_trusted_vault_debug_info() const {
  const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* p = trusted_vault_debug_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo&>(
      ::sync_pb::_NigoriSpecifics_TrustedVaultDebugInfo_default_instance_);
}
inline const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& NigoriSpecifics::trusted_vault_debug_info() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
  return _internal_trusted_vault_debug_info();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_trusted_vault_debug_info(
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trusted_vault_debug_info_);
  }
  trusted_vault_debug_info_ = trusted_vault_debug_info;
  if (trusted_vault_debug_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::release_trusted_vault_debug_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* temp = trusted_vault_debug_info_;
  trusted_vault_debug_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::unsafe_arena_release_trusted_vault_debug_info() {
  // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
  _has_bits_[0] &= ~0x00000008u;
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* temp = trusted_vault_debug_info_;
  trusted_vault_debug_info_ = nullptr;
  return temp;
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::_internal_mutable_trusted_vault_debug_info() {
  _has_bits_[0] |= 0x00000008u;
  if (trusted_vault_debug_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo>(GetArenaForAllocation());
    trusted_vault_debug_info_ = p;
  }
  return trusted_vault_debug_info_;
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::mutable_trusted_vault_debug_info() {
  ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* _msg = _internal_mutable_trusted_vault_debug_info();
  // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
  return _msg;
}
inline void NigoriSpecifics::set_allocated_trusted_vault_debug_info(::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trusted_vault_debug_info_;
  }
  if (trusted_vault_debug_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trusted_vault_debug_info);
    if (message_arena != submessage_arena) {
      trusted_vault_debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trusted_vault_debug_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  trusted_vault_debug_info_ = trusted_vault_debug_info;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
}

// optional bool encrypt_workspace_desk = 51;
inline bool NigoriSpecifics::_internal_has_encrypt_workspace_desk() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_workspace_desk() const {
  return _internal_has_encrypt_workspace_desk();
}
inline void NigoriSpecifics::clear_encrypt_workspace_desk() {
  encrypt_workspace_desk_ = false;
  _has_bits_[1] &= ~0x00000002u;
}
inline bool NigoriSpecifics::_internal_encrypt_workspace_desk() const {
  return encrypt_workspace_desk_;
}
inline bool NigoriSpecifics::encrypt_workspace_desk() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_workspace_desk)
  return _internal_encrypt_workspace_desk();
}
inline void NigoriSpecifics::_internal_set_encrypt_workspace_desk(bool value) {
  _has_bits_[1] |= 0x00000002u;
  encrypt_workspace_desk_ = value;
}
inline void NigoriSpecifics::set_encrypt_workspace_desk(bool value) {
  _internal_set_encrypt_workspace_desk(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_workspace_desk)
}

// optional bool encrypt_printers_authorization_servers = 52;
inline bool NigoriSpecifics::_internal_has_encrypt_printers_authorization_servers() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool NigoriSpecifics::has_encrypt_printers_authorization_servers() const {
  return _internal_has_encrypt_printers_authorization_servers();
}
inline void NigoriSpecifics::clear_encrypt_printers_authorization_servers() {
  encrypt_printers_authorization_servers_ = false;
  _has_bits_[1] &= ~0x00000004u;
}
inline bool NigoriSpecifics::_internal_encrypt_printers_authorization_servers() const {
  return encrypt_printers_authorization_servers_;
}
inline bool NigoriSpecifics::encrypt_printers_authorization_servers() const {
  // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_printers_authorization_servers)
  return _internal_encrypt_printers_authorization_servers();
}
inline void NigoriSpecifics::_internal_set_encrypt_printers_authorization_servers(bool value) {
  _has_bits_[1] |= 0x00000004u;
  encrypt_printers_authorization_servers_ = value;
}
inline void NigoriSpecifics::set_encrypt_printers_authorization_servers(bool value) {
  _internal_set_encrypt_printers_authorization_servers(value);
  // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_printers_authorization_servers)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sync_pb::NigoriSpecifics_PassphraseType> : ::std::true_type {};
template <> struct is_proto_enum< ::sync_pb::NigoriSpecifics_KeyDerivationMethod> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto
