// media/capture/mojom/video_capture.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_CAPTURE_MOJOM_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_
#define MEDIA_CAPTURE_MOJOM_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_

#include "media/capture/mojom/video_capture.mojom.h"


namespace media {
namespace mojom {


class  VideoCaptureObserverInterceptorForTesting : public VideoCaptureObserver {
  virtual VideoCaptureObserver* GetForwardingInterface() = 0;
  void OnStateChanged(VideoCaptureResultPtr result) override;
  void OnNewBuffer(int32_t buffer_id, ::media::mojom::VideoBufferHandlePtr buffer_handle) override;
  void OnBufferReady(::media::mojom::ReadyBufferPtr buffer, std::vector<::media::mojom::ReadyBufferPtr> scaled_buffers) override;
  void OnBufferDestroyed(int32_t buffer_id) override;
  void OnNewCropVersion(uint32_t crop_version) override;
};
class  VideoCaptureObserverAsyncWaiter {
 public:
  explicit VideoCaptureObserverAsyncWaiter(VideoCaptureObserver* proxy);

  VideoCaptureObserverAsyncWaiter(const VideoCaptureObserverAsyncWaiter&) = delete;
  VideoCaptureObserverAsyncWaiter& operator=(const VideoCaptureObserverAsyncWaiter&) = delete;

  ~VideoCaptureObserverAsyncWaiter();

 private:
  VideoCaptureObserver* const proxy_;
};


class  VideoCaptureHostInterceptorForTesting : public VideoCaptureHost {
  virtual VideoCaptureHost* GetForwardingInterface() = 0;
  void Start(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, const ::media::VideoCaptureParams& params, ::mojo::PendingRemote<VideoCaptureObserver> observer) override;
  void Stop(const ::base::UnguessableToken& device_id) override;
  void Pause(const ::base::UnguessableToken& device_id) override;
  void Resume(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, const ::media::VideoCaptureParams& params) override;
  void RequestRefreshFrame(const ::base::UnguessableToken& device_id) override;
  void ReleaseBuffer(const ::base::UnguessableToken& device_id, int32_t buffer_id, const ::media::VideoCaptureFeedback& feedback) override;
  void GetDeviceSupportedFormats(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, GetDeviceSupportedFormatsCallback callback) override;
  void GetDeviceFormatsInUse(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, GetDeviceFormatsInUseCallback callback) override;
  void OnFrameDropped(const ::base::UnguessableToken& device_id, ::media::VideoCaptureFrameDropReason reason) override;
  void OnLog(const ::base::UnguessableToken& device_id, const std::string& message) override;
};
class  VideoCaptureHostAsyncWaiter {
 public:
  explicit VideoCaptureHostAsyncWaiter(VideoCaptureHost* proxy);

  VideoCaptureHostAsyncWaiter(const VideoCaptureHostAsyncWaiter&) = delete;
  VideoCaptureHostAsyncWaiter& operator=(const VideoCaptureHostAsyncWaiter&) = delete;

  ~VideoCaptureHostAsyncWaiter();
  void GetDeviceSupportedFormats(
      const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, std::vector<::media::VideoCaptureFormat>* out_formats_supported);
  void GetDeviceFormatsInUse(
      const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, std::vector<::media::VideoCaptureFormat>* out_formats_in_use);

 private:
  VideoCaptureHost* const proxy_;
};




}  // namespace mojom
}  // namespace media

#endif  // MEDIA_CAPTURE_MOJOM_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_