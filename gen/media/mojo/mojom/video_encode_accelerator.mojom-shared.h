// media/mojo/mojom/video_encode_accelerator.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_VIDEO_ENCODE_ACCELERATOR_MOJOM_SHARED_H_
#define MEDIA_MOJO_MOJOM_VIDEO_ENCODE_ACCELERATOR_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "media/mojo/mojom/video_encode_accelerator.mojom-shared-internal.h"
#include "media/mojo/mojom/media_log.mojom-shared.h"
#include "media/mojo/mojom/media_types.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "media/mojo/mojom/video_encoder_info.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"




namespace media {
namespace mojom {
class VideoEncodeAcceleratorSupportedProfileDataView;

class VariableBitratePeakDataView;

class VideoBitrateAllocationDataView;

class SpatialLayerDataView;

class ConstantBitrateDataView;

class VariableBitrateDataView;

class VideoEncodeAcceleratorConfigDataView;

class H264MetadataDataView;

class Vp8MetadataDataView;

class Vp9MetadataDataView;

class Av1MetadataDataView;

class BitstreamBufferMetadataDataView;

class BitrateDataView;
class CodecMetadataDataView;


}  // namespace mojom
}  // namespace media

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView> {
  using Data = ::media::mojom::internal::VideoEncodeAcceleratorSupportedProfile_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VariableBitratePeakDataView> {
  using Data = ::media::mojom::internal::VariableBitratePeak_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoBitrateAllocationDataView> {
  using Data = ::media::mojom::internal::VideoBitrateAllocation_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::SpatialLayerDataView> {
  using Data = ::media::mojom::internal::SpatialLayer_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::ConstantBitrateDataView> {
  using Data = ::media::mojom::internal::ConstantBitrate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VariableBitrateDataView> {
  using Data = ::media::mojom::internal::VariableBitrate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoEncodeAcceleratorConfigDataView> {
  using Data = ::media::mojom::internal::VideoEncodeAcceleratorConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::H264MetadataDataView> {
  using Data = ::media::mojom::internal::H264Metadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::Vp8MetadataDataView> {
  using Data = ::media::mojom::internal::Vp8Metadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::Vp9MetadataDataView> {
  using Data = ::media::mojom::internal::Vp9Metadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::Av1MetadataDataView> {
  using Data = ::media::mojom::internal::Av1Metadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::BitstreamBufferMetadataDataView> {
  using Data = ::media::mojom::internal::BitstreamBufferMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::BitrateDataView> {
  using Data = ::media::mojom::internal::Bitrate_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::media::mojom::CodecMetadataDataView> {
  using Data = ::media::mojom::internal::CodecMetadata_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace media {
namespace mojom {


enum class VideoEncodeAcceleratorSupportedRateControlMode : int32_t {
  
  kNoMode = 0,
  
  kConstantMode = 1,
  
  kVariableMode = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorSupportedRateControlMode value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorSupportedRateControlMode value) {
  return internal::VideoEncodeAcceleratorSupportedRateControlMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class VideoEncodeAcceleratorConfig_ContentType : int32_t {
  
  kCamera = 0,
  
  kDisplay = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorConfig_ContentType value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorConfig_ContentType value) {
  return internal::VideoEncodeAcceleratorConfig_ContentType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class VideoEncodeAcceleratorConfig_InterLayerPredMode : int32_t {
  
  kOff = 0,
  
  kOn = 1,
  
  kOnKeyPic = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorConfig_InterLayerPredMode value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorConfig_InterLayerPredMode value) {
  return internal::VideoEncodeAcceleratorConfig_InterLayerPredMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class VideoEncodeAcceleratorConfig_StorageType : int32_t {
  
  kShmem = 0,
  
  kGpuMemoryBuffer = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorConfig_StorageType value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorConfig_StorageType value) {
  return internal::VideoEncodeAcceleratorConfig_StorageType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class VideoEncodeAccelerator_Error : int32_t {
  
  ILLEGAL_STATE = 0,
  
  INVALID_ARGUMENT = 1,
  
  PLATFORM_FAILURE = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, VideoEncodeAccelerator_Error value);
inline bool IsKnownEnumValue(VideoEncodeAccelerator_Error value) {
  return internal::VideoEncodeAccelerator_Error_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class VideoEncodeAcceleratorProviderInterfaceBase {};

using VideoEncodeAcceleratorProviderPtrDataView =
    mojo::InterfacePtrDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
using VideoEncodeAcceleratorProviderRequestDataView =
    mojo::InterfaceRequestDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
using VideoEncodeAcceleratorProviderAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
using VideoEncodeAcceleratorProviderAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
class VideoEncodeAcceleratorInterfaceBase {};

using VideoEncodeAcceleratorPtrDataView =
    mojo::InterfacePtrDataView<VideoEncodeAcceleratorInterfaceBase>;
using VideoEncodeAcceleratorRequestDataView =
    mojo::InterfaceRequestDataView<VideoEncodeAcceleratorInterfaceBase>;
using VideoEncodeAcceleratorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<VideoEncodeAcceleratorInterfaceBase>;
using VideoEncodeAcceleratorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<VideoEncodeAcceleratorInterfaceBase>;
class VideoEncodeAcceleratorClientInterfaceBase {};

using VideoEncodeAcceleratorClientPtrDataView =
    mojo::InterfacePtrDataView<VideoEncodeAcceleratorClientInterfaceBase>;
using VideoEncodeAcceleratorClientRequestDataView =
    mojo::InterfaceRequestDataView<VideoEncodeAcceleratorClientInterfaceBase>;
using VideoEncodeAcceleratorClientAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<VideoEncodeAcceleratorClientInterfaceBase>;
using VideoEncodeAcceleratorClientAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<VideoEncodeAcceleratorClientInterfaceBase>;


class VideoEncodeAcceleratorSupportedProfileDataView {
 public:
  VideoEncodeAcceleratorSupportedProfileDataView() = default;

  VideoEncodeAcceleratorSupportedProfileDataView(
      internal::VideoEncodeAcceleratorSupportedProfile_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadProfile(UserType* output) const {
    auto data_value = data_->profile;
    return mojo::internal::Deserialize<::media::mojom::VideoCodecProfile>(
        data_value, output);
  }
  ::media::mojom::VideoCodecProfile profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoCodecProfile>(data_->profile));
  }
  inline void GetMinResolutionDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMinResolution(UserType* output) {
    
    auto* pointer = data_->min_resolution.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetMaxResolutionDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMaxResolution(UserType* output) {
    
    auto* pointer = data_->max_resolution.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  uint32_t max_framerate_numerator() const {
    return data_->max_framerate_numerator;
  }
  uint32_t max_framerate_denominator() const {
    return data_->max_framerate_denominator;
  }
  inline void GetRateControlModesDataView(
      mojo::ArrayDataView<VideoEncodeAcceleratorSupportedRateControlMode>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRateControlModes(UserType* output) {
    
    auto* pointer = data_->rate_control_modes.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>>(
        pointer, output, message_);
  }
  inline void GetScalabilityModesDataView(
      mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadScalabilityModes(UserType* output) {
    
    auto* pointer = data_->scalability_modes.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>>(
        pointer, output, message_);
  }
 private:
  internal::VideoEncodeAcceleratorSupportedProfile_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VariableBitratePeakDataView {
 public:
  VariableBitratePeakDataView() = default;

  VariableBitratePeakDataView(
      internal::VariableBitratePeak_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t bps() const {
    return data_->bps;
  }
 private:
  internal::VariableBitratePeak_Data* data_ = nullptr;
};



class VideoBitrateAllocationDataView {
 public:
  VideoBitrateAllocationDataView() = default;

  VideoBitrateAllocationDataView(
      internal::VideoBitrateAllocation_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetBitratesDataView(
      mojo::ArrayDataView<uint32_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBitrates(UserType* output) {
    
    auto* pointer = data_->bitrates.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint32_t>>(
        pointer, output, message_);
  }
  inline void GetVariableBitratePeakDataView(
      VariableBitratePeakDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVariableBitratePeak(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::VariableBitratePeakDataView, UserType>(),
    "Attempting to read the optional `variable_bitrate_peak` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadVariableBitratePeak` instead "
    "of `ReadVariableBitratePeak if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->variable_bitrate_peak.Get();
    return mojo::internal::Deserialize<::media::mojom::VariableBitratePeakDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoBitrateAllocation_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SpatialLayerDataView {
 public:
  SpatialLayerDataView() = default;

  SpatialLayerDataView(
      internal::SpatialLayer_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t width() const {
    return data_->width;
  }
  int32_t height() const {
    return data_->height;
  }
  uint32_t bitrate_bps() const {
    return data_->bitrate_bps;
  }
  uint32_t framerate() const {
    return data_->framerate;
  }
  uint8_t max_qp() const {
    return data_->max_qp;
  }
  uint8_t num_of_temporal_layers() const {
    return data_->num_of_temporal_layers;
  }
 private:
  internal::SpatialLayer_Data* data_ = nullptr;
};



class ConstantBitrateDataView {
 public:
  ConstantBitrateDataView() = default;

  ConstantBitrateDataView(
      internal::ConstantBitrate_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t target_bps() const {
    return data_->target_bps;
  }
 private:
  internal::ConstantBitrate_Data* data_ = nullptr;
};



class VariableBitrateDataView {
 public:
  VariableBitrateDataView() = default;

  VariableBitrateDataView(
      internal::VariableBitrate_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t target_bps() const {
    return data_->target_bps;
  }
  uint32_t peak_bps() const {
    return data_->peak_bps;
  }
 private:
  internal::VariableBitrate_Data* data_ = nullptr;
};



class VideoEncodeAcceleratorConfigDataView {
 public:
  VideoEncodeAcceleratorConfigDataView() = default;

  VideoEncodeAcceleratorConfigDataView(
      internal::VideoEncodeAcceleratorConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadInputFormat(UserType* output) const {
    auto data_value = data_->input_format;
    return mojo::internal::Deserialize<::media::mojom::VideoPixelFormat>(
        data_value, output);
  }
  ::media::mojom::VideoPixelFormat input_format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoPixelFormat>(data_->input_format));
  }
  inline void GetInputVisibleSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInputVisibleSize(UserType* output) {
    
    auto* pointer = data_->input_visible_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadOutputProfile(UserType* output) const {
    auto data_value = data_->output_profile;
    return mojo::internal::Deserialize<::media::mojom::VideoCodecProfile>(
        data_value, output);
  }
  ::media::mojom::VideoCodecProfile output_profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoCodecProfile>(data_->output_profile));
  }
  inline void GetBitrateDataView(
      BitrateDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBitrate(UserType* output) {
    
    auto* pointer = !data_->bitrate.is_null() ? &data_->bitrate : nullptr;
    return mojo::internal::Deserialize<::media::mojom::BitrateDataView>(
        pointer, output, message_);
  }
  uint32_t initial_framerate() const {
    return data_->initial_framerate;
  }
  bool has_initial_framerate() const {
    return data_->has_initial_framerate;
  }
  uint32_t gop_length() const {
    return data_->gop_length;
  }
  bool has_gop_length() const {
    return data_->has_gop_length;
  }
  uint8_t h264_output_level() const {
    return data_->h264_output_level;
  }
  bool has_h264_output_level() const {
    return data_->has_h264_output_level;
  }
  bool is_constrained_h264() const {
    return data_->is_constrained_h264;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadStorageType(UserType* output) const {
    auto data_value = data_->storage_type;
    return mojo::internal::Deserialize<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(
        data_value, output);
  }
  VideoEncodeAcceleratorConfig_StorageType storage_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(data_->storage_type));
  }
  bool has_storage_type() const {
    return data_->has_storage_type;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadContentType(UserType* output) const {
    auto data_value = data_->content_type;
    return mojo::internal::Deserialize<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(
        data_value, output);
  }
  VideoEncodeAcceleratorConfig_ContentType content_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(data_->content_type));
  }
  inline void GetSpatialLayersDataView(
      mojo::ArrayDataView<SpatialLayerDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSpatialLayers(UserType* output) {
    
    auto* pointer = data_->spatial_layers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::SpatialLayerDataView>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadInterLayerPred(UserType* output) const {
    auto data_value = data_->inter_layer_pred;
    return mojo::internal::Deserialize<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode>(
        data_value, output);
  }
  VideoEncodeAcceleratorConfig_InterLayerPredMode inter_layer_pred() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode>(data_->inter_layer_pred));
  }
  bool require_low_delay() const {
    return data_->require_low_delay;
  }
 private:
  internal::VideoEncodeAcceleratorConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class H264MetadataDataView {
 public:
  H264MetadataDataView() = default;

  H264MetadataDataView(
      internal::H264Metadata_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint8_t temporal_idx() const {
    return data_->temporal_idx;
  }
  bool layer_sync() const {
    return data_->layer_sync;
  }
 private:
  internal::H264Metadata_Data* data_ = nullptr;
};



class Vp8MetadataDataView {
 public:
  Vp8MetadataDataView() = default;

  Vp8MetadataDataView(
      internal::Vp8Metadata_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  bool non_reference() const {
    return data_->non_reference;
  }
  uint8_t temporal_idx() const {
    return data_->temporal_idx;
  }
  bool layer_sync() const {
    return data_->layer_sync;
  }
 private:
  internal::Vp8Metadata_Data* data_ = nullptr;
};



class Vp9MetadataDataView {
 public:
  Vp9MetadataDataView() = default;

  Vp9MetadataDataView(
      internal::Vp9Metadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  bool inter_pic_predicted() const {
    return data_->inter_pic_predicted;
  }
  bool temporal_up_switch() const {
    return data_->temporal_up_switch;
  }
  bool referenced_by_upper_spatial_layers() const {
    return data_->referenced_by_upper_spatial_layers;
  }
  bool reference_lower_spatial_layers() const {
    return data_->reference_lower_spatial_layers;
  }
  bool end_of_picture() const {
    return data_->end_of_picture;
  }
  uint8_t temporal_idx() const {
    return data_->temporal_idx;
  }
  uint8_t spatial_idx() const {
    return data_->spatial_idx;
  }
  inline void GetSpatialLayerResolutionsDataView(
      mojo::ArrayDataView<::gfx::mojom::SizeDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSpatialLayerResolutions(UserType* output) {
    
    auto* pointer = data_->spatial_layer_resolutions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::gfx::mojom::SizeDataView>>(
        pointer, output, message_);
  }
  inline void GetPDiffsDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPDiffs(UserType* output) {
    
    auto* pointer = data_->p_diffs.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::Vp9Metadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class Av1MetadataDataView {
 public:
  Av1MetadataDataView() = default;

  Av1MetadataDataView(
      internal::Av1Metadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  bool inter_pic_predicted() const {
    return data_->inter_pic_predicted;
  }
  bool switch_frame() const {
    return data_->switch_frame;
  }
  bool end_of_picture() const {
    return data_->end_of_picture;
  }
  uint8_t temporal_idx() const {
    return data_->temporal_idx;
  }
  uint8_t spatial_idx() const {
    return data_->spatial_idx;
  }
  inline void GetSpatialLayerResolutionsDataView(
      mojo::ArrayDataView<::gfx::mojom::SizeDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSpatialLayerResolutions(UserType* output) {
    
    auto* pointer = data_->spatial_layer_resolutions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::gfx::mojom::SizeDataView>>(
        pointer, output, message_);
  }
  inline void GetFDiffsDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFDiffs(UserType* output) {
    
    auto* pointer = data_->f_diffs.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::Av1Metadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BitstreamBufferMetadataDataView {
 public:
  BitstreamBufferMetadataDataView() = default;

  BitstreamBufferMetadataDataView(
      internal::BitstreamBufferMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint32_t payload_size_bytes() const {
    return data_->payload_size_bytes;
  }
  bool key_frame() const {
    return data_->key_frame;
  }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  int32_t qp() const {
    return data_->qp;
  }
  inline void GetCodecMetadataDataView(
      CodecMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodecMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::CodecMetadataDataView, UserType>(),
    "Attempting to read the optional `codec_metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCodecMetadata` instead "
    "of `ReadCodecMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = !data_->codec_metadata.is_null() ? &data_->codec_metadata : nullptr;
    return mojo::internal::Deserialize<::media::mojom::CodecMetadataDataView>(
        pointer, output, message_);
  }
 private:
  internal::BitstreamBufferMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BitrateDataView {
 public:
  using Tag = internal::Bitrate_Data::Bitrate_Tag;

  BitrateDataView() = default;

  BitrateDataView(
      internal::Bitrate_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_constant() const { return data_->tag == Tag::kConstant; }
  inline void GetConstantDataView(
      ConstantBitrateDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadConstant(UserType* output) const {
    
    CHECK(is_constant());
    return mojo::internal::Deserialize<::media::mojom::ConstantBitrateDataView>(
        data_->data.f_constant.Get(), output, message_);
  }
  bool is_variable() const { return data_->tag == Tag::kVariable; }
  inline void GetVariableDataView(
      VariableBitrateDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadVariable(UserType* output) const {
    
    CHECK(is_variable());
    return mojo::internal::Deserialize<::media::mojom::VariableBitrateDataView>(
        data_->data.f_variable.Get(), output, message_);
  }

 private:
  internal::Bitrate_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CodecMetadataDataView {
 public:
  using Tag = internal::CodecMetadata_Data::CodecMetadata_Tag;

  CodecMetadataDataView() = default;

  CodecMetadataDataView(
      internal::CodecMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_h264() const { return data_->tag == Tag::kH264; }
  inline void GetH264DataView(
      H264MetadataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadH264(UserType* output) const {
    
    CHECK(is_h264());
    return mojo::internal::Deserialize<::media::mojom::H264MetadataDataView>(
        data_->data.f_h264.Get(), output, message_);
  }
  bool is_vp8() const { return data_->tag == Tag::kVp8; }
  inline void GetVp8DataView(
      Vp8MetadataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadVp8(UserType* output) const {
    
    CHECK(is_vp8());
    return mojo::internal::Deserialize<::media::mojom::Vp8MetadataDataView>(
        data_->data.f_vp8.Get(), output, message_);
  }
  bool is_vp9() const { return data_->tag == Tag::kVp9; }
  inline void GetVp9DataView(
      Vp9MetadataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadVp9(UserType* output) const {
    
    CHECK(is_vp9());
    return mojo::internal::Deserialize<::media::mojom::Vp9MetadataDataView>(
        data_->data.f_vp9.Get(), output, message_);
  }
  bool is_av1() const { return data_->tag == Tag::kAv1; }
  inline void GetAv1DataView(
      Av1MetadataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadAv1(UserType* output) const {
    
    CHECK(is_av1());
    return mojo::internal::Deserialize<::media::mojom::Av1MetadataDataView>(
        data_->data.f_av1.Get(), output, message_);
  }

 private:
  internal::CodecMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace media

namespace std {

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode> {};

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorConfig_ContentType> {};

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode> {};

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorConfig_StorageType> {};

template <>
struct hash<::media::mojom::VideoEncodeAccelerator_Error>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAccelerator_Error> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAcceleratorConfig_ContentType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorConfig_ContentType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAcceleratorConfig_StorageType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorConfig_StorageType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAccelerator_Error, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::VideoEncodeAccelerator_Error, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::VideoEncodeAccelerator_Error>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoEncodeAcceleratorSupportedProfile_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoCodecProfile>(
        Traits::profile(input), &fragment->profile);
    decltype(Traits::min_resolution(input)) in_min_resolution = Traits::min_resolution(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->min_resolution)::BaseType> min_resolution_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_min_resolution, min_resolution_fragment);
    fragment->min_resolution.Set(
        min_resolution_fragment.is_null() ? nullptr : min_resolution_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->min_resolution.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null min_resolution in VideoEncodeAcceleratorSupportedProfile struct");
    decltype(Traits::max_resolution(input)) in_max_resolution = Traits::max_resolution(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->max_resolution)::BaseType> max_resolution_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_max_resolution, max_resolution_fragment);
    fragment->max_resolution.Set(
        max_resolution_fragment.is_null() ? nullptr : max_resolution_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->max_resolution.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null max_resolution in VideoEncodeAcceleratorSupportedProfile struct");
    fragment->max_framerate_numerator = Traits::max_framerate_numerator(input);
    fragment->max_framerate_denominator = Traits::max_framerate_denominator(input);
    decltype(Traits::rate_control_modes(input)) in_rate_control_modes = Traits::rate_control_modes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->rate_control_modes)::BaseType>
        rate_control_modes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams rate_control_modes_validate_params(
        0, ::media::mojom::internal::VideoEncodeAcceleratorSupportedRateControlMode_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>>(
        in_rate_control_modes, rate_control_modes_fragment, &rate_control_modes_validate_params);
    fragment->rate_control_modes.Set(
        rate_control_modes_fragment.is_null() ? nullptr : rate_control_modes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->rate_control_modes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null rate_control_modes in VideoEncodeAcceleratorSupportedProfile struct");
    decltype(Traits::scalability_modes(input)) in_scalability_modes = Traits::scalability_modes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->scalability_modes)::BaseType>
        scalability_modes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams scalability_modes_validate_params(
        0, ::media::mojom::internal::SVCScalabilityMode_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>>(
        in_scalability_modes, scalability_modes_fragment, &scalability_modes_validate_params);
    fragment->scalability_modes.Set(
        scalability_modes_fragment.is_null() ? nullptr : scalability_modes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->scalability_modes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null scalability_modes in VideoEncodeAcceleratorSupportedProfile struct");
  }

  static bool Deserialize(::media::mojom::internal::VideoEncodeAcceleratorSupportedProfile_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VariableBitratePeakDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VariableBitratePeakDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VariableBitratePeak_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->bps = Traits::bps(input);
  }

  static bool Deserialize(::media::mojom::internal::VariableBitratePeak_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VariableBitratePeakDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoBitrateAllocationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoBitrateAllocationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoBitrateAllocation_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::bitrates(input)) in_bitrates = Traits::bitrates(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->bitrates)::BaseType>
        bitrates_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams bitrates_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
        in_bitrates, bitrates_fragment, &bitrates_validate_params);
    fragment->bitrates.Set(
        bitrates_fragment.is_null() ? nullptr : bitrates_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->bitrates.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null bitrates in VideoBitrateAllocation struct");
    decltype(Traits::variable_bitrate_peak(input)) in_variable_bitrate_peak = Traits::variable_bitrate_peak(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->variable_bitrate_peak)::BaseType> variable_bitrate_peak_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::VariableBitratePeakDataView>(
        in_variable_bitrate_peak, variable_bitrate_peak_fragment);
    fragment->variable_bitrate_peak.Set(
        variable_bitrate_peak_fragment.is_null() ? nullptr : variable_bitrate_peak_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::VideoBitrateAllocation_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoBitrateAllocationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::SpatialLayerDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::SpatialLayerDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::SpatialLayer_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->width = Traits::width(input);
    fragment->height = Traits::height(input);
    fragment->bitrate_bps = Traits::bitrate_bps(input);
    fragment->framerate = Traits::framerate(input);
    fragment->max_qp = Traits::max_qp(input);
    fragment->num_of_temporal_layers = Traits::num_of_temporal_layers(input);
  }

  static bool Deserialize(::media::mojom::internal::SpatialLayer_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::SpatialLayerDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::ConstantBitrateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::ConstantBitrateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::ConstantBitrate_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->target_bps = Traits::target_bps(input);
  }

  static bool Deserialize(::media::mojom::internal::ConstantBitrate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::ConstantBitrateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VariableBitrateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VariableBitrateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VariableBitrate_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->target_bps = Traits::target_bps(input);
    fragment->peak_bps = Traits::peak_bps(input);
  }

  static bool Deserialize(::media::mojom::internal::VariableBitrate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VariableBitrateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoEncodeAcceleratorConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoEncodeAcceleratorConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoEncodeAcceleratorConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoPixelFormat>(
        Traits::input_format(input), &fragment->input_format);
    decltype(Traits::input_visible_size(input)) in_input_visible_size = Traits::input_visible_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->input_visible_size)::BaseType> input_visible_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_input_visible_size, input_visible_size_fragment);
    fragment->input_visible_size.Set(
        input_visible_size_fragment.is_null() ? nullptr : input_visible_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->input_visible_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null input_visible_size in VideoEncodeAcceleratorConfig struct");
    mojo::internal::Serialize<::media::mojom::VideoCodecProfile>(
        Traits::output_profile(input), &fragment->output_profile);
    decltype(Traits::bitrate(input)) in_bitrate = Traits::bitrate(input);
    mojo::internal::MessageFragment<decltype(fragment->bitrate)>
        bitrate_fragment(fragment.message());
    bitrate_fragment.Claim(&fragment->bitrate);
    mojo::internal::Serialize<::media::mojom::BitrateDataView>(
        in_bitrate, bitrate_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->bitrate.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null bitrate in VideoEncodeAcceleratorConfig struct");
    fragment->initial_framerate = Traits::initial_framerate(input);
    fragment->has_initial_framerate = Traits::has_initial_framerate(input);
    fragment->gop_length = Traits::gop_length(input);
    fragment->has_gop_length = Traits::has_gop_length(input);
    fragment->h264_output_level = Traits::h264_output_level(input);
    fragment->has_h264_output_level = Traits::has_h264_output_level(input);
    fragment->is_constrained_h264 = Traits::is_constrained_h264(input);
    mojo::internal::Serialize<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(
        Traits::storage_type(input), &fragment->storage_type);
    fragment->has_storage_type = Traits::has_storage_type(input);
    mojo::internal::Serialize<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(
        Traits::content_type(input), &fragment->content_type);
    decltype(Traits::spatial_layers(input)) in_spatial_layers = Traits::spatial_layers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->spatial_layers)::BaseType>
        spatial_layers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams spatial_layers_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::SpatialLayerDataView>>(
        in_spatial_layers, spatial_layers_fragment, &spatial_layers_validate_params);
    fragment->spatial_layers.Set(
        spatial_layers_fragment.is_null() ? nullptr : spatial_layers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->spatial_layers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null spatial_layers in VideoEncodeAcceleratorConfig struct");
    mojo::internal::Serialize<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode>(
        Traits::inter_layer_pred(input), &fragment->inter_layer_pred);
    fragment->require_low_delay = Traits::require_low_delay(input);
  }

  static bool Deserialize(::media::mojom::internal::VideoEncodeAcceleratorConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoEncodeAcceleratorConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::H264MetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::H264MetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::H264Metadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->temporal_idx = Traits::temporal_idx(input);
    fragment->layer_sync = Traits::layer_sync(input);
  }

  static bool Deserialize(::media::mojom::internal::H264Metadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::H264MetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::Vp8MetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::Vp8MetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::Vp8Metadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->non_reference = Traits::non_reference(input);
    fragment->temporal_idx = Traits::temporal_idx(input);
    fragment->layer_sync = Traits::layer_sync(input);
  }

  static bool Deserialize(::media::mojom::internal::Vp8Metadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::Vp8MetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::Vp9MetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::Vp9MetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::Vp9Metadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->inter_pic_predicted = Traits::inter_pic_predicted(input);
    fragment->temporal_up_switch = Traits::temporal_up_switch(input);
    fragment->referenced_by_upper_spatial_layers = Traits::referenced_by_upper_spatial_layers(input);
    fragment->reference_lower_spatial_layers = Traits::reference_lower_spatial_layers(input);
    fragment->end_of_picture = Traits::end_of_picture(input);
    fragment->temporal_idx = Traits::temporal_idx(input);
    fragment->spatial_idx = Traits::spatial_idx(input);
    decltype(Traits::spatial_layer_resolutions(input)) in_spatial_layer_resolutions = Traits::spatial_layer_resolutions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->spatial_layer_resolutions)::BaseType>
        spatial_layer_resolutions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams spatial_layer_resolutions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::gfx::mojom::SizeDataView>>(
        in_spatial_layer_resolutions, spatial_layer_resolutions_fragment, &spatial_layer_resolutions_validate_params);
    fragment->spatial_layer_resolutions.Set(
        spatial_layer_resolutions_fragment.is_null() ? nullptr : spatial_layer_resolutions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->spatial_layer_resolutions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null spatial_layer_resolutions in Vp9Metadata struct");
    decltype(Traits::p_diffs(input)) in_p_diffs = Traits::p_diffs(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->p_diffs)::BaseType>
        p_diffs_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams p_diffs_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_p_diffs, p_diffs_fragment, &p_diffs_validate_params);
    fragment->p_diffs.Set(
        p_diffs_fragment.is_null() ? nullptr : p_diffs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->p_diffs.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null p_diffs in Vp9Metadata struct");
  }

  static bool Deserialize(::media::mojom::internal::Vp9Metadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::Vp9MetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::Av1MetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::Av1MetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::Av1Metadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->inter_pic_predicted = Traits::inter_pic_predicted(input);
    fragment->switch_frame = Traits::switch_frame(input);
    fragment->end_of_picture = Traits::end_of_picture(input);
    fragment->temporal_idx = Traits::temporal_idx(input);
    fragment->spatial_idx = Traits::spatial_idx(input);
    decltype(Traits::spatial_layer_resolutions(input)) in_spatial_layer_resolutions = Traits::spatial_layer_resolutions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->spatial_layer_resolutions)::BaseType>
        spatial_layer_resolutions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams spatial_layer_resolutions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::gfx::mojom::SizeDataView>>(
        in_spatial_layer_resolutions, spatial_layer_resolutions_fragment, &spatial_layer_resolutions_validate_params);
    fragment->spatial_layer_resolutions.Set(
        spatial_layer_resolutions_fragment.is_null() ? nullptr : spatial_layer_resolutions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->spatial_layer_resolutions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null spatial_layer_resolutions in Av1Metadata struct");
    decltype(Traits::f_diffs(input)) in_f_diffs = Traits::f_diffs(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->f_diffs)::BaseType>
        f_diffs_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams f_diffs_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_f_diffs, f_diffs_fragment, &f_diffs_validate_params);
    fragment->f_diffs.Set(
        f_diffs_fragment.is_null() ? nullptr : f_diffs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->f_diffs.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null f_diffs in Av1Metadata struct");
  }

  static bool Deserialize(::media::mojom::internal::Av1Metadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::Av1MetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::BitstreamBufferMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::BitstreamBufferMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::BitstreamBufferMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->payload_size_bytes = Traits::payload_size_bytes(input);
    fragment->key_frame = Traits::key_frame(input);
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in BitstreamBufferMetadata struct");
    fragment->qp = Traits::qp(input);
    decltype(Traits::codec_metadata(input)) in_codec_metadata = Traits::codec_metadata(input);
    mojo::internal::MessageFragment<decltype(fragment->codec_metadata)>
        codec_metadata_fragment(fragment.message());
    codec_metadata_fragment.Claim(&fragment->codec_metadata);
    mojo::internal::Serialize<::media::mojom::CodecMetadataDataView>(
        in_codec_metadata, codec_metadata_fragment, true);
  }

  static bool Deserialize(::media::mojom::internal::BitstreamBufferMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::BitstreamBufferMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::BitrateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::media::mojom::BitrateDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::media::mojom::internal::Bitrate_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::media::mojom::BitrateDataView::Tag::kConstant: {
        decltype(Traits::constant(input))
            in_constant = Traits::constant(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_constant)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::ConstantBitrateDataView>(
            in_constant, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null constant in Bitrate union");
        fragment->data.f_constant.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::BitrateDataView::Tag::kVariable: {
        decltype(Traits::variable(input))
            in_variable = Traits::variable(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_variable)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::VariableBitrateDataView>(
            in_variable, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null variable in Bitrate union");
        fragment->data.f_variable.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::media::mojom::internal::Bitrate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::BitrateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::CodecMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::media::mojom::CodecMetadataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::media::mojom::internal::CodecMetadata_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::media::mojom::CodecMetadataDataView::Tag::kH264: {
        decltype(Traits::h264(input))
            in_h264 = Traits::h264(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_h264)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::H264MetadataDataView>(
            in_h264, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null h264 in CodecMetadata union");
        fragment->data.f_h264.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::CodecMetadataDataView::Tag::kVp8: {
        decltype(Traits::vp8(input))
            in_vp8 = Traits::vp8(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_vp8)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::Vp8MetadataDataView>(
            in_vp8, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null vp8 in CodecMetadata union");
        fragment->data.f_vp8.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::CodecMetadataDataView::Tag::kVp9: {
        decltype(Traits::vp9(input))
            in_vp9 = Traits::vp9(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_vp9)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::Vp9MetadataDataView>(
            in_vp9, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null vp9 in CodecMetadata union");
        fragment->data.f_vp9.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::CodecMetadataDataView::Tag::kAv1: {
        decltype(Traits::av1(input))
            in_av1 = Traits::av1(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_av1)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::Av1MetadataDataView>(
            in_av1, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null av1 in CodecMetadata union");
        fragment->data.f_av1.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::media::mojom::internal::CodecMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::CodecMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace media {
namespace mojom {

inline void VideoEncodeAcceleratorSupportedProfileDataView::GetMinResolutionDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->min_resolution.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetMaxResolutionDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->max_resolution.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetRateControlModesDataView(
    mojo::ArrayDataView<VideoEncodeAcceleratorSupportedRateControlMode>* output) {
  auto pointer = data_->rate_control_modes.Get();
  *output = mojo::ArrayDataView<VideoEncodeAcceleratorSupportedRateControlMode>(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetScalabilityModesDataView(
    mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>* output) {
  auto pointer = data_->scalability_modes.Get();
  *output = mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>(pointer, message_);
}




inline void VideoBitrateAllocationDataView::GetBitratesDataView(
    mojo::ArrayDataView<uint32_t>* output) {
  auto pointer = data_->bitrates.Get();
  *output = mojo::ArrayDataView<uint32_t>(pointer, message_);
}
inline void VideoBitrateAllocationDataView::GetVariableBitratePeakDataView(
    VariableBitratePeakDataView* output) {
  auto pointer = data_->variable_bitrate_peak.Get();
  *output = VariableBitratePeakDataView(pointer, message_);
}








inline void VideoEncodeAcceleratorConfigDataView::GetInputVisibleSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->input_visible_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorConfigDataView::GetBitrateDataView(
    BitrateDataView* output) {
  auto pointer = &data_->bitrate;
  *output = BitrateDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorConfigDataView::GetSpatialLayersDataView(
    mojo::ArrayDataView<SpatialLayerDataView>* output) {
  auto pointer = data_->spatial_layers.Get();
  *output = mojo::ArrayDataView<SpatialLayerDataView>(pointer, message_);
}






inline void Vp9MetadataDataView::GetSpatialLayerResolutionsDataView(
    mojo::ArrayDataView<::gfx::mojom::SizeDataView>* output) {
  auto pointer = data_->spatial_layer_resolutions.Get();
  *output = mojo::ArrayDataView<::gfx::mojom::SizeDataView>(pointer, message_);
}
inline void Vp9MetadataDataView::GetPDiffsDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->p_diffs.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void Av1MetadataDataView::GetSpatialLayerResolutionsDataView(
    mojo::ArrayDataView<::gfx::mojom::SizeDataView>* output) {
  auto pointer = data_->spatial_layer_resolutions.Get();
  *output = mojo::ArrayDataView<::gfx::mojom::SizeDataView>(pointer, message_);
}
inline void Av1MetadataDataView::GetFDiffsDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->f_diffs.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void BitstreamBufferMetadataDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void BitstreamBufferMetadataDataView::GetCodecMetadataDataView(
    CodecMetadataDataView* output) {
  auto pointer = &data_->codec_metadata;
  *output = CodecMetadataDataView(pointer, message_);
}


inline void BitrateDataView::GetConstantDataView(
    ConstantBitrateDataView* output) const {
  CHECK(is_constant());
  *output = ConstantBitrateDataView(data_->data.f_constant.Get(), message_);
}
inline void BitrateDataView::GetVariableDataView(
    VariableBitrateDataView* output) const {
  CHECK(is_variable());
  *output = VariableBitrateDataView(data_->data.f_variable.Get(), message_);
}

inline void CodecMetadataDataView::GetH264DataView(
    H264MetadataDataView* output) const {
  CHECK(is_h264());
  *output = H264MetadataDataView(data_->data.f_h264.Get(), message_);
}
inline void CodecMetadataDataView::GetVp8DataView(
    Vp8MetadataDataView* output) const {
  CHECK(is_vp8());
  *output = Vp8MetadataDataView(data_->data.f_vp8.Get(), message_);
}
inline void CodecMetadataDataView::GetVp9DataView(
    Vp9MetadataDataView* output) const {
  CHECK(is_vp9());
  *output = Vp9MetadataDataView(data_->data.f_vp9.Get(), message_);
}
inline void CodecMetadataDataView::GetAv1DataView(
    Av1MetadataDataView* output) const {
  CHECK(is_av1());
  *output = Av1MetadataDataView(data_->data.f_av1.Get(), message_);
}


}  // namespace mojom
}  // namespace media

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorConfig_ContentType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorConfig_ContentType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorConfig_InterLayerPredMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorConfig_StorageType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorConfig_StorageType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::VideoEncodeAccelerator_Error> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAccelerator_Error value);
};

} // namespace perfetto

#endif  // MEDIA_MOJO_MOJOM_VIDEO_ENCODE_ACCELERATOR_MOJOM_SHARED_H_