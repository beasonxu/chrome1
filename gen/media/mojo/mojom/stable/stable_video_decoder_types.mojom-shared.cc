// media/mojo/mojom/stable/stable_video_decoder_types.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-params-data.h"
namespace media {
namespace stable {
namespace mojom {

static NOINLINE const char* VideoCodecToStringHelper(VideoCodec value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCodec::kUnknown:
      return "kUnknown";
    case VideoCodec::kH264:
      return "kH264";
    case VideoCodec::kVC1:
      return "kVC1";
    case VideoCodec::kMPEG2:
      return "kMPEG2";
    case VideoCodec::kMPEG4:
      return "kMPEG4";
    case VideoCodec::kTheora:
      return "kTheora";
    case VideoCodec::kVP8:
      return "kVP8";
    case VideoCodec::kVP9:
      return "kVP9";
    case VideoCodec::kHEVC:
      return "kHEVC";
    case VideoCodec::kDolbyVision:
      return "kDolbyVision";
    case VideoCodec::kAV1:
      return "kAV1";
    default:
      return nullptr;
  }
}

std::string VideoCodecToString(VideoCodec value) {
  const char *str = VideoCodecToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCodec value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCodec value) {
  return os << VideoCodecToString(value);
}

static NOINLINE const char* VideoCodecProfileToStringHelper(VideoCodecProfile value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCodecProfile::kVideoCodecProfileUnknown:
      return "kVideoCodecProfileUnknown";
    case VideoCodecProfile::kH264ProfileMin:
      return "{kH264ProfileMin, kH264ProfileBaseline}";
    case VideoCodecProfile::kH264ProfileMain:
      return "kH264ProfileMain";
    case VideoCodecProfile::kH264ProfileExtended:
      return "kH264ProfileExtended";
    case VideoCodecProfile::kH264ProfileHigh:
      return "kH264ProfileHigh";
    case VideoCodecProfile::kH264ProfileHigh10:
      return "kH264ProfileHigh10";
    case VideoCodecProfile::kH264ProfileHigh422:
      return "kH264ProfileHigh422";
    case VideoCodecProfile::kH264ProfileHigh444Predictive:
      return "kH264ProfileHigh444Predictive";
    case VideoCodecProfile::kH264ProfileScalableBaseline:
      return "kH264ProfileScalableBaseline";
    case VideoCodecProfile::kH264ProfileScalableHigh:
      return "kH264ProfileScalableHigh";
    case VideoCodecProfile::kH264ProfileStereoHigh:
      return "kH264ProfileStereoHigh";
    case VideoCodecProfile::kH264ProfileMultiviewHigh:
      return "{kH264ProfileMultiviewHigh, kH264ProfileMax}";
    case VideoCodecProfile::kVP8ProfileMin:
      return "{kVP8ProfileMin, kVP8ProfileAny, kVP8ProfileMax}";
    case VideoCodecProfile::kVP9ProfileMin:
      return "{kVP9ProfileMin, kVP9Profile0}";
    case VideoCodecProfile::kVP9Profile1:
      return "kVP9Profile1";
    case VideoCodecProfile::kVP9Profile2:
      return "kVP9Profile2";
    case VideoCodecProfile::kVP9Profile3:
      return "{kVP9Profile3, kVP9ProfileMax}";
    case VideoCodecProfile::kHEVCProfileMin:
      return "{kHEVCProfileMin, kHEVCProfileMain}";
    case VideoCodecProfile::kHEVCProfileMain10:
      return "kHEVCProfileMain10";
    case VideoCodecProfile::kHEVCProfileMainStillPicture:
      return "{kHEVCProfileMainStillPicture, kHEVCProfileMax}";
    case VideoCodecProfile::kDolbyVisionProfile0:
      return "kDolbyVisionProfile0";
    case VideoCodecProfile::kDolbyVisionProfile4:
      return "kDolbyVisionProfile4";
    case VideoCodecProfile::kDolbyVisionProfile5:
      return "kDolbyVisionProfile5";
    case VideoCodecProfile::kDolbyVisionProfile7:
      return "kDolbyVisionProfile7";
    case VideoCodecProfile::kTheoraProfileMin:
      return "{kTheoraProfileMin, kTheoraProfileAny, kTheoraProfileMax}";
    case VideoCodecProfile::kAV1ProfileMin:
      return "{kAV1ProfileMin, kAV1ProfileMain}";
    case VideoCodecProfile::kAV1ProfileHigh:
      return "kAV1ProfileHigh";
    case VideoCodecProfile::kAV1ProfilePro:
      return "{kAV1ProfilePro, kAV1ProfileMax}";
    case VideoCodecProfile::kDolbyVisionProfile8:
      return "kDolbyVisionProfile8";
    case VideoCodecProfile::kDolbyVisionProfile9:
      return "kDolbyVisionProfile9";
    case VideoCodecProfile::kHEVCProfileExtMin:
      return "{kHEVCProfileExtMin, kHEVCProfileRext}";
    case VideoCodecProfile::kHEVCProfileHighThroughput:
      return "kHEVCProfileHighThroughput";
    case VideoCodecProfile::kHEVCProfileMultiviewMain:
      return "kHEVCProfileMultiviewMain";
    case VideoCodecProfile::kHEVCProfileScalableMain:
      return "kHEVCProfileScalableMain";
    case VideoCodecProfile::kHEVCProfile3dMain:
      return "kHEVCProfile3dMain";
    case VideoCodecProfile::kHEVCProfileScreenExtended:
      return "kHEVCProfileScreenExtended";
    case VideoCodecProfile::kHEVCProfileScalableRext:
      return "kHEVCProfileScalableRext";
    case VideoCodecProfile::kHEVCProfileHighThroughputScreenExtended:
      return "{kHEVCProfileHighThroughputScreenExtended, kHEVCProfileExtMax}";
    default:
      return nullptr;
  }
}

std::string VideoCodecProfileToString(VideoCodecProfile value) {
  const char *str = VideoCodecProfileToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCodecProfile value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCodecProfile value) {
  return os << VideoCodecProfileToString(value);
}

static NOINLINE const char* EncryptionSchemeToStringHelper(EncryptionScheme value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case EncryptionScheme::kUnencrypted:
      return "kUnencrypted";
    case EncryptionScheme::kCenc:
      return "kCenc";
    case EncryptionScheme::kCbcs:
      return "kCbcs";
    default:
      return nullptr;
  }
}

std::string EncryptionSchemeToString(EncryptionScheme value) {
  const char *str = EncryptionSchemeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown EncryptionScheme value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, EncryptionScheme value) {
  return os << EncryptionSchemeToString(value);
}

static NOINLINE const char* StatusCodeToStringHelper(StatusCode value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case StatusCode::kOk:
      return "kOk";
    case StatusCode::kAborted:
      return "kAborted";
    case StatusCode::kError:
      return "kError";
    default:
      return nullptr;
  }
}

std::string StatusCodeToString(StatusCode value) {
  const char *str = StatusCodeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown StatusCode value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, StatusCode value) {
  return os << StatusCodeToString(value);
}

static NOINLINE const char* VideoDecoderTypeToStringHelper(VideoDecoderType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoDecoderType::kUnknown:
      return "kUnknown";
    case VideoDecoderType::kVaapi:
      return "kVaapi";
    case VideoDecoderType::kVda:
      return "kVda";
    case VideoDecoderType::kV4L2:
      return "kV4L2";
    case VideoDecoderType::kTesting:
      return "kTesting";
    default:
      return nullptr;
  }
}

std::string VideoDecoderTypeToString(VideoDecoderType value) {
  const char *str = VideoDecoderTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoDecoderType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoDecoderType value) {
  return os << VideoDecoderTypeToString(value);
}

static NOINLINE const char* ColorSpacePrimaryIDToStringHelper(ColorSpacePrimaryID value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ColorSpacePrimaryID::kInvalid:
      return "kInvalid";
    case ColorSpacePrimaryID::kBT709:
      return "kBT709";
    case ColorSpacePrimaryID::kBT470M:
      return "kBT470M";
    case ColorSpacePrimaryID::kBT470BG:
      return "kBT470BG";
    case ColorSpacePrimaryID::kSMPTE170M:
      return "kSMPTE170M";
    case ColorSpacePrimaryID::kSMPTE240M:
      return "kSMPTE240M";
    case ColorSpacePrimaryID::kFilm:
      return "kFilm";
    case ColorSpacePrimaryID::kBT2020:
      return "kBT2020";
    case ColorSpacePrimaryID::kSMPTEST428_1:
      return "kSMPTEST428_1";
    case ColorSpacePrimaryID::kSMPTEST431_2:
      return "kSMPTEST431_2";
    case ColorSpacePrimaryID::kSMPTEST432_1:
      return "kSMPTEST432_1";
    case ColorSpacePrimaryID::kXYZ_D50:
      return "kXYZ_D50";
    case ColorSpacePrimaryID::kAdobeRGB:
      return "kAdobeRGB";
    case ColorSpacePrimaryID::kAppleGenericRGB:
      return "kAppleGenericRGB";
    case ColorSpacePrimaryID::kWideGamutColorSpin:
      return "kWideGamutColorSpin";
    case ColorSpacePrimaryID::kCustom:
      return "kCustom";
    default:
      return nullptr;
  }
}

std::string ColorSpacePrimaryIDToString(ColorSpacePrimaryID value) {
  const char *str = ColorSpacePrimaryIDToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ColorSpacePrimaryID value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ColorSpacePrimaryID value) {
  return os << ColorSpacePrimaryIDToString(value);
}

static NOINLINE const char* ColorSpaceTransferIDToStringHelper(ColorSpaceTransferID value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ColorSpaceTransferID::kInvalid:
      return "kInvalid";
    case ColorSpaceTransferID::kBT709:
      return "kBT709";
    case ColorSpaceTransferID::kBT709Apple:
      return "kBT709Apple";
    case ColorSpaceTransferID::kGamma18:
      return "kGamma18";
    case ColorSpaceTransferID::kGamma22:
      return "kGamma22";
    case ColorSpaceTransferID::kGamma24:
      return "kGamma24";
    case ColorSpaceTransferID::kGamma28:
      return "kGamma28";
    case ColorSpaceTransferID::kSMPTE170M:
      return "kSMPTE170M";
    case ColorSpaceTransferID::kSMPTE240M:
      return "kSMPTE240M";
    case ColorSpaceTransferID::kLinear:
      return "kLinear";
    case ColorSpaceTransferID::kLog:
      return "kLog";
    case ColorSpaceTransferID::kLogSqrt:
      return "kLogSqrt";
    case ColorSpaceTransferID::kIEC61966_2_4:
      return "kIEC61966_2_4";
    case ColorSpaceTransferID::kBT1361_ECG:
      return "kBT1361_ECG";
    case ColorSpaceTransferID::kIEC61966_2_1:
      return "kIEC61966_2_1";
    case ColorSpaceTransferID::kBT2020_10:
      return "kBT2020_10";
    case ColorSpaceTransferID::kBT2020_12:
      return "kBT2020_12";
    case ColorSpaceTransferID::kSMPTEST2084:
      return "kSMPTEST2084";
    case ColorSpaceTransferID::kSMPTEST428_1:
      return "kSMPTEST428_1";
    case ColorSpaceTransferID::kARIB_STD_B67:
      return "kARIB_STD_B67";
    case ColorSpaceTransferID::kIEC61966_2_1_HDR:
      return "kIEC61966_2_1_HDR";
    case ColorSpaceTransferID::kLinearHDR:
      return "kLinearHDR";
    case ColorSpaceTransferID::kCustom:
      return "kCustom";
    case ColorSpaceTransferID::kCustomHDR:
      return "kCustomHDR";
    case ColorSpaceTransferID::kPiecewiseHDR:
      return "kPiecewiseHDR";
    case ColorSpaceTransferID::kScrgbLinear80Nits:
      return "kScrgbLinear80Nits";
    default:
      return nullptr;
  }
}

std::string ColorSpaceTransferIDToString(ColorSpaceTransferID value) {
  const char *str = ColorSpaceTransferIDToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ColorSpaceTransferID value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ColorSpaceTransferID value) {
  return os << ColorSpaceTransferIDToString(value);
}

static NOINLINE const char* ColorSpaceMatrixIDToStringHelper(ColorSpaceMatrixID value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ColorSpaceMatrixID::kInvalid:
      return "kInvalid";
    case ColorSpaceMatrixID::kRGB:
      return "kRGB";
    case ColorSpaceMatrixID::kBT709:
      return "kBT709";
    case ColorSpaceMatrixID::kFCC:
      return "kFCC";
    case ColorSpaceMatrixID::kBT470BG:
      return "kBT470BG";
    case ColorSpaceMatrixID::kSMPTE170M:
      return "kSMPTE170M";
    case ColorSpaceMatrixID::kSMPTE240M:
      return "kSMPTE240M";
    case ColorSpaceMatrixID::kYCOCG:
      return "kYCOCG";
    case ColorSpaceMatrixID::kBT2020_NCL:
      return "kBT2020_NCL";
    case ColorSpaceMatrixID::kBT2020_CL:
      return "kBT2020_CL";
    case ColorSpaceMatrixID::kYDZDX:
      return "kYDZDX";
    case ColorSpaceMatrixID::kGBR:
      return "kGBR";
    default:
      return nullptr;
  }
}

std::string ColorSpaceMatrixIDToString(ColorSpaceMatrixID value) {
  const char *str = ColorSpaceMatrixIDToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ColorSpaceMatrixID value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ColorSpaceMatrixID value) {
  return os << ColorSpaceMatrixIDToString(value);
}

static NOINLINE const char* ColorSpaceRangeIDToStringHelper(ColorSpaceRangeID value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ColorSpaceRangeID::kInvalid:
      return "kInvalid";
    case ColorSpaceRangeID::kLimited:
      return "kLimited";
    case ColorSpaceRangeID::kFull:
      return "kFull";
    case ColorSpaceRangeID::kDerived:
      return "kDerived";
    default:
      return nullptr;
  }
}

std::string ColorSpaceRangeIDToString(ColorSpaceRangeID value) {
  const char *str = ColorSpaceRangeIDToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ColorSpaceRangeID value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ColorSpaceRangeID value) {
  return os << ColorSpaceRangeIDToString(value);
}

static NOINLINE const char* VideoPixelFormatToStringHelper(VideoPixelFormat value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoPixelFormat::kPixelFormatUnknown:
      return "kPixelFormatUnknown";
    case VideoPixelFormat::kPixelFormatI420:
      return "kPixelFormatI420";
    case VideoPixelFormat::kPixelFormatYV12:
      return "kPixelFormatYV12";
    case VideoPixelFormat::kPixelFormatI422:
      return "kPixelFormatI422";
    case VideoPixelFormat::kPixelFormatI420A:
      return "kPixelFormatI420A";
    case VideoPixelFormat::kPixelFormatI444:
      return "kPixelFormatI444";
    case VideoPixelFormat::kPixelFormatNV12:
      return "kPixelFormatNV12";
    case VideoPixelFormat::kPixelFormatNV21:
      return "kPixelFormatNV21";
    case VideoPixelFormat::kPixelFormatUYVY:
      return "kPixelFormatUYVY";
    case VideoPixelFormat::kPixelFormatYUY2:
      return "kPixelFormatYUY2";
    case VideoPixelFormat::kPixelFormatARGB:
      return "kPixelFormatARGB";
    case VideoPixelFormat::kPixelFormatXRGB:
      return "kPixelFormatXRGB";
    case VideoPixelFormat::kPixelFormatRGB24:
      return "kPixelFormatRGB24";
    case VideoPixelFormat::kPixelFormatMJPEG:
      return "kPixelFormatMJPEG";
    case VideoPixelFormat::kPixelFormatYUV420P9:
      return "kPixelFormatYUV420P9";
    case VideoPixelFormat::kPixelFormatYUV420P10:
      return "kPixelFormatYUV420P10";
    case VideoPixelFormat::kPixelFormatYUV422P9:
      return "kPixelFormatYUV422P9";
    case VideoPixelFormat::kPixelFormatYUV422P10:
      return "kPixelFormatYUV422P10";
    case VideoPixelFormat::kPixelFormatYUV444P9:
      return "kPixelFormatYUV444P9";
    case VideoPixelFormat::kPixelFormatYUV444P10:
      return "kPixelFormatYUV444P10";
    case VideoPixelFormat::kPixelFormatYUV420P12:
      return "kPixelFormatYUV420P12";
    case VideoPixelFormat::kPixelFormatYUV422P12:
      return "kPixelFormatYUV422P12";
    case VideoPixelFormat::kPixelFormatYUV444P12:
      return "kPixelFormatYUV444P12";
    case VideoPixelFormat::kPixelFormatY16:
      return "kPixelFormatY16";
    case VideoPixelFormat::kPixelFormatABGR:
      return "kPixelFormatABGR";
    case VideoPixelFormat::kPixelFormatXBGR:
      return "kPixelFormatXBGR";
    case VideoPixelFormat::kPixelFormatP016LE:
      return "kPixelFormatP016LE";
    case VideoPixelFormat::kPixelFormatXR30:
      return "kPixelFormatXR30";
    case VideoPixelFormat::kPixelFormatXB30:
      return "kPixelFormatXB30";
    case VideoPixelFormat::kPixelFormatBGRA:
      return "kPixelFormatBGRA";
    case VideoPixelFormat::kPixelFormatRGBAF16:
      return "kPixelFormatRGBAF16";
    case VideoPixelFormat::kPixelFormatI422A:
      return "kPixelFormatI422A";
    case VideoPixelFormat::kPixelFormatI444A:
      return "kPixelFormatI444A";
    case VideoPixelFormat::kPixelFormatYUV420AP10:
      return "kPixelFormatYUV420AP10";
    case VideoPixelFormat::kPixelFormatYUV422AP10:
      return "kPixelFormatYUV422AP10";
    case VideoPixelFormat::kPixelFormatYUV444AP10:
      return "kPixelFormatYUV444AP10";
    default:
      return nullptr;
  }
}

std::string VideoPixelFormatToString(VideoPixelFormat value) {
  const char *str = VideoPixelFormatToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoPixelFormat value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoPixelFormat value) {
  return os << VideoPixelFormatToString(value);
}

static NOINLINE const char* WaitingReasonToStringHelper(WaitingReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case WaitingReason::kNoCdm:
      return "kNoCdm";
    case WaitingReason::kNoDecryptionKey:
      return "kNoDecryptionKey";
    case WaitingReason::kDecoderStateLost:
      return "kDecoderStateLost";
    default:
      return nullptr;
  }
}

std::string WaitingReasonToString(WaitingReason value) {
  const char *str = WaitingReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown WaitingReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, WaitingReason value) {
  return os << WaitingReasonToString(value);
}

static NOINLINE const char* DecryptStatusToStringHelper(DecryptStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case DecryptStatus::kSuccess:
      return "kSuccess";
    case DecryptStatus::kNoKey:
      return "kNoKey";
    case DecryptStatus::kFailure:
      return "kFailure";
    default:
      return nullptr;
  }
}

std::string DecryptStatusToString(DecryptStatus value) {
  const char *str = DecryptStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown DecryptStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, DecryptStatus value) {
  return os << DecryptStatusToString(value);
}

static NOINLINE const char* CdmContextEventToStringHelper(CdmContextEvent value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case CdmContextEvent::kHasAdditionalUsableKey:
      return "kHasAdditionalUsableKey";
    case CdmContextEvent::kHardwareContextReset:
      return "kHardwareContextReset";
    default:
      return nullptr;
  }
}

std::string CdmContextEventToString(CdmContextEvent value) {
  const char *str = CdmContextEventToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown CdmContextEvent value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, CdmContextEvent value) {
  return os << CdmContextEventToString(value);
}

static NOINLINE const char* MediaLogRecord_TypeToStringHelper(MediaLogRecord_Type value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case MediaLogRecord_Type::kMessage:
      return "kMessage";
    case MediaLogRecord_Type::kMediaPropertyChange:
      return "kMediaPropertyChange";
    case MediaLogRecord_Type::kMediaEventTriggered:
      return "kMediaEventTriggered";
    case MediaLogRecord_Type::kMediaStatus:
      return "kMediaStatus";
    default:
      return nullptr;
  }
}

std::string MediaLogRecord_TypeToString(MediaLogRecord_Type value) {
  const char *str = MediaLogRecord_TypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown MediaLogRecord_Type value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, MediaLogRecord_Type value) {
  return os << MediaLogRecord_TypeToString(value);
}

namespace internal {
// static
bool VideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context,
    bool inlined) {
  if (!data) {
    DCHECK(!inlined);
    return true;
  }

  // If it is inlined, the alignment is already enforced by its enclosing
  // object. We don't have to validate that.
  DCHECK(!inlined || mojo::internal::IsAligned(data));

  if (!inlined &&
      !mojo::internal::ValidateNonInlinedUnionHeaderAndClaimMemory(
          data, validation_context)) {
    return false;
  }

  const VideoFrameData_Data* object = static_cast<const VideoFrameData_Data*>(data);

  if (inlined && object->is_null())
    return true;

  switch (object->tag) {

    case VideoFrameData_Tag::kEosData: {

      if (!mojo::internal::ValidatePointerNonNullable(
              object->data.f_eos_data, 1, validation_context)) {
        return false;
      }
      if (!mojo::internal::ValidateStruct(object->data.f_eos_data, validation_context))
        return false;
      return true;
    }
    case VideoFrameData_Tag::kGpuMemoryBufferData: {

      if (!mojo::internal::ValidatePointerNonNullable(
              object->data.f_gpu_memory_buffer_data, 2, validation_context)) {
        return false;
      }
      if (!mojo::internal::ValidateStruct(object->data.f_gpu_memory_buffer_data, validation_context))
        return false;
      return true;
    }
    default: {

      ReportValidationError(
          validation_context,
          mojo::internal::VALIDATION_ERROR_UNKNOWN_UNION_TAG,
          "unknown tag in VideoFrameData");
      return false;
    }
  }
}


// static
bool SubsampleEntry_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const SubsampleEntry_Data* object =
      static_cast<const SubsampleEntry_Data*>(data);

  return true;
}

SubsampleEntry_Data::SubsampleEntry_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool DecryptConfig_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const DecryptConfig_Data* object =
      static_cast<const DecryptConfig_Data*>(data);


  if (!::media::stable::mojom::internal::EncryptionScheme_Data
        ::Validate(object->encryption_scheme, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->key_id, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams key_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->key_id, validation_context,
                                         &key_id_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->iv, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams iv_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->iv, validation_context,
                                         &iv_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->subsamples, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams subsamples_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->subsamples, validation_context,
                                         &subsamples_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->encryption_pattern, validation_context))
    return false;

  return true;
}

DecryptConfig_Data::DecryptConfig_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ColorVolumeMetadata_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const ColorVolumeMetadata_Data* object =
      static_cast<const ColorVolumeMetadata_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->primary_r, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->primary_r, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->primary_g, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->primary_g, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->primary_b, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->primary_b, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->white_point, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->white_point, validation_context))
    return false;

  return true;
}

ColorVolumeMetadata_Data::ColorVolumeMetadata_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool HDRMetadata_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const HDRMetadata_Data* object =
      static_cast<const HDRMetadata_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->color_volume_metadata, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->color_volume_metadata, validation_context))
    return false;

  return true;
}

HDRMetadata_Data::HDRMetadata_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoDecoderConfig_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 80, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoDecoderConfig_Data* object =
      static_cast<const VideoDecoderConfig_Data*>(data);


  if (!::media::stable::mojom::internal::VideoCodec_Data
        ::Validate(object->codec, validation_context))
    return false;


  if (!::media::stable::mojom::internal::VideoCodecProfile_Data
        ::Validate(object->profile, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->coded_size, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->coded_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->visible_rect, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->visible_rect, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->natural_size, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->natural_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->extra_data, 8, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams extra_data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->extra_data, validation_context,
                                         &extra_data_validate_params)) {
    return false;
  }


  if (!::media::stable::mojom::internal::EncryptionScheme_Data
        ::Validate(object->encryption_scheme, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->color_space_info, 10, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->color_space_info, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->hdr_metadata, validation_context))
    return false;

  return true;
}

VideoDecoderConfig_Data::VideoDecoderConfig_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool SupportedVideoDecoderConfig_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 40, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const SupportedVideoDecoderConfig_Data* object =
      static_cast<const SupportedVideoDecoderConfig_Data*>(data);


  if (!::media::stable::mojom::internal::VideoCodecProfile_Data
        ::Validate(object->profile_min, validation_context))
    return false;


  if (!::media::stable::mojom::internal::VideoCodecProfile_Data
        ::Validate(object->profile_max, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->coded_size_min, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->coded_size_min, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->coded_size_max, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->coded_size_max, validation_context))
    return false;

  return true;
}

SupportedVideoDecoderConfig_Data::SupportedVideoDecoderConfig_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool StatusData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 64, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const StatusData_Data* object =
      static_cast<const StatusData_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->group, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams group_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->group, validation_context,
                                         &group_validate_params)) {
    return false;
  }


  if (!::media::stable::mojom::internal::StatusCode_Data
        ::Validate(object->code, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->message, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams message_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->message, validation_context,
                                         &message_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->frames, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams frames_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->frames, validation_context,
                                         &frames_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->cause, validation_context))
    return false;

  if (!mojo::internal::ValidateInlinedUnionNonNullable(
          object->data, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateInlinedUnion(object->data, validation_context))
    return false;

  return true;
}

StatusData_Data::StatusData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool Status_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const Status_Data* object =
      static_cast<const Status_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->internal, validation_context))
    return false;

  return true;
}

Status_Data::Status_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool DecoderBuffer_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 64, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const DecoderBuffer_Data* object =
      static_cast<const DecoderBuffer_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->timestamp, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->timestamp, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->duration, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->duration, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->side_data, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams side_data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->side_data, validation_context,
                                         &side_data_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->decrypt_config, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->front_discard, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->front_discard, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->back_discard, 9, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->back_discard, validation_context))
    return false;

  return true;
}

DecoderBuffer_Data::DecoderBuffer_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ColorSpace_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 40, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const ColorSpace_Data* object =
      static_cast<const ColorSpace_Data*>(data);


  if (!::media::stable::mojom::internal::ColorSpacePrimaryID_Data
        ::Validate(object->primaries, validation_context))
    return false;


  if (!::media::stable::mojom::internal::ColorSpaceTransferID_Data
        ::Validate(object->transfer, validation_context))
    return false;


  if (!::media::stable::mojom::internal::ColorSpaceMatrixID_Data
        ::Validate(object->matrix, validation_context))
    return false;


  if (!::media::stable::mojom::internal::ColorSpaceRangeID_Data
        ::Validate(object->range, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->custom_primary_matrix, 5, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams custom_primary_matrix_validate_params(
      9, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->custom_primary_matrix, validation_context,
                                         &custom_primary_matrix_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->transfer_params, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams transfer_params_validate_params(
      7, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->transfer_params, validation_context,
                                         &transfer_params_validate_params)) {
    return false;
  }

  return true;
}

ColorSpace_Data::ColorSpace_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool EosVideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 8, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const EosVideoFrameData_Data* object =
      static_cast<const EosVideoFrameData_Data*>(data);

  return true;
}

EosVideoFrameData_Data::EosVideoFrameData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool NativeGpuMemoryBufferHandle_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const NativeGpuMemoryBufferHandle_Data* object =
      static_cast<const NativeGpuMemoryBufferHandle_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->id, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->id, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->platform_handle, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->platform_handle, validation_context))
    return false;

  return true;
}

NativeGpuMemoryBufferHandle_Data::NativeGpuMemoryBufferHandle_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool GpuMemoryBufferVideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const GpuMemoryBufferVideoFrameData_Data* object =
      static_cast<const GpuMemoryBufferVideoFrameData_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->gpu_memory_buffer_handle, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->gpu_memory_buffer_handle, validation_context))
    return false;

  return true;
}

GpuMemoryBufferVideoFrameData_Data::GpuMemoryBufferVideoFrameData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoFrameMetadata_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoFrameMetadata_Data* object =
      static_cast<const VideoFrameMetadata_Data*>(data);

  return true;
}

VideoFrameMetadata_Data::VideoFrameMetadata_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoFrame_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 88, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoFrame_Data* object =
      static_cast<const VideoFrame_Data*>(data);


  if (!::media::stable::mojom::internal::VideoPixelFormat_Data
        ::Validate(object->format, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->coded_size, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->coded_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->visible_rect, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->visible_rect, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->natural_size, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->natural_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->timestamp, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->timestamp, validation_context))
    return false;

  if (!mojo::internal::ValidateInlinedUnionNonNullable(
          object->data, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateInlinedUnion(object->data, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->metadata, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->metadata, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->color_space, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->color_space, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->hdr_metadata, validation_context))
    return false;

  return true;
}

VideoFrame_Data::VideoFrame_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MediaLogRecord_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 32, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const MediaLogRecord_Data* object =
      static_cast<const MediaLogRecord_Data*>(data);


  if (!::media::stable::mojom::internal::MediaLogRecord_Type_Data
        ::Validate(object->type, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->params, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->params, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->time, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->time, validation_context))
    return false;

  return true;
}

MediaLogRecord_Data::MediaLogRecord_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace stable
}  // namespace media

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::VideoCodec>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::VideoCodec value) {
  return std::move(context).WriteString(::media::stable::mojom::VideoCodecToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::VideoCodecProfile>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::VideoCodecProfile value) {
  return std::move(context).WriteString(::media::stable::mojom::VideoCodecProfileToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::EncryptionScheme>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::EncryptionScheme value) {
  return std::move(context).WriteString(::media::stable::mojom::EncryptionSchemeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::StatusCode>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::StatusCode value) {
  return std::move(context).WriteString(::media::stable::mojom::StatusCodeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::VideoDecoderType>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::VideoDecoderType value) {
  return std::move(context).WriteString(::media::stable::mojom::VideoDecoderTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::ColorSpacePrimaryID>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::ColorSpacePrimaryID value) {
  return std::move(context).WriteString(::media::stable::mojom::ColorSpacePrimaryIDToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::ColorSpaceTransferID>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::ColorSpaceTransferID value) {
  return std::move(context).WriteString(::media::stable::mojom::ColorSpaceTransferIDToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::ColorSpaceMatrixID>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::ColorSpaceMatrixID value) {
  return std::move(context).WriteString(::media::stable::mojom::ColorSpaceMatrixIDToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::ColorSpaceRangeID>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::ColorSpaceRangeID value) {
  return std::move(context).WriteString(::media::stable::mojom::ColorSpaceRangeIDToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::VideoPixelFormat>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::VideoPixelFormat value) {
  return std::move(context).WriteString(::media::stable::mojom::VideoPixelFormatToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::WaitingReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::WaitingReason value) {
  return std::move(context).WriteString(::media::stable::mojom::WaitingReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::DecryptStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::DecryptStatus value) {
  return std::move(context).WriteString(::media::stable::mojom::DecryptStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::CdmContextEvent>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::CdmContextEvent value) {
  return std::move(context).WriteString(::media::stable::mojom::CdmContextEventToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::stable::mojom::MediaLogRecord_Type>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::stable::mojom::MediaLogRecord_Type value) {
  return std::move(context).WriteString(::media::stable::mojom::MediaLogRecord_TypeToString(value));
}

} // namespace perfetto