// media/mojo/mojom/stable/stable_video_decoder_types.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_SHARED_H_
#define MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-shared-internal.h"
#include "media/mojo/mojom/encryption_pattern.mojom-shared.h"
#include "media/mojo/mojom/stable/native_pixmap_handle.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/mojom/base/values.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/buffer_types.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace media {
namespace stable {
namespace mojom {
class SubsampleEntryDataView;

class DecryptConfigDataView;

class ColorVolumeMetadataDataView;

class HDRMetadataDataView;

class VideoDecoderConfigDataView;

class SupportedVideoDecoderConfigDataView;

class StatusDataDataView;

class StatusDataView;

class DecoderBufferDataView;

class ColorSpaceDataView;

class EosVideoFrameDataDataView;

class NativeGpuMemoryBufferHandleDataView;

class GpuMemoryBufferVideoFrameDataDataView;

class VideoFrameMetadataDataView;

class VideoFrameDataView;

class MediaLogRecordDataView;

class VideoFrameDataDataView;


}  // namespace mojom
}  // namespace stable
}  // namespace media

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::media::stable::mojom::SubsampleEntryDataView> {
  using Data = ::media::stable::mojom::internal::SubsampleEntry_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::DecryptConfigDataView> {
  using Data = ::media::stable::mojom::internal::DecryptConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::ColorVolumeMetadataDataView> {
  using Data = ::media::stable::mojom::internal::ColorVolumeMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::HDRMetadataDataView> {
  using Data = ::media::stable::mojom::internal::HDRMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::VideoDecoderConfigDataView> {
  using Data = ::media::stable::mojom::internal::VideoDecoderConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::SupportedVideoDecoderConfigDataView> {
  using Data = ::media::stable::mojom::internal::SupportedVideoDecoderConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::StatusDataDataView> {
  using Data = ::media::stable::mojom::internal::StatusData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::StatusDataView> {
  using Data = ::media::stable::mojom::internal::Status_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::DecoderBufferDataView> {
  using Data = ::media::stable::mojom::internal::DecoderBuffer_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::ColorSpaceDataView> {
  using Data = ::media::stable::mojom::internal::ColorSpace_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::EosVideoFrameDataDataView> {
  using Data = ::media::stable::mojom::internal::EosVideoFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::NativeGpuMemoryBufferHandleDataView> {
  using Data = ::media::stable::mojom::internal::NativeGpuMemoryBufferHandle_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::GpuMemoryBufferVideoFrameDataDataView> {
  using Data = ::media::stable::mojom::internal::GpuMemoryBufferVideoFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::VideoFrameMetadataDataView> {
  using Data = ::media::stable::mojom::internal::VideoFrameMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::VideoFrameDataView> {
  using Data = ::media::stable::mojom::internal::VideoFrame_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::MediaLogRecordDataView> {
  using Data = ::media::stable::mojom::internal::MediaLogRecord_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::stable::mojom::VideoFrameDataDataView> {
  using Data = ::media::stable::mojom::internal::VideoFrameData_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace media {
namespace stable {
namespace mojom {


enum class VideoCodec : int32_t {
  
  kUnknown = 0,
  
  kH264 = 1,
  
  kVC1 = 2,
  
  kMPEG2 = 3,
  
  kMPEG4 = 4,
  
  kTheora = 5,
  
  kVP8 = 6,
  
  kVP9 = 7,
  
  kHEVC = 8,
  
  kDolbyVision = 9,
  
  kAV1 = 10,
  kMinValue = 0,
  kMaxValue = 10,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, VideoCodec value);
inline bool IsKnownEnumValue(VideoCodec value) {
  return internal::VideoCodec_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline VideoCodec ToKnownEnumValue(VideoCodec value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return VideoCodec::kDefaultValue;
}


enum class VideoCodecProfile : int32_t {
  
  kVideoCodecProfileUnknown = -1,
  
  kH264ProfileMin = 0,
  
  kH264ProfileBaseline = 0,
  
  kH264ProfileMain = 1,
  
  kH264ProfileExtended = 2,
  
  kH264ProfileHigh = 3,
  
  kH264ProfileHigh10 = 4,
  
  kH264ProfileHigh422 = 5,
  
  kH264ProfileHigh444Predictive = 6,
  
  kH264ProfileScalableBaseline = 7,
  
  kH264ProfileScalableHigh = 8,
  
  kH264ProfileStereoHigh = 9,
  
  kH264ProfileMultiviewHigh = 10,
  
  kH264ProfileMax = 10,
  
  kVP8ProfileMin = 11,
  
  kVP8ProfileAny = 11,
  
  kVP8ProfileMax = 11,
  
  kVP9ProfileMin = 12,
  
  kVP9Profile0 = 12,
  
  kVP9Profile1 = 13,
  
  kVP9Profile2 = 14,
  
  kVP9Profile3 = 15,
  
  kVP9ProfileMax = 15,
  
  kHEVCProfileMin = 16,
  
  kHEVCProfileMain = 16,
  
  kHEVCProfileMain10 = 17,
  
  kHEVCProfileMainStillPicture = 18,
  
  kHEVCProfileMax = 18,
  
  kDolbyVisionProfile0 = 19,
  
  kDolbyVisionProfile4 = 20,
  
  kDolbyVisionProfile5 = 21,
  
  kDolbyVisionProfile7 = 22,
  
  kTheoraProfileMin = 23,
  
  kTheoraProfileAny = 23,
  
  kTheoraProfileMax = 23,
  
  kAV1ProfileMin = 24,
  
  kAV1ProfileMain = 24,
  
  kAV1ProfileHigh = 25,
  
  kAV1ProfilePro = 26,
  
  kAV1ProfileMax = 26,
  
  kDolbyVisionProfile8 = 27,
  
  kDolbyVisionProfile9 = 28,
  
  kHEVCProfileExtMin = 29,
  
  kHEVCProfileRext = 29,
  
  kHEVCProfileHighThroughput = 30,
  
  kHEVCProfileMultiviewMain = 31,
  
  kHEVCProfileScalableMain = 32,
  
  kHEVCProfile3dMain = 33,
  
  kHEVCProfileScreenExtended = 34,
  
  kHEVCProfileScalableRext = 35,
  
  kHEVCProfileHighThroughputScreenExtended = 36,
  
  kHEVCProfileExtMax = 36,
  kMinValue = -1,
  kMaxValue = 36,
  kDefaultValue = -1
};

 std::ostream& operator<<(std::ostream& os, VideoCodecProfile value);
inline bool IsKnownEnumValue(VideoCodecProfile value) {
  return internal::VideoCodecProfile_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline VideoCodecProfile ToKnownEnumValue(VideoCodecProfile value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return VideoCodecProfile::kDefaultValue;
}


enum class EncryptionScheme : int32_t {
  
  kUnencrypted = 0,
  
  kCenc = 1,
  
  kCbcs = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, EncryptionScheme value);
inline bool IsKnownEnumValue(EncryptionScheme value) {
  return internal::EncryptionScheme_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline EncryptionScheme ToKnownEnumValue(EncryptionScheme value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return EncryptionScheme::kDefaultValue;
}


enum class StatusCode : int32_t {
  
  kOk = 0,
  
  kAborted = 1,
  
  kError = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 2
};

 std::ostream& operator<<(std::ostream& os, StatusCode value);
inline bool IsKnownEnumValue(StatusCode value) {
  return internal::StatusCode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline StatusCode ToKnownEnumValue(StatusCode value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return StatusCode::kDefaultValue;
}


enum class VideoDecoderType : int32_t {
  
  kUnknown = 0,
  
  kVaapi = 1,
  
  kVda = 2,
  
  kV4L2 = 3,
  
  kTesting = 4,
  kMinValue = 0,
  kMaxValue = 4,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, VideoDecoderType value);
inline bool IsKnownEnumValue(VideoDecoderType value) {
  return internal::VideoDecoderType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline VideoDecoderType ToKnownEnumValue(VideoDecoderType value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return VideoDecoderType::kDefaultValue;
}


enum class ColorSpacePrimaryID : int32_t {
  
  kInvalid = 0,
  
  kBT709 = 1,
  
  kBT470M = 2,
  
  kBT470BG = 3,
  
  kSMPTE170M = 4,
  
  kSMPTE240M = 5,
  
  kFilm = 6,
  
  kBT2020 = 7,
  
  kSMPTEST428_1 = 8,
  
  kSMPTEST431_2 = 9,
  
  kSMPTEST432_1 = 10,
  
  kXYZ_D50 = 11,
  
  kAdobeRGB = 12,
  
  kAppleGenericRGB = 13,
  
  kWideGamutColorSpin = 14,
  
  kCustom = 15,
  kMinValue = 0,
  kMaxValue = 15,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, ColorSpacePrimaryID value);
inline bool IsKnownEnumValue(ColorSpacePrimaryID value) {
  return internal::ColorSpacePrimaryID_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline ColorSpacePrimaryID ToKnownEnumValue(ColorSpacePrimaryID value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return ColorSpacePrimaryID::kDefaultValue;
}


enum class ColorSpaceTransferID : int32_t {
  
  kInvalid = 0,
  
  kBT709 = 1,
  
  kBT709Apple = 2,
  
  kGamma18 = 3,
  
  kGamma22 = 4,
  
  kGamma24 = 5,
  
  kGamma28 = 6,
  
  kSMPTE170M = 7,
  
  kSMPTE240M = 8,
  
  kLinear = 9,
  
  kLog = 10,
  
  kLogSqrt = 11,
  
  kIEC61966_2_4 = 12,
  
  kBT1361_ECG = 13,
  
  kIEC61966_2_1 = 14,
  
  kBT2020_10 = 15,
  
  kBT2020_12 = 16,
  
  kSMPTEST2084 = 17,
  
  kSMPTEST428_1 = 18,
  
  kARIB_STD_B67 = 19,
  
  kIEC61966_2_1_HDR = 20,
  
  kLinearHDR = 21,
  
  kCustom = 22,
  
  kCustomHDR = 23,
  
  kPiecewiseHDR = 24,
  
  kScrgbLinear80Nits = 25,
  kMinValue = 0,
  kMaxValue = 25,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, ColorSpaceTransferID value);
inline bool IsKnownEnumValue(ColorSpaceTransferID value) {
  return internal::ColorSpaceTransferID_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline ColorSpaceTransferID ToKnownEnumValue(ColorSpaceTransferID value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return ColorSpaceTransferID::kDefaultValue;
}


enum class ColorSpaceMatrixID : int32_t {
  
  kInvalid = 0,
  
  kRGB = 1,
  
  kBT709 = 2,
  
  kFCC = 3,
  
  kBT470BG = 4,
  
  kSMPTE170M = 5,
  
  kSMPTE240M = 6,
  
  kYCOCG = 7,
  
  kBT2020_NCL = 8,
  
  kBT2020_CL = 9,
  
  kYDZDX = 10,
  
  kGBR = 11,
  kMinValue = 0,
  kMaxValue = 11,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, ColorSpaceMatrixID value);
inline bool IsKnownEnumValue(ColorSpaceMatrixID value) {
  return internal::ColorSpaceMatrixID_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline ColorSpaceMatrixID ToKnownEnumValue(ColorSpaceMatrixID value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return ColorSpaceMatrixID::kDefaultValue;
}


enum class ColorSpaceRangeID : int32_t {
  
  kInvalid = 0,
  
  kLimited = 1,
  
  kFull = 2,
  
  kDerived = 3,
  kMinValue = 0,
  kMaxValue = 3,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, ColorSpaceRangeID value);
inline bool IsKnownEnumValue(ColorSpaceRangeID value) {
  return internal::ColorSpaceRangeID_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline ColorSpaceRangeID ToKnownEnumValue(ColorSpaceRangeID value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return ColorSpaceRangeID::kDefaultValue;
}


enum class VideoPixelFormat : int32_t {
  
  kPixelFormatUnknown = 0,
  
  kPixelFormatI420 = 1,
  
  kPixelFormatYV12 = 2,
  
  kPixelFormatI422 = 3,
  
  kPixelFormatI420A = 4,
  
  kPixelFormatI444 = 5,
  
  kPixelFormatNV12 = 6,
  
  kPixelFormatNV21 = 7,
  
  kPixelFormatUYVY = 8,
  
  kPixelFormatYUY2 = 9,
  
  kPixelFormatARGB = 10,
  
  kPixelFormatXRGB = 11,
  
  kPixelFormatRGB24 = 12,
  
  kPixelFormatMJPEG = 14,
  
  kPixelFormatYUV420P9 = 16,
  
  kPixelFormatYUV420P10 = 17,
  
  kPixelFormatYUV422P9 = 18,
  
  kPixelFormatYUV422P10 = 19,
  
  kPixelFormatYUV444P9 = 20,
  
  kPixelFormatYUV444P10 = 21,
  
  kPixelFormatYUV420P12 = 22,
  
  kPixelFormatYUV422P12 = 23,
  
  kPixelFormatYUV444P12 = 24,
  
  kPixelFormatY16 = 26,
  
  kPixelFormatABGR = 27,
  
  kPixelFormatXBGR = 28,
  
  kPixelFormatP016LE = 29,
  
  kPixelFormatXR30 = 30,
  
  kPixelFormatXB30 = 31,
  
  kPixelFormatBGRA = 32,
  
  kPixelFormatRGBAF16 = 33,
  
  kPixelFormatI422A = 34,
  
  kPixelFormatI444A = 35,
  
  kPixelFormatYUV420AP10 = 36,
  
  kPixelFormatYUV422AP10 = 37,
  
  kPixelFormatYUV444AP10 = 38,
  kMinValue = 0,
  kMaxValue = 38,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, VideoPixelFormat value);
inline bool IsKnownEnumValue(VideoPixelFormat value) {
  return internal::VideoPixelFormat_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline VideoPixelFormat ToKnownEnumValue(VideoPixelFormat value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return VideoPixelFormat::kDefaultValue;
}


enum class WaitingReason : int32_t {
  
  kNoCdm = 0,
  
  kNoDecryptionKey = 1,
  
  kDecoderStateLost = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, WaitingReason value);
inline bool IsKnownEnumValue(WaitingReason value) {
  return internal::WaitingReason_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline WaitingReason ToKnownEnumValue(WaitingReason value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return WaitingReason::kDefaultValue;
}


enum class DecryptStatus : int32_t {
  
  kSuccess = 0,
  
  kNoKey = 1,
  
  kFailure = 2,
  kMinValue = 0,
  kMaxValue = 2,
  kDefaultValue = 2
};

 std::ostream& operator<<(std::ostream& os, DecryptStatus value);
inline bool IsKnownEnumValue(DecryptStatus value) {
  return internal::DecryptStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline DecryptStatus ToKnownEnumValue(DecryptStatus value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return DecryptStatus::kDefaultValue;
}


enum class CdmContextEvent : int32_t {
  
  kHasAdditionalUsableKey = 0,
  
  kHardwareContextReset = 1,
  kMinValue = 0,
  kMaxValue = 1,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, CdmContextEvent value);
inline bool IsKnownEnumValue(CdmContextEvent value) {
  return internal::CdmContextEvent_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline CdmContextEvent ToKnownEnumValue(CdmContextEvent value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return CdmContextEvent::kDefaultValue;
}


enum class MediaLogRecord_Type : int32_t {
  
  kMessage = 0,
  
  kMediaPropertyChange = 1,
  
  kMediaEventTriggered = 2,
  
  kMediaStatus = 3,
  kMinValue = 0,
  kMaxValue = 3,
  kDefaultValue = 0
};

 std::ostream& operator<<(std::ostream& os, MediaLogRecord_Type value);
inline bool IsKnownEnumValue(MediaLogRecord_Type value) {
  return internal::MediaLogRecord_Type_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
inline MediaLogRecord_Type ToKnownEnumValue(MediaLogRecord_Type value) {
  if (IsKnownEnumValue(value)) {
    return value;
  }
  return MediaLogRecord_Type::kDefaultValue;
}


class SubsampleEntryDataView {
 public:
  SubsampleEntryDataView() = default;

  SubsampleEntryDataView(
      internal::SubsampleEntry_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t clear_bytes() const {
    return data_->clear_bytes;
  }
  uint32_t cypher_bytes() const {
    return data_->cypher_bytes;
  }
 private:
  internal::SubsampleEntry_Data* data_ = nullptr;
};



class DecryptConfigDataView {
 public:
  DecryptConfigDataView() = default;

  DecryptConfigDataView(
      internal::DecryptConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionScheme(UserType* output) const {
    auto data_value = data_->encryption_scheme;
    return mojo::internal::Deserialize<::media::stable::mojom::EncryptionScheme>(
        data_value, output);
  }
  EncryptionScheme encryption_scheme() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::EncryptionScheme>(data_->encryption_scheme));
  }
  inline void GetKeyIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyId(UserType* output) {
    
    auto* pointer = data_->key_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetIvDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIv(UserType* output) {
    
    auto* pointer = data_->iv.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetSubsamplesDataView(
      mojo::ArrayDataView<SubsampleEntryDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSubsamples(UserType* output) {
    
    auto* pointer = data_->subsamples.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::media::stable::mojom::SubsampleEntryDataView>>(
        pointer, output, message_);
  }
  inline void GetEncryptionPatternDataView(
      ::media::mojom::EncryptionPatternDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionPattern(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::EncryptionPatternDataView, UserType>(),
    "Attempting to read the optional `encryption_pattern` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadEncryptionPattern` instead "
    "of `ReadEncryptionPattern if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->encryption_pattern.Get();
    return mojo::internal::Deserialize<::media::mojom::EncryptionPatternDataView>(
        pointer, output, message_);
  }
 private:
  internal::DecryptConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ColorVolumeMetadataDataView {
 public:
  ColorVolumeMetadataDataView() = default;

  ColorVolumeMetadataDataView(
      internal::ColorVolumeMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetPrimaryRDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryR(UserType* output) {
    
    auto* pointer = data_->primary_r.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetPrimaryGDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryG(UserType* output) {
    
    auto* pointer = data_->primary_g.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetPrimaryBDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryB(UserType* output) {
    
    auto* pointer = data_->primary_b.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetWhitePointDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadWhitePoint(UserType* output) {
    
    auto* pointer = data_->white_point.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  float luminance_max() const {
    return data_->luminance_max;
  }
  float luminance_min() const {
    return data_->luminance_min;
  }
 private:
  internal::ColorVolumeMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HDRMetadataDataView {
 public:
  HDRMetadataDataView() = default;

  HDRMetadataDataView(
      internal::HDRMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetColorVolumeMetadataDataView(
      ColorVolumeMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorVolumeMetadata(UserType* output) {
    
    auto* pointer = data_->color_volume_metadata.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::ColorVolumeMetadataDataView>(
        pointer, output, message_);
  }
  uint32_t max_content_light_level() const {
    return data_->max_content_light_level;
  }
  uint32_t max_frame_average_light_level() const {
    return data_->max_frame_average_light_level;
  }
 private:
  internal::HDRMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoDecoderConfigDataView {
 public:
  VideoDecoderConfigDataView() = default;

  VideoDecoderConfigDataView(
      internal::VideoDecoderConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadCodec(UserType* output) const {
    auto data_value = data_->codec;
    return mojo::internal::Deserialize<::media::stable::mojom::VideoCodec>(
        data_value, output);
  }
  VideoCodec codec() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::VideoCodec>(data_->codec));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadProfile(UserType* output) const {
    auto data_value = data_->profile;
    return mojo::internal::Deserialize<::media::stable::mojom::VideoCodecProfile>(
        data_value, output);
  }
  VideoCodecProfile profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::VideoCodecProfile>(data_->profile));
  }
  uint32_t level() const {
    return data_->level;
  }
  bool has_alpha() const {
    return data_->has_alpha;
  }
  inline void GetCodedSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodedSize(UserType* output) {
    
    auto* pointer = data_->coded_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetVisibleRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVisibleRect(UserType* output) {
    
    auto* pointer = data_->visible_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetNaturalSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNaturalSize(UserType* output) {
    
    auto* pointer = data_->natural_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetExtraDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExtraData(UserType* output) {
    
    auto* pointer = data_->extra_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionScheme(UserType* output) const {
    auto data_value = data_->encryption_scheme;
    return mojo::internal::Deserialize<::media::stable::mojom::EncryptionScheme>(
        data_value, output);
  }
  EncryptionScheme encryption_scheme() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::EncryptionScheme>(data_->encryption_scheme));
  }
  inline void GetColorSpaceInfoDataView(
      ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpaceInfo(UserType* output) {
    
    auto* pointer = data_->color_space_info.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  inline void GetHdrMetadataDataView(
      HDRMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHdrMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::stable::mojom::HDRMetadataDataView, UserType>(),
    "Attempting to read the optional `hdr_metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadHdrMetadata` instead "
    "of `ReadHdrMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->hdr_metadata.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::HDRMetadataDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoDecoderConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SupportedVideoDecoderConfigDataView {
 public:
  SupportedVideoDecoderConfigDataView() = default;

  SupportedVideoDecoderConfigDataView(
      internal::SupportedVideoDecoderConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadProfileMin(UserType* output) const {
    auto data_value = data_->profile_min;
    return mojo::internal::Deserialize<::media::stable::mojom::VideoCodecProfile>(
        data_value, output);
  }
  VideoCodecProfile profile_min() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::VideoCodecProfile>(data_->profile_min));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadProfileMax(UserType* output) const {
    auto data_value = data_->profile_max;
    return mojo::internal::Deserialize<::media::stable::mojom::VideoCodecProfile>(
        data_value, output);
  }
  VideoCodecProfile profile_max() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::VideoCodecProfile>(data_->profile_max));
  }
  inline void GetCodedSizeMinDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodedSizeMin(UserType* output) {
    
    auto* pointer = data_->coded_size_min.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetCodedSizeMaxDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodedSizeMax(UserType* output) {
    
    auto* pointer = data_->coded_size_max.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  bool allow_encrypted() const {
    return data_->allow_encrypted;
  }
  bool require_encrypted() const {
    return data_->require_encrypted;
  }
 private:
  internal::SupportedVideoDecoderConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StatusDataDataView {
 public:
  StatusDataDataView() = default;

  StatusDataDataView(
      internal::StatusData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetGroupDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGroup(UserType* output) {
    
    auto* pointer = data_->group.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadCode(UserType* output) const {
    auto data_value = data_->code;
    return mojo::internal::Deserialize<::media::stable::mojom::StatusCode>(
        data_value, output);
  }
  StatusCode code() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::StatusCode>(data_->code));
  }
  inline void GetMessageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMessage(UserType* output) {
    
    auto* pointer = data_->message.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetFramesDataView(
      mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrames(UserType* output) {
    
    auto* pointer = data_->frames.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>>(
        pointer, output, message_);
  }
  inline void GetCauseDataView(
      StatusDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCause(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::stable::mojom::StatusDataDataView, UserType>(),
    "Attempting to read the optional `cause` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCause` instead "
    "of `ReadCause if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->cause.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::StatusDataDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      ::mojo_base::mojom::ValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
    auto* pointer = !data_->data.is_null() ? &data_->data : nullptr;
    return mojo::internal::Deserialize<::mojo_base::mojom::ValueDataView>(
        pointer, output, message_);
  }
 private:
  internal::StatusData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StatusDataView {
 public:
  StatusDataView() = default;

  StatusDataView(
      internal::Status_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInternalDataView(
      StatusDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInternal(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::stable::mojom::StatusDataDataView, UserType>(),
    "Attempting to read the optional `internal` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInternal` instead "
    "of `ReadInternal if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->internal.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::StatusDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::Status_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DecoderBufferDataView {
 public:
  DecoderBufferDataView() = default;

  DecoderBufferDataView(
      internal::DecoderBuffer_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDuration(UserType* output) {
    
    auto* pointer = data_->duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  bool is_end_of_stream() const {
    return data_->is_end_of_stream;
  }
  uint32_t data_size() const {
    return data_->data_size;
  }
  bool is_key_frame() const {
    return data_->is_key_frame;
  }
  inline void GetSideDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSideData(UserType* output) {
    
    auto* pointer = data_->side_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetDecryptConfigDataView(
      DecryptConfigDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecryptConfig(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::stable::mojom::DecryptConfigDataView, UserType>(),
    "Attempting to read the optional `decrypt_config` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDecryptConfig` instead "
    "of `ReadDecryptConfig if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->decrypt_config.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::DecryptConfigDataView>(
        pointer, output, message_);
  }
  inline void GetFrontDiscardDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrontDiscard(UserType* output) {
    
    auto* pointer = data_->front_discard.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetBackDiscardDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBackDiscard(UserType* output) {
    
    auto* pointer = data_->back_discard.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::DecoderBuffer_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ColorSpaceDataView {
 public:
  ColorSpaceDataView() = default;

  ColorSpaceDataView(
      internal::ColorSpace_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadPrimaries(UserType* output) const {
    auto data_value = data_->primaries;
    return mojo::internal::Deserialize<::media::stable::mojom::ColorSpacePrimaryID>(
        data_value, output);
  }
  ColorSpacePrimaryID primaries() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::ColorSpacePrimaryID>(data_->primaries));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadTransfer(UserType* output) const {
    auto data_value = data_->transfer;
    return mojo::internal::Deserialize<::media::stable::mojom::ColorSpaceTransferID>(
        data_value, output);
  }
  ColorSpaceTransferID transfer() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::ColorSpaceTransferID>(data_->transfer));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadMatrix(UserType* output) const {
    auto data_value = data_->matrix;
    return mojo::internal::Deserialize<::media::stable::mojom::ColorSpaceMatrixID>(
        data_value, output);
  }
  ColorSpaceMatrixID matrix() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::ColorSpaceMatrixID>(data_->matrix));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadRange(UserType* output) const {
    auto data_value = data_->range;
    return mojo::internal::Deserialize<::media::stable::mojom::ColorSpaceRangeID>(
        data_value, output);
  }
  ColorSpaceRangeID range() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::ColorSpaceRangeID>(data_->range));
  }
  inline void GetCustomPrimaryMatrixDataView(
      mojo::ArrayDataView<float>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCustomPrimaryMatrix(UserType* output) {
    
    auto* pointer = data_->custom_primary_matrix.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<float>>(
        pointer, output, message_);
  }
  inline void GetTransferParamsDataView(
      mojo::ArrayDataView<float>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransferParams(UserType* output) {
    
    auto* pointer = data_->transfer_params.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<float>>(
        pointer, output, message_);
  }
 private:
  internal::ColorSpace_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EosVideoFrameDataDataView {
 public:
  EosVideoFrameDataDataView() = default;

  EosVideoFrameDataDataView(
      internal::EosVideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
 private:
  internal::EosVideoFrameData_Data* data_ = nullptr;
};



class NativeGpuMemoryBufferHandleDataView {
 public:
  NativeGpuMemoryBufferHandleDataView() = default;

  NativeGpuMemoryBufferHandleDataView(
      internal::NativeGpuMemoryBufferHandle_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIdDataView(
      ::gfx::mojom::GpuMemoryBufferIdDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<::gfx::mojom::GpuMemoryBufferIdDataView>(
        pointer, output, message_);
  }
  inline void GetPlatformHandleDataView(
      ::media::stable::mojom::NativePixmapHandleDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPlatformHandle(UserType* output) {
    
    auto* pointer = data_->platform_handle.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::NativePixmapHandleDataView>(
        pointer, output, message_);
  }
 private:
  internal::NativeGpuMemoryBufferHandle_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GpuMemoryBufferVideoFrameDataDataView {
 public:
  GpuMemoryBufferVideoFrameDataDataView() = default;

  GpuMemoryBufferVideoFrameDataDataView(
      internal::GpuMemoryBufferVideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetGpuMemoryBufferHandleDataView(
      NativeGpuMemoryBufferHandleDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGpuMemoryBufferHandle(UserType* output) {
    
    auto* pointer = data_->gpu_memory_buffer_handle.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::NativeGpuMemoryBufferHandleDataView>(
        pointer, output, message_);
  }
 private:
  internal::GpuMemoryBufferVideoFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoFrameMetadataDataView {
 public:
  VideoFrameMetadataDataView() = default;

  VideoFrameMetadataDataView(
      internal::VideoFrameMetadata_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  bool allow_overlay() const {
    return data_->allow_overlay;
  }
  bool end_of_stream() const {
    return data_->end_of_stream;
  }
  bool read_lock_fences_enabled() const {
    return data_->read_lock_fences_enabled;
  }
  bool protected_video() const {
    return data_->protected_video;
  }
  bool hw_protected() const {
    return data_->hw_protected;
  }
  bool power_efficient() const {
    return data_->power_efficient;
  }
 private:
  internal::VideoFrameMetadata_Data* data_ = nullptr;
};



class VideoFrameDataView {
 public:
  VideoFrameDataView() = default;

  VideoFrameDataView(
      internal::VideoFrame_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadFormat(UserType* output) const {
    auto data_value = data_->format;
    return mojo::internal::Deserialize<::media::stable::mojom::VideoPixelFormat>(
        data_value, output);
  }
  VideoPixelFormat format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::VideoPixelFormat>(data_->format));
  }
  inline void GetCodedSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodedSize(UserType* output) {
    
    auto* pointer = data_->coded_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetVisibleRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVisibleRect(UserType* output) {
    
    auto* pointer = data_->visible_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetNaturalSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNaturalSize(UserType* output) {
    
    auto* pointer = data_->natural_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      VideoFrameDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
    auto* pointer = !data_->data.is_null() ? &data_->data : nullptr;
    return mojo::internal::Deserialize<::media::stable::mojom::VideoFrameDataDataView>(
        pointer, output, message_);
  }
  inline void GetMetadataDataView(
      VideoFrameMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMetadata(UserType* output) {
    
    auto* pointer = data_->metadata.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::VideoFrameMetadataDataView>(
        pointer, output, message_);
  }
  inline void GetColorSpaceDataView(
      ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) {
    
    auto* pointer = data_->color_space.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  inline void GetHdrMetadataDataView(
      HDRMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHdrMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::stable::mojom::HDRMetadataDataView, UserType>(),
    "Attempting to read the optional `hdr_metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadHdrMetadata` instead "
    "of `ReadHdrMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->hdr_metadata.Get();
    return mojo::internal::Deserialize<::media::stable::mojom::HDRMetadataDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoFrame_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class MediaLogRecordDataView {
 public:
  MediaLogRecordDataView() = default;

  MediaLogRecordDataView(
      internal::MediaLogRecord_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t id() const {
    return data_->id;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::media::stable::mojom::MediaLogRecord_Type>(
        data_value, output);
  }
  MediaLogRecord_Type type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::stable::mojom::MediaLogRecord_Type>(data_->type));
  }
  inline void GetParamsDataView(
      ::mojo_base::mojom::DeprecatedDictionaryValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParams(UserType* output) {
    
    auto* pointer = data_->params.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::DeprecatedDictionaryValueDataView>(
        pointer, output, message_);
  }
  inline void GetTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTime(UserType* output) {
    
    auto* pointer = data_->time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
 private:
  internal::MediaLogRecord_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoFrameDataDataView {
 public:
  using Tag = internal::VideoFrameData_Data::VideoFrameData_Tag;

  VideoFrameDataDataView() = default;

  VideoFrameDataDataView(
      internal::VideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_eos_data() const { return data_->tag == Tag::kEosData; }
  inline void GetEosDataDataView(
      EosVideoFrameDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadEosData(UserType* output) const {
    
    CHECK(is_eos_data());
    return mojo::internal::Deserialize<::media::stable::mojom::EosVideoFrameDataDataView>(
        data_->data.f_eos_data.Get(), output, message_);
  }
  bool is_gpu_memory_buffer_data() const { return data_->tag == Tag::kGpuMemoryBufferData; }
  inline void GetGpuMemoryBufferDataDataView(
      GpuMemoryBufferVideoFrameDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadGpuMemoryBufferData(UserType* output) const {
    
    CHECK(is_gpu_memory_buffer_data());
    return mojo::internal::Deserialize<::media::stable::mojom::GpuMemoryBufferVideoFrameDataDataView>(
        data_->data.f_gpu_memory_buffer_data.Get(), output, message_);
  }

 private:
  internal::VideoFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace stable
}  // namespace media

namespace std {

template <>
struct hash<::media::stable::mojom::VideoCodec>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::VideoCodec> {};

template <>
struct hash<::media::stable::mojom::VideoCodecProfile>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::VideoCodecProfile> {};

template <>
struct hash<::media::stable::mojom::EncryptionScheme>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::EncryptionScheme> {};

template <>
struct hash<::media::stable::mojom::StatusCode>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::StatusCode> {};

template <>
struct hash<::media::stable::mojom::VideoDecoderType>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::VideoDecoderType> {};

template <>
struct hash<::media::stable::mojom::ColorSpacePrimaryID>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::ColorSpacePrimaryID> {};

template <>
struct hash<::media::stable::mojom::ColorSpaceTransferID>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::ColorSpaceTransferID> {};

template <>
struct hash<::media::stable::mojom::ColorSpaceMatrixID>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::ColorSpaceMatrixID> {};

template <>
struct hash<::media::stable::mojom::ColorSpaceRangeID>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::ColorSpaceRangeID> {};

template <>
struct hash<::media::stable::mojom::VideoPixelFormat>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::VideoPixelFormat> {};

template <>
struct hash<::media::stable::mojom::WaitingReason>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::WaitingReason> {};

template <>
struct hash<::media::stable::mojom::DecryptStatus>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::DecryptStatus> {};

template <>
struct hash<::media::stable::mojom::CdmContextEvent>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::CdmContextEvent> {};

template <>
struct hash<::media::stable::mojom::MediaLogRecord_Type>
    : public mojo::internal::EnumHashImpl<::media::stable::mojom::MediaLogRecord_Type> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoCodec, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::VideoCodec, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::VideoCodec>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoCodecProfile, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::VideoCodecProfile, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::VideoCodecProfile>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::EncryptionScheme, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::EncryptionScheme, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::EncryptionScheme>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::StatusCode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::StatusCode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::StatusCode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoDecoderType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::VideoDecoderType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::VideoDecoderType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::ColorSpacePrimaryID, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::ColorSpacePrimaryID, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::ColorSpacePrimaryID>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::ColorSpaceTransferID, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::ColorSpaceTransferID, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::ColorSpaceTransferID>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::ColorSpaceMatrixID, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::ColorSpaceMatrixID, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::ColorSpaceMatrixID>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::ColorSpaceRangeID, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::ColorSpaceRangeID, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::ColorSpaceRangeID>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoPixelFormat, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::VideoPixelFormat, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::VideoPixelFormat>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::WaitingReason, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::WaitingReason, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::WaitingReason>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::DecryptStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::DecryptStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::DecryptStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::CdmContextEvent, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::CdmContextEvent, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::CdmContextEvent>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::MediaLogRecord_Type, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::stable::mojom::MediaLogRecord_Type, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::stable::mojom::MediaLogRecord_Type>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::SubsampleEntryDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::SubsampleEntryDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::SubsampleEntry_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->clear_bytes = Traits::clear_bytes(input);
    fragment->cypher_bytes = Traits::cypher_bytes(input);
  }

  static bool Deserialize(::media::stable::mojom::internal::SubsampleEntry_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::SubsampleEntryDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::DecryptConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::DecryptConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::DecryptConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::stable::mojom::EncryptionScheme>(
        Traits::encryption_scheme(input), &fragment->encryption_scheme);
    decltype(Traits::key_id(input)) in_key_id = Traits::key_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_id)::BaseType> key_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_key_id, key_id_fragment);
    fragment->key_id.Set(
        key_id_fragment.is_null() ? nullptr : key_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_id in DecryptConfig struct");
    decltype(Traits::iv(input)) in_iv = Traits::iv(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->iv)::BaseType> iv_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_iv, iv_fragment);
    fragment->iv.Set(
        iv_fragment.is_null() ? nullptr : iv_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->iv.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null iv in DecryptConfig struct");
    decltype(Traits::subsamples(input)) in_subsamples = Traits::subsamples(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->subsamples)::BaseType>
        subsamples_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams subsamples_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::media::stable::mojom::SubsampleEntryDataView>>(
        in_subsamples, subsamples_fragment, &subsamples_validate_params);
    fragment->subsamples.Set(
        subsamples_fragment.is_null() ? nullptr : subsamples_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->subsamples.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null subsamples in DecryptConfig struct");
    decltype(Traits::encryption_pattern(input)) in_encryption_pattern = Traits::encryption_pattern(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->encryption_pattern)::BaseType> encryption_pattern_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::EncryptionPatternDataView>(
        in_encryption_pattern, encryption_pattern_fragment);
    fragment->encryption_pattern.Set(
        encryption_pattern_fragment.is_null() ? nullptr : encryption_pattern_fragment.data());
  }

  static bool Deserialize(::media::stable::mojom::internal::DecryptConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::DecryptConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::ColorVolumeMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::ColorVolumeMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::ColorVolumeMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::primary_r(input)) in_primary_r = Traits::primary_r(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->primary_r)::BaseType> primary_r_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_primary_r, primary_r_fragment);
    fragment->primary_r.Set(
        primary_r_fragment.is_null() ? nullptr : primary_r_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_r.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_r in ColorVolumeMetadata struct");
    decltype(Traits::primary_g(input)) in_primary_g = Traits::primary_g(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->primary_g)::BaseType> primary_g_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_primary_g, primary_g_fragment);
    fragment->primary_g.Set(
        primary_g_fragment.is_null() ? nullptr : primary_g_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_g.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_g in ColorVolumeMetadata struct");
    decltype(Traits::primary_b(input)) in_primary_b = Traits::primary_b(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->primary_b)::BaseType> primary_b_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_primary_b, primary_b_fragment);
    fragment->primary_b.Set(
        primary_b_fragment.is_null() ? nullptr : primary_b_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_b.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_b in ColorVolumeMetadata struct");
    decltype(Traits::white_point(input)) in_white_point = Traits::white_point(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->white_point)::BaseType> white_point_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_white_point, white_point_fragment);
    fragment->white_point.Set(
        white_point_fragment.is_null() ? nullptr : white_point_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->white_point.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null white_point in ColorVolumeMetadata struct");
    fragment->luminance_max = Traits::luminance_max(input);
    fragment->luminance_min = Traits::luminance_min(input);
  }

  static bool Deserialize(::media::stable::mojom::internal::ColorVolumeMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::ColorVolumeMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::HDRMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::HDRMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::HDRMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::color_volume_metadata(input)) in_color_volume_metadata = Traits::color_volume_metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_volume_metadata)::BaseType> color_volume_metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::ColorVolumeMetadataDataView>(
        in_color_volume_metadata, color_volume_metadata_fragment);
    fragment->color_volume_metadata.Set(
        color_volume_metadata_fragment.is_null() ? nullptr : color_volume_metadata_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_volume_metadata.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_volume_metadata in HDRMetadata struct");
    fragment->max_content_light_level = Traits::max_content_light_level(input);
    fragment->max_frame_average_light_level = Traits::max_frame_average_light_level(input);
  }

  static bool Deserialize(::media::stable::mojom::internal::HDRMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::HDRMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoDecoderConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::VideoDecoderConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::VideoDecoderConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::stable::mojom::VideoCodec>(
        Traits::codec(input), &fragment->codec);
    mojo::internal::Serialize<::media::stable::mojom::VideoCodecProfile>(
        Traits::profile(input), &fragment->profile);
    fragment->level = Traits::level(input);
    fragment->has_alpha = Traits::has_alpha(input);
    decltype(Traits::coded_size(input)) in_coded_size = Traits::coded_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->coded_size)::BaseType> coded_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_coded_size, coded_size_fragment);
    fragment->coded_size.Set(
        coded_size_fragment.is_null() ? nullptr : coded_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->coded_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coded_size in VideoDecoderConfig struct");
    decltype(Traits::visible_rect(input)) in_visible_rect = Traits::visible_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->visible_rect)::BaseType> visible_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_visible_rect, visible_rect_fragment);
    fragment->visible_rect.Set(
        visible_rect_fragment.is_null() ? nullptr : visible_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->visible_rect.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null visible_rect in VideoDecoderConfig struct");
    decltype(Traits::natural_size(input)) in_natural_size = Traits::natural_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->natural_size)::BaseType> natural_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_natural_size, natural_size_fragment);
    fragment->natural_size.Set(
        natural_size_fragment.is_null() ? nullptr : natural_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->natural_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null natural_size in VideoDecoderConfig struct");
    decltype(Traits::extra_data(input)) in_extra_data = Traits::extra_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->extra_data)::BaseType>
        extra_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams extra_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_extra_data, extra_data_fragment, &extra_data_validate_params);
    fragment->extra_data.Set(
        extra_data_fragment.is_null() ? nullptr : extra_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->extra_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null extra_data in VideoDecoderConfig struct");
    mojo::internal::Serialize<::media::stable::mojom::EncryptionScheme>(
        Traits::encryption_scheme(input), &fragment->encryption_scheme);
    decltype(Traits::color_space_info(input)) in_color_space_info = Traits::color_space_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space_info)::BaseType> color_space_info_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::ColorSpaceDataView>(
        in_color_space_info, color_space_info_fragment);
    fragment->color_space_info.Set(
        color_space_info_fragment.is_null() ? nullptr : color_space_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space_info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space_info in VideoDecoderConfig struct");
    decltype(Traits::hdr_metadata(input)) in_hdr_metadata = Traits::hdr_metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->hdr_metadata)::BaseType> hdr_metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::HDRMetadataDataView>(
        in_hdr_metadata, hdr_metadata_fragment);
    fragment->hdr_metadata.Set(
        hdr_metadata_fragment.is_null() ? nullptr : hdr_metadata_fragment.data());
  }

  static bool Deserialize(::media::stable::mojom::internal::VideoDecoderConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::VideoDecoderConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::SupportedVideoDecoderConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::SupportedVideoDecoderConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::SupportedVideoDecoderConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::stable::mojom::VideoCodecProfile>(
        Traits::profile_min(input), &fragment->profile_min);
    mojo::internal::Serialize<::media::stable::mojom::VideoCodecProfile>(
        Traits::profile_max(input), &fragment->profile_max);
    decltype(Traits::coded_size_min(input)) in_coded_size_min = Traits::coded_size_min(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->coded_size_min)::BaseType> coded_size_min_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_coded_size_min, coded_size_min_fragment);
    fragment->coded_size_min.Set(
        coded_size_min_fragment.is_null() ? nullptr : coded_size_min_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->coded_size_min.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coded_size_min in SupportedVideoDecoderConfig struct");
    decltype(Traits::coded_size_max(input)) in_coded_size_max = Traits::coded_size_max(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->coded_size_max)::BaseType> coded_size_max_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_coded_size_max, coded_size_max_fragment);
    fragment->coded_size_max.Set(
        coded_size_max_fragment.is_null() ? nullptr : coded_size_max_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->coded_size_max.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coded_size_max in SupportedVideoDecoderConfig struct");
    fragment->allow_encrypted = Traits::allow_encrypted(input);
    fragment->require_encrypted = Traits::require_encrypted(input);
  }

  static bool Deserialize(::media::stable::mojom::internal::SupportedVideoDecoderConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::SupportedVideoDecoderConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::StatusDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::StatusDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::StatusData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::group(input)) in_group = Traits::group(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->group)::BaseType> group_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_group, group_fragment);
    fragment->group.Set(
        group_fragment.is_null() ? nullptr : group_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->group.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null group in StatusData struct");
    mojo::internal::Serialize<::media::stable::mojom::StatusCode>(
        Traits::code(input), &fragment->code);
    decltype(Traits::message(input)) in_message = Traits::message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->message)::BaseType> message_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_message, message_fragment);
    fragment->message.Set(
        message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null message in StatusData struct");
    decltype(Traits::frames(input)) in_frames = Traits::frames(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frames)::BaseType>
        frames_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams frames_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>>(
        in_frames, frames_fragment, &frames_validate_params);
    fragment->frames.Set(
        frames_fragment.is_null() ? nullptr : frames_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->frames.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frames in StatusData struct");
    decltype(Traits::cause(input)) in_cause = Traits::cause(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cause)::BaseType> cause_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::StatusDataDataView>(
        in_cause, cause_fragment);
    fragment->cause.Set(
        cause_fragment.is_null() ? nullptr : cause_fragment.data());
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<decltype(fragment->data)>
        data_fragment(fragment.message());
    data_fragment.Claim(&fragment->data);
    mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
        in_data, data_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null data in StatusData struct");
  }

  static bool Deserialize(::media::stable::mojom::internal::StatusData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::StatusDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::StatusDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::StatusDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::Status_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::internal(input)) in_internal = Traits::internal(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->internal)::BaseType> internal_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::StatusDataDataView>(
        in_internal, internal_fragment);
    fragment->internal.Set(
        internal_fragment.is_null() ? nullptr : internal_fragment.data());
  }

  static bool Deserialize(::media::stable::mojom::internal::Status_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::StatusDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::DecoderBufferDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::DecoderBufferDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::DecoderBuffer_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in DecoderBuffer struct");
    decltype(Traits::duration(input)) in_duration = Traits::duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->duration)::BaseType> duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_duration, duration_fragment);
    fragment->duration.Set(
        duration_fragment.is_null() ? nullptr : duration_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->duration.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null duration in DecoderBuffer struct");
    fragment->is_end_of_stream = Traits::is_end_of_stream(input);
    fragment->data_size = Traits::data_size(input);
    fragment->is_key_frame = Traits::is_key_frame(input);
    decltype(Traits::side_data(input)) in_side_data = Traits::side_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->side_data)::BaseType>
        side_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams side_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_side_data, side_data_fragment, &side_data_validate_params);
    fragment->side_data.Set(
        side_data_fragment.is_null() ? nullptr : side_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->side_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null side_data in DecoderBuffer struct");
    decltype(Traits::decrypt_config(input)) in_decrypt_config = Traits::decrypt_config(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decrypt_config)::BaseType> decrypt_config_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::DecryptConfigDataView>(
        in_decrypt_config, decrypt_config_fragment);
    fragment->decrypt_config.Set(
        decrypt_config_fragment.is_null() ? nullptr : decrypt_config_fragment.data());
    decltype(Traits::front_discard(input)) in_front_discard = Traits::front_discard(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->front_discard)::BaseType> front_discard_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_front_discard, front_discard_fragment);
    fragment->front_discard.Set(
        front_discard_fragment.is_null() ? nullptr : front_discard_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->front_discard.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null front_discard in DecoderBuffer struct");
    decltype(Traits::back_discard(input)) in_back_discard = Traits::back_discard(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->back_discard)::BaseType> back_discard_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_back_discard, back_discard_fragment);
    fragment->back_discard.Set(
        back_discard_fragment.is_null() ? nullptr : back_discard_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->back_discard.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null back_discard in DecoderBuffer struct");
  }

  static bool Deserialize(::media::stable::mojom::internal::DecoderBuffer_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::DecoderBufferDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::ColorSpaceDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::ColorSpaceDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::ColorSpace_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::stable::mojom::ColorSpacePrimaryID>(
        Traits::primaries(input), &fragment->primaries);
    mojo::internal::Serialize<::media::stable::mojom::ColorSpaceTransferID>(
        Traits::transfer(input), &fragment->transfer);
    mojo::internal::Serialize<::media::stable::mojom::ColorSpaceMatrixID>(
        Traits::matrix(input), &fragment->matrix);
    mojo::internal::Serialize<::media::stable::mojom::ColorSpaceRangeID>(
        Traits::range(input), &fragment->range);
    decltype(Traits::custom_primary_matrix(input)) in_custom_primary_matrix = Traits::custom_primary_matrix(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->custom_primary_matrix)::BaseType>
        custom_primary_matrix_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams custom_primary_matrix_validate_params(
        9, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<float>>(
        in_custom_primary_matrix, custom_primary_matrix_fragment, &custom_primary_matrix_validate_params);
    fragment->custom_primary_matrix.Set(
        custom_primary_matrix_fragment.is_null() ? nullptr : custom_primary_matrix_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->custom_primary_matrix.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null custom_primary_matrix in ColorSpace struct");
    decltype(Traits::transfer_params(input)) in_transfer_params = Traits::transfer_params(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transfer_params)::BaseType>
        transfer_params_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams transfer_params_validate_params(
        7, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<float>>(
        in_transfer_params, transfer_params_fragment, &transfer_params_validate_params);
    fragment->transfer_params.Set(
        transfer_params_fragment.is_null() ? nullptr : transfer_params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->transfer_params.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transfer_params in ColorSpace struct");
  }

  static bool Deserialize(::media::stable::mojom::internal::ColorSpace_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::ColorSpaceDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::EosVideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::EosVideoFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::EosVideoFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
  }

  static bool Deserialize(::media::stable::mojom::internal::EosVideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::EosVideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::NativeGpuMemoryBufferHandleDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::NativeGpuMemoryBufferHandleDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::NativeGpuMemoryBufferHandle_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType> id_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::GpuMemoryBufferIdDataView>(
        in_id, id_fragment);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in NativeGpuMemoryBufferHandle struct");
    decltype(Traits::platform_handle(input)) in_platform_handle = Traits::platform_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->platform_handle)::BaseType> platform_handle_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::NativePixmapHandleDataView>(
        in_platform_handle, platform_handle_fragment);
    fragment->platform_handle.Set(
        platform_handle_fragment.is_null() ? nullptr : platform_handle_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->platform_handle.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null platform_handle in NativeGpuMemoryBufferHandle struct");
  }

  static bool Deserialize(::media::stable::mojom::internal::NativeGpuMemoryBufferHandle_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::NativeGpuMemoryBufferHandleDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::GpuMemoryBufferVideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::GpuMemoryBufferVideoFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::GpuMemoryBufferVideoFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::gpu_memory_buffer_handle(input)) in_gpu_memory_buffer_handle = Traits::gpu_memory_buffer_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->gpu_memory_buffer_handle)::BaseType> gpu_memory_buffer_handle_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::NativeGpuMemoryBufferHandleDataView>(
        in_gpu_memory_buffer_handle, gpu_memory_buffer_handle_fragment);
    fragment->gpu_memory_buffer_handle.Set(
        gpu_memory_buffer_handle_fragment.is_null() ? nullptr : gpu_memory_buffer_handle_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->gpu_memory_buffer_handle.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null gpu_memory_buffer_handle in GpuMemoryBufferVideoFrameData struct");
  }

  static bool Deserialize(::media::stable::mojom::internal::GpuMemoryBufferVideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::GpuMemoryBufferVideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoFrameMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::VideoFrameMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::VideoFrameMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->allow_overlay = Traits::allow_overlay(input);
    fragment->end_of_stream = Traits::end_of_stream(input);
    fragment->read_lock_fences_enabled = Traits::read_lock_fences_enabled(input);
    fragment->protected_video = Traits::protected_video(input);
    fragment->hw_protected = Traits::hw_protected(input);
    fragment->power_efficient = Traits::power_efficient(input);
  }

  static bool Deserialize(::media::stable::mojom::internal::VideoFrameMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::VideoFrameMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoFrameDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::VideoFrameDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::VideoFrame_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::stable::mojom::VideoPixelFormat>(
        Traits::format(input), &fragment->format);
    decltype(Traits::coded_size(input)) in_coded_size = Traits::coded_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->coded_size)::BaseType> coded_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_coded_size, coded_size_fragment);
    fragment->coded_size.Set(
        coded_size_fragment.is_null() ? nullptr : coded_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->coded_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coded_size in VideoFrame struct");
    decltype(Traits::visible_rect(input)) in_visible_rect = Traits::visible_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->visible_rect)::BaseType> visible_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_visible_rect, visible_rect_fragment);
    fragment->visible_rect.Set(
        visible_rect_fragment.is_null() ? nullptr : visible_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->visible_rect.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null visible_rect in VideoFrame struct");
    decltype(Traits::natural_size(input)) in_natural_size = Traits::natural_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->natural_size)::BaseType> natural_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_natural_size, natural_size_fragment);
    fragment->natural_size.Set(
        natural_size_fragment.is_null() ? nullptr : natural_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->natural_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null natural_size in VideoFrame struct");
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in VideoFrame struct");
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<decltype(fragment->data)>
        data_fragment(fragment.message());
    data_fragment.Claim(&fragment->data);
    mojo::internal::Serialize<::media::stable::mojom::VideoFrameDataDataView>(
        in_data, data_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null data in VideoFrame struct");
    decltype(Traits::metadata(input)) in_metadata = Traits::metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->metadata)::BaseType> metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::VideoFrameMetadataDataView>(
        in_metadata, metadata_fragment);
    fragment->metadata.Set(
        metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->metadata.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null metadata in VideoFrame struct");
    decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space)::BaseType> color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::ColorSpaceDataView>(
        in_color_space, color_space_fragment);
    fragment->color_space.Set(
        color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space in VideoFrame struct");
    decltype(Traits::hdr_metadata(input)) in_hdr_metadata = Traits::hdr_metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->hdr_metadata)::BaseType> hdr_metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::stable::mojom::HDRMetadataDataView>(
        in_hdr_metadata, hdr_metadata_fragment);
    fragment->hdr_metadata.Set(
        hdr_metadata_fragment.is_null() ? nullptr : hdr_metadata_fragment.data());
  }

  static bool Deserialize(::media::stable::mojom::internal::VideoFrame_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::VideoFrameDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::MediaLogRecordDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::stable::mojom::MediaLogRecordDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::stable::mojom::internal::MediaLogRecord_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->id = Traits::id(input);
    mojo::internal::Serialize<::media::stable::mojom::MediaLogRecord_Type>(
        Traits::type(input), &fragment->type);
    decltype(Traits::params(input)) in_params = Traits::params(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->params)::BaseType> params_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::DeprecatedDictionaryValueDataView>(
        in_params, params_fragment);
    fragment->params.Set(
        params_fragment.is_null() ? nullptr : params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->params.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null params in MediaLogRecord struct");
    decltype(Traits::time(input)) in_time = Traits::time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->time)::BaseType> time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_time, time_fragment);
    fragment->time.Set(
        time_fragment.is_null() ? nullptr : time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->time.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null time in MediaLogRecord struct");
  }

  static bool Deserialize(::media::stable::mojom::internal::MediaLogRecord_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::MediaLogRecordDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::stable::mojom::VideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::media::stable::mojom::VideoFrameDataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::media::stable::mojom::internal::VideoFrameData_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::media::stable::mojom::VideoFrameDataDataView::Tag::kEosData: {
        decltype(Traits::eos_data(input))
            in_eos_data = Traits::eos_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_eos_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::stable::mojom::EosVideoFrameDataDataView>(
            in_eos_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null eos_data in VideoFrameData union");
        fragment->data.f_eos_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::stable::mojom::VideoFrameDataDataView::Tag::kGpuMemoryBufferData: {
        decltype(Traits::gpu_memory_buffer_data(input))
            in_gpu_memory_buffer_data = Traits::gpu_memory_buffer_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_gpu_memory_buffer_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::stable::mojom::GpuMemoryBufferVideoFrameDataDataView>(
            in_gpu_memory_buffer_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null gpu_memory_buffer_data in VideoFrameData union");
        fragment->data.f_gpu_memory_buffer_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::media::stable::mojom::internal::VideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::media::stable::mojom::VideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace media {
namespace stable {
namespace mojom {



inline void DecryptConfigDataView::GetKeyIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->key_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void DecryptConfigDataView::GetIvDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->iv.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void DecryptConfigDataView::GetSubsamplesDataView(
    mojo::ArrayDataView<SubsampleEntryDataView>* output) {
  auto pointer = data_->subsamples.Get();
  *output = mojo::ArrayDataView<SubsampleEntryDataView>(pointer, message_);
}
inline void DecryptConfigDataView::GetEncryptionPatternDataView(
    ::media::mojom::EncryptionPatternDataView* output) {
  auto pointer = data_->encryption_pattern.Get();
  *output = ::media::mojom::EncryptionPatternDataView(pointer, message_);
}


inline void ColorVolumeMetadataDataView::GetPrimaryRDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->primary_r.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void ColorVolumeMetadataDataView::GetPrimaryGDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->primary_g.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void ColorVolumeMetadataDataView::GetPrimaryBDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->primary_b.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void ColorVolumeMetadataDataView::GetWhitePointDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->white_point.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}


inline void HDRMetadataDataView::GetColorVolumeMetadataDataView(
    ColorVolumeMetadataDataView* output) {
  auto pointer = data_->color_volume_metadata.Get();
  *output = ColorVolumeMetadataDataView(pointer, message_);
}


inline void VideoDecoderConfigDataView::GetCodedSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->coded_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetVisibleRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->visible_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetNaturalSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->natural_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetExtraDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->extra_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetColorSpaceInfoDataView(
    ColorSpaceDataView* output) {
  auto pointer = data_->color_space_info.Get();
  *output = ColorSpaceDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetHdrMetadataDataView(
    HDRMetadataDataView* output) {
  auto pointer = data_->hdr_metadata.Get();
  *output = HDRMetadataDataView(pointer, message_);
}


inline void SupportedVideoDecoderConfigDataView::GetCodedSizeMinDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->coded_size_min.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void SupportedVideoDecoderConfigDataView::GetCodedSizeMaxDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->coded_size_max.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}


inline void StatusDataDataView::GetGroupDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->group.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void StatusDataDataView::GetMessageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->message.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void StatusDataDataView::GetFramesDataView(
    mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>* output) {
  auto pointer = data_->frames.Get();
  *output = mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>(pointer, message_);
}
inline void StatusDataDataView::GetCauseDataView(
    StatusDataDataView* output) {
  auto pointer = data_->cause.Get();
  *output = StatusDataDataView(pointer, message_);
}
inline void StatusDataDataView::GetDataDataView(
    ::mojo_base::mojom::ValueDataView* output) {
  auto pointer = &data_->data;
  *output = ::mojo_base::mojom::ValueDataView(pointer, message_);
}


inline void StatusDataView::GetInternalDataView(
    StatusDataDataView* output) {
  auto pointer = data_->internal.Get();
  *output = StatusDataDataView(pointer, message_);
}


inline void DecoderBufferDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetSideDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->side_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void DecoderBufferDataView::GetDecryptConfigDataView(
    DecryptConfigDataView* output) {
  auto pointer = data_->decrypt_config.Get();
  *output = DecryptConfigDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetFrontDiscardDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->front_discard.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetBackDiscardDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->back_discard.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void ColorSpaceDataView::GetCustomPrimaryMatrixDataView(
    mojo::ArrayDataView<float>* output) {
  auto pointer = data_->custom_primary_matrix.Get();
  *output = mojo::ArrayDataView<float>(pointer, message_);
}
inline void ColorSpaceDataView::GetTransferParamsDataView(
    mojo::ArrayDataView<float>* output) {
  auto pointer = data_->transfer_params.Get();
  *output = mojo::ArrayDataView<float>(pointer, message_);
}




inline void NativeGpuMemoryBufferHandleDataView::GetIdDataView(
    ::gfx::mojom::GpuMemoryBufferIdDataView* output) {
  auto pointer = data_->id.Get();
  *output = ::gfx::mojom::GpuMemoryBufferIdDataView(pointer, message_);
}
inline void NativeGpuMemoryBufferHandleDataView::GetPlatformHandleDataView(
    ::media::stable::mojom::NativePixmapHandleDataView* output) {
  auto pointer = data_->platform_handle.Get();
  *output = ::media::stable::mojom::NativePixmapHandleDataView(pointer, message_);
}


inline void GpuMemoryBufferVideoFrameDataDataView::GetGpuMemoryBufferHandleDataView(
    NativeGpuMemoryBufferHandleDataView* output) {
  auto pointer = data_->gpu_memory_buffer_handle.Get();
  *output = NativeGpuMemoryBufferHandleDataView(pointer, message_);
}




inline void VideoFrameDataView::GetCodedSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->coded_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoFrameDataView::GetVisibleRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->visible_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void VideoFrameDataView::GetNaturalSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->natural_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoFrameDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void VideoFrameDataView::GetDataDataView(
    VideoFrameDataDataView* output) {
  auto pointer = &data_->data;
  *output = VideoFrameDataDataView(pointer, message_);
}
inline void VideoFrameDataView::GetMetadataDataView(
    VideoFrameMetadataDataView* output) {
  auto pointer = data_->metadata.Get();
  *output = VideoFrameMetadataDataView(pointer, message_);
}
inline void VideoFrameDataView::GetColorSpaceDataView(
    ColorSpaceDataView* output) {
  auto pointer = data_->color_space.Get();
  *output = ColorSpaceDataView(pointer, message_);
}
inline void VideoFrameDataView::GetHdrMetadataDataView(
    HDRMetadataDataView* output) {
  auto pointer = data_->hdr_metadata.Get();
  *output = HDRMetadataDataView(pointer, message_);
}


inline void MediaLogRecordDataView::GetParamsDataView(
    ::mojo_base::mojom::DeprecatedDictionaryValueDataView* output) {
  auto pointer = data_->params.Get();
  *output = ::mojo_base::mojom::DeprecatedDictionaryValueDataView(pointer, message_);
}
inline void MediaLogRecordDataView::GetTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}


inline void VideoFrameDataDataView::GetEosDataDataView(
    EosVideoFrameDataDataView* output) const {
  CHECK(is_eos_data());
  *output = EosVideoFrameDataDataView(data_->data.f_eos_data.Get(), message_);
}
inline void VideoFrameDataDataView::GetGpuMemoryBufferDataDataView(
    GpuMemoryBufferVideoFrameDataDataView* output) const {
  CHECK(is_gpu_memory_buffer_data());
  *output = GpuMemoryBufferVideoFrameDataDataView(data_->data.f_gpu_memory_buffer_data.Get(), message_);
}


}  // namespace mojom
}  // namespace stable
}  // namespace media

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::VideoCodec> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::VideoCodec value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::VideoCodecProfile> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::VideoCodecProfile value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::EncryptionScheme> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::EncryptionScheme value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::StatusCode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::StatusCode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::VideoDecoderType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::VideoDecoderType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::ColorSpacePrimaryID> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::ColorSpacePrimaryID value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::ColorSpaceTransferID> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::ColorSpaceTransferID value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::ColorSpaceMatrixID> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::ColorSpaceMatrixID value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::ColorSpaceRangeID> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::ColorSpaceRangeID value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::VideoPixelFormat> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::VideoPixelFormat value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::WaitingReason> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::WaitingReason value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::DecryptStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::DecryptStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::CdmContextEvent> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::CdmContextEvent value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::stable::mojom::MediaLogRecord_Type> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::stable::mojom::MediaLogRecord_Type value);
};

} // namespace perfetto

#endif  // MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_SHARED_H_