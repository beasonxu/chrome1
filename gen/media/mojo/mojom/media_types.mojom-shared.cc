// media/mojo/mojom/media_types.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "media/mojo/mojom/media_types.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "media/mojo/mojom/media_types.mojom-params-data.h"
namespace media {
namespace mojom {

static NOINLINE const char* VideoRotationToStringHelper(VideoRotation value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoRotation::kVideoRotation0:
      return "kVideoRotation0";
    case VideoRotation::kVideoRotation90:
      return "kVideoRotation90";
    case VideoRotation::kVideoRotation180:
      return "kVideoRotation180";
    case VideoRotation::kVideoRotation270:
      return "kVideoRotation270";
    default:
      return nullptr;
  }
}

std::string VideoRotationToString(VideoRotation value) {
  const char *str = VideoRotationToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoRotation value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoRotation value) {
  return os << VideoRotationToString(value);
}

static NOINLINE const char* EncryptionTypeToStringHelper(EncryptionType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case EncryptionType::kNone:
      return "kNone";
    case EncryptionType::kClear:
      return "kClear";
    case EncryptionType::kEncrypted:
      return "kEncrypted";
    case EncryptionType::kEncryptedWithClearLead:
      return "kEncryptedWithClearLead";
    default:
      return nullptr;
  }
}

std::string EncryptionTypeToString(EncryptionType value) {
  const char *str = EncryptionTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown EncryptionType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, EncryptionType value) {
  return os << EncryptionTypeToString(value);
}

static NOINLINE const char* SVCScalabilityModeToStringHelper(SVCScalabilityMode value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case SVCScalabilityMode::kUnsupportedMode:
      return "kUnsupportedMode";
    case SVCScalabilityMode::kL1T2:
      return "kL1T2";
    case SVCScalabilityMode::kL1T3:
      return "kL1T3";
    case SVCScalabilityMode::kL2T2Key:
      return "kL2T2Key";
    case SVCScalabilityMode::kL2T3Key:
      return "kL2T3Key";
    case SVCScalabilityMode::kL3T2Key:
      return "kL3T2Key";
    case SVCScalabilityMode::kL3T3Key:
      return "kL3T3Key";
    default:
      return nullptr;
  }
}

std::string SVCScalabilityModeToString(SVCScalabilityMode value) {
  const char *str = SVCScalabilityModeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown SVCScalabilityMode value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, SVCScalabilityMode value) {
  return os << SVCScalabilityModeToString(value);
}

static NOINLINE const char* CdmSessionClosedReasonToStringHelper(CdmSessionClosedReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case CdmSessionClosedReason::kInternalError:
      return "kInternalError";
    case CdmSessionClosedReason::kClose:
      return "kClose";
    case CdmSessionClosedReason::kReleaseAcknowledged:
      return "kReleaseAcknowledged";
    case CdmSessionClosedReason::kHardwareContextReset:
      return "kHardwareContextReset";
    case CdmSessionClosedReason::kResourceEvicted:
      return "kResourceEvicted";
    default:
      return nullptr;
  }
}

std::string CdmSessionClosedReasonToString(CdmSessionClosedReason value) {
  const char *str = CdmSessionClosedReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown CdmSessionClosedReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, CdmSessionClosedReason value) {
  return os << CdmSessionClosedReasonToString(value);
}

static NOINLINE const char* MediaStreamTypeToStringHelper(MediaStreamType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case MediaStreamType::kLocalElementCapture:
      return "kLocalElementCapture";
    case MediaStreamType::kLocalDeviceCapture:
      return "kLocalDeviceCapture";
    case MediaStreamType::kLocalTabCapture:
      return "kLocalTabCapture";
    case MediaStreamType::kLocalDesktopCapture:
      return "kLocalDesktopCapture";
    case MediaStreamType::kLocalDisplayCapture:
      return "kLocalDisplayCapture";
    case MediaStreamType::kRemote:
      return "kRemote";
    case MediaStreamType::kNone:
      return "kNone";
    default:
      return nullptr;
  }
}

std::string MediaStreamTypeToString(MediaStreamType value) {
  const char *str = MediaStreamTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown MediaStreamType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, MediaStreamType value) {
  return os << MediaStreamTypeToString(value);
}

static NOINLINE const char* InputStreamErrorCodeToStringHelper(InputStreamErrorCode value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case InputStreamErrorCode::kUnknown:
      return "kUnknown";
    case InputStreamErrorCode::kSystemPermissions:
      return "kSystemPermissions";
    case InputStreamErrorCode::kDeviceInUse:
      return "kDeviceInUse";
    default:
      return nullptr;
  }
}

std::string InputStreamErrorCodeToString(InputStreamErrorCode value) {
  const char *str = InputStreamErrorCodeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown InputStreamErrorCode value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, InputStreamErrorCode value) {
  return os << InputStreamErrorCodeToString(value);
}

static NOINLINE const char* RendererTypeToStringHelper(RendererType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case RendererType::kDefault:
      return "kDefault";
    case RendererType::kMojo:
      return "kMojo";
    case RendererType::kMediaPlayer:
      return "kMediaPlayer";
    case RendererType::kCourier:
      return "kCourier";
    case RendererType::kFlinging:
      return "kFlinging";
    case RendererType::kCast:
      return "kCast";
    case RendererType::kMediaFoundation:
      return "kMediaFoundation";
    case RendererType::kRemoting:
      return "kRemoting";
    case RendererType::kCastStreaming:
      return "kCastStreaming";
    case RendererType::kContentEmbedderDefined:
      return "kContentEmbedderDefined";
    default:
      return nullptr;
  }
}

std::string RendererTypeToString(RendererType value) {
  const char *str = RendererTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown RendererType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, RendererType value) {
  return os << RendererTypeToString(value);
}

namespace internal {
// static
bool VideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context,
    bool inlined) {
  if (!data) {
    DCHECK(!inlined);
    return true;
  }

  // If it is inlined, the alignment is already enforced by its enclosing
  // object. We don't have to validate that.
  DCHECK(!inlined || mojo::internal::IsAligned(data));

  if (!inlined &&
      !mojo::internal::ValidateNonInlinedUnionHeaderAndClaimMemory(
          data, validation_context)) {
    return false;
  }

  const VideoFrameData_Data* object = static_cast<const VideoFrameData_Data*>(data);

  if (inlined && object->is_null())
    return true;

  switch (object->tag) {

    case VideoFrameData_Tag::kEosData: {

      if (!mojo::internal::ValidatePointerNonNullable(
              object->data.f_eos_data, 1, validation_context)) {
        return false;
      }
      if (!mojo::internal::ValidateStruct(object->data.f_eos_data, validation_context))
        return false;
      return true;
    }
    case VideoFrameData_Tag::kSharedBufferData: {

      if (!mojo::internal::ValidatePointerNonNullable(
              object->data.f_shared_buffer_data, 2, validation_context)) {
        return false;
      }
      if (!mojo::internal::ValidateStruct(object->data.f_shared_buffer_data, validation_context))
        return false;
      return true;
    }
    case VideoFrameData_Tag::kGpuMemoryBufferData: {

      if (!mojo::internal::ValidatePointerNonNullable(
              object->data.f_gpu_memory_buffer_data, 3, validation_context)) {
        return false;
      }
      if (!mojo::internal::ValidateStruct(object->data.f_gpu_memory_buffer_data, validation_context))
        return false;
      return true;
    }
    case VideoFrameData_Tag::kMailboxData: {

      if (!mojo::internal::ValidatePointerNonNullable(
              object->data.f_mailbox_data, 4, validation_context)) {
        return false;
      }
      if (!mojo::internal::ValidateStruct(object->data.f_mailbox_data, validation_context))
        return false;
      return true;
    }
    default: {

      ReportValidationError(
          validation_context,
          mojo::internal::VALIDATION_ERROR_UNKNOWN_UNION_TAG,
          "unknown tag in VideoFrameData");
      return false;
    }
  }
}


// static
bool VideoTransformation_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoTransformation_Data* object =
      static_cast<const VideoTransformation_Data*>(data);


  if (!::media::mojom::internal::VideoRotation_Data
        ::Validate(object->rotation, validation_context))
    return false;

  return true;
}

VideoTransformation_Data::VideoTransformation_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoColorSpace_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoColorSpace_Data* object =
      static_cast<const VideoColorSpace_Data*>(data);


  if (!::media::mojom::internal::VideoColorSpace_PrimaryID_Data
        ::Validate(object->primaries, validation_context))
    return false;


  if (!::media::mojom::internal::VideoColorSpace_TransferID_Data
        ::Validate(object->transfer, validation_context))
    return false;


  if (!::media::mojom::internal::VideoColorSpace_MatrixID_Data
        ::Validate(object->matrix, validation_context))
    return false;


  if (!::media::mojom::internal::VideoColorSpace_RangeID_Data
        ::Validate(object->range, validation_context))
    return false;

  return true;
}

VideoColorSpace_Data::VideoColorSpace_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool AudioDecoderConfig_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 72, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AudioDecoderConfig_Data* object =
      static_cast<const AudioDecoderConfig_Data*>(data);


  if (!::media::mojom::internal::AudioCodec_Data
        ::Validate(object->codec, validation_context))
    return false;


  if (!::media::mojom::internal::SampleFormat_Data
        ::Validate(object->sample_format, validation_context))
    return false;


  if (!::media::mojom::internal::ChannelLayout_Data
        ::Validate(object->channel_layout, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->extra_data, 5, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams extra_data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->extra_data, validation_context,
                                         &extra_data_validate_params)) {
    return false;
  }


  if (!::media::mojom::internal::EncryptionScheme_Data
        ::Validate(object->encryption_scheme, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->seek_preroll, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->seek_preroll, validation_context))
    return false;


  if (!::media::mojom::internal::AudioCodecProfile_Data
        ::Validate(object->profile, validation_context))
    return false;


  if (!::media::mojom::internal::ChannelLayout_Data
        ::Validate(object->target_output_channel_layout, validation_context))
    return false;


  if (!::media::mojom::internal::SampleFormat_Data
        ::Validate(object->target_output_sample_format, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->aac_extra_data, 13, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams aac_extra_data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->aac_extra_data, validation_context,
                                         &aac_extra_data_validate_params)) {
    return false;
  }

  return true;
}

AudioDecoderConfig_Data::AudioDecoderConfig_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoDecoderConfig_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 88, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoDecoderConfig_Data* object =
      static_cast<const VideoDecoderConfig_Data*>(data);


  if (!::media::mojom::internal::VideoCodec_Data
        ::Validate(object->codec, validation_context))
    return false;


  if (!::media::mojom::internal::VideoCodecProfile_Data
        ::Validate(object->profile, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->transformation, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->transformation, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->coded_size, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->coded_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->visible_rect, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->visible_rect, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->natural_size, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->natural_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->extra_data, 9, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams extra_data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->extra_data, validation_context,
                                         &extra_data_validate_params)) {
    return false;
  }


  if (!::media::mojom::internal::EncryptionScheme_Data
        ::Validate(object->encryption_scheme, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->color_space_info, 11, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->color_space_info, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->hdr_metadata, validation_context))
    return false;

  return true;
}

VideoDecoderConfig_Data::VideoDecoderConfig_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool DecryptConfig_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const DecryptConfig_Data* object =
      static_cast<const DecryptConfig_Data*>(data);


  if (!::media::mojom::internal::EncryptionScheme_Data
        ::Validate(object->encryption_scheme, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->key_id, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams key_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->key_id, validation_context,
                                         &key_id_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->iv, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams iv_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->iv, validation_context,
                                         &iv_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->subsamples, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams subsamples_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->subsamples, validation_context,
                                         &subsamples_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->encryption_pattern, validation_context))
    return false;

  return true;
}

DecryptConfig_Data::DecryptConfig_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool DecoderBuffer_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 64, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const DecoderBuffer_Data* object =
      static_cast<const DecoderBuffer_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->timestamp, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->timestamp, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->duration, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->duration, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->side_data, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams side_data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->side_data, validation_context,
                                         &side_data_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->decrypt_config, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->front_discard, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->front_discard, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->back_discard, 9, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->back_discard, validation_context))
    return false;

  return true;
}

DecoderBuffer_Data::DecoderBuffer_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool AudioBuffer_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AudioBuffer_Data* object =
      static_cast<const AudioBuffer_Data*>(data);


  if (!::media::mojom::internal::SampleFormat_Data
        ::Validate(object->sample_format, validation_context))
    return false;


  if (!::media::mojom::internal::ChannelLayout_Data
        ::Validate(object->channel_layout, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->timestamp, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->timestamp, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->data, 8, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams data_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->data, validation_context,
                                         &data_validate_params)) {
    return false;
  }

  return true;
}

AudioBuffer_Data::AudioBuffer_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoFrameMetadata_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 192, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoFrameMetadata_Data* object =
      static_cast<const VideoFrameMetadata_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->capture_begin_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->capture_end_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->capture_update_rect, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->source_size, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->region_capture_rect, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->frame_duration, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->reference_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->transformation, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->overlay_plane_id, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->decode_begin_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->decode_end_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->processing_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->receive_time, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->wallclock_frame_duration, validation_context))
    return false;

  return true;
}

VideoFrameMetadata_Data::VideoFrameMetadata_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoFrame_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 88, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoFrame_Data* object =
      static_cast<const VideoFrame_Data*>(data);


  if (!::media::mojom::internal::VideoPixelFormat_Data
        ::Validate(object->format, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->coded_size, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->coded_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->visible_rect, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->visible_rect, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->natural_size, 4, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->natural_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->timestamp, 5, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->timestamp, validation_context))
    return false;

  if (!mojo::internal::ValidateInlinedUnionNonNullable(
          object->data, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateInlinedUnion(object->data, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->metadata, 7, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->metadata, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->color_space, 8, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->color_space, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->hdr_metadata, validation_context))
    return false;

  return true;
}

VideoFrame_Data::VideoFrame_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool EosVideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 8, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const EosVideoFrameData_Data* object =
      static_cast<const EosVideoFrameData_Data*>(data);

  return true;
}

EosVideoFrameData_Data::EosVideoFrameData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool SharedBufferVideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 32, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const SharedBufferVideoFrameData_Data* object =
      static_cast<const SharedBufferVideoFrameData_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->frame_data, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->frame_data, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->strides, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams strides_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->strides, validation_context,
                                         &strides_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->offsets, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams offsets_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->offsets, validation_context,
                                         &offsets_validate_params)) {
    return false;
  }

  return true;
}

SharedBufferVideoFrameData_Data::SharedBufferVideoFrameData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool GpuMemoryBufferVideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const GpuMemoryBufferVideoFrameData_Data* object =
      static_cast<const GpuMemoryBufferVideoFrameData_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->gpu_memory_buffer_handle, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->gpu_memory_buffer_handle, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->mailbox_holder, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams mailbox_holder_validate_params(
      4, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->mailbox_holder, validation_context,
                                         &mailbox_holder_validate_params)) {
    return false;
  }

  return true;
}

GpuMemoryBufferVideoFrameData_Data::GpuMemoryBufferVideoFrameData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MailboxVideoFrameData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const MailboxVideoFrameData_Data* object =
      static_cast<const MailboxVideoFrameData_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->mailbox_holder, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams mailbox_holder_validate_params(
      4, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->mailbox_holder, validation_context,
                                         &mailbox_holder_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->ycbcr_data, validation_context))
    return false;

  return true;
}

MailboxVideoFrameData_Data::MailboxVideoFrameData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PipelineStatistics_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const PipelineStatistics_Data* object =
      static_cast<const PipelineStatistics_Data*>(data);

  return true;
}

PipelineStatistics_Data::PipelineStatistics_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PredictionFeatures_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 40, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const PredictionFeatures_Data* object =
      static_cast<const PredictionFeatures_Data*>(data);


  if (!::media::mojom::internal::VideoCodecProfile_Data
        ::Validate(object->profile, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->video_size, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->video_size, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->key_system, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams key_system_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->key_system, validation_context,
                                         &key_system_validate_params)) {
    return false;
  }

  return true;
}

PredictionFeatures_Data::PredictionFeatures_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PredictionTargets_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const PredictionTargets_Data* object =
      static_cast<const PredictionTargets_Data*>(data);

  return true;
}

PredictionTargets_Data::PredictionTargets_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool AudioPipelineInfo_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AudioPipelineInfo_Data* object =
      static_cast<const AudioPipelineInfo_Data*>(data);


  if (!::media::mojom::internal::AudioDecoderType_Data
        ::Validate(object->decoder_type, validation_context))
    return false;


  if (!::media::mojom::internal::EncryptionType_Data
        ::Validate(object->encryption_type, validation_context))
    return false;

  return true;
}

AudioPipelineInfo_Data::AudioPipelineInfo_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoPipelineInfo_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoPipelineInfo_Data* object =
      static_cast<const VideoPipelineInfo_Data*>(data);


  if (!::media::mojom::internal::VideoDecoderType_Data
        ::Validate(object->decoder_type, validation_context))
    return false;


  if (!::media::mojom::internal::EncryptionType_Data
        ::Validate(object->encryption_type, validation_context))
    return false;

  return true;
}

VideoPipelineInfo_Data::VideoPipelineInfo_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool StatusData_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 72, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const StatusData_Data* object =
      static_cast<const StatusData_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->group, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams group_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->group, validation_context,
                                         &group_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->message, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams message_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->message, validation_context,
                                         &message_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->frames, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams frames_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->frames, validation_context,
                                         &frames_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->cause, validation_context))
    return false;

  if (!mojo::internal::ValidateInlinedUnionNonNullable(
          object->data, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateInlinedUnion(object->data, validation_context))
    return false;

  return true;
}

StatusData_Data::StatusData_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool EncoderStatus_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const EncoderStatus_Data* object =
      static_cast<const EncoderStatus_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->internal, validation_context))
    return false;

  return true;
}

EncoderStatus_Data::EncoderStatus_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool DecoderStatus_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const DecoderStatus_Data* object =
      static_cast<const DecoderStatus_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->internal, validation_context))
    return false;

  return true;
}

DecoderStatus_Data::DecoderStatus_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool PipelineStatus_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const PipelineStatus_Data* object =
      static_cast<const PipelineStatus_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->internal, validation_context))
    return false;

  return true;
}

PipelineStatus_Data::PipelineStatus_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace media

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoRotation>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoRotation value) {
  return std::move(context).WriteString(::media::mojom::VideoRotationToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::EncryptionType>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::EncryptionType value) {
  return std::move(context).WriteString(::media::mojom::EncryptionTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::SVCScalabilityMode>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::SVCScalabilityMode value) {
  return std::move(context).WriteString(::media::mojom::SVCScalabilityModeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::CdmSessionClosedReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::CdmSessionClosedReason value) {
  return std::move(context).WriteString(::media::mojom::CdmSessionClosedReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::MediaStreamType>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::MediaStreamType value) {
  return std::move(context).WriteString(::media::mojom::MediaStreamTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::InputStreamErrorCode>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::InputStreamErrorCode value) {
  return std::move(context).WriteString(::media::mojom::InputStreamErrorCodeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::RendererType>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::RendererType value) {
  return std::move(context).WriteString(::media::mojom::RendererTypeToString(value));
}

} // namespace perfetto