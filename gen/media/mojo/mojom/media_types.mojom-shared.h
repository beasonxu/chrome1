// media/mojo/mojom/media_types.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_MEDIA_TYPES_MOJOM_SHARED_H_
#define MEDIA_MOJO_MOJOM_MEDIA_TYPES_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "media/mojo/mojom/media_types.mojom-shared-internal.h"
#include "gpu/ipc/common/mailbox_holder.mojom-shared.h"
#include "gpu/ipc/common/vulkan_ycbcr_info.mojom-shared.h"
#include "media/mojo/mojom/audio_data.mojom-shared.h"
#include "media/mojo/mojom/encryption_pattern.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/mojom/base/values.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/buffer_types.mojom-shared.h"
#include "ui/gfx/mojom/color_space.mojom-shared.h"
#include "ui/gfx/mojom/hdr_metadata.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"




namespace media {
namespace mojom {
using MediaLogRecordDataView = mojo::native::NativeStructDataView;

class VideoTransformationDataView;

class VideoColorSpaceDataView;

class AudioDecoderConfigDataView;

class VideoDecoderConfigDataView;

using SubsampleEntryDataView = mojo::native::NativeStructDataView;

class DecryptConfigDataView;

class DecoderBufferDataView;

class AudioBufferDataView;

class VideoFrameMetadataDataView;

class VideoFrameDataView;

class EosVideoFrameDataDataView;

class SharedBufferVideoFrameDataDataView;

class GpuMemoryBufferVideoFrameDataDataView;

class MailboxVideoFrameDataDataView;

class PipelineStatisticsDataView;

class PredictionFeaturesDataView;

class PredictionTargetsDataView;

class AudioPipelineInfoDataView;

class VideoPipelineInfoDataView;

class StatusDataDataView;

class EncoderStatusDataView;

class DecoderStatusDataView;

class PipelineStatusDataView;

class VideoFrameDataDataView;


}  // namespace mojom
}  // namespace media

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::media::mojom::VideoTransformationDataView> {
  using Data = ::media::mojom::internal::VideoTransformation_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoColorSpaceDataView> {
  using Data = ::media::mojom::internal::VideoColorSpace_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::AudioDecoderConfigDataView> {
  using Data = ::media::mojom::internal::AudioDecoderConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoDecoderConfigDataView> {
  using Data = ::media::mojom::internal::VideoDecoderConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::DecryptConfigDataView> {
  using Data = ::media::mojom::internal::DecryptConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::DecoderBufferDataView> {
  using Data = ::media::mojom::internal::DecoderBuffer_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::AudioBufferDataView> {
  using Data = ::media::mojom::internal::AudioBuffer_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoFrameMetadataDataView> {
  using Data = ::media::mojom::internal::VideoFrameMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoFrameDataView> {
  using Data = ::media::mojom::internal::VideoFrame_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::EosVideoFrameDataDataView> {
  using Data = ::media::mojom::internal::EosVideoFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::SharedBufferVideoFrameDataDataView> {
  using Data = ::media::mojom::internal::SharedBufferVideoFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::GpuMemoryBufferVideoFrameDataDataView> {
  using Data = ::media::mojom::internal::GpuMemoryBufferVideoFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::MailboxVideoFrameDataDataView> {
  using Data = ::media::mojom::internal::MailboxVideoFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::PipelineStatisticsDataView> {
  using Data = ::media::mojom::internal::PipelineStatistics_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::PredictionFeaturesDataView> {
  using Data = ::media::mojom::internal::PredictionFeatures_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::PredictionTargetsDataView> {
  using Data = ::media::mojom::internal::PredictionTargets_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::AudioPipelineInfoDataView> {
  using Data = ::media::mojom::internal::AudioPipelineInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoPipelineInfoDataView> {
  using Data = ::media::mojom::internal::VideoPipelineInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::StatusDataDataView> {
  using Data = ::media::mojom::internal::StatusData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::EncoderStatusDataView> {
  using Data = ::media::mojom::internal::EncoderStatus_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::DecoderStatusDataView> {
  using Data = ::media::mojom::internal::DecoderStatus_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::PipelineStatusDataView> {
  using Data = ::media::mojom::internal::PipelineStatus_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::VideoFrameDataDataView> {
  using Data = ::media::mojom::internal::VideoFrameData_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace media {
namespace mojom {
using AudioCodec = mojo::NativeEnum;
using AudioCodecProfile = mojo::NativeEnum;
using BufferingState = mojo::NativeEnum;
using BufferingStateChangeReason = mojo::NativeEnum;
using ChannelLayout = mojo::NativeEnum;
using MediaContentType = mojo::NativeEnum;
using OutputDeviceStatus = mojo::NativeEnum;
using SampleFormat = mojo::NativeEnum;
using VideoCodec = mojo::NativeEnum;
using VideoCodecProfile = mojo::NativeEnum;
using VideoPixelFormat = mojo::NativeEnum;
using VideoDecoderType = mojo::NativeEnum;
using AudioDecoderType = mojo::NativeEnum;


enum class VideoRotation : int32_t {
  
  kVideoRotation0 = 0,
  
  kVideoRotation90 = 1,
  
  kVideoRotation180 = 2,
  
  kVideoRotation270 = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

 std::ostream& operator<<(std::ostream& os, VideoRotation value);
inline bool IsKnownEnumValue(VideoRotation value) {
  return internal::VideoRotation_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
using FullscreenVideoStatus = mojo::NativeEnum;
using WaitingReason = mojo::NativeEnum;
using WatchTimeKey = mojo::NativeEnum;
using MediaContainerName = mojo::NativeEnum;
using MediaStatusState = mojo::NativeEnum;
using EncryptionScheme = mojo::NativeEnum;


enum class EncryptionType : int32_t {
  
  kNone = 0,
  
  kClear = 1,
  
  kEncrypted = 2,
  
  kEncryptedWithClearLead = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

 std::ostream& operator<<(std::ostream& os, EncryptionType value);
inline bool IsKnownEnumValue(EncryptionType value) {
  return internal::EncryptionType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class SVCScalabilityMode : int32_t {
  
  kUnsupportedMode = 0,
  
  kL1T2 = 1,
  
  kL1T3 = 2,
  
  kL2T2Key = 3,
  
  kL2T3Key = 4,
  
  kL3T2Key = 5,
  
  kL3T3Key = 6,
  kMinValue = 0,
  kMaxValue = 6,
};

 std::ostream& operator<<(std::ostream& os, SVCScalabilityMode value);
inline bool IsKnownEnumValue(SVCScalabilityMode value) {
  return internal::SVCScalabilityMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class CdmSessionClosedReason : int32_t {
  
  kInternalError = 0,
  
  kClose = 1,
  
  kReleaseAcknowledged = 2,
  
  kHardwareContextReset = 3,
  
  kResourceEvicted = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

 std::ostream& operator<<(std::ostream& os, CdmSessionClosedReason value);
inline bool IsKnownEnumValue(CdmSessionClosedReason value) {
  return internal::CdmSessionClosedReason_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MediaStreamType : int32_t {
  
  kLocalElementCapture = 0,
  
  kLocalDeviceCapture = 1,
  
  kLocalTabCapture = 2,
  
  kLocalDesktopCapture = 3,
  
  kLocalDisplayCapture = 4,
  
  kRemote = 5,
  
  kNone = 6,
  kMinValue = 0,
  kMaxValue = 6,
};

 std::ostream& operator<<(std::ostream& os, MediaStreamType value);
inline bool IsKnownEnumValue(MediaStreamType value) {
  return internal::MediaStreamType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class InputStreamErrorCode : int32_t {
  
  kUnknown = 0,
  
  kSystemPermissions = 1,
  
  kDeviceInUse = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, InputStreamErrorCode value);
inline bool IsKnownEnumValue(InputStreamErrorCode value) {
  return internal::InputStreamErrorCode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class RendererType : int32_t {
  
  kDefault = 0,
  
  kMojo = 1,
  
  kMediaPlayer = 2,
  
  kCourier = 3,
  
  kFlinging = 4,
  
  kCast = 5,
  
  kMediaFoundation = 6,
  
  kRemoting = 8,
  
  kCastStreaming = 9,
  
  kContentEmbedderDefined = 10,
  kMinValue = 0,
  kMaxValue = 10,
};

 std::ostream& operator<<(std::ostream& os, RendererType value);
inline bool IsKnownEnumValue(RendererType value) {
  return internal::RendererType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
using VideoColorSpace_PrimaryID = mojo::NativeEnum;
using VideoColorSpace_TransferID = mojo::NativeEnum;
using VideoColorSpace_MatrixID = mojo::NativeEnum;
using VideoColorSpace_RangeID = mojo::NativeEnum;


class VideoTransformationDataView {
 public:
  VideoTransformationDataView() = default;

  VideoTransformationDataView(
      internal::VideoTransformation_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadRotation(UserType* output) const {
    auto data_value = data_->rotation;
    return mojo::internal::Deserialize<::media::mojom::VideoRotation>(
        data_value, output);
  }
  VideoRotation rotation() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoRotation>(data_->rotation));
  }
  bool mirrored() const {
    return data_->mirrored;
  }
 private:
  internal::VideoTransformation_Data* data_ = nullptr;
};



class VideoColorSpaceDataView {
 public:
  VideoColorSpaceDataView() = default;

  VideoColorSpaceDataView(
      internal::VideoColorSpace_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadPrimaries(UserType* output) const {
    auto data_value = data_->primaries;
    return mojo::internal::Deserialize<::media::mojom::VideoColorSpace_PrimaryID>(
        data_value, output);
  }
  VideoColorSpace_PrimaryID primaries() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoColorSpace_PrimaryID>(data_->primaries));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadTransfer(UserType* output) const {
    auto data_value = data_->transfer;
    return mojo::internal::Deserialize<::media::mojom::VideoColorSpace_TransferID>(
        data_value, output);
  }
  VideoColorSpace_TransferID transfer() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoColorSpace_TransferID>(data_->transfer));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadMatrix(UserType* output) const {
    auto data_value = data_->matrix;
    return mojo::internal::Deserialize<::media::mojom::VideoColorSpace_MatrixID>(
        data_value, output);
  }
  VideoColorSpace_MatrixID matrix() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoColorSpace_MatrixID>(data_->matrix));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadRange(UserType* output) const {
    auto data_value = data_->range;
    return mojo::internal::Deserialize<::media::mojom::VideoColorSpace_RangeID>(
        data_value, output);
  }
  VideoColorSpace_RangeID range() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoColorSpace_RangeID>(data_->range));
  }
 private:
  internal::VideoColorSpace_Data* data_ = nullptr;
};



class AudioDecoderConfigDataView {
 public:
  AudioDecoderConfigDataView() = default;

  AudioDecoderConfigDataView(
      internal::AudioDecoderConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadCodec(UserType* output) const {
    auto data_value = data_->codec;
    return mojo::internal::Deserialize<::media::mojom::AudioCodec>(
        data_value, output);
  }
  AudioCodec codec() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::AudioCodec>(data_->codec));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSampleFormat(UserType* output) const {
    auto data_value = data_->sample_format;
    return mojo::internal::Deserialize<::media::mojom::SampleFormat>(
        data_value, output);
  }
  SampleFormat sample_format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::SampleFormat>(data_->sample_format));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadChannelLayout(UserType* output) const {
    auto data_value = data_->channel_layout;
    return mojo::internal::Deserialize<::media::mojom::ChannelLayout>(
        data_value, output);
  }
  ChannelLayout channel_layout() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::ChannelLayout>(data_->channel_layout));
  }
  int32_t samples_per_second() const {
    return data_->samples_per_second;
  }
  inline void GetExtraDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExtraData(UserType* output) {
    
    auto* pointer = data_->extra_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionScheme(UserType* output) const {
    auto data_value = data_->encryption_scheme;
    return mojo::internal::Deserialize<::media::mojom::EncryptionScheme>(
        data_value, output);
  }
  EncryptionScheme encryption_scheme() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::EncryptionScheme>(data_->encryption_scheme));
  }
  inline void GetSeekPrerollDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSeekPreroll(UserType* output) {
    
    auto* pointer = data_->seek_preroll.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  int32_t codec_delay() const {
    return data_->codec_delay;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadProfile(UserType* output) const {
    auto data_value = data_->profile;
    return mojo::internal::Deserialize<::media::mojom::AudioCodecProfile>(
        data_value, output);
  }
  AudioCodecProfile profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::AudioCodecProfile>(data_->profile));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadTargetOutputChannelLayout(UserType* output) const {
    auto data_value = data_->target_output_channel_layout;
    return mojo::internal::Deserialize<::media::mojom::ChannelLayout>(
        data_value, output);
  }
  ChannelLayout target_output_channel_layout() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::ChannelLayout>(data_->target_output_channel_layout));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadTargetOutputSampleFormat(UserType* output) const {
    auto data_value = data_->target_output_sample_format;
    return mojo::internal::Deserialize<::media::mojom::SampleFormat>(
        data_value, output);
  }
  SampleFormat target_output_sample_format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::SampleFormat>(data_->target_output_sample_format));
  }
  bool should_discard_decoder_delay() const {
    return data_->should_discard_decoder_delay;
  }
  inline void GetAacExtraDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAacExtraData(UserType* output) {
    
    auto* pointer = data_->aac_extra_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::AudioDecoderConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoDecoderConfigDataView {
 public:
  VideoDecoderConfigDataView() = default;

  VideoDecoderConfigDataView(
      internal::VideoDecoderConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadCodec(UserType* output) const {
    auto data_value = data_->codec;
    return mojo::internal::Deserialize<::media::mojom::VideoCodec>(
        data_value, output);
  }
  VideoCodec codec() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoCodec>(data_->codec));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadProfile(UserType* output) const {
    auto data_value = data_->profile;
    return mojo::internal::Deserialize<::media::mojom::VideoCodecProfile>(
        data_value, output);
  }
  VideoCodecProfile profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoCodecProfile>(data_->profile));
  }
  uint32_t level() const {
    return data_->level;
  }
  bool has_alpha() const {
    return data_->has_alpha;
  }
  inline void GetTransformationDataView(
      VideoTransformationDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransformation(UserType* output) {
    
    auto* pointer = data_->transformation.Get();
    return mojo::internal::Deserialize<::media::mojom::VideoTransformationDataView>(
        pointer, output, message_);
  }
  inline void GetCodedSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodedSize(UserType* output) {
    
    auto* pointer = data_->coded_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetVisibleRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVisibleRect(UserType* output) {
    
    auto* pointer = data_->visible_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetNaturalSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNaturalSize(UserType* output) {
    
    auto* pointer = data_->natural_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetExtraDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExtraData(UserType* output) {
    
    auto* pointer = data_->extra_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionScheme(UserType* output) const {
    auto data_value = data_->encryption_scheme;
    return mojo::internal::Deserialize<::media::mojom::EncryptionScheme>(
        data_value, output);
  }
  EncryptionScheme encryption_scheme() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::EncryptionScheme>(data_->encryption_scheme));
  }
  inline void GetColorSpaceInfoDataView(
      VideoColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpaceInfo(UserType* output) {
    
    auto* pointer = data_->color_space_info.Get();
    return mojo::internal::Deserialize<::media::mojom::VideoColorSpaceDataView>(
        pointer, output, message_);
  }
  inline void GetHdrMetadataDataView(
      ::gfx::mojom::HDRMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHdrMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::HDRMetadataDataView, UserType>(),
    "Attempting to read the optional `hdr_metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadHdrMetadata` instead "
    "of `ReadHdrMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->hdr_metadata.Get();
    return mojo::internal::Deserialize<::gfx::mojom::HDRMetadataDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoDecoderConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DecryptConfigDataView {
 public:
  DecryptConfigDataView() = default;

  DecryptConfigDataView(
      internal::DecryptConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionScheme(UserType* output) const {
    auto data_value = data_->encryption_scheme;
    return mojo::internal::Deserialize<::media::mojom::EncryptionScheme>(
        data_value, output);
  }
  EncryptionScheme encryption_scheme() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::EncryptionScheme>(data_->encryption_scheme));
  }
  inline void GetKeyIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyId(UserType* output) {
    
    auto* pointer = data_->key_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetIvDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIv(UserType* output) {
    
    auto* pointer = data_->iv.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetSubsamplesDataView(
      mojo::ArrayDataView<SubsampleEntryDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSubsamples(UserType* output) {
    
    auto* pointer = data_->subsamples.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::SubsampleEntryDataView>>(
        pointer, output, message_);
  }
  inline void GetEncryptionPatternDataView(
      ::media::mojom::EncryptionPatternDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionPattern(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::EncryptionPatternDataView, UserType>(),
    "Attempting to read the optional `encryption_pattern` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadEncryptionPattern` instead "
    "of `ReadEncryptionPattern if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->encryption_pattern.Get();
    return mojo::internal::Deserialize<::media::mojom::EncryptionPatternDataView>(
        pointer, output, message_);
  }
 private:
  internal::DecryptConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DecoderBufferDataView {
 public:
  DecoderBufferDataView() = default;

  DecoderBufferDataView(
      internal::DecoderBuffer_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDuration(UserType* output) {
    
    auto* pointer = data_->duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  bool is_end_of_stream() const {
    return data_->is_end_of_stream;
  }
  uint32_t data_size() const {
    return data_->data_size;
  }
  bool is_key_frame() const {
    return data_->is_key_frame;
  }
  inline void GetSideDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSideData(UserType* output) {
    
    auto* pointer = data_->side_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetDecryptConfigDataView(
      DecryptConfigDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecryptConfig(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::DecryptConfigDataView, UserType>(),
    "Attempting to read the optional `decrypt_config` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDecryptConfig` instead "
    "of `ReadDecryptConfig if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->decrypt_config.Get();
    return mojo::internal::Deserialize<::media::mojom::DecryptConfigDataView>(
        pointer, output, message_);
  }
  inline void GetFrontDiscardDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrontDiscard(UserType* output) {
    
    auto* pointer = data_->front_discard.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetBackDiscardDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBackDiscard(UserType* output) {
    
    auto* pointer = data_->back_discard.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::DecoderBuffer_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AudioBufferDataView {
 public:
  AudioBufferDataView() = default;

  AudioBufferDataView(
      internal::AudioBuffer_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadSampleFormat(UserType* output) const {
    auto data_value = data_->sample_format;
    return mojo::internal::Deserialize<::media::mojom::SampleFormat>(
        data_value, output);
  }
  SampleFormat sample_format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::SampleFormat>(data_->sample_format));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadChannelLayout(UserType* output) const {
    auto data_value = data_->channel_layout;
    return mojo::internal::Deserialize<::media::mojom::ChannelLayout>(
        data_value, output);
  }
  ChannelLayout channel_layout() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::ChannelLayout>(data_->channel_layout));
  }
  int32_t channel_count() const {
    return data_->channel_count;
  }
  int32_t sample_rate() const {
    return data_->sample_rate;
  }
  int32_t frame_count() const {
    return data_->frame_count;
  }
  bool end_of_stream() const {
    return data_->end_of_stream;
  }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
    auto* pointer = data_->data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::AudioBuffer_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoFrameMetadataDataView {
 public:
  VideoFrameMetadataDataView() = default;

  VideoFrameMetadataDataView(
      internal::VideoFrameMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  bool allow_overlay() const {
    return data_->allow_overlay;
  }
  inline void GetCaptureBeginTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCaptureBeginTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `capture_begin_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCaptureBeginTime` instead "
    "of `ReadCaptureBeginTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->capture_begin_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  inline void GetCaptureEndTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCaptureEndTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `capture_end_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCaptureEndTime` instead "
    "of `ReadCaptureEndTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->capture_end_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  bool has_capture_counter() const {
    return data_->has_capture_counter;
  }
  int32_t capture_counter() const {
    return data_->capture_counter;
  }
  inline void GetCaptureUpdateRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCaptureUpdateRect(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::RectDataView, UserType>(),
    "Attempting to read the optional `capture_update_rect` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCaptureUpdateRect` instead "
    "of `ReadCaptureUpdateRect if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->capture_update_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetSourceSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSourceSize(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::SizeDataView, UserType>(),
    "Attempting to read the optional `source_size` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSourceSize` instead "
    "of `ReadSourceSize if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->source_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetRegionCaptureRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRegionCaptureRect(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::RectDataView, UserType>(),
    "Attempting to read the optional `region_capture_rect` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRegionCaptureRect` instead "
    "of `ReadRegionCaptureRect if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->region_capture_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  uint32_t crop_version() const {
    return data_->crop_version;
  }
  bool copy_required() const {
    return data_->copy_required;
  }
  bool end_of_stream() const {
    return data_->end_of_stream;
  }
  inline void GetFrameDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrameDuration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `frame_duration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFrameDuration` instead "
    "of `ReadFrameDuration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->frame_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  bool has_frame_rate() const {
    return data_->has_frame_rate;
  }
  double frame_rate() const {
    return data_->frame_rate;
  }
  bool interactive_content() const {
    return data_->interactive_content;
  }
  inline void GetReferenceTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReferenceTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `reference_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadReferenceTime` instead "
    "of `ReadReferenceTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->reference_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  bool read_lock_fences_enabled() const {
    return data_->read_lock_fences_enabled;
  }
  inline void GetTransformationDataView(
      VideoTransformationDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransformation(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::VideoTransformationDataView, UserType>(),
    "Attempting to read the optional `transformation` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTransformation` instead "
    "of `ReadTransformation if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->transformation.Get();
    return mojo::internal::Deserialize<::media::mojom::VideoTransformationDataView>(
        pointer, output, message_);
  }
  bool texture_owner() const {
    return data_->texture_owner;
  }
  bool wants_promotion_hint() const {
    return data_->wants_promotion_hint;
  }
  bool protected_video() const {
    return data_->protected_video;
  }
  bool hw_protected() const {
    return data_->hw_protected;
  }
  bool is_webgpu_compatible() const {
    return data_->is_webgpu_compatible;
  }
  inline void GetOverlayPlaneIdDataView(
      ::mojo_base::mojom::UnguessableTokenDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOverlayPlaneId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::UnguessableTokenDataView, UserType>(),
    "Attempting to read the optional `overlay_plane_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadOverlayPlaneId` instead "
    "of `ReadOverlayPlaneId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->overlay_plane_id.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(
        pointer, output, message_);
  }
  bool power_efficient() const {
    return data_->power_efficient;
  }
  bool texture_origin_is_top_left() const {
    return data_->texture_origin_is_top_left;
  }
  bool has_device_scale_factor() const {
    return data_->has_device_scale_factor;
  }
  double device_scale_factor() const {
    return data_->device_scale_factor;
  }
  bool has_page_scale_factor() const {
    return data_->has_page_scale_factor;
  }
  double page_scale_factor() const {
    return data_->page_scale_factor;
  }
  bool has_root_scroll_offset_x() const {
    return data_->has_root_scroll_offset_x;
  }
  double root_scroll_offset_x() const {
    return data_->root_scroll_offset_x;
  }
  bool has_root_scroll_offset_y() const {
    return data_->has_root_scroll_offset_y;
  }
  double root_scroll_offset_y() const {
    return data_->root_scroll_offset_y;
  }
  bool has_top_controls_visible_height() const {
    return data_->has_top_controls_visible_height;
  }
  double top_controls_visible_height() const {
    return data_->top_controls_visible_height;
  }
  inline void GetDecodeBeginTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecodeBeginTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `decode_begin_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDecodeBeginTime` instead "
    "of `ReadDecodeBeginTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->decode_begin_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  inline void GetDecodeEndTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecodeEndTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `decode_end_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDecodeEndTime` instead "
    "of `ReadDecodeEndTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->decode_end_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  inline void GetProcessingTimeDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadProcessingTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `processing_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadProcessingTime` instead "
    "of `ReadProcessingTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->processing_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  bool has_rtp_timestamp() const {
    return data_->has_rtp_timestamp;
  }
  double rtp_timestamp() const {
    return data_->rtp_timestamp;
  }
  inline void GetReceiveTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReceiveTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `receive_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadReceiveTime` instead "
    "of `ReadReceiveTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->receive_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  inline void GetWallclockFrameDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadWallclockFrameDuration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `wallclock_frame_duration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadWallclockFrameDuration` instead "
    "of `ReadWallclockFrameDuration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->wallclock_frame_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoFrameMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoFrameDataView {
 public:
  VideoFrameDataView() = default;

  VideoFrameDataView(
      internal::VideoFrame_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadFormat(UserType* output) const {
    auto data_value = data_->format;
    return mojo::internal::Deserialize<::media::mojom::VideoPixelFormat>(
        data_value, output);
  }
  VideoPixelFormat format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoPixelFormat>(data_->format));
  }
  inline void GetCodedSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCodedSize(UserType* output) {
    
    auto* pointer = data_->coded_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetVisibleRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVisibleRect(UserType* output) {
    
    auto* pointer = data_->visible_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetNaturalSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNaturalSize(UserType* output) {
    
    auto* pointer = data_->natural_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      VideoFrameDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
    auto* pointer = !data_->data.is_null() ? &data_->data : nullptr;
    return mojo::internal::Deserialize<::media::mojom::VideoFrameDataDataView>(
        pointer, output, message_);
  }
  inline void GetMetadataDataView(
      VideoFrameMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMetadata(UserType* output) {
    
    auto* pointer = data_->metadata.Get();
    return mojo::internal::Deserialize<::media::mojom::VideoFrameMetadataDataView>(
        pointer, output, message_);
  }
  inline void GetColorSpaceDataView(
      ::gfx::mojom::ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) {
    
    auto* pointer = data_->color_space.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  inline void GetHdrMetadataDataView(
      ::gfx::mojom::HDRMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHdrMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::HDRMetadataDataView, UserType>(),
    "Attempting to read the optional `hdr_metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadHdrMetadata` instead "
    "of `ReadHdrMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->hdr_metadata.Get();
    return mojo::internal::Deserialize<::gfx::mojom::HDRMetadataDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoFrame_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EosVideoFrameDataDataView {
 public:
  EosVideoFrameDataDataView() = default;

  EosVideoFrameDataDataView(
      internal::EosVideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
 private:
  internal::EosVideoFrameData_Data* data_ = nullptr;
};



class SharedBufferVideoFrameDataDataView {
 public:
  SharedBufferVideoFrameDataDataView() = default;

  SharedBufferVideoFrameDataDataView(
      internal::SharedBufferVideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFrameDataDataView(
      ::mojo_base::mojom::UnsafeSharedMemoryRegionDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrameData(UserType* output) {
    
    auto* pointer = data_->frame_data.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::UnsafeSharedMemoryRegionDataView>(
        pointer, output, message_);
  }
  inline void GetStridesDataView(
      mojo::ArrayDataView<int32_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStrides(UserType* output) {
    
    auto* pointer = data_->strides.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<int32_t>>(
        pointer, output, message_);
  }
  inline void GetOffsetsDataView(
      mojo::ArrayDataView<uint32_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOffsets(UserType* output) {
    
    auto* pointer = data_->offsets.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint32_t>>(
        pointer, output, message_);
  }
 private:
  internal::SharedBufferVideoFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GpuMemoryBufferVideoFrameDataDataView {
 public:
  GpuMemoryBufferVideoFrameDataDataView() = default;

  GpuMemoryBufferVideoFrameDataDataView(
      internal::GpuMemoryBufferVideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetGpuMemoryBufferHandleDataView(
      ::gfx::mojom::GpuMemoryBufferHandleDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGpuMemoryBufferHandle(UserType* output) {
    
    auto* pointer = data_->gpu_memory_buffer_handle.Get();
    return mojo::internal::Deserialize<::gfx::mojom::GpuMemoryBufferHandleDataView>(
        pointer, output, message_);
  }
  inline void GetMailboxHolderDataView(
      mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailboxHolder(UserType* output) {
    
    auto* pointer = data_->mailbox_holder.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>>(
        pointer, output, message_);
  }
 private:
  internal::GpuMemoryBufferVideoFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class MailboxVideoFrameDataDataView {
 public:
  MailboxVideoFrameDataDataView() = default;

  MailboxVideoFrameDataDataView(
      internal::MailboxVideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetMailboxHolderDataView(
      mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailboxHolder(UserType* output) {
    
    auto* pointer = data_->mailbox_holder.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>>(
        pointer, output, message_);
  }
  inline void GetYcbcrDataDataView(
      ::gpu::mojom::VulkanYCbCrInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadYcbcrData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gpu::mojom::VulkanYCbCrInfoDataView, UserType>(),
    "Attempting to read the optional `ycbcr_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadYcbcrData` instead "
    "of `ReadYcbcrData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->ycbcr_data.Get();
    return mojo::internal::Deserialize<::gpu::mojom::VulkanYCbCrInfoDataView>(
        pointer, output, message_);
  }
 private:
  internal::MailboxVideoFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PipelineStatisticsDataView {
 public:
  PipelineStatisticsDataView() = default;

  PipelineStatisticsDataView(
      internal::PipelineStatistics_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t audio_bytes_decoded() const {
    return data_->audio_bytes_decoded;
  }
  uint64_t video_bytes_decoded() const {
    return data_->video_bytes_decoded;
  }
  uint32_t video_frames_decoded() const {
    return data_->video_frames_decoded;
  }
  uint32_t video_frames_dropped() const {
    return data_->video_frames_dropped;
  }
  int64_t audio_memory_usage() const {
    return data_->audio_memory_usage;
  }
  int64_t video_memory_usage() const {
    return data_->video_memory_usage;
  }
 private:
  internal::PipelineStatistics_Data* data_ = nullptr;
};



class PredictionFeaturesDataView {
 public:
  PredictionFeaturesDataView() = default;

  PredictionFeaturesDataView(
      internal::PredictionFeatures_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadProfile(UserType* output) const {
    auto data_value = data_->profile;
    return mojo::internal::Deserialize<::media::mojom::VideoCodecProfile>(
        data_value, output);
  }
  VideoCodecProfile profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoCodecProfile>(data_->profile));
  }
  inline void GetVideoSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVideoSize(UserType* output) {
    
    auto* pointer = data_->video_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  double frames_per_sec() const {
    return data_->frames_per_sec;
  }
  inline void GetKeySystemDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeySystem(UserType* output) {
    
    auto* pointer = data_->key_system.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool use_hw_secure_codecs() const {
    return data_->use_hw_secure_codecs;
  }
 private:
  internal::PredictionFeatures_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PredictionTargetsDataView {
 public:
  PredictionTargetsDataView() = default;

  PredictionTargetsDataView(
      internal::PredictionTargets_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t frames_decoded() const {
    return data_->frames_decoded;
  }
  uint32_t frames_dropped() const {
    return data_->frames_dropped;
  }
  uint32_t frames_power_efficient() const {
    return data_->frames_power_efficient;
  }
 private:
  internal::PredictionTargets_Data* data_ = nullptr;
};



class AudioPipelineInfoDataView {
 public:
  AudioPipelineInfoDataView() = default;

  AudioPipelineInfoDataView(
      internal::AudioPipelineInfo_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadDecoderType(UserType* output) const {
    auto data_value = data_->decoder_type;
    return mojo::internal::Deserialize<::media::mojom::AudioDecoderType>(
        data_value, output);
  }
  AudioDecoderType decoder_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::AudioDecoderType>(data_->decoder_type));
  }
  bool is_platform_decoder() const {
    return data_->is_platform_decoder;
  }
  bool has_decrypting_demuxer_stream() const {
    return data_->has_decrypting_demuxer_stream;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionType(UserType* output) const {
    auto data_value = data_->encryption_type;
    return mojo::internal::Deserialize<::media::mojom::EncryptionType>(
        data_value, output);
  }
  EncryptionType encryption_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::EncryptionType>(data_->encryption_type));
  }
 private:
  internal::AudioPipelineInfo_Data* data_ = nullptr;
};



class VideoPipelineInfoDataView {
 public:
  VideoPipelineInfoDataView() = default;

  VideoPipelineInfoDataView(
      internal::VideoPipelineInfo_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadDecoderType(UserType* output) const {
    auto data_value = data_->decoder_type;
    return mojo::internal::Deserialize<::media::mojom::VideoDecoderType>(
        data_value, output);
  }
  VideoDecoderType decoder_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoDecoderType>(data_->decoder_type));
  }
  bool is_platform_decoder() const {
    return data_->is_platform_decoder;
  }
  bool has_decrypting_demuxer_stream() const {
    return data_->has_decrypting_demuxer_stream;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEncryptionType(UserType* output) const {
    auto data_value = data_->encryption_type;
    return mojo::internal::Deserialize<::media::mojom::EncryptionType>(
        data_value, output);
  }
  EncryptionType encryption_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::EncryptionType>(data_->encryption_type));
  }
 private:
  internal::VideoPipelineInfo_Data* data_ = nullptr;
};



class StatusDataDataView {
 public:
  StatusDataDataView() = default;

  StatusDataDataView(
      internal::StatusData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetGroupDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGroup(UserType* output) {
    
    auto* pointer = data_->group.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  uint16_t code() const {
    return data_->code;
  }
  inline void GetMessageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMessage(UserType* output) {
    
    auto* pointer = data_->message.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetFramesDataView(
      mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrames(UserType* output) {
    
    auto* pointer = data_->frames.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>>(
        pointer, output, message_);
  }
  inline void GetCauseDataView(
      StatusDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCause(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::StatusDataDataView, UserType>(),
    "Attempting to read the optional `cause` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCause` instead "
    "of `ReadCause if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->cause.Get();
    return mojo::internal::Deserialize<::media::mojom::StatusDataDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      ::mojo_base::mojom::ValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
    auto* pointer = !data_->data.is_null() ? &data_->data : nullptr;
    return mojo::internal::Deserialize<::mojo_base::mojom::ValueDataView>(
        pointer, output, message_);
  }
  uint64_t packed_root_cause() const {
    return data_->packed_root_cause;
  }
 private:
  internal::StatusData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EncoderStatusDataView {
 public:
  EncoderStatusDataView() = default;

  EncoderStatusDataView(
      internal::EncoderStatus_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInternalDataView(
      StatusDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInternal(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::StatusDataDataView, UserType>(),
    "Attempting to read the optional `internal` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInternal` instead "
    "of `ReadInternal if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->internal.Get();
    return mojo::internal::Deserialize<::media::mojom::StatusDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::EncoderStatus_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DecoderStatusDataView {
 public:
  DecoderStatusDataView() = default;

  DecoderStatusDataView(
      internal::DecoderStatus_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInternalDataView(
      StatusDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInternal(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::StatusDataDataView, UserType>(),
    "Attempting to read the optional `internal` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInternal` instead "
    "of `ReadInternal if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->internal.Get();
    return mojo::internal::Deserialize<::media::mojom::StatusDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::DecoderStatus_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PipelineStatusDataView {
 public:
  PipelineStatusDataView() = default;

  PipelineStatusDataView(
      internal::PipelineStatus_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInternalDataView(
      StatusDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInternal(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::StatusDataDataView, UserType>(),
    "Attempting to read the optional `internal` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInternal` instead "
    "of `ReadInternal if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->internal.Get();
    return mojo::internal::Deserialize<::media::mojom::StatusDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::PipelineStatus_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoFrameDataDataView {
 public:
  using Tag = internal::VideoFrameData_Data::VideoFrameData_Tag;

  VideoFrameDataDataView() = default;

  VideoFrameDataDataView(
      internal::VideoFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_eos_data() const { return data_->tag == Tag::kEosData; }
  inline void GetEosDataDataView(
      EosVideoFrameDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadEosData(UserType* output) const {
    
    CHECK(is_eos_data());
    return mojo::internal::Deserialize<::media::mojom::EosVideoFrameDataDataView>(
        data_->data.f_eos_data.Get(), output, message_);
  }
  bool is_shared_buffer_data() const { return data_->tag == Tag::kSharedBufferData; }
  inline void GetSharedBufferDataDataView(
      SharedBufferVideoFrameDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadSharedBufferData(UserType* output) const {
    
    CHECK(is_shared_buffer_data());
    return mojo::internal::Deserialize<::media::mojom::SharedBufferVideoFrameDataDataView>(
        data_->data.f_shared_buffer_data.Get(), output, message_);
  }
  bool is_gpu_memory_buffer_data() const { return data_->tag == Tag::kGpuMemoryBufferData; }
  inline void GetGpuMemoryBufferDataDataView(
      GpuMemoryBufferVideoFrameDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadGpuMemoryBufferData(UserType* output) const {
    
    CHECK(is_gpu_memory_buffer_data());
    return mojo::internal::Deserialize<::media::mojom::GpuMemoryBufferVideoFrameDataDataView>(
        data_->data.f_gpu_memory_buffer_data.Get(), output, message_);
  }
  bool is_mailbox_data() const { return data_->tag == Tag::kMailboxData; }
  inline void GetMailboxDataDataView(
      MailboxVideoFrameDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadMailboxData(UserType* output) const {
    
    CHECK(is_mailbox_data());
    return mojo::internal::Deserialize<::media::mojom::MailboxVideoFrameDataDataView>(
        data_->data.f_mailbox_data.Get(), output, message_);
  }

 private:
  internal::VideoFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace media

namespace std {

template <>
struct hash<::media::mojom::VideoRotation>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoRotation> {};

template <>
struct hash<::media::mojom::EncryptionType>
    : public mojo::internal::EnumHashImpl<::media::mojom::EncryptionType> {};

template <>
struct hash<::media::mojom::SVCScalabilityMode>
    : public mojo::internal::EnumHashImpl<::media::mojom::SVCScalabilityMode> {};

template <>
struct hash<::media::mojom::CdmSessionClosedReason>
    : public mojo::internal::EnumHashImpl<::media::mojom::CdmSessionClosedReason> {};

template <>
struct hash<::media::mojom::MediaStreamType>
    : public mojo::internal::EnumHashImpl<::media::mojom::MediaStreamType> {};

template <>
struct hash<::media::mojom::InputStreamErrorCode>
    : public mojo::internal::EnumHashImpl<::media::mojom::InputStreamErrorCode> {};

template <>
struct hash<::media::mojom::RendererType>
    : public mojo::internal::EnumHashImpl<::media::mojom::RendererType> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoRotation, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::VideoRotation, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::VideoRotation>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::EncryptionType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::EncryptionType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::EncryptionType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::SVCScalabilityMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::SVCScalabilityMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::SVCScalabilityMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::CdmSessionClosedReason, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::CdmSessionClosedReason, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::CdmSessionClosedReason>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::MediaStreamType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::MediaStreamType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::MediaStreamType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::InputStreamErrorCode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::InputStreamErrorCode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::InputStreamErrorCode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::RendererType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::media::mojom::RendererType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::media::mojom::RendererType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoTransformationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoTransformationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoTransformation_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoRotation>(
        Traits::rotation(input), &fragment->rotation);
    fragment->mirrored = Traits::mirrored(input);
  }

  static bool Deserialize(::media::mojom::internal::VideoTransformation_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoTransformationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoColorSpaceDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoColorSpaceDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoColorSpace_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoColorSpace_PrimaryID>(
        Traits::primaries(input), &fragment->primaries);
    mojo::internal::Serialize<::media::mojom::VideoColorSpace_TransferID>(
        Traits::transfer(input), &fragment->transfer);
    mojo::internal::Serialize<::media::mojom::VideoColorSpace_MatrixID>(
        Traits::matrix(input), &fragment->matrix);
    mojo::internal::Serialize<::media::mojom::VideoColorSpace_RangeID>(
        Traits::range(input), &fragment->range);
  }

  static bool Deserialize(::media::mojom::internal::VideoColorSpace_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoColorSpaceDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::AudioDecoderConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::AudioDecoderConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::AudioDecoderConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::AudioCodec>(
        Traits::codec(input), &fragment->codec);
    mojo::internal::Serialize<::media::mojom::SampleFormat>(
        Traits::sample_format(input), &fragment->sample_format);
    mojo::internal::Serialize<::media::mojom::ChannelLayout>(
        Traits::channel_layout(input), &fragment->channel_layout);
    fragment->samples_per_second = Traits::samples_per_second(input);
    decltype(Traits::extra_data(input)) in_extra_data = Traits::extra_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->extra_data)::BaseType>
        extra_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams extra_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_extra_data, extra_data_fragment, &extra_data_validate_params);
    fragment->extra_data.Set(
        extra_data_fragment.is_null() ? nullptr : extra_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->extra_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null extra_data in AudioDecoderConfig struct");
    mojo::internal::Serialize<::media::mojom::EncryptionScheme>(
        Traits::encryption_scheme(input), &fragment->encryption_scheme);
    decltype(Traits::seek_preroll(input)) in_seek_preroll = Traits::seek_preroll(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->seek_preroll)::BaseType> seek_preroll_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_seek_preroll, seek_preroll_fragment);
    fragment->seek_preroll.Set(
        seek_preroll_fragment.is_null() ? nullptr : seek_preroll_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->seek_preroll.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null seek_preroll in AudioDecoderConfig struct");
    fragment->codec_delay = Traits::codec_delay(input);
    mojo::internal::Serialize<::media::mojom::AudioCodecProfile>(
        Traits::profile(input), &fragment->profile);
    mojo::internal::Serialize<::media::mojom::ChannelLayout>(
        Traits::target_output_channel_layout(input), &fragment->target_output_channel_layout);
    mojo::internal::Serialize<::media::mojom::SampleFormat>(
        Traits::target_output_sample_format(input), &fragment->target_output_sample_format);
    fragment->should_discard_decoder_delay = Traits::should_discard_decoder_delay(input);
    decltype(Traits::aac_extra_data(input)) in_aac_extra_data = Traits::aac_extra_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aac_extra_data)::BaseType>
        aac_extra_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aac_extra_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_aac_extra_data, aac_extra_data_fragment, &aac_extra_data_validate_params);
    fragment->aac_extra_data.Set(
        aac_extra_data_fragment.is_null() ? nullptr : aac_extra_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aac_extra_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aac_extra_data in AudioDecoderConfig struct");
  }

  static bool Deserialize(::media::mojom::internal::AudioDecoderConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::AudioDecoderConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoDecoderConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoDecoderConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoDecoderConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoCodec>(
        Traits::codec(input), &fragment->codec);
    mojo::internal::Serialize<::media::mojom::VideoCodecProfile>(
        Traits::profile(input), &fragment->profile);
    fragment->level = Traits::level(input);
    fragment->has_alpha = Traits::has_alpha(input);
    decltype(Traits::transformation(input)) in_transformation = Traits::transformation(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transformation)::BaseType> transformation_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::VideoTransformationDataView>(
        in_transformation, transformation_fragment);
    fragment->transformation.Set(
        transformation_fragment.is_null() ? nullptr : transformation_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->transformation.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transformation in VideoDecoderConfig struct");
    decltype(Traits::coded_size(input)) in_coded_size = Traits::coded_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->coded_size)::BaseType> coded_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_coded_size, coded_size_fragment);
    fragment->coded_size.Set(
        coded_size_fragment.is_null() ? nullptr : coded_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->coded_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coded_size in VideoDecoderConfig struct");
    decltype(Traits::visible_rect(input)) in_visible_rect = Traits::visible_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->visible_rect)::BaseType> visible_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_visible_rect, visible_rect_fragment);
    fragment->visible_rect.Set(
        visible_rect_fragment.is_null() ? nullptr : visible_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->visible_rect.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null visible_rect in VideoDecoderConfig struct");
    decltype(Traits::natural_size(input)) in_natural_size = Traits::natural_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->natural_size)::BaseType> natural_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_natural_size, natural_size_fragment);
    fragment->natural_size.Set(
        natural_size_fragment.is_null() ? nullptr : natural_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->natural_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null natural_size in VideoDecoderConfig struct");
    decltype(Traits::extra_data(input)) in_extra_data = Traits::extra_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->extra_data)::BaseType>
        extra_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams extra_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_extra_data, extra_data_fragment, &extra_data_validate_params);
    fragment->extra_data.Set(
        extra_data_fragment.is_null() ? nullptr : extra_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->extra_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null extra_data in VideoDecoderConfig struct");
    mojo::internal::Serialize<::media::mojom::EncryptionScheme>(
        Traits::encryption_scheme(input), &fragment->encryption_scheme);
    decltype(Traits::color_space_info(input)) in_color_space_info = Traits::color_space_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space_info)::BaseType> color_space_info_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::VideoColorSpaceDataView>(
        in_color_space_info, color_space_info_fragment);
    fragment->color_space_info.Set(
        color_space_info_fragment.is_null() ? nullptr : color_space_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space_info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space_info in VideoDecoderConfig struct");
    decltype(Traits::hdr_metadata(input)) in_hdr_metadata = Traits::hdr_metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->hdr_metadata)::BaseType> hdr_metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::HDRMetadataDataView>(
        in_hdr_metadata, hdr_metadata_fragment);
    fragment->hdr_metadata.Set(
        hdr_metadata_fragment.is_null() ? nullptr : hdr_metadata_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::VideoDecoderConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoDecoderConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::DecryptConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::DecryptConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::DecryptConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::EncryptionScheme>(
        Traits::encryption_scheme(input), &fragment->encryption_scheme);
    decltype(Traits::key_id(input)) in_key_id = Traits::key_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_id)::BaseType> key_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_key_id, key_id_fragment);
    fragment->key_id.Set(
        key_id_fragment.is_null() ? nullptr : key_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_id in DecryptConfig struct");
    decltype(Traits::iv(input)) in_iv = Traits::iv(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->iv)::BaseType> iv_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_iv, iv_fragment);
    fragment->iv.Set(
        iv_fragment.is_null() ? nullptr : iv_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->iv.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null iv in DecryptConfig struct");
    decltype(Traits::subsamples(input)) in_subsamples = Traits::subsamples(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->subsamples)::BaseType>
        subsamples_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams subsamples_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::SubsampleEntryDataView>>(
        in_subsamples, subsamples_fragment, &subsamples_validate_params);
    fragment->subsamples.Set(
        subsamples_fragment.is_null() ? nullptr : subsamples_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->subsamples.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null subsamples in DecryptConfig struct");
    decltype(Traits::encryption_pattern(input)) in_encryption_pattern = Traits::encryption_pattern(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->encryption_pattern)::BaseType> encryption_pattern_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::EncryptionPatternDataView>(
        in_encryption_pattern, encryption_pattern_fragment);
    fragment->encryption_pattern.Set(
        encryption_pattern_fragment.is_null() ? nullptr : encryption_pattern_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::DecryptConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::DecryptConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::DecoderBufferDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::DecoderBufferDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::DecoderBuffer_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in DecoderBuffer struct");
    decltype(Traits::duration(input)) in_duration = Traits::duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->duration)::BaseType> duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_duration, duration_fragment);
    fragment->duration.Set(
        duration_fragment.is_null() ? nullptr : duration_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->duration.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null duration in DecoderBuffer struct");
    fragment->is_end_of_stream = Traits::is_end_of_stream(input);
    fragment->data_size = Traits::data_size(input);
    fragment->is_key_frame = Traits::is_key_frame(input);
    decltype(Traits::side_data(input)) in_side_data = Traits::side_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->side_data)::BaseType>
        side_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams side_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_side_data, side_data_fragment, &side_data_validate_params);
    fragment->side_data.Set(
        side_data_fragment.is_null() ? nullptr : side_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->side_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null side_data in DecoderBuffer struct");
    decltype(Traits::decrypt_config(input)) in_decrypt_config = Traits::decrypt_config(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decrypt_config)::BaseType> decrypt_config_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::DecryptConfigDataView>(
        in_decrypt_config, decrypt_config_fragment);
    fragment->decrypt_config.Set(
        decrypt_config_fragment.is_null() ? nullptr : decrypt_config_fragment.data());
    decltype(Traits::front_discard(input)) in_front_discard = Traits::front_discard(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->front_discard)::BaseType> front_discard_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_front_discard, front_discard_fragment);
    fragment->front_discard.Set(
        front_discard_fragment.is_null() ? nullptr : front_discard_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->front_discard.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null front_discard in DecoderBuffer struct");
    decltype(Traits::back_discard(input)) in_back_discard = Traits::back_discard(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->back_discard)::BaseType> back_discard_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_back_discard, back_discard_fragment);
    fragment->back_discard.Set(
        back_discard_fragment.is_null() ? nullptr : back_discard_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->back_discard.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null back_discard in DecoderBuffer struct");
  }

  static bool Deserialize(::media::mojom::internal::DecoderBuffer_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::DecoderBufferDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::AudioBufferDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::AudioBufferDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::AudioBuffer_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::SampleFormat>(
        Traits::sample_format(input), &fragment->sample_format);
    mojo::internal::Serialize<::media::mojom::ChannelLayout>(
        Traits::channel_layout(input), &fragment->channel_layout);
    fragment->channel_count = Traits::channel_count(input);
    fragment->sample_rate = Traits::sample_rate(input);
    fragment->frame_count = Traits::frame_count(input);
    fragment->end_of_stream = Traits::end_of_stream(input);
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in AudioBuffer struct");
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->data)::BaseType>
        data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_data, data_fragment, &data_validate_params);
    fragment->data.Set(
        data_fragment.is_null() ? nullptr : data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null data in AudioBuffer struct");
  }

  static bool Deserialize(::media::mojom::internal::AudioBuffer_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::AudioBufferDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoFrameMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoFrameMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoFrameMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->allow_overlay = Traits::allow_overlay(input);
    decltype(Traits::capture_begin_time(input)) in_capture_begin_time = Traits::capture_begin_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->capture_begin_time)::BaseType> capture_begin_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_capture_begin_time, capture_begin_time_fragment);
    fragment->capture_begin_time.Set(
        capture_begin_time_fragment.is_null() ? nullptr : capture_begin_time_fragment.data());
    decltype(Traits::capture_end_time(input)) in_capture_end_time = Traits::capture_end_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->capture_end_time)::BaseType> capture_end_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_capture_end_time, capture_end_time_fragment);
    fragment->capture_end_time.Set(
        capture_end_time_fragment.is_null() ? nullptr : capture_end_time_fragment.data());
    fragment->has_capture_counter = Traits::has_capture_counter(input);
    fragment->capture_counter = Traits::capture_counter(input);
    decltype(Traits::capture_update_rect(input)) in_capture_update_rect = Traits::capture_update_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->capture_update_rect)::BaseType> capture_update_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_capture_update_rect, capture_update_rect_fragment);
    fragment->capture_update_rect.Set(
        capture_update_rect_fragment.is_null() ? nullptr : capture_update_rect_fragment.data());
    decltype(Traits::source_size(input)) in_source_size = Traits::source_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->source_size)::BaseType> source_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_source_size, source_size_fragment);
    fragment->source_size.Set(
        source_size_fragment.is_null() ? nullptr : source_size_fragment.data());
    decltype(Traits::region_capture_rect(input)) in_region_capture_rect = Traits::region_capture_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->region_capture_rect)::BaseType> region_capture_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_region_capture_rect, region_capture_rect_fragment);
    fragment->region_capture_rect.Set(
        region_capture_rect_fragment.is_null() ? nullptr : region_capture_rect_fragment.data());
    fragment->crop_version = Traits::crop_version(input);
    fragment->copy_required = Traits::copy_required(input);
    fragment->end_of_stream = Traits::end_of_stream(input);
    decltype(Traits::frame_duration(input)) in_frame_duration = Traits::frame_duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame_duration)::BaseType> frame_duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_frame_duration, frame_duration_fragment);
    fragment->frame_duration.Set(
        frame_duration_fragment.is_null() ? nullptr : frame_duration_fragment.data());
    fragment->has_frame_rate = Traits::has_frame_rate(input);
    fragment->frame_rate = Traits::frame_rate(input);
    fragment->interactive_content = Traits::interactive_content(input);
    decltype(Traits::reference_time(input)) in_reference_time = Traits::reference_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->reference_time)::BaseType> reference_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_reference_time, reference_time_fragment);
    fragment->reference_time.Set(
        reference_time_fragment.is_null() ? nullptr : reference_time_fragment.data());
    fragment->read_lock_fences_enabled = Traits::read_lock_fences_enabled(input);
    decltype(Traits::transformation(input)) in_transformation = Traits::transformation(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transformation)::BaseType> transformation_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::VideoTransformationDataView>(
        in_transformation, transformation_fragment);
    fragment->transformation.Set(
        transformation_fragment.is_null() ? nullptr : transformation_fragment.data());
    fragment->texture_owner = Traits::texture_owner(input);
    fragment->wants_promotion_hint = Traits::wants_promotion_hint(input);
    fragment->protected_video = Traits::protected_video(input);
    fragment->hw_protected = Traits::hw_protected(input);
    fragment->is_webgpu_compatible = Traits::is_webgpu_compatible(input);
    decltype(Traits::overlay_plane_id(input)) in_overlay_plane_id = Traits::overlay_plane_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->overlay_plane_id)::BaseType> overlay_plane_id_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
        in_overlay_plane_id, overlay_plane_id_fragment);
    fragment->overlay_plane_id.Set(
        overlay_plane_id_fragment.is_null() ? nullptr : overlay_plane_id_fragment.data());
    fragment->power_efficient = Traits::power_efficient(input);
    fragment->texture_origin_is_top_left = Traits::texture_origin_is_top_left(input);
    fragment->has_device_scale_factor = Traits::has_device_scale_factor(input);
    fragment->device_scale_factor = Traits::device_scale_factor(input);
    fragment->has_page_scale_factor = Traits::has_page_scale_factor(input);
    fragment->page_scale_factor = Traits::page_scale_factor(input);
    fragment->has_root_scroll_offset_x = Traits::has_root_scroll_offset_x(input);
    fragment->root_scroll_offset_x = Traits::root_scroll_offset_x(input);
    fragment->has_root_scroll_offset_y = Traits::has_root_scroll_offset_y(input);
    fragment->root_scroll_offset_y = Traits::root_scroll_offset_y(input);
    fragment->has_top_controls_visible_height = Traits::has_top_controls_visible_height(input);
    fragment->top_controls_visible_height = Traits::top_controls_visible_height(input);
    decltype(Traits::decode_begin_time(input)) in_decode_begin_time = Traits::decode_begin_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decode_begin_time)::BaseType> decode_begin_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_decode_begin_time, decode_begin_time_fragment);
    fragment->decode_begin_time.Set(
        decode_begin_time_fragment.is_null() ? nullptr : decode_begin_time_fragment.data());
    decltype(Traits::decode_end_time(input)) in_decode_end_time = Traits::decode_end_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decode_end_time)::BaseType> decode_end_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_decode_end_time, decode_end_time_fragment);
    fragment->decode_end_time.Set(
        decode_end_time_fragment.is_null() ? nullptr : decode_end_time_fragment.data());
    decltype(Traits::processing_time(input)) in_processing_time = Traits::processing_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->processing_time)::BaseType> processing_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_processing_time, processing_time_fragment);
    fragment->processing_time.Set(
        processing_time_fragment.is_null() ? nullptr : processing_time_fragment.data());
    fragment->has_rtp_timestamp = Traits::has_rtp_timestamp(input);
    fragment->rtp_timestamp = Traits::rtp_timestamp(input);
    decltype(Traits::receive_time(input)) in_receive_time = Traits::receive_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->receive_time)::BaseType> receive_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_receive_time, receive_time_fragment);
    fragment->receive_time.Set(
        receive_time_fragment.is_null() ? nullptr : receive_time_fragment.data());
    decltype(Traits::wallclock_frame_duration(input)) in_wallclock_frame_duration = Traits::wallclock_frame_duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->wallclock_frame_duration)::BaseType> wallclock_frame_duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_wallclock_frame_duration, wallclock_frame_duration_fragment);
    fragment->wallclock_frame_duration.Set(
        wallclock_frame_duration_fragment.is_null() ? nullptr : wallclock_frame_duration_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::VideoFrameMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoFrameMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoFrameDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoFrameDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoFrame_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoPixelFormat>(
        Traits::format(input), &fragment->format);
    decltype(Traits::coded_size(input)) in_coded_size = Traits::coded_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->coded_size)::BaseType> coded_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_coded_size, coded_size_fragment);
    fragment->coded_size.Set(
        coded_size_fragment.is_null() ? nullptr : coded_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->coded_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coded_size in VideoFrame struct");
    decltype(Traits::visible_rect(input)) in_visible_rect = Traits::visible_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->visible_rect)::BaseType> visible_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_visible_rect, visible_rect_fragment);
    fragment->visible_rect.Set(
        visible_rect_fragment.is_null() ? nullptr : visible_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->visible_rect.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null visible_rect in VideoFrame struct");
    decltype(Traits::natural_size(input)) in_natural_size = Traits::natural_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->natural_size)::BaseType> natural_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_natural_size, natural_size_fragment);
    fragment->natural_size.Set(
        natural_size_fragment.is_null() ? nullptr : natural_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->natural_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null natural_size in VideoFrame struct");
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in VideoFrame struct");
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<decltype(fragment->data)>
        data_fragment(fragment.message());
    data_fragment.Claim(&fragment->data);
    mojo::internal::Serialize<::media::mojom::VideoFrameDataDataView>(
        in_data, data_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null data in VideoFrame struct");
    decltype(Traits::metadata(input)) in_metadata = Traits::metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->metadata)::BaseType> metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::VideoFrameMetadataDataView>(
        in_metadata, metadata_fragment);
    fragment->metadata.Set(
        metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->metadata.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null metadata in VideoFrame struct");
    decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space)::BaseType> color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
        in_color_space, color_space_fragment);
    fragment->color_space.Set(
        color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space in VideoFrame struct");
    decltype(Traits::hdr_metadata(input)) in_hdr_metadata = Traits::hdr_metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->hdr_metadata)::BaseType> hdr_metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::HDRMetadataDataView>(
        in_hdr_metadata, hdr_metadata_fragment);
    fragment->hdr_metadata.Set(
        hdr_metadata_fragment.is_null() ? nullptr : hdr_metadata_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::VideoFrame_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoFrameDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::EosVideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::EosVideoFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::EosVideoFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
  }

  static bool Deserialize(::media::mojom::internal::EosVideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::EosVideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::SharedBufferVideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::SharedBufferVideoFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::SharedBufferVideoFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::frame_data(input)) in_frame_data = Traits::frame_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame_data)::BaseType> frame_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnsafeSharedMemoryRegionDataView>(
        in_frame_data, frame_data_fragment);
    fragment->frame_data.Set(
        frame_data_fragment.is_null() ? nullptr : frame_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->frame_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame_data in SharedBufferVideoFrameData struct");
    decltype(Traits::strides(input)) in_strides = Traits::strides(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->strides)::BaseType>
        strides_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams strides_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<int32_t>>(
        in_strides, strides_fragment, &strides_validate_params);
    fragment->strides.Set(
        strides_fragment.is_null() ? nullptr : strides_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->strides.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null strides in SharedBufferVideoFrameData struct");
    decltype(Traits::offsets(input)) in_offsets = Traits::offsets(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->offsets)::BaseType>
        offsets_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams offsets_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
        in_offsets, offsets_fragment, &offsets_validate_params);
    fragment->offsets.Set(
        offsets_fragment.is_null() ? nullptr : offsets_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->offsets.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null offsets in SharedBufferVideoFrameData struct");
  }

  static bool Deserialize(::media::mojom::internal::SharedBufferVideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::SharedBufferVideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::GpuMemoryBufferVideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::GpuMemoryBufferVideoFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::GpuMemoryBufferVideoFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::gpu_memory_buffer_handle(input)) in_gpu_memory_buffer_handle = Traits::gpu_memory_buffer_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->gpu_memory_buffer_handle)::BaseType> gpu_memory_buffer_handle_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::GpuMemoryBufferHandleDataView>(
        in_gpu_memory_buffer_handle, gpu_memory_buffer_handle_fragment);
    fragment->gpu_memory_buffer_handle.Set(
        gpu_memory_buffer_handle_fragment.is_null() ? nullptr : gpu_memory_buffer_handle_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->gpu_memory_buffer_handle.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null gpu_memory_buffer_handle in GpuMemoryBufferVideoFrameData struct");
    decltype(Traits::mailbox_holder(input)) in_mailbox_holder = Traits::mailbox_holder(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox_holder)::BaseType>
        mailbox_holder_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams mailbox_holder_validate_params(
        4, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>>(
        in_mailbox_holder, mailbox_holder_fragment, &mailbox_holder_validate_params);
    fragment->mailbox_holder.Set(
        mailbox_holder_fragment.is_null() ? nullptr : mailbox_holder_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox_holder.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox_holder in GpuMemoryBufferVideoFrameData struct");
  }

  static bool Deserialize(::media::mojom::internal::GpuMemoryBufferVideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::GpuMemoryBufferVideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::MailboxVideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::MailboxVideoFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::MailboxVideoFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::mailbox_holder(input)) in_mailbox_holder = Traits::mailbox_holder(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox_holder)::BaseType>
        mailbox_holder_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams mailbox_holder_validate_params(
        4, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>>(
        in_mailbox_holder, mailbox_holder_fragment, &mailbox_holder_validate_params);
    fragment->mailbox_holder.Set(
        mailbox_holder_fragment.is_null() ? nullptr : mailbox_holder_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox_holder.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox_holder in MailboxVideoFrameData struct");
    decltype(Traits::ycbcr_data(input)) in_ycbcr_data = Traits::ycbcr_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->ycbcr_data)::BaseType> ycbcr_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::VulkanYCbCrInfoDataView>(
        in_ycbcr_data, ycbcr_data_fragment);
    fragment->ycbcr_data.Set(
        ycbcr_data_fragment.is_null() ? nullptr : ycbcr_data_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::MailboxVideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::MailboxVideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::PipelineStatisticsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::PipelineStatisticsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::PipelineStatistics_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->audio_bytes_decoded = Traits::audio_bytes_decoded(input);
    fragment->video_bytes_decoded = Traits::video_bytes_decoded(input);
    fragment->video_frames_decoded = Traits::video_frames_decoded(input);
    fragment->video_frames_dropped = Traits::video_frames_dropped(input);
    fragment->audio_memory_usage = Traits::audio_memory_usage(input);
    fragment->video_memory_usage = Traits::video_memory_usage(input);
  }

  static bool Deserialize(::media::mojom::internal::PipelineStatistics_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::PipelineStatisticsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::PredictionFeaturesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::PredictionFeaturesDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::PredictionFeatures_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoCodecProfile>(
        Traits::profile(input), &fragment->profile);
    decltype(Traits::video_size(input)) in_video_size = Traits::video_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->video_size)::BaseType> video_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_video_size, video_size_fragment);
    fragment->video_size.Set(
        video_size_fragment.is_null() ? nullptr : video_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->video_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null video_size in PredictionFeatures struct");
    fragment->frames_per_sec = Traits::frames_per_sec(input);
    decltype(Traits::key_system(input)) in_key_system = Traits::key_system(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_system)::BaseType> key_system_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_key_system, key_system_fragment);
    fragment->key_system.Set(
        key_system_fragment.is_null() ? nullptr : key_system_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_system.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_system in PredictionFeatures struct");
    fragment->use_hw_secure_codecs = Traits::use_hw_secure_codecs(input);
  }

  static bool Deserialize(::media::mojom::internal::PredictionFeatures_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::PredictionFeaturesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::PredictionTargetsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::PredictionTargetsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::PredictionTargets_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->frames_decoded = Traits::frames_decoded(input);
    fragment->frames_dropped = Traits::frames_dropped(input);
    fragment->frames_power_efficient = Traits::frames_power_efficient(input);
  }

  static bool Deserialize(::media::mojom::internal::PredictionTargets_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::PredictionTargetsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::AudioPipelineInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::AudioPipelineInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::AudioPipelineInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::AudioDecoderType>(
        Traits::decoder_type(input), &fragment->decoder_type);
    fragment->is_platform_decoder = Traits::is_platform_decoder(input);
    fragment->has_decrypting_demuxer_stream = Traits::has_decrypting_demuxer_stream(input);
    mojo::internal::Serialize<::media::mojom::EncryptionType>(
        Traits::encryption_type(input), &fragment->encryption_type);
  }

  static bool Deserialize(::media::mojom::internal::AudioPipelineInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::AudioPipelineInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoPipelineInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::VideoPipelineInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::VideoPipelineInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::media::mojom::VideoDecoderType>(
        Traits::decoder_type(input), &fragment->decoder_type);
    fragment->is_platform_decoder = Traits::is_platform_decoder(input);
    fragment->has_decrypting_demuxer_stream = Traits::has_decrypting_demuxer_stream(input);
    mojo::internal::Serialize<::media::mojom::EncryptionType>(
        Traits::encryption_type(input), &fragment->encryption_type);
  }

  static bool Deserialize(::media::mojom::internal::VideoPipelineInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoPipelineInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::StatusDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::StatusDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::StatusData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::group(input)) in_group = Traits::group(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->group)::BaseType> group_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_group, group_fragment);
    fragment->group.Set(
        group_fragment.is_null() ? nullptr : group_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->group.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null group in StatusData struct");
    fragment->code = Traits::code(input);
    decltype(Traits::message(input)) in_message = Traits::message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->message)::BaseType> message_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_message, message_fragment);
    fragment->message.Set(
        message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null message in StatusData struct");
    decltype(Traits::frames(input)) in_frames = Traits::frames(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frames)::BaseType>
        frames_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams frames_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>>(
        in_frames, frames_fragment, &frames_validate_params);
    fragment->frames.Set(
        frames_fragment.is_null() ? nullptr : frames_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->frames.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frames in StatusData struct");
    decltype(Traits::cause(input)) in_cause = Traits::cause(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cause)::BaseType> cause_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::StatusDataDataView>(
        in_cause, cause_fragment);
    fragment->cause.Set(
        cause_fragment.is_null() ? nullptr : cause_fragment.data());
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<decltype(fragment->data)>
        data_fragment(fragment.message());
    data_fragment.Claim(&fragment->data);
    mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
        in_data, data_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null data in StatusData struct");
    fragment->packed_root_cause = Traits::packed_root_cause(input);
  }

  static bool Deserialize(::media::mojom::internal::StatusData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::StatusDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::EncoderStatusDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::EncoderStatusDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::EncoderStatus_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::internal(input)) in_internal = Traits::internal(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->internal)::BaseType> internal_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::StatusDataDataView>(
        in_internal, internal_fragment);
    fragment->internal.Set(
        internal_fragment.is_null() ? nullptr : internal_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::EncoderStatus_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::EncoderStatusDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::DecoderStatusDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::DecoderStatusDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::DecoderStatus_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::internal(input)) in_internal = Traits::internal(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->internal)::BaseType> internal_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::StatusDataDataView>(
        in_internal, internal_fragment);
    fragment->internal.Set(
        internal_fragment.is_null() ? nullptr : internal_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::DecoderStatus_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::DecoderStatusDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::PipelineStatusDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::PipelineStatusDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::PipelineStatus_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::internal(input)) in_internal = Traits::internal(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->internal)::BaseType> internal_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::StatusDataDataView>(
        in_internal, internal_fragment);
    fragment->internal.Set(
        internal_fragment.is_null() ? nullptr : internal_fragment.data());
  }

  static bool Deserialize(::media::mojom::internal::PipelineStatus_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::PipelineStatusDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::VideoFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::media::mojom::VideoFrameDataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::media::mojom::internal::VideoFrameData_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::media::mojom::VideoFrameDataDataView::Tag::kEosData: {
        decltype(Traits::eos_data(input))
            in_eos_data = Traits::eos_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_eos_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::EosVideoFrameDataDataView>(
            in_eos_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null eos_data in VideoFrameData union");
        fragment->data.f_eos_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::VideoFrameDataDataView::Tag::kSharedBufferData: {
        decltype(Traits::shared_buffer_data(input))
            in_shared_buffer_data = Traits::shared_buffer_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_shared_buffer_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::SharedBufferVideoFrameDataDataView>(
            in_shared_buffer_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null shared_buffer_data in VideoFrameData union");
        fragment->data.f_shared_buffer_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::VideoFrameDataDataView::Tag::kGpuMemoryBufferData: {
        decltype(Traits::gpu_memory_buffer_data(input))
            in_gpu_memory_buffer_data = Traits::gpu_memory_buffer_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_gpu_memory_buffer_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::GpuMemoryBufferVideoFrameDataDataView>(
            in_gpu_memory_buffer_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null gpu_memory_buffer_data in VideoFrameData union");
        fragment->data.f_gpu_memory_buffer_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::media::mojom::VideoFrameDataDataView::Tag::kMailboxData: {
        decltype(Traits::mailbox_data(input))
            in_mailbox_data = Traits::mailbox_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_mailbox_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::MailboxVideoFrameDataDataView>(
            in_mailbox_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null mailbox_data in VideoFrameData union");
        fragment->data.f_mailbox_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::media::mojom::internal::VideoFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::VideoFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace media {
namespace mojom {





inline void AudioDecoderConfigDataView::GetExtraDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->extra_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void AudioDecoderConfigDataView::GetSeekPrerollDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->seek_preroll.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void AudioDecoderConfigDataView::GetAacExtraDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->aac_extra_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void VideoDecoderConfigDataView::GetTransformationDataView(
    VideoTransformationDataView* output) {
  auto pointer = data_->transformation.Get();
  *output = VideoTransformationDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetCodedSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->coded_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetVisibleRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->visible_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetNaturalSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->natural_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetExtraDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->extra_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetColorSpaceInfoDataView(
    VideoColorSpaceDataView* output) {
  auto pointer = data_->color_space_info.Get();
  *output = VideoColorSpaceDataView(pointer, message_);
}
inline void VideoDecoderConfigDataView::GetHdrMetadataDataView(
    ::gfx::mojom::HDRMetadataDataView* output) {
  auto pointer = data_->hdr_metadata.Get();
  *output = ::gfx::mojom::HDRMetadataDataView(pointer, message_);
}


inline void DecryptConfigDataView::GetKeyIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->key_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void DecryptConfigDataView::GetIvDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->iv.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void DecryptConfigDataView::GetSubsamplesDataView(
    mojo::ArrayDataView<SubsampleEntryDataView>* output) {
  auto pointer = data_->subsamples.Get();
  *output = mojo::ArrayDataView<SubsampleEntryDataView>(pointer, message_);
}
inline void DecryptConfigDataView::GetEncryptionPatternDataView(
    ::media::mojom::EncryptionPatternDataView* output) {
  auto pointer = data_->encryption_pattern.Get();
  *output = ::media::mojom::EncryptionPatternDataView(pointer, message_);
}


inline void DecoderBufferDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetSideDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->side_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void DecoderBufferDataView::GetDecryptConfigDataView(
    DecryptConfigDataView* output) {
  auto pointer = data_->decrypt_config.Get();
  *output = DecryptConfigDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetFrontDiscardDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->front_discard.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DecoderBufferDataView::GetBackDiscardDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->back_discard.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void AudioBufferDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void AudioBufferDataView::GetDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void VideoFrameMetadataDataView::GetCaptureBeginTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->capture_begin_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetCaptureEndTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->capture_end_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetCaptureUpdateRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->capture_update_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetSourceSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->source_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetRegionCaptureRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->region_capture_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetFrameDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->frame_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetReferenceTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->reference_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetTransformationDataView(
    VideoTransformationDataView* output) {
  auto pointer = data_->transformation.Get();
  *output = VideoTransformationDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetOverlayPlaneIdDataView(
    ::mojo_base::mojom::UnguessableTokenDataView* output) {
  auto pointer = data_->overlay_plane_id.Get();
  *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetDecodeBeginTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->decode_begin_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetDecodeEndTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->decode_end_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetProcessingTimeDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->processing_time.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetReceiveTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->receive_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void VideoFrameMetadataDataView::GetWallclockFrameDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->wallclock_frame_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void VideoFrameDataView::GetCodedSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->coded_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoFrameDataView::GetVisibleRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->visible_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void VideoFrameDataView::GetNaturalSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->natural_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoFrameDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void VideoFrameDataView::GetDataDataView(
    VideoFrameDataDataView* output) {
  auto pointer = &data_->data;
  *output = VideoFrameDataDataView(pointer, message_);
}
inline void VideoFrameDataView::GetMetadataDataView(
    VideoFrameMetadataDataView* output) {
  auto pointer = data_->metadata.Get();
  *output = VideoFrameMetadataDataView(pointer, message_);
}
inline void VideoFrameDataView::GetColorSpaceDataView(
    ::gfx::mojom::ColorSpaceDataView* output) {
  auto pointer = data_->color_space.Get();
  *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}
inline void VideoFrameDataView::GetHdrMetadataDataView(
    ::gfx::mojom::HDRMetadataDataView* output) {
  auto pointer = data_->hdr_metadata.Get();
  *output = ::gfx::mojom::HDRMetadataDataView(pointer, message_);
}




inline void SharedBufferVideoFrameDataDataView::GetFrameDataDataView(
    ::mojo_base::mojom::UnsafeSharedMemoryRegionDataView* output) {
  auto pointer = data_->frame_data.Get();
  *output = ::mojo_base::mojom::UnsafeSharedMemoryRegionDataView(pointer, message_);
}
inline void SharedBufferVideoFrameDataDataView::GetStridesDataView(
    mojo::ArrayDataView<int32_t>* output) {
  auto pointer = data_->strides.Get();
  *output = mojo::ArrayDataView<int32_t>(pointer, message_);
}
inline void SharedBufferVideoFrameDataDataView::GetOffsetsDataView(
    mojo::ArrayDataView<uint32_t>* output) {
  auto pointer = data_->offsets.Get();
  *output = mojo::ArrayDataView<uint32_t>(pointer, message_);
}


inline void GpuMemoryBufferVideoFrameDataDataView::GetGpuMemoryBufferHandleDataView(
    ::gfx::mojom::GpuMemoryBufferHandleDataView* output) {
  auto pointer = data_->gpu_memory_buffer_handle.Get();
  *output = ::gfx::mojom::GpuMemoryBufferHandleDataView(pointer, message_);
}
inline void GpuMemoryBufferVideoFrameDataDataView::GetMailboxHolderDataView(
    mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>* output) {
  auto pointer = data_->mailbox_holder.Get();
  *output = mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>(pointer, message_);
}


inline void MailboxVideoFrameDataDataView::GetMailboxHolderDataView(
    mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>* output) {
  auto pointer = data_->mailbox_holder.Get();
  *output = mojo::ArrayDataView<::gpu::mojom::MailboxHolderDataView>(pointer, message_);
}
inline void MailboxVideoFrameDataDataView::GetYcbcrDataDataView(
    ::gpu::mojom::VulkanYCbCrInfoDataView* output) {
  auto pointer = data_->ycbcr_data.Get();
  *output = ::gpu::mojom::VulkanYCbCrInfoDataView(pointer, message_);
}




inline void PredictionFeaturesDataView::GetVideoSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->video_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void PredictionFeaturesDataView::GetKeySystemDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->key_system.Get();
  *output = mojo::StringDataView(pointer, message_);
}








inline void StatusDataDataView::GetGroupDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->group.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void StatusDataDataView::GetMessageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->message.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void StatusDataDataView::GetFramesDataView(
    mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>* output) {
  auto pointer = data_->frames.Get();
  *output = mojo::ArrayDataView<::mojo_base::mojom::ValueDataView>(pointer, message_);
}
inline void StatusDataDataView::GetCauseDataView(
    StatusDataDataView* output) {
  auto pointer = data_->cause.Get();
  *output = StatusDataDataView(pointer, message_);
}
inline void StatusDataDataView::GetDataDataView(
    ::mojo_base::mojom::ValueDataView* output) {
  auto pointer = &data_->data;
  *output = ::mojo_base::mojom::ValueDataView(pointer, message_);
}


inline void EncoderStatusDataView::GetInternalDataView(
    StatusDataDataView* output) {
  auto pointer = data_->internal.Get();
  *output = StatusDataDataView(pointer, message_);
}


inline void DecoderStatusDataView::GetInternalDataView(
    StatusDataDataView* output) {
  auto pointer = data_->internal.Get();
  *output = StatusDataDataView(pointer, message_);
}


inline void PipelineStatusDataView::GetInternalDataView(
    StatusDataDataView* output) {
  auto pointer = data_->internal.Get();
  *output = StatusDataDataView(pointer, message_);
}


inline void VideoFrameDataDataView::GetEosDataDataView(
    EosVideoFrameDataDataView* output) const {
  CHECK(is_eos_data());
  *output = EosVideoFrameDataDataView(data_->data.f_eos_data.Get(), message_);
}
inline void VideoFrameDataDataView::GetSharedBufferDataDataView(
    SharedBufferVideoFrameDataDataView* output) const {
  CHECK(is_shared_buffer_data());
  *output = SharedBufferVideoFrameDataDataView(data_->data.f_shared_buffer_data.Get(), message_);
}
inline void VideoFrameDataDataView::GetGpuMemoryBufferDataDataView(
    GpuMemoryBufferVideoFrameDataDataView* output) const {
  CHECK(is_gpu_memory_buffer_data());
  *output = GpuMemoryBufferVideoFrameDataDataView(data_->data.f_gpu_memory_buffer_data.Get(), message_);
}
inline void VideoFrameDataDataView::GetMailboxDataDataView(
    MailboxVideoFrameDataDataView* output) const {
  CHECK(is_mailbox_data());
  *output = MailboxVideoFrameDataDataView(data_->data.f_mailbox_data.Get(), message_);
}


}  // namespace mojom
}  // namespace media

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::VideoRotation> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoRotation value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::EncryptionType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::EncryptionType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::SVCScalabilityMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::SVCScalabilityMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::CdmSessionClosedReason> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::CdmSessionClosedReason value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::MediaStreamType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::MediaStreamType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::InputStreamErrorCode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::InputStreamErrorCode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::media::mojom::RendererType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::RendererType value);
};

} // namespace perfetto

#endif  // MEDIA_MOJO_MOJOM_MEDIA_TYPES_MOJOM_SHARED_H_