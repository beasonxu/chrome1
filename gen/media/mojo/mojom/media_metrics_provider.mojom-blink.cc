// media/mojo/mojom/media_metrics_provider.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "media/mojo/mojom/media_metrics_provider.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "media/mojo/mojom/media_metrics_provider.mojom-params-data.h"
#include "media/mojo/mojom/media_metrics_provider.mojom-shared-message-ids.h"

#include "media/mojo/mojom/media_metrics_provider.mojom-blink-import-headers.h"
#include "media/mojo/mojom/media_metrics_provider.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef MEDIA_MOJO_MOJOM_MEDIA_METRICS_PROVIDER_MOJOM_BLINK_JUMBO_H_
#define MEDIA_MOJO_MOJOM_MEDIA_METRICS_PROVIDER_MOJOM_BLINK_JUMBO_H_
#endif



namespace media {
namespace mojom {
namespace blink {
const char MediaMetricsProvider::Name_[] = "media.mojom.MediaMetricsProvider";

MediaMetricsProvider::IPCStableHashFunction MediaMetricsProvider::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kMediaMetricsProvider_Initialize_Name: {
      return &MediaMetricsProvider::Initialize_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_OnError_Name: {
      return &MediaMetricsProvider::OnError_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_OnFallback_Name: {
      return &MediaMetricsProvider::OnFallback_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetHasPlayed_Name: {
      return &MediaMetricsProvider::SetHasPlayed_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetHaveEnough_Name: {
      return &MediaMetricsProvider::SetHaveEnough_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetIsEME_Name: {
      return &MediaMetricsProvider::SetIsEME_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetTimeToMetadata_Name: {
      return &MediaMetricsProvider::SetTimeToMetadata_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetTimeToFirstFrame_Name: {
      return &MediaMetricsProvider::SetTimeToFirstFrame_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetTimeToPlayReady_Name: {
      return &MediaMetricsProvider::SetTimeToPlayReady_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetRendererType_Name: {
      return &MediaMetricsProvider::SetRendererType_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetKeySystem_Name: {
      return &MediaMetricsProvider::SetKeySystem_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetIsHardwareSecure_Name: {
      return &MediaMetricsProvider::SetIsHardwareSecure_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetContainerName_Name: {
      return &MediaMetricsProvider::SetContainerName_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_AcquireWatchTimeRecorder_Name: {
      return &MediaMetricsProvider::AcquireWatchTimeRecorder_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Name: {
      return &MediaMetricsProvider::AcquireVideoDecodeStatsRecorder_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_AcquireLearningTaskController_Name: {
      return &MediaMetricsProvider::AcquireLearningTaskController_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_AcquirePlaybackEventsRecorder_Name: {
      return &MediaMetricsProvider::AcquirePlaybackEventsRecorder_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetHasAudio_Name: {
      return &MediaMetricsProvider::SetHasAudio_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetHasVideo_Name: {
      return &MediaMetricsProvider::SetHasVideo_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetVideoPipelineInfo_Name: {
      return &MediaMetricsProvider::SetVideoPipelineInfo_Sym::IPCStableHash;
    }
    case internal::kMediaMetricsProvider_SetAudioPipelineInfo_Name: {
      return &MediaMetricsProvider::SetAudioPipelineInfo_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* MediaMetricsProvider::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kMediaMetricsProvider_Initialize_Name:
            return "Receive media::mojom::MediaMetricsProvider::Initialize";
      case internal::kMediaMetricsProvider_OnError_Name:
            return "Receive media::mojom::MediaMetricsProvider::OnError";
      case internal::kMediaMetricsProvider_OnFallback_Name:
            return "Receive media::mojom::MediaMetricsProvider::OnFallback";
      case internal::kMediaMetricsProvider_SetHasPlayed_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetHasPlayed";
      case internal::kMediaMetricsProvider_SetHaveEnough_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetHaveEnough";
      case internal::kMediaMetricsProvider_SetIsEME_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetIsEME";
      case internal::kMediaMetricsProvider_SetTimeToMetadata_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetTimeToMetadata";
      case internal::kMediaMetricsProvider_SetTimeToFirstFrame_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetTimeToFirstFrame";
      case internal::kMediaMetricsProvider_SetTimeToPlayReady_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetTimeToPlayReady";
      case internal::kMediaMetricsProvider_SetRendererType_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetRendererType";
      case internal::kMediaMetricsProvider_SetKeySystem_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetKeySystem";
      case internal::kMediaMetricsProvider_SetIsHardwareSecure_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetIsHardwareSecure";
      case internal::kMediaMetricsProvider_SetContainerName_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetContainerName";
      case internal::kMediaMetricsProvider_AcquireWatchTimeRecorder_Name:
            return "Receive media::mojom::MediaMetricsProvider::AcquireWatchTimeRecorder";
      case internal::kMediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Name:
            return "Receive media::mojom::MediaMetricsProvider::AcquireVideoDecodeStatsRecorder";
      case internal::kMediaMetricsProvider_AcquireLearningTaskController_Name:
            return "Receive media::mojom::MediaMetricsProvider::AcquireLearningTaskController";
      case internal::kMediaMetricsProvider_AcquirePlaybackEventsRecorder_Name:
            return "Receive media::mojom::MediaMetricsProvider::AcquirePlaybackEventsRecorder";
      case internal::kMediaMetricsProvider_SetHasAudio_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetHasAudio";
      case internal::kMediaMetricsProvider_SetHasVideo_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetHasVideo";
      case internal::kMediaMetricsProvider_SetVideoPipelineInfo_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetVideoPipelineInfo";
      case internal::kMediaMetricsProvider_SetAudioPipelineInfo_Name:
            return "Receive media::mojom::MediaMetricsProvider::SetAudioPipelineInfo";
    }
  } else {
    switch (message.name()) {
      case internal::kMediaMetricsProvider_Initialize_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::Initialize";
      case internal::kMediaMetricsProvider_OnError_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::OnError";
      case internal::kMediaMetricsProvider_OnFallback_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::OnFallback";
      case internal::kMediaMetricsProvider_SetHasPlayed_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetHasPlayed";
      case internal::kMediaMetricsProvider_SetHaveEnough_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetHaveEnough";
      case internal::kMediaMetricsProvider_SetIsEME_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetIsEME";
      case internal::kMediaMetricsProvider_SetTimeToMetadata_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetTimeToMetadata";
      case internal::kMediaMetricsProvider_SetTimeToFirstFrame_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetTimeToFirstFrame";
      case internal::kMediaMetricsProvider_SetTimeToPlayReady_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetTimeToPlayReady";
      case internal::kMediaMetricsProvider_SetRendererType_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetRendererType";
      case internal::kMediaMetricsProvider_SetKeySystem_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetKeySystem";
      case internal::kMediaMetricsProvider_SetIsHardwareSecure_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetIsHardwareSecure";
      case internal::kMediaMetricsProvider_SetContainerName_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetContainerName";
      case internal::kMediaMetricsProvider_AcquireWatchTimeRecorder_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::AcquireWatchTimeRecorder";
      case internal::kMediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::AcquireVideoDecodeStatsRecorder";
      case internal::kMediaMetricsProvider_AcquireLearningTaskController_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::AcquireLearningTaskController";
      case internal::kMediaMetricsProvider_AcquirePlaybackEventsRecorder_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::AcquirePlaybackEventsRecorder";
      case internal::kMediaMetricsProvider_SetHasAudio_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetHasAudio";
      case internal::kMediaMetricsProvider_SetHasVideo_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetHasVideo";
      case internal::kMediaMetricsProvider_SetVideoPipelineInfo_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetVideoPipelineInfo";
      case internal::kMediaMetricsProvider_SetAudioPipelineInfo_Name:
            return "Receive reply media::mojom::MediaMetricsProvider::SetAudioPipelineInfo";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t MediaMetricsProvider::Initialize_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::Initialize");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::OnError_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::OnError");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::OnFallback_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::OnFallback");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetHasPlayed_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetHasPlayed");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetHaveEnough_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetHaveEnough");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetIsEME_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetIsEME");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetTimeToMetadata_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetTimeToMetadata");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetTimeToFirstFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetTimeToFirstFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetTimeToPlayReady_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetTimeToPlayReady");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetRendererType_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetRendererType");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetKeySystem_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetKeySystem");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetIsHardwareSecure_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetIsHardwareSecure");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetContainerName_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetContainerName");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::AcquireWatchTimeRecorder_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::AcquireWatchTimeRecorder");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::AcquireVideoDecodeStatsRecorder_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::AcquireVideoDecodeStatsRecorder");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::AcquireLearningTaskController_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::AcquireLearningTaskController");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::AcquirePlaybackEventsRecorder_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::AcquirePlaybackEventsRecorder");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetHasAudio_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetHasAudio");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetHasVideo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetHasVideo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetVideoPipelineInfo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetVideoPipelineInfo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaMetricsProvider::SetAudioPipelineInfo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media::mojom::MediaMetricsProvider::SetAudioPipelineInfo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

MediaMetricsProviderProxy::MediaMetricsProviderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void MediaMetricsProviderProxy::Initialize(
    bool in_is_mse, MediaURLScheme in_url_scheme, ::media::mojom::blink::MediaStreamType in_stream_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::Initialize", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_mse"), in_is_mse,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url_scheme"), in_url_scheme,
                        "<value of type MediaURLScheme>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("stream_type"), in_stream_type,
                        "<value of type ::media::mojom::blink::MediaStreamType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_Initialize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_Initialize_Params_Data> params(
          message);
  params.Allocate();
  params->is_mse = in_is_mse;
  mojo::internal::Serialize<::media::mojom::MediaURLScheme>(
      in_url_scheme, &params->url_scheme);
  mojo::internal::Serialize<::media::mojom::MediaStreamType>(
      in_stream_type, &params->stream_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("Initialize");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::OnError(
    ::media::mojom::blink::PipelineStatusPtr in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::OnError", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::media::mojom::blink::PipelineStatusPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_OnError_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_OnError_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->status)::BaseType> status_fragment(
          params.message());
  mojo::internal::Serialize<::media::mojom::PipelineStatusDataView>(
      in_status, status_fragment);
  params->status.Set(
      status_fragment.is_null() ? nullptr : status_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->status.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null status in MediaMetricsProvider.OnError request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("OnError");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::OnFallback(
    ::media::mojom::blink::PipelineStatusPtr in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::OnFallback", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::media::mojom::blink::PipelineStatusPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_OnFallback_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_OnFallback_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->status)::BaseType> status_fragment(
          params.message());
  mojo::internal::Serialize<::media::mojom::PipelineStatusDataView>(
      in_status, status_fragment);
  params->status.Set(
      status_fragment.is_null() ? nullptr : status_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->status.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null status in MediaMetricsProvider.OnFallback request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("OnFallback");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetHasPlayed(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media::mojom::MediaMetricsProvider::SetHasPlayed");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetHasPlayed_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetHasPlayed_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetHasPlayed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetHaveEnough(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media::mojom::MediaMetricsProvider::SetHaveEnough");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetHaveEnough_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetHaveEnough_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetHaveEnough");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetIsEME(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media::mojom::MediaMetricsProvider::SetIsEME");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetIsEME_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetIsEME_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetIsEME");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetTimeToMetadata(
    ::base::TimeDelta in_elapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetTimeToMetadata", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("elapsed"), in_elapsed,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetTimeToMetadata_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetTimeToMetadata_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->elapsed)::BaseType> elapsed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_elapsed, elapsed_fragment);
  params->elapsed.Set(
      elapsed_fragment.is_null() ? nullptr : elapsed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->elapsed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null elapsed in MediaMetricsProvider.SetTimeToMetadata request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetTimeToMetadata");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetTimeToFirstFrame(
    ::base::TimeDelta in_elapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetTimeToFirstFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("elapsed"), in_elapsed,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetTimeToFirstFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetTimeToFirstFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->elapsed)::BaseType> elapsed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_elapsed, elapsed_fragment);
  params->elapsed.Set(
      elapsed_fragment.is_null() ? nullptr : elapsed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->elapsed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null elapsed in MediaMetricsProvider.SetTimeToFirstFrame request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetTimeToFirstFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetTimeToPlayReady(
    ::base::TimeDelta in_elapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetTimeToPlayReady", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("elapsed"), in_elapsed,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetTimeToPlayReady_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetTimeToPlayReady_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->elapsed)::BaseType> elapsed_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_elapsed, elapsed_fragment);
  params->elapsed.Set(
      elapsed_fragment.is_null() ? nullptr : elapsed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->elapsed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null elapsed in MediaMetricsProvider.SetTimeToPlayReady request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetTimeToPlayReady");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetRendererType(
    ::media::mojom::blink::RendererType in_renderer_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetRendererType", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("renderer_type"), in_renderer_type,
                        "<value of type ::media::mojom::blink::RendererType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetRendererType_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetRendererType_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media::mojom::RendererType>(
      in_renderer_type, &params->renderer_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetRendererType");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetKeySystem(
    const WTF::String& in_key_system) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetKeySystem", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_system"), in_key_system,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetKeySystem_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetKeySystem_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key_system)::BaseType> key_system_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_key_system, key_system_fragment);
  params->key_system.Set(
      key_system_fragment.is_null() ? nullptr : key_system_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_system.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_system in MediaMetricsProvider.SetKeySystem request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetKeySystem");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetIsHardwareSecure(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media::mojom::MediaMetricsProvider::SetIsHardwareSecure");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetIsHardwareSecure_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetIsHardwareSecure_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetIsHardwareSecure");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetContainerName(
    ::media::mojom::blink::MediaContainerName in_container_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetContainerName", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("container_name"), in_container_name,
                        "<value of type ::media::mojom::blink::MediaContainerName>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetContainerName_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetContainerName_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media::mojom::MediaContainerName>(
      in_container_name, &params->container_name);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetContainerName");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::AcquireWatchTimeRecorder(
    ::media::mojom::blink::PlaybackPropertiesPtr in_properties, ::mojo::PendingReceiver<::media::mojom::blink::WatchTimeRecorder> in_recorder) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::AcquireWatchTimeRecorder", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("properties"), in_properties,
                        "<value of type ::media::mojom::blink::PlaybackPropertiesPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("recorder"), in_recorder,
                        "<value of type ::mojo::PendingReceiver<::media::mojom::blink::WatchTimeRecorder>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_AcquireWatchTimeRecorder_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_AcquireWatchTimeRecorder_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->properties)::BaseType> properties_fragment(
          params.message());
  mojo::internal::Serialize<::media::mojom::PlaybackPropertiesDataView>(
      in_properties, properties_fragment);
  params->properties.Set(
      properties_fragment.is_null() ? nullptr : properties_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in MediaMetricsProvider.AcquireWatchTimeRecorder request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::media::mojom::WatchTimeRecorderInterfaceBase>>(
      in_recorder, &params->recorder, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->recorder),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid recorder in MediaMetricsProvider.AcquireWatchTimeRecorder request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("AcquireWatchTimeRecorder");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::AcquireVideoDecodeStatsRecorder(
    ::mojo::PendingReceiver<::media::mojom::blink::VideoDecodeStatsRecorder> in_recorder) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::AcquireVideoDecodeStatsRecorder", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("recorder"), in_recorder,
                        "<value of type ::mojo::PendingReceiver<::media::mojom::blink::VideoDecodeStatsRecorder>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::media::mojom::VideoDecodeStatsRecorderInterfaceBase>>(
      in_recorder, &params->recorder, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->recorder),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid recorder in MediaMetricsProvider.AcquireVideoDecodeStatsRecorder request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("AcquireVideoDecodeStatsRecorder");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::AcquireLearningTaskController(
    const WTF::String& in_taskName, ::mojo::PendingReceiver<::media::learning::mojom::blink::LearningTaskController> in_controller) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::AcquireLearningTaskController", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("taskName"), in_taskName,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("controller"), in_controller,
                        "<value of type ::mojo::PendingReceiver<::media::learning::mojom::blink::LearningTaskController>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_AcquireLearningTaskController_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_AcquireLearningTaskController_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->taskName)::BaseType> taskName_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_taskName, taskName_fragment);
  params->taskName.Set(
      taskName_fragment.is_null() ? nullptr : taskName_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->taskName.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null taskName in MediaMetricsProvider.AcquireLearningTaskController request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::media::learning::mojom::LearningTaskControllerInterfaceBase>>(
      in_controller, &params->controller, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->controller),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid controller in MediaMetricsProvider.AcquireLearningTaskController request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("AcquireLearningTaskController");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::AcquirePlaybackEventsRecorder(
    ::mojo::PendingReceiver<::media::mojom::blink::PlaybackEventsRecorder> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::AcquirePlaybackEventsRecorder", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::media::mojom::blink::PlaybackEventsRecorder>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_AcquirePlaybackEventsRecorder_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_AcquirePlaybackEventsRecorder_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::media::mojom::PlaybackEventsRecorderInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in MediaMetricsProvider.AcquirePlaybackEventsRecorder request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("AcquirePlaybackEventsRecorder");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetHasAudio(
    ::media::mojom::blink::AudioCodec in_codec) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetHasAudio", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("codec"), in_codec,
                        "<value of type ::media::mojom::blink::AudioCodec>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetHasAudio_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetHasAudio_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media::mojom::AudioCodec>(
      in_codec, &params->codec);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetHasAudio");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetHasVideo(
    ::media::mojom::blink::VideoCodec in_codec) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetHasVideo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("codec"), in_codec,
                        "<value of type ::media::mojom::blink::VideoCodec>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetHasVideo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetHasVideo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media::mojom::VideoCodec>(
      in_codec, &params->codec);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetHasVideo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetVideoPipelineInfo(
    ::media::mojom::blink::VideoPipelineInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetVideoPipelineInfo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type ::media::mojom::blink::VideoPipelineInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetVideoPipelineInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetVideoPipelineInfo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::media::mojom::VideoPipelineInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in MediaMetricsProvider.SetVideoPipelineInfo request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetVideoPipelineInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaMetricsProviderProxy::SetAudioPipelineInfo(
    ::media::mojom::blink::AudioPipelineInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media::mojom::MediaMetricsProvider::SetAudioPipelineInfo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type ::media::mojom::blink::AudioPipelineInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaMetricsProvider_SetAudioPipelineInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media::mojom::internal::MediaMetricsProvider_SetAudioPipelineInfo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::media::mojom::AudioPipelineInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in MediaMetricsProvider.SetAudioPipelineInfo request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaMetricsProvider::Name_);
  message.set_method_name("SetAudioPipelineInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool MediaMetricsProviderStubDispatch::Accept(
    MediaMetricsProvider* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kMediaMetricsProvider_Initialize_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_Initialize_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_Initialize_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_mse{};
      MediaURLScheme p_url_scheme{};
      ::media::mojom::blink::MediaStreamType p_stream_type{};
      MediaMetricsProvider_Initialize_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_mse = input_data_view.is_mse();
      if (success && !input_data_view.ReadUrlScheme(&p_url_scheme))
        success = false;
      if (success && !input_data_view.ReadStreamType(&p_stream_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Initialize(
std::move(p_is_mse), 
std::move(p_url_scheme), 
std::move(p_stream_type));
      return true;
    }
    case internal::kMediaMetricsProvider_OnError_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_OnError_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_OnError_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::PipelineStatusPtr p_status{};
      MediaMetricsProvider_OnError_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStatus(&p_status))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnError(
std::move(p_status));
      return true;
    }
    case internal::kMediaMetricsProvider_OnFallback_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_OnFallback_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_OnFallback_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::PipelineStatusPtr p_status{};
      MediaMetricsProvider_OnFallback_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStatus(&p_status))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnFallback(
std::move(p_status));
      return true;
    }
    case internal::kMediaMetricsProvider_SetHasPlayed_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetHasPlayed_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetHasPlayed_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaMetricsProvider_SetHasPlayed_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHasPlayed();
      return true;
    }
    case internal::kMediaMetricsProvider_SetHaveEnough_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetHaveEnough_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetHaveEnough_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaMetricsProvider_SetHaveEnough_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHaveEnough();
      return true;
    }
    case internal::kMediaMetricsProvider_SetIsEME_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetIsEME_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetIsEME_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaMetricsProvider_SetIsEME_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetIsEME();
      return true;
    }
    case internal::kMediaMetricsProvider_SetTimeToMetadata_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetTimeToMetadata_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetTimeToMetadata_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_elapsed{};
      MediaMetricsProvider_SetTimeToMetadata_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadElapsed(&p_elapsed))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTimeToMetadata(
std::move(p_elapsed));
      return true;
    }
    case internal::kMediaMetricsProvider_SetTimeToFirstFrame_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetTimeToFirstFrame_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetTimeToFirstFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_elapsed{};
      MediaMetricsProvider_SetTimeToFirstFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadElapsed(&p_elapsed))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTimeToFirstFrame(
std::move(p_elapsed));
      return true;
    }
    case internal::kMediaMetricsProvider_SetTimeToPlayReady_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetTimeToPlayReady_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetTimeToPlayReady_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_elapsed{};
      MediaMetricsProvider_SetTimeToPlayReady_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadElapsed(&p_elapsed))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTimeToPlayReady(
std::move(p_elapsed));
      return true;
    }
    case internal::kMediaMetricsProvider_SetRendererType_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetRendererType_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetRendererType_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::RendererType p_renderer_type{};
      MediaMetricsProvider_SetRendererType_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRendererType(&p_renderer_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetRendererType(
std::move(p_renderer_type));
      return true;
    }
    case internal::kMediaMetricsProvider_SetKeySystem_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetKeySystem_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetKeySystem_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::String p_key_system{};
      MediaMetricsProvider_SetKeySystem_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKeySystem(&p_key_system))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetKeySystem(
std::move(p_key_system));
      return true;
    }
    case internal::kMediaMetricsProvider_SetIsHardwareSecure_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetIsHardwareSecure_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetIsHardwareSecure_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaMetricsProvider_SetIsHardwareSecure_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetIsHardwareSecure();
      return true;
    }
    case internal::kMediaMetricsProvider_SetContainerName_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetContainerName_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetContainerName_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::MediaContainerName p_container_name{};
      MediaMetricsProvider_SetContainerName_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadContainerName(&p_container_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetContainerName(
std::move(p_container_name));
      return true;
    }
    case internal::kMediaMetricsProvider_AcquireWatchTimeRecorder_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_AcquireWatchTimeRecorder_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_AcquireWatchTimeRecorder_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::PlaybackPropertiesPtr p_properties{};
      ::mojo::PendingReceiver<::media::mojom::blink::WatchTimeRecorder> p_recorder{};
      MediaMetricsProvider_AcquireWatchTimeRecorder_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadProperties(&p_properties))
        success = false;
      if (success) {
        p_recorder =
            input_data_view.TakeRecorder<decltype(p_recorder)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AcquireWatchTimeRecorder(
std::move(p_properties), 
std::move(p_recorder));
      return true;
    }
    case internal::kMediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::media::mojom::blink::VideoDecodeStatsRecorder> p_recorder{};
      MediaMetricsProvider_AcquireVideoDecodeStatsRecorder_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_recorder =
            input_data_view.TakeRecorder<decltype(p_recorder)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AcquireVideoDecodeStatsRecorder(
std::move(p_recorder));
      return true;
    }
    case internal::kMediaMetricsProvider_AcquireLearningTaskController_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_AcquireLearningTaskController_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_AcquireLearningTaskController_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::String p_taskName{};
      ::mojo::PendingReceiver<::media::learning::mojom::blink::LearningTaskController> p_controller{};
      MediaMetricsProvider_AcquireLearningTaskController_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTaskName(&p_taskName))
        success = false;
      if (success) {
        p_controller =
            input_data_view.TakeController<decltype(p_controller)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AcquireLearningTaskController(
std::move(p_taskName), 
std::move(p_controller));
      return true;
    }
    case internal::kMediaMetricsProvider_AcquirePlaybackEventsRecorder_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_AcquirePlaybackEventsRecorder_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_AcquirePlaybackEventsRecorder_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::media::mojom::blink::PlaybackEventsRecorder> p_receiver{};
      MediaMetricsProvider_AcquirePlaybackEventsRecorder_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AcquirePlaybackEventsRecorder(
std::move(p_receiver));
      return true;
    }
    case internal::kMediaMetricsProvider_SetHasAudio_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetHasAudio_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetHasAudio_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::AudioCodec p_codec{};
      MediaMetricsProvider_SetHasAudio_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCodec(&p_codec))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHasAudio(
std::move(p_codec));
      return true;
    }
    case internal::kMediaMetricsProvider_SetHasVideo_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetHasVideo_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetHasVideo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::VideoCodec p_codec{};
      MediaMetricsProvider_SetHasVideo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCodec(&p_codec))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHasVideo(
std::move(p_codec));
      return true;
    }
    case internal::kMediaMetricsProvider_SetVideoPipelineInfo_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetVideoPipelineInfo_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetVideoPipelineInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::VideoPipelineInfoPtr p_info{};
      MediaMetricsProvider_SetVideoPipelineInfo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetVideoPipelineInfo(
std::move(p_info));
      return true;
    }
    case internal::kMediaMetricsProvider_SetAudioPipelineInfo_Name: {

      DCHECK(message->is_serialized());
      internal::MediaMetricsProvider_SetAudioPipelineInfo_Params_Data* params =
          reinterpret_cast<internal::MediaMetricsProvider_SetAudioPipelineInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::media::mojom::blink::AudioPipelineInfoPtr p_info{};
      MediaMetricsProvider_SetAudioPipelineInfo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaMetricsProvider::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetAudioPipelineInfo(
std::move(p_info));
      return true;
    }
  }
  return false;
}

// static
bool MediaMetricsProviderStubDispatch::AcceptWithResponder(
    MediaMetricsProvider* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kMediaMetricsProvider_Initialize_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_OnError_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_OnFallback_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetHasPlayed_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetHaveEnough_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetIsEME_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetTimeToMetadata_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetTimeToFirstFrame_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetTimeToPlayReady_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetRendererType_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetKeySystem_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetIsHardwareSecure_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetContainerName_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_AcquireWatchTimeRecorder_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_AcquireLearningTaskController_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_AcquirePlaybackEventsRecorder_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetHasAudio_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetHasVideo_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetVideoPipelineInfo_Name: {
      break;
    }
    case internal::kMediaMetricsProvider_SetAudioPipelineInfo_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kMediaMetricsProviderValidationInfo[] = {
    {&internal::MediaMetricsProvider_Initialize_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_OnError_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_OnFallback_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetHasPlayed_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetHaveEnough_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetIsEME_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetTimeToMetadata_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetTimeToFirstFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetTimeToPlayReady_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetRendererType_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetKeySystem_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetIsHardwareSecure_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetContainerName_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_AcquireWatchTimeRecorder_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_AcquireVideoDecodeStatsRecorder_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_AcquireLearningTaskController_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_AcquirePlaybackEventsRecorder_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetHasAudio_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetHasVideo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetVideoPipelineInfo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaMetricsProvider_SetAudioPipelineInfo_Params_Data::Validate,
     nullptr /* no response */},
};

bool MediaMetricsProviderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::media::mojom::blink::MediaMetricsProvider::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kMediaMetricsProviderValidationInfo);
}



}  // namespace blink
}  // namespace mojom
}  // namespace media


namespace mojo {

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace media {
namespace mojom {
namespace blink {


void MediaMetricsProviderInterceptorForTesting::Initialize(bool is_mse, MediaURLScheme url_scheme, ::media::mojom::blink::MediaStreamType stream_type) {
  GetForwardingInterface()->Initialize(std::move(is_mse), std::move(url_scheme), std::move(stream_type));
}
void MediaMetricsProviderInterceptorForTesting::OnError(::media::mojom::blink::PipelineStatusPtr status) {
  GetForwardingInterface()->OnError(std::move(status));
}
void MediaMetricsProviderInterceptorForTesting::OnFallback(::media::mojom::blink::PipelineStatusPtr status) {
  GetForwardingInterface()->OnFallback(std::move(status));
}
void MediaMetricsProviderInterceptorForTesting::SetHasPlayed() {
  GetForwardingInterface()->SetHasPlayed();
}
void MediaMetricsProviderInterceptorForTesting::SetHaveEnough() {
  GetForwardingInterface()->SetHaveEnough();
}
void MediaMetricsProviderInterceptorForTesting::SetIsEME() {
  GetForwardingInterface()->SetIsEME();
}
void MediaMetricsProviderInterceptorForTesting::SetTimeToMetadata(::base::TimeDelta elapsed) {
  GetForwardingInterface()->SetTimeToMetadata(std::move(elapsed));
}
void MediaMetricsProviderInterceptorForTesting::SetTimeToFirstFrame(::base::TimeDelta elapsed) {
  GetForwardingInterface()->SetTimeToFirstFrame(std::move(elapsed));
}
void MediaMetricsProviderInterceptorForTesting::SetTimeToPlayReady(::base::TimeDelta elapsed) {
  GetForwardingInterface()->SetTimeToPlayReady(std::move(elapsed));
}
void MediaMetricsProviderInterceptorForTesting::SetRendererType(::media::mojom::blink::RendererType renderer_type) {
  GetForwardingInterface()->SetRendererType(std::move(renderer_type));
}
void MediaMetricsProviderInterceptorForTesting::SetKeySystem(const WTF::String& key_system) {
  GetForwardingInterface()->SetKeySystem(std::move(key_system));
}
void MediaMetricsProviderInterceptorForTesting::SetIsHardwareSecure() {
  GetForwardingInterface()->SetIsHardwareSecure();
}
void MediaMetricsProviderInterceptorForTesting::SetContainerName(::media::mojom::blink::MediaContainerName container_name) {
  GetForwardingInterface()->SetContainerName(std::move(container_name));
}
void MediaMetricsProviderInterceptorForTesting::AcquireWatchTimeRecorder(::media::mojom::blink::PlaybackPropertiesPtr properties, ::mojo::PendingReceiver<::media::mojom::blink::WatchTimeRecorder> recorder) {
  GetForwardingInterface()->AcquireWatchTimeRecorder(std::move(properties), std::move(recorder));
}
void MediaMetricsProviderInterceptorForTesting::AcquireVideoDecodeStatsRecorder(::mojo::PendingReceiver<::media::mojom::blink::VideoDecodeStatsRecorder> recorder) {
  GetForwardingInterface()->AcquireVideoDecodeStatsRecorder(std::move(recorder));
}
void MediaMetricsProviderInterceptorForTesting::AcquireLearningTaskController(const WTF::String& taskName, ::mojo::PendingReceiver<::media::learning::mojom::blink::LearningTaskController> controller) {
  GetForwardingInterface()->AcquireLearningTaskController(std::move(taskName), std::move(controller));
}
void MediaMetricsProviderInterceptorForTesting::AcquirePlaybackEventsRecorder(::mojo::PendingReceiver<::media::mojom::blink::PlaybackEventsRecorder> receiver) {
  GetForwardingInterface()->AcquirePlaybackEventsRecorder(std::move(receiver));
}
void MediaMetricsProviderInterceptorForTesting::SetHasAudio(::media::mojom::blink::AudioCodec codec) {
  GetForwardingInterface()->SetHasAudio(std::move(codec));
}
void MediaMetricsProviderInterceptorForTesting::SetHasVideo(::media::mojom::blink::VideoCodec codec) {
  GetForwardingInterface()->SetHasVideo(std::move(codec));
}
void MediaMetricsProviderInterceptorForTesting::SetVideoPipelineInfo(::media::mojom::blink::VideoPipelineInfoPtr info) {
  GetForwardingInterface()->SetVideoPipelineInfo(std::move(info));
}
void MediaMetricsProviderInterceptorForTesting::SetAudioPipelineInfo(::media::mojom::blink::AudioPipelineInfoPtr info) {
  GetForwardingInterface()->SetAudioPipelineInfo(std::move(info));
}
MediaMetricsProviderAsyncWaiter::MediaMetricsProviderAsyncWaiter(
    MediaMetricsProvider* proxy) : proxy_(proxy) {}

MediaMetricsProviderAsyncWaiter::~MediaMetricsProviderAsyncWaiter() = default;






}  // namespace blink
}  // namespace mojom
}  // namespace media


#if defined(__clang__)
#pragma clang diagnostic pop
#endif