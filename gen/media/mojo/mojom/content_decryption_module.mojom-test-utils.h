// media/mojo/mojom/content_decryption_module.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_CONTENT_DECRYPTION_MODULE_MOJOM_TEST_UTILS_H_
#define MEDIA_MOJO_MOJOM_CONTENT_DECRYPTION_MODULE_MOJOM_TEST_UTILS_H_

#include "media/mojo/mojom/content_decryption_module.mojom.h"


namespace media {
namespace mojom {


class  ContentDecryptionModuleInterceptorForTesting : public ContentDecryptionModule {
  virtual ContentDecryptionModule* GetForwardingInterface() = 0;
  void SetClient(::mojo::PendingAssociatedRemote<ContentDecryptionModuleClient> client) override;
  void SetServerCertificate(const std::vector<uint8_t>& certificate_data, SetServerCertificateCallback callback) override;
  void GetStatusForPolicy(::media::HdcpVersion min_hdcp_version, GetStatusForPolicyCallback callback) override;
  void CreateSessionAndGenerateRequest(::media::CdmSessionType session_type, ::media::EmeInitDataType init_data_type, const std::vector<uint8_t>& init_data, CreateSessionAndGenerateRequestCallback callback) override;
  void LoadSession(::media::CdmSessionType session_type, const std::string& session_id, LoadSessionCallback callback) override;
  void UpdateSession(const std::string& session_id, const std::vector<uint8_t>& response, UpdateSessionCallback callback) override;
  void CloseSession(const std::string& session_id, CloseSessionCallback callback) override;
  void RemoveSession(const std::string& session_id, RemoveSessionCallback callback) override;
};
class  ContentDecryptionModuleAsyncWaiter {
 public:
  explicit ContentDecryptionModuleAsyncWaiter(ContentDecryptionModule* proxy);

  ContentDecryptionModuleAsyncWaiter(const ContentDecryptionModuleAsyncWaiter&) = delete;
  ContentDecryptionModuleAsyncWaiter& operator=(const ContentDecryptionModuleAsyncWaiter&) = delete;

  ~ContentDecryptionModuleAsyncWaiter();
  void SetServerCertificate(
      const std::vector<uint8_t>& certificate_data, CdmPromiseResultPtr* out_result);
  void GetStatusForPolicy(
      ::media::HdcpVersion min_hdcp_version, CdmPromiseResultPtr* out_result, ::media::CdmKeyInformation::KeyStatus* out_key_status);
  void CreateSessionAndGenerateRequest(
      ::media::CdmSessionType session_type, ::media::EmeInitDataType init_data_type, const std::vector<uint8_t>& init_data, CdmPromiseResultPtr* out_result, std::string* out_session_id);
  void LoadSession(
      ::media::CdmSessionType session_type, const std::string& session_id, CdmPromiseResultPtr* out_result, std::string* out_session_id);
  void UpdateSession(
      const std::string& session_id, const std::vector<uint8_t>& response, CdmPromiseResultPtr* out_result);
  void CloseSession(
      const std::string& session_id, CdmPromiseResultPtr* out_result);
  void RemoveSession(
      const std::string& session_id, CdmPromiseResultPtr* out_result);

 private:
  ContentDecryptionModule* const proxy_;
};


class  ContentDecryptionModuleClientInterceptorForTesting : public ContentDecryptionModuleClient {
  virtual ContentDecryptionModuleClient* GetForwardingInterface() = 0;
  void OnSessionMessage(const std::string& session_id, ::media::CdmMessageType message_type, const std::vector<uint8_t>& message) override;
  void OnSessionClosed(const std::string& session_id, ::media::CdmSessionClosedReason reason) override;
  void OnSessionKeysChange(const std::string& session_id, bool has_additional_usable_key, std::vector<::std::unique_ptr<::media::CdmKeyInformation>> keys_info) override;
  void OnSessionExpirationUpdate(const std::string& session_id, double new_expiry_time_sec) override;
};
class  ContentDecryptionModuleClientAsyncWaiter {
 public:
  explicit ContentDecryptionModuleClientAsyncWaiter(ContentDecryptionModuleClient* proxy);

  ContentDecryptionModuleClientAsyncWaiter(const ContentDecryptionModuleClientAsyncWaiter&) = delete;
  ContentDecryptionModuleClientAsyncWaiter& operator=(const ContentDecryptionModuleClientAsyncWaiter&) = delete;

  ~ContentDecryptionModuleClientAsyncWaiter();

 private:
  ContentDecryptionModuleClient* const proxy_;
};


class  CdmFactoryInterceptorForTesting : public CdmFactory {
  virtual CdmFactory* GetForwardingInterface() = 0;
  void CreateCdm(const ::media::CdmConfig& cdm_config, CreateCdmCallback callback) override;
};
class  CdmFactoryAsyncWaiter {
 public:
  explicit CdmFactoryAsyncWaiter(CdmFactory* proxy);

  CdmFactoryAsyncWaiter(const CdmFactoryAsyncWaiter&) = delete;
  CdmFactoryAsyncWaiter& operator=(const CdmFactoryAsyncWaiter&) = delete;

  ~CdmFactoryAsyncWaiter();
  void CreateCdm(
      const ::media::CdmConfig& cdm_config, ::mojo::PendingRemote<ContentDecryptionModule>* out_cdm, CdmContextPtr* out_cdm_context, std::string* out_error_message);

 private:
  CdmFactory* const proxy_;
};




}  // namespace mojom
}  // namespace media

#endif  // MEDIA_MOJO_MOJOM_CONTENT_DECRYPTION_MODULE_MOJOM_TEST_UTILS_H_