// content/services/auction_worklet/public/mojom/seller_worklet.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "content/services/auction_worklet/public/mojom/seller_worklet.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "content/services/auction_worklet/public/mojom/seller_worklet.mojom-params-data.h"
#include "content/services/auction_worklet/public/mojom/seller_worklet.mojom-shared-message-ids.h"

#include "content/services/auction_worklet/public/mojom/seller_worklet.mojom-import-headers.h"
#include "content/services/auction_worklet/public/mojom/seller_worklet.mojom-test-utils.h"


#ifndef CONTENT_SERVICES_AUCTION_WORKLET_PUBLIC_MOJOM_SELLER_WORKLET_MOJOM_JUMBO_H_
#define CONTENT_SERVICES_AUCTION_WORKLET_PUBLIC_MOJOM_SELLER_WORKLET_MOJOM_JUMBO_H_
#endif



namespace auction_worklet {
namespace mojom {
ComponentAuctionModifiedBidParams::ComponentAuctionModifiedBidParams()
    : ad(),
      bid(),
      has_bid() {}

ComponentAuctionModifiedBidParams::ComponentAuctionModifiedBidParams(
    const std::string& ad_in,
    double bid_in,
    bool has_bid_in)
    : ad(std::move(ad_in)),
      bid(std::move(bid_in)),
      has_bid(std::move(has_bid_in)) {}

ComponentAuctionModifiedBidParams::~ComponentAuctionModifiedBidParams() = default;
size_t ComponentAuctionModifiedBidParams::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->ad);
  seed = mojo::internal::Hash(seed, this->bid);
  seed = mojo::internal::Hash(seed, this->has_bid);
  return seed;
}

void ComponentAuctionModifiedBidParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ad"), this->ad,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bid"), this->bid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_bid"), this->has_bid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ComponentAuctionModifiedBidParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ComponentAuctionReportResultParams::ComponentAuctionReportResultParams()
    : top_level_seller_signals(),
      modified_bid(),
      has_modified_bid() {}

ComponentAuctionReportResultParams::ComponentAuctionReportResultParams(
    const std::string& top_level_seller_signals_in,
    double modified_bid_in,
    bool has_modified_bid_in)
    : top_level_seller_signals(std::move(top_level_seller_signals_in)),
      modified_bid(std::move(modified_bid_in)),
      has_modified_bid(std::move(has_modified_bid_in)) {}

ComponentAuctionReportResultParams::~ComponentAuctionReportResultParams() = default;
size_t ComponentAuctionReportResultParams::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->top_level_seller_signals);
  seed = mojo::internal::Hash(seed, this->modified_bid);
  seed = mojo::internal::Hash(seed, this->has_modified_bid);
  return seed;
}

void ComponentAuctionReportResultParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "top_level_seller_signals"), this->top_level_seller_signals,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "modified_bid"), this->modified_bid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_modified_bid"), this->has_modified_bid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ComponentAuctionReportResultParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ComponentAuctionOtherSeller::ComponentAuctionOtherSeller() : tag_(Tag::kTopLevelSeller) {
  data_.top_level_seller = new ::url::Origin;
}

ComponentAuctionOtherSeller::~ComponentAuctionOtherSeller() {
  DestroyActive();
}


void ComponentAuctionOtherSeller::set_top_level_seller(
    const ::url::Origin& top_level_seller) {
  if (tag_ == Tag::kTopLevelSeller) {
    *(data_.top_level_seller) = std::move(top_level_seller);
  } else {
    DestroyActive();
    tag_ = Tag::kTopLevelSeller;
    data_.top_level_seller = new ::url::Origin(
        std::move(top_level_seller));
  }
}
void ComponentAuctionOtherSeller::set_component_seller(
    const ::url::Origin& component_seller) {
  if (tag_ == Tag::kComponentSeller) {
    *(data_.component_seller) = std::move(component_seller);
  } else {
    DestroyActive();
    tag_ = Tag::kComponentSeller;
    data_.component_seller = new ::url::Origin(
        std::move(component_seller));
  }
}

void ComponentAuctionOtherSeller::DestroyActive() {
  switch (tag_) {

    case Tag::kTopLevelSeller:

      delete data_.top_level_seller;
      break;
    case Tag::kComponentSeller:

      delete data_.component_seller;
      break;
  }
}

bool ComponentAuctionOtherSeller::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char SellerWorklet::Name_[] = "auction_worklet.mojom.SellerWorklet";

SellerWorklet::IPCStableHashFunction SellerWorklet::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSellerWorklet_ScoreAd_Name: {
      return &SellerWorklet::ScoreAd_Sym::IPCStableHash;
    }
    case internal::kSellerWorklet_SendPendingSignalsRequests_Name: {
      return &SellerWorklet::SendPendingSignalsRequests_Sym::IPCStableHash;
    }
    case internal::kSellerWorklet_ReportResult_Name: {
      return &SellerWorklet::ReportResult_Sym::IPCStableHash;
    }
    case internal::kSellerWorklet_ConnectDevToolsAgent_Name: {
      return &SellerWorklet::ConnectDevToolsAgent_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SellerWorklet::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSellerWorklet_ScoreAd_Name:
            return "Receive auction_worklet::mojom::SellerWorklet::ScoreAd";
      case internal::kSellerWorklet_SendPendingSignalsRequests_Name:
            return "Receive auction_worklet::mojom::SellerWorklet::SendPendingSignalsRequests";
      case internal::kSellerWorklet_ReportResult_Name:
            return "Receive auction_worklet::mojom::SellerWorklet::ReportResult";
      case internal::kSellerWorklet_ConnectDevToolsAgent_Name:
            return "Receive auction_worklet::mojom::SellerWorklet::ConnectDevToolsAgent";
    }
  } else {
    switch (message.name()) {
      case internal::kSellerWorklet_ScoreAd_Name:
            return "Receive reply auction_worklet::mojom::SellerWorklet::ScoreAd";
      case internal::kSellerWorklet_SendPendingSignalsRequests_Name:
            return "Receive reply auction_worklet::mojom::SellerWorklet::SendPendingSignalsRequests";
      case internal::kSellerWorklet_ReportResult_Name:
            return "Receive reply auction_worklet::mojom::SellerWorklet::ReportResult";
      case internal::kSellerWorklet_ConnectDevToolsAgent_Name:
            return "Receive reply auction_worklet::mojom::SellerWorklet::ConnectDevToolsAgent";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SellerWorklet::ScoreAd_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::SellerWorklet::ScoreAd");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SellerWorklet::SendPendingSignalsRequests_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::SellerWorklet::SendPendingSignalsRequests");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SellerWorklet::ReportResult_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::SellerWorklet::ReportResult");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SellerWorklet::ConnectDevToolsAgent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::SellerWorklet::ConnectDevToolsAgent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class SellerWorklet_ScoreAd_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SellerWorklet_ScoreAd_ForwardToCallback(
      SellerWorklet::ScoreAdCallback callback
      ) : callback_(std::move(callback)) {
  }

  SellerWorklet_ScoreAd_ForwardToCallback(const SellerWorklet_ScoreAd_ForwardToCallback&) = delete;
  SellerWorklet_ScoreAd_ForwardToCallback& operator=(const SellerWorklet_ScoreAd_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SellerWorklet::ScoreAdCallback callback_;
};

class SellerWorklet_ReportResult_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SellerWorklet_ReportResult_ForwardToCallback(
      SellerWorklet::ReportResultCallback callback
      ) : callback_(std::move(callback)) {
  }

  SellerWorklet_ReportResult_ForwardToCallback(const SellerWorklet_ReportResult_ForwardToCallback&) = delete;
  SellerWorklet_ReportResult_ForwardToCallback& operator=(const SellerWorklet_ReportResult_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SellerWorklet::ReportResultCallback callback_;
};

SellerWorkletProxy::SellerWorkletProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SellerWorkletProxy::ScoreAd(
    const std::string& in_ad_metadata_json, double in_bid, const ::blink::AuctionConfig::NonSharedParams& in_auction_ad_config_non_shared_params, ComponentAuctionOtherSellerPtr in_browser_signals_other_seller, const ::url::Origin& in_browser_signal_interest_group_owner, const ::GURL& in_browser_signal_render_url, const std::vector<::GURL>& in_browser_signal_ad_component_render_urls, uint32_t in_browser_signal_bidding_duration_msecs, absl::optional<::base::TimeDelta> in_seller_timeout, uint64_t in_trace_id, ScoreAdCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send auction_worklet::mojom::SellerWorklet::ScoreAd", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ad_metadata_json"), in_ad_metadata_json,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bid"), in_bid,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auction_ad_config_non_shared_params"), in_auction_ad_config_non_shared_params,
                        "<value of type const ::blink::AuctionConfig::NonSharedParams&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signals_other_seller"), in_browser_signals_other_seller,
                        "<value of type ComponentAuctionOtherSellerPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_interest_group_owner"), in_browser_signal_interest_group_owner,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_render_url"), in_browser_signal_render_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_ad_component_render_urls"), in_browser_signal_ad_component_render_urls,
                        "<value of type const std::vector<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_bidding_duration_msecs"), in_browser_signal_bidding_duration_msecs,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("seller_timeout"), in_seller_timeout,
                        "<value of type absl::optional<::base::TimeDelta>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type uint64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSellerWorklet_ScoreAd_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::SellerWorklet_ScoreAd_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->ad_metadata_json)::BaseType> ad_metadata_json_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_ad_metadata_json, ad_metadata_json_fragment);
  params->ad_metadata_json.Set(
      ad_metadata_json_fragment.is_null() ? nullptr : ad_metadata_json_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ad_metadata_json.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ad_metadata_json in SellerWorklet.ScoreAd request");
  params->bid = in_bid;
  mojo::internal::MessageFragment<
      typename decltype(params->auction_ad_config_non_shared_params)::BaseType> auction_ad_config_non_shared_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AuctionAdConfigNonSharedParamsDataView>(
      in_auction_ad_config_non_shared_params, auction_ad_config_non_shared_params_fragment);
  params->auction_ad_config_non_shared_params.Set(
      auction_ad_config_non_shared_params_fragment.is_null() ? nullptr : auction_ad_config_non_shared_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->auction_ad_config_non_shared_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null auction_ad_config_non_shared_params in SellerWorklet.ScoreAd request");
  mojo::internal::MessageFragment<decltype(params->browser_signals_other_seller)>
      browser_signals_other_seller_fragment(params.message());
  browser_signals_other_seller_fragment.Claim(&params->browser_signals_other_seller);
  mojo::internal::Serialize<::auction_worklet::mojom::ComponentAuctionOtherSellerDataView>(
      in_browser_signals_other_seller, browser_signals_other_seller_fragment, true);
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_interest_group_owner)::BaseType> browser_signal_interest_group_owner_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_browser_signal_interest_group_owner, browser_signal_interest_group_owner_fragment);
  params->browser_signal_interest_group_owner.Set(
      browser_signal_interest_group_owner_fragment.is_null() ? nullptr : browser_signal_interest_group_owner_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_interest_group_owner.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_interest_group_owner in SellerWorklet.ScoreAd request");
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_render_url)::BaseType> browser_signal_render_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_browser_signal_render_url, browser_signal_render_url_fragment);
  params->browser_signal_render_url.Set(
      browser_signal_render_url_fragment.is_null() ? nullptr : browser_signal_render_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_render_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_render_url in SellerWorklet.ScoreAd request");
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_ad_component_render_urls)::BaseType>
      browser_signal_ad_component_render_urls_fragment(params.message());
  const mojo::internal::ContainerValidateParams browser_signal_ad_component_render_urls_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::UrlDataView>>(
      in_browser_signal_ad_component_render_urls, browser_signal_ad_component_render_urls_fragment, &browser_signal_ad_component_render_urls_validate_params);
  params->browser_signal_ad_component_render_urls.Set(
      browser_signal_ad_component_render_urls_fragment.is_null() ? nullptr : browser_signal_ad_component_render_urls_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_ad_component_render_urls.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_ad_component_render_urls in SellerWorklet.ScoreAd request");
  params->browser_signal_bidding_duration_msecs = in_browser_signal_bidding_duration_msecs;
  mojo::internal::MessageFragment<
      typename decltype(params->seller_timeout)::BaseType> seller_timeout_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_seller_timeout, seller_timeout_fragment);
  params->seller_timeout.Set(
      seller_timeout_fragment.is_null() ? nullptr : seller_timeout_fragment.data());
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SellerWorklet::Name_);
  message.set_method_name("ScoreAd");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SellerWorklet_ScoreAd_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SellerWorkletProxy::SendPendingSignalsRequests(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send auction_worklet::mojom::SellerWorklet::SendPendingSignalsRequests");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSellerWorklet_SendPendingSignalsRequests_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::SellerWorklet_SendPendingSignalsRequests_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SellerWorklet::Name_);
  message.set_method_name("SendPendingSignalsRequests");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SellerWorkletProxy::ReportResult(
    const ::blink::AuctionConfig::NonSharedParams& in_auction_ad_config_non_shared_params, ComponentAuctionOtherSellerPtr in_browser_signals_other_seller, const ::url::Origin& in_browser_signal_interest_group_owner, const ::GURL& in_browser_signal_render_url, double in_browser_signal_bid, double in_browser_signal_desirability, double in_browser_signal_highest_scoring_other_bid, ComponentAuctionReportResultParamsPtr in_browser_signals_component_auction_report_result_params, uint32_t in_scoring_signals_data_version, bool in_has_scoring_signals_data_version, uint64_t in_trace_id, ReportResultCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send auction_worklet::mojom::SellerWorklet::ReportResult", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auction_ad_config_non_shared_params"), in_auction_ad_config_non_shared_params,
                        "<value of type const ::blink::AuctionConfig::NonSharedParams&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signals_other_seller"), in_browser_signals_other_seller,
                        "<value of type ComponentAuctionOtherSellerPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_interest_group_owner"), in_browser_signal_interest_group_owner,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_render_url"), in_browser_signal_render_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_bid"), in_browser_signal_bid,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_desirability"), in_browser_signal_desirability,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_highest_scoring_other_bid"), in_browser_signal_highest_scoring_other_bid,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signals_component_auction_report_result_params"), in_browser_signals_component_auction_report_result_params,
                        "<value of type ComponentAuctionReportResultParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("scoring_signals_data_version"), in_scoring_signals_data_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_scoring_signals_data_version"), in_has_scoring_signals_data_version,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type uint64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSellerWorklet_ReportResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::SellerWorklet_ReportResult_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->auction_ad_config_non_shared_params)::BaseType> auction_ad_config_non_shared_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AuctionAdConfigNonSharedParamsDataView>(
      in_auction_ad_config_non_shared_params, auction_ad_config_non_shared_params_fragment);
  params->auction_ad_config_non_shared_params.Set(
      auction_ad_config_non_shared_params_fragment.is_null() ? nullptr : auction_ad_config_non_shared_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->auction_ad_config_non_shared_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null auction_ad_config_non_shared_params in SellerWorklet.ReportResult request");
  mojo::internal::MessageFragment<decltype(params->browser_signals_other_seller)>
      browser_signals_other_seller_fragment(params.message());
  browser_signals_other_seller_fragment.Claim(&params->browser_signals_other_seller);
  mojo::internal::Serialize<::auction_worklet::mojom::ComponentAuctionOtherSellerDataView>(
      in_browser_signals_other_seller, browser_signals_other_seller_fragment, true);
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_interest_group_owner)::BaseType> browser_signal_interest_group_owner_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_browser_signal_interest_group_owner, browser_signal_interest_group_owner_fragment);
  params->browser_signal_interest_group_owner.Set(
      browser_signal_interest_group_owner_fragment.is_null() ? nullptr : browser_signal_interest_group_owner_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_interest_group_owner.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_interest_group_owner in SellerWorklet.ReportResult request");
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_render_url)::BaseType> browser_signal_render_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_browser_signal_render_url, browser_signal_render_url_fragment);
  params->browser_signal_render_url.Set(
      browser_signal_render_url_fragment.is_null() ? nullptr : browser_signal_render_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_render_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_render_url in SellerWorklet.ReportResult request");
  params->browser_signal_bid = in_browser_signal_bid;
  params->browser_signal_desirability = in_browser_signal_desirability;
  params->browser_signal_highest_scoring_other_bid = in_browser_signal_highest_scoring_other_bid;
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signals_component_auction_report_result_params)::BaseType> browser_signals_component_auction_report_result_params_fragment(
          params.message());
  mojo::internal::Serialize<::auction_worklet::mojom::ComponentAuctionReportResultParamsDataView>(
      in_browser_signals_component_auction_report_result_params, browser_signals_component_auction_report_result_params_fragment);
  params->browser_signals_component_auction_report_result_params.Set(
      browser_signals_component_auction_report_result_params_fragment.is_null() ? nullptr : browser_signals_component_auction_report_result_params_fragment.data());
  params->scoring_signals_data_version = in_scoring_signals_data_version;
  params->has_scoring_signals_data_version = in_has_scoring_signals_data_version;
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SellerWorklet::Name_);
  message.set_method_name("ReportResult");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SellerWorklet_ReportResult_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SellerWorkletProxy::ConnectDevToolsAgent(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> in_agent) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send auction_worklet::mojom::SellerWorklet::ConnectDevToolsAgent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("agent"), in_agent,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSellerWorklet_ConnectDevToolsAgent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::SellerWorklet_ConnectDevToolsAgent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::DevToolsAgentAssociatedRequestDataView>(
      in_agent, &params->agent, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->agent),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid agent in SellerWorklet.ConnectDevToolsAgent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SellerWorklet::Name_);
  message.set_method_name("ConnectDevToolsAgent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class SellerWorklet_ScoreAd_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SellerWorklet::ScoreAdCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SellerWorklet_ScoreAd_ProxyToResponder> proxy(
        new SellerWorklet_ScoreAd_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SellerWorklet_ScoreAd_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SellerWorklet_ScoreAd_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SellerWorklet_ScoreAd_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SellerWorklet::ScoreAdCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      double in_score, ComponentAuctionModifiedBidParamsPtr in_component_auction_modified_bid_params, uint32_t in_scoring_signals_data_version, bool in_has_scoring_signals_data_version, const absl::optional<::GURL>& in_debug_loss_report_url, const absl::optional<::GURL>& in_debug_win_report_url, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_errors);
};

bool SellerWorklet_ScoreAd_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SellerWorklet_ScoreAd_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SellerWorklet_ScoreAd_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  double p_score{};
  ComponentAuctionModifiedBidParamsPtr p_component_auction_modified_bid_params{};
  uint32_t p_scoring_signals_data_version{};
  bool p_has_scoring_signals_data_version{};
  absl::optional<::GURL> p_debug_loss_report_url{};
  absl::optional<::GURL> p_debug_win_report_url{};
  std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> p_pa_requests{};
  std::vector<std::string> p_errors{};
  SellerWorklet_ScoreAd_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_score = input_data_view.score();
  if (success && !input_data_view.ReadComponentAuctionModifiedBidParams(&p_component_auction_modified_bid_params))
    success = false;
  if (success)
    p_scoring_signals_data_version = input_data_view.scoring_signals_data_version();
  if (success)
    p_has_scoring_signals_data_version = input_data_view.has_scoring_signals_data_version();
  if (success && !input_data_view.ReadDebugLossReportUrl(&p_debug_loss_report_url))
    success = false;
  if (success && !input_data_view.ReadDebugWinReportUrl(&p_debug_win_report_url))
    success = false;
  if (success && !input_data_view.ReadPaRequests(&p_pa_requests))
    success = false;
  if (success && !input_data_view.ReadErrors(&p_errors))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SellerWorklet::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_score), 
std::move(p_component_auction_modified_bid_params), 
std::move(p_scoring_signals_data_version), 
std::move(p_has_scoring_signals_data_version), 
std::move(p_debug_loss_report_url), 
std::move(p_debug_win_report_url), 
std::move(p_pa_requests), 
std::move(p_errors));
  return true;
}

void SellerWorklet_ScoreAd_ProxyToResponder::Run(
    double in_score, ComponentAuctionModifiedBidParamsPtr in_component_auction_modified_bid_params, uint32_t in_scoring_signals_data_version, bool in_has_scoring_signals_data_version, const absl::optional<::GURL>& in_debug_loss_report_url, const absl::optional<::GURL>& in_debug_win_report_url, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_errors) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply auction_worklet::mojom::SellerWorklet::ScoreAd", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("score"), in_score,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("component_auction_modified_bid_params"), in_component_auction_modified_bid_params,
                        "<value of type ComponentAuctionModifiedBidParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("scoring_signals_data_version"), in_scoring_signals_data_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_scoring_signals_data_version"), in_has_scoring_signals_data_version,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("debug_loss_report_url"), in_debug_loss_report_url,
                        "<value of type const absl::optional<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("debug_win_report_url"), in_debug_win_report_url,
                        "<value of type const absl::optional<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pa_requests"), in_pa_requests,
                        "<value of type std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("errors"), in_errors,
                        "<value of type const std::vector<std::string>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSellerWorklet_ScoreAd_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::SellerWorklet_ScoreAd_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->score = in_score;
  mojo::internal::MessageFragment<
      typename decltype(params->component_auction_modified_bid_params)::BaseType> component_auction_modified_bid_params_fragment(
          params.message());
  mojo::internal::Serialize<::auction_worklet::mojom::ComponentAuctionModifiedBidParamsDataView>(
      in_component_auction_modified_bid_params, component_auction_modified_bid_params_fragment);
  params->component_auction_modified_bid_params.Set(
      component_auction_modified_bid_params_fragment.is_null() ? nullptr : component_auction_modified_bid_params_fragment.data());
  params->scoring_signals_data_version = in_scoring_signals_data_version;
  params->has_scoring_signals_data_version = in_has_scoring_signals_data_version;
  mojo::internal::MessageFragment<
      typename decltype(params->debug_loss_report_url)::BaseType> debug_loss_report_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_debug_loss_report_url, debug_loss_report_url_fragment);
  params->debug_loss_report_url.Set(
      debug_loss_report_url_fragment.is_null() ? nullptr : debug_loss_report_url_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->debug_win_report_url)::BaseType> debug_win_report_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_debug_win_report_url, debug_win_report_url_fragment);
  params->debug_win_report_url.Set(
      debug_win_report_url_fragment.is_null() ? nullptr : debug_win_report_url_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->pa_requests)::BaseType>
      pa_requests_fragment(params.message());
  const mojo::internal::ContainerValidateParams pa_requests_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::auction_worklet::mojom::PrivateAggregationRequestDataView>>(
      in_pa_requests, pa_requests_fragment, &pa_requests_validate_params);
  params->pa_requests.Set(
      pa_requests_fragment.is_null() ? nullptr : pa_requests_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pa_requests.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pa_requests in ");
  mojo::internal::MessageFragment<
      typename decltype(params->errors)::BaseType>
      errors_fragment(params.message());
  const mojo::internal::ContainerValidateParams errors_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_errors, errors_fragment, &errors_validate_params);
  params->errors.Set(
      errors_fragment.is_null() ? nullptr : errors_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->errors.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null errors in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SellerWorklet::Name_);
  message.set_method_name("ScoreAd");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SellerWorklet_ReportResult_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SellerWorklet::ReportResultCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SellerWorklet_ReportResult_ProxyToResponder> proxy(
        new SellerWorklet_ReportResult_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SellerWorklet_ReportResult_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SellerWorklet_ReportResult_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SellerWorklet_ReportResult_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SellerWorklet::ReportResultCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<std::string>& in_signals_for_winner, const absl::optional<::GURL>& in_report_url, const base::flat_map<std::string, ::GURL>& in_ad_beacon_map, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_error_msgs);
};

bool SellerWorklet_ReportResult_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SellerWorklet_ReportResult_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SellerWorklet_ReportResult_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<std::string> p_signals_for_winner{};
  absl::optional<::GURL> p_report_url{};
  base::flat_map<std::string, ::GURL> p_ad_beacon_map{};
  std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> p_pa_requests{};
  std::vector<std::string> p_error_msgs{};
  SellerWorklet_ReportResult_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadSignalsForWinner(&p_signals_for_winner))
    success = false;
  if (success && !input_data_view.ReadReportUrl(&p_report_url))
    success = false;
  if (success && !input_data_view.ReadAdBeaconMap(&p_ad_beacon_map))
    success = false;
  if (success && !input_data_view.ReadPaRequests(&p_pa_requests))
    success = false;
  if (success && !input_data_view.ReadErrorMsgs(&p_error_msgs))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SellerWorklet::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_signals_for_winner), 
std::move(p_report_url), 
std::move(p_ad_beacon_map), 
std::move(p_pa_requests), 
std::move(p_error_msgs));
  return true;
}

void SellerWorklet_ReportResult_ProxyToResponder::Run(
    const absl::optional<std::string>& in_signals_for_winner, const absl::optional<::GURL>& in_report_url, const base::flat_map<std::string, ::GURL>& in_ad_beacon_map, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_error_msgs) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply auction_worklet::mojom::SellerWorklet::ReportResult", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("signals_for_winner"), in_signals_for_winner,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report_url"), in_report_url,
                        "<value of type const absl::optional<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ad_beacon_map"), in_ad_beacon_map,
                        "<value of type const base::flat_map<std::string, ::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pa_requests"), in_pa_requests,
                        "<value of type std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_msgs"), in_error_msgs,
                        "<value of type const std::vector<std::string>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSellerWorklet_ReportResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::SellerWorklet_ReportResult_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->signals_for_winner)::BaseType> signals_for_winner_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_signals_for_winner, signals_for_winner_fragment);
  params->signals_for_winner.Set(
      signals_for_winner_fragment.is_null() ? nullptr : signals_for_winner_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->report_url)::BaseType> report_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_report_url, report_url_fragment);
  params->report_url.Set(
      report_url_fragment.is_null() ? nullptr : report_url_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->ad_beacon_map)::BaseType>
      ad_beacon_map_fragment(params.message());
  const mojo::internal::ContainerValidateParams ad_beacon_map_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::url::mojom::UrlDataView>>(
      in_ad_beacon_map, ad_beacon_map_fragment, &ad_beacon_map_validate_params);
  params->ad_beacon_map.Set(
      ad_beacon_map_fragment.is_null() ? nullptr : ad_beacon_map_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ad_beacon_map.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ad_beacon_map in ");
  mojo::internal::MessageFragment<
      typename decltype(params->pa_requests)::BaseType>
      pa_requests_fragment(params.message());
  const mojo::internal::ContainerValidateParams pa_requests_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::auction_worklet::mojom::PrivateAggregationRequestDataView>>(
      in_pa_requests, pa_requests_fragment, &pa_requests_validate_params);
  params->pa_requests.Set(
      pa_requests_fragment.is_null() ? nullptr : pa_requests_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pa_requests.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pa_requests in ");
  mojo::internal::MessageFragment<
      typename decltype(params->error_msgs)::BaseType>
      error_msgs_fragment(params.message());
  const mojo::internal::ContainerValidateParams error_msgs_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_error_msgs, error_msgs_fragment, &error_msgs_validate_params);
  params->error_msgs.Set(
      error_msgs_fragment.is_null() ? nullptr : error_msgs_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_msgs.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_msgs in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SellerWorklet::Name_);
  message.set_method_name("ReportResult");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool SellerWorkletStubDispatch::Accept(
    SellerWorklet* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSellerWorklet_ScoreAd_Name: {
      break;
    }
    case internal::kSellerWorklet_SendPendingSignalsRequests_Name: {

      DCHECK(message->is_serialized());
      internal::SellerWorklet_SendPendingSignalsRequests_Params_Data* params =
          reinterpret_cast<internal::SellerWorklet_SendPendingSignalsRequests_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SellerWorklet_SendPendingSignalsRequests_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SellerWorklet::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendPendingSignalsRequests();
      return true;
    }
    case internal::kSellerWorklet_ReportResult_Name: {
      break;
    }
    case internal::kSellerWorklet_ConnectDevToolsAgent_Name: {

      DCHECK(message->is_serialized());
      internal::SellerWorklet_ConnectDevToolsAgent_Params_Data* params =
          reinterpret_cast<internal::SellerWorklet_ConnectDevToolsAgent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> p_agent{};
      SellerWorklet_ConnectDevToolsAgent_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_agent =
            input_data_view.TakeAgent<decltype(p_agent)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SellerWorklet::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConnectDevToolsAgent(
std::move(p_agent));
      return true;
    }
  }
  return false;
}

// static
bool SellerWorkletStubDispatch::AcceptWithResponder(
    SellerWorklet* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSellerWorklet_ScoreAd_Name: {

      internal::SellerWorklet_ScoreAd_Params_Data* params =
          reinterpret_cast<
              internal::SellerWorklet_ScoreAd_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_ad_metadata_json{};
      double p_bid{};
      ::blink::AuctionConfig::NonSharedParams p_auction_ad_config_non_shared_params{};
      ComponentAuctionOtherSellerPtr p_browser_signals_other_seller{};
      ::url::Origin p_browser_signal_interest_group_owner{};
      ::GURL p_browser_signal_render_url{};
      std::vector<::GURL> p_browser_signal_ad_component_render_urls{};
      uint32_t p_browser_signal_bidding_duration_msecs{};
      absl::optional<::base::TimeDelta> p_seller_timeout{};
      uint64_t p_trace_id{};
      SellerWorklet_ScoreAd_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAdMetadataJson(&p_ad_metadata_json))
        success = false;
      if (success)
        p_bid = input_data_view.bid();
      if (success && !input_data_view.ReadAuctionAdConfigNonSharedParams(&p_auction_ad_config_non_shared_params))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalsOtherSeller(&p_browser_signals_other_seller))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalInterestGroupOwner(&p_browser_signal_interest_group_owner))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalRenderUrl(&p_browser_signal_render_url))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalAdComponentRenderUrls(&p_browser_signal_ad_component_render_urls))
        success = false;
      if (success)
        p_browser_signal_bidding_duration_msecs = input_data_view.browser_signal_bidding_duration_msecs();
      if (success && !input_data_view.ReadSellerTimeout(&p_seller_timeout))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SellerWorklet::Name_, 0, false);
        return false;
      }
      SellerWorklet::ScoreAdCallback callback =
          SellerWorklet_ScoreAd_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScoreAd(
std::move(p_ad_metadata_json), 
std::move(p_bid), 
std::move(p_auction_ad_config_non_shared_params), 
std::move(p_browser_signals_other_seller), 
std::move(p_browser_signal_interest_group_owner), 
std::move(p_browser_signal_render_url), 
std::move(p_browser_signal_ad_component_render_urls), 
std::move(p_browser_signal_bidding_duration_msecs), 
std::move(p_seller_timeout), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kSellerWorklet_SendPendingSignalsRequests_Name: {
      break;
    }
    case internal::kSellerWorklet_ReportResult_Name: {

      internal::SellerWorklet_ReportResult_Params_Data* params =
          reinterpret_cast<
              internal::SellerWorklet_ReportResult_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::AuctionConfig::NonSharedParams p_auction_ad_config_non_shared_params{};
      ComponentAuctionOtherSellerPtr p_browser_signals_other_seller{};
      ::url::Origin p_browser_signal_interest_group_owner{};
      ::GURL p_browser_signal_render_url{};
      double p_browser_signal_bid{};
      double p_browser_signal_desirability{};
      double p_browser_signal_highest_scoring_other_bid{};
      ComponentAuctionReportResultParamsPtr p_browser_signals_component_auction_report_result_params{};
      uint32_t p_scoring_signals_data_version{};
      bool p_has_scoring_signals_data_version{};
      uint64_t p_trace_id{};
      SellerWorklet_ReportResult_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAuctionAdConfigNonSharedParams(&p_auction_ad_config_non_shared_params))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalsOtherSeller(&p_browser_signals_other_seller))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalInterestGroupOwner(&p_browser_signal_interest_group_owner))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalRenderUrl(&p_browser_signal_render_url))
        success = false;
      if (success)
        p_browser_signal_bid = input_data_view.browser_signal_bid();
      if (success)
        p_browser_signal_desirability = input_data_view.browser_signal_desirability();
      if (success)
        p_browser_signal_highest_scoring_other_bid = input_data_view.browser_signal_highest_scoring_other_bid();
      if (success && !input_data_view.ReadBrowserSignalsComponentAuctionReportResultParams(&p_browser_signals_component_auction_report_result_params))
        success = false;
      if (success)
        p_scoring_signals_data_version = input_data_view.scoring_signals_data_version();
      if (success)
        p_has_scoring_signals_data_version = input_data_view.has_scoring_signals_data_version();
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SellerWorklet::Name_, 2, false);
        return false;
      }
      SellerWorklet::ReportResultCallback callback =
          SellerWorklet_ReportResult_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportResult(
std::move(p_auction_ad_config_non_shared_params), 
std::move(p_browser_signals_other_seller), 
std::move(p_browser_signal_interest_group_owner), 
std::move(p_browser_signal_render_url), 
std::move(p_browser_signal_bid), 
std::move(p_browser_signal_desirability), 
std::move(p_browser_signal_highest_scoring_other_bid), 
std::move(p_browser_signals_component_auction_report_result_params), 
std::move(p_scoring_signals_data_version), 
std::move(p_has_scoring_signals_data_version), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kSellerWorklet_ConnectDevToolsAgent_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSellerWorkletValidationInfo[] = {
    {&internal::SellerWorklet_ScoreAd_Params_Data::Validate,
     &internal::SellerWorklet_ScoreAd_ResponseParams_Data::Validate},
    {&internal::SellerWorklet_SendPendingSignalsRequests_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SellerWorklet_ReportResult_Params_Data::Validate,
     &internal::SellerWorklet_ReportResult_ResponseParams_Data::Validate},
    {&internal::SellerWorklet_ConnectDevToolsAgent_Params_Data::Validate,
     nullptr /* no response */},
};

bool SellerWorkletRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::auction_worklet::mojom::SellerWorklet::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSellerWorkletValidationInfo);
}

bool SellerWorkletResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::auction_worklet::mojom::SellerWorklet::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kSellerWorkletValidationInfo);
}


}  // namespace mojom
}  // namespace auction_worklet


namespace mojo {


// static
bool StructTraits<::auction_worklet::mojom::ComponentAuctionModifiedBidParams::DataView, ::auction_worklet::mojom::ComponentAuctionModifiedBidParamsPtr>::Read(
    ::auction_worklet::mojom::ComponentAuctionModifiedBidParams::DataView input,
    ::auction_worklet::mojom::ComponentAuctionModifiedBidParamsPtr* output) {
  bool success = true;
  ::auction_worklet::mojom::ComponentAuctionModifiedBidParamsPtr result(::auction_worklet::mojom::ComponentAuctionModifiedBidParams::New());
  
      if (success && !input.ReadAd(&result->ad))
        success = false;
      if (success)
        result->bid = input.bid();
      if (success)
        result->has_bid = input.has_bid();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::auction_worklet::mojom::ComponentAuctionReportResultParams::DataView, ::auction_worklet::mojom::ComponentAuctionReportResultParamsPtr>::Read(
    ::auction_worklet::mojom::ComponentAuctionReportResultParams::DataView input,
    ::auction_worklet::mojom::ComponentAuctionReportResultParamsPtr* output) {
  bool success = true;
  ::auction_worklet::mojom::ComponentAuctionReportResultParamsPtr result(::auction_worklet::mojom::ComponentAuctionReportResultParams::New());
  
      if (success && !input.ReadTopLevelSellerSignals(&result->top_level_seller_signals))
        success = false;
      if (success)
        result->modified_bid = input.modified_bid();
      if (success)
        result->has_modified_bid = input.has_modified_bid();
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::auction_worklet::mojom::ComponentAuctionOtherSeller::DataView, ::auction_worklet::mojom::ComponentAuctionOtherSellerPtr>::Read(
    ::auction_worklet::mojom::ComponentAuctionOtherSeller::DataView input,
    ::auction_worklet::mojom::ComponentAuctionOtherSellerPtr* output) {
  using UnionType = ::auction_worklet::mojom::ComponentAuctionOtherSeller;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kTopLevelSeller: {
      ::url::Origin result_top_level_seller;
      if (!input.ReadTopLevelSeller(&result_top_level_seller))
        return false;

      *output = UnionType::NewTopLevelSeller(
          std::move(result_top_level_seller));
      break;
    }
    case Tag::kComponentSeller: {
      ::url::Origin result_component_seller;
      if (!input.ReadComponentSeller(&result_component_seller))
        return false;

      *output = UnionType::NewComponentSeller(
          std::move(result_component_seller));
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace auction_worklet {
namespace mojom {


void SellerWorkletInterceptorForTesting::ScoreAd(const std::string& ad_metadata_json, double bid, const ::blink::AuctionConfig::NonSharedParams& auction_ad_config_non_shared_params, ComponentAuctionOtherSellerPtr browser_signals_other_seller, const ::url::Origin& browser_signal_interest_group_owner, const ::GURL& browser_signal_render_url, const std::vector<::GURL>& browser_signal_ad_component_render_urls, uint32_t browser_signal_bidding_duration_msecs, absl::optional<::base::TimeDelta> seller_timeout, uint64_t trace_id, ScoreAdCallback callback) {
  GetForwardingInterface()->ScoreAd(std::move(ad_metadata_json), std::move(bid), std::move(auction_ad_config_non_shared_params), std::move(browser_signals_other_seller), std::move(browser_signal_interest_group_owner), std::move(browser_signal_render_url), std::move(browser_signal_ad_component_render_urls), std::move(browser_signal_bidding_duration_msecs), std::move(seller_timeout), std::move(trace_id), std::move(callback));
}
void SellerWorkletInterceptorForTesting::SendPendingSignalsRequests() {
  GetForwardingInterface()->SendPendingSignalsRequests();
}
void SellerWorkletInterceptorForTesting::ReportResult(const ::blink::AuctionConfig::NonSharedParams& auction_ad_config_non_shared_params, ComponentAuctionOtherSellerPtr browser_signals_other_seller, const ::url::Origin& browser_signal_interest_group_owner, const ::GURL& browser_signal_render_url, double browser_signal_bid, double browser_signal_desirability, double browser_signal_highest_scoring_other_bid, ComponentAuctionReportResultParamsPtr browser_signals_component_auction_report_result_params, uint32_t scoring_signals_data_version, bool has_scoring_signals_data_version, uint64_t trace_id, ReportResultCallback callback) {
  GetForwardingInterface()->ReportResult(std::move(auction_ad_config_non_shared_params), std::move(browser_signals_other_seller), std::move(browser_signal_interest_group_owner), std::move(browser_signal_render_url), std::move(browser_signal_bid), std::move(browser_signal_desirability), std::move(browser_signal_highest_scoring_other_bid), std::move(browser_signals_component_auction_report_result_params), std::move(scoring_signals_data_version), std::move(has_scoring_signals_data_version), std::move(trace_id), std::move(callback));
}
void SellerWorkletInterceptorForTesting::ConnectDevToolsAgent(::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> agent) {
  GetForwardingInterface()->ConnectDevToolsAgent(std::move(agent));
}
SellerWorkletAsyncWaiter::SellerWorkletAsyncWaiter(
    SellerWorklet* proxy) : proxy_(proxy) {}

SellerWorkletAsyncWaiter::~SellerWorkletAsyncWaiter() = default;

void SellerWorkletAsyncWaiter::ScoreAd(
    const std::string& ad_metadata_json, double bid, const ::blink::AuctionConfig::NonSharedParams& auction_ad_config_non_shared_params, ComponentAuctionOtherSellerPtr browser_signals_other_seller, const ::url::Origin& browser_signal_interest_group_owner, const ::GURL& browser_signal_render_url, const std::vector<::GURL>& browser_signal_ad_component_render_urls, uint32_t browser_signal_bidding_duration_msecs, absl::optional<::base::TimeDelta> seller_timeout, uint64_t trace_id, double* out_score, ComponentAuctionModifiedBidParamsPtr* out_component_auction_modified_bid_params, uint32_t* out_scoring_signals_data_version, bool* out_has_scoring_signals_data_version, absl::optional<::GURL>* out_debug_loss_report_url, absl::optional<::GURL>* out_debug_win_report_url, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests, std::vector<std::string>* out_errors) {
  base::RunLoop loop;
  proxy_->ScoreAd(std::move(ad_metadata_json),std::move(bid),std::move(auction_ad_config_non_shared_params),std::move(browser_signals_other_seller),std::move(browser_signal_interest_group_owner),std::move(browser_signal_render_url),std::move(browser_signal_ad_component_render_urls),std::move(browser_signal_bidding_duration_msecs),std::move(seller_timeout),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             double* out_score
,
             ComponentAuctionModifiedBidParamsPtr* out_component_auction_modified_bid_params
,
             uint32_t* out_scoring_signals_data_version
,
             bool* out_has_scoring_signals_data_version
,
             absl::optional<::GURL>* out_debug_loss_report_url
,
             absl::optional<::GURL>* out_debug_win_report_url
,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests
,
             std::vector<std::string>* out_errors
,
             double score,
             ComponentAuctionModifiedBidParamsPtr component_auction_modified_bid_params,
             uint32_t scoring_signals_data_version,
             bool has_scoring_signals_data_version,
             const absl::optional<::GURL>& debug_loss_report_url,
             const absl::optional<::GURL>& debug_win_report_url,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> pa_requests,
             const std::vector<std::string>& errors) {*out_score = std::move(score);*out_component_auction_modified_bid_params = std::move(component_auction_modified_bid_params);*out_scoring_signals_data_version = std::move(scoring_signals_data_version);*out_has_scoring_signals_data_version = std::move(has_scoring_signals_data_version);*out_debug_loss_report_url = std::move(debug_loss_report_url);*out_debug_win_report_url = std::move(debug_win_report_url);*out_pa_requests = std::move(pa_requests);*out_errors = std::move(errors);
            loop->Quit();
          },
          &loop,
          out_score,
          out_component_auction_modified_bid_params,
          out_scoring_signals_data_version,
          out_has_scoring_signals_data_version,
          out_debug_loss_report_url,
          out_debug_win_report_url,
          out_pa_requests,
          out_errors));
  loop.Run();
}
void SellerWorkletAsyncWaiter::ReportResult(
    const ::blink::AuctionConfig::NonSharedParams& auction_ad_config_non_shared_params, ComponentAuctionOtherSellerPtr browser_signals_other_seller, const ::url::Origin& browser_signal_interest_group_owner, const ::GURL& browser_signal_render_url, double browser_signal_bid, double browser_signal_desirability, double browser_signal_highest_scoring_other_bid, ComponentAuctionReportResultParamsPtr browser_signals_component_auction_report_result_params, uint32_t scoring_signals_data_version, bool has_scoring_signals_data_version, uint64_t trace_id, absl::optional<std::string>* out_signals_for_winner, absl::optional<::GURL>* out_report_url, base::flat_map<std::string, ::GURL>* out_ad_beacon_map, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests, std::vector<std::string>* out_error_msgs) {
  base::RunLoop loop;
  proxy_->ReportResult(std::move(auction_ad_config_non_shared_params),std::move(browser_signals_other_seller),std::move(browser_signal_interest_group_owner),std::move(browser_signal_render_url),std::move(browser_signal_bid),std::move(browser_signal_desirability),std::move(browser_signal_highest_scoring_other_bid),std::move(browser_signals_component_auction_report_result_params),std::move(scoring_signals_data_version),std::move(has_scoring_signals_data_version),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<std::string>* out_signals_for_winner
,
             absl::optional<::GURL>* out_report_url
,
             base::flat_map<std::string, ::GURL>* out_ad_beacon_map
,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests
,
             std::vector<std::string>* out_error_msgs
,
             const absl::optional<std::string>& signals_for_winner,
             const absl::optional<::GURL>& report_url,
             const base::flat_map<std::string, ::GURL>& ad_beacon_map,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> pa_requests,
             const std::vector<std::string>& error_msgs) {*out_signals_for_winner = std::move(signals_for_winner);*out_report_url = std::move(report_url);*out_ad_beacon_map = std::move(ad_beacon_map);*out_pa_requests = std::move(pa_requests);*out_error_msgs = std::move(error_msgs);
            loop->Quit();
          },
          &loop,
          out_signals_for_winner,
          out_report_url,
          out_ad_beacon_map,
          out_pa_requests,
          out_error_msgs));
  loop.Run();
}





}  // namespace mojom
}  // namespace auction_worklet


#if defined(__clang__)
#pragma clang diagnostic pop
#endif