// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/storage.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Storage {

using crdtp::DeserializerState;
using crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Storage";
const char Metainfo::commandPrefix[] = "Storage.";
const char Metainfo::version[] = "1.3";


namespace StorageTypeEnum {
const char Appcache[] = "appcache";
const char Cookies[] = "cookies";
const char File_systems[] = "file_systems";
const char Indexeddb[] = "indexeddb";
const char Local_storage[] = "local_storage";
const char Shader_cache[] = "shader_cache";
const char Websql[] = "websql";
const char Service_workers[] = "service_workers";
const char Cache_storage[] = "cache_storage";
const char Interest_groups[] = "interest_groups";
const char All[] = "all";
const char Other[] = "other";
} // namespace StorageTypeEnum


CRDTP_BEGIN_DESERIALIZER(UsageForType)
    CRDTP_DESERIALIZE_FIELD("storageType", m_storageType),
    CRDTP_DESERIALIZE_FIELD("usage", m_usage),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(UsageForType)
    CRDTP_SERIALIZE_FIELD("storageType", m_storageType);
    CRDTP_SERIALIZE_FIELD("usage", m_usage);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(TrustTokens)
    CRDTP_DESERIALIZE_FIELD("count", m_count),
    CRDTP_DESERIALIZE_FIELD("issuerOrigin", m_issuerOrigin),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(TrustTokens)
    CRDTP_SERIALIZE_FIELD("issuerOrigin", m_issuerOrigin);
    CRDTP_SERIALIZE_FIELD("count", m_count);
CRDTP_END_SERIALIZER();


namespace InterestGroupAccessTypeEnum {
const char Join[] = "join";
const char Leave[] = "leave";
const char Update[] = "update";
const char Bid[] = "bid";
const char Win[] = "win";
} // namespace InterestGroupAccessTypeEnum


CRDTP_BEGIN_DESERIALIZER(InterestGroupAd)
    CRDTP_DESERIALIZE_FIELD_OPT("metadata", m_metadata),
    CRDTP_DESERIALIZE_FIELD("renderUrl", m_renderUrl),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(InterestGroupAd)
    CRDTP_SERIALIZE_FIELD("renderUrl", m_renderUrl);
    CRDTP_SERIALIZE_FIELD("metadata", m_metadata);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(InterestGroupDetails)
    CRDTP_DESERIALIZE_FIELD("adComponents", m_adComponents),
    CRDTP_DESERIALIZE_FIELD("ads", m_ads),
    CRDTP_DESERIALIZE_FIELD_OPT("biddingUrl", m_biddingUrl),
    CRDTP_DESERIALIZE_FIELD_OPT("biddingWasmHelperUrl", m_biddingWasmHelperUrl),
    CRDTP_DESERIALIZE_FIELD("expirationTime", m_expirationTime),
    CRDTP_DESERIALIZE_FIELD("joiningOrigin", m_joiningOrigin),
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD("ownerOrigin", m_ownerOrigin),
    CRDTP_DESERIALIZE_FIELD("trustedBiddingSignalsKeys", m_trustedBiddingSignalsKeys),
    CRDTP_DESERIALIZE_FIELD_OPT("trustedBiddingSignalsUrl", m_trustedBiddingSignalsUrl),
    CRDTP_DESERIALIZE_FIELD_OPT("updateUrl", m_updateUrl),
    CRDTP_DESERIALIZE_FIELD_OPT("userBiddingSignals", m_userBiddingSignals),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(InterestGroupDetails)
    CRDTP_SERIALIZE_FIELD("ownerOrigin", m_ownerOrigin);
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("expirationTime", m_expirationTime);
    CRDTP_SERIALIZE_FIELD("joiningOrigin", m_joiningOrigin);
    CRDTP_SERIALIZE_FIELD("biddingUrl", m_biddingUrl);
    CRDTP_SERIALIZE_FIELD("biddingWasmHelperUrl", m_biddingWasmHelperUrl);
    CRDTP_SERIALIZE_FIELD("updateUrl", m_updateUrl);
    CRDTP_SERIALIZE_FIELD("trustedBiddingSignalsUrl", m_trustedBiddingSignalsUrl);
    CRDTP_SERIALIZE_FIELD("trustedBiddingSignalsKeys", m_trustedBiddingSignalsKeys);
    CRDTP_SERIALIZE_FIELD("userBiddingSignals", m_userBiddingSignals);
    CRDTP_SERIALIZE_FIELD("ads", m_ads);
    CRDTP_SERIALIZE_FIELD("adComponents", m_adComponents);
CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::CacheStorageContentUpdated(const String& origin, const String& cacheName)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("origin"), origin);
    serializer.AddField(crdtp::MakeSpan("cacheName"), cacheName);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Storage.cacheStorageContentUpdated", serializer.Finish()));
}

void Frontend::CacheStorageListUpdated(const String& origin)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("origin"), origin);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Storage.cacheStorageListUpdated", serializer.Finish()));
}

void Frontend::IndexedDBContentUpdated(const String& origin, const String& storageKey, const String& databaseName, const String& objectStoreName)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("origin"), origin);
    serializer.AddField(crdtp::MakeSpan("storageKey"), storageKey);
    serializer.AddField(crdtp::MakeSpan("databaseName"), databaseName);
    serializer.AddField(crdtp::MakeSpan("objectStoreName"), objectStoreName);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Storage.indexedDBContentUpdated", serializer.Finish()));
}

void Frontend::IndexedDBListUpdated(const String& origin, const String& storageKey)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("origin"), origin);
    serializer.AddField(crdtp::MakeSpan("storageKey"), storageKey);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Storage.indexedDBListUpdated", serializer.Finish()));
}

void Frontend::InterestGroupAccessed(double accessTime, const String& type, const String& ownerOrigin, const String& name)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("accessTime"), accessTime);
    serializer.AddField(crdtp::MakeSpan("type"), type);
    serializer.AddField(crdtp::MakeSpan("ownerOrigin"), ownerOrigin);
    serializer.AddField(crdtp::MakeSpan("name"), name);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Storage.interestGroupAccessed", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void getStorageKeyForFrame(const crdtp::Dispatchable& dispatchable);
    void clearDataForOrigin(const crdtp::Dispatchable& dispatchable);
    void clearDataForStorageKey(const crdtp::Dispatchable& dispatchable);
    void getCookies(const crdtp::Dispatchable& dispatchable);
    void setCookies(const crdtp::Dispatchable& dispatchable);
    void clearCookies(const crdtp::Dispatchable& dispatchable);
    void getUsageAndQuota(const crdtp::Dispatchable& dispatchable);
    void overrideQuotaForOrigin(const crdtp::Dispatchable& dispatchable);
    void trackCacheStorageForOrigin(const crdtp::Dispatchable& dispatchable);
    void trackIndexedDBForOrigin(const crdtp::Dispatchable& dispatchable);
    void trackIndexedDBForStorageKey(const crdtp::Dispatchable& dispatchable);
    void untrackCacheStorageForOrigin(const crdtp::Dispatchable& dispatchable);
    void untrackIndexedDBForOrigin(const crdtp::Dispatchable& dispatchable);
    void untrackIndexedDBForStorageKey(const crdtp::Dispatchable& dispatchable);
    void getTrustTokens(const crdtp::Dispatchable& dispatchable);
    void clearTrustTokens(const crdtp::Dispatchable& dispatchable);
    void getInterestGroupDetails(const crdtp::Dispatchable& dispatchable);
    void setInterestGroupTracking(const crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("clearCookies"),
          &DomainDispatcherImpl::clearCookies
    },
    {
          crdtp::SpanFrom("clearDataForOrigin"),
          &DomainDispatcherImpl::clearDataForOrigin
    },
    {
          crdtp::SpanFrom("clearDataForStorageKey"),
          &DomainDispatcherImpl::clearDataForStorageKey
    },
    {
          crdtp::SpanFrom("clearTrustTokens"),
          &DomainDispatcherImpl::clearTrustTokens
    },
    {
          crdtp::SpanFrom("getCookies"),
          &DomainDispatcherImpl::getCookies
    },
    {
          crdtp::SpanFrom("getInterestGroupDetails"),
          &DomainDispatcherImpl::getInterestGroupDetails
    },
    {
          crdtp::SpanFrom("getStorageKeyForFrame"),
          &DomainDispatcherImpl::getStorageKeyForFrame
    },
    {
          crdtp::SpanFrom("getTrustTokens"),
          &DomainDispatcherImpl::getTrustTokens
    },
    {
          crdtp::SpanFrom("getUsageAndQuota"),
          &DomainDispatcherImpl::getUsageAndQuota
    },
    {
          crdtp::SpanFrom("overrideQuotaForOrigin"),
          &DomainDispatcherImpl::overrideQuotaForOrigin
    },
    {
          crdtp::SpanFrom("setCookies"),
          &DomainDispatcherImpl::setCookies
    },
    {
          crdtp::SpanFrom("setInterestGroupTracking"),
          &DomainDispatcherImpl::setInterestGroupTracking
    },
    {
          crdtp::SpanFrom("trackCacheStorageForOrigin"),
          &DomainDispatcherImpl::trackCacheStorageForOrigin
    },
    {
          crdtp::SpanFrom("trackIndexedDBForOrigin"),
          &DomainDispatcherImpl::trackIndexedDBForOrigin
    },
    {
          crdtp::SpanFrom("trackIndexedDBForStorageKey"),
          &DomainDispatcherImpl::trackIndexedDBForStorageKey
    },
    {
          crdtp::SpanFrom("untrackCacheStorageForOrigin"),
          &DomainDispatcherImpl::untrackCacheStorageForOrigin
    },
    {
          crdtp::SpanFrom("untrackIndexedDBForOrigin"),
          &DomainDispatcherImpl::untrackIndexedDBForOrigin
    },
    {
          crdtp::SpanFrom("untrackIndexedDBForStorageKey"),
          &DomainDispatcherImpl::untrackIndexedDBForStorageKey
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct getStorageKeyForFrameParams : public crdtp::DeserializableProtocolObject<getStorageKeyForFrameParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getStorageKeyForFrameParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getStorageKeyForFrame(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getStorageKeyForFrameParams params;
    if (!getStorageKeyForFrameParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_storageKey;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetStorageKeyForFrame(params.frameId, &out_storageKey);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.getStorageKeyForFrame"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("storageKey"), out_storageKey);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

class ClearDataForOriginCallbackImpl : public Backend::ClearDataForOriginCallback, public DomainDispatcher::Callback {
public:
    ClearDataForOriginCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.clearDataForOrigin"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct clearDataForOriginParams : public crdtp::DeserializableProtocolObject<clearDataForOriginParams> {
    String origin;
    String storageTypes;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(clearDataForOriginParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
    CRDTP_DESERIALIZE_FIELD("storageTypes", storageTypes),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::clearDataForOrigin(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    clearDataForOriginParams params;
    if (!clearDataForOriginParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->ClearDataForOrigin(params.origin, params.storageTypes, std::make_unique<ClearDataForOriginCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ClearDataForStorageKeyCallbackImpl : public Backend::ClearDataForStorageKeyCallback, public DomainDispatcher::Callback {
public:
    ClearDataForStorageKeyCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.clearDataForStorageKey"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct clearDataForStorageKeyParams : public crdtp::DeserializableProtocolObject<clearDataForStorageKeyParams> {
    String storageKey;
    String storageTypes;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(clearDataForStorageKeyParams)
    CRDTP_DESERIALIZE_FIELD("storageKey", storageKey),
    CRDTP_DESERIALIZE_FIELD("storageTypes", storageTypes),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::clearDataForStorageKey(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    clearDataForStorageKeyParams params;
    if (!clearDataForStorageKeyParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->ClearDataForStorageKey(params.storageKey, params.storageTypes, std::make_unique<ClearDataForStorageKeyCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetCookiesCallbackImpl : public Backend::GetCookiesCallback, public DomainDispatcher::Callback {
public:
    GetCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.getCookies"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Network::Cookie>> cookies) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("cookies"), cookies);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getCookiesParams : public crdtp::DeserializableProtocolObject<getCookiesParams> {
    Maybe<String> browserContextId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getCookiesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("browserContextId", browserContextId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getCookiesParams params;
    if (!getCookiesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->GetCookies(std::move(params.browserContextId), std::make_unique<GetCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class SetCookiesCallbackImpl : public Backend::SetCookiesCallback, public DomainDispatcher::Callback {
public:
    SetCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.setCookies"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct setCookiesParams : public crdtp::DeserializableProtocolObject<setCookiesParams> {
    std::unique_ptr<protocol::Array<protocol::Network::CookieParam>> cookies;
    Maybe<String> browserContextId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setCookiesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("browserContextId", browserContextId),
    CRDTP_DESERIALIZE_FIELD("cookies", cookies),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setCookiesParams params;
    if (!setCookiesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->SetCookies(std::move(params.cookies), std::move(params.browserContextId), std::make_unique<SetCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ClearCookiesCallbackImpl : public Backend::ClearCookiesCallback, public DomainDispatcher::Callback {
public:
    ClearCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.clearCookies"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct clearCookiesParams : public crdtp::DeserializableProtocolObject<clearCookiesParams> {
    Maybe<String> browserContextId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(clearCookiesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("browserContextId", browserContextId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::clearCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    clearCookiesParams params;
    if (!clearCookiesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->ClearCookies(std::move(params.browserContextId), std::make_unique<ClearCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetUsageAndQuotaCallbackImpl : public Backend::GetUsageAndQuotaCallback, public DomainDispatcher::Callback {
public:
    GetUsageAndQuotaCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.getUsageAndQuota"), message) { }

    void sendSuccess(double usage, double quota, bool overrideActive, std::unique_ptr<protocol::Array<protocol::Storage::UsageForType>> usageBreakdown) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("usage"), usage);
        serializer.AddField(crdtp::MakeSpan("quota"), quota);
        serializer.AddField(crdtp::MakeSpan("overrideActive"), overrideActive);
        serializer.AddField(crdtp::MakeSpan("usageBreakdown"), usageBreakdown);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getUsageAndQuotaParams : public crdtp::DeserializableProtocolObject<getUsageAndQuotaParams> {
    String origin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getUsageAndQuotaParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getUsageAndQuota(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getUsageAndQuotaParams params;
    if (!getUsageAndQuotaParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->GetUsageAndQuota(params.origin, std::make_unique<GetUsageAndQuotaCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class OverrideQuotaForOriginCallbackImpl : public Backend::OverrideQuotaForOriginCallback, public DomainDispatcher::Callback {
public:
    OverrideQuotaForOriginCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.overrideQuotaForOrigin"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct overrideQuotaForOriginParams : public crdtp::DeserializableProtocolObject<overrideQuotaForOriginParams> {
    String origin;
    Maybe<double> quotaSize;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(overrideQuotaForOriginParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
    CRDTP_DESERIALIZE_FIELD_OPT("quotaSize", quotaSize),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::overrideQuotaForOrigin(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    overrideQuotaForOriginParams params;
    if (!overrideQuotaForOriginParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->OverrideQuotaForOrigin(params.origin, std::move(params.quotaSize), std::make_unique<OverrideQuotaForOriginCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct trackCacheStorageForOriginParams : public crdtp::DeserializableProtocolObject<trackCacheStorageForOriginParams> {
    String origin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(trackCacheStorageForOriginParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::trackCacheStorageForOrigin(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    trackCacheStorageForOriginParams params;
    if (!trackCacheStorageForOriginParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->TrackCacheStorageForOrigin(params.origin);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.trackCacheStorageForOrigin"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct trackIndexedDBForOriginParams : public crdtp::DeserializableProtocolObject<trackIndexedDBForOriginParams> {
    String origin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(trackIndexedDBForOriginParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::trackIndexedDBForOrigin(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    trackIndexedDBForOriginParams params;
    if (!trackIndexedDBForOriginParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->TrackIndexedDBForOrigin(params.origin);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.trackIndexedDBForOrigin"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct trackIndexedDBForStorageKeyParams : public crdtp::DeserializableProtocolObject<trackIndexedDBForStorageKeyParams> {
    String storageKey;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(trackIndexedDBForStorageKeyParams)
    CRDTP_DESERIALIZE_FIELD("storageKey", storageKey),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::trackIndexedDBForStorageKey(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    trackIndexedDBForStorageKeyParams params;
    if (!trackIndexedDBForStorageKeyParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->TrackIndexedDBForStorageKey(params.storageKey);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.trackIndexedDBForStorageKey"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct untrackCacheStorageForOriginParams : public crdtp::DeserializableProtocolObject<untrackCacheStorageForOriginParams> {
    String origin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(untrackCacheStorageForOriginParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::untrackCacheStorageForOrigin(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    untrackCacheStorageForOriginParams params;
    if (!untrackCacheStorageForOriginParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->UntrackCacheStorageForOrigin(params.origin);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.untrackCacheStorageForOrigin"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct untrackIndexedDBForOriginParams : public crdtp::DeserializableProtocolObject<untrackIndexedDBForOriginParams> {
    String origin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(untrackIndexedDBForOriginParams)
    CRDTP_DESERIALIZE_FIELD("origin", origin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::untrackIndexedDBForOrigin(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    untrackIndexedDBForOriginParams params;
    if (!untrackIndexedDBForOriginParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->UntrackIndexedDBForOrigin(params.origin);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.untrackIndexedDBForOrigin"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct untrackIndexedDBForStorageKeyParams : public crdtp::DeserializableProtocolObject<untrackIndexedDBForStorageKeyParams> {
    String storageKey;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(untrackIndexedDBForStorageKeyParams)
    CRDTP_DESERIALIZE_FIELD("storageKey", storageKey),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::untrackIndexedDBForStorageKey(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    untrackIndexedDBForStorageKeyParams params;
    if (!untrackIndexedDBForStorageKeyParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->UntrackIndexedDBForStorageKey(params.storageKey);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.untrackIndexedDBForStorageKey"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class GetTrustTokensCallbackImpl : public Backend::GetTrustTokensCallback, public DomainDispatcher::Callback {
public:
    GetTrustTokensCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.getTrustTokens"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Storage::TrustTokens>> tokens) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("tokens"), tokens);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::getTrustTokens(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    m_backend->GetTrustTokens(std::make_unique<GetTrustTokensCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ClearTrustTokensCallbackImpl : public Backend::ClearTrustTokensCallback, public DomainDispatcher::Callback {
public:
    ClearTrustTokensCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.clearTrustTokens"), message) { }

    void sendSuccess(bool didDeleteTokens) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("didDeleteTokens"), didDeleteTokens);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct clearTrustTokensParams : public crdtp::DeserializableProtocolObject<clearTrustTokensParams> {
    String issuerOrigin;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(clearTrustTokensParams)
    CRDTP_DESERIALIZE_FIELD("issuerOrigin", issuerOrigin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::clearTrustTokens(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    clearTrustTokensParams params;
    if (!clearTrustTokensParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->ClearTrustTokens(params.issuerOrigin, std::make_unique<ClearTrustTokensCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetInterestGroupDetailsCallbackImpl : public Backend::GetInterestGroupDetailsCallback, public DomainDispatcher::Callback {
public:
    GetInterestGroupDetailsCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Storage.getInterestGroupDetails"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Storage::InterestGroupDetails> details) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("details"), details);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getInterestGroupDetailsParams : public crdtp::DeserializableProtocolObject<getInterestGroupDetailsParams> {
    String ownerOrigin;
    String name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getInterestGroupDetailsParams)
    CRDTP_DESERIALIZE_FIELD("name", name),
    CRDTP_DESERIALIZE_FIELD("ownerOrigin", ownerOrigin),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getInterestGroupDetails(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getInterestGroupDetailsParams params;
    if (!getInterestGroupDetailsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->GetInterestGroupDetails(params.ownerOrigin, params.name, std::make_unique<GetInterestGroupDetailsCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct setInterestGroupTrackingParams : public crdtp::DeserializableProtocolObject<setInterestGroupTrackingParams> {
    bool enable;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setInterestGroupTrackingParams)
    CRDTP_DESERIALIZE_FIELD("enable", enable),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setInterestGroupTracking(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setInterestGroupTrackingParams params;
    if (!setInterestGroupTrackingParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetInterestGroupTracking(params.enable);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Storage.setInterestGroupTracking"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Storage"), SortedRedirects(), std::move(dispatcher));
}

} // Storage
} // namespace content
} // namespace protocol
