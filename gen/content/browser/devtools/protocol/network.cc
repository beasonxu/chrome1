// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "content/browser/devtools/protocol/network.h"

#include "content/browser/devtools/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace content {
namespace protocol {
namespace Network {

using crdtp::DeserializerState;
using crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Network";
const char Metainfo::commandPrefix[] = "Network.";
const char Metainfo::version[] = "1.3";

namespace ResourceTypeEnum {
const char Document[] = "Document";
const char Stylesheet[] = "Stylesheet";
const char Image[] = "Image";
const char Media[] = "Media";
const char Font[] = "Font";
const char Script[] = "Script";
const char TextTrack[] = "TextTrack";
const char XHR[] = "XHR";
const char Fetch[] = "Fetch";
const char Prefetch[] = "Prefetch";
const char EventSource[] = "EventSource";
const char WebSocket[] = "WebSocket";
const char Manifest[] = "Manifest";
const char SignedExchange[] = "SignedExchange";
const char Ping[] = "Ping";
const char CSPViolationReport[] = "CSPViolationReport";
const char Preflight[] = "Preflight";
const char Other[] = "Other";
} // namespace ResourceTypeEnum





namespace ErrorReasonEnum {
const char Failed[] = "Failed";
const char Aborted[] = "Aborted";
const char TimedOut[] = "TimedOut";
const char AccessDenied[] = "AccessDenied";
const char ConnectionClosed[] = "ConnectionClosed";
const char ConnectionReset[] = "ConnectionReset";
const char ConnectionRefused[] = "ConnectionRefused";
const char ConnectionAborted[] = "ConnectionAborted";
const char ConnectionFailed[] = "ConnectionFailed";
const char NameNotResolved[] = "NameNotResolved";
const char InternetDisconnected[] = "InternetDisconnected";
const char AddressUnreachable[] = "AddressUnreachable";
const char BlockedByClient[] = "BlockedByClient";
const char BlockedByResponse[] = "BlockedByResponse";
} // namespace ErrorReasonEnum





namespace ConnectionTypeEnum {
const char None[] = "none";
const char Cellular2g[] = "cellular2g";
const char Cellular3g[] = "cellular3g";
const char Cellular4g[] = "cellular4g";
const char Bluetooth[] = "bluetooth";
const char Ethernet[] = "ethernet";
const char Wifi[] = "wifi";
const char Wimax[] = "wimax";
const char Other[] = "other";
} // namespace ConnectionTypeEnum


namespace CookieSameSiteEnum {
const char Strict[] = "Strict";
const char Lax[] = "Lax";
const char None[] = "None";
} // namespace CookieSameSiteEnum


namespace CookiePriorityEnum {
const char Low[] = "Low";
const char Medium[] = "Medium";
const char High[] = "High";
} // namespace CookiePriorityEnum


namespace CookieSourceSchemeEnum {
const char Unset[] = "Unset";
const char NonSecure[] = "NonSecure";
const char Secure[] = "Secure";
} // namespace CookieSourceSchemeEnum


CRDTP_BEGIN_DESERIALIZER(ResourceTiming)
    CRDTP_DESERIALIZE_FIELD("connectEnd", m_connectEnd),
    CRDTP_DESERIALIZE_FIELD("connectStart", m_connectStart),
    CRDTP_DESERIALIZE_FIELD("dnsEnd", m_dnsEnd),
    CRDTP_DESERIALIZE_FIELD("dnsStart", m_dnsStart),
    CRDTP_DESERIALIZE_FIELD("proxyEnd", m_proxyEnd),
    CRDTP_DESERIALIZE_FIELD("proxyStart", m_proxyStart),
    CRDTP_DESERIALIZE_FIELD("pushEnd", m_pushEnd),
    CRDTP_DESERIALIZE_FIELD("pushStart", m_pushStart),
    CRDTP_DESERIALIZE_FIELD("receiveHeadersEnd", m_receiveHeadersEnd),
    CRDTP_DESERIALIZE_FIELD("requestTime", m_requestTime),
    CRDTP_DESERIALIZE_FIELD("sendEnd", m_sendEnd),
    CRDTP_DESERIALIZE_FIELD("sendStart", m_sendStart),
    CRDTP_DESERIALIZE_FIELD("sslEnd", m_sslEnd),
    CRDTP_DESERIALIZE_FIELD("sslStart", m_sslStart),
    CRDTP_DESERIALIZE_FIELD("workerFetchStart", m_workerFetchStart),
    CRDTP_DESERIALIZE_FIELD("workerReady", m_workerReady),
    CRDTP_DESERIALIZE_FIELD("workerRespondWithSettled", m_workerRespondWithSettled),
    CRDTP_DESERIALIZE_FIELD("workerStart", m_workerStart),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ResourceTiming)
    CRDTP_SERIALIZE_FIELD("requestTime", m_requestTime);
    CRDTP_SERIALIZE_FIELD("proxyStart", m_proxyStart);
    CRDTP_SERIALIZE_FIELD("proxyEnd", m_proxyEnd);
    CRDTP_SERIALIZE_FIELD("dnsStart", m_dnsStart);
    CRDTP_SERIALIZE_FIELD("dnsEnd", m_dnsEnd);
    CRDTP_SERIALIZE_FIELD("connectStart", m_connectStart);
    CRDTP_SERIALIZE_FIELD("connectEnd", m_connectEnd);
    CRDTP_SERIALIZE_FIELD("sslStart", m_sslStart);
    CRDTP_SERIALIZE_FIELD("sslEnd", m_sslEnd);
    CRDTP_SERIALIZE_FIELD("workerStart", m_workerStart);
    CRDTP_SERIALIZE_FIELD("workerReady", m_workerReady);
    CRDTP_SERIALIZE_FIELD("workerFetchStart", m_workerFetchStart);
    CRDTP_SERIALIZE_FIELD("workerRespondWithSettled", m_workerRespondWithSettled);
    CRDTP_SERIALIZE_FIELD("sendStart", m_sendStart);
    CRDTP_SERIALIZE_FIELD("sendEnd", m_sendEnd);
    CRDTP_SERIALIZE_FIELD("pushStart", m_pushStart);
    CRDTP_SERIALIZE_FIELD("pushEnd", m_pushEnd);
    CRDTP_SERIALIZE_FIELD("receiveHeadersEnd", m_receiveHeadersEnd);
CRDTP_END_SERIALIZER();


namespace ResourcePriorityEnum {
const char VeryLow[] = "VeryLow";
const char Low[] = "Low";
const char Medium[] = "Medium";
const char High[] = "High";
const char VeryHigh[] = "VeryHigh";
} // namespace ResourcePriorityEnum


CRDTP_BEGIN_DESERIALIZER(PostDataEntry)
    CRDTP_DESERIALIZE_FIELD_OPT("bytes", m_bytes),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(PostDataEntry)
    CRDTP_SERIALIZE_FIELD("bytes", m_bytes);
CRDTP_END_SERIALIZER();



const char* Request::ReferrerPolicyEnum::UnsafeUrl = "unsafe-url";
const char* Request::ReferrerPolicyEnum::NoReferrerWhenDowngrade = "no-referrer-when-downgrade";
const char* Request::ReferrerPolicyEnum::NoReferrer = "no-referrer";
const char* Request::ReferrerPolicyEnum::Origin = "origin";
const char* Request::ReferrerPolicyEnum::OriginWhenCrossOrigin = "origin-when-cross-origin";
const char* Request::ReferrerPolicyEnum::SameOrigin = "same-origin";
const char* Request::ReferrerPolicyEnum::StrictOrigin = "strict-origin";
const char* Request::ReferrerPolicyEnum::StrictOriginWhenCrossOrigin = "strict-origin-when-cross-origin";
CRDTP_BEGIN_DESERIALIZER(Request)
    CRDTP_DESERIALIZE_FIELD_OPT("hasPostData", m_hasPostData),
    CRDTP_DESERIALIZE_FIELD("headers", m_headers),
    CRDTP_DESERIALIZE_FIELD("initialPriority", m_initialPriority),
    CRDTP_DESERIALIZE_FIELD_OPT("isLinkPreload", m_isLinkPreload),
    CRDTP_DESERIALIZE_FIELD_OPT("isSameSite", m_isSameSite),
    CRDTP_DESERIALIZE_FIELD("method", m_method),
    CRDTP_DESERIALIZE_FIELD_OPT("mixedContentType", m_mixedContentType),
    CRDTP_DESERIALIZE_FIELD_OPT("postData", m_postData),
    CRDTP_DESERIALIZE_FIELD_OPT("postDataEntries", m_postDataEntries),
    CRDTP_DESERIALIZE_FIELD("referrerPolicy", m_referrerPolicy),
    CRDTP_DESERIALIZE_FIELD_OPT("trustTokenParams", m_trustTokenParams),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
    CRDTP_DESERIALIZE_FIELD_OPT("urlFragment", m_urlFragment),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Request)
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("urlFragment", m_urlFragment);
    CRDTP_SERIALIZE_FIELD("method", m_method);
    CRDTP_SERIALIZE_FIELD("headers", m_headers);
    CRDTP_SERIALIZE_FIELD("postData", m_postData);
    CRDTP_SERIALIZE_FIELD("hasPostData", m_hasPostData);
    CRDTP_SERIALIZE_FIELD("postDataEntries", m_postDataEntries);
    CRDTP_SERIALIZE_FIELD("mixedContentType", m_mixedContentType);
    CRDTP_SERIALIZE_FIELD("initialPriority", m_initialPriority);
    CRDTP_SERIALIZE_FIELD("referrerPolicy", m_referrerPolicy);
    CRDTP_SERIALIZE_FIELD("isLinkPreload", m_isLinkPreload);
    CRDTP_SERIALIZE_FIELD("trustTokenParams", m_trustTokenParams);
    CRDTP_SERIALIZE_FIELD("isSameSite", m_isSameSite);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SignedCertificateTimestamp)
    CRDTP_DESERIALIZE_FIELD("hashAlgorithm", m_hashAlgorithm),
    CRDTP_DESERIALIZE_FIELD("logDescription", m_logDescription),
    CRDTP_DESERIALIZE_FIELD("logId", m_logId),
    CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    CRDTP_DESERIALIZE_FIELD("signatureAlgorithm", m_signatureAlgorithm),
    CRDTP_DESERIALIZE_FIELD("signatureData", m_signatureData),
    CRDTP_DESERIALIZE_FIELD("status", m_status),
    CRDTP_DESERIALIZE_FIELD("timestamp", m_timestamp),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SignedCertificateTimestamp)
    CRDTP_SERIALIZE_FIELD("status", m_status);
    CRDTP_SERIALIZE_FIELD("origin", m_origin);
    CRDTP_SERIALIZE_FIELD("logDescription", m_logDescription);
    CRDTP_SERIALIZE_FIELD("logId", m_logId);
    CRDTP_SERIALIZE_FIELD("timestamp", m_timestamp);
    CRDTP_SERIALIZE_FIELD("hashAlgorithm", m_hashAlgorithm);
    CRDTP_SERIALIZE_FIELD("signatureAlgorithm", m_signatureAlgorithm);
    CRDTP_SERIALIZE_FIELD("signatureData", m_signatureData);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SecurityDetails)
    CRDTP_DESERIALIZE_FIELD("certificateId", m_certificateId),
    CRDTP_DESERIALIZE_FIELD("certificateTransparencyCompliance", m_certificateTransparencyCompliance),
    CRDTP_DESERIALIZE_FIELD("cipher", m_cipher),
    CRDTP_DESERIALIZE_FIELD("encryptedClientHello", m_encryptedClientHello),
    CRDTP_DESERIALIZE_FIELD("issuer", m_issuer),
    CRDTP_DESERIALIZE_FIELD("keyExchange", m_keyExchange),
    CRDTP_DESERIALIZE_FIELD_OPT("keyExchangeGroup", m_keyExchangeGroup),
    CRDTP_DESERIALIZE_FIELD_OPT("mac", m_mac),
    CRDTP_DESERIALIZE_FIELD("protocol", m_protocol),
    CRDTP_DESERIALIZE_FIELD("sanList", m_sanList),
    CRDTP_DESERIALIZE_FIELD_OPT("serverSignatureAlgorithm", m_serverSignatureAlgorithm),
    CRDTP_DESERIALIZE_FIELD("signedCertificateTimestampList", m_signedCertificateTimestampList),
    CRDTP_DESERIALIZE_FIELD("subjectName", m_subjectName),
    CRDTP_DESERIALIZE_FIELD("validFrom", m_validFrom),
    CRDTP_DESERIALIZE_FIELD("validTo", m_validTo),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SecurityDetails)
    CRDTP_SERIALIZE_FIELD("protocol", m_protocol);
    CRDTP_SERIALIZE_FIELD("keyExchange", m_keyExchange);
    CRDTP_SERIALIZE_FIELD("keyExchangeGroup", m_keyExchangeGroup);
    CRDTP_SERIALIZE_FIELD("cipher", m_cipher);
    CRDTP_SERIALIZE_FIELD("mac", m_mac);
    CRDTP_SERIALIZE_FIELD("certificateId", m_certificateId);
    CRDTP_SERIALIZE_FIELD("subjectName", m_subjectName);
    CRDTP_SERIALIZE_FIELD("sanList", m_sanList);
    CRDTP_SERIALIZE_FIELD("issuer", m_issuer);
    CRDTP_SERIALIZE_FIELD("validFrom", m_validFrom);
    CRDTP_SERIALIZE_FIELD("validTo", m_validTo);
    CRDTP_SERIALIZE_FIELD("signedCertificateTimestampList", m_signedCertificateTimestampList);
    CRDTP_SERIALIZE_FIELD("certificateTransparencyCompliance", m_certificateTransparencyCompliance);
    CRDTP_SERIALIZE_FIELD("serverSignatureAlgorithm", m_serverSignatureAlgorithm);
    CRDTP_SERIALIZE_FIELD("encryptedClientHello", m_encryptedClientHello);
CRDTP_END_SERIALIZER();


namespace CertificateTransparencyComplianceEnum {
const char Unknown[] = "unknown";
const char NotCompliant[] = "not-compliant";
const char Compliant[] = "compliant";
} // namespace CertificateTransparencyComplianceEnum


namespace BlockedReasonEnum {
const char Other[] = "other";
const char Csp[] = "csp";
const char MixedContent[] = "mixed-content";
const char Origin[] = "origin";
const char Inspector[] = "inspector";
const char SubresourceFilter[] = "subresource-filter";
const char ContentType[] = "content-type";
const char CoepFrameResourceNeedsCoepHeader[] = "coep-frame-resource-needs-coep-header";
const char CoopSandboxedIframeCannotNavigateToCoopPage[] = "coop-sandboxed-iframe-cannot-navigate-to-coop-page";
const char CorpNotSameOrigin[] = "corp-not-same-origin";
const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[] = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep";
const char CorpNotSameSite[] = "corp-not-same-site";
} // namespace BlockedReasonEnum


namespace CorsErrorEnum {
const char DisallowedByMode[] = "DisallowedByMode";
const char InvalidResponse[] = "InvalidResponse";
const char WildcardOriginNotAllowed[] = "WildcardOriginNotAllowed";
const char MissingAllowOriginHeader[] = "MissingAllowOriginHeader";
const char MultipleAllowOriginValues[] = "MultipleAllowOriginValues";
const char InvalidAllowOriginValue[] = "InvalidAllowOriginValue";
const char AllowOriginMismatch[] = "AllowOriginMismatch";
const char InvalidAllowCredentials[] = "InvalidAllowCredentials";
const char CorsDisabledScheme[] = "CorsDisabledScheme";
const char PreflightInvalidStatus[] = "PreflightInvalidStatus";
const char PreflightDisallowedRedirect[] = "PreflightDisallowedRedirect";
const char PreflightWildcardOriginNotAllowed[] = "PreflightWildcardOriginNotAllowed";
const char PreflightMissingAllowOriginHeader[] = "PreflightMissingAllowOriginHeader";
const char PreflightMultipleAllowOriginValues[] = "PreflightMultipleAllowOriginValues";
const char PreflightInvalidAllowOriginValue[] = "PreflightInvalidAllowOriginValue";
const char PreflightAllowOriginMismatch[] = "PreflightAllowOriginMismatch";
const char PreflightInvalidAllowCredentials[] = "PreflightInvalidAllowCredentials";
const char PreflightMissingAllowExternal[] = "PreflightMissingAllowExternal";
const char PreflightInvalidAllowExternal[] = "PreflightInvalidAllowExternal";
const char PreflightMissingAllowPrivateNetwork[] = "PreflightMissingAllowPrivateNetwork";
const char PreflightInvalidAllowPrivateNetwork[] = "PreflightInvalidAllowPrivateNetwork";
const char InvalidAllowMethodsPreflightResponse[] = "InvalidAllowMethodsPreflightResponse";
const char InvalidAllowHeadersPreflightResponse[] = "InvalidAllowHeadersPreflightResponse";
const char MethodDisallowedByPreflightResponse[] = "MethodDisallowedByPreflightResponse";
const char HeaderDisallowedByPreflightResponse[] = "HeaderDisallowedByPreflightResponse";
const char RedirectContainsCredentials[] = "RedirectContainsCredentials";
const char InsecurePrivateNetwork[] = "InsecurePrivateNetwork";
const char InvalidPrivateNetworkAccess[] = "InvalidPrivateNetworkAccess";
const char UnexpectedPrivateNetworkAccess[] = "UnexpectedPrivateNetworkAccess";
const char NoCorsRedirectModeNotFollow[] = "NoCorsRedirectModeNotFollow";
} // namespace CorsErrorEnum


CRDTP_BEGIN_DESERIALIZER(CorsErrorStatus)
    CRDTP_DESERIALIZE_FIELD("corsError", m_corsError),
    CRDTP_DESERIALIZE_FIELD("failedParameter", m_failedParameter),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CorsErrorStatus)
    CRDTP_SERIALIZE_FIELD("corsError", m_corsError);
    CRDTP_SERIALIZE_FIELD("failedParameter", m_failedParameter);
CRDTP_END_SERIALIZER();


namespace ServiceWorkerResponseSourceEnum {
const char CacheStorage[] = "cache-storage";
const char HttpCache[] = "http-cache";
const char FallbackCode[] = "fallback-code";
const char Network[] = "network";
} // namespace ServiceWorkerResponseSourceEnum



const char* TrustTokenParams::RefreshPolicyEnum::UseCached = "UseCached";
const char* TrustTokenParams::RefreshPolicyEnum::Refresh = "Refresh";
CRDTP_BEGIN_DESERIALIZER(TrustTokenParams)
    CRDTP_DESERIALIZE_FIELD_OPT("issuers", m_issuers),
    CRDTP_DESERIALIZE_FIELD("refreshPolicy", m_refreshPolicy),
    CRDTP_DESERIALIZE_FIELD("type", m_type),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(TrustTokenParams)
    CRDTP_SERIALIZE_FIELD("type", m_type);
    CRDTP_SERIALIZE_FIELD("refreshPolicy", m_refreshPolicy);
    CRDTP_SERIALIZE_FIELD("issuers", m_issuers);
CRDTP_END_SERIALIZER();


namespace TrustTokenOperationTypeEnum {
const char Issuance[] = "Issuance";
const char Redemption[] = "Redemption";
const char Signing[] = "Signing";
} // namespace TrustTokenOperationTypeEnum


CRDTP_BEGIN_DESERIALIZER(Response)
    CRDTP_DESERIALIZE_FIELD_OPT("cacheStorageCacheName", m_cacheStorageCacheName),
    CRDTP_DESERIALIZE_FIELD("connectionId", m_connectionId),
    CRDTP_DESERIALIZE_FIELD("connectionReused", m_connectionReused),
    CRDTP_DESERIALIZE_FIELD("encodedDataLength", m_encodedDataLength),
    CRDTP_DESERIALIZE_FIELD_OPT("fromDiskCache", m_fromDiskCache),
    CRDTP_DESERIALIZE_FIELD_OPT("fromPrefetchCache", m_fromPrefetchCache),
    CRDTP_DESERIALIZE_FIELD_OPT("fromServiceWorker", m_fromServiceWorker),
    CRDTP_DESERIALIZE_FIELD("headers", m_headers),
    CRDTP_DESERIALIZE_FIELD_OPT("headersText", m_headersText),
    CRDTP_DESERIALIZE_FIELD("mimeType", m_mimeType),
    CRDTP_DESERIALIZE_FIELD_OPT("protocol", m_protocol),
    CRDTP_DESERIALIZE_FIELD_OPT("remoteIPAddress", m_remoteIPAddress),
    CRDTP_DESERIALIZE_FIELD_OPT("remotePort", m_remotePort),
    CRDTP_DESERIALIZE_FIELD_OPT("requestHeaders", m_requestHeaders),
    CRDTP_DESERIALIZE_FIELD_OPT("requestHeadersText", m_requestHeadersText),
    CRDTP_DESERIALIZE_FIELD_OPT("responseTime", m_responseTime),
    CRDTP_DESERIALIZE_FIELD_OPT("securityDetails", m_securityDetails),
    CRDTP_DESERIALIZE_FIELD("securityState", m_securityState),
    CRDTP_DESERIALIZE_FIELD_OPT("serviceWorkerResponseSource", m_serviceWorkerResponseSource),
    CRDTP_DESERIALIZE_FIELD("status", m_status),
    CRDTP_DESERIALIZE_FIELD("statusText", m_statusText),
    CRDTP_DESERIALIZE_FIELD_OPT("timing", m_timing),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Response)
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("status", m_status);
    CRDTP_SERIALIZE_FIELD("statusText", m_statusText);
    CRDTP_SERIALIZE_FIELD("headers", m_headers);
    CRDTP_SERIALIZE_FIELD("headersText", m_headersText);
    CRDTP_SERIALIZE_FIELD("mimeType", m_mimeType);
    CRDTP_SERIALIZE_FIELD("requestHeaders", m_requestHeaders);
    CRDTP_SERIALIZE_FIELD("requestHeadersText", m_requestHeadersText);
    CRDTP_SERIALIZE_FIELD("connectionReused", m_connectionReused);
    CRDTP_SERIALIZE_FIELD("connectionId", m_connectionId);
    CRDTP_SERIALIZE_FIELD("remoteIPAddress", m_remoteIPAddress);
    CRDTP_SERIALIZE_FIELD("remotePort", m_remotePort);
    CRDTP_SERIALIZE_FIELD("fromDiskCache", m_fromDiskCache);
    CRDTP_SERIALIZE_FIELD("fromServiceWorker", m_fromServiceWorker);
    CRDTP_SERIALIZE_FIELD("fromPrefetchCache", m_fromPrefetchCache);
    CRDTP_SERIALIZE_FIELD("encodedDataLength", m_encodedDataLength);
    CRDTP_SERIALIZE_FIELD("timing", m_timing);
    CRDTP_SERIALIZE_FIELD("serviceWorkerResponseSource", m_serviceWorkerResponseSource);
    CRDTP_SERIALIZE_FIELD("responseTime", m_responseTime);
    CRDTP_SERIALIZE_FIELD("cacheStorageCacheName", m_cacheStorageCacheName);
    CRDTP_SERIALIZE_FIELD("protocol", m_protocol);
    CRDTP_SERIALIZE_FIELD("securityState", m_securityState);
    CRDTP_SERIALIZE_FIELD("securityDetails", m_securityDetails);
CRDTP_END_SERIALIZER();



const char* Initiator::TypeEnum::Parser = "parser";
const char* Initiator::TypeEnum::Script = "script";
const char* Initiator::TypeEnum::Preload = "preload";
const char* Initiator::TypeEnum::SignedExchange = "SignedExchange";
const char* Initiator::TypeEnum::Preflight = "preflight";
const char* Initiator::TypeEnum::Other = "other";
CRDTP_BEGIN_DESERIALIZER(Initiator)
    CRDTP_DESERIALIZE_FIELD_OPT("columnNumber", m_columnNumber),
    CRDTP_DESERIALIZE_FIELD_OPT("lineNumber", m_lineNumber),
    CRDTP_DESERIALIZE_FIELD_OPT("requestId", m_requestId),
    CRDTP_DESERIALIZE_FIELD_OPT("stack", m_stack),
    CRDTP_DESERIALIZE_FIELD("type", m_type),
    CRDTP_DESERIALIZE_FIELD_OPT("url", m_url),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Initiator)
    CRDTP_SERIALIZE_FIELD("type", m_type);
    CRDTP_SERIALIZE_FIELD("stack", m_stack);
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("lineNumber", m_lineNumber);
    CRDTP_SERIALIZE_FIELD("columnNumber", m_columnNumber);
    CRDTP_SERIALIZE_FIELD("requestId", m_requestId);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(Cookie)
    CRDTP_DESERIALIZE_FIELD("domain", m_domain),
    CRDTP_DESERIALIZE_FIELD("expires", m_expires),
    CRDTP_DESERIALIZE_FIELD("httpOnly", m_httpOnly),
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD_OPT("partitionKey", m_partitionKey),
    CRDTP_DESERIALIZE_FIELD_OPT("partitionKeyOpaque", m_partitionKeyOpaque),
    CRDTP_DESERIALIZE_FIELD("path", m_path),
    CRDTP_DESERIALIZE_FIELD("priority", m_priority),
    CRDTP_DESERIALIZE_FIELD("sameParty", m_sameParty),
    CRDTP_DESERIALIZE_FIELD_OPT("sameSite", m_sameSite),
    CRDTP_DESERIALIZE_FIELD("secure", m_secure),
    CRDTP_DESERIALIZE_FIELD("session", m_session),
    CRDTP_DESERIALIZE_FIELD("size", m_size),
    CRDTP_DESERIALIZE_FIELD("sourcePort", m_sourcePort),
    CRDTP_DESERIALIZE_FIELD("sourceScheme", m_sourceScheme),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Cookie)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("domain", m_domain);
    CRDTP_SERIALIZE_FIELD("path", m_path);
    CRDTP_SERIALIZE_FIELD("expires", m_expires);
    CRDTP_SERIALIZE_FIELD("size", m_size);
    CRDTP_SERIALIZE_FIELD("httpOnly", m_httpOnly);
    CRDTP_SERIALIZE_FIELD("secure", m_secure);
    CRDTP_SERIALIZE_FIELD("session", m_session);
    CRDTP_SERIALIZE_FIELD("sameSite", m_sameSite);
    CRDTP_SERIALIZE_FIELD("priority", m_priority);
    CRDTP_SERIALIZE_FIELD("sameParty", m_sameParty);
    CRDTP_SERIALIZE_FIELD("sourceScheme", m_sourceScheme);
    CRDTP_SERIALIZE_FIELD("sourcePort", m_sourcePort);
    CRDTP_SERIALIZE_FIELD("partitionKey", m_partitionKey);
    CRDTP_SERIALIZE_FIELD("partitionKeyOpaque", m_partitionKeyOpaque);
CRDTP_END_SERIALIZER();


namespace SetCookieBlockedReasonEnum {
const char SecureOnly[] = "SecureOnly";
const char SameSiteStrict[] = "SameSiteStrict";
const char SameSiteLax[] = "SameSiteLax";
const char SameSiteUnspecifiedTreatedAsLax[] = "SameSiteUnspecifiedTreatedAsLax";
const char SameSiteNoneInsecure[] = "SameSiteNoneInsecure";
const char UserPreferences[] = "UserPreferences";
const char SyntaxError[] = "SyntaxError";
const char SchemeNotSupported[] = "SchemeNotSupported";
const char OverwriteSecure[] = "OverwriteSecure";
const char InvalidDomain[] = "InvalidDomain";
const char InvalidPrefix[] = "InvalidPrefix";
const char UnknownError[] = "UnknownError";
const char SchemefulSameSiteStrict[] = "SchemefulSameSiteStrict";
const char SchemefulSameSiteLax[] = "SchemefulSameSiteLax";
const char SchemefulSameSiteUnspecifiedTreatedAsLax[] = "SchemefulSameSiteUnspecifiedTreatedAsLax";
const char SamePartyFromCrossPartyContext[] = "SamePartyFromCrossPartyContext";
const char SamePartyConflictsWithOtherAttributes[] = "SamePartyConflictsWithOtherAttributes";
const char NameValuePairExceedsMaxSize[] = "NameValuePairExceedsMaxSize";
} // namespace SetCookieBlockedReasonEnum


namespace CookieBlockedReasonEnum {
const char SecureOnly[] = "SecureOnly";
const char NotOnPath[] = "NotOnPath";
const char DomainMismatch[] = "DomainMismatch";
const char SameSiteStrict[] = "SameSiteStrict";
const char SameSiteLax[] = "SameSiteLax";
const char SameSiteUnspecifiedTreatedAsLax[] = "SameSiteUnspecifiedTreatedAsLax";
const char SameSiteNoneInsecure[] = "SameSiteNoneInsecure";
const char UserPreferences[] = "UserPreferences";
const char UnknownError[] = "UnknownError";
const char SchemefulSameSiteStrict[] = "SchemefulSameSiteStrict";
const char SchemefulSameSiteLax[] = "SchemefulSameSiteLax";
const char SchemefulSameSiteUnspecifiedTreatedAsLax[] = "SchemefulSameSiteUnspecifiedTreatedAsLax";
const char SamePartyFromCrossPartyContext[] = "SamePartyFromCrossPartyContext";
const char NameValuePairExceedsMaxSize[] = "NameValuePairExceedsMaxSize";
} // namespace CookieBlockedReasonEnum


CRDTP_BEGIN_DESERIALIZER(BlockedSetCookieWithReason)
    CRDTP_DESERIALIZE_FIELD("blockedReasons", m_blockedReasons),
    CRDTP_DESERIALIZE_FIELD_OPT("cookie", m_cookie),
    CRDTP_DESERIALIZE_FIELD("cookieLine", m_cookieLine),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(BlockedSetCookieWithReason)
    CRDTP_SERIALIZE_FIELD("blockedReasons", m_blockedReasons);
    CRDTP_SERIALIZE_FIELD("cookieLine", m_cookieLine);
    CRDTP_SERIALIZE_FIELD("cookie", m_cookie);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(BlockedCookieWithReason)
    CRDTP_DESERIALIZE_FIELD("blockedReasons", m_blockedReasons),
    CRDTP_DESERIALIZE_FIELD("cookie", m_cookie),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(BlockedCookieWithReason)
    CRDTP_SERIALIZE_FIELD("blockedReasons", m_blockedReasons);
    CRDTP_SERIALIZE_FIELD("cookie", m_cookie);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CookieParam)
    CRDTP_DESERIALIZE_FIELD_OPT("domain", m_domain),
    CRDTP_DESERIALIZE_FIELD_OPT("expires", m_expires),
    CRDTP_DESERIALIZE_FIELD_OPT("httpOnly", m_httpOnly),
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD_OPT("partitionKey", m_partitionKey),
    CRDTP_DESERIALIZE_FIELD_OPT("path", m_path),
    CRDTP_DESERIALIZE_FIELD_OPT("priority", m_priority),
    CRDTP_DESERIALIZE_FIELD_OPT("sameParty", m_sameParty),
    CRDTP_DESERIALIZE_FIELD_OPT("sameSite", m_sameSite),
    CRDTP_DESERIALIZE_FIELD_OPT("secure", m_secure),
    CRDTP_DESERIALIZE_FIELD_OPT("sourcePort", m_sourcePort),
    CRDTP_DESERIALIZE_FIELD_OPT("sourceScheme", m_sourceScheme),
    CRDTP_DESERIALIZE_FIELD_OPT("url", m_url),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CookieParam)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("domain", m_domain);
    CRDTP_SERIALIZE_FIELD("path", m_path);
    CRDTP_SERIALIZE_FIELD("secure", m_secure);
    CRDTP_SERIALIZE_FIELD("httpOnly", m_httpOnly);
    CRDTP_SERIALIZE_FIELD("sameSite", m_sameSite);
    CRDTP_SERIALIZE_FIELD("expires", m_expires);
    CRDTP_SERIALIZE_FIELD("priority", m_priority);
    CRDTP_SERIALIZE_FIELD("sameParty", m_sameParty);
    CRDTP_SERIALIZE_FIELD("sourceScheme", m_sourceScheme);
    CRDTP_SERIALIZE_FIELD("sourcePort", m_sourcePort);
    CRDTP_SERIALIZE_FIELD("partitionKey", m_partitionKey);
CRDTP_END_SERIALIZER();



const char* AuthChallenge::SourceEnum::Server = "Server";
const char* AuthChallenge::SourceEnum::Proxy = "Proxy";
CRDTP_BEGIN_DESERIALIZER(AuthChallenge)
    CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    CRDTP_DESERIALIZE_FIELD("realm", m_realm),
    CRDTP_DESERIALIZE_FIELD("scheme", m_scheme),
    CRDTP_DESERIALIZE_FIELD_OPT("source", m_source),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(AuthChallenge)
    CRDTP_SERIALIZE_FIELD("source", m_source);
    CRDTP_SERIALIZE_FIELD("origin", m_origin);
    CRDTP_SERIALIZE_FIELD("scheme", m_scheme);
    CRDTP_SERIALIZE_FIELD("realm", m_realm);
CRDTP_END_SERIALIZER();



const char* AuthChallengeResponse::ResponseEnum::Default = "Default";
const char* AuthChallengeResponse::ResponseEnum::CancelAuth = "CancelAuth";
const char* AuthChallengeResponse::ResponseEnum::ProvideCredentials = "ProvideCredentials";
CRDTP_BEGIN_DESERIALIZER(AuthChallengeResponse)
    CRDTP_DESERIALIZE_FIELD_OPT("password", m_password),
    CRDTP_DESERIALIZE_FIELD("response", m_response),
    CRDTP_DESERIALIZE_FIELD_OPT("username", m_username),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(AuthChallengeResponse)
    CRDTP_SERIALIZE_FIELD("response", m_response);
    CRDTP_SERIALIZE_FIELD("username", m_username);
    CRDTP_SERIALIZE_FIELD("password", m_password);
CRDTP_END_SERIALIZER();


namespace InterceptionStageEnum {
const char Request[] = "Request";
const char HeadersReceived[] = "HeadersReceived";
} // namespace InterceptionStageEnum


CRDTP_BEGIN_DESERIALIZER(RequestPattern)
    CRDTP_DESERIALIZE_FIELD_OPT("interceptionStage", m_interceptionStage),
    CRDTP_DESERIALIZE_FIELD_OPT("resourceType", m_resourceType),
    CRDTP_DESERIALIZE_FIELD_OPT("urlPattern", m_urlPattern),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(RequestPattern)
    CRDTP_SERIALIZE_FIELD("urlPattern", m_urlPattern);
    CRDTP_SERIALIZE_FIELD("resourceType", m_resourceType);
    CRDTP_SERIALIZE_FIELD("interceptionStage", m_interceptionStage);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SignedExchangeSignature)
    CRDTP_DESERIALIZE_FIELD_OPT("certSha256", m_certSha256),
    CRDTP_DESERIALIZE_FIELD_OPT("certUrl", m_certUrl),
    CRDTP_DESERIALIZE_FIELD_OPT("certificates", m_certificates),
    CRDTP_DESERIALIZE_FIELD("date", m_date),
    CRDTP_DESERIALIZE_FIELD("expires", m_expires),
    CRDTP_DESERIALIZE_FIELD("integrity", m_integrity),
    CRDTP_DESERIALIZE_FIELD("label", m_label),
    CRDTP_DESERIALIZE_FIELD("signature", m_signature),
    CRDTP_DESERIALIZE_FIELD("validityUrl", m_validityUrl),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SignedExchangeSignature)
    CRDTP_SERIALIZE_FIELD("label", m_label);
    CRDTP_SERIALIZE_FIELD("signature", m_signature);
    CRDTP_SERIALIZE_FIELD("integrity", m_integrity);
    CRDTP_SERIALIZE_FIELD("certUrl", m_certUrl);
    CRDTP_SERIALIZE_FIELD("certSha256", m_certSha256);
    CRDTP_SERIALIZE_FIELD("validityUrl", m_validityUrl);
    CRDTP_SERIALIZE_FIELD("date", m_date);
    CRDTP_SERIALIZE_FIELD("expires", m_expires);
    CRDTP_SERIALIZE_FIELD("certificates", m_certificates);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SignedExchangeHeader)
    CRDTP_DESERIALIZE_FIELD("headerIntegrity", m_headerIntegrity),
    CRDTP_DESERIALIZE_FIELD("requestUrl", m_requestUrl),
    CRDTP_DESERIALIZE_FIELD("responseCode", m_responseCode),
    CRDTP_DESERIALIZE_FIELD("responseHeaders", m_responseHeaders),
    CRDTP_DESERIALIZE_FIELD("signatures", m_signatures),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SignedExchangeHeader)
    CRDTP_SERIALIZE_FIELD("requestUrl", m_requestUrl);
    CRDTP_SERIALIZE_FIELD("responseCode", m_responseCode);
    CRDTP_SERIALIZE_FIELD("responseHeaders", m_responseHeaders);
    CRDTP_SERIALIZE_FIELD("signatures", m_signatures);
    CRDTP_SERIALIZE_FIELD("headerIntegrity", m_headerIntegrity);
CRDTP_END_SERIALIZER();


namespace SignedExchangeErrorFieldEnum {
const char SignatureSig[] = "signatureSig";
const char SignatureIntegrity[] = "signatureIntegrity";
const char SignatureCertUrl[] = "signatureCertUrl";
const char SignatureCertSha256[] = "signatureCertSha256";
const char SignatureValidityUrl[] = "signatureValidityUrl";
const char SignatureTimestamps[] = "signatureTimestamps";
} // namespace SignedExchangeErrorFieldEnum


CRDTP_BEGIN_DESERIALIZER(SignedExchangeError)
    CRDTP_DESERIALIZE_FIELD_OPT("errorField", m_errorField),
    CRDTP_DESERIALIZE_FIELD("message", m_message),
    CRDTP_DESERIALIZE_FIELD_OPT("signatureIndex", m_signatureIndex),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SignedExchangeError)
    CRDTP_SERIALIZE_FIELD("message", m_message);
    CRDTP_SERIALIZE_FIELD("signatureIndex", m_signatureIndex);
    CRDTP_SERIALIZE_FIELD("errorField", m_errorField);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SignedExchangeInfo)
    CRDTP_DESERIALIZE_FIELD_OPT("errors", m_errors),
    CRDTP_DESERIALIZE_FIELD_OPT("header", m_header),
    CRDTP_DESERIALIZE_FIELD("outerResponse", m_outerResponse),
    CRDTP_DESERIALIZE_FIELD_OPT("securityDetails", m_securityDetails),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SignedExchangeInfo)
    CRDTP_SERIALIZE_FIELD("outerResponse", m_outerResponse);
    CRDTP_SERIALIZE_FIELD("header", m_header);
    CRDTP_SERIALIZE_FIELD("securityDetails", m_securityDetails);
    CRDTP_SERIALIZE_FIELD("errors", m_errors);
CRDTP_END_SERIALIZER();


namespace ContentEncodingEnum {
const char Deflate[] = "deflate";
const char Gzip[] = "gzip";
const char Br[] = "br";
} // namespace ContentEncodingEnum


namespace PrivateNetworkRequestPolicyEnum {
const char Allow[] = "Allow";
const char BlockFromInsecureToMorePrivate[] = "BlockFromInsecureToMorePrivate";
const char WarnFromInsecureToMorePrivate[] = "WarnFromInsecureToMorePrivate";
const char PreflightBlock[] = "PreflightBlock";
const char PreflightWarn[] = "PreflightWarn";
} // namespace PrivateNetworkRequestPolicyEnum


namespace IPAddressSpaceEnum {
const char Local[] = "Local";
const char Private[] = "Private";
const char Public[] = "Public";
const char Unknown[] = "Unknown";
} // namespace IPAddressSpaceEnum


CRDTP_BEGIN_DESERIALIZER(ConnectTiming)
    CRDTP_DESERIALIZE_FIELD("requestTime", m_requestTime),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ConnectTiming)
    CRDTP_SERIALIZE_FIELD("requestTime", m_requestTime);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(ClientSecurityState)
    CRDTP_DESERIALIZE_FIELD("initiatorIPAddressSpace", m_initiatorIPAddressSpace),
    CRDTP_DESERIALIZE_FIELD("initiatorIsSecureContext", m_initiatorIsSecureContext),
    CRDTP_DESERIALIZE_FIELD("privateNetworkRequestPolicy", m_privateNetworkRequestPolicy),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ClientSecurityState)
    CRDTP_SERIALIZE_FIELD("initiatorIsSecureContext", m_initiatorIsSecureContext);
    CRDTP_SERIALIZE_FIELD("initiatorIPAddressSpace", m_initiatorIPAddressSpace);
    CRDTP_SERIALIZE_FIELD("privateNetworkRequestPolicy", m_privateNetworkRequestPolicy);
CRDTP_END_SERIALIZER();


namespace CrossOriginOpenerPolicyValueEnum {
const char SameOrigin[] = "SameOrigin";
const char SameOriginAllowPopups[] = "SameOriginAllowPopups";
const char RestrictProperties[] = "RestrictProperties";
const char UnsafeNone[] = "UnsafeNone";
const char SameOriginPlusCoep[] = "SameOriginPlusCoep";
const char RestrictPropertiesPlusCoep[] = "RestrictPropertiesPlusCoep";
} // namespace CrossOriginOpenerPolicyValueEnum


CRDTP_BEGIN_DESERIALIZER(CrossOriginOpenerPolicyStatus)
    CRDTP_DESERIALIZE_FIELD_OPT("reportOnlyReportingEndpoint", m_reportOnlyReportingEndpoint),
    CRDTP_DESERIALIZE_FIELD("reportOnlyValue", m_reportOnlyValue),
    CRDTP_DESERIALIZE_FIELD_OPT("reportingEndpoint", m_reportingEndpoint),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CrossOriginOpenerPolicyStatus)
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("reportOnlyValue", m_reportOnlyValue);
    CRDTP_SERIALIZE_FIELD("reportingEndpoint", m_reportingEndpoint);
    CRDTP_SERIALIZE_FIELD("reportOnlyReportingEndpoint", m_reportOnlyReportingEndpoint);
CRDTP_END_SERIALIZER();


namespace CrossOriginEmbedderPolicyValueEnum {
const char None[] = "None";
const char Credentialless[] = "Credentialless";
const char RequireCorp[] = "RequireCorp";
} // namespace CrossOriginEmbedderPolicyValueEnum


CRDTP_BEGIN_DESERIALIZER(CrossOriginEmbedderPolicyStatus)
    CRDTP_DESERIALIZE_FIELD_OPT("reportOnlyReportingEndpoint", m_reportOnlyReportingEndpoint),
    CRDTP_DESERIALIZE_FIELD("reportOnlyValue", m_reportOnlyValue),
    CRDTP_DESERIALIZE_FIELD_OPT("reportingEndpoint", m_reportingEndpoint),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CrossOriginEmbedderPolicyStatus)
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("reportOnlyValue", m_reportOnlyValue);
    CRDTP_SERIALIZE_FIELD("reportingEndpoint", m_reportingEndpoint);
    CRDTP_SERIALIZE_FIELD("reportOnlyReportingEndpoint", m_reportOnlyReportingEndpoint);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SecurityIsolationStatus)
    CRDTP_DESERIALIZE_FIELD_OPT("coep", m_coep),
    CRDTP_DESERIALIZE_FIELD_OPT("coop", m_coop),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SecurityIsolationStatus)
    CRDTP_SERIALIZE_FIELD("coop", m_coop);
    CRDTP_SERIALIZE_FIELD("coep", m_coep);
CRDTP_END_SERIALIZER();


namespace ReportStatusEnum {
const char Queued[] = "Queued";
const char Pending[] = "Pending";
const char MarkedForRemoval[] = "MarkedForRemoval";
const char Success[] = "Success";
} // namespace ReportStatusEnum



CRDTP_BEGIN_DESERIALIZER(ReportingApiReport)
    CRDTP_DESERIALIZE_FIELD("body", m_body),
    CRDTP_DESERIALIZE_FIELD("completedAttempts", m_completedAttempts),
    CRDTP_DESERIALIZE_FIELD("depth", m_depth),
    CRDTP_DESERIALIZE_FIELD("destination", m_destination),
    CRDTP_DESERIALIZE_FIELD("id", m_id),
    CRDTP_DESERIALIZE_FIELD("initiatorUrl", m_initiatorUrl),
    CRDTP_DESERIALIZE_FIELD("status", m_status),
    CRDTP_DESERIALIZE_FIELD("timestamp", m_timestamp),
    CRDTP_DESERIALIZE_FIELD("type", m_type),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ReportingApiReport)
    CRDTP_SERIALIZE_FIELD("id", m_id);
    CRDTP_SERIALIZE_FIELD("initiatorUrl", m_initiatorUrl);
    CRDTP_SERIALIZE_FIELD("destination", m_destination);
    CRDTP_SERIALIZE_FIELD("type", m_type);
    CRDTP_SERIALIZE_FIELD("timestamp", m_timestamp);
    CRDTP_SERIALIZE_FIELD("depth", m_depth);
    CRDTP_SERIALIZE_FIELD("completedAttempts", m_completedAttempts);
    CRDTP_SERIALIZE_FIELD("body", m_body);
    CRDTP_SERIALIZE_FIELD("status", m_status);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(ReportingApiEndpoint)
    CRDTP_DESERIALIZE_FIELD("groupName", m_groupName),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ReportingApiEndpoint)
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("groupName", m_groupName);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(LoadNetworkResourcePageResult)
    CRDTP_DESERIALIZE_FIELD_OPT("headers", m_headers),
    CRDTP_DESERIALIZE_FIELD_OPT("httpStatusCode", m_httpStatusCode),
    CRDTP_DESERIALIZE_FIELD_OPT("netError", m_netError),
    CRDTP_DESERIALIZE_FIELD_OPT("netErrorName", m_netErrorName),
    CRDTP_DESERIALIZE_FIELD_OPT("stream", m_stream),
    CRDTP_DESERIALIZE_FIELD("success", m_success),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(LoadNetworkResourcePageResult)
    CRDTP_SERIALIZE_FIELD("success", m_success);
    CRDTP_SERIALIZE_FIELD("netError", m_netError);
    CRDTP_SERIALIZE_FIELD("netErrorName", m_netErrorName);
    CRDTP_SERIALIZE_FIELD("httpStatusCode", m_httpStatusCode);
    CRDTP_SERIALIZE_FIELD("stream", m_stream);
    CRDTP_SERIALIZE_FIELD("headers", m_headers);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(LoadNetworkResourceOptions)
    CRDTP_DESERIALIZE_FIELD("disableCache", m_disableCache),
    CRDTP_DESERIALIZE_FIELD("includeCredentials", m_includeCredentials),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(LoadNetworkResourceOptions)
    CRDTP_SERIALIZE_FIELD("disableCache", m_disableCache);
    CRDTP_SERIALIZE_FIELD("includeCredentials", m_includeCredentials);
CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


namespace TrustTokenOperationDone {
namespace StatusEnum {
const char* Ok = "Ok";
const char* InvalidArgument = "InvalidArgument";
const char* FailedPrecondition = "FailedPrecondition";
const char* ResourceExhausted = "ResourceExhausted";
const char* AlreadyExists = "AlreadyExists";
const char* Unavailable = "Unavailable";
const char* BadResponse = "BadResponse";
const char* InternalError = "InternalError";
const char* UnknownError = "UnknownError";
const char* FulfilledLocally = "FulfilledLocally";
} // namespace StatusEnum
} // namespace TrustTokenOperationDone

// ------------- Frontend notifications.

void Frontend::LoadingFailed(const String& requestId, double timestamp, const String& type, const String& errorText, Maybe<bool> canceled, Maybe<String> blockedReason, Maybe<protocol::Network::CorsErrorStatus> corsErrorStatus)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(crdtp::MakeSpan("type"), type);
    serializer.AddField(crdtp::MakeSpan("errorText"), errorText);
    serializer.AddField(crdtp::MakeSpan("canceled"), canceled);
    serializer.AddField(crdtp::MakeSpan("blockedReason"), blockedReason);
    serializer.AddField(crdtp::MakeSpan("corsErrorStatus"), corsErrorStatus);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.loadingFailed", serializer.Finish()));
}

void Frontend::LoadingFinished(const String& requestId, double timestamp, double encodedDataLength, Maybe<bool> shouldReportCorbBlocking)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(crdtp::MakeSpan("encodedDataLength"), encodedDataLength);
    serializer.AddField(crdtp::MakeSpan("shouldReportCorbBlocking"), shouldReportCorbBlocking);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.loadingFinished", serializer.Finish()));
}

void Frontend::RequestIntercepted(const String& interceptionId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, bool isNavigationRequest, Maybe<bool> isDownload, Maybe<String> redirectUrl, Maybe<protocol::Network::AuthChallenge> authChallenge, Maybe<String> responseErrorReason, Maybe<int> responseStatusCode, Maybe<protocol::Network::Headers> responseHeaders, Maybe<String> requestId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("interceptionId"), interceptionId);
    serializer.AddField(crdtp::MakeSpan("request"), request);
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("resourceType"), resourceType);
    serializer.AddField(crdtp::MakeSpan("isNavigationRequest"), isNavigationRequest);
    serializer.AddField(crdtp::MakeSpan("isDownload"), isDownload);
    serializer.AddField(crdtp::MakeSpan("redirectUrl"), redirectUrl);
    serializer.AddField(crdtp::MakeSpan("authChallenge"), authChallenge);
    serializer.AddField(crdtp::MakeSpan("responseErrorReason"), responseErrorReason);
    serializer.AddField(crdtp::MakeSpan("responseStatusCode"), responseStatusCode);
    serializer.AddField(crdtp::MakeSpan("responseHeaders"), responseHeaders);
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.requestIntercepted", serializer.Finish()));
}

void Frontend::RequestWillBeSent(const String& requestId, const String& loaderId, const String& documentURL, std::unique_ptr<protocol::Network::Request> request, double timestamp, double wallTime, std::unique_ptr<protocol::Network::Initiator> initiator, bool redirectHasExtraInfo, Maybe<protocol::Network::Response> redirectResponse, Maybe<String> type, Maybe<String> frameId, Maybe<bool> hasUserGesture)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(crdtp::MakeSpan("documentURL"), documentURL);
    serializer.AddField(crdtp::MakeSpan("request"), request);
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(crdtp::MakeSpan("wallTime"), wallTime);
    serializer.AddField(crdtp::MakeSpan("initiator"), initiator);
    serializer.AddField(crdtp::MakeSpan("redirectHasExtraInfo"), redirectHasExtraInfo);
    serializer.AddField(crdtp::MakeSpan("redirectResponse"), redirectResponse);
    serializer.AddField(crdtp::MakeSpan("type"), type);
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("hasUserGesture"), hasUserGesture);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.requestWillBeSent", serializer.Finish()));
}

void Frontend::SignedExchangeReceived(const String& requestId, std::unique_ptr<protocol::Network::SignedExchangeInfo> info)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("info"), info);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.signedExchangeReceived", serializer.Finish()));
}

void Frontend::ResponseReceived(const String& requestId, const String& loaderId, double timestamp, const String& type, std::unique_ptr<protocol::Network::Response> response, bool hasExtraInfo, Maybe<String> frameId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    serializer.AddField(crdtp::MakeSpan("type"), type);
    serializer.AddField(crdtp::MakeSpan("response"), response);
    serializer.AddField(crdtp::MakeSpan("hasExtraInfo"), hasExtraInfo);
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.responseReceived", serializer.Finish()));
}

void Frontend::RequestWillBeSentExtraInfo(const String& requestId, std::unique_ptr<protocol::Array<protocol::Network::BlockedCookieWithReason>> associatedCookies, std::unique_ptr<protocol::Network::Headers> headers, std::unique_ptr<protocol::Network::ConnectTiming> connectTiming, Maybe<protocol::Network::ClientSecurityState> clientSecurityState)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("associatedCookies"), associatedCookies);
    serializer.AddField(crdtp::MakeSpan("headers"), headers);
    serializer.AddField(crdtp::MakeSpan("connectTiming"), connectTiming);
    serializer.AddField(crdtp::MakeSpan("clientSecurityState"), clientSecurityState);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.requestWillBeSentExtraInfo", serializer.Finish()));
}

void Frontend::ResponseReceivedExtraInfo(const String& requestId, std::unique_ptr<protocol::Array<protocol::Network::BlockedSetCookieWithReason>> blockedCookies, std::unique_ptr<protocol::Network::Headers> headers, const String& resourceIPAddressSpace, int statusCode, Maybe<String> headersText)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("blockedCookies"), blockedCookies);
    serializer.AddField(crdtp::MakeSpan("headers"), headers);
    serializer.AddField(crdtp::MakeSpan("resourceIPAddressSpace"), resourceIPAddressSpace);
    serializer.AddField(crdtp::MakeSpan("statusCode"), statusCode);
    serializer.AddField(crdtp::MakeSpan("headersText"), headersText);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.responseReceivedExtraInfo", serializer.Finish()));
}

void Frontend::TrustTokenOperationDone(const String& status, const String& type, const String& requestId, Maybe<String> topLevelOrigin, Maybe<String> issuerOrigin, Maybe<int> issuedTokenCount)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("status"), status);
    serializer.AddField(crdtp::MakeSpan("type"), type);
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("topLevelOrigin"), topLevelOrigin);
    serializer.AddField(crdtp::MakeSpan("issuerOrigin"), issuerOrigin);
    serializer.AddField(crdtp::MakeSpan("issuedTokenCount"), issuedTokenCount);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.trustTokenOperationDone", serializer.Finish()));
}

void Frontend::SubresourceWebBundleMetadataReceived(const String& requestId, std::unique_ptr<protocol::Array<String>> urls)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("urls"), urls);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.subresourceWebBundleMetadataReceived", serializer.Finish()));
}

void Frontend::SubresourceWebBundleMetadataError(const String& requestId, const String& errorMessage)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("requestId"), requestId);
    serializer.AddField(crdtp::MakeSpan("errorMessage"), errorMessage);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.subresourceWebBundleMetadataError", serializer.Finish()));
}

void Frontend::SubresourceWebBundleInnerResponseParsed(const String& innerRequestId, const String& innerRequestURL, Maybe<String> bundleRequestId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("innerRequestId"), innerRequestId);
    serializer.AddField(crdtp::MakeSpan("innerRequestURL"), innerRequestURL);
    serializer.AddField(crdtp::MakeSpan("bundleRequestId"), bundleRequestId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.subresourceWebBundleInnerResponseParsed", serializer.Finish()));
}

void Frontend::SubresourceWebBundleInnerResponseError(const String& innerRequestId, const String& innerRequestURL, const String& errorMessage, Maybe<String> bundleRequestId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("innerRequestId"), innerRequestId);
    serializer.AddField(crdtp::MakeSpan("innerRequestURL"), innerRequestURL);
    serializer.AddField(crdtp::MakeSpan("errorMessage"), errorMessage);
    serializer.AddField(crdtp::MakeSpan("bundleRequestId"), bundleRequestId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.subresourceWebBundleInnerResponseError", serializer.Finish()));
}

void Frontend::ReportingApiReportAdded(std::unique_ptr<protocol::Network::ReportingApiReport> report)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("report"), report);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.reportingApiReportAdded", serializer.Finish()));
}

void Frontend::ReportingApiReportUpdated(std::unique_ptr<protocol::Network::ReportingApiReport> report)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("report"), report);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.reportingApiReportUpdated", serializer.Finish()));
}

void Frontend::ReportingApiEndpointsChangedForOrigin(const String& origin, std::unique_ptr<protocol::Array<protocol::Network::ReportingApiEndpoint>> endpoints)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("origin"), origin);
    serializer.AddField(crdtp::MakeSpan("endpoints"), endpoints);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Network.reportingApiEndpointsChangedForOrigin", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void setAcceptedEncodings(const crdtp::Dispatchable& dispatchable);
    void clearAcceptedEncodingsOverride(const crdtp::Dispatchable& dispatchable);
    void canEmulateNetworkConditions(const crdtp::Dispatchable& dispatchable);
    void clearBrowserCache(const crdtp::Dispatchable& dispatchable);
    void clearBrowserCookies(const crdtp::Dispatchable& dispatchable);
    void continueInterceptedRequest(const crdtp::Dispatchable& dispatchable);
    void deleteCookies(const crdtp::Dispatchable& dispatchable);
    void disable(const crdtp::Dispatchable& dispatchable);
    void emulateNetworkConditions(const crdtp::Dispatchable& dispatchable);
    void enable(const crdtp::Dispatchable& dispatchable);
    void getAllCookies(const crdtp::Dispatchable& dispatchable);
    void getCookies(const crdtp::Dispatchable& dispatchable);
    void getResponseBody(const crdtp::Dispatchable& dispatchable);
    void getResponseBodyForInterception(const crdtp::Dispatchable& dispatchable);
    void takeResponseBodyForInterceptionAsStream(const crdtp::Dispatchable& dispatchable);
    void setBypassServiceWorker(const crdtp::Dispatchable& dispatchable);
    void setCacheDisabled(const crdtp::Dispatchable& dispatchable);
    void setCookie(const crdtp::Dispatchable& dispatchable);
    void setCookies(const crdtp::Dispatchable& dispatchable);
    void setExtraHTTPHeaders(const crdtp::Dispatchable& dispatchable);
    void setRequestInterception(const crdtp::Dispatchable& dispatchable);
    void getSecurityIsolationStatus(const crdtp::Dispatchable& dispatchable);
    void enableReportingApi(const crdtp::Dispatchable& dispatchable);
    void loadNetworkResource(const crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("canEmulateNetworkConditions"),
          &DomainDispatcherImpl::canEmulateNetworkConditions
    },
    {
          crdtp::SpanFrom("clearAcceptedEncodingsOverride"),
          &DomainDispatcherImpl::clearAcceptedEncodingsOverride
    },
    {
          crdtp::SpanFrom("clearBrowserCache"),
          &DomainDispatcherImpl::clearBrowserCache
    },
    {
          crdtp::SpanFrom("clearBrowserCookies"),
          &DomainDispatcherImpl::clearBrowserCookies
    },
    {
          crdtp::SpanFrom("continueInterceptedRequest"),
          &DomainDispatcherImpl::continueInterceptedRequest
    },
    {
          crdtp::SpanFrom("deleteCookies"),
          &DomainDispatcherImpl::deleteCookies
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("emulateNetworkConditions"),
          &DomainDispatcherImpl::emulateNetworkConditions
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("enableReportingApi"),
          &DomainDispatcherImpl::enableReportingApi
    },
    {
          crdtp::SpanFrom("getAllCookies"),
          &DomainDispatcherImpl::getAllCookies
    },
    {
          crdtp::SpanFrom("getCookies"),
          &DomainDispatcherImpl::getCookies
    },
    {
          crdtp::SpanFrom("getResponseBody"),
          &DomainDispatcherImpl::getResponseBody
    },
    {
          crdtp::SpanFrom("getResponseBodyForInterception"),
          &DomainDispatcherImpl::getResponseBodyForInterception
    },
    {
          crdtp::SpanFrom("getSecurityIsolationStatus"),
          &DomainDispatcherImpl::getSecurityIsolationStatus
    },
    {
          crdtp::SpanFrom("loadNetworkResource"),
          &DomainDispatcherImpl::loadNetworkResource
    },
    {
          crdtp::SpanFrom("setAcceptedEncodings"),
          &DomainDispatcherImpl::setAcceptedEncodings
    },
    {
          crdtp::SpanFrom("setBypassServiceWorker"),
          &DomainDispatcherImpl::setBypassServiceWorker
    },
    {
          crdtp::SpanFrom("setCacheDisabled"),
          &DomainDispatcherImpl::setCacheDisabled
    },
    {
          crdtp::SpanFrom("setCookie"),
          &DomainDispatcherImpl::setCookie
    },
    {
          crdtp::SpanFrom("setCookies"),
          &DomainDispatcherImpl::setCookies
    },
    {
          crdtp::SpanFrom("setExtraHTTPHeaders"),
          &DomainDispatcherImpl::setExtraHTTPHeaders
    },
    {
          crdtp::SpanFrom("setRequestInterception"),
          &DomainDispatcherImpl::setRequestInterception
    },
    {
          crdtp::SpanFrom("takeResponseBodyForInterceptionAsStream"),
          &DomainDispatcherImpl::takeResponseBodyForInterceptionAsStream
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct setAcceptedEncodingsParams : public crdtp::DeserializableProtocolObject<setAcceptedEncodingsParams> {
    std::unique_ptr<protocol::Array<String>> encodings;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setAcceptedEncodingsParams)
    CRDTP_DESERIALIZE_FIELD("encodings", encodings),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAcceptedEncodings(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAcceptedEncodingsParams params;
    if (!setAcceptedEncodingsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetAcceptedEncodings(std::move(params.encodings));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setAcceptedEncodings"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::clearAcceptedEncodingsOverride(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->ClearAcceptedEncodingsOverride();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.clearAcceptedEncodingsOverride"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::canEmulateNetworkConditions(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    bool out_result;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->CanEmulateNetworkConditions(&out_result);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.canEmulateNetworkConditions"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("result"), out_result);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

class ClearBrowserCacheCallbackImpl : public Backend::ClearBrowserCacheCallback, public DomainDispatcher::Callback {
public:
    ClearBrowserCacheCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.clearBrowserCache"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::clearBrowserCache(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    m_backend->ClearBrowserCache(std::make_unique<ClearBrowserCacheCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ClearBrowserCookiesCallbackImpl : public Backend::ClearBrowserCookiesCallback, public DomainDispatcher::Callback {
public:
    ClearBrowserCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.clearBrowserCookies"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::clearBrowserCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    m_backend->ClearBrowserCookies(std::make_unique<ClearBrowserCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class ContinueInterceptedRequestCallbackImpl : public Backend::ContinueInterceptedRequestCallback, public DomainDispatcher::Callback {
public:
    ContinueInterceptedRequestCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.continueInterceptedRequest"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct continueInterceptedRequestParams : public crdtp::DeserializableProtocolObject<continueInterceptedRequestParams> {
    String interceptionId;
    Maybe<String> errorReason;
    Maybe<Binary> rawResponse;
    Maybe<String> url;
    Maybe<String> method;
    Maybe<String> postData;
    Maybe<protocol::Network::Headers> headers;
    Maybe<protocol::Network::AuthChallengeResponse> authChallengeResponse;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(continueInterceptedRequestParams)
    CRDTP_DESERIALIZE_FIELD_OPT("authChallengeResponse", authChallengeResponse),
    CRDTP_DESERIALIZE_FIELD_OPT("errorReason", errorReason),
    CRDTP_DESERIALIZE_FIELD_OPT("headers", headers),
    CRDTP_DESERIALIZE_FIELD("interceptionId", interceptionId),
    CRDTP_DESERIALIZE_FIELD_OPT("method", method),
    CRDTP_DESERIALIZE_FIELD_OPT("postData", postData),
    CRDTP_DESERIALIZE_FIELD_OPT("rawResponse", rawResponse),
    CRDTP_DESERIALIZE_FIELD_OPT("url", url),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::continueInterceptedRequest(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    continueInterceptedRequestParams params;
    if (!continueInterceptedRequestParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->ContinueInterceptedRequest(params.interceptionId, std::move(params.errorReason), std::move(params.rawResponse), std::move(params.url), std::move(params.method), std::move(params.postData), std::move(params.headers), std::move(params.authChallengeResponse), std::make_unique<ContinueInterceptedRequestCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class DeleteCookiesCallbackImpl : public Backend::DeleteCookiesCallback, public DomainDispatcher::Callback {
public:
    DeleteCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.deleteCookies"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct deleteCookiesParams : public crdtp::DeserializableProtocolObject<deleteCookiesParams> {
    String name;
    Maybe<String> url;
    Maybe<String> domain;
    Maybe<String> path;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(deleteCookiesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("domain", domain),
    CRDTP_DESERIALIZE_FIELD("name", name),
    CRDTP_DESERIALIZE_FIELD_OPT("path", path),
    CRDTP_DESERIALIZE_FIELD_OPT("url", url),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::deleteCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    deleteCookiesParams params;
    if (!deleteCookiesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->DeleteCookies(params.name, std::move(params.url), std::move(params.domain), std::move(params.path), std::make_unique<DeleteCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct emulateNetworkConditionsParams : public crdtp::DeserializableProtocolObject<emulateNetworkConditionsParams> {
    bool offline;
    double latency;
    double downloadThroughput;
    double uploadThroughput;
    Maybe<String> connectionType;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(emulateNetworkConditionsParams)
    CRDTP_DESERIALIZE_FIELD_OPT("connectionType", connectionType),
    CRDTP_DESERIALIZE_FIELD("downloadThroughput", downloadThroughput),
    CRDTP_DESERIALIZE_FIELD("latency", latency),
    CRDTP_DESERIALIZE_FIELD("offline", offline),
    CRDTP_DESERIALIZE_FIELD("uploadThroughput", uploadThroughput),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::emulateNetworkConditions(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    emulateNetworkConditionsParams params;
    if (!emulateNetworkConditionsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->EmulateNetworkConditions(params.offline, params.latency, params.downloadThroughput, params.uploadThroughput, std::move(params.connectionType));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.emulateNetworkConditions"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct enableParams : public crdtp::DeserializableProtocolObject<enableParams> {
    Maybe<int> maxTotalBufferSize;
    Maybe<int> maxResourceBufferSize;
    Maybe<int> maxPostDataSize;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(enableParams)
    CRDTP_DESERIALIZE_FIELD_OPT("maxPostDataSize", maxPostDataSize),
    CRDTP_DESERIALIZE_FIELD_OPT("maxResourceBufferSize", maxResourceBufferSize),
    CRDTP_DESERIALIZE_FIELD_OPT("maxTotalBufferSize", maxTotalBufferSize),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    enableParams params;
    if (!enableParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->Enable(std::move(params.maxTotalBufferSize), std::move(params.maxResourceBufferSize), std::move(params.maxPostDataSize));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class GetAllCookiesCallbackImpl : public Backend::GetAllCookiesCallback, public DomainDispatcher::Callback {
public:
    GetAllCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getAllCookies"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Network::Cookie>> cookies) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("cookies"), cookies);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::getAllCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    m_backend->GetAllCookies(std::make_unique<GetAllCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetCookiesCallbackImpl : public Backend::GetCookiesCallback, public DomainDispatcher::Callback {
public:
    GetCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getCookies"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<protocol::Network::Cookie>> cookies) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("cookies"), cookies);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getCookiesParams : public crdtp::DeserializableProtocolObject<getCookiesParams> {
    Maybe<protocol::Array<String>> urls;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getCookiesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("urls", urls),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getCookiesParams params;
    if (!getCookiesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->GetCookies(std::move(params.urls), std::make_unique<GetCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetResponseBodyCallbackImpl : public Backend::GetResponseBodyCallback, public DomainDispatcher::Callback {
public:
    GetResponseBodyCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getResponseBody"), message) { }

    void sendSuccess(const String& body, bool base64Encoded) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("body"), body);
        serializer.AddField(crdtp::MakeSpan("base64Encoded"), base64Encoded);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getResponseBodyParams : public crdtp::DeserializableProtocolObject<getResponseBodyParams> {
    String requestId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getResponseBodyParams)
    CRDTP_DESERIALIZE_FIELD("requestId", requestId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getResponseBody(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getResponseBodyParams params;
    if (!getResponseBodyParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->GetResponseBody(params.requestId, std::make_unique<GetResponseBodyCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class GetResponseBodyForInterceptionCallbackImpl : public Backend::GetResponseBodyForInterceptionCallback, public DomainDispatcher::Callback {
public:
    GetResponseBodyForInterceptionCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.getResponseBodyForInterception"), message) { }

    void sendSuccess(const String& body, bool base64Encoded) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("body"), body);
        serializer.AddField(crdtp::MakeSpan("base64Encoded"), base64Encoded);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getResponseBodyForInterceptionParams : public crdtp::DeserializableProtocolObject<getResponseBodyForInterceptionParams> {
    String interceptionId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getResponseBodyForInterceptionParams)
    CRDTP_DESERIALIZE_FIELD("interceptionId", interceptionId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getResponseBodyForInterception(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getResponseBodyForInterceptionParams params;
    if (!getResponseBodyForInterceptionParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->GetResponseBodyForInterception(params.interceptionId, std::make_unique<GetResponseBodyForInterceptionCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class TakeResponseBodyForInterceptionAsStreamCallbackImpl : public Backend::TakeResponseBodyForInterceptionAsStreamCallback, public DomainDispatcher::Callback {
public:
    TakeResponseBodyForInterceptionAsStreamCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.takeResponseBodyForInterceptionAsStream"), message) { }

    void sendSuccess(const String& stream) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("stream"), stream);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct takeResponseBodyForInterceptionAsStreamParams : public crdtp::DeserializableProtocolObject<takeResponseBodyForInterceptionAsStreamParams> {
    String interceptionId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(takeResponseBodyForInterceptionAsStreamParams)
    CRDTP_DESERIALIZE_FIELD("interceptionId", interceptionId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::takeResponseBodyForInterceptionAsStream(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    takeResponseBodyForInterceptionAsStreamParams params;
    if (!takeResponseBodyForInterceptionAsStreamParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->TakeResponseBodyForInterceptionAsStream(params.interceptionId, std::make_unique<TakeResponseBodyForInterceptionAsStreamCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct setBypassServiceWorkerParams : public crdtp::DeserializableProtocolObject<setBypassServiceWorkerParams> {
    bool bypass;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setBypassServiceWorkerParams)
    CRDTP_DESERIALIZE_FIELD("bypass", bypass),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setBypassServiceWorker(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setBypassServiceWorkerParams params;
    if (!setBypassServiceWorkerParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetBypassServiceWorker(params.bypass);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setBypassServiceWorker"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setCacheDisabledParams : public crdtp::DeserializableProtocolObject<setCacheDisabledParams> {
    bool cacheDisabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setCacheDisabledParams)
    CRDTP_DESERIALIZE_FIELD("cacheDisabled", cacheDisabled),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setCacheDisabled(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setCacheDisabledParams params;
    if (!setCacheDisabledParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetCacheDisabled(params.cacheDisabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setCacheDisabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SetCookieCallbackImpl : public Backend::SetCookieCallback, public DomainDispatcher::Callback {
public:
    SetCookieCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.setCookie"), message) { }

    void sendSuccess(bool success) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("success"), success);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct setCookieParams : public crdtp::DeserializableProtocolObject<setCookieParams> {
    String name;
    String value;
    Maybe<String> url;
    Maybe<String> domain;
    Maybe<String> path;
    Maybe<bool> secure;
    Maybe<bool> httpOnly;
    Maybe<String> sameSite;
    Maybe<double> expires;
    Maybe<String> priority;
    Maybe<bool> sameParty;
    Maybe<String> sourceScheme;
    Maybe<int> sourcePort;
    Maybe<String> partitionKey;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setCookieParams)
    CRDTP_DESERIALIZE_FIELD_OPT("domain", domain),
    CRDTP_DESERIALIZE_FIELD_OPT("expires", expires),
    CRDTP_DESERIALIZE_FIELD_OPT("httpOnly", httpOnly),
    CRDTP_DESERIALIZE_FIELD("name", name),
    CRDTP_DESERIALIZE_FIELD_OPT("partitionKey", partitionKey),
    CRDTP_DESERIALIZE_FIELD_OPT("path", path),
    CRDTP_DESERIALIZE_FIELD_OPT("priority", priority),
    CRDTP_DESERIALIZE_FIELD_OPT("sameParty", sameParty),
    CRDTP_DESERIALIZE_FIELD_OPT("sameSite", sameSite),
    CRDTP_DESERIALIZE_FIELD_OPT("secure", secure),
    CRDTP_DESERIALIZE_FIELD_OPT("sourcePort", sourcePort),
    CRDTP_DESERIALIZE_FIELD_OPT("sourceScheme", sourceScheme),
    CRDTP_DESERIALIZE_FIELD_OPT("url", url),
    CRDTP_DESERIALIZE_FIELD("value", value),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setCookie(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setCookieParams params;
    if (!setCookieParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->SetCookie(params.name, params.value, std::move(params.url), std::move(params.domain), std::move(params.path), std::move(params.secure), std::move(params.httpOnly), std::move(params.sameSite), std::move(params.expires), std::move(params.priority), std::move(params.sameParty), std::move(params.sourceScheme), std::move(params.sourcePort), std::move(params.partitionKey), std::make_unique<SetCookieCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

class SetCookiesCallbackImpl : public Backend::SetCookiesCallback, public DomainDispatcher::Callback {
public:
    SetCookiesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.setCookies"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct setCookiesParams : public crdtp::DeserializableProtocolObject<setCookiesParams> {
    std::unique_ptr<protocol::Array<protocol::Network::CookieParam>> cookies;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setCookiesParams)
    CRDTP_DESERIALIZE_FIELD("cookies", cookies),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setCookies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setCookiesParams params;
    if (!setCookiesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->SetCookies(std::move(params.cookies), std::make_unique<SetCookiesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct setExtraHTTPHeadersParams : public crdtp::DeserializableProtocolObject<setExtraHTTPHeadersParams> {
    std::unique_ptr<protocol::Network::Headers> headers;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setExtraHTTPHeadersParams)
    CRDTP_DESERIALIZE_FIELD("headers", headers),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setExtraHTTPHeaders(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setExtraHTTPHeadersParams params;
    if (!setExtraHTTPHeadersParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetExtraHTTPHeaders(std::move(params.headers));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setExtraHTTPHeaders"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setRequestInterceptionParams : public crdtp::DeserializableProtocolObject<setRequestInterceptionParams> {
    std::unique_ptr<protocol::Array<protocol::Network::RequestPattern>> patterns;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setRequestInterceptionParams)
    CRDTP_DESERIALIZE_FIELD("patterns", patterns),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setRequestInterception(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setRequestInterceptionParams params;
    if (!setRequestInterceptionParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->SetRequestInterception(std::move(params.patterns));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.setRequestInterception"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getSecurityIsolationStatusParams : public crdtp::DeserializableProtocolObject<getSecurityIsolationStatusParams> {
    Maybe<String> frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getSecurityIsolationStatusParams)
    CRDTP_DESERIALIZE_FIELD_OPT("frameId", frameId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getSecurityIsolationStatus(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getSecurityIsolationStatusParams params;
    if (!getSecurityIsolationStatusParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Network::SecurityIsolationStatus> out_status;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->GetSecurityIsolationStatus(std::move(params.frameId), &out_status);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.getSecurityIsolationStatus"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("status"), out_status);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct enableReportingApiParams : public crdtp::DeserializableProtocolObject<enableReportingApiParams> {
    bool enable;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(enableReportingApiParams)
    CRDTP_DESERIALIZE_FIELD("enable", enable),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::enableReportingApi(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    enableReportingApiParams params;
    if (!enableReportingApiParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->EnableReportingApi(params.enable);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Network.enableReportingApi"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class LoadNetworkResourceCallbackImpl : public Backend::LoadNetworkResourceCallback, public DomainDispatcher::Callback {
public:
    LoadNetworkResourceCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Network.loadNetworkResource"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Network::LoadNetworkResourcePageResult> resource) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("resource"), resource);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct loadNetworkResourceParams : public crdtp::DeserializableProtocolObject<loadNetworkResourceParams> {
    Maybe<String> frameId;
    String url;
    std::unique_ptr<protocol::Network::LoadNetworkResourceOptions> options;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(loadNetworkResourceParams)
    CRDTP_DESERIALIZE_FIELD_OPT("frameId", frameId),
    CRDTP_DESERIALIZE_FIELD("options", options),
    CRDTP_DESERIALIZE_FIELD("url", url),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::loadNetworkResource(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    loadNetworkResourceParams params;
    if (!loadNetworkResourceParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->LoadNetworkResource(std::move(params.frameId), params.url, std::move(params.options), std::make_unique<LoadNetworkResourceCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("Network.setUserAgentOverride"), crdtp::SpanFrom("Emulation.setUserAgentOverride") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Network"), SortedRedirects(), std::move(dispatcher));
}

} // Network
} // namespace content
} // namespace protocol
