// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef content_protocol_Storage_h
#define content_protocol_Storage_h

#include "content/common/content_export.h"
#include "content/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "content/browser/devtools/protocol/browser.h"
#include "content/browser/devtools/protocol/network.h"

namespace content {
namespace protocol {
namespace Storage {
using SerializedStorageKey = String;
using StorageType = String;
class UsageForType;
class TrustTokens;
using InterestGroupAccessType = String;
class InterestGroupAd;
class InterestGroupDetails;

// ------------- Forward and enum declarations.

namespace StorageTypeEnum {
CONTENT_EXPORT extern const char Appcache[];
CONTENT_EXPORT extern const char Cookies[];
CONTENT_EXPORT extern const char File_systems[];
CONTENT_EXPORT extern const char Indexeddb[];
CONTENT_EXPORT extern const char Local_storage[];
CONTENT_EXPORT extern const char Shader_cache[];
CONTENT_EXPORT extern const char Websql[];
CONTENT_EXPORT extern const char Service_workers[];
CONTENT_EXPORT extern const char Cache_storage[];
CONTENT_EXPORT extern const char Interest_groups[];
CONTENT_EXPORT extern const char All[];
CONTENT_EXPORT extern const char Other[];
} // namespace StorageTypeEnum

namespace InterestGroupAccessTypeEnum {
CONTENT_EXPORT extern const char Join[];
CONTENT_EXPORT extern const char Leave[];
CONTENT_EXPORT extern const char Update[];
CONTENT_EXPORT extern const char Bid[];
CONTENT_EXPORT extern const char Win[];
} // namespace InterestGroupAccessTypeEnum

// ------------- Type and builder declarations.

class CONTENT_EXPORT UsageForType : public ::crdtp::ProtocolObject<UsageForType> {
public:
    ~UsageForType() override { }

    String GetStorageType() { return m_storageType; }
    void SetStorageType(const String& value) { m_storageType = value; }

    double GetUsage() { return m_usage; }
    void SetUsage(double value) { m_usage = value; }

    template<int STATE>
    class UsageForTypeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StorageTypeSet = 1 << 1,
            UsageSet = 1 << 2,
            AllFieldsSet = (StorageTypeSet | UsageSet | 0)};


        UsageForTypeBuilder<STATE | StorageTypeSet>& SetStorageType(const String& value)
        {
            static_assert(!(STATE & StorageTypeSet), "property storageType should not be set yet");
            m_result->SetStorageType(value);
            return castState<StorageTypeSet>();
        }

        UsageForTypeBuilder<STATE | UsageSet>& SetUsage(double value)
        {
            static_assert(!(STATE & UsageSet), "property usage should not be set yet");
            m_result->SetUsage(value);
            return castState<UsageSet>();
        }

        std::unique_ptr<UsageForType> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class UsageForType;
        UsageForTypeBuilder() : m_result(new UsageForType()) { }

        template<int STEP> UsageForTypeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<UsageForTypeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::UsageForType> m_result;
    };

    static UsageForTypeBuilder<0> Create()
    {
        return UsageForTypeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    UsageForType()
    {
          m_usage = 0;
    }

    String m_storageType;
    double m_usage;
};


class CONTENT_EXPORT TrustTokens : public ::crdtp::ProtocolObject<TrustTokens> {
public:
    ~TrustTokens() override { }

    String GetIssuerOrigin() { return m_issuerOrigin; }
    void SetIssuerOrigin(const String& value) { m_issuerOrigin = value; }

    double GetCount() { return m_count; }
    void SetCount(double value) { m_count = value; }

    template<int STATE>
    class TrustTokensBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IssuerOriginSet = 1 << 1,
            CountSet = 1 << 2,
            AllFieldsSet = (IssuerOriginSet | CountSet | 0)};


        TrustTokensBuilder<STATE | IssuerOriginSet>& SetIssuerOrigin(const String& value)
        {
            static_assert(!(STATE & IssuerOriginSet), "property issuerOrigin should not be set yet");
            m_result->SetIssuerOrigin(value);
            return castState<IssuerOriginSet>();
        }

        TrustTokensBuilder<STATE | CountSet>& SetCount(double value)
        {
            static_assert(!(STATE & CountSet), "property count should not be set yet");
            m_result->SetCount(value);
            return castState<CountSet>();
        }

        std::unique_ptr<TrustTokens> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TrustTokens;
        TrustTokensBuilder() : m_result(new TrustTokens()) { }

        template<int STEP> TrustTokensBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TrustTokensBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::TrustTokens> m_result;
    };

    static TrustTokensBuilder<0> Create()
    {
        return TrustTokensBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    TrustTokens()
    {
          m_count = 0;
    }

    String m_issuerOrigin;
    double m_count;
};


class CONTENT_EXPORT InterestGroupAd : public ::crdtp::ProtocolObject<InterestGroupAd> {
public:
    ~InterestGroupAd() override { }

    String GetRenderUrl() { return m_renderUrl; }
    void SetRenderUrl(const String& value) { m_renderUrl = value; }

    bool HasMetadata() { return m_metadata.isJust(); }
    String GetMetadata(const String& defaultValue) { return m_metadata.isJust() ? m_metadata.fromJust() : defaultValue; }
    void SetMetadata(const String& value) { m_metadata = value; }

    template<int STATE>
    class InterestGroupAdBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RenderUrlSet = 1 << 1,
            AllFieldsSet = (RenderUrlSet | 0)};


        InterestGroupAdBuilder<STATE | RenderUrlSet>& SetRenderUrl(const String& value)
        {
            static_assert(!(STATE & RenderUrlSet), "property renderUrl should not be set yet");
            m_result->SetRenderUrl(value);
            return castState<RenderUrlSet>();
        }

        InterestGroupAdBuilder<STATE>& SetMetadata(const String& value)
        {
            m_result->SetMetadata(value);
            return *this;
        }

        std::unique_ptr<InterestGroupAd> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InterestGroupAd;
        InterestGroupAdBuilder() : m_result(new InterestGroupAd()) { }

        template<int STEP> InterestGroupAdBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InterestGroupAdBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::InterestGroupAd> m_result;
    };

    static InterestGroupAdBuilder<0> Create()
    {
        return InterestGroupAdBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InterestGroupAd()
    {
    }

    String m_renderUrl;
    Maybe<String> m_metadata;
};


class CONTENT_EXPORT InterestGroupDetails : public ::crdtp::ProtocolObject<InterestGroupDetails> {
public:
    ~InterestGroupDetails() override { }

    String GetOwnerOrigin() { return m_ownerOrigin; }
    void SetOwnerOrigin(const String& value) { m_ownerOrigin = value; }

    String GetName() { return m_name; }
    void SetName(const String& value) { m_name = value; }

    double GetExpirationTime() { return m_expirationTime; }
    void SetExpirationTime(double value) { m_expirationTime = value; }

    String GetJoiningOrigin() { return m_joiningOrigin; }
    void SetJoiningOrigin(const String& value) { m_joiningOrigin = value; }

    bool HasBiddingUrl() { return m_biddingUrl.isJust(); }
    String GetBiddingUrl(const String& defaultValue) { return m_biddingUrl.isJust() ? m_biddingUrl.fromJust() : defaultValue; }
    void SetBiddingUrl(const String& value) { m_biddingUrl = value; }

    bool HasBiddingWasmHelperUrl() { return m_biddingWasmHelperUrl.isJust(); }
    String GetBiddingWasmHelperUrl(const String& defaultValue) { return m_biddingWasmHelperUrl.isJust() ? m_biddingWasmHelperUrl.fromJust() : defaultValue; }
    void SetBiddingWasmHelperUrl(const String& value) { m_biddingWasmHelperUrl = value; }

    bool HasUpdateUrl() { return m_updateUrl.isJust(); }
    String GetUpdateUrl(const String& defaultValue) { return m_updateUrl.isJust() ? m_updateUrl.fromJust() : defaultValue; }
    void SetUpdateUrl(const String& value) { m_updateUrl = value; }

    bool HasTrustedBiddingSignalsUrl() { return m_trustedBiddingSignalsUrl.isJust(); }
    String GetTrustedBiddingSignalsUrl(const String& defaultValue) { return m_trustedBiddingSignalsUrl.isJust() ? m_trustedBiddingSignalsUrl.fromJust() : defaultValue; }
    void SetTrustedBiddingSignalsUrl(const String& value) { m_trustedBiddingSignalsUrl = value; }

    protocol::Array<String>* GetTrustedBiddingSignalsKeys() { return m_trustedBiddingSignalsKeys.get(); }
    void SetTrustedBiddingSignalsKeys(std::unique_ptr<protocol::Array<String>> value) { m_trustedBiddingSignalsKeys = std::move(value); }

    bool HasUserBiddingSignals() { return m_userBiddingSignals.isJust(); }
    String GetUserBiddingSignals(const String& defaultValue) { return m_userBiddingSignals.isJust() ? m_userBiddingSignals.fromJust() : defaultValue; }
    void SetUserBiddingSignals(const String& value) { m_userBiddingSignals = value; }

    protocol::Array<protocol::Storage::InterestGroupAd>* GetAds() { return m_ads.get(); }
    void SetAds(std::unique_ptr<protocol::Array<protocol::Storage::InterestGroupAd>> value) { m_ads = std::move(value); }

    protocol::Array<protocol::Storage::InterestGroupAd>* GetAdComponents() { return m_adComponents.get(); }
    void SetAdComponents(std::unique_ptr<protocol::Array<protocol::Storage::InterestGroupAd>> value) { m_adComponents = std::move(value); }

    template<int STATE>
    class InterestGroupDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OwnerOriginSet = 1 << 1,
            NameSet = 1 << 2,
            ExpirationTimeSet = 1 << 3,
            JoiningOriginSet = 1 << 4,
            TrustedBiddingSignalsKeysSet = 1 << 5,
            AdsSet = 1 << 6,
            AdComponentsSet = 1 << 7,
            AllFieldsSet = (OwnerOriginSet | NameSet | ExpirationTimeSet | JoiningOriginSet | TrustedBiddingSignalsKeysSet | AdsSet | AdComponentsSet | 0)};


        InterestGroupDetailsBuilder<STATE | OwnerOriginSet>& SetOwnerOrigin(const String& value)
        {
            static_assert(!(STATE & OwnerOriginSet), "property ownerOrigin should not be set yet");
            m_result->SetOwnerOrigin(value);
            return castState<OwnerOriginSet>();
        }

        InterestGroupDetailsBuilder<STATE | NameSet>& SetName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->SetName(value);
            return castState<NameSet>();
        }

        InterestGroupDetailsBuilder<STATE | ExpirationTimeSet>& SetExpirationTime(double value)
        {
            static_assert(!(STATE & ExpirationTimeSet), "property expirationTime should not be set yet");
            m_result->SetExpirationTime(value);
            return castState<ExpirationTimeSet>();
        }

        InterestGroupDetailsBuilder<STATE | JoiningOriginSet>& SetJoiningOrigin(const String& value)
        {
            static_assert(!(STATE & JoiningOriginSet), "property joiningOrigin should not be set yet");
            m_result->SetJoiningOrigin(value);
            return castState<JoiningOriginSet>();
        }

        InterestGroupDetailsBuilder<STATE>& SetBiddingUrl(const String& value)
        {
            m_result->SetBiddingUrl(value);
            return *this;
        }

        InterestGroupDetailsBuilder<STATE>& SetBiddingWasmHelperUrl(const String& value)
        {
            m_result->SetBiddingWasmHelperUrl(value);
            return *this;
        }

        InterestGroupDetailsBuilder<STATE>& SetUpdateUrl(const String& value)
        {
            m_result->SetUpdateUrl(value);
            return *this;
        }

        InterestGroupDetailsBuilder<STATE>& SetTrustedBiddingSignalsUrl(const String& value)
        {
            m_result->SetTrustedBiddingSignalsUrl(value);
            return *this;
        }

        InterestGroupDetailsBuilder<STATE | TrustedBiddingSignalsKeysSet>& SetTrustedBiddingSignalsKeys(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & TrustedBiddingSignalsKeysSet), "property trustedBiddingSignalsKeys should not be set yet");
            m_result->SetTrustedBiddingSignalsKeys(std::move(value));
            return castState<TrustedBiddingSignalsKeysSet>();
        }

        InterestGroupDetailsBuilder<STATE>& SetUserBiddingSignals(const String& value)
        {
            m_result->SetUserBiddingSignals(value);
            return *this;
        }

        InterestGroupDetailsBuilder<STATE | AdsSet>& SetAds(std::unique_ptr<protocol::Array<protocol::Storage::InterestGroupAd>> value)
        {
            static_assert(!(STATE & AdsSet), "property ads should not be set yet");
            m_result->SetAds(std::move(value));
            return castState<AdsSet>();
        }

        InterestGroupDetailsBuilder<STATE | AdComponentsSet>& SetAdComponents(std::unique_ptr<protocol::Array<protocol::Storage::InterestGroupAd>> value)
        {
            static_assert(!(STATE & AdComponentsSet), "property adComponents should not be set yet");
            m_result->SetAdComponents(std::move(value));
            return castState<AdComponentsSet>();
        }

        std::unique_ptr<InterestGroupDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InterestGroupDetails;
        InterestGroupDetailsBuilder() : m_result(new InterestGroupDetails()) { }

        template<int STEP> InterestGroupDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InterestGroupDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::InterestGroupDetails> m_result;
    };

    static InterestGroupDetailsBuilder<0> Create()
    {
        return InterestGroupDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InterestGroupDetails()
    {
          m_expirationTime = 0;
    }

    String m_ownerOrigin;
    String m_name;
    double m_expirationTime;
    String m_joiningOrigin;
    Maybe<String> m_biddingUrl;
    Maybe<String> m_biddingWasmHelperUrl;
    Maybe<String> m_updateUrl;
    Maybe<String> m_trustedBiddingSignalsUrl;
    std::unique_ptr<protocol::Array<String>> m_trustedBiddingSignalsKeys;
    Maybe<String> m_userBiddingSignals;
    std::unique_ptr<protocol::Array<protocol::Storage::InterestGroupAd>> m_ads;
    std::unique_ptr<protocol::Array<protocol::Storage::InterestGroupAd>> m_adComponents;
};


// ------------- Backend interface.

class CONTENT_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse GetStorageKeyForFrame(const String& in_frameId, String* out_storageKey) = 0;
    class CONTENT_EXPORT ClearDataForOriginCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~ClearDataForOriginCallback() { }
    };
    virtual void ClearDataForOrigin(const String& in_origin, const String& in_storageTypes, std::unique_ptr<ClearDataForOriginCallback> callback) = 0;
    class CONTENT_EXPORT ClearDataForStorageKeyCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~ClearDataForStorageKeyCallback() { }
    };
    virtual void ClearDataForStorageKey(const String& in_storageKey, const String& in_storageTypes, std::unique_ptr<ClearDataForStorageKeyCallback> callback) = 0;
    class CONTENT_EXPORT GetCookiesCallback {
    public:
        virtual void sendSuccess(std::unique_ptr<protocol::Array<protocol::Network::Cookie>> cookies) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetCookiesCallback() { }
    };
    virtual void GetCookies(Maybe<String> in_browserContextId, std::unique_ptr<GetCookiesCallback> callback) = 0;
    class CONTENT_EXPORT SetCookiesCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~SetCookiesCallback() { }
    };
    virtual void SetCookies(std::unique_ptr<protocol::Array<protocol::Network::CookieParam>> in_cookies, Maybe<String> in_browserContextId, std::unique_ptr<SetCookiesCallback> callback) = 0;
    class CONTENT_EXPORT ClearCookiesCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~ClearCookiesCallback() { }
    };
    virtual void ClearCookies(Maybe<String> in_browserContextId, std::unique_ptr<ClearCookiesCallback> callback) = 0;
    class CONTENT_EXPORT GetUsageAndQuotaCallback {
    public:
        virtual void sendSuccess(double usage, double quota, bool overrideActive, std::unique_ptr<protocol::Array<protocol::Storage::UsageForType>> usageBreakdown) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetUsageAndQuotaCallback() { }
    };
    virtual void GetUsageAndQuota(const String& in_origin, std::unique_ptr<GetUsageAndQuotaCallback> callback) = 0;
    class CONTENT_EXPORT OverrideQuotaForOriginCallback {
    public:
        virtual void sendSuccess() = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~OverrideQuotaForOriginCallback() { }
    };
    virtual void OverrideQuotaForOrigin(const String& in_origin, Maybe<double> in_quotaSize, std::unique_ptr<OverrideQuotaForOriginCallback> callback) = 0;
    virtual DispatchResponse TrackCacheStorageForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse TrackIndexedDBForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse TrackIndexedDBForStorageKey(const String& in_storageKey) = 0;
    virtual DispatchResponse UntrackCacheStorageForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse UntrackIndexedDBForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse UntrackIndexedDBForStorageKey(const String& in_storageKey) = 0;
    class CONTENT_EXPORT GetTrustTokensCallback {
    public:
        virtual void sendSuccess(std::unique_ptr<protocol::Array<protocol::Storage::TrustTokens>> tokens) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetTrustTokensCallback() { }
    };
    virtual void GetTrustTokens(std::unique_ptr<GetTrustTokensCallback> callback) = 0;
    class CONTENT_EXPORT ClearTrustTokensCallback {
    public:
        virtual void sendSuccess(bool didDeleteTokens) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~ClearTrustTokensCallback() { }
    };
    virtual void ClearTrustTokens(const String& in_issuerOrigin, std::unique_ptr<ClearTrustTokensCallback> callback) = 0;
    class CONTENT_EXPORT GetInterestGroupDetailsCallback {
    public:
        virtual void sendSuccess(std::unique_ptr<protocol::Storage::InterestGroupDetails> details) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetInterestGroupDetailsCallback() { }
    };
    virtual void GetInterestGroupDetails(const String& in_ownerOrigin, const String& in_name, std::unique_ptr<GetInterestGroupDetailsCallback> callback) = 0;
    virtual DispatchResponse SetInterestGroupTracking(bool in_enable) = 0;

    virtual DispatchResponse Disable()
    {
        return DispatchResponse::Success();
    }
};

// ------------- Frontend interface.

class CONTENT_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void CacheStorageContentUpdated(const String& origin, const String& cacheName);
    void CacheStorageListUpdated(const String& origin);
    void IndexedDBContentUpdated(const String& origin, const String& storageKey, const String& databaseName, const String& objectStoreName);
    void IndexedDBListUpdated(const String& origin, const String& storageKey);
    void InterestGroupAccessed(double accessTime, const String& type, const String& ownerOrigin, const String& name);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CONTENT_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CONTENT_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Storage
} // namespace content
} // namespace protocol

#endif // !defined(content_protocol_Storage_h)
