// content/browser/attribution_reporting/attribution_internals.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "content/browser/attribution_reporting/attribution_internals.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "content/browser/attribution_reporting/attribution_internals.mojom-params-data.h"
#include "content/browser/attribution_reporting/attribution_internals.mojom-shared-message-ids.h"

#include "content/browser/attribution_reporting/attribution_internals.mojom-import-headers.h"
#include "content/browser/attribution_reporting/attribution_internals.mojom-test-utils.h"


#ifndef CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_JUMBO_H_
#define CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_JUMBO_H_
#endif



namespace attribution_internals {
namespace mojom {
EventLevelReportID::EventLevelReportID()
    : value() {}

EventLevelReportID::EventLevelReportID(
    int64_t value_in)
    : value(std::move(value_in)) {}

EventLevelReportID::~EventLevelReportID() = default;

void EventLevelReportID::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool EventLevelReportID::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AggregatableAttributionReportID::AggregatableAttributionReportID()
    : value() {}

AggregatableAttributionReportID::AggregatableAttributionReportID(
    int64_t value_in)
    : value(std::move(value_in)) {}

AggregatableAttributionReportID::~AggregatableAttributionReportID() = default;

void AggregatableAttributionReportID::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AggregatableAttributionReportID::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUIReportEventLevelData::WebUIReportEventLevelData()
    : priority(),
      attributed_truthfully() {}

WebUIReportEventLevelData::WebUIReportEventLevelData(
    int64_t priority_in,
    bool attributed_truthfully_in)
    : priority(std::move(priority_in)),
      attributed_truthfully(std::move(attributed_truthfully_in)) {}

WebUIReportEventLevelData::~WebUIReportEventLevelData() = default;
size_t WebUIReportEventLevelData::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->priority);
  seed = mojo::internal::Hash(seed, this->attributed_truthfully);
  return seed;
}

void WebUIReportEventLevelData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "priority"), this->priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "attributed_truthfully"), this->attributed_truthfully,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUIReportEventLevelData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AggregatableHistogramContribution::AggregatableHistogramContribution()
    : key(),
      value() {}

AggregatableHistogramContribution::AggregatableHistogramContribution(
    const std::string& key_in,
    uint32_t value_in)
    : key(std::move(key_in)),
      value(std::move(value_in)) {}

AggregatableHistogramContribution::~AggregatableHistogramContribution() = default;
size_t AggregatableHistogramContribution::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->key);
  seed = mojo::internal::Hash(seed, this->value);
  return seed;
}

void AggregatableHistogramContribution::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key"), this->key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AggregatableHistogramContribution::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUIReportAggregatableAttributionData::WebUIReportAggregatableAttributionData()
    : contributions() {}

WebUIReportAggregatableAttributionData::WebUIReportAggregatableAttributionData(
    std::vector<AggregatableHistogramContributionPtr> contributions_in)
    : contributions(std::move(contributions_in)) {}

WebUIReportAggregatableAttributionData::~WebUIReportAggregatableAttributionData() = default;

void WebUIReportAggregatableAttributionData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "contributions"), this->contributions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<AggregatableHistogramContributionPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUIReportAggregatableAttributionData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Empty::Empty() {}

Empty::~Empty() = default;
size_t Empty::Hash(size_t seed) const {
  return seed;
}

void Empty::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
}

bool Empty::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUIReport::WebUIReport()
    : id(),
      report_url(),
      trigger_time(),
      report_time(),
      report_body(),
      status(),
      data() {}

WebUIReport::WebUIReport(
    const ::content::AttributionReport::Id& id_in,
    const ::GURL& report_url_in,
    double trigger_time_in,
    double report_time_in,
    const std::string& report_body_in,
    ReportStatusPtr status_in,
    WebUIReportDataPtr data_in)
    : id(std::move(id_in)),
      report_url(std::move(report_url_in)),
      trigger_time(std::move(trigger_time_in)),
      report_time(std::move(report_time_in)),
      report_body(std::move(report_body_in)),
      status(std::move(status_in)),
      data(std::move(data_in)) {}

WebUIReport::~WebUIReport() = default;

void WebUIReport::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::content::AttributionReport::Id&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "report_url"), this->report_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "trigger_time"), this->trigger_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "report_time"), this->report_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "report_body"), this->report_body,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "status"), this->status,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ReportStatusPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WebUIReportDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUIReport::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DebugKey::DebugKey()
    : value() {}

DebugKey::DebugKey(
    uint64_t value_in)
    : value(std::move(value_in)) {}

DebugKey::~DebugKey() = default;
size_t DebugKey::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->value);
  return seed;
}

void DebugKey::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DebugKey::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUISource::WebUISource()
    : source_event_id(),
      source_origin(),
      attribution_destination(),
      reporting_origin(),
      source_time(),
      expiry_time(),
      source_type(),
      priority(),
      debug_key(),
      dedup_keys(),
      filter_data(),
      aggregation_keys(),
      attributability() {}

WebUISource::WebUISource(
    uint64_t source_event_id_in,
    const ::url::Origin& source_origin_in,
    const std::string& attribution_destination_in,
    const ::url::Origin& reporting_origin_in,
    double source_time_in,
    double expiry_time_in,
    ::content::AttributionSourceType source_type_in,
    int64_t priority_in,
    DebugKeyPtr debug_key_in,
    std::vector<uint64_t> dedup_keys_in,
    const base::flat_map<std::string, std::vector<std::string>>& filter_data_in,
    const base::flat_map<std::string, std::string>& aggregation_keys_in,
    WebUISource::Attributability attributability_in)
    : source_event_id(std::move(source_event_id_in)),
      source_origin(std::move(source_origin_in)),
      attribution_destination(std::move(attribution_destination_in)),
      reporting_origin(std::move(reporting_origin_in)),
      source_time(std::move(source_time_in)),
      expiry_time(std::move(expiry_time_in)),
      source_type(std::move(source_type_in)),
      priority(std::move(priority_in)),
      debug_key(std::move(debug_key_in)),
      dedup_keys(std::move(dedup_keys_in)),
      filter_data(std::move(filter_data_in)),
      aggregation_keys(std::move(aggregation_keys_in)),
      attributability(std::move(attributability_in)) {}

WebUISource::~WebUISource() = default;

void WebUISource::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_event_id"), this->source_event_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_origin"), this->source_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "attribution_destination"), this->attribution_destination,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_origin"), this->reporting_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_time"), this->source_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "expiry_time"), this->expiry_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_type"), this->source_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::content::AttributionSourceType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "priority"), this->priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "debug_key"), this->debug_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DebugKeyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dedup_keys"), this->dedup_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<uint64_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filter_data"), this->filter_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregation_keys"), this->aggregation_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "attributability"), this->attributability,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WebUISource::Attributability>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUISource::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DedupKey::DedupKey()
    : value() {}

DedupKey::DedupKey(
    uint64_t value_in)
    : value(std::move(value_in)) {}

DedupKey::~DedupKey() = default;
size_t DedupKey::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->value);
  return seed;
}

void DedupKey::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DedupKey::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUIEventTriggerData::WebUIEventTriggerData()
    : data(),
      priority(),
      dedup_key(),
      filters(),
      not_filters() {}

WebUIEventTriggerData::WebUIEventTriggerData(
    uint64_t data_in,
    int64_t priority_in,
    DedupKeyPtr dedup_key_in,
    const base::flat_map<std::string, std::vector<std::string>>& filters_in,
    const base::flat_map<std::string, std::vector<std::string>>& not_filters_in)
    : data(std::move(data_in)),
      priority(std::move(priority_in)),
      dedup_key(std::move(dedup_key_in)),
      filters(std::move(filters_in)),
      not_filters(std::move(not_filters_in)) {}

WebUIEventTriggerData::~WebUIEventTriggerData() = default;

void WebUIEventTriggerData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "priority"), this->priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dedup_key"), this->dedup_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DedupKeyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filters"), this->filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "not_filters"), this->not_filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUIEventTriggerData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUIAggregatableTriggerData::WebUIAggregatableTriggerData()
    : key_piece(),
      source_keys(),
      filters(),
      not_filters() {}

WebUIAggregatableTriggerData::WebUIAggregatableTriggerData(
    const std::string& key_piece_in,
    std::vector<std::string> source_keys_in,
    const base::flat_map<std::string, std::vector<std::string>>& filters_in,
    const base::flat_map<std::string, std::vector<std::string>>& not_filters_in)
    : key_piece(std::move(key_piece_in)),
      source_keys(std::move(source_keys_in)),
      filters(std::move(filters_in)),
      not_filters(std::move(not_filters_in)) {}

WebUIAggregatableTriggerData::~WebUIAggregatableTriggerData() = default;

void WebUIAggregatableTriggerData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_piece"), this->key_piece,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_keys"), this->source_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filters"), this->filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "not_filters"), this->not_filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUIAggregatableTriggerData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
WebUITrigger::WebUITrigger()
    : trigger_time(),
      destination_origin(),
      reporting_origin(),
      filters(),
      not_filters(),
      debug_key(),
      event_triggers(),
      aggregatable_triggers(),
      aggregatable_values(),
      event_level_status(),
      aggregatable_status() {}

WebUITrigger::WebUITrigger(
    double trigger_time_in,
    const ::url::Origin& destination_origin_in,
    const ::url::Origin& reporting_origin_in,
    const base::flat_map<std::string, std::vector<std::string>>& filters_in,
    const base::flat_map<std::string, std::vector<std::string>>& not_filters_in,
    DebugKeyPtr debug_key_in,
    std::vector<WebUIEventTriggerDataPtr> event_triggers_in,
    std::vector<WebUIAggregatableTriggerDataPtr> aggregatable_triggers_in,
    const base::flat_map<std::string, uint32_t>& aggregatable_values_in,
    WebUITrigger::Status event_level_status_in,
    WebUITrigger::Status aggregatable_status_in)
    : trigger_time(std::move(trigger_time_in)),
      destination_origin(std::move(destination_origin_in)),
      reporting_origin(std::move(reporting_origin_in)),
      filters(std::move(filters_in)),
      not_filters(std::move(not_filters_in)),
      debug_key(std::move(debug_key_in)),
      event_triggers(std::move(event_triggers_in)),
      aggregatable_triggers(std::move(aggregatable_triggers_in)),
      aggregatable_values(std::move(aggregatable_values_in)),
      event_level_status(std::move(event_level_status_in)),
      aggregatable_status(std::move(aggregatable_status_in)) {}

WebUITrigger::~WebUITrigger() = default;

void WebUITrigger::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "trigger_time"), this->trigger_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "destination_origin"), this->destination_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_origin"), this->reporting_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filters"), this->filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "not_filters"), this->not_filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "debug_key"), this->debug_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DebugKeyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "event_triggers"), this->event_triggers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<WebUIEventTriggerDataPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregatable_triggers"), this->aggregatable_triggers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<WebUIAggregatableTriggerDataPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregatable_values"), this->aggregatable_values,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, uint32_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "event_level_status"), this->event_level_status,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WebUITrigger::Status>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregatable_status"), this->aggregatable_status,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WebUITrigger::Status>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebUITrigger::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ReportID::ReportID() : tag_(Tag::kEventLevelId) {
  data_.event_level_id = new ::content::AttributionReport::EventLevelData::Id;
}

ReportID::~ReportID() {
  DestroyActive();
}


void ReportID::set_event_level_id(
    const ::content::AttributionReport::EventLevelData::Id& event_level_id) {
  if (tag_ == Tag::kEventLevelId) {
    *(data_.event_level_id) = std::move(event_level_id);
  } else {
    DestroyActive();
    tag_ = Tag::kEventLevelId;
    data_.event_level_id = new ::content::AttributionReport::EventLevelData::Id(
        std::move(event_level_id));
  }
}
void ReportID::set_aggregatable_attribution_id(
    const ::content::AttributionReport::AggregatableAttributionData::Id& aggregatable_attribution_id) {
  if (tag_ == Tag::kAggregatableAttributionId) {
    *(data_.aggregatable_attribution_id) = std::move(aggregatable_attribution_id);
  } else {
    DestroyActive();
    tag_ = Tag::kAggregatableAttributionId;
    data_.aggregatable_attribution_id = new ::content::AttributionReport::AggregatableAttributionData::Id(
        std::move(aggregatable_attribution_id));
  }
}

void ReportID::DestroyActive() {
  switch (tag_) {

    case Tag::kEventLevelId:

      delete data_.event_level_id;
      break;
    case Tag::kAggregatableAttributionId:

      delete data_.aggregatable_attribution_id;
      break;
  }
}

bool ReportID::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
WebUIReportData::WebUIReportData() : tag_(Tag::kEventLevelData) {
  data_.event_level_data = new WebUIReportEventLevelDataPtr;
}

WebUIReportData::~WebUIReportData() {
  DestroyActive();
}


void WebUIReportData::set_event_level_data(
    WebUIReportEventLevelDataPtr event_level_data) {
  if (tag_ == Tag::kEventLevelData) {
    *(data_.event_level_data) = std::move(event_level_data);
  } else {
    DestroyActive();
    tag_ = Tag::kEventLevelData;
    data_.event_level_data = new WebUIReportEventLevelDataPtr(
        std::move(event_level_data));
  }
}
void WebUIReportData::set_aggregatable_attribution_data(
    WebUIReportAggregatableAttributionDataPtr aggregatable_attribution_data) {
  if (tag_ == Tag::kAggregatableAttributionData) {
    *(data_.aggregatable_attribution_data) = std::move(aggregatable_attribution_data);
  } else {
    DestroyActive();
    tag_ = Tag::kAggregatableAttributionData;
    data_.aggregatable_attribution_data = new WebUIReportAggregatableAttributionDataPtr(
        std::move(aggregatable_attribution_data));
  }
}

void WebUIReportData::DestroyActive() {
  switch (tag_) {

    case Tag::kEventLevelData:

      delete data_.event_level_data;
      break;
    case Tag::kAggregatableAttributionData:

      delete data_.aggregatable_attribution_data;
      break;
  }
}

bool WebUIReportData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
ReportStatus::ReportStatus() : tag_(Tag::kPending) {
  data_.pending = new EmptyPtr;
}

ReportStatus::~ReportStatus() {
  DestroyActive();
}


void ReportStatus::set_pending(
    EmptyPtr pending) {
  if (tag_ == Tag::kPending) {
    *(data_.pending) = std::move(pending);
  } else {
    DestroyActive();
    tag_ = Tag::kPending;
    data_.pending = new EmptyPtr(
        std::move(pending));
  }
}
void ReportStatus::set_replaced_by_higher_priority_report(
    const std::string& replaced_by_higher_priority_report) {
  if (tag_ == Tag::kReplacedByHigherPriorityReport) {
    *(data_.replaced_by_higher_priority_report) = std::move(replaced_by_higher_priority_report);
  } else {
    DestroyActive();
    tag_ = Tag::kReplacedByHigherPriorityReport;
    data_.replaced_by_higher_priority_report = new std::string(
        std::move(replaced_by_higher_priority_report));
  }
}
void ReportStatus::set_prohibited_by_browser_policy(
    EmptyPtr prohibited_by_browser_policy) {
  if (tag_ == Tag::kProhibitedByBrowserPolicy) {
    *(data_.prohibited_by_browser_policy) = std::move(prohibited_by_browser_policy);
  } else {
    DestroyActive();
    tag_ = Tag::kProhibitedByBrowserPolicy;
    data_.prohibited_by_browser_policy = new EmptyPtr(
        std::move(prohibited_by_browser_policy));
  }
}
void ReportStatus::set_sent(
    int32_t sent) {
  if (tag_ != Tag::kSent) {
    DestroyActive();
    tag_ = Tag::kSent;
  }
  data_.sent = sent;
}
void ReportStatus::set_network_error(
    const std::string& network_error) {
  if (tag_ == Tag::kNetworkError) {
    *(data_.network_error) = std::move(network_error);
  } else {
    DestroyActive();
    tag_ = Tag::kNetworkError;
    data_.network_error = new std::string(
        std::move(network_error));
  }
}
void ReportStatus::set_failed_to_assemble(
    EmptyPtr failed_to_assemble) {
  if (tag_ == Tag::kFailedToAssemble) {
    *(data_.failed_to_assemble) = std::move(failed_to_assemble);
  } else {
    DestroyActive();
    tag_ = Tag::kFailedToAssemble;
    data_.failed_to_assemble = new EmptyPtr(
        std::move(failed_to_assemble));
  }
}

void ReportStatus::DestroyActive() {
  switch (tag_) {

    case Tag::kPending:

      delete data_.pending;
      break;
    case Tag::kReplacedByHigherPriorityReport:

      delete data_.replaced_by_higher_priority_report;
      break;
    case Tag::kProhibitedByBrowserPolicy:

      delete data_.prohibited_by_browser_policy;
      break;
    case Tag::kSent:

      break;
    case Tag::kNetworkError:

      delete data_.network_error;
      break;
    case Tag::kFailedToAssemble:

      delete data_.failed_to_assemble;
      break;
  }
}
size_t ReportStatus::Hash(size_t seed) const {
  seed = mojo::internal::HashCombine(seed, static_cast<uint32_t>(tag_));
  switch (tag_) {

    case Tag::kPending:
      return mojo::internal::Hash(seed, data_.pending);
    case Tag::kReplacedByHigherPriorityReport:
      return mojo::internal::Hash(seed, data_.replaced_by_higher_priority_report);
    case Tag::kProhibitedByBrowserPolicy:
      return mojo::internal::Hash(seed, data_.prohibited_by_browser_policy);
    case Tag::kSent:
      return mojo::internal::Hash(seed, data_.sent);
    case Tag::kNetworkError:
      return mojo::internal::Hash(seed, data_.network_error);
    case Tag::kFailedToAssemble:
      return mojo::internal::Hash(seed, data_.failed_to_assemble);
    default:
      NOTREACHED();
      return seed;
  }
}

bool ReportStatus::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char Observer::Name_[] = "attribution_internals.mojom.Observer";

Observer::IPCStableHashFunction Observer::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kObserver_OnSourcesChanged_Name: {
      return &Observer::OnSourcesChanged_Sym::IPCStableHash;
    }
    case internal::kObserver_OnReportsChanged_Name: {
      return &Observer::OnReportsChanged_Sym::IPCStableHash;
    }
    case internal::kObserver_OnSourceRejectedOrDeactivated_Name: {
      return &Observer::OnSourceRejectedOrDeactivated_Sym::IPCStableHash;
    }
    case internal::kObserver_OnReportSent_Name: {
      return &Observer::OnReportSent_Sym::IPCStableHash;
    }
    case internal::kObserver_OnReportDropped_Name: {
      return &Observer::OnReportDropped_Sym::IPCStableHash;
    }
    case internal::kObserver_OnTriggerHandled_Name: {
      return &Observer::OnTriggerHandled_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* Observer::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kObserver_OnSourcesChanged_Name:
            return "Receive attribution_internals::mojom::Observer::OnSourcesChanged";
      case internal::kObserver_OnReportsChanged_Name:
            return "Receive attribution_internals::mojom::Observer::OnReportsChanged";
      case internal::kObserver_OnSourceRejectedOrDeactivated_Name:
            return "Receive attribution_internals::mojom::Observer::OnSourceRejectedOrDeactivated";
      case internal::kObserver_OnReportSent_Name:
            return "Receive attribution_internals::mojom::Observer::OnReportSent";
      case internal::kObserver_OnReportDropped_Name:
            return "Receive attribution_internals::mojom::Observer::OnReportDropped";
      case internal::kObserver_OnTriggerHandled_Name:
            return "Receive attribution_internals::mojom::Observer::OnTriggerHandled";
    }
  } else {
    switch (message.name()) {
      case internal::kObserver_OnSourcesChanged_Name:
            return "Receive reply attribution_internals::mojom::Observer::OnSourcesChanged";
      case internal::kObserver_OnReportsChanged_Name:
            return "Receive reply attribution_internals::mojom::Observer::OnReportsChanged";
      case internal::kObserver_OnSourceRejectedOrDeactivated_Name:
            return "Receive reply attribution_internals::mojom::Observer::OnSourceRejectedOrDeactivated";
      case internal::kObserver_OnReportSent_Name:
            return "Receive reply attribution_internals::mojom::Observer::OnReportSent";
      case internal::kObserver_OnReportDropped_Name:
            return "Receive reply attribution_internals::mojom::Observer::OnReportDropped";
      case internal::kObserver_OnTriggerHandled_Name:
            return "Receive reply attribution_internals::mojom::Observer::OnTriggerHandled";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t Observer::OnSourcesChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Observer::OnSourcesChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Observer::OnReportsChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Observer::OnReportsChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Observer::OnSourceRejectedOrDeactivated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Observer::OnSourceRejectedOrDeactivated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Observer::OnReportSent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Observer::OnReportSent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Observer::OnReportDropped_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Observer::OnReportDropped");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Observer::OnTriggerHandled_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Observer::OnTriggerHandled");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

ObserverProxy::ObserverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void ObserverProxy::OnSourcesChanged(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send attribution_internals::mojom::Observer::OnSourcesChanged");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kObserver_OnSourcesChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Observer_OnSourcesChanged_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Observer::Name_);
  message.set_method_name("OnSourcesChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void ObserverProxy::OnReportsChanged(
    ::content::AttributionReport::ReportType in_report_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Observer::OnReportsChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report_type"), in_report_type,
                        "<value of type ::content::AttributionReport::ReportType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kObserver_OnReportsChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Observer_OnReportsChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::attribution_internals::mojom::ReportType>(
      in_report_type, &params->report_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Observer::Name_);
  message.set_method_name("OnReportsChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void ObserverProxy::OnSourceRejectedOrDeactivated(
    WebUISourcePtr in_source) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Observer::OnSourceRejectedOrDeactivated", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source"), in_source,
                        "<value of type WebUISourcePtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kObserver_OnSourceRejectedOrDeactivated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Observer_OnSourceRejectedOrDeactivated_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->source)::BaseType> source_fragment(
          params.message());
  mojo::internal::Serialize<::attribution_internals::mojom::WebUISourceDataView>(
      in_source, source_fragment);
  params->source.Set(
      source_fragment.is_null() ? nullptr : source_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source in Observer.OnSourceRejectedOrDeactivated request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Observer::Name_);
  message.set_method_name("OnSourceRejectedOrDeactivated");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void ObserverProxy::OnReportSent(
    WebUIReportPtr in_report) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Observer::OnReportSent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report"), in_report,
                        "<value of type WebUIReportPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kObserver_OnReportSent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Observer_OnReportSent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->report)::BaseType> report_fragment(
          params.message());
  mojo::internal::Serialize<::attribution_internals::mojom::WebUIReportDataView>(
      in_report, report_fragment);
  params->report.Set(
      report_fragment.is_null() ? nullptr : report_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->report.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null report in Observer.OnReportSent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Observer::Name_);
  message.set_method_name("OnReportSent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void ObserverProxy::OnReportDropped(
    WebUIReportPtr in_report) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Observer::OnReportDropped", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report"), in_report,
                        "<value of type WebUIReportPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kObserver_OnReportDropped_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Observer_OnReportDropped_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->report)::BaseType> report_fragment(
          params.message());
  mojo::internal::Serialize<::attribution_internals::mojom::WebUIReportDataView>(
      in_report, report_fragment);
  params->report.Set(
      report_fragment.is_null() ? nullptr : report_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->report.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null report in Observer.OnReportDropped request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Observer::Name_);
  message.set_method_name("OnReportDropped");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void ObserverProxy::OnTriggerHandled(
    WebUITriggerPtr in_trigger) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Observer::OnTriggerHandled", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trigger"), in_trigger,
                        "<value of type WebUITriggerPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kObserver_OnTriggerHandled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Observer_OnTriggerHandled_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->trigger)::BaseType> trigger_fragment(
          params.message());
  mojo::internal::Serialize<::attribution_internals::mojom::WebUITriggerDataView>(
      in_trigger, trigger_fragment);
  params->trigger.Set(
      trigger_fragment.is_null() ? nullptr : trigger_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->trigger.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null trigger in Observer.OnTriggerHandled request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Observer::Name_);
  message.set_method_name("OnTriggerHandled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool ObserverStubDispatch::Accept(
    Observer* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kObserver_OnSourcesChanged_Name: {

      DCHECK(message->is_serialized());
      internal::Observer_OnSourcesChanged_Params_Data* params =
          reinterpret_cast<internal::Observer_OnSourcesChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      Observer_OnSourcesChanged_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Observer::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSourcesChanged();
      return true;
    }
    case internal::kObserver_OnReportsChanged_Name: {

      DCHECK(message->is_serialized());
      internal::Observer_OnReportsChanged_Params_Data* params =
          reinterpret_cast<internal::Observer_OnReportsChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::content::AttributionReport::ReportType p_report_type{};
      Observer_OnReportsChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReportType(&p_report_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Observer::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnReportsChanged(
std::move(p_report_type));
      return true;
    }
    case internal::kObserver_OnSourceRejectedOrDeactivated_Name: {

      DCHECK(message->is_serialized());
      internal::Observer_OnSourceRejectedOrDeactivated_Params_Data* params =
          reinterpret_cast<internal::Observer_OnSourceRejectedOrDeactivated_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WebUISourcePtr p_source{};
      Observer_OnSourceRejectedOrDeactivated_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSource(&p_source))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Observer::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSourceRejectedOrDeactivated(
std::move(p_source));
      return true;
    }
    case internal::kObserver_OnReportSent_Name: {

      DCHECK(message->is_serialized());
      internal::Observer_OnReportSent_Params_Data* params =
          reinterpret_cast<internal::Observer_OnReportSent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WebUIReportPtr p_report{};
      Observer_OnReportSent_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReport(&p_report))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Observer::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnReportSent(
std::move(p_report));
      return true;
    }
    case internal::kObserver_OnReportDropped_Name: {

      DCHECK(message->is_serialized());
      internal::Observer_OnReportDropped_Params_Data* params =
          reinterpret_cast<internal::Observer_OnReportDropped_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WebUIReportPtr p_report{};
      Observer_OnReportDropped_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReport(&p_report))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Observer::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnReportDropped(
std::move(p_report));
      return true;
    }
    case internal::kObserver_OnTriggerHandled_Name: {

      DCHECK(message->is_serialized());
      internal::Observer_OnTriggerHandled_Params_Data* params =
          reinterpret_cast<internal::Observer_OnTriggerHandled_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WebUITriggerPtr p_trigger{};
      Observer_OnTriggerHandled_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTrigger(&p_trigger))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Observer::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnTriggerHandled(
std::move(p_trigger));
      return true;
    }
  }
  return false;
}

// static
bool ObserverStubDispatch::AcceptWithResponder(
    Observer* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kObserver_OnSourcesChanged_Name: {
      break;
    }
    case internal::kObserver_OnReportsChanged_Name: {
      break;
    }
    case internal::kObserver_OnSourceRejectedOrDeactivated_Name: {
      break;
    }
    case internal::kObserver_OnReportSent_Name: {
      break;
    }
    case internal::kObserver_OnReportDropped_Name: {
      break;
    }
    case internal::kObserver_OnTriggerHandled_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kObserverValidationInfo[] = {
    {&internal::Observer_OnSourcesChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Observer_OnReportsChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Observer_OnSourceRejectedOrDeactivated_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Observer_OnReportSent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Observer_OnReportDropped_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::Observer_OnTriggerHandled_Params_Data::Validate,
     nullptr /* no response */},
};

bool ObserverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::attribution_internals::mojom::Observer::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kObserverValidationInfo);
}

const char Handler::Name_[] = "attribution_internals.mojom.Handler";

Handler::IPCStableHashFunction Handler::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kHandler_IsAttributionReportingEnabled_Name: {
      return &Handler::IsAttributionReportingEnabled_Sym::IPCStableHash;
    }
    case internal::kHandler_GetActiveSources_Name: {
      return &Handler::GetActiveSources_Sym::IPCStableHash;
    }
    case internal::kHandler_GetReports_Name: {
      return &Handler::GetReports_Sym::IPCStableHash;
    }
    case internal::kHandler_SendReports_Name: {
      return &Handler::SendReports_Sym::IPCStableHash;
    }
    case internal::kHandler_ClearStorage_Name: {
      return &Handler::ClearStorage_Sym::IPCStableHash;
    }
    case internal::kHandler_AddObserver_Name: {
      return &Handler::AddObserver_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* Handler::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kHandler_IsAttributionReportingEnabled_Name:
            return "Receive attribution_internals::mojom::Handler::IsAttributionReportingEnabled";
      case internal::kHandler_GetActiveSources_Name:
            return "Receive attribution_internals::mojom::Handler::GetActiveSources";
      case internal::kHandler_GetReports_Name:
            return "Receive attribution_internals::mojom::Handler::GetReports";
      case internal::kHandler_SendReports_Name:
            return "Receive attribution_internals::mojom::Handler::SendReports";
      case internal::kHandler_ClearStorage_Name:
            return "Receive attribution_internals::mojom::Handler::ClearStorage";
      case internal::kHandler_AddObserver_Name:
            return "Receive attribution_internals::mojom::Handler::AddObserver";
    }
  } else {
    switch (message.name()) {
      case internal::kHandler_IsAttributionReportingEnabled_Name:
            return "Receive reply attribution_internals::mojom::Handler::IsAttributionReportingEnabled";
      case internal::kHandler_GetActiveSources_Name:
            return "Receive reply attribution_internals::mojom::Handler::GetActiveSources";
      case internal::kHandler_GetReports_Name:
            return "Receive reply attribution_internals::mojom::Handler::GetReports";
      case internal::kHandler_SendReports_Name:
            return "Receive reply attribution_internals::mojom::Handler::SendReports";
      case internal::kHandler_ClearStorage_Name:
            return "Receive reply attribution_internals::mojom::Handler::ClearStorage";
      case internal::kHandler_AddObserver_Name:
            return "Receive reply attribution_internals::mojom::Handler::AddObserver";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t Handler::IsAttributionReportingEnabled_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Handler::IsAttributionReportingEnabled");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Handler::GetActiveSources_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Handler::GetActiveSources");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Handler::GetReports_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Handler::GetReports");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Handler::SendReports_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Handler::SendReports");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Handler::ClearStorage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Handler::ClearStorage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t Handler::AddObserver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)attribution_internals::mojom::Handler::AddObserver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class Handler_IsAttributionReportingEnabled_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Handler_IsAttributionReportingEnabled_ForwardToCallback(
      Handler::IsAttributionReportingEnabledCallback callback
      ) : callback_(std::move(callback)) {
  }

  Handler_IsAttributionReportingEnabled_ForwardToCallback(const Handler_IsAttributionReportingEnabled_ForwardToCallback&) = delete;
  Handler_IsAttributionReportingEnabled_ForwardToCallback& operator=(const Handler_IsAttributionReportingEnabled_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  Handler::IsAttributionReportingEnabledCallback callback_;
};

class Handler_GetActiveSources_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Handler_GetActiveSources_ForwardToCallback(
      Handler::GetActiveSourcesCallback callback
      ) : callback_(std::move(callback)) {
  }

  Handler_GetActiveSources_ForwardToCallback(const Handler_GetActiveSources_ForwardToCallback&) = delete;
  Handler_GetActiveSources_ForwardToCallback& operator=(const Handler_GetActiveSources_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  Handler::GetActiveSourcesCallback callback_;
};

class Handler_GetReports_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Handler_GetReports_ForwardToCallback(
      Handler::GetReportsCallback callback
      ) : callback_(std::move(callback)) {
  }

  Handler_GetReports_ForwardToCallback(const Handler_GetReports_ForwardToCallback&) = delete;
  Handler_GetReports_ForwardToCallback& operator=(const Handler_GetReports_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  Handler::GetReportsCallback callback_;
};

class Handler_SendReports_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Handler_SendReports_ForwardToCallback(
      Handler::SendReportsCallback callback
      ) : callback_(std::move(callback)) {
  }

  Handler_SendReports_ForwardToCallback(const Handler_SendReports_ForwardToCallback&) = delete;
  Handler_SendReports_ForwardToCallback& operator=(const Handler_SendReports_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  Handler::SendReportsCallback callback_;
};

class Handler_ClearStorage_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Handler_ClearStorage_ForwardToCallback(
      Handler::ClearStorageCallback callback
      ) : callback_(std::move(callback)) {
  }

  Handler_ClearStorage_ForwardToCallback(const Handler_ClearStorage_ForwardToCallback&) = delete;
  Handler_ClearStorage_ForwardToCallback& operator=(const Handler_ClearStorage_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  Handler::ClearStorageCallback callback_;
};

class Handler_AddObserver_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  Handler_AddObserver_ForwardToCallback(
      Handler::AddObserverCallback callback
      ) : callback_(std::move(callback)) {
  }

  Handler_AddObserver_ForwardToCallback(const Handler_AddObserver_ForwardToCallback&) = delete;
  Handler_AddObserver_ForwardToCallback& operator=(const Handler_AddObserver_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  Handler::AddObserverCallback callback_;
};

HandlerProxy::HandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void HandlerProxy::IsAttributionReportingEnabled(
    IsAttributionReportingEnabledCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send attribution_internals::mojom::Handler::IsAttributionReportingEnabled");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_IsAttributionReportingEnabled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_IsAttributionReportingEnabled_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("IsAttributionReportingEnabled");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Handler_IsAttributionReportingEnabled_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void HandlerProxy::GetActiveSources(
    GetActiveSourcesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send attribution_internals::mojom::Handler::GetActiveSources");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_GetActiveSources_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_GetActiveSources_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("GetActiveSources");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Handler_GetActiveSources_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void HandlerProxy::GetReports(
    ::content::AttributionReport::ReportType in_report_type, GetReportsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Handler::GetReports", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report_type"), in_report_type,
                        "<value of type ::content::AttributionReport::ReportType>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_GetReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_GetReports_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::attribution_internals::mojom::ReportType>(
      in_report_type, &params->report_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("GetReports");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Handler_GetReports_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void HandlerProxy::SendReports(
    const std::vector<::content::AttributionReport::Id>& in_ids, SendReportsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Handler::SendReports", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ids"), in_ids,
                        "<value of type const std::vector<::content::AttributionReport::Id>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_SendReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_SendReports_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->ids)::BaseType>
      ids_fragment(params.message());
  const mojo::internal::ContainerValidateParams ids_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::attribution_internals::mojom::ReportIDDataView>>(
      in_ids, ids_fragment, &ids_validate_params);
  params->ids.Set(
      ids_fragment.is_null() ? nullptr : ids_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ids.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ids in Handler.SendReports request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("SendReports");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Handler_SendReports_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void HandlerProxy::ClearStorage(
    ClearStorageCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send attribution_internals::mojom::Handler::ClearStorage");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_ClearStorage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_ClearStorage_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("ClearStorage");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Handler_ClearStorage_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void HandlerProxy::AddObserver(
    ::mojo::PendingRemote<Observer> in_observer, AddObserverCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send attribution_internals::mojom::Handler::AddObserver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("observer"), in_observer,
                        "<value of type ::mojo::PendingRemote<Observer>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_AddObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_AddObserver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::attribution_internals::mojom::ObserverInterfaceBase>>(
      in_observer, &params->observer, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->observer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid observer in Handler.AddObserver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("AddObserver");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new Handler_AddObserver_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class Handler_IsAttributionReportingEnabled_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static Handler::IsAttributionReportingEnabledCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Handler_IsAttributionReportingEnabled_ProxyToResponder> proxy(
        new Handler_IsAttributionReportingEnabled_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&Handler_IsAttributionReportingEnabled_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Handler_IsAttributionReportingEnabled_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  Handler_IsAttributionReportingEnabled_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Handler::IsAttributionReportingEnabledCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_enabled, bool in_debug_mode);
};

bool Handler_IsAttributionReportingEnabled_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::Handler_IsAttributionReportingEnabled_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Handler_IsAttributionReportingEnabled_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_enabled{};
  bool p_debug_mode{};
  Handler_IsAttributionReportingEnabled_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_enabled = input_data_view.enabled();
  if (success)
    p_debug_mode = input_data_view.debug_mode();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Handler::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_enabled), 
std::move(p_debug_mode));
  return true;
}

void Handler_IsAttributionReportingEnabled_ProxyToResponder::Run(
    bool in_enabled, bool in_debug_mode) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply attribution_internals::mojom::Handler::IsAttributionReportingEnabled", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("enabled"), in_enabled,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("debug_mode"), in_debug_mode,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_IsAttributionReportingEnabled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_IsAttributionReportingEnabled_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->enabled = in_enabled;
  params->debug_mode = in_debug_mode;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("IsAttributionReportingEnabled");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Handler_GetActiveSources_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static Handler::GetActiveSourcesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Handler_GetActiveSources_ProxyToResponder> proxy(
        new Handler_GetActiveSources_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&Handler_GetActiveSources_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Handler_GetActiveSources_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  Handler_GetActiveSources_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Handler::GetActiveSourcesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<WebUISourcePtr> in_sources);
};

bool Handler_GetActiveSources_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::Handler_GetActiveSources_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Handler_GetActiveSources_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<WebUISourcePtr> p_sources{};
  Handler_GetActiveSources_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadSources(&p_sources))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Handler::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_sources));
  return true;
}

void Handler_GetActiveSources_ProxyToResponder::Run(
    std::vector<WebUISourcePtr> in_sources) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply attribution_internals::mojom::Handler::GetActiveSources", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sources"), in_sources,
                        "<value of type std::vector<WebUISourcePtr>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_GetActiveSources_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_GetActiveSources_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->sources)::BaseType>
      sources_fragment(params.message());
  const mojo::internal::ContainerValidateParams sources_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::attribution_internals::mojom::WebUISourceDataView>>(
      in_sources, sources_fragment, &sources_validate_params);
  params->sources.Set(
      sources_fragment.is_null() ? nullptr : sources_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sources.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sources in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("GetActiveSources");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Handler_GetReports_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static Handler::GetReportsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Handler_GetReports_ProxyToResponder> proxy(
        new Handler_GetReports_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&Handler_GetReports_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Handler_GetReports_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  Handler_GetReports_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Handler::GetReportsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<WebUIReportPtr> in_reports);
};

bool Handler_GetReports_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::Handler_GetReports_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Handler_GetReports_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<WebUIReportPtr> p_reports{};
  Handler_GetReports_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadReports(&p_reports))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Handler::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_reports));
  return true;
}

void Handler_GetReports_ProxyToResponder::Run(
    std::vector<WebUIReportPtr> in_reports) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply attribution_internals::mojom::Handler::GetReports", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reports"), in_reports,
                        "<value of type std::vector<WebUIReportPtr>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_GetReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_GetReports_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->reports)::BaseType>
      reports_fragment(params.message());
  const mojo::internal::ContainerValidateParams reports_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::attribution_internals::mojom::WebUIReportDataView>>(
      in_reports, reports_fragment, &reports_validate_params);
  params->reports.Set(
      reports_fragment.is_null() ? nullptr : reports_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->reports.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null reports in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("GetReports");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Handler_SendReports_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static Handler::SendReportsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Handler_SendReports_ProxyToResponder> proxy(
        new Handler_SendReports_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&Handler_SendReports_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Handler_SendReports_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  Handler_SendReports_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Handler::SendReportsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool Handler_SendReports_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::Handler_SendReports_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Handler_SendReports_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  Handler_SendReports_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Handler::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void Handler_SendReports_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply attribution_internals::mojom::Handler::SendReports");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_SendReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_SendReports_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("SendReports");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Handler_ClearStorage_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static Handler::ClearStorageCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Handler_ClearStorage_ProxyToResponder> proxy(
        new Handler_ClearStorage_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&Handler_ClearStorage_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Handler_ClearStorage_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  Handler_ClearStorage_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Handler::ClearStorageCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool Handler_ClearStorage_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::Handler_ClearStorage_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Handler_ClearStorage_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  Handler_ClearStorage_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Handler::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void Handler_ClearStorage_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply attribution_internals::mojom::Handler::ClearStorage");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_ClearStorage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_ClearStorage_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("ClearStorage");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class Handler_AddObserver_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static Handler::AddObserverCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<Handler_AddObserver_ProxyToResponder> proxy(
        new Handler_AddObserver_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&Handler_AddObserver_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~Handler_AddObserver_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  Handler_AddObserver_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "Handler::AddObserverCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);
};

bool Handler_AddObserver_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::Handler_AddObserver_ResponseParams_Data* params =
      reinterpret_cast<
          internal::Handler_AddObserver_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  Handler_AddObserver_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        Handler::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void Handler_AddObserver_ProxyToResponder::Run(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply attribution_internals::mojom::Handler::AddObserver", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHandler_AddObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::attribution_internals::mojom::internal::Handler_AddObserver_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(Handler::Name_);
  message.set_method_name("AddObserver");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool HandlerStubDispatch::Accept(
    Handler* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kHandler_IsAttributionReportingEnabled_Name: {
      break;
    }
    case internal::kHandler_GetActiveSources_Name: {
      break;
    }
    case internal::kHandler_GetReports_Name: {
      break;
    }
    case internal::kHandler_SendReports_Name: {
      break;
    }
    case internal::kHandler_ClearStorage_Name: {
      break;
    }
    case internal::kHandler_AddObserver_Name: {
      break;
    }
  }
  return false;
}

// static
bool HandlerStubDispatch::AcceptWithResponder(
    Handler* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kHandler_IsAttributionReportingEnabled_Name: {

      internal::Handler_IsAttributionReportingEnabled_Params_Data* params =
          reinterpret_cast<
              internal::Handler_IsAttributionReportingEnabled_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      Handler_IsAttributionReportingEnabled_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Handler::Name_, 0, false);
        return false;
      }
      Handler::IsAttributionReportingEnabledCallback callback =
          Handler_IsAttributionReportingEnabled_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IsAttributionReportingEnabled(std::move(callback));
      return true;
    }
    case internal::kHandler_GetActiveSources_Name: {

      internal::Handler_GetActiveSources_Params_Data* params =
          reinterpret_cast<
              internal::Handler_GetActiveSources_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      Handler_GetActiveSources_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Handler::Name_, 1, false);
        return false;
      }
      Handler::GetActiveSourcesCallback callback =
          Handler_GetActiveSources_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetActiveSources(std::move(callback));
      return true;
    }
    case internal::kHandler_GetReports_Name: {

      internal::Handler_GetReports_Params_Data* params =
          reinterpret_cast<
              internal::Handler_GetReports_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::content::AttributionReport::ReportType p_report_type{};
      Handler_GetReports_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReportType(&p_report_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Handler::Name_, 2, false);
        return false;
      }
      Handler::GetReportsCallback callback =
          Handler_GetReports_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetReports(
std::move(p_report_type), std::move(callback));
      return true;
    }
    case internal::kHandler_SendReports_Name: {

      internal::Handler_SendReports_Params_Data* params =
          reinterpret_cast<
              internal::Handler_SendReports_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<::content::AttributionReport::Id> p_ids{};
      Handler_SendReports_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadIds(&p_ids))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Handler::Name_, 3, false);
        return false;
      }
      Handler::SendReportsCallback callback =
          Handler_SendReports_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendReports(
std::move(p_ids), std::move(callback));
      return true;
    }
    case internal::kHandler_ClearStorage_Name: {

      internal::Handler_ClearStorage_Params_Data* params =
          reinterpret_cast<
              internal::Handler_ClearStorage_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      Handler_ClearStorage_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Handler::Name_, 4, false);
        return false;
      }
      Handler::ClearStorageCallback callback =
          Handler_ClearStorage_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearStorage(std::move(callback));
      return true;
    }
    case internal::kHandler_AddObserver_Name: {

      internal::Handler_AddObserver_Params_Data* params =
          reinterpret_cast<
              internal::Handler_AddObserver_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<Observer> p_observer{};
      Handler_AddObserver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_observer =
            input_data_view.TakeObserver<decltype(p_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            Handler::Name_, 5, false);
        return false;
      }
      Handler::AddObserverCallback callback =
          Handler_AddObserver_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddObserver(
std::move(p_observer), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kHandlerValidationInfo[] = {
    {&internal::Handler_IsAttributionReportingEnabled_Params_Data::Validate,
     &internal::Handler_IsAttributionReportingEnabled_ResponseParams_Data::Validate},
    {&internal::Handler_GetActiveSources_Params_Data::Validate,
     &internal::Handler_GetActiveSources_ResponseParams_Data::Validate},
    {&internal::Handler_GetReports_Params_Data::Validate,
     &internal::Handler_GetReports_ResponseParams_Data::Validate},
    {&internal::Handler_SendReports_Params_Data::Validate,
     &internal::Handler_SendReports_ResponseParams_Data::Validate},
    {&internal::Handler_ClearStorage_Params_Data::Validate,
     &internal::Handler_ClearStorage_ResponseParams_Data::Validate},
    {&internal::Handler_AddObserver_Params_Data::Validate,
     &internal::Handler_AddObserver_ResponseParams_Data::Validate},
};

bool HandlerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::attribution_internals::mojom::Handler::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kHandlerValidationInfo);
}

bool HandlerResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::attribution_internals::mojom::Handler::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kHandlerValidationInfo);
}


}  // namespace mojom
}  // namespace attribution_internals


namespace mojo {


// static
bool StructTraits<::attribution_internals::mojom::EventLevelReportID::DataView, ::attribution_internals::mojom::EventLevelReportIDPtr>::Read(
    ::attribution_internals::mojom::EventLevelReportID::DataView input,
    ::attribution_internals::mojom::EventLevelReportIDPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::EventLevelReportIDPtr result(::attribution_internals::mojom::EventLevelReportID::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::AggregatableAttributionReportID::DataView, ::attribution_internals::mojom::AggregatableAttributionReportIDPtr>::Read(
    ::attribution_internals::mojom::AggregatableAttributionReportID::DataView input,
    ::attribution_internals::mojom::AggregatableAttributionReportIDPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::AggregatableAttributionReportIDPtr result(::attribution_internals::mojom::AggregatableAttributionReportID::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUIReportEventLevelData::DataView, ::attribution_internals::mojom::WebUIReportEventLevelDataPtr>::Read(
    ::attribution_internals::mojom::WebUIReportEventLevelData::DataView input,
    ::attribution_internals::mojom::WebUIReportEventLevelDataPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUIReportEventLevelDataPtr result(::attribution_internals::mojom::WebUIReportEventLevelData::New());
  
      if (success)
        result->priority = input.priority();
      if (success)
        result->attributed_truthfully = input.attributed_truthfully();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::AggregatableHistogramContribution::DataView, ::attribution_internals::mojom::AggregatableHistogramContributionPtr>::Read(
    ::attribution_internals::mojom::AggregatableHistogramContribution::DataView input,
    ::attribution_internals::mojom::AggregatableHistogramContributionPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::AggregatableHistogramContributionPtr result(::attribution_internals::mojom::AggregatableHistogramContribution::New());
  
      if (success && !input.ReadKey(&result->key))
        success = false;
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUIReportAggregatableAttributionData::DataView, ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr>::Read(
    ::attribution_internals::mojom::WebUIReportAggregatableAttributionData::DataView input,
    ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr result(::attribution_internals::mojom::WebUIReportAggregatableAttributionData::New());
  
      if (success && !input.ReadContributions(&result->contributions))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::Empty::DataView, ::attribution_internals::mojom::EmptyPtr>::Read(
    ::attribution_internals::mojom::Empty::DataView input,
    ::attribution_internals::mojom::EmptyPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::EmptyPtr result(::attribution_internals::mojom::Empty::New());
  
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUIReport::DataView, ::attribution_internals::mojom::WebUIReportPtr>::Read(
    ::attribution_internals::mojom::WebUIReport::DataView input,
    ::attribution_internals::mojom::WebUIReportPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUIReportPtr result(::attribution_internals::mojom::WebUIReport::New());
  
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadReportUrl(&result->report_url))
        success = false;
      if (success)
        result->trigger_time = input.trigger_time();
      if (success)
        result->report_time = input.report_time();
      if (success && !input.ReadReportBody(&result->report_body))
        success = false;
      if (success && !input.ReadStatus(&result->status))
        success = false;
      if (success && !input.ReadData(&result->data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::DebugKey::DataView, ::attribution_internals::mojom::DebugKeyPtr>::Read(
    ::attribution_internals::mojom::DebugKey::DataView input,
    ::attribution_internals::mojom::DebugKeyPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::DebugKeyPtr result(::attribution_internals::mojom::DebugKey::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUISource::DataView, ::attribution_internals::mojom::WebUISourcePtr>::Read(
    ::attribution_internals::mojom::WebUISource::DataView input,
    ::attribution_internals::mojom::WebUISourcePtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUISourcePtr result(::attribution_internals::mojom::WebUISource::New());
  
      if (success)
        result->source_event_id = input.source_event_id();
      if (success && !input.ReadSourceOrigin(&result->source_origin))
        success = false;
      if (success && !input.ReadAttributionDestination(&result->attribution_destination))
        success = false;
      if (success && !input.ReadReportingOrigin(&result->reporting_origin))
        success = false;
      if (success)
        result->source_time = input.source_time();
      if (success)
        result->expiry_time = input.expiry_time();
      if (success && !input.ReadSourceType(&result->source_type))
        success = false;
      if (success)
        result->priority = input.priority();
      if (success && !input.ReadDebugKey(&result->debug_key))
        success = false;
      if (success && !input.ReadDedupKeys(&result->dedup_keys))
        success = false;
      if (success && !input.ReadFilterData(&result->filter_data))
        success = false;
      if (success && !input.ReadAggregationKeys(&result->aggregation_keys))
        success = false;
      if (success && !input.ReadAttributability(&result->attributability))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::DedupKey::DataView, ::attribution_internals::mojom::DedupKeyPtr>::Read(
    ::attribution_internals::mojom::DedupKey::DataView input,
    ::attribution_internals::mojom::DedupKeyPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::DedupKeyPtr result(::attribution_internals::mojom::DedupKey::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUIEventTriggerData::DataView, ::attribution_internals::mojom::WebUIEventTriggerDataPtr>::Read(
    ::attribution_internals::mojom::WebUIEventTriggerData::DataView input,
    ::attribution_internals::mojom::WebUIEventTriggerDataPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUIEventTriggerDataPtr result(::attribution_internals::mojom::WebUIEventTriggerData::New());
  
      if (success)
        result->data = input.data();
      if (success)
        result->priority = input.priority();
      if (success && !input.ReadDedupKey(&result->dedup_key))
        success = false;
      if (success && !input.ReadFilters(&result->filters))
        success = false;
      if (success && !input.ReadNotFilters(&result->not_filters))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUIAggregatableTriggerData::DataView, ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr>::Read(
    ::attribution_internals::mojom::WebUIAggregatableTriggerData::DataView input,
    ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr result(::attribution_internals::mojom::WebUIAggregatableTriggerData::New());
  
      if (success && !input.ReadKeyPiece(&result->key_piece))
        success = false;
      if (success && !input.ReadSourceKeys(&result->source_keys))
        success = false;
      if (success && !input.ReadFilters(&result->filters))
        success = false;
      if (success && !input.ReadNotFilters(&result->not_filters))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::attribution_internals::mojom::WebUITrigger::DataView, ::attribution_internals::mojom::WebUITriggerPtr>::Read(
    ::attribution_internals::mojom::WebUITrigger::DataView input,
    ::attribution_internals::mojom::WebUITriggerPtr* output) {
  bool success = true;
  ::attribution_internals::mojom::WebUITriggerPtr result(::attribution_internals::mojom::WebUITrigger::New());
  
      if (success)
        result->trigger_time = input.trigger_time();
      if (success && !input.ReadDestinationOrigin(&result->destination_origin))
        success = false;
      if (success && !input.ReadReportingOrigin(&result->reporting_origin))
        success = false;
      if (success && !input.ReadFilters(&result->filters))
        success = false;
      if (success && !input.ReadNotFilters(&result->not_filters))
        success = false;
      if (success && !input.ReadDebugKey(&result->debug_key))
        success = false;
      if (success && !input.ReadEventTriggers(&result->event_triggers))
        success = false;
      if (success && !input.ReadAggregatableTriggers(&result->aggregatable_triggers))
        success = false;
      if (success && !input.ReadAggregatableValues(&result->aggregatable_values))
        success = false;
      if (success && !input.ReadEventLevelStatus(&result->event_level_status))
        success = false;
      if (success && !input.ReadAggregatableStatus(&result->aggregatable_status))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::attribution_internals::mojom::ReportID::DataView, ::attribution_internals::mojom::ReportIDPtr>::Read(
    ::attribution_internals::mojom::ReportID::DataView input,
    ::attribution_internals::mojom::ReportIDPtr* output) {
  using UnionType = ::attribution_internals::mojom::ReportID;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kEventLevelId: {
      ::content::AttributionReport::EventLevelData::Id result_event_level_id;
      if (!input.ReadEventLevelId(&result_event_level_id))
        return false;

      *output = UnionType::NewEventLevelId(
          std::move(result_event_level_id));
      break;
    }
    case Tag::kAggregatableAttributionId: {
      ::content::AttributionReport::AggregatableAttributionData::Id result_aggregatable_attribution_id;
      if (!input.ReadAggregatableAttributionId(&result_aggregatable_attribution_id))
        return false;

      *output = UnionType::NewAggregatableAttributionId(
          std::move(result_aggregatable_attribution_id));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::attribution_internals::mojom::WebUIReportData::DataView, ::attribution_internals::mojom::WebUIReportDataPtr>::Read(
    ::attribution_internals::mojom::WebUIReportData::DataView input,
    ::attribution_internals::mojom::WebUIReportDataPtr* output) {
  using UnionType = ::attribution_internals::mojom::WebUIReportData;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kEventLevelData: {
      ::attribution_internals::mojom::WebUIReportEventLevelDataPtr result_event_level_data;
      if (!input.ReadEventLevelData(&result_event_level_data))
        return false;

      *output = UnionType::NewEventLevelData(
          std::move(result_event_level_data));
      break;
    }
    case Tag::kAggregatableAttributionData: {
      ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr result_aggregatable_attribution_data;
      if (!input.ReadAggregatableAttributionData(&result_aggregatable_attribution_data))
        return false;

      *output = UnionType::NewAggregatableAttributionData(
          std::move(result_aggregatable_attribution_data));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::attribution_internals::mojom::ReportStatus::DataView, ::attribution_internals::mojom::ReportStatusPtr>::Read(
    ::attribution_internals::mojom::ReportStatus::DataView input,
    ::attribution_internals::mojom::ReportStatusPtr* output) {
  using UnionType = ::attribution_internals::mojom::ReportStatus;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kPending: {
      ::attribution_internals::mojom::EmptyPtr result_pending;
      if (!input.ReadPending(&result_pending))
        return false;

      *output = UnionType::NewPending(
          std::move(result_pending));
      break;
    }
    case Tag::kReplacedByHigherPriorityReport: {
      std::string result_replaced_by_higher_priority_report;
      if (!input.ReadReplacedByHigherPriorityReport(&result_replaced_by_higher_priority_report))
        return false;

      *output = UnionType::NewReplacedByHigherPriorityReport(
          std::move(result_replaced_by_higher_priority_report));
      break;
    }
    case Tag::kProhibitedByBrowserPolicy: {
      ::attribution_internals::mojom::EmptyPtr result_prohibited_by_browser_policy;
      if (!input.ReadProhibitedByBrowserPolicy(&result_prohibited_by_browser_policy))
        return false;

      *output = UnionType::NewProhibitedByBrowserPolicy(
          std::move(result_prohibited_by_browser_policy));
      break;
    }
    case Tag::kSent: {
      *output = UnionType::NewSent(input.sent());
      break;
    }
    case Tag::kNetworkError: {
      std::string result_network_error;
      if (!input.ReadNetworkError(&result_network_error))
        return false;

      *output = UnionType::NewNetworkError(
          std::move(result_network_error));
      break;
    }
    case Tag::kFailedToAssemble: {
      ::attribution_internals::mojom::EmptyPtr result_failed_to_assemble;
      if (!input.ReadFailedToAssemble(&result_failed_to_assemble))
        return false;

      *output = UnionType::NewFailedToAssemble(
          std::move(result_failed_to_assemble));
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace attribution_internals {
namespace mojom {


void ObserverInterceptorForTesting::OnSourcesChanged() {
  GetForwardingInterface()->OnSourcesChanged();
}
void ObserverInterceptorForTesting::OnReportsChanged(::content::AttributionReport::ReportType report_type) {
  GetForwardingInterface()->OnReportsChanged(std::move(report_type));
}
void ObserverInterceptorForTesting::OnSourceRejectedOrDeactivated(WebUISourcePtr source) {
  GetForwardingInterface()->OnSourceRejectedOrDeactivated(std::move(source));
}
void ObserverInterceptorForTesting::OnReportSent(WebUIReportPtr report) {
  GetForwardingInterface()->OnReportSent(std::move(report));
}
void ObserverInterceptorForTesting::OnReportDropped(WebUIReportPtr report) {
  GetForwardingInterface()->OnReportDropped(std::move(report));
}
void ObserverInterceptorForTesting::OnTriggerHandled(WebUITriggerPtr trigger) {
  GetForwardingInterface()->OnTriggerHandled(std::move(trigger));
}
ObserverAsyncWaiter::ObserverAsyncWaiter(
    Observer* proxy) : proxy_(proxy) {}

ObserverAsyncWaiter::~ObserverAsyncWaiter() = default;




void HandlerInterceptorForTesting::IsAttributionReportingEnabled(IsAttributionReportingEnabledCallback callback) {
  GetForwardingInterface()->IsAttributionReportingEnabled(std::move(callback));
}
void HandlerInterceptorForTesting::GetActiveSources(GetActiveSourcesCallback callback) {
  GetForwardingInterface()->GetActiveSources(std::move(callback));
}
void HandlerInterceptorForTesting::GetReports(::content::AttributionReport::ReportType report_type, GetReportsCallback callback) {
  GetForwardingInterface()->GetReports(std::move(report_type), std::move(callback));
}
void HandlerInterceptorForTesting::SendReports(const std::vector<::content::AttributionReport::Id>& ids, SendReportsCallback callback) {
  GetForwardingInterface()->SendReports(std::move(ids), std::move(callback));
}
void HandlerInterceptorForTesting::ClearStorage(ClearStorageCallback callback) {
  GetForwardingInterface()->ClearStorage(std::move(callback));
}
void HandlerInterceptorForTesting::AddObserver(::mojo::PendingRemote<Observer> observer, AddObserverCallback callback) {
  GetForwardingInterface()->AddObserver(std::move(observer), std::move(callback));
}
HandlerAsyncWaiter::HandlerAsyncWaiter(
    Handler* proxy) : proxy_(proxy) {}

HandlerAsyncWaiter::~HandlerAsyncWaiter() = default;

void HandlerAsyncWaiter::IsAttributionReportingEnabled(
    bool* out_enabled, bool* out_debug_mode) {
  base::RunLoop loop;
  proxy_->IsAttributionReportingEnabled(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_enabled
,
             bool* out_debug_mode
,
             bool enabled,
             bool debug_mode) {*out_enabled = std::move(enabled);*out_debug_mode = std::move(debug_mode);
            loop->Quit();
          },
          &loop,
          out_enabled,
          out_debug_mode));
  loop.Run();
}
void HandlerAsyncWaiter::GetActiveSources(
    std::vector<WebUISourcePtr>* out_sources) {
  base::RunLoop loop;
  proxy_->GetActiveSources(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<WebUISourcePtr>* out_sources
,
             std::vector<WebUISourcePtr> sources) {*out_sources = std::move(sources);
            loop->Quit();
          },
          &loop,
          out_sources));
  loop.Run();
}
void HandlerAsyncWaiter::GetReports(
    ::content::AttributionReport::ReportType report_type, std::vector<WebUIReportPtr>* out_reports) {
  base::RunLoop loop;
  proxy_->GetReports(std::move(report_type),
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<WebUIReportPtr>* out_reports
,
             std::vector<WebUIReportPtr> reports) {*out_reports = std::move(reports);
            loop->Quit();
          },
          &loop,
          out_reports));
  loop.Run();
}
void HandlerAsyncWaiter::SendReports(
    const std::vector<::content::AttributionReport::Id>& ids) {
  base::RunLoop loop;
  proxy_->SendReports(std::move(ids),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void HandlerAsyncWaiter::ClearStorage(
    ) {
  base::RunLoop loop;
  proxy_->ClearStorage(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void HandlerAsyncWaiter::AddObserver(
    ::mojo::PendingRemote<Observer> observer, bool* out_success) {
  base::RunLoop loop;
  proxy_->AddObserver(std::move(observer),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}





}  // namespace mojom
}  // namespace attribution_internals


#if defined(__clang__)
#pragma clang diagnostic pop
#endif