// content/browser/attribution_reporting/attribution_internals.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_SHARED_H_
#define CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "content/browser/attribution_reporting/attribution_internals.mojom-shared-internal.h"
#include "url/mojom/origin.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace attribution_internals {
namespace mojom {
class EventLevelReportIDDataView;

class AggregatableAttributionReportIDDataView;

class WebUIReportEventLevelDataDataView;

class AggregatableHistogramContributionDataView;

class WebUIReportAggregatableAttributionDataDataView;

class EmptyDataView;

class WebUIReportDataView;

class DebugKeyDataView;

class WebUISourceDataView;

class DedupKeyDataView;

class WebUIEventTriggerDataDataView;

class WebUIAggregatableTriggerDataDataView;

class WebUITriggerDataView;

class ReportIDDataView;
class WebUIReportDataDataView;
class ReportStatusDataView;


}  // namespace mojom
}  // namespace attribution_internals

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::attribution_internals::mojom::EventLevelReportIDDataView> {
  using Data = ::attribution_internals::mojom::internal::EventLevelReportID_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::AggregatableAttributionReportIDDataView> {
  using Data = ::attribution_internals::mojom::internal::AggregatableAttributionReportID_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUIReportEventLevelDataDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUIReportEventLevelData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::AggregatableHistogramContributionDataView> {
  using Data = ::attribution_internals::mojom::internal::AggregatableHistogramContribution_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUIReportAggregatableAttributionDataDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUIReportAggregatableAttributionData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::EmptyDataView> {
  using Data = ::attribution_internals::mojom::internal::Empty_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUIReportDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUIReport_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::DebugKeyDataView> {
  using Data = ::attribution_internals::mojom::internal::DebugKey_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUISourceDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUISource_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::DedupKeyDataView> {
  using Data = ::attribution_internals::mojom::internal::DedupKey_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUIEventTriggerDataDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUIEventTriggerData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUIAggregatableTriggerDataDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUIAggregatableTriggerData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUITriggerDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUITrigger_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::ReportIDDataView> {
  using Data = ::attribution_internals::mojom::internal::ReportID_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::WebUIReportDataDataView> {
  using Data = ::attribution_internals::mojom::internal::WebUIReportData_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::attribution_internals::mojom::ReportStatusDataView> {
  using Data = ::attribution_internals::mojom::internal::ReportStatus_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace attribution_internals {
namespace mojom {


enum class SourceType : int32_t {
  
  kNavigation = 0,
  
  kEvent = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, SourceType value);
inline bool IsKnownEnumValue(SourceType value) {
  return internal::SourceType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ReportType : int32_t {
  
  kEventLevel = 0,
  
  kAggregatableAttribution = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, ReportType value);
inline bool IsKnownEnumValue(ReportType value) {
  return internal::ReportType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class WebUISource_Attributability : int32_t {
  
  kAttributable = 0,
  
  kNoised = 1,
  
  kReplacedByNewerSource = 2,
  
  kReachedEventLevelAttributionLimit = 3,
  
  kInternalError = 4,
  
  kInsufficientSourceCapacity = 5,
  
  kInsufficientUniqueDestinationCapacity = 6,
  
  kExcessiveReportingOrigins = 7,
  
  kProhibitedByBrowserPolicy = 8,
  kMinValue = 0,
  kMaxValue = 8,
};

 std::ostream& operator<<(std::ostream& os, WebUISource_Attributability value);
inline bool IsKnownEnumValue(WebUISource_Attributability value) {
  return internal::WebUISource_Attributability_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class WebUITrigger_Status : int32_t {
  
  kSuccess = 0,
  
  kInternalError = 1,
  
  kNoMatchingSources = 2,
  
  kNoMatchingSourceFilterData = 3,
  
  kNoReportCapacityForDestinationSite = 4,
  
  kExcessiveAttributions = 5,
  
  kExcessiveReportingOrigins = 6,
  
  kProhibitedByBrowserPolicy = 7,
  
  kDeduplicated = 8,
  
  kLowPriority = 9,
  
  kNoised = 10,
  
  kNoMatchingConfigurations = 11,
  
  kNoHistograms = 12,
  
  kInsufficientBudget = 13,
  
  kNotRegistered = 14,
  kMinValue = 0,
  kMaxValue = 14,
};

 std::ostream& operator<<(std::ostream& os, WebUITrigger_Status value);
inline bool IsKnownEnumValue(WebUITrigger_Status value) {
  return internal::WebUITrigger_Status_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class ObserverInterfaceBase {};

using ObserverPtrDataView =
    mojo::InterfacePtrDataView<ObserverInterfaceBase>;
using ObserverRequestDataView =
    mojo::InterfaceRequestDataView<ObserverInterfaceBase>;
using ObserverAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<ObserverInterfaceBase>;
using ObserverAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<ObserverInterfaceBase>;
class HandlerInterfaceBase {};

using HandlerPtrDataView =
    mojo::InterfacePtrDataView<HandlerInterfaceBase>;
using HandlerRequestDataView =
    mojo::InterfaceRequestDataView<HandlerInterfaceBase>;
using HandlerAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<HandlerInterfaceBase>;
using HandlerAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<HandlerInterfaceBase>;


class EventLevelReportIDDataView {
 public:
  EventLevelReportIDDataView() = default;

  EventLevelReportIDDataView(
      internal::EventLevelReportID_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int64_t value() const {
    return data_->value;
  }
 private:
  internal::EventLevelReportID_Data* data_ = nullptr;
};



class AggregatableAttributionReportIDDataView {
 public:
  AggregatableAttributionReportIDDataView() = default;

  AggregatableAttributionReportIDDataView(
      internal::AggregatableAttributionReportID_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int64_t value() const {
    return data_->value;
  }
 private:
  internal::AggregatableAttributionReportID_Data* data_ = nullptr;
};



class WebUIReportEventLevelDataDataView {
 public:
  WebUIReportEventLevelDataDataView() = default;

  WebUIReportEventLevelDataDataView(
      internal::WebUIReportEventLevelData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int64_t priority() const {
    return data_->priority;
  }
  bool attributed_truthfully() const {
    return data_->attributed_truthfully;
  }
 private:
  internal::WebUIReportEventLevelData_Data* data_ = nullptr;
};



class AggregatableHistogramContributionDataView {
 public:
  AggregatableHistogramContributionDataView() = default;

  AggregatableHistogramContributionDataView(
      internal::AggregatableHistogramContribution_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetKeyDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKey(UserType* output) {
    
    auto* pointer = data_->key.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  uint32_t value() const {
    return data_->value;
  }
 private:
  internal::AggregatableHistogramContribution_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class WebUIReportAggregatableAttributionDataDataView {
 public:
  WebUIReportAggregatableAttributionDataDataView() = default;

  WebUIReportAggregatableAttributionDataDataView(
      internal::WebUIReportAggregatableAttributionData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetContributionsDataView(
      mojo::ArrayDataView<AggregatableHistogramContributionDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadContributions(UserType* output) {
    
    auto* pointer = data_->contributions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::attribution_internals::mojom::AggregatableHistogramContributionDataView>>(
        pointer, output, message_);
  }
 private:
  internal::WebUIReportAggregatableAttributionData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EmptyDataView {
 public:
  EmptyDataView() = default;

  EmptyDataView(
      internal::Empty_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
 private:
  internal::Empty_Data* data_ = nullptr;
};



class WebUIReportDataView {
 public:
  WebUIReportDataView() = default;

  WebUIReportDataView(
      internal::WebUIReport_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIdDataView(
      ReportIDDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = !data_->id.is_null() ? &data_->id : nullptr;
    return mojo::internal::Deserialize<::attribution_internals::mojom::ReportIDDataView>(
        pointer, output, message_);
  }
  inline void GetReportUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReportUrl(UserType* output) {
    
    auto* pointer = data_->report_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  double trigger_time() const {
    return data_->trigger_time;
  }
  double report_time() const {
    return data_->report_time;
  }
  inline void GetReportBodyDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReportBody(UserType* output) {
    
    auto* pointer = data_->report_body.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetStatusDataView(
      ReportStatusDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStatus(UserType* output) {
    
    auto* pointer = !data_->status.is_null() ? &data_->status : nullptr;
    return mojo::internal::Deserialize<::attribution_internals::mojom::ReportStatusDataView>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      WebUIReportDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
    auto* pointer = !data_->data.is_null() ? &data_->data : nullptr;
    return mojo::internal::Deserialize<::attribution_internals::mojom::WebUIReportDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::WebUIReport_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DebugKeyDataView {
 public:
  DebugKeyDataView() = default;

  DebugKeyDataView(
      internal::DebugKey_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t value() const {
    return data_->value;
  }
 private:
  internal::DebugKey_Data* data_ = nullptr;
};



class WebUISourceDataView {
 public:
  WebUISourceDataView() = default;

  WebUISourceDataView(
      internal::WebUISource_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t source_event_id() const {
    return data_->source_event_id;
  }
  inline void GetSourceOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSourceOrigin(UserType* output) {
    
    auto* pointer = data_->source_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetAttributionDestinationDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAttributionDestination(UserType* output) {
    
    auto* pointer = data_->attribution_destination.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetReportingOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReportingOrigin(UserType* output) {
    
    auto* pointer = data_->reporting_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  double source_time() const {
    return data_->source_time;
  }
  double expiry_time() const {
    return data_->expiry_time;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSourceType(UserType* output) const {
    auto data_value = data_->source_type;
    return mojo::internal::Deserialize<::attribution_internals::mojom::SourceType>(
        data_value, output);
  }
  SourceType source_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::attribution_internals::mojom::SourceType>(data_->source_type));
  }
  int64_t priority() const {
    return data_->priority;
  }
  inline void GetDebugKeyDataView(
      DebugKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDebugKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::attribution_internals::mojom::DebugKeyDataView, UserType>(),
    "Attempting to read the optional `debug_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDebugKey` instead "
    "of `ReadDebugKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->debug_key.Get();
    return mojo::internal::Deserialize<::attribution_internals::mojom::DebugKeyDataView>(
        pointer, output, message_);
  }
  inline void GetDedupKeysDataView(
      mojo::ArrayDataView<uint64_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDedupKeys(UserType* output) {
    
    auto* pointer = data_->dedup_keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint64_t>>(
        pointer, output, message_);
  }
  inline void GetFilterDataDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilterData(UserType* output) {
    
    auto* pointer = data_->filter_data.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
  inline void GetAggregationKeysDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregationKeys(UserType* output) {
    
    auto* pointer = data_->aggregation_keys.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAttributability(UserType* output) const {
    auto data_value = data_->attributability;
    return mojo::internal::Deserialize<::attribution_internals::mojom::WebUISource_Attributability>(
        data_value, output);
  }
  WebUISource_Attributability attributability() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::attribution_internals::mojom::WebUISource_Attributability>(data_->attributability));
  }
 private:
  internal::WebUISource_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DedupKeyDataView {
 public:
  DedupKeyDataView() = default;

  DedupKeyDataView(
      internal::DedupKey_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t value() const {
    return data_->value;
  }
 private:
  internal::DedupKey_Data* data_ = nullptr;
};



class WebUIEventTriggerDataDataView {
 public:
  WebUIEventTriggerDataDataView() = default;

  WebUIEventTriggerDataDataView(
      internal::WebUIEventTriggerData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t data() const {
    return data_->data;
  }
  int64_t priority() const {
    return data_->priority;
  }
  inline void GetDedupKeyDataView(
      DedupKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDedupKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::attribution_internals::mojom::DedupKeyDataView, UserType>(),
    "Attempting to read the optional `dedup_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDedupKey` instead "
    "of `ReadDedupKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->dedup_key.Get();
    return mojo::internal::Deserialize<::attribution_internals::mojom::DedupKeyDataView>(
        pointer, output, message_);
  }
  inline void GetFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilters(UserType* output) {
    
    auto* pointer = data_->filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
  inline void GetNotFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNotFilters(UserType* output) {
    
    auto* pointer = data_->not_filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
 private:
  internal::WebUIEventTriggerData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class WebUIAggregatableTriggerDataDataView {
 public:
  WebUIAggregatableTriggerDataDataView() = default;

  WebUIAggregatableTriggerDataDataView(
      internal::WebUIAggregatableTriggerData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetKeyPieceDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyPiece(UserType* output) {
    
    auto* pointer = data_->key_piece.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetSourceKeysDataView(
      mojo::ArrayDataView<mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSourceKeys(UserType* output) {
    
    auto* pointer = data_->source_keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilters(UserType* output) {
    
    auto* pointer = data_->filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
  inline void GetNotFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNotFilters(UserType* output) {
    
    auto* pointer = data_->not_filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
 private:
  internal::WebUIAggregatableTriggerData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class WebUITriggerDataView {
 public:
  WebUITriggerDataView() = default;

  WebUITriggerDataView(
      internal::WebUITrigger_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  double trigger_time() const {
    return data_->trigger_time;
  }
  inline void GetDestinationOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDestinationOrigin(UserType* output) {
    
    auto* pointer = data_->destination_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetReportingOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReportingOrigin(UserType* output) {
    
    auto* pointer = data_->reporting_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilters(UserType* output) {
    
    auto* pointer = data_->filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
  inline void GetNotFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNotFilters(UserType* output) {
    
    auto* pointer = data_->not_filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
  inline void GetDebugKeyDataView(
      DebugKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDebugKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::attribution_internals::mojom::DebugKeyDataView, UserType>(),
    "Attempting to read the optional `debug_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDebugKey` instead "
    "of `ReadDebugKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->debug_key.Get();
    return mojo::internal::Deserialize<::attribution_internals::mojom::DebugKeyDataView>(
        pointer, output, message_);
  }
  inline void GetEventTriggersDataView(
      mojo::ArrayDataView<WebUIEventTriggerDataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadEventTriggers(UserType* output) {
    
    auto* pointer = data_->event_triggers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::attribution_internals::mojom::WebUIEventTriggerDataDataView>>(
        pointer, output, message_);
  }
  inline void GetAggregatableTriggersDataView(
      mojo::ArrayDataView<WebUIAggregatableTriggerDataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableTriggers(UserType* output) {
    
    auto* pointer = data_->aggregatable_triggers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::attribution_internals::mojom::WebUIAggregatableTriggerDataDataView>>(
        pointer, output, message_);
  }
  inline void GetAggregatableValuesDataView(
      mojo::MapDataView<mojo::StringDataView, uint32_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableValues(UserType* output) {
    
    auto* pointer = data_->aggregatable_values.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, uint32_t>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEventLevelStatus(UserType* output) const {
    auto data_value = data_->event_level_status;
    return mojo::internal::Deserialize<::attribution_internals::mojom::WebUITrigger_Status>(
        data_value, output);
  }
  WebUITrigger_Status event_level_status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::attribution_internals::mojom::WebUITrigger_Status>(data_->event_level_status));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableStatus(UserType* output) const {
    auto data_value = data_->aggregatable_status;
    return mojo::internal::Deserialize<::attribution_internals::mojom::WebUITrigger_Status>(
        data_value, output);
  }
  WebUITrigger_Status aggregatable_status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::attribution_internals::mojom::WebUITrigger_Status>(data_->aggregatable_status));
  }
 private:
  internal::WebUITrigger_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ReportIDDataView {
 public:
  using Tag = internal::ReportID_Data::ReportID_Tag;

  ReportIDDataView() = default;

  ReportIDDataView(
      internal::ReportID_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_event_level_id() const { return data_->tag == Tag::kEventLevelId; }
  inline void GetEventLevelIdDataView(
      EventLevelReportIDDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadEventLevelId(UserType* output) const {
    
    CHECK(is_event_level_id());
    return mojo::internal::Deserialize<::attribution_internals::mojom::EventLevelReportIDDataView>(
        data_->data.f_event_level_id.Get(), output, message_);
  }
  bool is_aggregatable_attribution_id() const { return data_->tag == Tag::kAggregatableAttributionId; }
  inline void GetAggregatableAttributionIdDataView(
      AggregatableAttributionReportIDDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableAttributionId(UserType* output) const {
    
    CHECK(is_aggregatable_attribution_id());
    return mojo::internal::Deserialize<::attribution_internals::mojom::AggregatableAttributionReportIDDataView>(
        data_->data.f_aggregatable_attribution_id.Get(), output, message_);
  }

 private:
  internal::ReportID_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class WebUIReportDataDataView {
 public:
  using Tag = internal::WebUIReportData_Data::WebUIReportData_Tag;

  WebUIReportDataDataView() = default;

  WebUIReportDataDataView(
      internal::WebUIReportData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_event_level_data() const { return data_->tag == Tag::kEventLevelData; }
  inline void GetEventLevelDataDataView(
      WebUIReportEventLevelDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadEventLevelData(UserType* output) const {
    
    CHECK(is_event_level_data());
    return mojo::internal::Deserialize<::attribution_internals::mojom::WebUIReportEventLevelDataDataView>(
        data_->data.f_event_level_data.Get(), output, message_);
  }
  bool is_aggregatable_attribution_data() const { return data_->tag == Tag::kAggregatableAttributionData; }
  inline void GetAggregatableAttributionDataDataView(
      WebUIReportAggregatableAttributionDataDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableAttributionData(UserType* output) const {
    
    CHECK(is_aggregatable_attribution_data());
    return mojo::internal::Deserialize<::attribution_internals::mojom::WebUIReportAggregatableAttributionDataDataView>(
        data_->data.f_aggregatable_attribution_data.Get(), output, message_);
  }

 private:
  internal::WebUIReportData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ReportStatusDataView {
 public:
  using Tag = internal::ReportStatus_Data::ReportStatus_Tag;

  ReportStatusDataView() = default;

  ReportStatusDataView(
      internal::ReportStatus_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_pending() const { return data_->tag == Tag::kPending; }
  inline void GetPendingDataView(
      EmptyDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadPending(UserType* output) const {
    
    CHECK(is_pending());
    return mojo::internal::Deserialize<::attribution_internals::mojom::EmptyDataView>(
        data_->data.f_pending.Get(), output, message_);
  }
  bool is_replaced_by_higher_priority_report() const { return data_->tag == Tag::kReplacedByHigherPriorityReport; }
  inline void GetReplacedByHigherPriorityReportDataView(
      mojo::StringDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadReplacedByHigherPriorityReport(UserType* output) const {
    
    CHECK(is_replaced_by_higher_priority_report());
    return mojo::internal::Deserialize<mojo::StringDataView>(
        data_->data.f_replaced_by_higher_priority_report.Get(), output, message_);
  }
  bool is_prohibited_by_browser_policy() const { return data_->tag == Tag::kProhibitedByBrowserPolicy; }
  inline void GetProhibitedByBrowserPolicyDataView(
      EmptyDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadProhibitedByBrowserPolicy(UserType* output) const {
    
    CHECK(is_prohibited_by_browser_policy());
    return mojo::internal::Deserialize<::attribution_internals::mojom::EmptyDataView>(
        data_->data.f_prohibited_by_browser_policy.Get(), output, message_);
  }
  bool is_sent() const { return data_->tag == Tag::kSent; }
  int32_t sent() const {
    CHECK(is_sent());
    return data_->data.f_sent;
  }
  bool is_network_error() const { return data_->tag == Tag::kNetworkError; }
  inline void GetNetworkErrorDataView(
      mojo::StringDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadNetworkError(UserType* output) const {
    
    CHECK(is_network_error());
    return mojo::internal::Deserialize<mojo::StringDataView>(
        data_->data.f_network_error.Get(), output, message_);
  }
  bool is_failed_to_assemble() const { return data_->tag == Tag::kFailedToAssemble; }
  inline void GetFailedToAssembleDataView(
      EmptyDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadFailedToAssemble(UserType* output) const {
    
    CHECK(is_failed_to_assemble());
    return mojo::internal::Deserialize<::attribution_internals::mojom::EmptyDataView>(
        data_->data.f_failed_to_assemble.Get(), output, message_);
  }

 private:
  internal::ReportStatus_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace attribution_internals

namespace std {

template <>
struct hash<::attribution_internals::mojom::SourceType>
    : public mojo::internal::EnumHashImpl<::attribution_internals::mojom::SourceType> {};

template <>
struct hash<::attribution_internals::mojom::ReportType>
    : public mojo::internal::EnumHashImpl<::attribution_internals::mojom::ReportType> {};

template <>
struct hash<::attribution_internals::mojom::WebUISource_Attributability>
    : public mojo::internal::EnumHashImpl<::attribution_internals::mojom::WebUISource_Attributability> {};

template <>
struct hash<::attribution_internals::mojom::WebUITrigger_Status>
    : public mojo::internal::EnumHashImpl<::attribution_internals::mojom::WebUITrigger_Status> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::SourceType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::attribution_internals::mojom::SourceType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::attribution_internals::mojom::SourceType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::ReportType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::attribution_internals::mojom::ReportType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::attribution_internals::mojom::ReportType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUISource_Attributability, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::attribution_internals::mojom::WebUISource_Attributability, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::attribution_internals::mojom::WebUISource_Attributability>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUITrigger_Status, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::attribution_internals::mojom::WebUITrigger_Status, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::attribution_internals::mojom::WebUITrigger_Status>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::EventLevelReportIDDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::EventLevelReportIDDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::EventLevelReportID_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::EventLevelReportID_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::EventLevelReportIDDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::AggregatableAttributionReportIDDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::AggregatableAttributionReportIDDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::AggregatableAttributionReportID_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::AggregatableAttributionReportID_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::AggregatableAttributionReportIDDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUIReportEventLevelDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUIReportEventLevelDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUIReportEventLevelData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->priority = Traits::priority(input);
    fragment->attributed_truthfully = Traits::attributed_truthfully(input);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUIReportEventLevelData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUIReportEventLevelDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::AggregatableHistogramContributionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::AggregatableHistogramContributionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::AggregatableHistogramContribution_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::key(input)) in_key = Traits::key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key)::BaseType> key_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_key, key_fragment);
    fragment->key.Set(
        key_fragment.is_null() ? nullptr : key_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key in AggregatableHistogramContribution struct");
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::AggregatableHistogramContribution_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::AggregatableHistogramContributionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUIReportAggregatableAttributionDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUIReportAggregatableAttributionDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUIReportAggregatableAttributionData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::contributions(input)) in_contributions = Traits::contributions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->contributions)::BaseType>
        contributions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams contributions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::attribution_internals::mojom::AggregatableHistogramContributionDataView>>(
        in_contributions, contributions_fragment, &contributions_validate_params);
    fragment->contributions.Set(
        contributions_fragment.is_null() ? nullptr : contributions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->contributions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null contributions in WebUIReportAggregatableAttributionData struct");
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUIReportAggregatableAttributionData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::EmptyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::EmptyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::Empty_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
  }

  static bool Deserialize(::attribution_internals::mojom::internal::Empty_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::EmptyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUIReportDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUIReportDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUIReport_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<decltype(fragment->id)>
        id_fragment(fragment.message());
    id_fragment.Claim(&fragment->id);
    mojo::internal::Serialize<::attribution_internals::mojom::ReportIDDataView>(
        in_id, id_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in WebUIReport struct");
    decltype(Traits::report_url(input)) in_report_url = Traits::report_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->report_url)::BaseType> report_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_report_url, report_url_fragment);
    fragment->report_url.Set(
        report_url_fragment.is_null() ? nullptr : report_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->report_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null report_url in WebUIReport struct");
    fragment->trigger_time = Traits::trigger_time(input);
    fragment->report_time = Traits::report_time(input);
    decltype(Traits::report_body(input)) in_report_body = Traits::report_body(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->report_body)::BaseType> report_body_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_report_body, report_body_fragment);
    fragment->report_body.Set(
        report_body_fragment.is_null() ? nullptr : report_body_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->report_body.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null report_body in WebUIReport struct");
    decltype(Traits::status(input)) in_status = Traits::status(input);
    mojo::internal::MessageFragment<decltype(fragment->status)>
        status_fragment(fragment.message());
    status_fragment.Claim(&fragment->status);
    mojo::internal::Serialize<::attribution_internals::mojom::ReportStatusDataView>(
        in_status, status_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->status.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null status in WebUIReport struct");
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<decltype(fragment->data)>
        data_fragment(fragment.message());
    data_fragment.Claim(&fragment->data);
    mojo::internal::Serialize<::attribution_internals::mojom::WebUIReportDataDataView>(
        in_data, data_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null data in WebUIReport struct");
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUIReport_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUIReportDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::DebugKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::DebugKeyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::DebugKey_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::DebugKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::DebugKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUISourceDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUISourceDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUISource_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->source_event_id = Traits::source_event_id(input);
    decltype(Traits::source_origin(input)) in_source_origin = Traits::source_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->source_origin)::BaseType> source_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_source_origin, source_origin_fragment);
    fragment->source_origin.Set(
        source_origin_fragment.is_null() ? nullptr : source_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->source_origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null source_origin in WebUISource struct");
    decltype(Traits::attribution_destination(input)) in_attribution_destination = Traits::attribution_destination(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->attribution_destination)::BaseType> attribution_destination_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_attribution_destination, attribution_destination_fragment);
    fragment->attribution_destination.Set(
        attribution_destination_fragment.is_null() ? nullptr : attribution_destination_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->attribution_destination.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null attribution_destination in WebUISource struct");
    decltype(Traits::reporting_origin(input)) in_reporting_origin = Traits::reporting_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->reporting_origin)::BaseType> reporting_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_reporting_origin, reporting_origin_fragment);
    fragment->reporting_origin.Set(
        reporting_origin_fragment.is_null() ? nullptr : reporting_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->reporting_origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null reporting_origin in WebUISource struct");
    fragment->source_time = Traits::source_time(input);
    fragment->expiry_time = Traits::expiry_time(input);
    mojo::internal::Serialize<::attribution_internals::mojom::SourceType>(
        Traits::source_type(input), &fragment->source_type);
    fragment->priority = Traits::priority(input);
    decltype(Traits::debug_key(input)) in_debug_key = Traits::debug_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->debug_key)::BaseType> debug_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::attribution_internals::mojom::DebugKeyDataView>(
        in_debug_key, debug_key_fragment);
    fragment->debug_key.Set(
        debug_key_fragment.is_null() ? nullptr : debug_key_fragment.data());
    decltype(Traits::dedup_keys(input)) in_dedup_keys = Traits::dedup_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->dedup_keys)::BaseType>
        dedup_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams dedup_keys_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint64_t>>(
        in_dedup_keys, dedup_keys_fragment, &dedup_keys_validate_params);
    fragment->dedup_keys.Set(
        dedup_keys_fragment.is_null() ? nullptr : dedup_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->dedup_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null dedup_keys in WebUISource struct");
    decltype(Traits::filter_data(input)) in_filter_data = Traits::filter_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filter_data)::BaseType>
        filter_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams filter_data_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_filter_data, filter_data_fragment, &filter_data_validate_params);
    fragment->filter_data.Set(
        filter_data_fragment.is_null() ? nullptr : filter_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filter_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filter_data in WebUISource struct");
    decltype(Traits::aggregation_keys(input)) in_aggregation_keys = Traits::aggregation_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregation_keys)::BaseType>
        aggregation_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aggregation_keys_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        in_aggregation_keys, aggregation_keys_fragment, &aggregation_keys_validate_params);
    fragment->aggregation_keys.Set(
        aggregation_keys_fragment.is_null() ? nullptr : aggregation_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregation_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregation_keys in WebUISource struct");
    mojo::internal::Serialize<::attribution_internals::mojom::WebUISource_Attributability>(
        Traits::attributability(input), &fragment->attributability);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUISource_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUISourceDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::DedupKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::DedupKeyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::DedupKey_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::DedupKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::DedupKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUIEventTriggerDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUIEventTriggerDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUIEventTriggerData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->data = Traits::data(input);
    fragment->priority = Traits::priority(input);
    decltype(Traits::dedup_key(input)) in_dedup_key = Traits::dedup_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->dedup_key)::BaseType> dedup_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::attribution_internals::mojom::DedupKeyDataView>(
        in_dedup_key, dedup_key_fragment);
    fragment->dedup_key.Set(
        dedup_key_fragment.is_null() ? nullptr : dedup_key_fragment.data());
    decltype(Traits::filters(input)) in_filters = Traits::filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filters)::BaseType>
        filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_filters, filters_fragment, &filters_validate_params);
    fragment->filters.Set(
        filters_fragment.is_null() ? nullptr : filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filters in WebUIEventTriggerData struct");
    decltype(Traits::not_filters(input)) in_not_filters = Traits::not_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->not_filters)::BaseType>
        not_filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams not_filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_not_filters, not_filters_fragment, &not_filters_validate_params);
    fragment->not_filters.Set(
        not_filters_fragment.is_null() ? nullptr : not_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->not_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null not_filters in WebUIEventTriggerData struct");
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUIEventTriggerData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUIEventTriggerDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUIAggregatableTriggerDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUIAggregatableTriggerDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUIAggregatableTriggerData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::key_piece(input)) in_key_piece = Traits::key_piece(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_piece)::BaseType> key_piece_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_key_piece, key_piece_fragment);
    fragment->key_piece.Set(
        key_piece_fragment.is_null() ? nullptr : key_piece_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_piece.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_piece in WebUIAggregatableTriggerData struct");
    decltype(Traits::source_keys(input)) in_source_keys = Traits::source_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->source_keys)::BaseType>
        source_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams source_keys_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
        in_source_keys, source_keys_fragment, &source_keys_validate_params);
    fragment->source_keys.Set(
        source_keys_fragment.is_null() ? nullptr : source_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->source_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null source_keys in WebUIAggregatableTriggerData struct");
    decltype(Traits::filters(input)) in_filters = Traits::filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filters)::BaseType>
        filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_filters, filters_fragment, &filters_validate_params);
    fragment->filters.Set(
        filters_fragment.is_null() ? nullptr : filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filters in WebUIAggregatableTriggerData struct");
    decltype(Traits::not_filters(input)) in_not_filters = Traits::not_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->not_filters)::BaseType>
        not_filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams not_filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_not_filters, not_filters_fragment, &not_filters_validate_params);
    fragment->not_filters.Set(
        not_filters_fragment.is_null() ? nullptr : not_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->not_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null not_filters in WebUIAggregatableTriggerData struct");
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUIAggregatableTriggerData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUIAggregatableTriggerDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUITriggerDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::attribution_internals::mojom::WebUITriggerDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::attribution_internals::mojom::internal::WebUITrigger_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->trigger_time = Traits::trigger_time(input);
    decltype(Traits::destination_origin(input)) in_destination_origin = Traits::destination_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->destination_origin)::BaseType> destination_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_destination_origin, destination_origin_fragment);
    fragment->destination_origin.Set(
        destination_origin_fragment.is_null() ? nullptr : destination_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->destination_origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null destination_origin in WebUITrigger struct");
    decltype(Traits::reporting_origin(input)) in_reporting_origin = Traits::reporting_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->reporting_origin)::BaseType> reporting_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_reporting_origin, reporting_origin_fragment);
    fragment->reporting_origin.Set(
        reporting_origin_fragment.is_null() ? nullptr : reporting_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->reporting_origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null reporting_origin in WebUITrigger struct");
    decltype(Traits::filters(input)) in_filters = Traits::filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filters)::BaseType>
        filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_filters, filters_fragment, &filters_validate_params);
    fragment->filters.Set(
        filters_fragment.is_null() ? nullptr : filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filters in WebUITrigger struct");
    decltype(Traits::not_filters(input)) in_not_filters = Traits::not_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->not_filters)::BaseType>
        not_filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams not_filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_not_filters, not_filters_fragment, &not_filters_validate_params);
    fragment->not_filters.Set(
        not_filters_fragment.is_null() ? nullptr : not_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->not_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null not_filters in WebUITrigger struct");
    decltype(Traits::debug_key(input)) in_debug_key = Traits::debug_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->debug_key)::BaseType> debug_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::attribution_internals::mojom::DebugKeyDataView>(
        in_debug_key, debug_key_fragment);
    fragment->debug_key.Set(
        debug_key_fragment.is_null() ? nullptr : debug_key_fragment.data());
    decltype(Traits::event_triggers(input)) in_event_triggers = Traits::event_triggers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->event_triggers)::BaseType>
        event_triggers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams event_triggers_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::attribution_internals::mojom::WebUIEventTriggerDataDataView>>(
        in_event_triggers, event_triggers_fragment, &event_triggers_validate_params);
    fragment->event_triggers.Set(
        event_triggers_fragment.is_null() ? nullptr : event_triggers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->event_triggers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_triggers in WebUITrigger struct");
    decltype(Traits::aggregatable_triggers(input)) in_aggregatable_triggers = Traits::aggregatable_triggers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregatable_triggers)::BaseType>
        aggregatable_triggers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aggregatable_triggers_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::attribution_internals::mojom::WebUIAggregatableTriggerDataDataView>>(
        in_aggregatable_triggers, aggregatable_triggers_fragment, &aggregatable_triggers_validate_params);
    fragment->aggregatable_triggers.Set(
        aggregatable_triggers_fragment.is_null() ? nullptr : aggregatable_triggers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregatable_triggers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregatable_triggers in WebUITrigger struct");
    decltype(Traits::aggregatable_values(input)) in_aggregatable_values = Traits::aggregatable_values(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregatable_values)::BaseType>
        aggregatable_values_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aggregatable_values_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, uint32_t>>(
        in_aggregatable_values, aggregatable_values_fragment, &aggregatable_values_validate_params);
    fragment->aggregatable_values.Set(
        aggregatable_values_fragment.is_null() ? nullptr : aggregatable_values_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregatable_values.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregatable_values in WebUITrigger struct");
    mojo::internal::Serialize<::attribution_internals::mojom::WebUITrigger_Status>(
        Traits::event_level_status(input), &fragment->event_level_status);
    mojo::internal::Serialize<::attribution_internals::mojom::WebUITrigger_Status>(
        Traits::aggregatable_status(input), &fragment->aggregatable_status);
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUITrigger_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUITriggerDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::ReportIDDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::attribution_internals::mojom::ReportIDDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::attribution_internals::mojom::internal::ReportID_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::attribution_internals::mojom::ReportIDDataView::Tag::kEventLevelId: {
        decltype(Traits::event_level_id(input))
            in_event_level_id = Traits::event_level_id(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_event_level_id)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::EventLevelReportIDDataView>(
            in_event_level_id, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null event_level_id in ReportID union");
        fragment->data.f_event_level_id.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::attribution_internals::mojom::ReportIDDataView::Tag::kAggregatableAttributionId: {
        decltype(Traits::aggregatable_attribution_id(input))
            in_aggregatable_attribution_id = Traits::aggregatable_attribution_id(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_aggregatable_attribution_id)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::AggregatableAttributionReportIDDataView>(
            in_aggregatable_attribution_id, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null aggregatable_attribution_id in ReportID union");
        fragment->data.f_aggregatable_attribution_id.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::attribution_internals::mojom::internal::ReportID_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::ReportIDDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::WebUIReportDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::attribution_internals::mojom::WebUIReportDataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::attribution_internals::mojom::internal::WebUIReportData_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::attribution_internals::mojom::WebUIReportDataDataView::Tag::kEventLevelData: {
        decltype(Traits::event_level_data(input))
            in_event_level_data = Traits::event_level_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_event_level_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::WebUIReportEventLevelDataDataView>(
            in_event_level_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null event_level_data in WebUIReportData union");
        fragment->data.f_event_level_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::attribution_internals::mojom::WebUIReportDataDataView::Tag::kAggregatableAttributionData: {
        decltype(Traits::aggregatable_attribution_data(input))
            in_aggregatable_attribution_data = Traits::aggregatable_attribution_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_aggregatable_attribution_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::WebUIReportAggregatableAttributionDataDataView>(
            in_aggregatable_attribution_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null aggregatable_attribution_data in WebUIReportData union");
        fragment->data.f_aggregatable_attribution_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::attribution_internals::mojom::internal::WebUIReportData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::WebUIReportDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::attribution_internals::mojom::ReportStatusDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::attribution_internals::mojom::ReportStatusDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::attribution_internals::mojom::internal::ReportStatus_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::attribution_internals::mojom::ReportStatusDataView::Tag::kPending: {
        decltype(Traits::pending(input))
            in_pending = Traits::pending(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_pending)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::EmptyDataView>(
            in_pending, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null pending in ReportStatus union");
        fragment->data.f_pending.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::attribution_internals::mojom::ReportStatusDataView::Tag::kReplacedByHigherPriorityReport: {
        decltype(Traits::replaced_by_higher_priority_report(input))
            in_replaced_by_higher_priority_report = Traits::replaced_by_higher_priority_report(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_replaced_by_higher_priority_report)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(
            in_replaced_by_higher_priority_report, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null replaced_by_higher_priority_report in ReportStatus union");
        fragment->data.f_replaced_by_higher_priority_report.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::attribution_internals::mojom::ReportStatusDataView::Tag::kProhibitedByBrowserPolicy: {
        decltype(Traits::prohibited_by_browser_policy(input))
            in_prohibited_by_browser_policy = Traits::prohibited_by_browser_policy(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_prohibited_by_browser_policy)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::EmptyDataView>(
            in_prohibited_by_browser_policy, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null prohibited_by_browser_policy in ReportStatus union");
        fragment->data.f_prohibited_by_browser_policy.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::attribution_internals::mojom::ReportStatusDataView::Tag::kSent: {
        decltype(Traits::sent(input))
            in_sent = Traits::sent(input);
        fragment->data.f_sent = in_sent;
        break;
      }
      case ::attribution_internals::mojom::ReportStatusDataView::Tag::kNetworkError: {
        decltype(Traits::network_error(input))
            in_network_error = Traits::network_error(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_network_error)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(
            in_network_error, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null network_error in ReportStatus union");
        fragment->data.f_network_error.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::attribution_internals::mojom::ReportStatusDataView::Tag::kFailedToAssemble: {
        decltype(Traits::failed_to_assemble(input))
            in_failed_to_assemble = Traits::failed_to_assemble(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_failed_to_assemble)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::attribution_internals::mojom::EmptyDataView>(
            in_failed_to_assemble, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null failed_to_assemble in ReportStatus union");
        fragment->data.f_failed_to_assemble.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::attribution_internals::mojom::internal::ReportStatus_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::attribution_internals::mojom::ReportStatusDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace attribution_internals {
namespace mojom {







inline void AggregatableHistogramContributionDataView::GetKeyDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->key.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void WebUIReportAggregatableAttributionDataDataView::GetContributionsDataView(
    mojo::ArrayDataView<AggregatableHistogramContributionDataView>* output) {
  auto pointer = data_->contributions.Get();
  *output = mojo::ArrayDataView<AggregatableHistogramContributionDataView>(pointer, message_);
}




inline void WebUIReportDataView::GetIdDataView(
    ReportIDDataView* output) {
  auto pointer = &data_->id;
  *output = ReportIDDataView(pointer, message_);
}
inline void WebUIReportDataView::GetReportUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->report_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void WebUIReportDataView::GetReportBodyDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->report_body.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void WebUIReportDataView::GetStatusDataView(
    ReportStatusDataView* output) {
  auto pointer = &data_->status;
  *output = ReportStatusDataView(pointer, message_);
}
inline void WebUIReportDataView::GetDataDataView(
    WebUIReportDataDataView* output) {
  auto pointer = &data_->data;
  *output = WebUIReportDataDataView(pointer, message_);
}




inline void WebUISourceDataView::GetSourceOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->source_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void WebUISourceDataView::GetAttributionDestinationDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->attribution_destination.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void WebUISourceDataView::GetReportingOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->reporting_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void WebUISourceDataView::GetDebugKeyDataView(
    DebugKeyDataView* output) {
  auto pointer = data_->debug_key.Get();
  *output = DebugKeyDataView(pointer, message_);
}
inline void WebUISourceDataView::GetDedupKeysDataView(
    mojo::ArrayDataView<uint64_t>* output) {
  auto pointer = data_->dedup_keys.Get();
  *output = mojo::ArrayDataView<uint64_t>(pointer, message_);
}
inline void WebUISourceDataView::GetFilterDataDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->filter_data.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}
inline void WebUISourceDataView::GetAggregationKeysDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output) {
  auto pointer = data_->aggregation_keys.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>(pointer, message_);
}




inline void WebUIEventTriggerDataDataView::GetDedupKeyDataView(
    DedupKeyDataView* output) {
  auto pointer = data_->dedup_key.Get();
  *output = DedupKeyDataView(pointer, message_);
}
inline void WebUIEventTriggerDataDataView::GetFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}
inline void WebUIEventTriggerDataDataView::GetNotFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->not_filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}


inline void WebUIAggregatableTriggerDataDataView::GetKeyPieceDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->key_piece.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void WebUIAggregatableTriggerDataDataView::GetSourceKeysDataView(
    mojo::ArrayDataView<mojo::StringDataView>* output) {
  auto pointer = data_->source_keys.Get();
  *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void WebUIAggregatableTriggerDataDataView::GetFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}
inline void WebUIAggregatableTriggerDataDataView::GetNotFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->not_filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}


inline void WebUITriggerDataView::GetDestinationOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->destination_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void WebUITriggerDataView::GetReportingOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->reporting_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void WebUITriggerDataView::GetFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}
inline void WebUITriggerDataView::GetNotFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->not_filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}
inline void WebUITriggerDataView::GetDebugKeyDataView(
    DebugKeyDataView* output) {
  auto pointer = data_->debug_key.Get();
  *output = DebugKeyDataView(pointer, message_);
}
inline void WebUITriggerDataView::GetEventTriggersDataView(
    mojo::ArrayDataView<WebUIEventTriggerDataDataView>* output) {
  auto pointer = data_->event_triggers.Get();
  *output = mojo::ArrayDataView<WebUIEventTriggerDataDataView>(pointer, message_);
}
inline void WebUITriggerDataView::GetAggregatableTriggersDataView(
    mojo::ArrayDataView<WebUIAggregatableTriggerDataDataView>* output) {
  auto pointer = data_->aggregatable_triggers.Get();
  *output = mojo::ArrayDataView<WebUIAggregatableTriggerDataDataView>(pointer, message_);
}
inline void WebUITriggerDataView::GetAggregatableValuesDataView(
    mojo::MapDataView<mojo::StringDataView, uint32_t>* output) {
  auto pointer = data_->aggregatable_values.Get();
  *output = mojo::MapDataView<mojo::StringDataView, uint32_t>(pointer, message_);
}


inline void ReportIDDataView::GetEventLevelIdDataView(
    EventLevelReportIDDataView* output) const {
  CHECK(is_event_level_id());
  *output = EventLevelReportIDDataView(data_->data.f_event_level_id.Get(), message_);
}
inline void ReportIDDataView::GetAggregatableAttributionIdDataView(
    AggregatableAttributionReportIDDataView* output) const {
  CHECK(is_aggregatable_attribution_id());
  *output = AggregatableAttributionReportIDDataView(data_->data.f_aggregatable_attribution_id.Get(), message_);
}

inline void WebUIReportDataDataView::GetEventLevelDataDataView(
    WebUIReportEventLevelDataDataView* output) const {
  CHECK(is_event_level_data());
  *output = WebUIReportEventLevelDataDataView(data_->data.f_event_level_data.Get(), message_);
}
inline void WebUIReportDataDataView::GetAggregatableAttributionDataDataView(
    WebUIReportAggregatableAttributionDataDataView* output) const {
  CHECK(is_aggregatable_attribution_data());
  *output = WebUIReportAggregatableAttributionDataDataView(data_->data.f_aggregatable_attribution_data.Get(), message_);
}

inline void ReportStatusDataView::GetPendingDataView(
    EmptyDataView* output) const {
  CHECK(is_pending());
  *output = EmptyDataView(data_->data.f_pending.Get(), message_);
}
inline void ReportStatusDataView::GetReplacedByHigherPriorityReportDataView(
    mojo::StringDataView* output) const {
  CHECK(is_replaced_by_higher_priority_report());
  *output = mojo::StringDataView(data_->data.f_replaced_by_higher_priority_report.Get(), message_);
}
inline void ReportStatusDataView::GetProhibitedByBrowserPolicyDataView(
    EmptyDataView* output) const {
  CHECK(is_prohibited_by_browser_policy());
  *output = EmptyDataView(data_->data.f_prohibited_by_browser_policy.Get(), message_);
}
inline void ReportStatusDataView::GetNetworkErrorDataView(
    mojo::StringDataView* output) const {
  CHECK(is_network_error());
  *output = mojo::StringDataView(data_->data.f_network_error.Get(), message_);
}
inline void ReportStatusDataView::GetFailedToAssembleDataView(
    EmptyDataView* output) const {
  CHECK(is_failed_to_assemble());
  *output = EmptyDataView(data_->data.f_failed_to_assemble.Get(), message_);
}


}  // namespace mojom
}  // namespace attribution_internals

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::attribution_internals::mojom::SourceType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::attribution_internals::mojom::SourceType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::attribution_internals::mojom::ReportType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::attribution_internals::mojom::ReportType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::attribution_internals::mojom::WebUISource_Attributability> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::attribution_internals::mojom::WebUISource_Attributability value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::attribution_internals::mojom::WebUITrigger_Status> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::attribution_internals::mojom::WebUITrigger_Status value);
};

} // namespace perfetto

#endif  // CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_SHARED_H_