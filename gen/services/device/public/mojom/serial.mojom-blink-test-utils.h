// services/device/public/mojom/serial.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_DEVICE_PUBLIC_MOJOM_SERIAL_MOJOM_BLINK_TEST_UTILS_H_
#define SERVICES_DEVICE_PUBLIC_MOJOM_SERIAL_MOJOM_BLINK_TEST_UTILS_H_

#include "services/device/public/mojom/serial.mojom-blink.h"
#include "third_party/blink/public/platform/web_common.h"


namespace device {
namespace mojom {
namespace blink {


class BLINK_PLATFORM_EXPORT SerialPortManagerInterceptorForTesting : public SerialPortManager {
  virtual SerialPortManager* GetForwardingInterface() = 0;
  void SetClient(::mojo::PendingRemote<SerialPortManagerClient> client) override;
  void GetDevices(GetDevicesCallback callback) override;
  void OpenPort(const ::base::UnguessableToken& token, bool use_alternate_path, SerialConnectionOptionsPtr options, ::mojo::PendingRemote<SerialPortClient> client, ::mojo::PendingRemote<SerialPortConnectionWatcher> watcher, OpenPortCallback callback) override;
};
class BLINK_PLATFORM_EXPORT SerialPortManagerAsyncWaiter {
 public:
  explicit SerialPortManagerAsyncWaiter(SerialPortManager* proxy);

  SerialPortManagerAsyncWaiter(const SerialPortManagerAsyncWaiter&) = delete;
  SerialPortManagerAsyncWaiter& operator=(const SerialPortManagerAsyncWaiter&) = delete;

  ~SerialPortManagerAsyncWaiter();
  void GetDevices(
      WTF::Vector<SerialPortInfoPtr>* out_devices);
  void OpenPort(
      const ::base::UnguessableToken& token, bool use_alternate_path, SerialConnectionOptionsPtr options, ::mojo::PendingRemote<SerialPortClient> client, ::mojo::PendingRemote<SerialPortConnectionWatcher> watcher, ::mojo::PendingRemote<SerialPort>* out_port);

 private:
  SerialPortManager* const proxy_;
};


class BLINK_PLATFORM_EXPORT SerialPortManagerClientInterceptorForTesting : public SerialPortManagerClient {
  virtual SerialPortManagerClient* GetForwardingInterface() = 0;
  void OnPortAdded(SerialPortInfoPtr port_info) override;
  void OnPortRemoved(SerialPortInfoPtr port_info) override;
};
class BLINK_PLATFORM_EXPORT SerialPortManagerClientAsyncWaiter {
 public:
  explicit SerialPortManagerClientAsyncWaiter(SerialPortManagerClient* proxy);

  SerialPortManagerClientAsyncWaiter(const SerialPortManagerClientAsyncWaiter&) = delete;
  SerialPortManagerClientAsyncWaiter& operator=(const SerialPortManagerClientAsyncWaiter&) = delete;

  ~SerialPortManagerClientAsyncWaiter();

 private:
  SerialPortManagerClient* const proxy_;
};


class BLINK_PLATFORM_EXPORT SerialPortInterceptorForTesting : public SerialPort {
  virtual SerialPort* GetForwardingInterface() = 0;
  void StartWriting(::mojo::ScopedDataPipeConsumerHandle consumer) override;
  void StartReading(::mojo::ScopedDataPipeProducerHandle producer) override;
  void Flush(SerialPortFlushMode mode, FlushCallback callback) override;
  void Drain(DrainCallback callback) override;
  void GetControlSignals(GetControlSignalsCallback callback) override;
  void SetControlSignals(SerialHostControlSignalsPtr signals, SetControlSignalsCallback callback) override;
  void ConfigurePort(SerialConnectionOptionsPtr options, ConfigurePortCallback callback) override;
  void GetPortInfo(GetPortInfoCallback callback) override;
  void Close(bool flush, CloseCallback callback) override;
};
class BLINK_PLATFORM_EXPORT SerialPortAsyncWaiter {
 public:
  explicit SerialPortAsyncWaiter(SerialPort* proxy);

  SerialPortAsyncWaiter(const SerialPortAsyncWaiter&) = delete;
  SerialPortAsyncWaiter& operator=(const SerialPortAsyncWaiter&) = delete;

  ~SerialPortAsyncWaiter();
  void Flush(
      SerialPortFlushMode mode);
  void Drain(
      );
  void GetControlSignals(
      SerialPortControlSignalsPtr* out_signals);
  void SetControlSignals(
      SerialHostControlSignalsPtr signals, bool* out_success);
  void ConfigurePort(
      SerialConnectionOptionsPtr options, bool* out_success);
  void GetPortInfo(
      SerialConnectionInfoPtr* out_info);
  void Close(
      bool flush);

 private:
  SerialPort* const proxy_;
};


class BLINK_PLATFORM_EXPORT SerialPortClientInterceptorForTesting : public SerialPortClient {
  virtual SerialPortClient* GetForwardingInterface() = 0;
  void OnReadError(SerialReceiveError error) override;
  void OnSendError(SerialSendError error) override;
};
class BLINK_PLATFORM_EXPORT SerialPortClientAsyncWaiter {
 public:
  explicit SerialPortClientAsyncWaiter(SerialPortClient* proxy);

  SerialPortClientAsyncWaiter(const SerialPortClientAsyncWaiter&) = delete;
  SerialPortClientAsyncWaiter& operator=(const SerialPortClientAsyncWaiter&) = delete;

  ~SerialPortClientAsyncWaiter();

 private:
  SerialPortClient* const proxy_;
};


class BLINK_PLATFORM_EXPORT SerialPortConnectionWatcherInterceptorForTesting : public SerialPortConnectionWatcher {
  virtual SerialPortConnectionWatcher* GetForwardingInterface() = 0;
};
class BLINK_PLATFORM_EXPORT SerialPortConnectionWatcherAsyncWaiter {
 public:
  explicit SerialPortConnectionWatcherAsyncWaiter(SerialPortConnectionWatcher* proxy);

  SerialPortConnectionWatcherAsyncWaiter(const SerialPortConnectionWatcherAsyncWaiter&) = delete;
  SerialPortConnectionWatcherAsyncWaiter& operator=(const SerialPortConnectionWatcherAsyncWaiter&) = delete;

  ~SerialPortConnectionWatcherAsyncWaiter();

 private:
  SerialPortConnectionWatcher* const proxy_;
};




}  // namespace blink
}  // namespace mojom
}  // namespace device

#endif  // SERVICES_DEVICE_PUBLIC_MOJOM_SERIAL_MOJOM_BLINK_TEST_UTILS_H_