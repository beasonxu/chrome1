// services/media_session/public/mojom/media_session.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "services/media_session/public/mojom/media_session.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "services/media_session/public/mojom/media_session.mojom-params-data.h"
#include "services/media_session/public/mojom/media_session.mojom-shared-message-ids.h"

#include "services/media_session/public/mojom/media_session.mojom-import-headers.h"
#include "services/media_session/public/mojom/media_session.mojom-test-utils.h"


#ifndef SERVICES_MEDIA_SESSION_PUBLIC_MOJOM_MEDIA_SESSION_MOJOM_JUMBO_H_
#define SERVICES_MEDIA_SESSION_PUBLIC_MOJOM_MEDIA_SESSION_MOJOM_JUMBO_H_
#endif



namespace media_session {
namespace mojom {
MediaImage::MediaImage()
    : src(),
      type(),
      sizes() {}

MediaImage::MediaImage(
    const ::GURL& src_in,
    const ::std::u16string& type_in,
    std::vector<::gfx::Size> sizes_in)
    : src(std::move(src_in)),
      type(std::move(type_in)),
      sizes(std::move(sizes_in)) {}

MediaImage::~MediaImage() = default;

void MediaImage::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "src"), this->src,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "sizes"), this->sizes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::gfx::Size>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaImage::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MediaMetadata::MediaMetadata()
    : title(),
      artist(),
      album(),
      source_title() {}

MediaMetadata::MediaMetadata(
    const ::std::u16string& title_in,
    const ::std::u16string& artist_in,
    const ::std::u16string& album_in,
    const ::std::u16string& source_title_in)
    : title(std::move(title_in)),
      artist(std::move(artist_in)),
      album(std::move(album_in)),
      source_title(std::move(source_title_in)) {}

MediaMetadata::~MediaMetadata() = default;

void MediaMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "title"), this->title,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "artist"), this->artist,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "album"), this->album,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_title"), this->source_title,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MediaImageBitmap::MediaImageBitmap()
    : width(),
      height(),
      pixel_data(),
      color_type() {}

MediaImageBitmap::MediaImageBitmap(
    int32_t width_in,
    int32_t height_in,
    std::vector<uint8_t> pixel_data_in)
    : width(std::move(width_in)),
      height(std::move(height_in)),
      pixel_data(std::move(pixel_data_in)),
      color_type() {}

MediaImageBitmap::MediaImageBitmap(
    int32_t width_in,
    int32_t height_in,
    std::vector<uint8_t> pixel_data_in,
    MediaImageBitmapColorType color_type_in)
    : width(std::move(width_in)),
      height(std::move(height_in)),
      pixel_data(std::move(pixel_data_in)),
      color_type(std::move(color_type_in)) {}

MediaImageBitmap::~MediaImageBitmap() = default;

void MediaImageBitmap::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "width"), this->width,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "height"), this->height,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pixel_data"), this->pixel_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "color_type"), this->color_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MediaImageBitmapColorType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaImageBitmap::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MediaPosition::MediaPosition()
    : playback_rate(),
      duration(),
      position(),
      last_updated_time(),
      end_of_media() {}

MediaPosition::MediaPosition(
    double playback_rate_in,
    ::base::TimeDelta duration_in,
    ::base::TimeDelta position_in,
    ::base::TimeTicks last_updated_time_in)
    : playback_rate(std::move(playback_rate_in)),
      duration(std::move(duration_in)),
      position(std::move(position_in)),
      last_updated_time(std::move(last_updated_time_in)),
      end_of_media() {}

MediaPosition::MediaPosition(
    double playback_rate_in,
    ::base::TimeDelta duration_in,
    ::base::TimeDelta position_in,
    ::base::TimeTicks last_updated_time_in,
    bool end_of_media_in)
    : playback_rate(std::move(playback_rate_in)),
      duration(std::move(duration_in)),
      position(std::move(position_in)),
      last_updated_time(std::move(last_updated_time_in)),
      end_of_media(std::move(end_of_media_in)) {}

MediaPosition::~MediaPosition() = default;

void MediaPosition::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "playback_rate"), this->playback_rate,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "duration"), this->duration,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "position"), this->position,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "last_updated_time"), this->last_updated_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeTicks>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "end_of_media"), this->end_of_media,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaPosition::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MediaSessionInfo::MediaSessionInfo()
    : state(),
      force_duck(),
      playback_state(),
      is_controllable(),
      prefer_stop_for_gain_focus_loss(),
      is_sensitive(),
      picture_in_picture_state(),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(),
      is_controllable(),
      prefer_stop_for_gain_focus_loss(),
      is_sensitive(),
      picture_in_picture_state(),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(),
      prefer_stop_for_gain_focus_loss(),
      is_sensitive(),
      picture_in_picture_state(),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(),
      is_sensitive(),
      picture_in_picture_state(),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(),
      picture_in_picture_state(),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in,
    MediaAudioVideoState deprecated_audio_video_state_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(std::move(deprecated_audio_video_state_in)),
      audio_sink_id(),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in,
    MediaAudioVideoState deprecated_audio_video_state_in,
    const absl::optional<std::string>& audio_sink_id_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(std::move(deprecated_audio_video_state_in)),
      audio_sink_id(std::move(audio_sink_id_in)),
      audio_video_states(),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in,
    MediaAudioVideoState deprecated_audio_video_state_in,
    const absl::optional<std::string>& audio_sink_id_in,
    absl::optional<std::vector<MediaAudioVideoState>> audio_video_states_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(std::move(deprecated_audio_video_state_in)),
      audio_sink_id(std::move(audio_sink_id_in)),
      audio_video_states(std::move(audio_video_states_in)),
      microphone_state(),
      camera_state(),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in,
    MediaAudioVideoState deprecated_audio_video_state_in,
    const absl::optional<std::string>& audio_sink_id_in,
    absl::optional<std::vector<MediaAudioVideoState>> audio_video_states_in,
    MicrophoneState microphone_state_in,
    CameraState camera_state_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(std::move(deprecated_audio_video_state_in)),
      audio_sink_id(std::move(audio_sink_id_in)),
      audio_video_states(std::move(audio_video_states_in)),
      microphone_state(std::move(microphone_state_in)),
      camera_state(std::move(camera_state_in)),
      muted(),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in,
    MediaAudioVideoState deprecated_audio_video_state_in,
    const absl::optional<std::string>& audio_sink_id_in,
    absl::optional<std::vector<MediaAudioVideoState>> audio_video_states_in,
    MicrophoneState microphone_state_in,
    CameraState camera_state_in,
    bool muted_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(std::move(deprecated_audio_video_state_in)),
      audio_sink_id(std::move(audio_sink_id_in)),
      audio_video_states(std::move(audio_video_states_in)),
      microphone_state(std::move(microphone_state_in)),
      camera_state(std::move(camera_state_in)),
      muted(std::move(muted_in)),
      has_presentation() {}

MediaSessionInfo::MediaSessionInfo(
    MediaSessionInfo::SessionState state_in,
    bool force_duck_in,
    MediaPlaybackState playback_state_in,
    bool is_controllable_in,
    bool prefer_stop_for_gain_focus_loss_in,
    bool is_sensitive_in,
    MediaPictureInPictureState picture_in_picture_state_in,
    MediaAudioVideoState deprecated_audio_video_state_in,
    const absl::optional<std::string>& audio_sink_id_in,
    absl::optional<std::vector<MediaAudioVideoState>> audio_video_states_in,
    MicrophoneState microphone_state_in,
    CameraState camera_state_in,
    bool muted_in,
    bool has_presentation_in)
    : state(std::move(state_in)),
      force_duck(std::move(force_duck_in)),
      playback_state(std::move(playback_state_in)),
      is_controllable(std::move(is_controllable_in)),
      prefer_stop_for_gain_focus_loss(std::move(prefer_stop_for_gain_focus_loss_in)),
      is_sensitive(std::move(is_sensitive_in)),
      picture_in_picture_state(std::move(picture_in_picture_state_in)),
      deprecated_audio_video_state(std::move(deprecated_audio_video_state_in)),
      audio_sink_id(std::move(audio_sink_id_in)),
      audio_video_states(std::move(audio_video_states_in)),
      microphone_state(std::move(microphone_state_in)),
      camera_state(std::move(camera_state_in)),
      muted(std::move(muted_in)),
      has_presentation(std::move(has_presentation_in)) {}

MediaSessionInfo::~MediaSessionInfo() = default;

void MediaSessionInfo::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "state"), this->state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MediaSessionInfo::SessionState>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "force_duck"), this->force_duck,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "playback_state"), this->playback_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MediaPlaybackState>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_controllable"), this->is_controllable,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "prefer_stop_for_gain_focus_loss"), this->prefer_stop_for_gain_focus_loss,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_sensitive"), this->is_sensitive,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "picture_in_picture_state"), this->picture_in_picture_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MediaPictureInPictureState>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "deprecated_audio_video_state"), this->deprecated_audio_video_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MediaAudioVideoState>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "audio_sink_id"), this->audio_sink_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "audio_video_states"), this->audio_video_states,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::vector<MediaAudioVideoState>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "microphone_state"), this->microphone_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MicrophoneState>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "camera_state"), this->camera_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CameraState>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "muted"), this->muted,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_presentation"), this->has_presentation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaSessionInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MediaSessionDebugInfo::MediaSessionDebugInfo()
    : name(),
      owner(),
      state() {}

MediaSessionDebugInfo::MediaSessionDebugInfo(
    const std::string& name_in,
    const std::string& owner_in,
    const std::string& state_in)
    : name(std::move(name_in)),
      owner(std::move(owner_in)),
      state(std::move(state_in)) {}

MediaSessionDebugInfo::~MediaSessionDebugInfo() = default;
size_t MediaSessionDebugInfo::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->name);
  seed = mojo::internal::Hash(seed, this->owner);
  seed = mojo::internal::Hash(seed, this->state);
  return seed;
}

void MediaSessionDebugInfo::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "owner"), this->owner,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "state"), this->state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaSessionDebugInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char MediaSessionObserver::Name_[] = "media_session.mojom.MediaSessionObserver";

MediaSessionObserver::IPCStableHashFunction MediaSessionObserver::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kMediaSessionObserver_MediaSessionInfoChanged_Name: {
      return &MediaSessionObserver::MediaSessionInfoChanged_Sym::IPCStableHash;
    }
    case internal::kMediaSessionObserver_MediaSessionMetadataChanged_Name: {
      return &MediaSessionObserver::MediaSessionMetadataChanged_Sym::IPCStableHash;
    }
    case internal::kMediaSessionObserver_MediaSessionActionsChanged_Name: {
      return &MediaSessionObserver::MediaSessionActionsChanged_Sym::IPCStableHash;
    }
    case internal::kMediaSessionObserver_MediaSessionImagesChanged_Name: {
      return &MediaSessionObserver::MediaSessionImagesChanged_Sym::IPCStableHash;
    }
    case internal::kMediaSessionObserver_MediaSessionPositionChanged_Name: {
      return &MediaSessionObserver::MediaSessionPositionChanged_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* MediaSessionObserver::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kMediaSessionObserver_MediaSessionInfoChanged_Name:
            return "Receive media_session::mojom::MediaSessionObserver::MediaSessionInfoChanged";
      case internal::kMediaSessionObserver_MediaSessionMetadataChanged_Name:
            return "Receive media_session::mojom::MediaSessionObserver::MediaSessionMetadataChanged";
      case internal::kMediaSessionObserver_MediaSessionActionsChanged_Name:
            return "Receive media_session::mojom::MediaSessionObserver::MediaSessionActionsChanged";
      case internal::kMediaSessionObserver_MediaSessionImagesChanged_Name:
            return "Receive media_session::mojom::MediaSessionObserver::MediaSessionImagesChanged";
      case internal::kMediaSessionObserver_MediaSessionPositionChanged_Name:
            return "Receive media_session::mojom::MediaSessionObserver::MediaSessionPositionChanged";
    }
  } else {
    switch (message.name()) {
      case internal::kMediaSessionObserver_MediaSessionInfoChanged_Name:
            return "Receive reply media_session::mojom::MediaSessionObserver::MediaSessionInfoChanged";
      case internal::kMediaSessionObserver_MediaSessionMetadataChanged_Name:
            return "Receive reply media_session::mojom::MediaSessionObserver::MediaSessionMetadataChanged";
      case internal::kMediaSessionObserver_MediaSessionActionsChanged_Name:
            return "Receive reply media_session::mojom::MediaSessionObserver::MediaSessionActionsChanged";
      case internal::kMediaSessionObserver_MediaSessionImagesChanged_Name:
            return "Receive reply media_session::mojom::MediaSessionObserver::MediaSessionImagesChanged";
      case internal::kMediaSessionObserver_MediaSessionPositionChanged_Name:
            return "Receive reply media_session::mojom::MediaSessionObserver::MediaSessionPositionChanged";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t MediaSessionObserver::MediaSessionInfoChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSessionObserver::MediaSessionInfoChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSessionObserver::MediaSessionMetadataChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSessionObserver::MediaSessionMetadataChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSessionObserver::MediaSessionActionsChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSessionObserver::MediaSessionActionsChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSessionObserver::MediaSessionImagesChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSessionObserver::MediaSessionImagesChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSessionObserver::MediaSessionPositionChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSessionObserver::MediaSessionPositionChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

MediaSessionObserverProxy::MediaSessionObserverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void MediaSessionObserverProxy::MediaSessionInfoChanged(
    MediaSessionInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSessionObserver::MediaSessionInfoChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type MediaSessionInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSessionObserver_MediaSessionInfoChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSessionObserver_MediaSessionInfoChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaSessionInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in MediaSessionObserver.MediaSessionInfoChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSessionObserver::Name_);
  message.set_method_name("MediaSessionInfoChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionObserverProxy::MediaSessionMetadataChanged(
    const absl::optional<::media_session::MediaMetadata>& in_metadata) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSessionObserver::MediaSessionMetadataChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata"), in_metadata,
                        "<value of type const absl::optional<::media_session::MediaMetadata>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSessionObserver_MediaSessionMetadataChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSessionObserver_MediaSessionMetadataChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->metadata)::BaseType> metadata_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaMetadataDataView>(
      in_metadata, metadata_fragment);
  params->metadata.Set(
      metadata_fragment.is_null() ? nullptr : metadata_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSessionObserver::Name_);
  message.set_method_name("MediaSessionMetadataChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionObserverProxy::MediaSessionActionsChanged(
    const std::vector<MediaSessionAction>& in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSessionObserver::MediaSessionActionsChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("action"), in_action,
                        "<value of type const std::vector<MediaSessionAction>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSessionObserver_MediaSessionActionsChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSessionObserver_MediaSessionActionsChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->action)::BaseType>
      action_fragment(params.message());
  const mojo::internal::ContainerValidateParams action_validate_params(
      0, ::media_session::mojom::internal::MediaSessionAction_Data::Validate);
  mojo::internal::Serialize<mojo::ArrayDataView<::media_session::mojom::MediaSessionAction>>(
      in_action, action_fragment, &action_validate_params);
  params->action.Set(
      action_fragment.is_null() ? nullptr : action_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->action.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null action in MediaSessionObserver.MediaSessionActionsChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSessionObserver::Name_);
  message.set_method_name("MediaSessionActionsChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionObserverProxy::MediaSessionImagesChanged(
    const base::flat_map<MediaSessionImageType, std::vector<::media_session::MediaImage>>& in_images) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSessionObserver::MediaSessionImagesChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("images"), in_images,
                        "<value of type const base::flat_map<MediaSessionImageType, std::vector<::media_session::MediaImage>>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSessionObserver_MediaSessionImagesChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSessionObserver_MediaSessionImagesChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->images)::BaseType>
      images_fragment(params.message());
  const mojo::internal::ContainerValidateParams images_validate_params(
      new mojo::internal::ContainerValidateParams(0, ::media_session::mojom::internal::MediaSessionImageType_Data::Validate), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
  mojo::internal::Serialize<mojo::MapDataView<::media_session::mojom::MediaSessionImageType, mojo::ArrayDataView<::media_session::mojom::MediaImageDataView>>>(
      in_images, images_fragment, &images_validate_params);
  params->images.Set(
      images_fragment.is_null() ? nullptr : images_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->images.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null images in MediaSessionObserver.MediaSessionImagesChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSessionObserver::Name_);
  message.set_method_name("MediaSessionImagesChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionObserverProxy::MediaSessionPositionChanged(
    const absl::optional<::media_session::MediaPosition>& in_position) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSessionObserver::MediaSessionPositionChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("position"), in_position,
                        "<value of type const absl::optional<::media_session::MediaPosition>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSessionObserver_MediaSessionPositionChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSessionObserver_MediaSessionPositionChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->position)::BaseType> position_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaPositionDataView>(
      in_position, position_fragment);
  params->position.Set(
      position_fragment.is_null() ? nullptr : position_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSessionObserver::Name_);
  message.set_method_name("MediaSessionPositionChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool MediaSessionObserverStubDispatch::Accept(
    MediaSessionObserver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kMediaSessionObserver_MediaSessionInfoChanged_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSessionObserver_MediaSessionInfoChanged_Params_Data* params =
          reinterpret_cast<internal::MediaSessionObserver_MediaSessionInfoChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSessionInfoPtr p_info{};
      MediaSessionObserver_MediaSessionInfoChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSessionObserver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaSessionInfoChanged(
std::move(p_info));
      return true;
    }
    case internal::kMediaSessionObserver_MediaSessionMetadataChanged_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSessionObserver_MediaSessionMetadataChanged_Params_Data* params =
          reinterpret_cast<internal::MediaSessionObserver_MediaSessionMetadataChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::media_session::MediaMetadata> p_metadata{};
      MediaSessionObserver_MediaSessionMetadataChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMetadata(&p_metadata))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSessionObserver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaSessionMetadataChanged(
std::move(p_metadata));
      return true;
    }
    case internal::kMediaSessionObserver_MediaSessionActionsChanged_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSessionObserver_MediaSessionActionsChanged_Params_Data* params =
          reinterpret_cast<internal::MediaSessionObserver_MediaSessionActionsChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<MediaSessionAction> p_action{};
      MediaSessionObserver_MediaSessionActionsChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSessionObserver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaSessionActionsChanged(
std::move(p_action));
      return true;
    }
    case internal::kMediaSessionObserver_MediaSessionImagesChanged_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSessionObserver_MediaSessionImagesChanged_Params_Data* params =
          reinterpret_cast<internal::MediaSessionObserver_MediaSessionImagesChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      base::flat_map<MediaSessionImageType, std::vector<::media_session::MediaImage>> p_images{};
      MediaSessionObserver_MediaSessionImagesChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadImages(&p_images))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSessionObserver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaSessionImagesChanged(
std::move(p_images));
      return true;
    }
    case internal::kMediaSessionObserver_MediaSessionPositionChanged_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSessionObserver_MediaSessionPositionChanged_Params_Data* params =
          reinterpret_cast<internal::MediaSessionObserver_MediaSessionPositionChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::media_session::MediaPosition> p_position{};
      MediaSessionObserver_MediaSessionPositionChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPosition(&p_position))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSessionObserver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaSessionPositionChanged(
std::move(p_position));
      return true;
    }
  }
  return false;
}

// static
bool MediaSessionObserverStubDispatch::AcceptWithResponder(
    MediaSessionObserver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kMediaSessionObserver_MediaSessionInfoChanged_Name: {
      break;
    }
    case internal::kMediaSessionObserver_MediaSessionMetadataChanged_Name: {
      break;
    }
    case internal::kMediaSessionObserver_MediaSessionActionsChanged_Name: {
      break;
    }
    case internal::kMediaSessionObserver_MediaSessionImagesChanged_Name: {
      break;
    }
    case internal::kMediaSessionObserver_MediaSessionPositionChanged_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kMediaSessionObserverValidationInfo[] = {
    {&internal::MediaSessionObserver_MediaSessionInfoChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSessionObserver_MediaSessionMetadataChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSessionObserver_MediaSessionActionsChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSessionObserver_MediaSessionImagesChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSessionObserver_MediaSessionPositionChanged_Params_Data::Validate,
     nullptr /* no response */},
};

bool MediaSessionObserverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::media_session::mojom::MediaSessionObserver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kMediaSessionObserverValidationInfo);
}

const char MediaSession::Name_[] = "media_session.mojom.MediaSession";

MediaSession::IPCStableHashFunction MediaSession::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kMediaSession_GetMediaSessionInfo_Name: {
      return &MediaSession::GetMediaSessionInfo_Sym::IPCStableHash;
    }
    case internal::kMediaSession_GetDebugInfo_Name: {
      return &MediaSession::GetDebugInfo_Sym::IPCStableHash;
    }
    case internal::kMediaSession_StartDucking_Name: {
      return &MediaSession::StartDucking_Sym::IPCStableHash;
    }
    case internal::kMediaSession_StopDucking_Name: {
      return &MediaSession::StopDucking_Sym::IPCStableHash;
    }
    case internal::kMediaSession_Suspend_Name: {
      return &MediaSession::Suspend_Sym::IPCStableHash;
    }
    case internal::kMediaSession_Resume_Name: {
      return &MediaSession::Resume_Sym::IPCStableHash;
    }
    case internal::kMediaSession_AddObserver_Name: {
      return &MediaSession::AddObserver_Sym::IPCStableHash;
    }
    case internal::kMediaSession_PreviousTrack_Name: {
      return &MediaSession::PreviousTrack_Sym::IPCStableHash;
    }
    case internal::kMediaSession_NextTrack_Name: {
      return &MediaSession::NextTrack_Sym::IPCStableHash;
    }
    case internal::kMediaSession_Seek_Name: {
      return &MediaSession::Seek_Sym::IPCStableHash;
    }
    case internal::kMediaSession_Stop_Name: {
      return &MediaSession::Stop_Sym::IPCStableHash;
    }
    case internal::kMediaSession_SkipAd_Name: {
      return &MediaSession::SkipAd_Sym::IPCStableHash;
    }
    case internal::kMediaSession_GetMediaImageBitmap_Name: {
      return &MediaSession::GetMediaImageBitmap_Sym::IPCStableHash;
    }
    case internal::kMediaSession_SeekTo_Name: {
      return &MediaSession::SeekTo_Sym::IPCStableHash;
    }
    case internal::kMediaSession_ScrubTo_Name: {
      return &MediaSession::ScrubTo_Sym::IPCStableHash;
    }
    case internal::kMediaSession_EnterPictureInPicture_Name: {
      return &MediaSession::EnterPictureInPicture_Sym::IPCStableHash;
    }
    case internal::kMediaSession_ExitPictureInPicture_Name: {
      return &MediaSession::ExitPictureInPicture_Sym::IPCStableHash;
    }
    case internal::kMediaSession_SetAudioSinkId_Name: {
      return &MediaSession::SetAudioSinkId_Sym::IPCStableHash;
    }
    case internal::kMediaSession_ToggleMicrophone_Name: {
      return &MediaSession::ToggleMicrophone_Sym::IPCStableHash;
    }
    case internal::kMediaSession_ToggleCamera_Name: {
      return &MediaSession::ToggleCamera_Sym::IPCStableHash;
    }
    case internal::kMediaSession_HangUp_Name: {
      return &MediaSession::HangUp_Sym::IPCStableHash;
    }
    case internal::kMediaSession_Raise_Name: {
      return &MediaSession::Raise_Sym::IPCStableHash;
    }
    case internal::kMediaSession_SetMute_Name: {
      return &MediaSession::SetMute_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* MediaSession::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kMediaSession_GetMediaSessionInfo_Name:
            return "Receive media_session::mojom::MediaSession::GetMediaSessionInfo";
      case internal::kMediaSession_GetDebugInfo_Name:
            return "Receive media_session::mojom::MediaSession::GetDebugInfo";
      case internal::kMediaSession_StartDucking_Name:
            return "Receive media_session::mojom::MediaSession::StartDucking";
      case internal::kMediaSession_StopDucking_Name:
            return "Receive media_session::mojom::MediaSession::StopDucking";
      case internal::kMediaSession_Suspend_Name:
            return "Receive media_session::mojom::MediaSession::Suspend";
      case internal::kMediaSession_Resume_Name:
            return "Receive media_session::mojom::MediaSession::Resume";
      case internal::kMediaSession_AddObserver_Name:
            return "Receive media_session::mojom::MediaSession::AddObserver";
      case internal::kMediaSession_PreviousTrack_Name:
            return "Receive media_session::mojom::MediaSession::PreviousTrack";
      case internal::kMediaSession_NextTrack_Name:
            return "Receive media_session::mojom::MediaSession::NextTrack";
      case internal::kMediaSession_Seek_Name:
            return "Receive media_session::mojom::MediaSession::Seek";
      case internal::kMediaSession_Stop_Name:
            return "Receive media_session::mojom::MediaSession::Stop";
      case internal::kMediaSession_SkipAd_Name:
            return "Receive media_session::mojom::MediaSession::SkipAd";
      case internal::kMediaSession_GetMediaImageBitmap_Name:
            return "Receive media_session::mojom::MediaSession::GetMediaImageBitmap";
      case internal::kMediaSession_SeekTo_Name:
            return "Receive media_session::mojom::MediaSession::SeekTo";
      case internal::kMediaSession_ScrubTo_Name:
            return "Receive media_session::mojom::MediaSession::ScrubTo";
      case internal::kMediaSession_EnterPictureInPicture_Name:
            return "Receive media_session::mojom::MediaSession::EnterPictureInPicture";
      case internal::kMediaSession_ExitPictureInPicture_Name:
            return "Receive media_session::mojom::MediaSession::ExitPictureInPicture";
      case internal::kMediaSession_SetAudioSinkId_Name:
            return "Receive media_session::mojom::MediaSession::SetAudioSinkId";
      case internal::kMediaSession_ToggleMicrophone_Name:
            return "Receive media_session::mojom::MediaSession::ToggleMicrophone";
      case internal::kMediaSession_ToggleCamera_Name:
            return "Receive media_session::mojom::MediaSession::ToggleCamera";
      case internal::kMediaSession_HangUp_Name:
            return "Receive media_session::mojom::MediaSession::HangUp";
      case internal::kMediaSession_Raise_Name:
            return "Receive media_session::mojom::MediaSession::Raise";
      case internal::kMediaSession_SetMute_Name:
            return "Receive media_session::mojom::MediaSession::SetMute";
    }
  } else {
    switch (message.name()) {
      case internal::kMediaSession_GetMediaSessionInfo_Name:
            return "Receive reply media_session::mojom::MediaSession::GetMediaSessionInfo";
      case internal::kMediaSession_GetDebugInfo_Name:
            return "Receive reply media_session::mojom::MediaSession::GetDebugInfo";
      case internal::kMediaSession_StartDucking_Name:
            return "Receive reply media_session::mojom::MediaSession::StartDucking";
      case internal::kMediaSession_StopDucking_Name:
            return "Receive reply media_session::mojom::MediaSession::StopDucking";
      case internal::kMediaSession_Suspend_Name:
            return "Receive reply media_session::mojom::MediaSession::Suspend";
      case internal::kMediaSession_Resume_Name:
            return "Receive reply media_session::mojom::MediaSession::Resume";
      case internal::kMediaSession_AddObserver_Name:
            return "Receive reply media_session::mojom::MediaSession::AddObserver";
      case internal::kMediaSession_PreviousTrack_Name:
            return "Receive reply media_session::mojom::MediaSession::PreviousTrack";
      case internal::kMediaSession_NextTrack_Name:
            return "Receive reply media_session::mojom::MediaSession::NextTrack";
      case internal::kMediaSession_Seek_Name:
            return "Receive reply media_session::mojom::MediaSession::Seek";
      case internal::kMediaSession_Stop_Name:
            return "Receive reply media_session::mojom::MediaSession::Stop";
      case internal::kMediaSession_SkipAd_Name:
            return "Receive reply media_session::mojom::MediaSession::SkipAd";
      case internal::kMediaSession_GetMediaImageBitmap_Name:
            return "Receive reply media_session::mojom::MediaSession::GetMediaImageBitmap";
      case internal::kMediaSession_SeekTo_Name:
            return "Receive reply media_session::mojom::MediaSession::SeekTo";
      case internal::kMediaSession_ScrubTo_Name:
            return "Receive reply media_session::mojom::MediaSession::ScrubTo";
      case internal::kMediaSession_EnterPictureInPicture_Name:
            return "Receive reply media_session::mojom::MediaSession::EnterPictureInPicture";
      case internal::kMediaSession_ExitPictureInPicture_Name:
            return "Receive reply media_session::mojom::MediaSession::ExitPictureInPicture";
      case internal::kMediaSession_SetAudioSinkId_Name:
            return "Receive reply media_session::mojom::MediaSession::SetAudioSinkId";
      case internal::kMediaSession_ToggleMicrophone_Name:
            return "Receive reply media_session::mojom::MediaSession::ToggleMicrophone";
      case internal::kMediaSession_ToggleCamera_Name:
            return "Receive reply media_session::mojom::MediaSession::ToggleCamera";
      case internal::kMediaSession_HangUp_Name:
            return "Receive reply media_session::mojom::MediaSession::HangUp";
      case internal::kMediaSession_Raise_Name:
            return "Receive reply media_session::mojom::MediaSession::Raise";
      case internal::kMediaSession_SetMute_Name:
            return "Receive reply media_session::mojom::MediaSession::SetMute";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t MediaSession::GetMediaSessionInfo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::GetMediaSessionInfo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::GetDebugInfo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::GetDebugInfo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::StartDucking_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::StartDucking");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::StopDucking_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::StopDucking");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::Suspend_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::Suspend");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::Resume_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::Resume");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::AddObserver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::AddObserver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::PreviousTrack_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::PreviousTrack");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::NextTrack_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::NextTrack");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::Seek_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::Seek");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::Stop_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::Stop");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::SkipAd_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::SkipAd");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::GetMediaImageBitmap_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::GetMediaImageBitmap");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::SeekTo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::SeekTo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::ScrubTo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::ScrubTo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::EnterPictureInPicture_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::EnterPictureInPicture");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::ExitPictureInPicture_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::ExitPictureInPicture");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::SetAudioSinkId_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::SetAudioSinkId");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::ToggleMicrophone_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::ToggleMicrophone");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::ToggleCamera_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::ToggleCamera");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::HangUp_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::HangUp");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::Raise_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::Raise");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t MediaSession::SetMute_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)media_session::mojom::MediaSession::SetMute");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class MediaSession_GetMediaSessionInfo_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  MediaSession_GetMediaSessionInfo_ForwardToCallback(
      MediaSession::GetMediaSessionInfoCallback callback
      ) : callback_(std::move(callback)) {
  }

  MediaSession_GetMediaSessionInfo_ForwardToCallback(const MediaSession_GetMediaSessionInfo_ForwardToCallback&) = delete;
  MediaSession_GetMediaSessionInfo_ForwardToCallback& operator=(const MediaSession_GetMediaSessionInfo_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  MediaSession::GetMediaSessionInfoCallback callback_;
};

class MediaSession_GetDebugInfo_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  MediaSession_GetDebugInfo_ForwardToCallback(
      MediaSession::GetDebugInfoCallback callback
      ) : callback_(std::move(callback)) {
  }

  MediaSession_GetDebugInfo_ForwardToCallback(const MediaSession_GetDebugInfo_ForwardToCallback&) = delete;
  MediaSession_GetDebugInfo_ForwardToCallback& operator=(const MediaSession_GetDebugInfo_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  MediaSession::GetDebugInfoCallback callback_;
};

class MediaSession_GetMediaImageBitmap_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  MediaSession_GetMediaImageBitmap_ForwardToCallback(
      MediaSession::GetMediaImageBitmapCallback callback
      ) : callback_(std::move(callback)) {
  }

  MediaSession_GetMediaImageBitmap_ForwardToCallback(const MediaSession_GetMediaImageBitmap_ForwardToCallback&) = delete;
  MediaSession_GetMediaImageBitmap_ForwardToCallback& operator=(const MediaSession_GetMediaImageBitmap_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  MediaSession::GetMediaImageBitmapCallback callback_;
};

MediaSessionProxy::MediaSessionProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void MediaSessionProxy::GetMediaSessionInfo(
    GetMediaSessionInfoCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::GetMediaSessionInfo");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_GetMediaSessionInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_GetMediaSessionInfo_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("GetMediaSessionInfo");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new MediaSession_GetMediaSessionInfo_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void MediaSessionProxy::GetDebugInfo(
    GetDebugInfoCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::GetDebugInfo");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_GetDebugInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_GetDebugInfo_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("GetDebugInfo");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new MediaSession_GetDebugInfo_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void MediaSessionProxy::StartDucking(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::StartDucking");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_StartDucking_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_StartDucking_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("StartDucking");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::StopDucking(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::StopDucking");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_StopDucking_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_StopDucking_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("StopDucking");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::Suspend(
    MediaSession::SuspendType in_suspend_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::Suspend", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("suspend_type"), in_suspend_type,
                        "<value of type MediaSession::SuspendType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_Suspend_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_Suspend_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media_session::mojom::MediaSession_SuspendType>(
      in_suspend_type, &params->suspend_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("Suspend");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::Resume(
    MediaSession::SuspendType in_suspend_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::Resume", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("suspend_type"), in_suspend_type,
                        "<value of type MediaSession::SuspendType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_Resume_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_Resume_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media_session::mojom::MediaSession_SuspendType>(
      in_suspend_type, &params->suspend_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("Resume");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::AddObserver(
    ::mojo::PendingRemote<MediaSessionObserver> in_observer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::AddObserver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("observer"), in_observer,
                        "<value of type ::mojo::PendingRemote<MediaSessionObserver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_AddObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_AddObserver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::media_session::mojom::MediaSessionObserverInterfaceBase>>(
      in_observer, &params->observer, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->observer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid observer in MediaSession.AddObserver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("AddObserver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::PreviousTrack(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::PreviousTrack");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_PreviousTrack_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_PreviousTrack_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("PreviousTrack");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::NextTrack(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::NextTrack");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_NextTrack_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_NextTrack_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("NextTrack");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::Seek(
    ::base::TimeDelta in_seek_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::Seek", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("seek_time"), in_seek_time,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_Seek_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_Seek_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->seek_time)::BaseType> seek_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_seek_time, seek_time_fragment);
  params->seek_time.Set(
      seek_time_fragment.is_null() ? nullptr : seek_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->seek_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null seek_time in MediaSession.Seek request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("Seek");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::Stop(
    MediaSession::SuspendType in_suspend_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::Stop", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("suspend_type"), in_suspend_type,
                        "<value of type MediaSession::SuspendType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_Stop_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_Stop_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::media_session::mojom::MediaSession_SuspendType>(
      in_suspend_type, &params->suspend_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("Stop");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::SkipAd(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::SkipAd");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_SkipAd_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_SkipAd_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("SkipAd");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::GetMediaImageBitmap(
    const ::media_session::MediaImage& in_image, int32_t in_minimum_size_px, int32_t in_desired_size_px, GetMediaImageBitmapCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::GetMediaImageBitmap", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("image"), in_image,
                        "<value of type const ::media_session::MediaImage&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("minimum_size_px"), in_minimum_size_px,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("desired_size_px"), in_desired_size_px,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_GetMediaImageBitmap_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_GetMediaImageBitmap_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->image)::BaseType> image_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaImageDataView>(
      in_image, image_fragment);
  params->image.Set(
      image_fragment.is_null() ? nullptr : image_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->image.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null image in MediaSession.GetMediaImageBitmap request");
  params->minimum_size_px = in_minimum_size_px;
  params->desired_size_px = in_desired_size_px;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("GetMediaImageBitmap");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new MediaSession_GetMediaImageBitmap_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void MediaSessionProxy::SeekTo(
    ::base::TimeDelta in_seek_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::SeekTo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("seek_time"), in_seek_time,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_SeekTo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_SeekTo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->seek_time)::BaseType> seek_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_seek_time, seek_time_fragment);
  params->seek_time.Set(
      seek_time_fragment.is_null() ? nullptr : seek_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->seek_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null seek_time in MediaSession.SeekTo request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("SeekTo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::ScrubTo(
    ::base::TimeDelta in_seek_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::ScrubTo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("seek_time"), in_seek_time,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_ScrubTo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_ScrubTo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->seek_time)::BaseType> seek_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_seek_time, seek_time_fragment);
  params->seek_time.Set(
      seek_time_fragment.is_null() ? nullptr : seek_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->seek_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null seek_time in MediaSession.ScrubTo request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("ScrubTo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::EnterPictureInPicture(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::EnterPictureInPicture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_EnterPictureInPicture_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_EnterPictureInPicture_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("EnterPictureInPicture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::ExitPictureInPicture(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::ExitPictureInPicture");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_ExitPictureInPicture_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_ExitPictureInPicture_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("ExitPictureInPicture");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::SetAudioSinkId(
    const absl::optional<std::string>& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::SetAudioSinkId", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("id"), in_id,
                        "<value of type const absl::optional<std::string>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_SetAudioSinkId_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_SetAudioSinkId_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->id)::BaseType> id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, id_fragment);
  params->id.Set(
      id_fragment.is_null() ? nullptr : id_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("SetAudioSinkId");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::ToggleMicrophone(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::ToggleMicrophone");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_ToggleMicrophone_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_ToggleMicrophone_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("ToggleMicrophone");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::ToggleCamera(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::ToggleCamera");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_ToggleCamera_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_ToggleCamera_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("ToggleCamera");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::HangUp(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::HangUp");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_HangUp_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_HangUp_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("HangUp");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::Raise(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send media_session::mojom::MediaSession::Raise");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_Raise_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_Raise_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("Raise");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void MediaSessionProxy::SetMute(
    bool in_mute) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send media_session::mojom::MediaSession::SetMute", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mute"), in_mute,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_SetMute_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_SetMute_Params_Data> params(
          message);
  params.Allocate();
  params->mute = in_mute;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("SetMute");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class MediaSession_GetMediaSessionInfo_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static MediaSession::GetMediaSessionInfoCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<MediaSession_GetMediaSessionInfo_ProxyToResponder> proxy(
        new MediaSession_GetMediaSessionInfo_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&MediaSession_GetMediaSessionInfo_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~MediaSession_GetMediaSessionInfo_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  MediaSession_GetMediaSessionInfo_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "MediaSession::GetMediaSessionInfoCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MediaSessionInfoPtr in_info);
};

bool MediaSession_GetMediaSessionInfo_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::MediaSession_GetMediaSessionInfo_ResponseParams_Data* params =
      reinterpret_cast<
          internal::MediaSession_GetMediaSessionInfo_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MediaSessionInfoPtr p_info{};
  MediaSession_GetMediaSessionInfo_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadInfo(&p_info))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        MediaSession::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_info));
  return true;
}

void MediaSession_GetMediaSessionInfo_ProxyToResponder::Run(
    MediaSessionInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply media_session::mojom::MediaSession::GetMediaSessionInfo", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type MediaSessionInfoPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_GetMediaSessionInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_GetMediaSessionInfo_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaSessionInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("GetMediaSessionInfo");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class MediaSession_GetDebugInfo_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static MediaSession::GetDebugInfoCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<MediaSession_GetDebugInfo_ProxyToResponder> proxy(
        new MediaSession_GetDebugInfo_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&MediaSession_GetDebugInfo_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~MediaSession_GetDebugInfo_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  MediaSession_GetDebugInfo_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "MediaSession::GetDebugInfoCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MediaSessionDebugInfoPtr in_info);
};

bool MediaSession_GetDebugInfo_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::MediaSession_GetDebugInfo_ResponseParams_Data* params =
      reinterpret_cast<
          internal::MediaSession_GetDebugInfo_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MediaSessionDebugInfoPtr p_info{};
  MediaSession_GetDebugInfo_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadInfo(&p_info))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        MediaSession::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_info));
  return true;
}

void MediaSession_GetDebugInfo_ProxyToResponder::Run(
    MediaSessionDebugInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply media_session::mojom::MediaSession::GetDebugInfo", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type MediaSessionDebugInfoPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_GetDebugInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_GetDebugInfo_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaSessionDebugInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("GetDebugInfo");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class MediaSession_GetMediaImageBitmap_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static MediaSession::GetMediaImageBitmapCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<MediaSession_GetMediaImageBitmap_ProxyToResponder> proxy(
        new MediaSession_GetMediaImageBitmap_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&MediaSession_GetMediaImageBitmap_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~MediaSession_GetMediaImageBitmap_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  MediaSession_GetMediaImageBitmap_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "MediaSession::GetMediaImageBitmapCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::SkBitmap& in_image);
};

bool MediaSession_GetMediaImageBitmap_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::MediaSession_GetMediaImageBitmap_ResponseParams_Data* params =
      reinterpret_cast<
          internal::MediaSession_GetMediaImageBitmap_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::SkBitmap p_image{};
  MediaSession_GetMediaImageBitmap_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadImage(&p_image))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        MediaSession::Name_, 12, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_image));
  return true;
}

void MediaSession_GetMediaImageBitmap_ProxyToResponder::Run(
    const ::SkBitmap& in_image) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply media_session::mojom::MediaSession::GetMediaImageBitmap", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("image"), in_image,
                        "<value of type const ::SkBitmap&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kMediaSession_GetMediaImageBitmap_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::media_session::mojom::internal::MediaSession_GetMediaImageBitmap_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->image)::BaseType> image_fragment(
          params.message());
  mojo::internal::Serialize<::media_session::mojom::MediaImageBitmapDataView>(
      in_image, image_fragment);
  params->image.Set(
      image_fragment.is_null() ? nullptr : image_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(MediaSession::Name_);
  message.set_method_name("GetMediaImageBitmap");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool MediaSessionStubDispatch::Accept(
    MediaSession* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kMediaSession_GetMediaSessionInfo_Name: {
      break;
    }
    case internal::kMediaSession_GetDebugInfo_Name: {
      break;
    }
    case internal::kMediaSession_StartDucking_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_StartDucking_Params_Data* params =
          reinterpret_cast<internal::MediaSession_StartDucking_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_StartDucking_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StartDucking();
      return true;
    }
    case internal::kMediaSession_StopDucking_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_StopDucking_Params_Data* params =
          reinterpret_cast<internal::MediaSession_StopDucking_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_StopDucking_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StopDucking();
      return true;
    }
    case internal::kMediaSession_Suspend_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_Suspend_Params_Data* params =
          reinterpret_cast<internal::MediaSession_Suspend_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession::SuspendType p_suspend_type{};
      MediaSession_Suspend_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSuspendType(&p_suspend_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Suspend(
std::move(p_suspend_type));
      return true;
    }
    case internal::kMediaSession_Resume_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_Resume_Params_Data* params =
          reinterpret_cast<internal::MediaSession_Resume_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession::SuspendType p_suspend_type{};
      MediaSession_Resume_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSuspendType(&p_suspend_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Resume(
std::move(p_suspend_type));
      return true;
    }
    case internal::kMediaSession_AddObserver_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_AddObserver_Params_Data* params =
          reinterpret_cast<internal::MediaSession_AddObserver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<MediaSessionObserver> p_observer{};
      MediaSession_AddObserver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_observer =
            input_data_view.TakeObserver<decltype(p_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddObserver(
std::move(p_observer));
      return true;
    }
    case internal::kMediaSession_PreviousTrack_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_PreviousTrack_Params_Data* params =
          reinterpret_cast<internal::MediaSession_PreviousTrack_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_PreviousTrack_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PreviousTrack();
      return true;
    }
    case internal::kMediaSession_NextTrack_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_NextTrack_Params_Data* params =
          reinterpret_cast<internal::MediaSession_NextTrack_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_NextTrack_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->NextTrack();
      return true;
    }
    case internal::kMediaSession_Seek_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_Seek_Params_Data* params =
          reinterpret_cast<internal::MediaSession_Seek_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_seek_time{};
      MediaSession_Seek_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSeekTime(&p_seek_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Seek(
std::move(p_seek_time));
      return true;
    }
    case internal::kMediaSession_Stop_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_Stop_Params_Data* params =
          reinterpret_cast<internal::MediaSession_Stop_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession::SuspendType p_suspend_type{};
      MediaSession_Stop_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSuspendType(&p_suspend_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Stop(
std::move(p_suspend_type));
      return true;
    }
    case internal::kMediaSession_SkipAd_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_SkipAd_Params_Data* params =
          reinterpret_cast<internal::MediaSession_SkipAd_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_SkipAd_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SkipAd();
      return true;
    }
    case internal::kMediaSession_GetMediaImageBitmap_Name: {
      break;
    }
    case internal::kMediaSession_SeekTo_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_SeekTo_Params_Data* params =
          reinterpret_cast<internal::MediaSession_SeekTo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_seek_time{};
      MediaSession_SeekTo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSeekTime(&p_seek_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SeekTo(
std::move(p_seek_time));
      return true;
    }
    case internal::kMediaSession_ScrubTo_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_ScrubTo_Params_Data* params =
          reinterpret_cast<internal::MediaSession_ScrubTo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_seek_time{};
      MediaSession_ScrubTo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSeekTime(&p_seek_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScrubTo(
std::move(p_seek_time));
      return true;
    }
    case internal::kMediaSession_EnterPictureInPicture_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_EnterPictureInPicture_Params_Data* params =
          reinterpret_cast<internal::MediaSession_EnterPictureInPicture_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_EnterPictureInPicture_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnterPictureInPicture();
      return true;
    }
    case internal::kMediaSession_ExitPictureInPicture_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_ExitPictureInPicture_Params_Data* params =
          reinterpret_cast<internal::MediaSession_ExitPictureInPicture_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_ExitPictureInPicture_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExitPictureInPicture();
      return true;
    }
    case internal::kMediaSession_SetAudioSinkId_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_SetAudioSinkId_Params_Data* params =
          reinterpret_cast<internal::MediaSession_SetAudioSinkId_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<std::string> p_id{};
      MediaSession_SetAudioSinkId_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetAudioSinkId(
std::move(p_id));
      return true;
    }
    case internal::kMediaSession_ToggleMicrophone_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_ToggleMicrophone_Params_Data* params =
          reinterpret_cast<internal::MediaSession_ToggleMicrophone_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_ToggleMicrophone_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ToggleMicrophone();
      return true;
    }
    case internal::kMediaSession_ToggleCamera_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_ToggleCamera_Params_Data* params =
          reinterpret_cast<internal::MediaSession_ToggleCamera_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_ToggleCamera_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ToggleCamera();
      return true;
    }
    case internal::kMediaSession_HangUp_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_HangUp_Params_Data* params =
          reinterpret_cast<internal::MediaSession_HangUp_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_HangUp_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HangUp();
      return true;
    }
    case internal::kMediaSession_Raise_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_Raise_Params_Data* params =
          reinterpret_cast<internal::MediaSession_Raise_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      MediaSession_Raise_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Raise();
      return true;
    }
    case internal::kMediaSession_SetMute_Name: {

      DCHECK(message->is_serialized());
      internal::MediaSession_SetMute_Params_Data* params =
          reinterpret_cast<internal::MediaSession_SetMute_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_mute{};
      MediaSession_SetMute_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_mute = input_data_view.mute();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMute(
std::move(p_mute));
      return true;
    }
  }
  return false;
}

// static
bool MediaSessionStubDispatch::AcceptWithResponder(
    MediaSession* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kMediaSession_GetMediaSessionInfo_Name: {

      internal::MediaSession_GetMediaSessionInfo_Params_Data* params =
          reinterpret_cast<
              internal::MediaSession_GetMediaSessionInfo_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      MediaSession_GetMediaSessionInfo_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 0, false);
        return false;
      }
      MediaSession::GetMediaSessionInfoCallback callback =
          MediaSession_GetMediaSessionInfo_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetMediaSessionInfo(std::move(callback));
      return true;
    }
    case internal::kMediaSession_GetDebugInfo_Name: {

      internal::MediaSession_GetDebugInfo_Params_Data* params =
          reinterpret_cast<
              internal::MediaSession_GetDebugInfo_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      MediaSession_GetDebugInfo_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 1, false);
        return false;
      }
      MediaSession::GetDebugInfoCallback callback =
          MediaSession_GetDebugInfo_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDebugInfo(std::move(callback));
      return true;
    }
    case internal::kMediaSession_StartDucking_Name: {
      break;
    }
    case internal::kMediaSession_StopDucking_Name: {
      break;
    }
    case internal::kMediaSession_Suspend_Name: {
      break;
    }
    case internal::kMediaSession_Resume_Name: {
      break;
    }
    case internal::kMediaSession_AddObserver_Name: {
      break;
    }
    case internal::kMediaSession_PreviousTrack_Name: {
      break;
    }
    case internal::kMediaSession_NextTrack_Name: {
      break;
    }
    case internal::kMediaSession_Seek_Name: {
      break;
    }
    case internal::kMediaSession_Stop_Name: {
      break;
    }
    case internal::kMediaSession_SkipAd_Name: {
      break;
    }
    case internal::kMediaSession_GetMediaImageBitmap_Name: {

      internal::MediaSession_GetMediaImageBitmap_Params_Data* params =
          reinterpret_cast<
              internal::MediaSession_GetMediaImageBitmap_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::media_session::MediaImage p_image{};
      int32_t p_minimum_size_px{};
      int32_t p_desired_size_px{};
      MediaSession_GetMediaImageBitmap_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadImage(&p_image))
        success = false;
      if (success)
        p_minimum_size_px = input_data_view.minimum_size_px();
      if (success)
        p_desired_size_px = input_data_view.desired_size_px();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            MediaSession::Name_, 12, false);
        return false;
      }
      MediaSession::GetMediaImageBitmapCallback callback =
          MediaSession_GetMediaImageBitmap_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetMediaImageBitmap(
std::move(p_image), 
std::move(p_minimum_size_px), 
std::move(p_desired_size_px), std::move(callback));
      return true;
    }
    case internal::kMediaSession_SeekTo_Name: {
      break;
    }
    case internal::kMediaSession_ScrubTo_Name: {
      break;
    }
    case internal::kMediaSession_EnterPictureInPicture_Name: {
      break;
    }
    case internal::kMediaSession_ExitPictureInPicture_Name: {
      break;
    }
    case internal::kMediaSession_SetAudioSinkId_Name: {
      break;
    }
    case internal::kMediaSession_ToggleMicrophone_Name: {
      break;
    }
    case internal::kMediaSession_ToggleCamera_Name: {
      break;
    }
    case internal::kMediaSession_HangUp_Name: {
      break;
    }
    case internal::kMediaSession_Raise_Name: {
      break;
    }
    case internal::kMediaSession_SetMute_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kMediaSessionValidationInfo[] = {
    {&internal::MediaSession_GetMediaSessionInfo_Params_Data::Validate,
     &internal::MediaSession_GetMediaSessionInfo_ResponseParams_Data::Validate},
    {&internal::MediaSession_GetDebugInfo_Params_Data::Validate,
     &internal::MediaSession_GetDebugInfo_ResponseParams_Data::Validate},
    {&internal::MediaSession_StartDucking_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_StopDucking_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_Suspend_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_Resume_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_AddObserver_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_PreviousTrack_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_NextTrack_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_Seek_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_Stop_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_SkipAd_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_GetMediaImageBitmap_Params_Data::Validate,
     &internal::MediaSession_GetMediaImageBitmap_ResponseParams_Data::Validate},
    {&internal::MediaSession_SeekTo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_ScrubTo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_EnterPictureInPicture_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_ExitPictureInPicture_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_SetAudioSinkId_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_ToggleMicrophone_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_ToggleCamera_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_HangUp_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_Raise_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::MediaSession_SetMute_Params_Data::Validate,
     nullptr /* no response */},
};

bool MediaSessionRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::media_session::mojom::MediaSession::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kMediaSessionValidationInfo);
}

bool MediaSessionResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::media_session::mojom::MediaSession::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kMediaSessionValidationInfo);
}


}  // namespace mojom
}  // namespace media_session


namespace mojo {


// static
bool StructTraits<::media_session::mojom::MediaImage::DataView, ::media_session::mojom::MediaImagePtr>::Read(
    ::media_session::mojom::MediaImage::DataView input,
    ::media_session::mojom::MediaImagePtr* output) {
  bool success = true;
  ::media_session::mojom::MediaImagePtr result(::media_session::mojom::MediaImage::New());
  
      if (success && !input.ReadSrc(&result->src))
        success = false;
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success && !input.ReadSizes(&result->sizes))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media_session::mojom::MediaMetadata::DataView, ::media_session::mojom::MediaMetadataPtr>::Read(
    ::media_session::mojom::MediaMetadata::DataView input,
    ::media_session::mojom::MediaMetadataPtr* output) {
  bool success = true;
  ::media_session::mojom::MediaMetadataPtr result(::media_session::mojom::MediaMetadata::New());
  
      if (success && !input.ReadTitle(&result->title))
        success = false;
      if (success && !input.ReadArtist(&result->artist))
        success = false;
      if (success && !input.ReadAlbum(&result->album))
        success = false;
      if (success && !input.ReadSourceTitle(&result->source_title))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media_session::mojom::MediaImageBitmap::DataView, ::media_session::mojom::MediaImageBitmapPtr>::Read(
    ::media_session::mojom::MediaImageBitmap::DataView input,
    ::media_session::mojom::MediaImageBitmapPtr* output) {
  bool success = true;
  ::media_session::mojom::MediaImageBitmapPtr result(::media_session::mojom::MediaImageBitmap::New());
  
      if (success)
        result->width = input.width();
      if (success)
        result->height = input.height();
      if (success && !input.ReadPixelData(&result->pixel_data))
        success = false;
      if (success && !input.ReadColorType(&result->color_type))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media_session::mojom::MediaPosition::DataView, ::media_session::mojom::MediaPositionPtr>::Read(
    ::media_session::mojom::MediaPosition::DataView input,
    ::media_session::mojom::MediaPositionPtr* output) {
  bool success = true;
  ::media_session::mojom::MediaPositionPtr result(::media_session::mojom::MediaPosition::New());
  
      if (success)
        result->playback_rate = input.playback_rate();
      if (success && !input.ReadDuration(&result->duration))
        success = false;
      if (success && !input.ReadPosition(&result->position))
        success = false;
      if (success && !input.ReadLastUpdatedTime(&result->last_updated_time))
        success = false;
      if (success)
        result->end_of_media = input.end_of_media();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media_session::mojom::MediaSessionInfo::DataView, ::media_session::mojom::MediaSessionInfoPtr>::Read(
    ::media_session::mojom::MediaSessionInfo::DataView input,
    ::media_session::mojom::MediaSessionInfoPtr* output) {
  bool success = true;
  ::media_session::mojom::MediaSessionInfoPtr result(::media_session::mojom::MediaSessionInfo::New());
  
      if (success && !input.ReadState(&result->state))
        success = false;
      if (success)
        result->force_duck = input.force_duck();
      if (success && !input.ReadPlaybackState(&result->playback_state))
        success = false;
      if (success)
        result->is_controllable = input.is_controllable();
      if (success)
        result->prefer_stop_for_gain_focus_loss = input.prefer_stop_for_gain_focus_loss();
      if (success)
        result->is_sensitive = input.is_sensitive();
      if (success && !input.ReadPictureInPictureState(&result->picture_in_picture_state))
        success = false;
      if (success && !input.ReadDeprecatedAudioVideoState(&result->deprecated_audio_video_state))
        success = false;
      if (success && !input.ReadAudioSinkId(&result->audio_sink_id))
        success = false;
      if (success && !input.ReadAudioVideoStates(&result->audio_video_states))
        success = false;
      if (success && !input.ReadMicrophoneState(&result->microphone_state))
        success = false;
      if (success && !input.ReadCameraState(&result->camera_state))
        success = false;
      if (success)
        result->muted = input.muted();
      if (success)
        result->has_presentation = input.has_presentation();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media_session::mojom::MediaSessionDebugInfo::DataView, ::media_session::mojom::MediaSessionDebugInfoPtr>::Read(
    ::media_session::mojom::MediaSessionDebugInfo::DataView input,
    ::media_session::mojom::MediaSessionDebugInfoPtr* output) {
  bool success = true;
  ::media_session::mojom::MediaSessionDebugInfoPtr result(::media_session::mojom::MediaSessionDebugInfo::New());
  
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadOwner(&result->owner))
        success = false;
      if (success && !input.ReadState(&result->state))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace media_session {
namespace mojom {


void MediaSessionObserverInterceptorForTesting::MediaSessionInfoChanged(MediaSessionInfoPtr info) {
  GetForwardingInterface()->MediaSessionInfoChanged(std::move(info));
}
void MediaSessionObserverInterceptorForTesting::MediaSessionMetadataChanged(const absl::optional<::media_session::MediaMetadata>& metadata) {
  GetForwardingInterface()->MediaSessionMetadataChanged(std::move(metadata));
}
void MediaSessionObserverInterceptorForTesting::MediaSessionActionsChanged(const std::vector<MediaSessionAction>& action) {
  GetForwardingInterface()->MediaSessionActionsChanged(std::move(action));
}
void MediaSessionObserverInterceptorForTesting::MediaSessionImagesChanged(const base::flat_map<MediaSessionImageType, std::vector<::media_session::MediaImage>>& images) {
  GetForwardingInterface()->MediaSessionImagesChanged(std::move(images));
}
void MediaSessionObserverInterceptorForTesting::MediaSessionPositionChanged(const absl::optional<::media_session::MediaPosition>& position) {
  GetForwardingInterface()->MediaSessionPositionChanged(std::move(position));
}
MediaSessionObserverAsyncWaiter::MediaSessionObserverAsyncWaiter(
    MediaSessionObserver* proxy) : proxy_(proxy) {}

MediaSessionObserverAsyncWaiter::~MediaSessionObserverAsyncWaiter() = default;




void MediaSessionInterceptorForTesting::GetMediaSessionInfo(GetMediaSessionInfoCallback callback) {
  GetForwardingInterface()->GetMediaSessionInfo(std::move(callback));
}
void MediaSessionInterceptorForTesting::GetDebugInfo(GetDebugInfoCallback callback) {
  GetForwardingInterface()->GetDebugInfo(std::move(callback));
}
void MediaSessionInterceptorForTesting::StartDucking() {
  GetForwardingInterface()->StartDucking();
}
void MediaSessionInterceptorForTesting::StopDucking() {
  GetForwardingInterface()->StopDucking();
}
void MediaSessionInterceptorForTesting::Suspend(MediaSession::SuspendType suspend_type) {
  GetForwardingInterface()->Suspend(std::move(suspend_type));
}
void MediaSessionInterceptorForTesting::Resume(MediaSession::SuspendType suspend_type) {
  GetForwardingInterface()->Resume(std::move(suspend_type));
}
void MediaSessionInterceptorForTesting::AddObserver(::mojo::PendingRemote<MediaSessionObserver> observer) {
  GetForwardingInterface()->AddObserver(std::move(observer));
}
void MediaSessionInterceptorForTesting::PreviousTrack() {
  GetForwardingInterface()->PreviousTrack();
}
void MediaSessionInterceptorForTesting::NextTrack() {
  GetForwardingInterface()->NextTrack();
}
void MediaSessionInterceptorForTesting::Seek(::base::TimeDelta seek_time) {
  GetForwardingInterface()->Seek(std::move(seek_time));
}
void MediaSessionInterceptorForTesting::Stop(MediaSession::SuspendType suspend_type) {
  GetForwardingInterface()->Stop(std::move(suspend_type));
}
void MediaSessionInterceptorForTesting::SkipAd() {
  GetForwardingInterface()->SkipAd();
}
void MediaSessionInterceptorForTesting::GetMediaImageBitmap(const ::media_session::MediaImage& image, int32_t minimum_size_px, int32_t desired_size_px, GetMediaImageBitmapCallback callback) {
  GetForwardingInterface()->GetMediaImageBitmap(std::move(image), std::move(minimum_size_px), std::move(desired_size_px), std::move(callback));
}
void MediaSessionInterceptorForTesting::SeekTo(::base::TimeDelta seek_time) {
  GetForwardingInterface()->SeekTo(std::move(seek_time));
}
void MediaSessionInterceptorForTesting::ScrubTo(::base::TimeDelta seek_time) {
  GetForwardingInterface()->ScrubTo(std::move(seek_time));
}
void MediaSessionInterceptorForTesting::EnterPictureInPicture() {
  GetForwardingInterface()->EnterPictureInPicture();
}
void MediaSessionInterceptorForTesting::ExitPictureInPicture() {
  GetForwardingInterface()->ExitPictureInPicture();
}
void MediaSessionInterceptorForTesting::SetAudioSinkId(const absl::optional<std::string>& id) {
  GetForwardingInterface()->SetAudioSinkId(std::move(id));
}
void MediaSessionInterceptorForTesting::ToggleMicrophone() {
  GetForwardingInterface()->ToggleMicrophone();
}
void MediaSessionInterceptorForTesting::ToggleCamera() {
  GetForwardingInterface()->ToggleCamera();
}
void MediaSessionInterceptorForTesting::HangUp() {
  GetForwardingInterface()->HangUp();
}
void MediaSessionInterceptorForTesting::Raise() {
  GetForwardingInterface()->Raise();
}
void MediaSessionInterceptorForTesting::SetMute(bool mute) {
  GetForwardingInterface()->SetMute(std::move(mute));
}
MediaSessionAsyncWaiter::MediaSessionAsyncWaiter(
    MediaSession* proxy) : proxy_(proxy) {}

MediaSessionAsyncWaiter::~MediaSessionAsyncWaiter() = default;

void MediaSessionAsyncWaiter::GetMediaSessionInfo(
    MediaSessionInfoPtr* out_info) {
  base::RunLoop loop;
  proxy_->GetMediaSessionInfo(
      base::BindOnce(
          [](base::RunLoop* loop,
             MediaSessionInfoPtr* out_info
,
             MediaSessionInfoPtr info) {*out_info = std::move(info);
            loop->Quit();
          },
          &loop,
          out_info));
  loop.Run();
}
void MediaSessionAsyncWaiter::GetDebugInfo(
    MediaSessionDebugInfoPtr* out_info) {
  base::RunLoop loop;
  proxy_->GetDebugInfo(
      base::BindOnce(
          [](base::RunLoop* loop,
             MediaSessionDebugInfoPtr* out_info
,
             MediaSessionDebugInfoPtr info) {*out_info = std::move(info);
            loop->Quit();
          },
          &loop,
          out_info));
  loop.Run();
}
void MediaSessionAsyncWaiter::GetMediaImageBitmap(
    const ::media_session::MediaImage& image, int32_t minimum_size_px, int32_t desired_size_px, ::SkBitmap* out_image) {
  base::RunLoop loop;
  proxy_->GetMediaImageBitmap(std::move(image),std::move(minimum_size_px),std::move(desired_size_px),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::SkBitmap* out_image
,
             const ::SkBitmap& image) {*out_image = std::move(image);
            loop->Quit();
          },
          &loop,
          out_image));
  loop.Run();
}





}  // namespace mojom
}  // namespace media_session


#if defined(__clang__)
#pragma clang diagnostic pop
#endif