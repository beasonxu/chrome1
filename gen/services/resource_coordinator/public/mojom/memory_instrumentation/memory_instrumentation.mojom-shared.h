// services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_MOJOM_MEMORY_INSTRUMENTATION_MEMORY_INSTRUMENTATION_MOJOM_SHARED_H_
#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_MOJOM_MEMORY_INSTRUMENTATION_MEMORY_INSTRUMENTATION_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom-shared-internal.h"
#include "mojo/public/mojom/base/big_string.mojom-shared.h"
#include "mojo/public/mojom/base/process_id.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace memory_instrumentation {
namespace mojom {
class RequestArgsDataView;

class RawAllocatorDumpEdgeDataView;

class RawAllocatorDumpEntryDataView;

class RawAllocatorDumpDataView;

class RawProcessMemoryDumpDataView;

class VmRegionDataView;

class PlatformPrivateFootprintDataView;

class RawOSMemDumpDataView;

class OSMemDumpDataView;

class AllocatorMemDumpDataView;

class ProcessMemoryDumpDataView;

class AggregatedMetricsDataView;

class GlobalMemoryDumpDataView;

class HeapProfileResultDataView;

class RawAllocatorDumpEntryValueDataView;


}  // namespace mojom
}  // namespace memory_instrumentation

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RequestArgsDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RequestArgs_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RawAllocatorDumpEdgeDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RawAllocatorDumpEdge_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RawAllocatorDumpEntryDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RawAllocatorDumpEntry_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RawAllocatorDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RawAllocatorDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RawProcessMemoryDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RawProcessMemoryDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::VmRegionDataView> {
  using Data = ::memory_instrumentation::mojom::internal::VmRegion_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::PlatformPrivateFootprintDataView> {
  using Data = ::memory_instrumentation::mojom::internal::PlatformPrivateFootprint_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RawOSMemDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RawOSMemDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::OSMemDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::OSMemDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::AllocatorMemDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::AllocatorMemDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::ProcessMemoryDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::ProcessMemoryDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::AggregatedMetricsDataView> {
  using Data = ::memory_instrumentation::mojom::internal::AggregatedMetrics_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::GlobalMemoryDumpDataView> {
  using Data = ::memory_instrumentation::mojom::internal::GlobalMemoryDump_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::HeapProfileResultDataView> {
  using Data = ::memory_instrumentation::mojom::internal::HeapProfileResult_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView> {
  using Data = ::memory_instrumentation::mojom::internal::RawAllocatorDumpEntryValue_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace memory_instrumentation {
namespace mojom {


enum class DumpType : int32_t {
  
  PERIODIC_INTERVAL = 0,
  
  EXPLICITLY_TRIGGERED = 1,
  
  SUMMARY_ONLY = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, DumpType value);
inline bool IsKnownEnumValue(DumpType value) {
  return internal::DumpType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class LevelOfDetail : int32_t {
  
  BACKGROUND = 0,
  
  LIGHT = 1,
  
  DETAILED = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, LevelOfDetail value);
inline bool IsKnownEnumValue(LevelOfDetail value) {
  return internal::LevelOfDetail_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class Determinism : int32_t {
  
  NONE = 0,
  
  FORCE_GC = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, Determinism value);
inline bool IsKnownEnumValue(Determinism value) {
  return internal::Determinism_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ProcessType : int32_t {
  
  OTHER = 0,
  
  BROWSER = 1,
  
  RENDERER = 2,
  
  GPU = 3,
  
  UTILITY = 4,
  
  PLUGIN = 5,
  
  ARC = 6,
  kMinValue = 0,
  kMaxValue = 6,
};

COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, ProcessType value);
inline bool IsKnownEnumValue(ProcessType value) {
  return internal::ProcessType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MemoryMapOption : int32_t {
  
  NONE = 0,
  
  MODULES = 1,
  
  FULL = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, MemoryMapOption value);
inline bool IsKnownEnumValue(MemoryMapOption value) {
  return internal::MemoryMapOption_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class ClientProcessInterfaceBase {};

using ClientProcessPtrDataView =
    mojo::InterfacePtrDataView<ClientProcessInterfaceBase>;
using ClientProcessRequestDataView =
    mojo::InterfaceRequestDataView<ClientProcessInterfaceBase>;
using ClientProcessAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<ClientProcessInterfaceBase>;
using ClientProcessAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<ClientProcessInterfaceBase>;
class HeapProfilerInterfaceBase {};

using HeapProfilerPtrDataView =
    mojo::InterfacePtrDataView<HeapProfilerInterfaceBase>;
using HeapProfilerRequestDataView =
    mojo::InterfaceRequestDataView<HeapProfilerInterfaceBase>;
using HeapProfilerAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<HeapProfilerInterfaceBase>;
using HeapProfilerAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<HeapProfilerInterfaceBase>;
class HeapProfilerHelperInterfaceBase {};

using HeapProfilerHelperPtrDataView =
    mojo::InterfacePtrDataView<HeapProfilerHelperInterfaceBase>;
using HeapProfilerHelperRequestDataView =
    mojo::InterfaceRequestDataView<HeapProfilerHelperInterfaceBase>;
using HeapProfilerHelperAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<HeapProfilerHelperInterfaceBase>;
using HeapProfilerHelperAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<HeapProfilerHelperInterfaceBase>;
class CoordinatorInterfaceBase {};

using CoordinatorPtrDataView =
    mojo::InterfacePtrDataView<CoordinatorInterfaceBase>;
using CoordinatorRequestDataView =
    mojo::InterfaceRequestDataView<CoordinatorInterfaceBase>;
using CoordinatorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<CoordinatorInterfaceBase>;
using CoordinatorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<CoordinatorInterfaceBase>;
class CoordinatorConnectorInterfaceBase {};

using CoordinatorConnectorPtrDataView =
    mojo::InterfacePtrDataView<CoordinatorConnectorInterfaceBase>;
using CoordinatorConnectorRequestDataView =
    mojo::InterfaceRequestDataView<CoordinatorConnectorInterfaceBase>;
using CoordinatorConnectorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<CoordinatorConnectorInterfaceBase>;
using CoordinatorConnectorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<CoordinatorConnectorInterfaceBase>;


class RequestArgsDataView {
 public:
  RequestArgsDataView() = default;

  RequestArgsDataView(
      internal::RequestArgs_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t dump_guid() const {
    return data_->dump_guid;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadDumpType(UserType* output) const {
    auto data_value = data_->dump_type;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::DumpType>(
        data_value, output);
  }
  DumpType dump_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::memory_instrumentation::mojom::DumpType>(data_->dump_type));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadLevelOfDetail(UserType* output) const {
    auto data_value = data_->level_of_detail;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::LevelOfDetail>(
        data_value, output);
  }
  LevelOfDetail level_of_detail() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::memory_instrumentation::mojom::LevelOfDetail>(data_->level_of_detail));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadDeterminism(UserType* output) const {
    auto data_value = data_->determinism;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::Determinism>(
        data_value, output);
  }
  Determinism determinism() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::memory_instrumentation::mojom::Determinism>(data_->determinism));
  }
 private:
  internal::RequestArgs_Data* data_ = nullptr;
};



class RawAllocatorDumpEdgeDataView {
 public:
  RawAllocatorDumpEdgeDataView() = default;

  RawAllocatorDumpEdgeDataView(
      internal::RawAllocatorDumpEdge_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t source_id() const {
    return data_->source_id;
  }
  uint64_t target_id() const {
    return data_->target_id;
  }
  int32_t importance() const {
    return data_->importance;
  }
  bool overridable() const {
    return data_->overridable;
  }
 private:
  internal::RawAllocatorDumpEdge_Data* data_ = nullptr;
};



class RawAllocatorDumpEntryDataView {
 public:
  RawAllocatorDumpEntryDataView() = default;

  RawAllocatorDumpEntryDataView(
      internal::RawAllocatorDumpEntry_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetUnitsDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUnits(UserType* output) {
    
    auto* pointer = data_->units.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetValueDataView(
      RawAllocatorDumpEntryValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
    auto* pointer = !data_->value.is_null() ? &data_->value : nullptr;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView>(
        pointer, output, message_);
  }
 private:
  internal::RawAllocatorDumpEntry_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class RawAllocatorDumpDataView {
 public:
  RawAllocatorDumpDataView() = default;

  RawAllocatorDumpDataView(
      internal::RawAllocatorDump_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t id() const {
    return data_->id;
  }
  inline void GetAbsoluteNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAbsoluteName(UserType* output) {
    
    auto* pointer = data_->absolute_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool weak() const {
    return data_->weak;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadLevelOfDetail(UserType* output) const {
    auto data_value = data_->level_of_detail;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::LevelOfDetail>(
        data_value, output);
  }
  LevelOfDetail level_of_detail() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::memory_instrumentation::mojom::LevelOfDetail>(data_->level_of_detail));
  }
  inline void GetEntriesDataView(
      mojo::ArrayDataView<RawAllocatorDumpEntryDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadEntries(UserType* output) {
    
    auto* pointer = data_->entries.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::memory_instrumentation::mojom::RawAllocatorDumpEntryDataView>>(
        pointer, output, message_);
  }
 private:
  internal::RawAllocatorDump_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class RawProcessMemoryDumpDataView {
 public:
  RawProcessMemoryDumpDataView() = default;

  RawProcessMemoryDumpDataView(
      internal::RawProcessMemoryDump_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadLevelOfDetail(UserType* output) const {
    auto data_value = data_->level_of_detail;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::LevelOfDetail>(
        data_value, output);
  }
  LevelOfDetail level_of_detail() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::memory_instrumentation::mojom::LevelOfDetail>(data_->level_of_detail));
  }
  inline void GetAllocatorDumpEdgesDataView(
      mojo::ArrayDataView<RawAllocatorDumpEdgeDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAllocatorDumpEdges(UserType* output) {
    
    auto* pointer = data_->allocator_dump_edges.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::memory_instrumentation::mojom::RawAllocatorDumpEdgeDataView>>(
        pointer, output, message_);
  }
  inline void GetAllocatorDumpsDataView(
      mojo::ArrayDataView<RawAllocatorDumpDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAllocatorDumps(UserType* output) {
    
    auto* pointer = data_->allocator_dumps.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::memory_instrumentation::mojom::RawAllocatorDumpDataView>>(
        pointer, output, message_);
  }
 private:
  internal::RawProcessMemoryDump_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VmRegionDataView {
 public:
  VmRegionDataView() = default;

  VmRegionDataView(
      internal::VmRegion_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t start_address() const {
    return data_->start_address;
  }
  uint64_t size_in_bytes() const {
    return data_->size_in_bytes;
  }
  uint64_t module_timestamp() const {
    return data_->module_timestamp;
  }
  inline void GetModuleDebugidDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadModuleDebugid(UserType* output) {
    
    auto* pointer = data_->module_debugid.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetModuleDebugPathDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadModuleDebugPath(UserType* output) {
    
    auto* pointer = data_->module_debug_path.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  uint32_t protection_flags() const {
    return data_->protection_flags;
  }
  inline void GetMappedFileDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMappedFile(UserType* output) {
    
    auto* pointer = data_->mapped_file.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  uint64_t byte_stats_private_dirty_resident() const {
    return data_->byte_stats_private_dirty_resident;
  }
  uint64_t byte_stats_private_clean_resident() const {
    return data_->byte_stats_private_clean_resident;
  }
  uint64_t byte_stats_shared_dirty_resident() const {
    return data_->byte_stats_shared_dirty_resident;
  }
  uint64_t byte_stats_shared_clean_resident() const {
    return data_->byte_stats_shared_clean_resident;
  }
  uint64_t byte_stats_swapped() const {
    return data_->byte_stats_swapped;
  }
  uint64_t byte_locked() const {
    return data_->byte_locked;
  }
  uint64_t byte_stats_proportional_resident() const {
    return data_->byte_stats_proportional_resident;
  }
 private:
  internal::VmRegion_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PlatformPrivateFootprintDataView {
 public:
  PlatformPrivateFootprintDataView() = default;

  PlatformPrivateFootprintDataView(
      internal::PlatformPrivateFootprint_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t phys_footprint_bytes() const {
    return data_->phys_footprint_bytes;
  }
  uint64_t internal_bytes() const {
    return data_->internal_bytes;
  }
  uint64_t compressed_bytes() const {
    return data_->compressed_bytes;
  }
  uint64_t rss_anon_bytes() const {
    return data_->rss_anon_bytes;
  }
  uint64_t vm_swap_bytes() const {
    return data_->vm_swap_bytes;
  }
  uint64_t private_bytes() const {
    return data_->private_bytes;
  }
 private:
  internal::PlatformPrivateFootprint_Data* data_ = nullptr;
};



class RawOSMemDumpDataView {
 public:
  RawOSMemDumpDataView() = default;

  RawOSMemDumpDataView(
      internal::RawOSMemDump_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint32_t resident_set_kb() const {
    return data_->resident_set_kb;
  }
  uint32_t peak_resident_set_kb() const {
    return data_->peak_resident_set_kb;
  }
  bool is_peak_rss_resettable() const {
    return data_->is_peak_rss_resettable;
  }
  inline void GetPlatformPrivateFootprintDataView(
      PlatformPrivateFootprintDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPlatformPrivateFootprint(UserType* output) {
    
    auto* pointer = data_->platform_private_footprint.Get();
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::PlatformPrivateFootprintDataView>(
        pointer, output, message_);
  }
  inline void GetMemoryMapsDataView(
      mojo::ArrayDataView<VmRegionDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMemoryMaps(UserType* output) {
    
    auto* pointer = data_->memory_maps.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::memory_instrumentation::mojom::VmRegionDataView>>(
        pointer, output, message_);
  }
  inline void GetNativeLibraryPagesBitmapDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNativeLibraryPagesBitmap(UserType* output) {
    
    auto* pointer = data_->native_library_pages_bitmap.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::RawOSMemDump_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class OSMemDumpDataView {
 public:
  OSMemDumpDataView() = default;

  OSMemDumpDataView(
      internal::OSMemDump_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t resident_set_kb() const {
    return data_->resident_set_kb;
  }
  uint32_t peak_resident_set_kb() const {
    return data_->peak_resident_set_kb;
  }
  bool is_peak_rss_resettable() const {
    return data_->is_peak_rss_resettable;
  }
  uint32_t private_footprint_kb() const {
    return data_->private_footprint_kb;
  }
  uint32_t shared_footprint_kb() const {
    return data_->shared_footprint_kb;
  }
  uint32_t private_footprint_swap_kb() const {
    return data_->private_footprint_swap_kb;
  }
 private:
  internal::OSMemDump_Data* data_ = nullptr;
};



class AllocatorMemDumpDataView {
 public:
  AllocatorMemDumpDataView() = default;

  AllocatorMemDumpDataView(
      internal::AllocatorMemDump_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNumericEntriesDataView(
      mojo::MapDataView<mojo::StringDataView, uint64_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNumericEntries(UserType* output) {
    
    auto* pointer = data_->numeric_entries.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, uint64_t>>(
        pointer, output, message_);
  }
  inline void GetChildrenDataView(
      mojo::MapDataView<mojo::StringDataView, AllocatorMemDumpDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadChildren(UserType* output) {
    
    auto* pointer = data_->children.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, ::memory_instrumentation::mojom::AllocatorMemDumpDataView>>(
        pointer, output, message_);
  }
 private:
  internal::AllocatorMemDump_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ProcessMemoryDumpDataView {
 public:
  ProcessMemoryDumpDataView() = default;

  ProcessMemoryDumpDataView(
      internal::ProcessMemoryDump_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadProcessType(UserType* output) const {
    auto data_value = data_->process_type;
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::ProcessType>(
        data_value, output);
  }
  ProcessType process_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::memory_instrumentation::mojom::ProcessType>(data_->process_type));
  }
  inline void GetOsDumpDataView(
      OSMemDumpDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOsDump(UserType* output) {
    
    auto* pointer = data_->os_dump.Get();
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::OSMemDumpDataView>(
        pointer, output, message_);
  }
  inline void GetChromeAllocatorDumpsDataView(
      mojo::MapDataView<mojo::StringDataView, AllocatorMemDumpDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadChromeAllocatorDumps(UserType* output) {
    
    auto* pointer = data_->chrome_allocator_dumps.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, ::memory_instrumentation::mojom::AllocatorMemDumpDataView>>(
        pointer, output, message_);
  }
  inline void GetPidDataView(
      ::mojo_base::mojom::ProcessIdDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPid(UserType* output) {
    
    auto* pointer = data_->pid.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::ProcessIdDataView>(
        pointer, output, message_);
  }
  inline void GetServiceNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadServiceName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `service_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadServiceName` instead "
    "of `ReadServiceName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->service_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::ProcessMemoryDump_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AggregatedMetricsDataView {
 public:
  AggregatedMetricsDataView() = default;

  AggregatedMetricsDataView(
      internal::AggregatedMetrics_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t native_library_resident_kb() const {
    return data_->native_library_resident_kb;
  }
  int32_t native_library_resident_not_ordered_kb() const {
    return data_->native_library_resident_not_ordered_kb;
  }
  int32_t native_library_not_resident_ordered_kb() const {
    return data_->native_library_not_resident_ordered_kb;
  }
 private:
  internal::AggregatedMetrics_Data* data_ = nullptr;
};



class GlobalMemoryDumpDataView {
 public:
  GlobalMemoryDumpDataView() = default;

  GlobalMemoryDumpDataView(
      internal::GlobalMemoryDump_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetStartTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStartTime(UserType* output) {
    
    auto* pointer = data_->start_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  inline void GetProcessDumpsDataView(
      mojo::ArrayDataView<ProcessMemoryDumpDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadProcessDumps(UserType* output) {
    
    auto* pointer = data_->process_dumps.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::memory_instrumentation::mojom::ProcessMemoryDumpDataView>>(
        pointer, output, message_);
  }
  inline void GetAggregatedMetricsDataView(
      AggregatedMetricsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatedMetrics(UserType* output) {
    
    auto* pointer = data_->aggregated_metrics.Get();
    return mojo::internal::Deserialize<::memory_instrumentation::mojom::AggregatedMetricsDataView>(
        pointer, output, message_);
  }
 private:
  internal::GlobalMemoryDump_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HeapProfileResultDataView {
 public:
  HeapProfileResultDataView() = default;

  HeapProfileResultDataView(
      internal::HeapProfileResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetPidDataView(
      ::mojo_base::mojom::ProcessIdDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPid(UserType* output) {
    
    auto* pointer = data_->pid.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::ProcessIdDataView>(
        pointer, output, message_);
  }
  inline void GetJsonDataView(
      ::mojo_base::mojom::BigStringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadJson(UserType* output) {
    
    auto* pointer = data_->json.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::BigStringDataView>(
        pointer, output, message_);
  }
 private:
  internal::HeapProfileResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class RawAllocatorDumpEntryValueDataView {
 public:
  using Tag = internal::RawAllocatorDumpEntryValue_Data::RawAllocatorDumpEntryValue_Tag;

  RawAllocatorDumpEntryValueDataView() = default;

  RawAllocatorDumpEntryValueDataView(
      internal::RawAllocatorDumpEntryValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_value_uint64() const { return data_->tag == Tag::kValueUint64; }
  uint64_t value_uint64() const {
    CHECK(is_value_uint64());
    return data_->data.f_value_uint64;
  }
  bool is_value_string() const { return data_->tag == Tag::kValueString; }
  inline void GetValueStringDataView(
      mojo::StringDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadValueString(UserType* output) const {
    
    CHECK(is_value_string());
    return mojo::internal::Deserialize<mojo::StringDataView>(
        data_->data.f_value_string.Get(), output, message_);
  }

 private:
  internal::RawAllocatorDumpEntryValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace memory_instrumentation

namespace std {

template <>
struct hash<::memory_instrumentation::mojom::DumpType>
    : public mojo::internal::EnumHashImpl<::memory_instrumentation::mojom::DumpType> {};

template <>
struct hash<::memory_instrumentation::mojom::LevelOfDetail>
    : public mojo::internal::EnumHashImpl<::memory_instrumentation::mojom::LevelOfDetail> {};

template <>
struct hash<::memory_instrumentation::mojom::Determinism>
    : public mojo::internal::EnumHashImpl<::memory_instrumentation::mojom::Determinism> {};

template <>
struct hash<::memory_instrumentation::mojom::ProcessType>
    : public mojo::internal::EnumHashImpl<::memory_instrumentation::mojom::ProcessType> {};

template <>
struct hash<::memory_instrumentation::mojom::MemoryMapOption>
    : public mojo::internal::EnumHashImpl<::memory_instrumentation::mojom::MemoryMapOption> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::DumpType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::memory_instrumentation::mojom::DumpType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::memory_instrumentation::mojom::DumpType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::LevelOfDetail, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::memory_instrumentation::mojom::LevelOfDetail, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::memory_instrumentation::mojom::LevelOfDetail>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::Determinism, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::memory_instrumentation::mojom::Determinism, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::memory_instrumentation::mojom::Determinism>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::ProcessType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::memory_instrumentation::mojom::ProcessType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::memory_instrumentation::mojom::ProcessType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::MemoryMapOption, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::memory_instrumentation::mojom::MemoryMapOption, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::memory_instrumentation::mojom::MemoryMapOption>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RequestArgsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::RequestArgsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::RequestArgs_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->dump_guid = Traits::dump_guid(input);
    mojo::internal::Serialize<::memory_instrumentation::mojom::DumpType>(
        Traits::dump_type(input), &fragment->dump_type);
    mojo::internal::Serialize<::memory_instrumentation::mojom::LevelOfDetail>(
        Traits::level_of_detail(input), &fragment->level_of_detail);
    mojo::internal::Serialize<::memory_instrumentation::mojom::Determinism>(
        Traits::determinism(input), &fragment->determinism);
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RequestArgs_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RequestArgsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RawAllocatorDumpEdgeDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::RawAllocatorDumpEdgeDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::RawAllocatorDumpEdge_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->source_id = Traits::source_id(input);
    fragment->target_id = Traits::target_id(input);
    fragment->importance = Traits::importance(input);
    fragment->overridable = Traits::overridable(input);
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RawAllocatorDumpEdge_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RawAllocatorDumpEdgeDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RawAllocatorDumpEntryDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::RawAllocatorDumpEntryDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::RawAllocatorDumpEntry_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in RawAllocatorDumpEntry struct");
    decltype(Traits::units(input)) in_units = Traits::units(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->units)::BaseType> units_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_units, units_fragment);
    fragment->units.Set(
        units_fragment.is_null() ? nullptr : units_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->units.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null units in RawAllocatorDumpEntry struct");
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<decltype(fragment->value)>
        value_fragment(fragment.message());
    value_fragment.Claim(&fragment->value);
    mojo::internal::Serialize<::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView>(
        in_value, value_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null value in RawAllocatorDumpEntry struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RawAllocatorDumpEntry_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RawAllocatorDumpEntryDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RawAllocatorDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::RawAllocatorDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::RawAllocatorDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->id = Traits::id(input);
    decltype(Traits::absolute_name(input)) in_absolute_name = Traits::absolute_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->absolute_name)::BaseType> absolute_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_absolute_name, absolute_name_fragment);
    fragment->absolute_name.Set(
        absolute_name_fragment.is_null() ? nullptr : absolute_name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->absolute_name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null absolute_name in RawAllocatorDump struct");
    fragment->weak = Traits::weak(input);
    mojo::internal::Serialize<::memory_instrumentation::mojom::LevelOfDetail>(
        Traits::level_of_detail(input), &fragment->level_of_detail);
    decltype(Traits::entries(input)) in_entries = Traits::entries(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->entries)::BaseType>
        entries_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams entries_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::memory_instrumentation::mojom::RawAllocatorDumpEntryDataView>>(
        in_entries, entries_fragment, &entries_validate_params);
    fragment->entries.Set(
        entries_fragment.is_null() ? nullptr : entries_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->entries.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null entries in RawAllocatorDump struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RawAllocatorDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RawAllocatorDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RawProcessMemoryDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::RawProcessMemoryDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::RawProcessMemoryDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::memory_instrumentation::mojom::LevelOfDetail>(
        Traits::level_of_detail(input), &fragment->level_of_detail);
    decltype(Traits::allocator_dump_edges(input)) in_allocator_dump_edges = Traits::allocator_dump_edges(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->allocator_dump_edges)::BaseType>
        allocator_dump_edges_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams allocator_dump_edges_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::memory_instrumentation::mojom::RawAllocatorDumpEdgeDataView>>(
        in_allocator_dump_edges, allocator_dump_edges_fragment, &allocator_dump_edges_validate_params);
    fragment->allocator_dump_edges.Set(
        allocator_dump_edges_fragment.is_null() ? nullptr : allocator_dump_edges_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->allocator_dump_edges.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null allocator_dump_edges in RawProcessMemoryDump struct");
    decltype(Traits::allocator_dumps(input)) in_allocator_dumps = Traits::allocator_dumps(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->allocator_dumps)::BaseType>
        allocator_dumps_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams allocator_dumps_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::memory_instrumentation::mojom::RawAllocatorDumpDataView>>(
        in_allocator_dumps, allocator_dumps_fragment, &allocator_dumps_validate_params);
    fragment->allocator_dumps.Set(
        allocator_dumps_fragment.is_null() ? nullptr : allocator_dumps_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->allocator_dumps.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null allocator_dumps in RawProcessMemoryDump struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RawProcessMemoryDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RawProcessMemoryDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::VmRegionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::VmRegionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::VmRegion_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->start_address = Traits::start_address(input);
    fragment->size_in_bytes = Traits::size_in_bytes(input);
    fragment->module_timestamp = Traits::module_timestamp(input);
    decltype(Traits::module_debugid(input)) in_module_debugid = Traits::module_debugid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->module_debugid)::BaseType> module_debugid_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_module_debugid, module_debugid_fragment);
    fragment->module_debugid.Set(
        module_debugid_fragment.is_null() ? nullptr : module_debugid_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->module_debugid.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null module_debugid in VmRegion struct");
    decltype(Traits::module_debug_path(input)) in_module_debug_path = Traits::module_debug_path(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->module_debug_path)::BaseType> module_debug_path_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_module_debug_path, module_debug_path_fragment);
    fragment->module_debug_path.Set(
        module_debug_path_fragment.is_null() ? nullptr : module_debug_path_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->module_debug_path.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null module_debug_path in VmRegion struct");
    fragment->protection_flags = Traits::protection_flags(input);
    decltype(Traits::mapped_file(input)) in_mapped_file = Traits::mapped_file(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mapped_file)::BaseType> mapped_file_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_mapped_file, mapped_file_fragment);
    fragment->mapped_file.Set(
        mapped_file_fragment.is_null() ? nullptr : mapped_file_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mapped_file.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mapped_file in VmRegion struct");
    fragment->byte_stats_private_dirty_resident = Traits::byte_stats_private_dirty_resident(input);
    fragment->byte_stats_private_clean_resident = Traits::byte_stats_private_clean_resident(input);
    fragment->byte_stats_shared_dirty_resident = Traits::byte_stats_shared_dirty_resident(input);
    fragment->byte_stats_shared_clean_resident = Traits::byte_stats_shared_clean_resident(input);
    fragment->byte_stats_swapped = Traits::byte_stats_swapped(input);
    fragment->byte_locked = Traits::byte_locked(input);
    fragment->byte_stats_proportional_resident = Traits::byte_stats_proportional_resident(input);
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::VmRegion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::VmRegionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::PlatformPrivateFootprintDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::PlatformPrivateFootprintDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::PlatformPrivateFootprint_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->phys_footprint_bytes = Traits::phys_footprint_bytes(input);
    fragment->internal_bytes = Traits::internal_bytes(input);
    fragment->compressed_bytes = Traits::compressed_bytes(input);
    fragment->rss_anon_bytes = Traits::rss_anon_bytes(input);
    fragment->vm_swap_bytes = Traits::vm_swap_bytes(input);
    fragment->private_bytes = Traits::private_bytes(input);
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::PlatformPrivateFootprint_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::PlatformPrivateFootprintDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RawOSMemDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::RawOSMemDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::RawOSMemDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->resident_set_kb = Traits::resident_set_kb(input);
    fragment->peak_resident_set_kb = Traits::peak_resident_set_kb(input);
    fragment->is_peak_rss_resettable = Traits::is_peak_rss_resettable(input);
    decltype(Traits::platform_private_footprint(input)) in_platform_private_footprint = Traits::platform_private_footprint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->platform_private_footprint)::BaseType> platform_private_footprint_fragment(
            fragment.message());
    mojo::internal::Serialize<::memory_instrumentation::mojom::PlatformPrivateFootprintDataView>(
        in_platform_private_footprint, platform_private_footprint_fragment);
    fragment->platform_private_footprint.Set(
        platform_private_footprint_fragment.is_null() ? nullptr : platform_private_footprint_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->platform_private_footprint.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null platform_private_footprint in RawOSMemDump struct");
    decltype(Traits::memory_maps(input)) in_memory_maps = Traits::memory_maps(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->memory_maps)::BaseType>
        memory_maps_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams memory_maps_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::memory_instrumentation::mojom::VmRegionDataView>>(
        in_memory_maps, memory_maps_fragment, &memory_maps_validate_params);
    fragment->memory_maps.Set(
        memory_maps_fragment.is_null() ? nullptr : memory_maps_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->memory_maps.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null memory_maps in RawOSMemDump struct");
    decltype(Traits::native_library_pages_bitmap(input)) in_native_library_pages_bitmap = Traits::native_library_pages_bitmap(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->native_library_pages_bitmap)::BaseType>
        native_library_pages_bitmap_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams native_library_pages_bitmap_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_native_library_pages_bitmap, native_library_pages_bitmap_fragment, &native_library_pages_bitmap_validate_params);
    fragment->native_library_pages_bitmap.Set(
        native_library_pages_bitmap_fragment.is_null() ? nullptr : native_library_pages_bitmap_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->native_library_pages_bitmap.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null native_library_pages_bitmap in RawOSMemDump struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RawOSMemDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RawOSMemDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::OSMemDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::OSMemDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::OSMemDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->resident_set_kb = Traits::resident_set_kb(input);
    fragment->peak_resident_set_kb = Traits::peak_resident_set_kb(input);
    fragment->is_peak_rss_resettable = Traits::is_peak_rss_resettable(input);
    fragment->private_footprint_kb = Traits::private_footprint_kb(input);
    fragment->shared_footprint_kb = Traits::shared_footprint_kb(input);
    fragment->private_footprint_swap_kb = Traits::private_footprint_swap_kb(input);
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::OSMemDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::OSMemDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::AllocatorMemDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::AllocatorMemDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::AllocatorMemDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::numeric_entries(input)) in_numeric_entries = Traits::numeric_entries(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->numeric_entries)::BaseType>
        numeric_entries_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams numeric_entries_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, uint64_t>>(
        in_numeric_entries, numeric_entries_fragment, &numeric_entries_validate_params);
    fragment->numeric_entries.Set(
        numeric_entries_fragment.is_null() ? nullptr : numeric_entries_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->numeric_entries.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null numeric_entries in AllocatorMemDump struct");
    decltype(Traits::children(input)) in_children = Traits::children(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->children)::BaseType>
        children_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams children_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::memory_instrumentation::mojom::AllocatorMemDumpDataView>>(
        in_children, children_fragment, &children_validate_params);
    fragment->children.Set(
        children_fragment.is_null() ? nullptr : children_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->children.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null children in AllocatorMemDump struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::AllocatorMemDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::AllocatorMemDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::ProcessMemoryDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::ProcessMemoryDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::ProcessMemoryDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::memory_instrumentation::mojom::ProcessType>(
        Traits::process_type(input), &fragment->process_type);
    decltype(Traits::os_dump(input)) in_os_dump = Traits::os_dump(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->os_dump)::BaseType> os_dump_fragment(
            fragment.message());
    mojo::internal::Serialize<::memory_instrumentation::mojom::OSMemDumpDataView>(
        in_os_dump, os_dump_fragment);
    fragment->os_dump.Set(
        os_dump_fragment.is_null() ? nullptr : os_dump_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->os_dump.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null os_dump in ProcessMemoryDump struct");
    decltype(Traits::chrome_allocator_dumps(input)) in_chrome_allocator_dumps = Traits::chrome_allocator_dumps(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->chrome_allocator_dumps)::BaseType>
        chrome_allocator_dumps_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams chrome_allocator_dumps_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::memory_instrumentation::mojom::AllocatorMemDumpDataView>>(
        in_chrome_allocator_dumps, chrome_allocator_dumps_fragment, &chrome_allocator_dumps_validate_params);
    fragment->chrome_allocator_dumps.Set(
        chrome_allocator_dumps_fragment.is_null() ? nullptr : chrome_allocator_dumps_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->chrome_allocator_dumps.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null chrome_allocator_dumps in ProcessMemoryDump struct");
    decltype(Traits::pid(input)) in_pid = Traits::pid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pid)::BaseType> pid_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::ProcessIdDataView>(
        in_pid, pid_fragment);
    fragment->pid.Set(
        pid_fragment.is_null() ? nullptr : pid_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->pid.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null pid in ProcessMemoryDump struct");
    decltype(Traits::service_name(input)) in_service_name = Traits::service_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->service_name)::BaseType> service_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_service_name, service_name_fragment);
    fragment->service_name.Set(
        service_name_fragment.is_null() ? nullptr : service_name_fragment.data());
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::ProcessMemoryDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::ProcessMemoryDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::AggregatedMetricsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::AggregatedMetricsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::AggregatedMetrics_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->native_library_resident_kb = Traits::native_library_resident_kb(input);
    fragment->native_library_resident_not_ordered_kb = Traits::native_library_resident_not_ordered_kb(input);
    fragment->native_library_not_resident_ordered_kb = Traits::native_library_not_resident_ordered_kb(input);
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::AggregatedMetrics_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::AggregatedMetricsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::GlobalMemoryDumpDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::GlobalMemoryDumpDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::GlobalMemoryDump_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::start_time(input)) in_start_time = Traits::start_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->start_time)::BaseType> start_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_start_time, start_time_fragment);
    fragment->start_time.Set(
        start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->start_time.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null start_time in GlobalMemoryDump struct");
    decltype(Traits::process_dumps(input)) in_process_dumps = Traits::process_dumps(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->process_dumps)::BaseType>
        process_dumps_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams process_dumps_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::memory_instrumentation::mojom::ProcessMemoryDumpDataView>>(
        in_process_dumps, process_dumps_fragment, &process_dumps_validate_params);
    fragment->process_dumps.Set(
        process_dumps_fragment.is_null() ? nullptr : process_dumps_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->process_dumps.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null process_dumps in GlobalMemoryDump struct");
    decltype(Traits::aggregated_metrics(input)) in_aggregated_metrics = Traits::aggregated_metrics(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregated_metrics)::BaseType> aggregated_metrics_fragment(
            fragment.message());
    mojo::internal::Serialize<::memory_instrumentation::mojom::AggregatedMetricsDataView>(
        in_aggregated_metrics, aggregated_metrics_fragment);
    fragment->aggregated_metrics.Set(
        aggregated_metrics_fragment.is_null() ? nullptr : aggregated_metrics_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregated_metrics.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregated_metrics in GlobalMemoryDump struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::GlobalMemoryDump_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::GlobalMemoryDumpDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::HeapProfileResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::memory_instrumentation::mojom::HeapProfileResultDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::memory_instrumentation::mojom::internal::HeapProfileResult_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::pid(input)) in_pid = Traits::pid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pid)::BaseType> pid_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::ProcessIdDataView>(
        in_pid, pid_fragment);
    fragment->pid.Set(
        pid_fragment.is_null() ? nullptr : pid_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->pid.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null pid in HeapProfileResult struct");
    decltype(Traits::json(input)) in_json = Traits::json(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->json)::BaseType> json_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigStringDataView>(
        in_json, json_fragment);
    fragment->json.Set(
        json_fragment.is_null() ? nullptr : json_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->json.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null json in HeapProfileResult struct");
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::HeapProfileResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::HeapProfileResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::memory_instrumentation::mojom::internal::RawAllocatorDumpEntryValue_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView::Tag::kValueUint64: {
        decltype(Traits::value_uint64(input))
            in_value_uint64 = Traits::value_uint64(input);
        fragment->data.f_value_uint64 = in_value_uint64;
        break;
      }
      case ::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView::Tag::kValueString: {
        decltype(Traits::value_string(input))
            in_value_string = Traits::value_string(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_value_string)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(
            in_value_string, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null value_string in RawAllocatorDumpEntryValue union");
        fragment->data.f_value_string.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::memory_instrumentation::mojom::internal::RawAllocatorDumpEntryValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::memory_instrumentation::mojom::RawAllocatorDumpEntryValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace memory_instrumentation {
namespace mojom {





inline void RawAllocatorDumpEntryDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void RawAllocatorDumpEntryDataView::GetUnitsDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->units.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void RawAllocatorDumpEntryDataView::GetValueDataView(
    RawAllocatorDumpEntryValueDataView* output) {
  auto pointer = &data_->value;
  *output = RawAllocatorDumpEntryValueDataView(pointer, message_);
}


inline void RawAllocatorDumpDataView::GetAbsoluteNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->absolute_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void RawAllocatorDumpDataView::GetEntriesDataView(
    mojo::ArrayDataView<RawAllocatorDumpEntryDataView>* output) {
  auto pointer = data_->entries.Get();
  *output = mojo::ArrayDataView<RawAllocatorDumpEntryDataView>(pointer, message_);
}


inline void RawProcessMemoryDumpDataView::GetAllocatorDumpEdgesDataView(
    mojo::ArrayDataView<RawAllocatorDumpEdgeDataView>* output) {
  auto pointer = data_->allocator_dump_edges.Get();
  *output = mojo::ArrayDataView<RawAllocatorDumpEdgeDataView>(pointer, message_);
}
inline void RawProcessMemoryDumpDataView::GetAllocatorDumpsDataView(
    mojo::ArrayDataView<RawAllocatorDumpDataView>* output) {
  auto pointer = data_->allocator_dumps.Get();
  *output = mojo::ArrayDataView<RawAllocatorDumpDataView>(pointer, message_);
}


inline void VmRegionDataView::GetModuleDebugidDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->module_debugid.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void VmRegionDataView::GetModuleDebugPathDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->module_debug_path.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void VmRegionDataView::GetMappedFileDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->mapped_file.Get();
  *output = mojo::StringDataView(pointer, message_);
}




inline void RawOSMemDumpDataView::GetPlatformPrivateFootprintDataView(
    PlatformPrivateFootprintDataView* output) {
  auto pointer = data_->platform_private_footprint.Get();
  *output = PlatformPrivateFootprintDataView(pointer, message_);
}
inline void RawOSMemDumpDataView::GetMemoryMapsDataView(
    mojo::ArrayDataView<VmRegionDataView>* output) {
  auto pointer = data_->memory_maps.Get();
  *output = mojo::ArrayDataView<VmRegionDataView>(pointer, message_);
}
inline void RawOSMemDumpDataView::GetNativeLibraryPagesBitmapDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->native_library_pages_bitmap.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}




inline void AllocatorMemDumpDataView::GetNumericEntriesDataView(
    mojo::MapDataView<mojo::StringDataView, uint64_t>* output) {
  auto pointer = data_->numeric_entries.Get();
  *output = mojo::MapDataView<mojo::StringDataView, uint64_t>(pointer, message_);
}
inline void AllocatorMemDumpDataView::GetChildrenDataView(
    mojo::MapDataView<mojo::StringDataView, AllocatorMemDumpDataView>* output) {
  auto pointer = data_->children.Get();
  *output = mojo::MapDataView<mojo::StringDataView, AllocatorMemDumpDataView>(pointer, message_);
}


inline void ProcessMemoryDumpDataView::GetOsDumpDataView(
    OSMemDumpDataView* output) {
  auto pointer = data_->os_dump.Get();
  *output = OSMemDumpDataView(pointer, message_);
}
inline void ProcessMemoryDumpDataView::GetChromeAllocatorDumpsDataView(
    mojo::MapDataView<mojo::StringDataView, AllocatorMemDumpDataView>* output) {
  auto pointer = data_->chrome_allocator_dumps.Get();
  *output = mojo::MapDataView<mojo::StringDataView, AllocatorMemDumpDataView>(pointer, message_);
}
inline void ProcessMemoryDumpDataView::GetPidDataView(
    ::mojo_base::mojom::ProcessIdDataView* output) {
  auto pointer = data_->pid.Get();
  *output = ::mojo_base::mojom::ProcessIdDataView(pointer, message_);
}
inline void ProcessMemoryDumpDataView::GetServiceNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->service_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}




inline void GlobalMemoryDumpDataView::GetStartTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->start_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void GlobalMemoryDumpDataView::GetProcessDumpsDataView(
    mojo::ArrayDataView<ProcessMemoryDumpDataView>* output) {
  auto pointer = data_->process_dumps.Get();
  *output = mojo::ArrayDataView<ProcessMemoryDumpDataView>(pointer, message_);
}
inline void GlobalMemoryDumpDataView::GetAggregatedMetricsDataView(
    AggregatedMetricsDataView* output) {
  auto pointer = data_->aggregated_metrics.Get();
  *output = AggregatedMetricsDataView(pointer, message_);
}


inline void HeapProfileResultDataView::GetPidDataView(
    ::mojo_base::mojom::ProcessIdDataView* output) {
  auto pointer = data_->pid.Get();
  *output = ::mojo_base::mojom::ProcessIdDataView(pointer, message_);
}
inline void HeapProfileResultDataView::GetJsonDataView(
    ::mojo_base::mojom::BigStringDataView* output) {
  auto pointer = data_->json.Get();
  *output = ::mojo_base::mojom::BigStringDataView(pointer, message_);
}


inline void RawAllocatorDumpEntryValueDataView::GetValueStringDataView(
    mojo::StringDataView* output) const {
  CHECK(is_value_string());
  *output = mojo::StringDataView(data_->data.f_value_string.Get(), message_);
}


}  // namespace mojom
}  // namespace memory_instrumentation

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) TraceFormatTraits<::memory_instrumentation::mojom::DumpType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::memory_instrumentation::mojom::DumpType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) TraceFormatTraits<::memory_instrumentation::mojom::LevelOfDetail> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::memory_instrumentation::mojom::LevelOfDetail value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) TraceFormatTraits<::memory_instrumentation::mojom::Determinism> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::memory_instrumentation::mojom::Determinism value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) TraceFormatTraits<::memory_instrumentation::mojom::ProcessType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::memory_instrumentation::mojom::ProcessType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_SHARED) TraceFormatTraits<::memory_instrumentation::mojom::MemoryMapOption> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::memory_instrumentation::mojom::MemoryMapOption value);
};

} // namespace perfetto

#endif  // SERVICES_RESOURCE_COORDINATOR_PUBLIC_MOJOM_MEMORY_INSTRUMENTATION_MEMORY_INSTRUMENTATION_MOJOM_SHARED_H_