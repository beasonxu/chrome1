// services/viz/public/mojom/compositing/frame_sink_bundle.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_FRAME_SINK_BUNDLE_MOJOM_BLINK_H_
#define SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_FRAME_SINK_BUNDLE_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/viz/public/mojom/compositing/frame_sink_bundle.mojom-shared.h"
#include "services/viz/public/mojom/compositing/frame_sink_bundle.mojom-blink-forward.h"
#include "gpu/ipc/common/mailbox.mojom-blink.h"
#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
#include "services/viz/public/mojom/compositing/begin_frame_args.mojom-blink.h"
#include "services/viz/public/mojom/compositing/compositor_frame.mojom-blink.h"
#include "services/viz/public/mojom/compositing/compositor_frame_sink.mojom-blink-forward.h"
#include "services/viz/public/mojom/compositing/local_surface_id.mojom-blink.h"
#include "services/viz/public/mojom/compositing/frame_timing_details.mojom-blink.h"
#include "services/viz/public/mojom/compositing/returned_resource.mojom-blink.h"
#include "services/viz/public/mojom/hit_test/hit_test_region_list.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/public/platform/web_common.h"




namespace viz {
namespace mojom {
namespace blink {

class FrameSinkBundleProxy;

template <typename ImplRefTraits>
class FrameSinkBundleStub;

class FrameSinkBundleRequestValidator;


class BLINK_PLATFORM_EXPORT FrameSinkBundle
    : public FrameSinkBundleInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = FrameSinkBundleInterfaceBase;
  using Proxy_ = FrameSinkBundleProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameSinkBundleStub<ImplRefTraits>;

  using RequestValidator_ = FrameSinkBundleRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kInitializeCompositorFrameSinkTypeMinVersion = 0,
    kSetNeedsBeginFrameMinVersion = 0,
    kSubmitMinVersion = 0,
    kDidAllocateSharedBitmapMinVersion = 0,
    kSetThreadIdsMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct InitializeCompositorFrameSinkType_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetNeedsBeginFrame_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct Submit_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct DidAllocateSharedBitmap_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetThreadIds_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~FrameSinkBundle() = default;

  
  virtual void InitializeCompositorFrameSinkType(uint32_t sink_id, ::viz::mojom::blink::CompositorFrameSinkType type) = 0;

  
  virtual void SetNeedsBeginFrame(uint32_t sink_id, bool needs_begin_frame) = 0;

  
  virtual void Submit(WTF::Vector<BundledFrameSubmissionPtr> submissions) = 0;

  
  virtual void DidAllocateSharedBitmap(uint32_t sink_id, ::base::ReadOnlySharedMemoryRegion region, const ::gpu::Mailbox& id) = 0;

  
  virtual void SetThreadIds(uint32_t sink_id, const WTF::Vector<int32_t>& thread_ids) = 0;
};

class FrameSinkBundleClientProxy;

template <typename ImplRefTraits>
class FrameSinkBundleClientStub;

class FrameSinkBundleClientRequestValidator;


class BLINK_PLATFORM_EXPORT FrameSinkBundleClient
    : public FrameSinkBundleClientInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = FrameSinkBundleClientInterfaceBase;
  using Proxy_ = FrameSinkBundleClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = FrameSinkBundleClientStub<ImplRefTraits>;

  using RequestValidator_ = FrameSinkBundleClientRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kFlushNotificationsMinVersion = 0,
    kOnBeginFramePausedChangedMinVersion = 0,
    kOnCompositorFrameTransitionDirectiveProcessedMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct FlushNotifications_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnBeginFramePausedChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnCompositorFrameTransitionDirectiveProcessed_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~FrameSinkBundleClient() = default;

  
  virtual void FlushNotifications(WTF::Vector<BundledReturnedResourcesPtr> acks, WTF::Vector<BeginFrameInfoPtr> begin_frames, WTF::Vector<BundledReturnedResourcesPtr> reclaimed_resources) = 0;

  
  virtual void OnBeginFramePausedChanged(uint32_t sink_id, bool paused) = 0;

  
  virtual void OnCompositorFrameTransitionDirectiveProcessed(uint32_t sink_id, uint32_t sequence_id) = 0;
};



class BLINK_PLATFORM_EXPORT FrameSinkBundleProxy
    : public FrameSinkBundle {
 public:
  using InterfaceType = FrameSinkBundle;

  explicit FrameSinkBundleProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void InitializeCompositorFrameSinkType(uint32_t sink_id, ::viz::mojom::blink::CompositorFrameSinkType type) final;
  
  void SetNeedsBeginFrame(uint32_t sink_id, bool needs_begin_frame) final;
  
  void Submit(WTF::Vector<BundledFrameSubmissionPtr> submissions) final;
  
  void DidAllocateSharedBitmap(uint32_t sink_id, ::base::ReadOnlySharedMemoryRegion region, const ::gpu::Mailbox& id) final;
  
  void SetThreadIds(uint32_t sink_id, const WTF::Vector<int32_t>& thread_ids) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT FrameSinkBundleClientProxy
    : public FrameSinkBundleClient {
 public:
  using InterfaceType = FrameSinkBundleClient;

  explicit FrameSinkBundleClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void FlushNotifications(WTF::Vector<BundledReturnedResourcesPtr> acks, WTF::Vector<BeginFrameInfoPtr> begin_frames, WTF::Vector<BundledReturnedResourcesPtr> reclaimed_resources) final;
  
  void OnBeginFramePausedChanged(uint32_t sink_id, bool paused) final;
  
  void OnCompositorFrameTransitionDirectiveProcessed(uint32_t sink_id, uint32_t sequence_id) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class BLINK_PLATFORM_EXPORT FrameSinkBundleStubDispatch {
 public:
  static bool Accept(FrameSinkBundle* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameSinkBundle* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameSinkBundle>>
class FrameSinkBundleStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameSinkBundleStub() = default;
  ~FrameSinkBundleStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameSinkBundleStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameSinkBundleStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT FrameSinkBundleClientStubDispatch {
 public:
  static bool Accept(FrameSinkBundleClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      FrameSinkBundleClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<FrameSinkBundleClient>>
class FrameSinkBundleClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  FrameSinkBundleClientStub() = default;
  ~FrameSinkBundleClientStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameSinkBundleClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return FrameSinkBundleClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT FrameSinkBundleRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT FrameSinkBundleClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};









class BLINK_PLATFORM_EXPORT BundledFrameSubmissionData {
 public:
  using DataView = BundledFrameSubmissionDataDataView;
  using Data_ = internal::BundledFrameSubmissionData_Data;
  using Tag = Data_::BundledFrameSubmissionData_Tag;

  template <typename... Args>
  static BundledFrameSubmissionDataPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |frame|.
  static BundledFrameSubmissionDataPtr
  NewFrame(
      BundledCompositorFramePtr frame) {
    auto result = BundledFrameSubmissionDataPtr(absl::in_place);
    result->set_frame(std::move(frame));
    return result;
  }
  // Construct an instance holding |did_not_produce_frame|.
  static BundledFrameSubmissionDataPtr
  NewDidNotProduceFrame(
      const ::viz::BeginFrameAck& did_not_produce_frame) {
    auto result = BundledFrameSubmissionDataPtr(absl::in_place);
    result->set_did_not_produce_frame(std::move(did_not_produce_frame));
    return result;
  }
  // Construct an instance holding |did_delete_shared_bitmap|.
  static BundledFrameSubmissionDataPtr
  NewDidDeleteSharedBitmap(
      const ::gpu::Mailbox& did_delete_shared_bitmap) {
    auto result = BundledFrameSubmissionDataPtr(absl::in_place);
    result->set_did_delete_shared_bitmap(std::move(did_delete_shared_bitmap));
    return result;
  }

  template <typename U>
  static BundledFrameSubmissionDataPtr From(const U& u) {
    return mojo::TypeConverter<BundledFrameSubmissionDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundledFrameSubmissionData>::Convert(*this);
  }

  BundledFrameSubmissionData();
  ~BundledFrameSubmissionData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = BundledFrameSubmissionDataPtr>
  BundledFrameSubmissionDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, BundledFrameSubmissionData>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, BundledFrameSubmissionData>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_frame() const { return tag_ == Tag::kFrame; }

  
  BundledCompositorFramePtr& get_frame() const {
    CHECK(tag_ == Tag::kFrame);
    return *(data_.frame);
  }

  
  void set_frame(
      BundledCompositorFramePtr frame);
  
  bool is_did_not_produce_frame() const { return tag_ == Tag::kDidNotProduceFrame; }

  
  ::viz::BeginFrameAck& get_did_not_produce_frame() const {
    CHECK(tag_ == Tag::kDidNotProduceFrame);
    return *(data_.did_not_produce_frame);
  }

  
  void set_did_not_produce_frame(
      const ::viz::BeginFrameAck& did_not_produce_frame);
  
  bool is_did_delete_shared_bitmap() const { return tag_ == Tag::kDidDeleteSharedBitmap; }

  
  ::gpu::Mailbox& get_did_delete_shared_bitmap() const {
    CHECK(tag_ == Tag::kDidDeleteSharedBitmap);
    return *(data_.did_delete_shared_bitmap);
  }

  
  void set_did_delete_shared_bitmap(
      const ::gpu::Mailbox& did_delete_shared_bitmap);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundledFrameSubmissionData::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<BundledFrameSubmissionData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    BundledCompositorFramePtr* frame;
    ::viz::BeginFrameAck* did_not_produce_frame;
    ::gpu::Mailbox* did_delete_shared_bitmap;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class BLINK_PLATFORM_EXPORT BundledFrameSubmission {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundledFrameSubmission, T>::value>;
  using DataView = BundledFrameSubmissionDataView;
  using Data_ = internal::BundledFrameSubmission_Data;

  template <typename... Args>
  static BundledFrameSubmissionPtr New(Args&&... args) {
    return BundledFrameSubmissionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundledFrameSubmissionPtr From(const U& u) {
    return mojo::TypeConverter<BundledFrameSubmissionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundledFrameSubmission>::Convert(*this);
  }


  BundledFrameSubmission();

  BundledFrameSubmission(
      uint32_t sink_id,
      BundledFrameSubmissionDataPtr data);

BundledFrameSubmission(const BundledFrameSubmission&) = delete;
BundledFrameSubmission& operator=(const BundledFrameSubmission&) = delete;

  ~BundledFrameSubmission();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundledFrameSubmissionPtr>
  BundledFrameSubmissionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundledFrameSubmission::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundledFrameSubmission::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundledFrameSubmission::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundledFrameSubmission_UnserializedMessageContext<
            UserType, BundledFrameSubmission::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundledFrameSubmission::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return BundledFrameSubmission::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundledFrameSubmission_UnserializedMessageContext<
            UserType, BundledFrameSubmission::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundledFrameSubmission::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint32_t sink_id;
  
  BundledFrameSubmissionDataPtr data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundledFrameSubmission::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundledFrameSubmission::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundledFrameSubmission::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundledFrameSubmission::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT BundledCompositorFrame {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundledCompositorFrame, T>::value>;
  using DataView = BundledCompositorFrameDataView;
  using Data_ = internal::BundledCompositorFrame_Data;

  template <typename... Args>
  static BundledCompositorFramePtr New(Args&&... args) {
    return BundledCompositorFramePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundledCompositorFramePtr From(const U& u) {
    return mojo::TypeConverter<BundledCompositorFramePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundledCompositorFrame>::Convert(*this);
  }


  BundledCompositorFrame();

  BundledCompositorFrame(
      const ::viz::LocalSurfaceId& local_surface_id,
      ::viz::CompositorFrame frame,
      absl::optional<::viz::HitTestRegionList> hit_test_region_list,
      uint64_t submit_time);

BundledCompositorFrame(const BundledCompositorFrame&) = delete;
BundledCompositorFrame& operator=(const BundledCompositorFrame&) = delete;

  ~BundledCompositorFrame();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundledCompositorFramePtr>
  BundledCompositorFramePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundledCompositorFrame::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundledCompositorFrame::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundledCompositorFrame::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundledCompositorFrame_UnserializedMessageContext<
            UserType, BundledCompositorFrame::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundledCompositorFrame::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return BundledCompositorFrame::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundledCompositorFrame_UnserializedMessageContext<
            UserType, BundledCompositorFrame::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundledCompositorFrame::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::viz::LocalSurfaceId local_surface_id;
  
  ::viz::CompositorFrame frame;
  
  absl::optional<::viz::HitTestRegionList> hit_test_region_list;
  
  uint64_t submit_time;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundledCompositorFrame::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundledCompositorFrame::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundledCompositorFrame::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundledCompositorFrame::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT BundledReturnedResources {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundledReturnedResources, T>::value>;
  using DataView = BundledReturnedResourcesDataView;
  using Data_ = internal::BundledReturnedResources_Data;

  template <typename... Args>
  static BundledReturnedResourcesPtr New(Args&&... args) {
    return BundledReturnedResourcesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundledReturnedResourcesPtr From(const U& u) {
    return mojo::TypeConverter<BundledReturnedResourcesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundledReturnedResources>::Convert(*this);
  }


  BundledReturnedResources();

  BundledReturnedResources(
      uint32_t sink_id,
      WTF::Vector<::viz::ReturnedResource> resources);

BundledReturnedResources(const BundledReturnedResources&) = delete;
BundledReturnedResources& operator=(const BundledReturnedResources&) = delete;

  ~BundledReturnedResources();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundledReturnedResourcesPtr>
  BundledReturnedResourcesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundledReturnedResources::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundledReturnedResources::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundledReturnedResources::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundledReturnedResources_UnserializedMessageContext<
            UserType, BundledReturnedResources::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundledReturnedResources::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return BundledReturnedResources::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundledReturnedResources_UnserializedMessageContext<
            UserType, BundledReturnedResources::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundledReturnedResources::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint32_t sink_id;
  
  WTF::Vector<::viz::ReturnedResource> resources;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundledReturnedResources::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundledReturnedResources::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundledReturnedResources::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundledReturnedResources::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT BeginFrameInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BeginFrameInfo, T>::value>;
  using DataView = BeginFrameInfoDataView;
  using Data_ = internal::BeginFrameInfo_Data;

  template <typename... Args>
  static BeginFrameInfoPtr New(Args&&... args) {
    return BeginFrameInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BeginFrameInfoPtr From(const U& u) {
    return mojo::TypeConverter<BeginFrameInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BeginFrameInfo>::Convert(*this);
  }


  BeginFrameInfo();

  BeginFrameInfo(
      uint32_t sink_id,
      const ::viz::BeginFrameArgs& args,
      const WTF::HashMap<uint32_t, ::viz::FrameTimingDetails>& details);


  ~BeginFrameInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BeginFrameInfoPtr>
  BeginFrameInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BeginFrameInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BeginFrameInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BeginFrameInfo::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BeginFrameInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BeginFrameInfo_UnserializedMessageContext<
            UserType, BeginFrameInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BeginFrameInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return BeginFrameInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BeginFrameInfo_UnserializedMessageContext<
            UserType, BeginFrameInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BeginFrameInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint32_t sink_id;
  
  ::viz::BeginFrameArgs args;
  
  WTF::HashMap<uint32_t, ::viz::FrameTimingDetails> details;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BeginFrameInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BeginFrameInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BeginFrameInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BeginFrameInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
BundledFrameSubmissionDataPtr BundledFrameSubmissionData::Clone() const {
  switch (tag_) {
    case Tag::kFrame:
      return NewFrame(
          mojo::Clone(*data_.frame));
    case Tag::kDidNotProduceFrame:
      return NewDidNotProduceFrame(
          mojo::Clone(*data_.did_not_produce_frame));
    case Tag::kDidDeleteSharedBitmap:
      return NewDidDeleteSharedBitmap(
          mojo::Clone(*data_.did_delete_shared_bitmap));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, BundledFrameSubmissionData>::value>::type*>
bool BundledFrameSubmissionData::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kFrame:
      return mojo::Equals(*(data_.frame), *(other.data_.frame));
    case Tag::kDidNotProduceFrame:
      return mojo::Equals(*(data_.did_not_produce_frame), *(other.data_.did_not_produce_frame));
    case Tag::kDidDeleteSharedBitmap:
      return mojo::Equals(*(data_.did_delete_shared_bitmap), *(other.data_.did_delete_shared_bitmap));
  }

  return false;
}
template <typename StructPtrType>
BundledFrameSubmissionPtr BundledFrameSubmission::Clone() const {
  return New(
      mojo::Clone(sink_id),
      mojo::Clone(data)
  );
}

template <typename T, BundledFrameSubmission::EnableIfSame<T>*>
bool BundledFrameSubmission::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sink_id, other_struct.sink_id))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  return true;
}

template <typename T, BundledFrameSubmission::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sink_id < rhs.sink_id)
    return true;
  if (rhs.sink_id < lhs.sink_id)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  return false;
}
template <typename StructPtrType>
BundledCompositorFramePtr BundledCompositorFrame::Clone() const {
  return New(
      mojo::Clone(local_surface_id),
      mojo::Clone(frame),
      mojo::Clone(hit_test_region_list),
      mojo::Clone(submit_time)
  );
}

template <typename T, BundledCompositorFrame::EnableIfSame<T>*>
bool BundledCompositorFrame::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->local_surface_id, other_struct.local_surface_id))
    return false;
  if (!mojo::Equals(this->frame, other_struct.frame))
    return false;
  if (!mojo::Equals(this->hit_test_region_list, other_struct.hit_test_region_list))
    return false;
  if (!mojo::Equals(this->submit_time, other_struct.submit_time))
    return false;
  return true;
}

template <typename T, BundledCompositorFrame::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.local_surface_id < rhs.local_surface_id)
    return true;
  if (rhs.local_surface_id < lhs.local_surface_id)
    return false;
  if (lhs.frame < rhs.frame)
    return true;
  if (rhs.frame < lhs.frame)
    return false;
  if (lhs.hit_test_region_list < rhs.hit_test_region_list)
    return true;
  if (rhs.hit_test_region_list < lhs.hit_test_region_list)
    return false;
  if (lhs.submit_time < rhs.submit_time)
    return true;
  if (rhs.submit_time < lhs.submit_time)
    return false;
  return false;
}
template <typename StructPtrType>
BundledReturnedResourcesPtr BundledReturnedResources::Clone() const {
  return New(
      mojo::Clone(sink_id),
      mojo::Clone(resources)
  );
}

template <typename T, BundledReturnedResources::EnableIfSame<T>*>
bool BundledReturnedResources::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sink_id, other_struct.sink_id))
    return false;
  if (!mojo::Equals(this->resources, other_struct.resources))
    return false;
  return true;
}

template <typename T, BundledReturnedResources::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sink_id < rhs.sink_id)
    return true;
  if (rhs.sink_id < lhs.sink_id)
    return false;
  if (lhs.resources < rhs.resources)
    return true;
  if (rhs.resources < lhs.resources)
    return false;
  return false;
}
template <typename StructPtrType>
BeginFrameInfoPtr BeginFrameInfo::Clone() const {
  return New(
      mojo::Clone(sink_id),
      mojo::Clone(args),
      mojo::Clone(details)
  );
}

template <typename T, BeginFrameInfo::EnableIfSame<T>*>
bool BeginFrameInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sink_id, other_struct.sink_id))
    return false;
  if (!mojo::Equals(this->args, other_struct.args))
    return false;
  if (!mojo::Equals(this->details, other_struct.details))
    return false;
  return true;
}

template <typename T, BeginFrameInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sink_id < rhs.sink_id)
    return true;
  if (rhs.sink_id < lhs.sink_id)
    return false;
  if (lhs.args < rhs.args)
    return true;
  if (rhs.args < lhs.args)
    return false;
  if (lhs.details < rhs.details)
    return true;
  if (rhs.details < lhs.details)
    return false;
  return false;
}


}  // namespace blink
}  // namespace mojom
}  // namespace viz

namespace mojo {


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::viz::mojom::blink::BundledFrameSubmission::DataView,
                                         ::viz::mojom::blink::BundledFrameSubmissionPtr> {
  static bool IsNull(const ::viz::mojom::blink::BundledFrameSubmissionPtr& input) { return !input; }
  static void SetToNull(::viz::mojom::blink::BundledFrameSubmissionPtr* output) { output->reset(); }

  static decltype(::viz::mojom::blink::BundledFrameSubmission::sink_id) sink_id(
      const ::viz::mojom::blink::BundledFrameSubmissionPtr& input) {
    return input->sink_id;
  }

  static  decltype(::viz::mojom::blink::BundledFrameSubmission::data)& data(
       ::viz::mojom::blink::BundledFrameSubmissionPtr& input) {
    return input->data;
  }

  static bool Read(::viz::mojom::blink::BundledFrameSubmission::DataView input, ::viz::mojom::blink::BundledFrameSubmissionPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::viz::mojom::blink::BundledCompositorFrame::DataView,
                                         ::viz::mojom::blink::BundledCompositorFramePtr> {
  static bool IsNull(const ::viz::mojom::blink::BundledCompositorFramePtr& input) { return !input; }
  static void SetToNull(::viz::mojom::blink::BundledCompositorFramePtr* output) { output->reset(); }

  static const decltype(::viz::mojom::blink::BundledCompositorFrame::local_surface_id)& local_surface_id(
      const ::viz::mojom::blink::BundledCompositorFramePtr& input) {
    return input->local_surface_id;
  }

  static  decltype(::viz::mojom::blink::BundledCompositorFrame::frame)& frame(
       ::viz::mojom::blink::BundledCompositorFramePtr& input) {
    return input->frame;
  }

  static const decltype(::viz::mojom::blink::BundledCompositorFrame::hit_test_region_list)& hit_test_region_list(
      const ::viz::mojom::blink::BundledCompositorFramePtr& input) {
    return input->hit_test_region_list;
  }

  static decltype(::viz::mojom::blink::BundledCompositorFrame::submit_time) submit_time(
      const ::viz::mojom::blink::BundledCompositorFramePtr& input) {
    return input->submit_time;
  }

  static bool Read(::viz::mojom::blink::BundledCompositorFrame::DataView input, ::viz::mojom::blink::BundledCompositorFramePtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::viz::mojom::blink::BundledReturnedResources::DataView,
                                         ::viz::mojom::blink::BundledReturnedResourcesPtr> {
  static bool IsNull(const ::viz::mojom::blink::BundledReturnedResourcesPtr& input) { return !input; }
  static void SetToNull(::viz::mojom::blink::BundledReturnedResourcesPtr* output) { output->reset(); }

  static decltype(::viz::mojom::blink::BundledReturnedResources::sink_id) sink_id(
      const ::viz::mojom::blink::BundledReturnedResourcesPtr& input) {
    return input->sink_id;
  }

  static  decltype(::viz::mojom::blink::BundledReturnedResources::resources)& resources(
       ::viz::mojom::blink::BundledReturnedResourcesPtr& input) {
    return input->resources;
  }

  static bool Read(::viz::mojom::blink::BundledReturnedResources::DataView input, ::viz::mojom::blink::BundledReturnedResourcesPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::viz::mojom::blink::BeginFrameInfo::DataView,
                                         ::viz::mojom::blink::BeginFrameInfoPtr> {
  static bool IsNull(const ::viz::mojom::blink::BeginFrameInfoPtr& input) { return !input; }
  static void SetToNull(::viz::mojom::blink::BeginFrameInfoPtr* output) { output->reset(); }

  static decltype(::viz::mojom::blink::BeginFrameInfo::sink_id) sink_id(
      const ::viz::mojom::blink::BeginFrameInfoPtr& input) {
    return input->sink_id;
  }

  static const decltype(::viz::mojom::blink::BeginFrameInfo::args)& args(
      const ::viz::mojom::blink::BeginFrameInfoPtr& input) {
    return input->args;
  }

  static const decltype(::viz::mojom::blink::BeginFrameInfo::details)& details(
      const ::viz::mojom::blink::BeginFrameInfoPtr& input) {
    return input->details;
  }

  static bool Read(::viz::mojom::blink::BeginFrameInfo::DataView input, ::viz::mojom::blink::BeginFrameInfoPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT UnionTraits<::viz::mojom::blink::BundledFrameSubmissionData::DataView,
                                        ::viz::mojom::blink::BundledFrameSubmissionDataPtr> {
  static bool IsNull(const ::viz::mojom::blink::BundledFrameSubmissionDataPtr& input) { return !input; }
  static void SetToNull(::viz::mojom::blink::BundledFrameSubmissionDataPtr* output) { output->reset(); }

  static ::viz::mojom::blink::BundledFrameSubmissionData::Tag GetTag(const ::viz::mojom::blink::BundledFrameSubmissionDataPtr& input) {
    return input->which();
  }

  static  ::viz::mojom::blink::BundledCompositorFramePtr& frame( ::viz::mojom::blink::BundledFrameSubmissionDataPtr& input) {
    return input->get_frame();
  }

  static const ::viz::BeginFrameAck& did_not_produce_frame(const ::viz::mojom::blink::BundledFrameSubmissionDataPtr& input) {
    return input->get_did_not_produce_frame();
  }

  static const ::gpu::Mailbox& did_delete_shared_bitmap(const ::viz::mojom::blink::BundledFrameSubmissionDataPtr& input) {
    return input->get_did_delete_shared_bitmap();
  }

  static bool Read(::viz::mojom::blink::BundledFrameSubmissionData::DataView input, ::viz::mojom::blink::BundledFrameSubmissionDataPtr* output);
};

}  // namespace mojo

#endif  // SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_FRAME_SINK_BUNDLE_MOJOM_BLINK_H_